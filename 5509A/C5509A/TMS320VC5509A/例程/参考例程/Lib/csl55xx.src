!<arch>
<filenames>/    0           1     0     0       192       `

_csl_usb_apimap.h/
csl_gpio5502dat.h/
csl_gpio5502hal.h/
csl_gpio5509adat.h/
csl_gpio5509ahal.h/
csl_gpio5509dat.h/
csl_gpio5509hal.h/
csl_gpio5510dat.h/
csl_gpio5510hal.h/
csl_usb_apimap.h/
_csl_init.c/    1051539355  0     0     0       2941      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... CSL
* FILENAME...... _csl_init.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library (CSL)
* COMPONENT..... service layer
* IMPORTS....... csl.h, csl_timer.h
*------------------------------------------------------------------------------
* HISTORY:
*   MODIFIED:      02/21/2000 C54x Romability 
*   MODIFIED:      06/19/2000 modified for DSPBIOS integration 
*   MODIFIED:      07/13/2000 modifed for TMS3205510
*   LAST MODIFIED: 04/16/2001 updated GIO to GPIO references 
*   MODIFIED:      10 April 2003 updated for .csldata size fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the CSL module)
*
*
*
\******************************************************************************/

#define _CSL_MOD_

#include <csl_std.h>  
#include <csl_csldat.h>


/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* CSL static macro declarations
\****************************************/

/****************************************\
* CSL static typedef declarations
\****************************************/

/****************************************\
* CSL static function declarations
\****************************************/

/****************************************\
* CSL static variable definitions
\****************************************/

/****************************************\
* CSL static function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* CSL global variable definitions
\****************************************/

/****************************************\
* CSL global function definitions
\****************************************/

#pragma CODE_SECTION(_CSL_init,".text:_CSL_init")

/*----------------------------------------------------------------------------*/
void _CSL_init(Uint16 osPresent) {

   (CSL_SYS_DATA).OsPresent |= osPresent;


}

adc_cfg.c/      1049976806  0     0     0       1509      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... ADC
* FILENAME...... adc_cfg.c
* DATE CREATED.. Fri Jun 29 15:39:48 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Fri Jun 29 15:39:48 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the ADC module 
*
\*************************************************************************/
#define _ADC_MOD_

#include <csl_chiphal.h>

#if (_ADC_SUPPORT)

#include <csl_adc.h> 


#pragma CODE_SECTION(ADC_config,".text:ADC_config")

void ADC_config(ADC_Config *Config) {

int old_intm;

  old_intm = IRQ_globalDisable();  
  ADC_RSET(ADCCTL,Config->adcctl);
  ADC_RSET(ADCCLKDIV,Config->adcclkdiv);
  ADC_RSET(ADCCLKCTL,Config->adcclkctl);
  IRQ_globalRestore(old_intm);   


}

#endif   /* ADC_SUPPORT */
/******************************************************************************\
*     
*      End of adc_cfg.c
*
\******************************************************************************/

adc_cfga.c/     1049976807  0     0     0       1533      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... ADC
* FILENAME...... adc_cfga.c
* DATE CREATED.. Fri Jun 29 15:39:48 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Fri Jun 29 15:39:48 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the ADC module 
*
\*************************************************************************/
#define _ADC_MOD_

#include <csl_chiphal.h>

#if (_ADC_SUPPORT) 

#include <csl_adc.h>

#pragma CODE_SECTION(ADC_configArgs,".text:ADC_configArgs")

void ADC_configArgs(Uint16 adcctl,Uint16 adcclkdiv,Uint16 adcclkctl) {

int old_intm;

  old_intm = IRQ_globalDisable();  
  ADC_RSET(ADCCTL,adcctl);
  ADC_RSET(ADCCLKDIV,adcclkdiv);	
  ADC_RSET(ADCCLKCTL,adcclkctl);
  IRQ_globalRestore(old_intm);   



}


#endif  /* _ADC_SUPPORT  */
/******************************************************************************\
*     
*      End of adc_cfga.c 
*
\******************************************************************************/

adc_gcfg.c/     1049976808  0     0     0       1532      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... ADC
* FILENAME...... adc_gcfg.c
* DATE CREATED.. Fri Jun 29 15:39:48 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Fri Jun 29 15:39:48 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the ADC module 
*
\*************************************************************************/

#define _ADC_MOD_


#include <csl_chiphal.h>	 

#if (_ADC_SUPPORT) 

#include <csl_adc.h>

#pragma CODE_SECTION(ADC_getConfig,".text:ADC_getConfig")

void ADC_getConfig(ADC_Config *Config) {

  int old_intm;

  old_intm = IRQ_globalDisable();
  Config->adcctl = ADC_RGET(ADCCTL);
  Config->adcclkdiv = ADC_RGET(ADCCLKDIV);
  Config->adcclkctl = ADC_RGET(ADCCLKCTL);
  IRQ_globalRestore(old_intm);   


}

#endif  /* _ADC_SUPPORT  */
/******************************************************************************\
*     
*      End of adc_gcfg.c 
*
\******************************************************************************/
adc_read.c/     1049976810  0     0     0       1469      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ADC
* FILENAME...... adc_read.c
* DATE CREATED.. Thu 08/02/2001
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (Read data from Analog -to- Digital Converter)
*
*
*
\******************************************************************************/
#define _ADC_MOD_

#include <csl_adc.h>

#if (_ADC_SUPPORT)

#pragma CODE_SECTION(ADC_read,".text:ADC_read")

void ADC_read(int channelnumber,Uint16 *data,int length) {

  int old_intm,i;
  
  old_intm = IRQ_globalDisable();
  ADC_FSET(ADCCTL,CHSELECT,channelnumber);  /* set channel number */
  
  for (i=0;i<length;i++) {
  
  ADC_FSET(ADCCTL,ADCSTART,1);   /* start conversion */
  while (ADC_FGET(ADCDATA,ADCBUSY)) {  /* loop until not busy */
    asm(" NOP");
  }
  
  *data++ = (ADC_FGET(ADCDATA,ADCDATA)&0x0FFE);  /* mask LSB (due to noise) */
  
  }  /* end of main loop */
  
  IRQ_globalRestore(old_intm);
  
  
}
#endif //_ADC_SUPPORT

adc_setfreq.c/  1049976811  0     0     0       1257      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ADC
* FILENAME...... adc_setfreq.c
* DATE CREATED.. Thu 08/02/2001
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (Read data from Analog -to- Digital Converter)
*
*
*
\******************************************************************************/
#define _ADC_MOD_

#include <csl_adc.h>

#if (_ADC_SUPPORT)

#pragma CODE_SECTION(ADC_setFreq,".text:ADC_setFreq")

void ADC_setFreq(int sysclkdiv, int convratediv, int sampletimediv) {

int old_intm;

  old_intm = IRQ_globalDisable();  
  ADC_FSET(ADCCLKCTL,CPUCLKDIV,sysclkdiv);
  ADC_FSET(ADCCLKDIV,CONVRATEDIV,convratediv);
  ADC_FSET(ADCCLKDIV,SAMPTIMEDIV,sampletimediv);
  IRQ_globalRestore(old_intm);   


}

#endif //_ADC_SUPPORT


bct_close.c/    1049976812  0     0     0       3130      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... BCT
* FILENAME...... bct_close.c
* DATE CREATED.. Tues 03/26/2002 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  03/26/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Open function for 5502 Watchdog timer)
*
*
*
\******************************************************************************/
#define _BCT_MOD_

/****************************************\
* include files
\****************************************/    
#include <csl_chiphal.h>
#include <csl_bct.h>
   
 
#if (_BCT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* BCT static macro declarations
\****************************************/
/* See BCT.h Romability */
 
/****************************************\
* BCT static typedef declarations
\****************************************/

/****************************************\
* BCT static function declarations
\****************************************/

/****************************************\
* BCT Variable definitions : ROMability 
\****************************************/

/* Definition Romability See BCT.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* BCT global variable definitions
\****************************************/
/* Definition See csl_bct.h */
/*----------------------------------------------------------------------------*/
             
/****************************************\
* BCT global function definitions
\****************************************/

#pragma CODE_SECTION(BCT_close,".text:BCT_close")

/*----------------------------------------------------------------------------*/
void BCT_close(BCT_Handle h) {
  CSL_SYS_DATA.BctAllocMask = 0x0000u; 
}
/*----------------------------------------------------------------------------*/

#endif /* BCT_SUPPORT */
/******************************************************************************\
* End of bct_close.c
\******************************************************************************/

bct_open.c/     1049976814  0     0     0       3140      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... BCT
* FILENAME...... bct_open.c
* DATE CREATED.. Tues 03/26/2002 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  03/26/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Open function for 5502 Watchdog timer)
*
*
*
\******************************************************************************/
#define _BCT_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_bct.h>
   
 
#if (_BCT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* BCT static macro declarations
\****************************************/
/* See BCT.h Romability */
 
/****************************************\
* BCT static typedef declarations
\****************************************/

/****************************************\
* BCT static function declarations
\****************************************/

/****************************************\
* BCT Variable definitions : ROMability 
\****************************************/

/* Definition Romability See BCT.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* BCT global variable definitions
\****************************************/
/* Definition See csl_bct.h */
/*----------------------------------------------------------------------------*/
             
/****************************************\
* BCT global function definitions
\****************************************/

#pragma CODE_SECTION(BCT_open,".text:BCT_open")

/*----------------------------------------------------------------------------*/
BCT_Handle BCT_open(void) {
  CSL_SYS_DATA.BctAllocMask = 0x0001u;
  return (BCT_Handle)(&(CSL_BCT_DATA)); 
}
/*----------------------------------------------------------------------------*/

#endif /* BCT_SUPPORT */
/******************************************************************************\
* End of bct_open.c
\******************************************************************************/

csl.c/          1049976815  0     0     0       4045      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... CSL
* FILENAME...... _csl_init.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library (CSL)
* COMPONENT..... service layer
* IMPORTS....... csl.h, csl_timer.h
*------------------------------------------------------------------------------
* HISTORY:
*   MODIFIED: 02/21/2000 C54x Romability 
*   MODIFIED: 06/19/2000 modified for DSPBIOS integration 
*   MODIFIED: 07/13/2000 modifed for TMS3205510
*   MODIFIED: 04/16/2001 updated GIO to GPIO references 
*   MODIFIED: 08/15/2002 reinstated CSL_init function in library for
*                        legacy code support
*   MODIFIED: 11/23/2002 re-introduced missing #pragma
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the CSL module)
*
*
*
\******************************************************************************/

#define _CSL_MOD_

#include <csl.h>  

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* CSL static macro declarations
\****************************************/

/****************************************\
* CSL static typedef declarations
\****************************************/

/****************************************\
* CSL static function declarations
\****************************************/

/****************************************\
* CSL static variable definitions
\****************************************/

/****************************************\
* CSL static function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* CSL global variable definitions
\****************************************/

/****************************************\
* CSL global function definitions
\****************************************/

#pragma CODE_SECTION(CSL_init,".text:CSL_init")

/*----------------------------------------------------------------------------*/
void CSL_init(void) {

  #if (CHIP_5510)
    CSL5510_LIB_();
  #elif (CHIP_5510PG1_0)
    CSL5510_PG1_LIB_();
  #elif (CHIP_5510PG1_2)
    CSL5510_PG1_2_LIB_();

  #elif (CHIP_5510PG2_0)
    CSL5510_PG2_0_LIB_();
  #elif (CHIP_5510PG2_1)
    CSL5510_PG2_1_LIB_();
  #elif (CHIP_5510PG2_2)
    CSL5510_PG2_2_LIB_();

  #elif (CHIP_5509)
    CSL5509_LIB_();
  #elif (CHIP_5509A)
    CSL5509A_LIB_();

  #elif (CHIP_5502)
    CSL5502_LIB_();
  #endif


   _CSL_init(0);     // Call _CSL_init with 0 for operating system
                     // flag


  }  

// Define Library Symbl for compatability check
  #if (CHIP_5510)
    void CSL5510_LIB_(){}
  #elif (CHIP_5510PG1_0)
    void CSL5510_PG1_LIB_(){}
  #elif (CHIP_5510PG1_2)
    void CSL5510_PG1_2_LIB_(){}

  #elif (CHIP_5510PG2_0)
    void CSL5510_PG2_0_LIB_(){}
  #elif (CHIP_5510PG2_1)
    void CSL5510_PG2_1_LIB_(){}
  #elif (CHIP_5510PG2_2)
    void CSL5510_PG2_2_LIB_(){}

  #elif (CHIP_5509)
    void CSL5509_LIB_(){}
  #elif (CHIP_5509A)
    void CSL5509A_LIB_(){}

  #elif (CHIP_5502)
    void CSL5502_LIB_(){}
  #endif

csl_bctdat.c/   1051540745  0     0     0       2908      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... BCT
* FILENAME...... csl_bctdat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data file for BCT Module)
*
*
*
\******************************************************************************/
#define _BCT_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_bct.h>
   
 
#if (_BCT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* BCT static macro declarations
\****************************************/
/* See BCT.h Romability */
 
/****************************************\
* BCT static typedef declarations
\****************************************/

/****************************************\
* BCT static function declarations
\****************************************/

/****************************************\
* BCT Variable definitions : ROMability 
\****************************************/

/* Definition Romability See BCT.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* BCT global variable definitions
\****************************************/
/* Definition See csl_bct.h */
/*----------------------------------------------------------------------------*/
             
/****************************************\
* BCT global function definitions
\****************************************/

#pragma DATA_SECTION(CSL_BctData,".csldata:BCT_data")

CSL_BctDataObj  CSL_BctData = CSL_BCTDATAINIT;

#endif /* BCT_SUPPORT */
/******************************************************************************\
* End of bct_open.c
\******************************************************************************/

csl_chipdat.c/  1051540745  0     0     0       1332      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... CSL
* FILENAME...... csl_chipdat.c
* DATE CREATED.. Thu April 10 2003
* PROJECT....... Chip Support Library (CSL)
* COMPONENT..... service layer
* IMPORTS....... csl.h, csl_timer.h
*------------------------------------------------------------------------------
* HISTORY:
*  CREATED: 10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the CSL module)
*
*
*
\******************************************************************************/

#include <csl_std.h>  
#include <csl_chipdat.h>


/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* CSL static variable definitions
\****************************************/



#pragma DATA_SECTION(CSL_ChipData,".csldat:CHIP_data")

CSL_ChipDataObj CSL_ChipData = CSL_CHIPDATAINIT;
csl_csldat.c/   1051539351  0     0     0       1367      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... CSL - chip support library service layer interface
* FILENAME...... csldata.h
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED: 02/04/2000 
*   MODIFIED: 06/19/2000  incorporate cpluplus compatability
*   MODIFIED: 06/28/2001  updatd for new CSL initialization model
*   MODIFIED: 10 April 2003 for .csldata size fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (Global/Static Data Table to Support ROMability of CSL modules)
*
*
*
\******************************************************************************/

#include <csl_csldat.h>



#pragma DATA_SECTION(CSL_SysData,".csldata:SYS_data")

CSL_SysDataObj CSL_SysData = CSL_SYSDATAINIT;

/******************************************************************************\
* End of csl_csldat.c
\******************************************************************************/


csl_dmadat.c/   1051540743  0     0     0       1700      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DMA
* FILENAME...... csl_dmadat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data file for the DMA module)
*
*
*
\******************************************************************************/
#define _DMA_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dma.h>

#if (_DMA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/****************************************\
* DMA global definitions
\****************************************/

#pragma DATA_SECTION(CSL_DmaData,".csldata:DMA_data")

CSL_DmaDataObj CSL_DmaData = CSL_DMADATAINIT;


/*----------------------------------------------------------------------------*/

#endif /* DMA_SUPPORT */
/******************************************************************************\
* End of csl_dmadat.c
\******************************************************************************/

csl_emifdat.c/  1051540743  0     0     0       1308      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... EMIF
* FILENAME...... csl_emifdat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the Cache module)
*
*
*
\******************************************************************************/
#define _EMIF_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_emif.h> 

#if _EMIF_SUPPORT

   #pragma DATA_SECTION(CSL_EmifData,".csldata:EMIF_data")

   CSL_EmifDataObj CSL_EmifData = CSL_EMIFDATAINIT;


#endif /* EMIF_SUPPORT */
/******************************************************************************\
* End of csl_emifdat.c
\******************************************************************************/
csl_errdat.c/   1051540741  0     0     0       1796      `

/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ERR
* FILENAME...... csl_errdat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ERR module)
*
*
*
\******************************************************************************/
#define _ERR_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_err.h> 

#if (_ERR_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/****************************************\
* ERR global variable definitions
\****************************************/


#pragma DATA_SECTION(CSL_ErrData,".csldata:ERR_data")

CSL_ErrDataObj CSL_ErrData = CSL_ERRDATAINIT;




#endif /* ERR_SUPPORT */
/******************************************************************************\
* End of csl_errdat.c
\******************************************************************************/

csl_gpiodat.c/  1051540740  0     0     0       1374      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpiodat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  07/31/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data file for the non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_gpio.h>
#include <csl_gpiodat.h>

#if (_GPIO_SUPPORT)

#pragma DATA_SECTION(CSL_GpioData,".csldata:GPIO_data")

CSL_GpioDataObj   CSL_GpioData = CSL_GPIODATAINIT;


/*----------------------------------------------------------------------------*/
/*------------------------------------------------------*/

#endif /* GPIO_SUPPORT */
/******************************************************************************\
* End of csl_gpiodat.c
\******************************************************************************/
csl_gptdat.c/   1051540740  0     0     0       2610      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... csl_gptdat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 April 2003 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data file for GPT Module)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    
#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See csl_gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma DATA_SECTION(CSL_GptData,".csldata:GPT_data")

CSL_GptDataObj CSL_GptData = CSL_GPTDATAINIT;

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of csl_gptdat.c
\******************************************************************************/

csl_hpidat.c/   1051540737  0     0     0       1222      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... HPI
* FILENAME...... csl_hpidat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data file for HPI module)
*              
\******************************************************************************/
#define _HPI_MOD_

#include <csl_chiphal.h>

#if (_HPI_SUPPORT)

#include <csl_hpi.h>

#pragma DATA_SECTION(CSL_HpiData,".csldata:HPI_data")

CSL_HpiDataObj  CSL_HpiData = CSL_HPIDATAINIT;

#endif /* HPI_SUPPORT */
/******************************************************************************\
* End of csl_hpidat.c
\******************************************************************************/
csl_i2cdat.c/   1051540734  0     0     0       1053      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... csl_i2cdat.c
* DATE CREATED.. Thu 10 April 2003 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 Apri 2003 added reference for CSL_I2cData for .csldata size fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (I2C initialization)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_chiphal.h>

#if (_I2C_SUPPORT)

#include <csl_i2c.h>

#pragma DATA_SECTION(CSL_I2cData,".csldata:I2C_data")

CSL_I2cDataObj  CSL_I2cData = CSL_I2CDATAINIT;

   




#endif


csl_icachedat.c/1051540734  0     0     0       1734      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ICACHE
* FILENAME...... csl_icachedat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   10 April 2003   added reference to CLS_IcacheData for .csldata size fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ICACHE module)
*
*
*
\******************************************************************************/
#define _ICACHE_MOD_

/****************************************\
* include files
\****************************************/    
#include "csl_chip.h" 
#include "csl_icache.h" 
#include "csl.h"
   
 
#if (_ICACHE_SUPPORT)
             
/****************************************\
* ICACHE static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

#pragma DATA_SECTION(CSL_IcacheData,".csldata:ICACHE_data")

CSL_IcacheDataObj   CSL_IcacheData = CSL_ICACHEDATAINIT;

/*----------------------------------------------------------------------------*/

#endif /* ICACHE_SUPPORT */
/******************************************************************************\
* End of csl_icachedat.c
\******************************************************************************/

csl_irqdat.c/   1051540733  0     0     0       2337      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... IRQ
* FILENAME...... csl_irqdat.c
* DATE CREATED.. Thu 10 April 2003 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* IMPORTS....... none
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_irq.h>

#if (_IRQ_SUPPORT)                                                               
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* IRQ static variable definitions
\****************************************/

/****************************************\
* IRQ static function definitions
\****************************************/
/* See for romability */     

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/
       
/****************************************\
* IRQ global variable definitions
\****************************************/

/* See definition under irq.h */

#pragma DATA_SECTION(CSL_IrqData,".csldata:IRQ_data")

CSL_IrqDataObj  CSL_IrqData = CSL_IRQDATAINIT;


/*----------------------------------------------------------------------------*/

#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of csl_irqdat.c
\******************************************************************************/


csl_mcbspdat.c/ 1051540732  0     0     0       1909      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... csl_mcbspdat.c
* DATE CREATED.. Thu April 10 2003 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data file for the MCBSP module)
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>    

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/



#pragma DATA_SECTION(CSL_McbspData,".csldata:MCBSP_data")

CSL_McbspDataObj CSL_McbspData = CSL_MCBSPDATAINIT;

/*----------------------------------------------------------------------------*/
 
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of csl_mcbspdat.c
\******************************************************************************/


csl_mmcdat.c/   1051540731  0     0     0       1231      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... csl_mmcdat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu 10 April 2003
*
*------------------------------------------------------------------------------
* DESCRIPTION: Data File for MMC Module
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>
#include <csl_pwr.h>

#if (_MMC_SUPPORT)

#pragma DATA_SECTION(CSL_MmcData,".csldata:MMC_data")

CSL_MmcDataObj  CSL_MmcData = CSL_MMCDATAINIT;


#endif
 

csl_plldat.c/   1051540730  0     0     0       1026      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... csl_plldat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data file for the PLL module)
\******************************************************************************/
#define _PLL_MOD_

#include <csl_emif.h>
#include <csl_pll.h>

#if (_PLLA_SUPPORT)

#pragma DATA_SECTION(CSL_PllData,".csldata:PLL_data")

CSL_PllDataObj  CSL_PllData = CSL_PLLDATAINIT;


#endif    //PLLB_SUPPORT



csl_pwrdat.c/   1051540729  0     0     0       1206      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PWR
* FILENAME...... csl_pwrdat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*  CREATED:  Thu 10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data file for the PWR module)
\******************************************************************************/
#define _PWR_MOD_

#include <csl_irq.h>
#include <csl_pwr.h>

#if (_PWR_SUPPORT)

#pragma DATA_SECTION(CSL_PwrData,".csldata:PWR_data")

CSL_PwrDataObj CSL_PwrData = CSL_PWRDATAINIT;


#endif /*PWR_SUPPORT */
/******************************************************************************\
* End of csl_pwrdat.c
\******************************************************************************/
csl_rtcdat.c/   1051540729  0     0     0       1211      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... RTC
* FILENAME...... csl_rtcdat.c
* DATE CREATED.. Tue 27/02/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 April 2003   	
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data file for RTC Module)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

#include <csl_rtc.h>
#include <csl.h>


#if (_RTC_SUPPORT)

#pragma DATA_SECTION(CSL_RtcData,".csldata:RTC_data")

CSL_RtcDataObj CSL_RtcData = CSL_RTCDATAINIT;

#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of csl_rtcdat.c
\******************************************************************************/


csl_sysdat.c/   1051540728  0     0     0       1325      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... CSL
* FILENAME...... csl_sysdat.c
* DATE CREATED.. Thu April 10 2003
* PROJECT....... Chip Support Library (CSL)
* COMPONENT..... service layer
* IMPORTS....... csl.h, csl_timer.h
*------------------------------------------------------------------------------
* HISTORY:
*  CREATED: 10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the CSL module)
*
*
*
\******************************************************************************/

#include <csl_std.h>  
#include <csl_csldat.h>


/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* CSL static variable definitions
\****************************************/



#pragma DATA_SECTION(CSL_SysData,".csldat:SYS_data")

CSL_SysDataObj CSL_SysData = CSL_SYSDATAINIT;

csl_timdat.c/   1051540727  0     0     0       3318      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... tim_cfg.c
* DATE CREATED.. Thu April 10 2003 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  10 April 2003 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data file for TIMER module)
*
*
*
\******************************************************************************/
#define _TIMER_MOD_

/****************************************\
* include files
\****************************************/    


#include <csl_chiphal.h>  
 
#if (_TIMER_SUPPORT)
#include <csl_timer.h>
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER static macro declarations
\****************************************/
/* See timer.h Romability */
 
/****************************************\
* TIMER static typedef declarations
\****************************************/

/****************************************\
* TIMER static function declarations
\****************************************/

/****************************************\
* TIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See timer.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/


#pragma DATA_SECTION(CSL_TimerData,".csldata:TIMER_data")

 CSL_TimerDataObj CSL_TimerData = CSL_TIMERDATAINIT;

/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of csl_timdat.c
\******************************************************************************/

csl_uartdat.c/  1051540726  0     0     0       1624      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... csl_uartdat.c
* DATE CREATED.. Thu April 10 2003 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   10 April 2003   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data structure for UART module)
*
*
*
\******************************************************************************/
#define _UART_MOD_

/****************************************\
* include files
\****************************************/  

#include <csl_irq.h>
 
#if (_UART_SUPPORT)

#include <csl_uart.h> 
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

#pragma DATA_SECTION(CSL_UartData,".csldata:UART_data")

CSL_UartDataObj CSL_UartData = CSL_UARTDATAINIT;

/*----------------------------------------------------------------------------*/

#endif /* UART_SUPPORT */
/******************************************************************************\
* End of csl_uartdat.c
\******************************************************************************/

csl_vers.c/     1051539328  0     0     0       70        `
#include <csl_version.h>

VERSION(CSL_C5500_TI, "csl55x-08", "C");
csl_wdtimdat.c/ 1051540725  0     0     0       1376      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... WDTIMER
* FILENAME...... csl_wdtimdat.c
* DATE CREATED.. Thu 10 April 2003
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED: 10 April 2003
*------------------------------------------------------------------------------
* DESCRIPTION:  (Data file for Watch Dog Timer, assumes preconfig)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

#include <csl_chiphal.h>

#if _WDTIM_SUPPORT

#include <csl_wdtim.h>
#include <csl_wdtimdat.h>

#pragma DATA_SECTION(CSL_WdtimData,".csldata:WDTIM_data")

CSL_WdtimDataObj  CSL_WdtimData = CSL_WDTIMDATAINIT;

/*----------------------------------------------------------------------------*/
#endif /* WDTIM_SUPPORT */
/******************************************************************************\
* End of csl_wdtimdat.c
\******************************************************************************/


csllibs.c/      1049976966  0     0     0       3672      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... CSL
* FILENAME...... csllibs.c
* DATE CREATED.. Tues 08/06/2002 
* PROJECT....... Chip Support Library (CSL)
* COMPONENT..... service layer
* IMPORTS....... csl.h, csl_timer.h
*------------------------------------------------------------------------------
* HISTORY:
*   MODIFIED: 08/06/2002 created to prevent compiler from optimizing
*                         out call to CSL lib functions 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the CSL module)
*
*
*
\******************************************************************************/

#define _CSL_MOD_

#include <csl.h>  

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* CSL static macro declarations
\****************************************/

/****************************************\
* CSL static typedef declarations
\****************************************/

/****************************************\
* CSL static function declarations
\****************************************/

/****************************************\
* CSL static variable definitions
\****************************************/

/****************************************\
* CSL static function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* CSL global variable definitions
\****************************************/

/****************************************\
* CSL global function definitions
\****************************************/

/*----------------------------------------------------------------------------*/
/* Here we will define a function whose name matches the library name         */
/* It will be called by CSL_init() and is used to detect when the             */
/* incorrect library is linked in.                                            */
/*----------------------------------------------------------------------------*/
  #if (CHIP_5510)
   void CSL5510_LIB_(){}
  #elif (CHIP_5510PG1_0)
    void CSL5510_PG1_LIB_(){}
  #elif (CHIP_5510PG1_2)
    void CSL5510_PG1_2_LIB_(){}
  #elif (CHIP_5510PG2_0)
    void CSL5510_PG2_0_LIB_(){}
  #elif (CHIP_5510PG2_1)
    void CSL5510_PG2_1_LIB_(){}
  #elif (CHIP_5510PG2_2)
    void CSL5510_PG2_2_LIB_(){}
  #elif (CHIP_5509)
    void CSL5509_LIB_(){}
  #elif (CHIP_5509PG1_0)
    void CSL5509_PG1_0_LIB_(){}
  #elif (CHIP_5509PG2_0)
    void CSL5509_PG2_0_LIB_(){}
  #endif




/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

dat_close.c/    1049976969  0     0     0       4076      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DAT
* FILENAME...... DAT_close.c
* DATE CREATED.. Thu 11/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* IMPORTS.......
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  11/11/1999 
*   MODIFIED: 07/10/2000 Modified for C55xx
*   MODIFIED: 06/29/2001 added pragma for section per function and updated
*                        for new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (C body file for the DAT module)
*
*
*
\******************************************************************************/
#define _DAT_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dat.h>

#if (_DAT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT static macro declarations
\****************************************/

/****************************************\
* DAT static typedef declarations
\****************************************/

/****************************************\
* DAT static function declarations
\****************************************/
static inline void DmaWait();

/****************************************\
* DAT static variable definitions
\****************************************/
/*
static CSLBool Initialized   = FALSE;
static DMA_Handle hDma    = INV;
static Uint16 EventId     = 0x0000;
static Uint16 ChaPriority = 0;
static int SubmitMask     = 0;
static int OpenFlag       = 0;
*/
/****************************************\
* DAT static function definitions
\****************************************/

#pragma CODE_SECTION(DmaWait,".text:DAT_close")

/*----------------------------------------------------------------------------*/
static inline void DmaWait(DMA_Handle hDma) {
   Uint16 chaMask = 1u<<((DMA_PrivateObj*)hDma)->DmaChaNum;
    if (CSL_SYS_DATA.DatSubmitMask & chaMask) {
      while (!IRQ_test(((DMA_PrivateObj*)hDma)->EventId)){};
      IRQ_clear(((DMA_PrivateObj*)hDma)->EventId); 
      CSL_SYS_DATA.DatSubmitMask &= (~chaMask);  
    }
  }

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT global variable definitions
\****************************************/

/****************************************\
* DAT global function definitions
\****************************************/

#pragma CODE_SECTION(DAT_close,".text:DAT_close")

/*----------------------------------------------------------------------------*/
void DAT_close(DAT_Handle hDat) {
  
  int oldgie;
  Uint16 chaMask;
  DMA_Handle hDma = (DMA_Handle) hDat;


  chaMask = 1u<<((DMA_PrivateObj*)hDma)->DmaChaNum;
  oldgie = IRQ_globalDisable();  

  if (CSL_SYS_DATA.DatOpenFlag & chaMask) {
    DmaWait(hDma);
    DMA_close(hDma);
    CSL_SYS_DATA.DatOpenFlag &= (~chaMask);
  }

  IRQ_globalRestore(oldgie);
}
/*----------------------------------------------------------------------------*/

#endif /* DAT_SUPPORT */
/******************************************************************************\
* End of DAT_close.c
\******************************************************************************/

dat_copy.c/     1074583736  0     0     0       6511      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DAT
* FILENAME...... DAT_Copy.c
* DATE CREATED.. Thu 11/11/1999
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* IMPORTS.......
*------------------------------------------------------------------------------
* HISTORY:
*   11/11/1999 (BWC) Created
*   07/10/2000 (IC) Modified for C55xx
*   09/16/2003 Changed src and dst address generation expression, Added missing
*				DMA control registers assignment
*   10/06/2003 Added CHIP_5502 type for CSDP register make.
*   01/19/2003 Added WP field to DMACCR register on 5502
*------------------------------------------------------------------------------
* DESCRIPTION:  (C body file for the DAT module)
*
*
*
\******************************************************************************/
#define _DAT_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dat.h>

#if (_DAT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT static macro declarations
\****************************************/

/****************************************\
* DAT static typedef declarations
\****************************************/

/****************************************\
* DAT static function declarations
\****************************************/

/****************************************\
* DAT static variable definitions
\****************************************/

/****************************************\
* DAT static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT global variable definitions
\****************************************/

/****************************************\
* DAT global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
Uint16 DAT_copy(DAT_Handle hDat, DMA_AdrPtr Src , DMA_AdrPtr Dst , Uint16 ElemCnt) {

  volatile int x;
   int oldgie;
   Uint16 chaMask;
   Uint16 prio;
   DMA_Handle hDma = (DMA_Handle) hDat;


  chaMask = 1u << ((DMA_PrivateObj*)hDma)->DmaChaNum;

  oldgie = IRQ_globalDisable();

  #ifdef _MCRTE_DEBUG
    if (!(CSL_SYS_DATA.DatOpenFlag&chaMask)) {
      ERR_submit(DAT_ERR_MAJOR,DAT_ERR_NOT_OPEN);
      return 0x00000000;
    }
  #endif


    CSL_SYS_DATA.DatSubmitMask |= chaMask;

    prio = (CSL_SYS_DATA.DatChaPriority & chaMask)? DMA_DMACCR_PRIO_HI: DMA_DMACCR_PRIO_LOW;

    DMA_RSETH(hDma,DMACSSAL,(((Uint32)Src << 1) & 0xFFFF));
    DMA_RSETH(hDma,DMACSSAU,(((Uint32)Src >> 15) & 0xFFFF));
    DMA_RSETH(hDma,DMACDSAL,(((Uint32)Dst << 1) & 0xFFFF));
    DMA_RSETH(hDma,DMACDSAU,(((Uint32)Dst >> 15) & 0xFFFF));

    DMA_RSETH(hDma,DMACEN,(Uint16)ElemCnt);
    DMA_RSETH(hDma,DMACFN,1);
  #if _DMA_DST_AND_SRC_INDEX_SUPPORT
    DMA_RSETH(hDma,DMACSFI,0);
	DMA_RSETH(hDma,DMACSEI,0);
	DMA_RSETH(hDma,DMACDFI,0);
	DMA_RSETH(hDma,DMACDEI,0);
  #else
    DMA_RSETH(hDma,DMACFI,0);
	DMA_RSETH(hDma,DMACEI,0);
  #endif

  #if (CHIP_5502)
	
    DMA_RSETH(hDma,DMACCR,DMA_DMACCR_RMK(
                   DMA_DMACCR_DSTAMODE_POSTINC,
                   DMA_DMACCR_SRCAMODE_POSTINC,
                   DMA_DMACCR_ENDPROG_OFF,
		   DMA_DMACCR_WP_DEFAULT,
		   DMA_DMACCR_REPEAT_OFF,
                   DMA_DMACCR_AUTOINIT_OFF,
                   DMA_DMACCR_EN_STOP,
                   prio,
                   DMA_DMACCR_FS_DISABLE,
                   DMA_DMACCR_SYNC_NONE
                   ));
  #else
    DMA_RSETH(hDma,DMACCR,DMA_DMACCR_RMK(
                   DMA_DMACCR_DSTAMODE_POSTINC,
                   DMA_DMACCR_SRCAMODE_POSTINC,
                   DMA_DMACCR_ENDPROG_OFF,
                   DMA_DMACCR_REPEAT_OFF,
                   DMA_DMACCR_AUTOINIT_OFF,
                   DMA_DMACCR_EN_STOP,
                   prio,
                   DMA_DMACCR_FS_DISABLE,
                   DMA_DMACCR_SYNC_NONE
                   ));
  #endif
    
    DMA_RSETH(hDma,DMACICR,DMA_DMACICR_RMK(
                      DMA_DMACICR_BLOCKIE_ON,
                      DMA_DMACICR_LASTIE_OFF,
                      DMA_DMACICR_FRAMEIE_ON,
                      DMA_DMACICR_HALFIE_OFF,
                      DMA_DMACICR_DROPIE_OFF,
                      DMA_DMACICR_TIMEOUTIE_OFF
                      ));
  #if (CHIP_5502)

    DMA_RSETH(hDma,DMACSDP,DMA_DMACSDP_RMK(
                      DMA_DMACSDP_DSTBEN_NOBURST,
                      DMA_DMACSDP_DSTPACK_OFF,
                      DMA_DMACSDP_DST_DARAMPORT0,
                      DMA_DMACSDP_SRCBEN_NOBURST,
                      DMA_DMACSDP_SRCPACK_OFF,
                      DMA_DMACSDP_SRC_DARAMPORT0,
                      DMA_DMACSDP_DATATYPE_16BIT
                      ));
  #else
       
    DMA_RSETH(hDma,DMACSDP,DMA_DMACSDP_RMK(
                      DMA_DMACSDP_DSTBEN_NOBURST,
                      DMA_DMACSDP_DSTPACK_OFF,
                      DMA_DMACSDP_DST_SARAM,
                      DMA_DMACSDP_SRCBEN_NOBURST,
                      DMA_DMACSDP_SRCPACK_OFF,
                      DMA_DMACSDP_SRC_SARAM,
                      DMA_DMACSDP_DATATYPE_16BIT
                      ));             
  #endif

    DMA_start(hDma);

    IRQ_globalRestore(oldgie);

  return DMA_FGETH(hDma,DMACSR,FRAME);
}

/*----------------------------------------------------------------------------*/

#endif /* DAT_SUPPORT */
/******************************************************************************\
* End of DAT_Copy.c
\******************************************************************************/


dat_copy2d.c/   1074583738  0     0     0       7337      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DAT
* FILENAME...... DAT_copy2D.c
* DATE CREATED.. Thu 11/11/1999
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* IMPORTS.......
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  11/11/1999
*   MODIFIED: 07/10/2000 Modified for C55xx
*   MODIFIED: 06/29/2001 added pragma for section per function and updated
*                        for new CSL initialization/data model
*	      09/16/2003 Changed src and dst address generation expression, Added missing
*	    		 DMA control registers assignment
*             10/06/2003 Added CHIP_5502 type for CSDP register make.
*             01/19/2003 Added WP field to DMACCR register on 5502
*------------------------------------------------------------------------------
* DESCRIPTION:  (C body file for the DAT module)
*
*
*
\******************************************************************************/
#define _DAT_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dat.h>

#if (_DAT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT static macro declarations
\****************************************/

/****************************************\
* DAT static typedef declarations
\****************************************/

/****************************************\
* DAT static function declarations
\****************************************/

/****************************************\
* DAT static variable definitions
\****************************************/
/*
static CSLBool Initialized   = FALSE;
static DMA_Handle hDma    = INV;
static Uint16 EventId     = 0x0000;
static Uint16 ChaPriority = 0;
static int SubmitMask     = 0;
static int OpenFlag       = 0;
*/
/****************************************\
* DAT static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT global variable definitions
\****************************************/

/****************************************\
* DAT global function definitions
\****************************************/

#pragma CODE_SECTION(DAT_copy2D,".text:DAT_copy2D")

/*----------------------------------------------------------------------------*/
Uint16 DAT_copy2D(DAT_Handle hDat,
                  Uint16 Type,
                  DMA_AdrPtr Src,
                  DMA_AdrPtr Dst,
                  Uint16 LineLen,
                  Uint16 LineCnt,
                  Uint16 LinePitch) {

  DMA_Handle hDma = (DMA_Handle) hDat;
  Uint16 chaMask;
  Uint16 Index;
  Uint16 prio;
  Uint16 srcAmode;
  Uint16 dstAmode;
    int oldgie;

  volatile Uint16 x;

  Index = (LinePitch - LineLen + 1);
  chaMask = 1u<<((DMA_PrivateObj*)hDma)->DmaChaNum;
  srcAmode = (Type >> 4) & 0xFu;
  dstAmode = (Type & 0xFu);
  prio = (CSL_SYS_DATA.DatChaPriority & chaMask)?
            DMA_DMACCR_PRIO_HI : DMA_DMACCR_PRIO_LOW;

  oldgie = IRQ_globalDisable();

  #ifdef _MCRTE_DEBUG
    if (!(CSL_SYS_DATA.DatOpenFlag & chaMask)) {
      ERR_submit(DAT_ERR_MAJOR,DAT_ERR_NOT_OPEN);
      return 0x00000000;
    }
  #endif

//  DmaWait();
    CSL_SYS_DATA.DatSubmitMask |= chaMask;


    DMA_RSETH(hDma,DMACSSAL,(((Uint32)Src << 1) & 0xFFFF));
    DMA_RSETH(hDma,DMACSSAU,(((Uint32)Src >> 15) & 0xFFFF));
    DMA_RSETH(hDma,DMACDSAL,(((Uint32)Dst << 1) & 0xFFFF));
    DMA_RSETH(hDma,DMACDSAU,(((Uint32)Dst >> 15) & 0xFFFF));

    DMA_RSETH(hDma,DMACEN,(Uint16)LineLen);
    DMA_RSETH(hDma,DMACFN,(Uint16)LineCnt);

#if _DMA_DST_AND_SRC_INDEX_SUPPORT
    DMA_RSETH(hDma,DMACSEI,1);
    DMA_RSETH(hDma,DMACSFI,(Uint16)Index);
    DMA_RSETH(hDma,DMACDEI,1);
    DMA_RSETH(hDma,DMACDFI,(Uint16)Index);
#else
    DMA_RSETH(hDma,DMACEI,1);
    DMA_RSETH(hDma,DMACFI,(Uint16)Index);
#endif

#if (CHIP_5502)
    
    DMA_RSETH(hDma,DMACCR,DMA_DMACCR_RMK(
                      dstAmode,
                      srcAmode,
                      DMA_DMACCR_ENDPROG_OFF,
		      DMA_DMACCR_WP_DEFAULT,
		      DMA_DMACCR_REPEAT_OFF,
                      DMA_DMACCR_AUTOINIT_OFF,
                      DMA_DMACCR_EN_STOP,
                      prio,
                      DMA_DMACCR_FS_DISABLE,
                      DMA_DMACCR_SYNC_NONE
                      ));
#else
    DMA_RSETH(hDma,DMACCR,DMA_DMACCR_RMK(
                      dstAmode,
                      srcAmode,
                      DMA_DMACCR_ENDPROG_OFF,
                      DMA_DMACCR_REPEAT_OFF,
                      DMA_DMACCR_AUTOINIT_OFF,
                      DMA_DMACCR_EN_STOP,
                      prio,
                      DMA_DMACCR_FS_DISABLE,
                      DMA_DMACCR_SYNC_NONE
                      ));
#endif
    

    DMA_RSETH(hDma,DMACICR,DMA_DMACICR_RMK(
                      DMA_DMACICR_BLOCKIE_ON,
                      DMA_DMACICR_LASTIE_OFF,
                      DMA_DMACICR_FRAMEIE_ON,
                      DMA_DMACICR_HALFIE_OFF,
                      DMA_DMACICR_DROPIE_OFF,
                      DMA_DMACICR_TIMEOUTIE_OFF
                      ));
  #if (CHIP_5502)

    DMA_RSETH(hDma,DMACSDP,DMA_DMACSDP_RMK(
                      DMA_DMACSDP_DSTBEN_NOBURST,
                      DMA_DMACSDP_DSTPACK_OFF,
                      DMA_DMACSDP_DST_DARAMPORT0,
                      DMA_DMACSDP_SRCBEN_NOBURST,
                      DMA_DMACSDP_SRCPACK_OFF,
                      DMA_DMACSDP_SRC_DARAMPORT0,
                      DMA_DMACSDP_DATATYPE_16BIT
                      ));
  #else
       
    DMA_RSETH(hDma,DMACSDP,DMA_DMACSDP_RMK(
                      DMA_DMACSDP_DSTBEN_NOBURST,
                      DMA_DMACSDP_DSTPACK_OFF,
                      DMA_DMACSDP_DST_SARAM,
                      DMA_DMACSDP_SRCBEN_NOBURST,
                      DMA_DMACSDP_SRCPACK_OFF,
                      DMA_DMACSDP_SRC_SARAM,
                      DMA_DMACSDP_DATATYPE_16BIT
                      ));             
  #endif


  DMA_start(hDma);


  IRQ_globalRestore(oldgie);

  return DMA_FGETH(hDma,DMACSR,FRAME);

}
/*----------------------------------------------------------------------------*/

#endif /* DAT_SUPPORT */
/******************************************************************************\
* End of DAT_Copy2D.c
\******************************************************************************/


dat_fill.c/     1074583738  0     0     0       6929      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DAT
* FILENAME...... DAT_fill.c
* DATE CREATED.. Thu 11/11/1999
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* IMPORTS.......
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  11/11/1999
*   MODIFIED: 07/10/2000 Modified for C55xx
*   MODIFIED: 06/29/2001 added pragma for section per function
*	      09/16/2003 Changed src and dst address generation expression
*	      10/06/2003 Added CHIP_5502 type for CSDP register make.
*	      01/19/2003 Added WP field to DMACCR register on 5502
*------------------------------------------------------------------------------
* DESCRIPTION:  (C body file for the DAT module)
*
*
*
\******************************************************************************/
#define _DAT_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dat.h>

#if (_DAT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT static macro declarations
\****************************************/

/****************************************\
* DAT static typedef declarations
\****************************************/

/****************************************\
* DAT static function declarations
\****************************************/

/****************************************\
* DAT static variable definitions
\****************************************/
/*
static CSLBOOL Initialized   = FALSE;
static DMA_Handle hDma    = INV;
static Uint16 EventId     = 0x0000;
static Uint16 ChaPriority = 0;
static int SubmitMask     = 0;
static int OpenFlag       = 0;
*/
/****************************************\
* DAT static function definitions
\****************************************/
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT global variable definitions
\****************************************/

/****************************************\
* DAT global function definitions
\****************************************/

#pragma CODE_SECTION(DAT_fill,".text:DAT_fill")

/*----------------------------------------------------------------------------*/
Uint16 DAT_fill(DAT_Handle hDat, DMA_AdrPtr Dst , Uint16 ElemCnt, Uint16 *Value) {

  int oldgie;
  Uint16 chaMask;
  Uint16 prio;
  DMA_Handle hDma = (DMA_Handle) hDat;




  chaMask = 1u<<((DMA_PrivateObj*)hDma)->DmaChaNum;
  prio = (CSL_SYS_DATA.DatChaPriority & chaMask) ? DMA_DMACCR_PRIO_HI : DMA_DMACCR_PRIO_LOW;

  oldgie = IRQ_globalDisable();

  #ifdef _MCRTE_DEBUG
    if (!(CSL_SYS_DATA.DatOpenFlag & chaMask)) {
      ERR_submit(DAT_ERR_MAJOR,DAT_ERR_NOT_OPEN);
      return 0x00000000;
    }
  #endif

    CSL_SYS_DATA.DatSubmitMask |= chaMask;

    DMA_RSETH(hDma,DMACSSAL,(((Uint32)Value << 1) & 0xFFFF));
    DMA_RSETH(hDma,DMACSSAU,(((Uint32)Value >> 15) & 0xFFFF));
    DMA_RSETH(hDma,DMACDSAL,(((Uint32)Dst << 1) & 0xFFFF));
    DMA_RSETH(hDma,DMACDSAU,(((Uint32)Dst >> 15) & 0xFFFF));

    DMA_RSETH(hDma,DMACEN,(Uint16)ElemCnt);
    DMA_RSETH(hDma,DMACFN,1);
  #if _DMA_DST_AND_SRC_INDEX_SUPPORT
    DMA_RSETH(hDma,DMACSFI,0);
	DMA_RSETH(hDma,DMACSEI,0);
	DMA_RSETH(hDma,DMACDFI,0);
	DMA_RSETH(hDma,DMACDEI,0);
  #else
    DMA_RSETH(hDma,DMACFI,0);
	DMA_RSETH(hDma,DMACEI,0);
  #endif
  
  #if (CHIP_5502)	
    DMA_RSETH(hDma,DMACCR,DMA_DMACCR_RMK(
                      DMA_DMACCR_DSTAMODE_POSTINC,
                      DMA_DMACCR_SRCAMODE_CONST,
                      DMA_DMACCR_ENDPROG_OFF,
		      DMA_DMACCR_WP_DEFAULT,
                      DMA_DMACCR_REPEAT_OFF,
                      DMA_DMACCR_AUTOINIT_OFF,
                      DMA_DMACCR_EN_STOP,
                      prio,
                      DMA_DMACCR_FS_DISABLE,
                      DMA_DMACCR_SYNC_NONE
                      ));

  #else
    DMA_RSETH(hDma,DMACCR,DMA_DMACCR_RMK(
                      DMA_DMACCR_DSTAMODE_POSTINC,
                      DMA_DMACCR_SRCAMODE_CONST,
                      DMA_DMACCR_ENDPROG_OFF,
                      DMA_DMACCR_REPEAT_OFF,
                      DMA_DMACCR_AUTOINIT_OFF,
                      DMA_DMACCR_EN_STOP,
                      prio,
                      DMA_DMACCR_FS_DISABLE,
                      DMA_DMACCR_SYNC_NONE
                      ));


  #endif 
    DMA_RSETH(hDma,DMACICR,DMA_DMACICR_RMK(
                      DMA_DMACICR_BLOCKIE_OFF,
                      DMA_DMACICR_LASTIE_OFF,
                      DMA_DMACICR_FRAMEIE_ON,
                      DMA_DMACICR_HALFIE_OFF,
                      DMA_DMACICR_DROPIE_OFF,
                      DMA_DMACICR_TIMEOUTIE_OFF
                      ));

  #if (CHIP_5502)

    DMA_RSETH(hDma,DMACSDP,DMA_DMACSDP_RMK(
                      DMA_DMACSDP_DSTBEN_NOBURST,
                      DMA_DMACSDP_DSTPACK_OFF,
                      DMA_DMACSDP_DST_DARAMPORT0,
                      DMA_DMACSDP_SRCBEN_NOBURST,
                      DMA_DMACSDP_SRCPACK_OFF,
                      DMA_DMACSDP_SRC_DARAMPORT0,
                      DMA_DMACSDP_DATATYPE_16BIT
                      ));
  #else
       
    DMA_RSETH(hDma,DMACSDP,DMA_DMACSDP_RMK(
                      DMA_DMACSDP_DSTBEN_NOBURST,
                      DMA_DMACSDP_DSTPACK_OFF,
                      DMA_DMACSDP_DST_SARAM,
                      DMA_DMACSDP_SRCBEN_NOBURST,
                      DMA_DMACSDP_SRCPACK_OFF,
                      DMA_DMACSDP_SRC_SARAM,
                      DMA_DMACSDP_DATATYPE_16BIT
                      ));             
  #endif
  
  DMA_start(hDma);


  IRQ_globalRestore(oldgie);

  return DMA_FGETH(hDma,DMACSR,FRAME);
}
/*----------------------------------------------------------------------------*/

#endif /* DAT_SUPPORT */
/******************************************************************************\
* End of DAT_fill.c
\******************************************************************************/


dat_open.c/     1065792316  0     0     0       4005      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DAT
* FILENAME...... DAT_open.c
* DATE CREATED.. Thu 11/11/1999
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* IMPORTS.......
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  11/11/1999
*   MODIFIED: 07/10/2000 modified for C55xx
*   MODIFIED: 06/29/2001 added pragma for section per function and updated
*                        for new CSL initialization/data model
*			  09/16/2003 Added chech for invalid channel number
*------------------------------------------------------------------------------
* DESCRIPTION:  (C body file for the DAT module)
*
*
*
\******************************************************************************/
#define _DAT_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dat.h>

#if (_DAT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT static macro declarations
\****************************************/

/****************************************\
* DAT static typedef declarations
\****************************************/

/****************************************\
* DAT static function declarations
\****************************************/

/****************************************\
* DAT static variable definitions
\****************************************/
/****************************************\
* DAT static function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT global variable definitions
\****************************************/

/****************************************\
* DAT global function definitions
\****************************************/

#pragma CODE_SECTION(DAT_open,".text:DAT_open")

/*----------------------------------------------------------------------------*/
DAT_Handle DAT_open(int ChaNum, int Priority, Uint32 Flags) {
  int oldgie;
  Uint16 chaMask = 1u << ChaNum;
  DMA_Handle hDma = INV;

  UNREFERENCED_PARAMETER(Flags);

  if ((ChaNum<DAT_CHA_ANY) || (ChaNum>=_DMA_CHA_CNT)) {
      return (DAT_Handle)INV;
  }


  oldgie = IRQ_globalDisable();

  if (!(CSL_SYS_DATA.DatOpenFlag & chaMask)) {

      hDma = DMA_open(ChaNum,DMA_OPEN_RESET);

    #ifdef _MCRTE_DEBUG
      if (hDma==INV) {
        ERR_submit(DAT_ERR_MAJOR,DAT_ERR_ALLOC);
        return;
      }
    #endif

    if (hDma != INV) {
      IRQ_clear(((DMA_PrivateObj*)hDma)->EventId);
      CSL_SYS_DATA.DatChaPriority = (CSL_SYS_DATA.DatChaPriority & (~chaMask))
                                     | ((Priority & 0x1u)<<ChaNum);
      CSL_SYS_DATA.DatOpenFlag |= chaMask;
    }
 }

  IRQ_globalRestore(oldgie);
  return (DAT_Handle) hDma;
}

/*----------------------------------------------------------------------------*/

#endif /* DAT_SUPPORT */
/******************************************************************************\
* End of DAT_open.c
\******************************************************************************/


dat_wait.c/     1049976978  0     0     0       3976      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DAT
* FILENAME...... DAT_wait.c
* DATE CREATED.. Thu 11/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* IMPORTS.......
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  11/11/1999 (BWC) Created
*   MODIFIED: 06/29/2001 added pragma for section per function and updated
*                        for new CSL initalization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (C body file for the DAT module)
*
*
*
\******************************************************************************/
#define _DAT_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dat.h>

#if (_DAT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT static macro declarations
\****************************************/

/****************************************\
* DAT static typedef declarations
\****************************************/

/****************************************\
* DAT static function declarations
\****************************************/
static inline void DmaWait();

/****************************************\
* DAT static variable definitions
\****************************************/
/*
static CSLBool Initialized   = FALSE;
static DMA_Handle hDma    = INV;
static Uint16 EventId     = 0x0000;
static Uint16 ChaPriority = 0;
static int SubmitMask     = 0;
static int OpenFlag       = 0;
*/
/****************************************\
* DAT static function definitions
\****************************************/

#pragma CODE_SECTION(DmaWait,".text:DAT_wait")

/*----------------------------------------------------------------------------*/
static inline void DmaWait(DMA_Handle hDma) {
    Uint16 chaMask = 1u<<((DMA_PrivateObj*)hDma)->DmaChaNum;
    if (CSL_SYS_DATA.DatSubmitMask & chaMask) {
      while (!IRQ_test(((DMA_PrivateObj*)hDma)->EventId)){};
      IRQ_clear(((DMA_PrivateObj*)hDma)->EventId);   
    }
  }

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DAT global variable definitions
\****************************************/

/****************************************\
* DAT global function definitions
\****************************************/

#pragma CODE_SECTION(DAT_wait,".text:DAT_wait")

/*----------------------------------------------------------------------------*/
void DAT_wait(DAT_Handle hDat) {
  DMA_Handle hDma = (DMA_Handle) hDat;
  Uint16 chaMask = 1u<<((DMA_PrivateObj*)hDma)->DmaChaNum;

  #ifdef _MCRTE_DEBUG
    if (!(CSL_SYS_DATA.DatOpenFlag & chaMask)) {
      ERR_submit(DAT_ERR_MAJOR,DAT_ERR_NOT_OPEN);
      return;
    }
  #endif
    
  DmaWait(hDma);
  CSL_SYS_DATA.DatSubmitMask &= ~chaMask;   
}
/*----------------------------------------------------------------------------*/

#endif /* DAT_SUPPORT */
/******************************************************************************\
* End of DAT_Wait.c
\******************************************************************************/

dma_cfg.c/      1061462362  0     0     0       3987      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DMA
* FILENAME...... DMA_cfg.c
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999
*   MODIFIED: 06/30/2000 Modified for C55xx   
*   MODIFIED: 03/27/2001 Modified to support 5510PG2.0
*   MODIFIED: 06/29/2001 added pragma for section per function
*   MODIFIED: 04/03/2002 fixed addressing problem for large model
*   MODIFIED: 07/26/2002 fixed typo for CDMACSSAL
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the DMA module)
*
*
*
\******************************************************************************/
#define _DMA_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dma.h>

#if (_DMA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA static macro declarations
\****************************************/

/****************************************\
* DMA static typedef declarations
\****************************************/

/****************************************\
* DMA static function declarations
\****************************************/

/****************************************\
* DMA static variable definitions
\****************************************/

/****************************************\
* DMA static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA global variable definitions
\****************************************/

/****************************************\
* DMA global function definitions
\****************************************/

#pragma CODE_SECTION(DMA_config,".text:DMA_config")

/*----------------------------------------------------------------------------*/
void DMA_config(DMA_Handle hDma, DMA_Config *Config) {
  int oldgie;
  DMA_ASSERT_HANDLE(hDma,return);

  oldgie = IRQ_globalDisable();         
 

  DMA_RSETH(hDma,DMACSDP,Config -> dmacsdp);
  DMA_RSETH(hDma,DMACCR,Config -> dmaccr);
  DMA_RSETH(hDma,DMACICR,Config -> dmacicr); 
  DMA_RSETH(hDma,DMACSSAL,(Uint16)((Uint32)(Config -> dmacssal)& 0xFFFFu)); 
  DMA_RSETH(hDma,DMACSSAU,Config -> dmacssau);
  DMA_RSETH(hDma,DMACDSAL,(Uint16)((Uint32)(Config -> dmacdsal)& 0xFFFFu));
  DMA_RSETH(hDma,DMACDSAU,Config -> dmacdsau);
  DMA_RSETH(hDma,DMACEN,Config -> dmacen);  
  DMA_RSETH(hDma,DMACFN,Config -> dmacfn); 
#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  DMA_RSETH(hDma,DMACSFI,Config -> dmacsfi); 
  DMA_RSETH(hDma,DMACSEI,Config -> dmacsei); 
  DMA_RSETH(hDma,DMACDFI,Config -> dmacdfi); 
  DMA_RSETH(hDma,DMACDEI,Config -> dmacdei); 
#else
  DMA_RSETH(hDma,DMACFI,Config -> dmacfi); 
  DMA_RSETH(hDma,DMACEI,Config -> dmacei); 
#endif
  IRQ_globalRestore(oldgie);
  return;
}
/*----------------------------------------------------------------------------*/

#endif /* DMA_SUPPORT */
/******************************************************************************\
* End of DMA_cfg.c
\******************************************************************************/


dma_cfgb.c/     1061462362  0     0     0       4297      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DMA
* FILENAME...... DMA_cfgb.c
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999 
*   MODIFIED: 06/30/2000 Modified for C55xx
*   MODIFIED: 03/27/2001 Modified to support 5510PG2.0
*   MODIFIED: 06/29/2001 added pragma for section per function
*   MODIFIED: 04/03/2002 Made src and dst equivalnet to config implementation
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the DMA module)
*
*
*
\******************************************************************************/
#define _DMA_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dma.h>

#if (_DMA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA static macro declarations
\****************************************/

/****************************************\
* DMA static typedef declarations
\****************************************/

/****************************************\
* DMA static function declarations
\****************************************/

/****************************************\
* DMA static variable definitions
\****************************************/

/****************************************\
* DMA static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA global variable definitions
\****************************************/

/****************************************\
* DMA global function definitions
\****************************************/

#pragma CODE_SECTION(DMA_configArgs,".text:DMA_configArgs")

/*----------------------------------------------------------------------------*/
#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  void DMA_configArgs(DMA_Handle hDma, Uint16 dmacsdp, Uint16 dmaccr, Uint16 dmacicr, 
    DMA_AdrPtr dmacssal, Uint16 dmacssau, DMA_AdrPtr dmacdsal, Uint16 dmacdsau, Uint16 dmacen,
    Uint16 dmacfn, Int16 dmacsfi, Int16 dmacsei, Int16 dmacdfi, Int16 dmacdei)
#else
  void DMA_configArgs(DMA_Handle hDma, Uint16 dmacsdp, Uint16 dmaccr,
    Uint16 dmacicr, DMA_AdrPtr dmacssal, Uint16 dmacssau, DMA_AdrPtr dmacdsal, Uint16 dmacdsau,
    Uint16 dmacen, Uint16 dmacfn, Int16 dmacfi, Int16 dmacei)
#endif
{
   int oldgie; 
  DMA_ASSERT_HANDLE(hDma,return);


  oldgie = IRQ_globalDisable();  

  DMA_RSETH(hDma,DMACSDP,dmacsdp);
  DMA_RSETH(hDma,DMACCR,dmaccr);
  DMA_RSETH(hDma,DMACICR,dmacicr); 
  DMA_RSETH(hDma,DMACSSAL,(Uint16)((Uint32)(dmacssal)& 0xFFFFu)); 
  DMA_RSETH(hDma,DMACSSAU,dmacssau);
  DMA_RSETH(hDma,DMACDSAL,(Uint16)((Uint32)(dmacdsal)& 0xFFFFu));
  DMA_RSETH(hDma,DMACDSAU,dmacdsau);
  DMA_RSETH(hDma,DMACEN,dmacen);  
  DMA_RSETH(hDma,DMACFN,dmacfn); 
#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  DMA_RSETH(hDma,DMACSFI,dmacsfi); 
  DMA_RSETH(hDma,DMACSEI,dmacsei); 
  DMA_RSETH(hDma,DMACDFI,dmacdfi); 
  DMA_RSETH(hDma,DMACDEI,dmacdei);
#else 
  DMA_RSETH(hDma,DMACFI,dmacfi); 
  DMA_RSETH(hDma,DMACEI,dmacei);
#endif 

  IRQ_globalRestore(oldgie);
  return;
}

/*----------------------------------------------------------------------------*/

#endif /* DMA_SUPPORT */
/******************************************************************************\
* End of DMA_cfgb.c
\******************************************************************************/


dma_close.c/    1049976983  0     0     0       3173      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DMA
* FILENAME...... DMA_close.c
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999 
*   MODIFIED: 06/30/2000 Modified for C55xx
*   MODIFIED: 06/29/2001 added pragma for section per function and updated
*                        for new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the DMA module)
*
*
*
\******************************************************************************/
#define _DMA_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dma.h>

#if (_DMA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA static macro declarations
\****************************************/

/****************************************\
* DMA static typedef declarations
\****************************************/

/****************************************\
* DMA static function declarations
\****************************************/

/****************************************\
* DMA static variable definitions
\****************************************/

/****************************************\
* DMA static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA global variable definitions
\****************************************/

/****************************************\
* DMA global function definitions
\****************************************/

#pragma CODE_SECTION(DMA_close,".text:DMA_close")

/*----------------------------------------------------------------------------*/
 void DMA_close(DMA_Handle hDma) {
  Uint16 chaMask = 1u<<((DMA_PrivateObj*)hDma)->DmaChaNum;
  int oldgie;
  DMA_ASSERT_HANDLE(hDma,return);


  oldgie = IRQ_globalDisable();  
  CSL_SYS_DATA.DmaAllocMask &= ~chaMask;
  DMA_reset(hDma);
  IRQ_globalRestore(oldgie);
  return;
}
/*----------------------------------------------------------------------------*/

#endif /* DMA_SUPPORT */
/******************************************************************************\
* End of DMA_close.c
\******************************************************************************/


dma_gcfg.c/     1049976984  0     0     0       3793      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DMA
* FILENAME...... DMA_gcfg.c
* DATE CREATED.. Thu 05/10/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  05/10/2001 Created
*   MODIFIED: 06/29/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the DMA module)
*
*
*
\******************************************************************************/
#define _DMA_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dma.h>

#if (_DMA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA static macro declarations
\****************************************/

/****************************************\
* DMA static typedef declarations
\****************************************/

/****************************************\
* DMA static function declarations
\****************************************/

/****************************************\
* DMA static variable definitions
\****************************************/

/****************************************\
* DMA static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA global variable definitions
\****************************************/

/****************************************\
* DMA global function definitions
\****************************************/

#pragma CODE_SECTION(DMA_getConfig,".text:DMA_getConfig")

/*----------------------------------------------------------------------------*/
void DMA_getConfig(DMA_Handle hDma, DMA_Config *Config) {
  int oldgie;
  DMA_ASSERT_HANDLE(hDma,return);

  oldgie = IRQ_globalDisable();         
 

  Config -> dmacsdp = DMA_RGETH(hDma,DMACSDP);
  Config -> dmaccr  = DMA_RGETH(hDma,DMACCR);
  Config -> dmacicr = DMA_RGETH(hDma,DMACICR); 
  Config -> dmacssal = (DMA_AdrPtr)(DMA_RGETH(hDma,DMACSSAL)); 
  Config -> dmacssau =  DMA_RGETH(hDma,DMACSSAU);
  Config -> dmacdsal = (DMA_AdrPtr)(DMA_RGETH(hDma,DMACDSAL));
  Config -> dmacdsau = DMA_RGETH(hDma,DMACDSAU); 
  Config -> dmacen  = DMA_RGETH(hDma,DMACEN);  
  Config -> dmacfn = DMA_RGETH(hDma,DMACFN); 
#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  Config -> dmacsfi = DMA_RGETH(hDma,DMACSFI); 
  Config -> dmacsei = DMA_RGETH(hDma,DMACSEI); 
  Config -> dmacdfi = DMA_RGETH(hDma,DMACDFI); 
  Config -> dmacdei = DMA_RGETH(hDma,DMACDEI); 
#else
  Config -> dmacfi = DMA_RGETH(hDma,DMACFI); 
  Config -> dmacei = DMA_RGETH(hDma,DMACEI); 
#endif
  IRQ_globalRestore(oldgie);
  return;
}
/*----------------------------------------------------------------------------*/

#endif /* DMA_SUPPORT */
/******************************************************************************\
* End of DMA_gcfg.c
\******************************************************************************/


dma_open.c/     1049976986  0     0     0       3900      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DMA
* FILENAME...... DMA_open.c
* DATE CREATED.. Fri 06/30/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999 (BWC) Created
*   MODIFIED: 06/30/2000 (IC) Modified for C55xx   
*   MODIFIED: 06/29/2001 added pragma for sectiuon per function and
*                        updated for new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the DMA module)
*
*
*
\******************************************************************************/
#define _DMA_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dma.h>

#if (_DMA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA static macro declarations
\****************************************/

/****************************************\
* DMA static typedef declarations
\****************************************/

/****************************************\
* DMA static function declarations
\****************************************/

/****************************************\
* DMA static variable definitions
\****************************************/

/****************************************\
* DMA static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA global variable definitions
\****************************************/

/****************************************\
* DMA global function definitions
\****************************************/

#pragma CODE_SECTION(DMA_open,".text:DMA_open");

/*----------------------------------------------------------------------------*/
  DMA_Handle DMA_open(int ChaNum, Uint32 Flags) {

  DMA_Handle hDma = INV;
  int cha = ChaNum;

  int oldgie;

  oldgie = IRQ_globalDisable();    

  #ifdef _MCRTE_DEBUG
  if (!((ChaNum==-1)||(ChaNum>=0)&&(ChaNum<DMA_CHA_CNT))) {
    ERR_submit(DMA_ERR_MAJOR, DMA_ERR_ALLOC);
    IRQ_restoreGie();
    return (DMA_Handle)INV;
  }
  #endif

  if (ChaNum==-1) {
    for (cha=0; cha<DMA_CHA_CNT; cha++) {
      if (!(CSL_SYS_DATA.DmaAllocMask & (1u<<cha))) {
        hDma = DMA_hCha(cha);
        break;
      }
    }
  } else if (!(CSL_SYS_DATA.DmaAllocMask & (1u<<cha))) {
    hDma = DMA_hCha(ChaNum);
  }

  #ifdef _MCRTE_DEBUG
    if (hDma == INV) {
      ERR_submit(DMA_ERR_MAJOR, DMA_ERR_ALLOC);
      IRQ_restoreGie();
      return (DMA_Handle)INV;
  }
  #endif

  if (hDma != INV) {
    CSL_SYS_DATA.DmaAllocMask |= 1u<<cha;
  
    if (Flags & DMA_OPEN_RESET) {
      DMA_reset(hDma);
    }
  }


  IRQ_globalRestore(oldgie);

  return hDma;
}
/*----------------------------------------------------------------------------*/

#endif /* DMA_SUPPORT */
/******************************************************************************\
* End of DMA_open.c
\******************************************************************************/

dma_reset.c/    1049976988  0     0     0       4052      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... DMA
* FILENAME...... DMA_reset.c
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999 
*   MODIFIED: 03/27/2001 Modified to support 5510PG2.0
*   MODIFIED: 06/29/2001 added pragma for section per program
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the DMA module)
*
*
*
\******************************************************************************/
#define _DMA_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_dma.h>

#if (_DMA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA static macro declarations
\****************************************/

/****************************************\
* DMA static typedef declarations
\****************************************/

/****************************************\
* DMA static function declarations
\****************************************/

/****************************************\
* DMA static variable definitions
\****************************************/

/****************************************\
* DMA static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* DMA global variable definitions
\****************************************/

/****************************************\
* DMA global function definitions
\****************************************/

#pragma CODE_SECTION(DMA_reset,".text:DMA_reset")

/*----------------------------------------------------------------------------*/
void DMA_reset(DMA_Handle hDma) {

  int oldgie;
  int i;

  oldgie = IRQ_globalDisable();  
  if (hDma == INV) {

  for (i = 0; i <=DMA_CHA_CNT-1; i++){

   DMA_Handle tmp = DMA_hCha(i);
    DMA_reset(tmp);
  }
  } else {

    DMA_RSETH(hDma,DMACSDP,DMA_DMACSDP_DEFAULT);
    DMA_RSETH(hDma,DMACCR,DMA_DMACCR_DEFAULT);  
    DMA_RSETH(hDma,DMACICR,DMA_DMACICR_DEFAULT);  
    DMA_RSETH(hDma,DMACSSAL,DMA_DMACSSAL_DEFAULT);  
    DMA_RSETH(hDma,DMACSSAU,DMA_DMACSSAU_DEFAULT);  
    DMA_RSETH(hDma,DMACDSAL,DMA_DMACDSAL_DEFAULT);  
    DMA_RSETH(hDma,DMACDSAU,DMA_DMACDSAU_DEFAULT); 
    DMA_RSETH(hDma,DMACEN,DMA_DMACEN_DEFAULT);  
    DMA_RSETH(hDma,DMACFN,DMA_DMACFN_DEFAULT); 
#if _DMA_DST_AND_SRC_INDEX_SUPPORT
    DMA_RSETH(hDma,DMACSFI,DMA_DMACSFI_DEFAULT);                       
    DMA_RSETH(hDma,DMACSEI,DMA_DMACSEI_DEFAULT);  
    DMA_RSETH(hDma,DMACDFI,DMA_DMACDFI_DEFAULT);                       
    DMA_RSETH(hDma,DMACDEI,DMA_DMACDEI_DEFAULT);
#else  
    DMA_RSETH(hDma,DMACFI,DMA_DMACFI_DEFAULT);                       
    DMA_RSETH(hDma,DMACEI,DMA_DMACEI_DEFAULT);  
#endif
    DMA_FSETH(hDma,DMACCR,PRIO,0); 
 
    IRQ_disable(((DMA_PrivateObj *)hDma)->EventId);
    IRQ_clear(((DMA_PrivateObj *)hDma)->EventId);
  }
  IRQ_globalRestore(oldgie);
  return;
}
#endif /* DMA_SUPPORT */
/******************************************************************************\
* End of DMA_reset.c
\******************************************************************************/

emifA_cfg.c/    1049976989  0     0     0       5032      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... EMIF
* FILENAME...... emif_cfga.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999 
*   MODIFIED: 12/06/2000 Modification for C54x.
*   MODIFIED: 05/18/2000 Modified for C55xx.
*   MODIFIED: 05/16/2001 renamed typedef EMIF_CONFIG -> EMIF_Config
*   MODIFIED: 06/29/2001 added pragma for section per function
*   MODIFIED: 08/14/2001 added code for 5509 memfreq emif workaround
*   MODIFIED: 10/11/2002 removed write to EMIF_emirst register
*   MODIFIED: 11/22/2002 added 5509A to XBSR test
*   MODIFIED: 11/25/2002 added check for SDRAM with MEMFREQ != 1xCPUCLK
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the Cache module)
*
*
*
\******************************************************************************/
#define _EMIF_MOD_

/****************************************\
* include files
\****************************************/    
#include <csl_chiphal.h>

#if (CHIP_5509) || (CHIP_5509A)
    #include <csl_chip.h>
#endif   
 
#if (_EMIFA_SUPPORT)
#include <csl_emif.h> 

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF static macro declarations
\****************************************/
/* See cache.h Romability */
 
 
/****************************************\
* EMIF static typedef declarations
\****************************************/

/****************************************\
* EMIF static function declarations
\****************************************/

/****************************************\
* EMIF Variable definitions : ROMability 
\****************************************/

/* Definition Romability See emif.h */


             
/****************************************\
* EMIF static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF global variable definitions
\****************************************/
/* Definition See emif.h */
/*----------------------------------------------------------------------------*/

             
/****************************************\
* EMIF global function definitions
\****************************************/

#pragma CODE_SECTION(EMIF_config,".text:EMIF_config")

/*----------------------------------------------------------------------------*/
void EMIF_config(EMIF_Config *Config) {

  int oldgie;
  oldgie = IRQ_globalDisable();

#if ((CHIP_5509) || (CHIP_5509A))
        if ((Config->egcr & _EMIF_EGCR_MEMFREQ_MASK) >= 0x200u)
         CHIP_FSET(XBSR,EMIFX2,1);
#endif
	  EMIF_RSET(EGCR,Config -> egcr);     
        EMIF_RSET(CE01,Config -> ce01); 
        EMIF_RSET(CE02,Config -> ce02);
        EMIF_RSET(CE03,Config -> ce03);
        EMIF_RSET(CE11,Config -> ce11); 
        EMIF_RSET(CE12,Config -> ce12);
        EMIF_RSET(CE13,Config -> ce13);
        EMIF_RSET(CE21,Config -> ce21); 
        EMIF_RSET(CE22,Config -> ce22);
        EMIF_RSET(CE23,Config -> ce23);
        EMIF_RSET(CE31,Config -> ce31); 
        EMIF_RSET(CE32,Config-> ce32);
        EMIF_RSET(CE33,Config -> ce33);
        EMIF_RSET(SDC1,Config -> sdc1);
        EMIF_RSET(SDPER,Config -> sdper);
        EMIF_RSET(INIT,Config -> init);
        EMIF_RSET(SDC2,Config -> sdc2);

#if (CHIP_5509A)
   {
     Uint16 clkMem = Config->egcr & _EMIF_EGCR_MEMFREQ_MASK;
     Uint16 mMask = _EMIF_CE01_MTYPE_MASK;
     Uint16 mSdram = ((Config->ce01 & mMask) != 0) ||
                     ((Config->ce11 & mMask) != 0) ||
                     ((Config->ce21 & mMask) != 0) ||
                     ((Config->ce31 & mMask) != 0);
     if (clkMem && mSdram) {
        _EMIF_IPMR = 0x0000u;
     }
   }
#endif


  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* EMIF_SUPPORT */
/******************************************************************************\
* End of emif_cfga.c
\******************************************************************************/
emifA_cfgb.c/   1049976991  0     0     0       4891      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... EMIF
* FILENAME...... emif_cfgb.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999 
*   MODIFIED: 12/06/2000 Modification for C54x.
*   MODIFIED: 05/18/2000 Modified for C55xx.
*   MODIFIED: 06/29/2001 added pragma for section per function
*   MODIFIED: 10/11/2002 removed write to EMIF_emirst register
*   MODIFIED: 11/21/2002 added 5509A to XBSR test
*   MODIFIED: 11/25/2002 added heck for SDRAM & MEMFREQ != 1x CPUCLK
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the Cache module)
*
*
*
\******************************************************************************/
#define _EMIF_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_emif.h> 

#if ((CHIP_5509) || (CHIP_5509A))
  #include <csl_chip.h>
#endif
 
#if (_EMIFA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF static macro declarations
\****************************************/
/* See cache.h Romability */
 
 
/****************************************\
* EMIF static typedef declarations
\****************************************/

/****************************************\
* EMIF static function declarations
\****************************************/

/****************************************\
* EMIF Variable definitions : ROMability 
\****************************************/

/* Definition Romability See emif.h */


             
/****************************************\
* EMIF static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF global variable definitions
\****************************************/
/* Definition See emif.h */
/*----------------------------------------------------------------------------*/

             
/****************************************\
* EMIF global function definitions
\****************************************/

#pragma CODE_SECTION(EMIF_configArgs,".text:EMIF_configArgs")

/*----------------------------------------------------------------------------*/


void EMIF_configArgs(Uint16 egcr, Uint16 emirst, Uint16 ce01,\
  Uint16 ce02, Uint16 ce03, Uint16 ce11, Uint16 ce12, Uint16 ce13,\
  Uint16 ce21, Uint16 ce22, Uint16 ce23, Uint16 ce31, Uint16 ce32,\
  Uint16 ce33, Uint16 sdc1, Uint16 sdper, Uint16 init,\
  Uint16 sdc2)

 {

  int oldgie;

  oldgie = IRQ_globalDisable(); 
#if ((CHIP_5509) || (CHIP_5509A))
        if ((egcr & _EMIF_EGCR_MEMFREQ_MASK) >= 0x200u)
         CHIP_FSET(XBSR,EMIFX2,1);
#endif

	  EMIF_RSET(EGCR,egcr);     
        EMIF_RSET(CE01,ce01); 
        EMIF_RSET(CE02,ce02);
        EMIF_RSET(CE03,ce03);
        EMIF_RSET(CE11,ce11); 
        EMIF_RSET(CE12,ce12);
        EMIF_RSET(CE13,ce13);
        EMIF_RSET(CE21,ce21); 
        EMIF_RSET(CE22,ce22);
        EMIF_RSET(CE23,ce23);
        EMIF_RSET(CE31,ce31); 
        EMIF_RSET(CE32,ce32);
        EMIF_RSET(CE33,ce33);
        EMIF_RSET(SDC1,sdc1);
        EMIF_RSET(SDPER,sdper);
        EMIF_RSET(INIT,init);
        EMIF_RSET(SDC2,sdc2);

#if (CHIP_5509A)
   {
     Uint16 clkMem = egcr & _EMIF_EGCR_MEMFREQ_MASK;
     Uint16 mMask = _EMIF_CE01_MTYPE_MASK;
     Uint16 mSdram = ((ce01 & mMask) != 0) ||
                     ((ce11 & mMask) != 0) ||
                     ((ce21 & mMask) != 0) ||
                     ((ce31 & mMask) != 0);
     if (clkMem && mSdram) {
        _EMIF_IPMR = 0x0000u;
     }
   }
#endif

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* EMIF_SUPPORT */
/******************************************************************************\
* End of emif_cfgb.c
\******************************************************************************/

emifA_entersr.c/1049976992  0     0     0       5093      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... EMIF
* FILENAME...... emif_entersr.c
* DATE CREATED.. Fri 11/22/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  11/22/2002 - EMIF self-refresh mode 
*------------------------------------------------------------------------------
* DESCRIPTION: 
*    Performs self-refresh for EMIF connnected to SDRAM
*
\******************************************************************************/
#define _EMIF_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_emif.h> 

#if ((CHIP_5509) || (CHIP_5509A))
    #include <csl_chip.h>
#endif   
 
#if (_EMIFA_SUPPORT) && (_EMIF_SELFREFRESH_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF static macro declarations
\****************************************/
/* See cache.h Romability */
 
 
/****************************************\
* EMIF static typedef declarations
\****************************************/

/****************************************\
* EMIF static function declarations
\****************************************/

/****************************************\
* EMIF Variable definitions : ROMability 
\****************************************/

/* Definition Romability See emif.h */


             
/****************************************\
* EMIF static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF global variable definitions
\****************************************/
/* Definition See emif.h */
/*----------------------------------------------------------------------------*/

             
/****************************************\
* EMIF global function definitions
\****************************************/

#pragma CODE_SECTION(EMIF_enterSelfRefresh,".text:EMIF_enterSelfRefresh")

/*----------------------------------------------------------------------------*/
void EMIF_enterSelfRefresh(Uint16 ckePin, Uint16 tRasDelay) {

#if (CHIP_5509A)

  int oldgie;
  Uint16 preChargeCnt;
  Uint16 i;


  oldgie = IRQ_globalDisable();


          /*    SDRAM self refresh procedure starts here    */

          /*  1.	Software selects the pin to be used for CKE: GPIO4 */

          CHIP_FSET(XBSR,CKE,ckePin);

      /*  2.	Software sets Bit # 7 of Bus Selection Register to 1 (CKE En=1)
        and Bit #6 to 0 (SR Com=0).SR Com must be zero until setup is completed.*/

         CHIP_FSET(XBSR,CKEEN,EMIF_CKEEN_ENABLED);

/*  3.	No accesses to external memory are permitted beyond this step.*/
    
/*  4.	Software needs to wait for a pre-charge command. Pre-charge command is 
        performed when doing an auto-refresh. To wait for a pre-charge command,
        software polls the SDRAM Counter Register and detect when this register
        counts down to 0 and is reloaded with the Period Register. When this 
        change occurs, EMIF sends a precharge command with A10 high to precharge
        all banks.    */
   
        while(EMIF_RGET(SDCNT));
        while(EMIF_RGET(SDCNT) != EMIF_RGET(SDPER));

/*  5.	Wait for the auto refresh to complete (30 clock cycles).      */

        preChargeCnt = 0x30 * ( 1 << EMIF_FGET(EGCR,MEMFREQ));
        while (--preChargeCnt){
            asm("\tNOP      ; Code Auto-Generated by CSL");
        }
        
  
/*  6.	Software sets RFEN= 0 deactivating auto-refresh mode in the EMIF     */
  
        EMIF_FSET(SDC1,RFEN,EMIF_SDC1_RFEN_DISABLE);

  
    
/*  7.	Software sets SR Com=1.*/
    
        CHIP_FSET(XBSR,SRCOM,EMIF_SRCOM_ENABLE);
    
/* Wait for minimum time in refresh */

       for(i=0;i<=tRasDelay-1; i++){
           asm("\tNOP     ; Code Generated by CSL");
       }       

  IRQ_globalRestore(oldgie);

 #endif

}
/*----------------------------------------------------------------------------*/

#endif /* EMIF_SUPPORT */
/******************************************************************************\
* End of emif_entersr.c
\******************************************************************************/

emifA_exitsr.c/ 1049976994  0     0     0       4277      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... EMIF
* FILENAME...... emif_exitsr.c
* DATE CREATED.. Fri 11/22/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  11/22/2002 - EMIF self-refresh mode 
*------------------------------------------------------------------------------
* DESCRIPTION: 
*    Performs self-refresh for EMIF connnected to SDRAM
*
\******************************************************************************/
#define _EMIF_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_emif.h> 
#include <csl_pwr.h>

#if ((CHIP_5509) || (CHIP_5509A))
    #include <csl_chip.h>
#endif   
 
#if (_EMIFA_SUPPORT) && (_EMIF_SELFREFRESH_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF static macro declarations
\****************************************/
/* See cache.h Romability */
 
 
/****************************************\
* EMIF static typedef declarations
\****************************************/

/****************************************\
* EMIF static function declarations
\****************************************/

/****************************************\
* EMIF Variable definitions : ROMability 
\****************************************/

/* Definition Romability See emif.h */


             
/****************************************\
* EMIF static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF global variable definitions
\****************************************/
/* Definition See emif.h */
/*----------------------------------------------------------------------------*/

             
/****************************************\
* EMIF global function definitions
\****************************************/

#pragma CODE_SECTION(EMIF_exitSelfRefresh,".text:EMIF_exitSelfRefresh")

void EMIF_exitSelfRefresh(Uint16 tXsrDelay) {

#if (CHIP_5509A)

 int oldgie;
 Uint16 i;


/* Only execute function if EMIF is not IDLEed */
   
    if ((_PWR_ISTR & _PWR_ISTR_EMIFIS_MASK) != 0) {
        return;
    }

   oldgie = IRQ_globalDisable();

/*  Exiting self refresh mode */

    
/* ENABLE CLKMEM */

     EMIF_FSET(EGCR,MEMCEN,EMIF_EGCR_MEMCEN_ENABLED);
     
/*  1.	Software sets SR Com=0,  disabling self refresh command and driving XF high.*/

     CHIP_FSET(XBSR,SRCOM,EMIF_SRCOM_DISABLED);

/*  2.	Wait until tXSR for a on-going self refresh to complete (around 100ns).*/
     
     for(i=0; i<=tXsrDelay; i++) {
       asm("\tNOP         ; Code Auto-Generated by CSL");
     }
/*  3.	Software sets RFEN= 1, exiting self refresh mode and entering auto refresh mode.   */

     EMIF_FSET(SDC1,RFEN,EMIF_SDC1_RFEN_ENABLE);

/*  4.	Write to EMIFF Initialization Register to re-initialize the EMIF. */

    EMIF_RSET(SDINIT,0x0000u);
    
        while(EMIF_RGET(SDCNT));
        while(EMIF_RGET(SDCNT) != EMIF_RGET(SDPER));

  IRQ_globalRestore(oldgie);
 
 #endif

}
/*----------------------------------------------------------------------------*/

#endif /* EMIF_SUPPORT */
/******************************************************************************\
* End of emif_exitsr.c
\******************************************************************************/

emifA_gcfg.c/   1049976996  0     0     0       4044      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... EMIF
* FILENAME...... emif_gcfg.c
* DATE CREATED.. Thu  05/10/2001 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  05/10/2001
*   MODIFIED: 05/16/2001 renamed typedef EMIF_CONFIG->EMIF_Config
*   MODIFIED: 06/29/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the Cache module)
*
*
*
\******************************************************************************/
#define _EMIF_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_emif.h> 
   
 
#if (_EMIFA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF static macro declarations
\****************************************/
/* See cache.h Romability */
 
 
/****************************************\
* EMIF static typedef declarations
\****************************************/

/****************************************\
* EMIF static function declarations
\****************************************/

/****************************************\
* EMIF Variable definitions : ROMability 
\****************************************/

/* Definition Romability See emif.h */


             
/****************************************\
* EMIF static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF global variable definitions
\****************************************/
/* Definition See emif.h */
/*----------------------------------------------------------------------------*/

             
/****************************************\
* EMIF global function definitions
\****************************************/

#pragma CODE_SECTION(EMIF_getConfig,".text:EMIF_getConfig")

/*----------------------------------------------------------------------------*/
void EMIF_getConfig(EMIF_Config *Config) {

  int oldgie;

  oldgie = IRQ_globalDisable();

	  Config -> egcr = EMIF_RGET(EGCR);     
        Config -> ce01 = EMIF_RGET(CE01); 
        Config -> ce02 = EMIF_RGET(CE02);
        Config -> ce03 = EMIF_RGET(CE03);
        Config -> ce11 = EMIF_RGET(CE11); 
        Config -> ce12 = EMIF_RGET(CE12);
        Config -> ce13 = EMIF_RGET(CE13);
        Config -> ce21 = EMIF_RGET(CE21); 
        Config -> ce22 = EMIF_RGET(CE22);
        Config -> ce23 = EMIF_RGET(CE23);
        Config -> ce31 = EMIF_RGET(CE31); 
        Config -> ce32 = EMIF_RGET(CE32);
        Config -> ce33 = EMIF_RGET(CE33);
        Config -> sdc1 = EMIF_RGET(SDC1);
        Config -> sdper = EMIF_RGET(SDPER);
        Config -> init = EMIF_RGET(INIT);
        Config -> sdc2 = EMIF_RGET(SDC2);

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* EMIF_SUPPORT */
/******************************************************************************\
* End of emif_gcfg.c
\******************************************************************************/
emifB_cfg.c/    1049976997  0     0     0       4140      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... EMIF
* FILENAME...... emif_cfga.c
* DATE CREATED.. Tues 02/12/2002 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/12/2002 for 5502 EMIF 
*   MODIFIED: 03/27/2003 Changed register names as per SPRU621A
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the 5502 EMIF configuration function)
*
*
*
\******************************************************************************/
#define _EMIF_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_emif.h> 
  
 
#if (_EMIFB_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF static macro declarations
\****************************************/
/* See cache.h Romability */
 
 
/****************************************\
* EMIF static typedef declarations
\****************************************/

/****************************************\
* EMIF static function declarations
\****************************************/

/****************************************\
* EMIF Variable definitions : ROMability 
\****************************************/

/* Definition Romability See emif.h */


             
/****************************************\
* EMIF static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF global variable definitions
\****************************************/
/* Definition See emif.h */
/*----------------------------------------------------------------------------*/

             
/****************************************\
* EMIF global function definitions
\****************************************/

#pragma CODE_SECTION(EMIF_config,".text:EMIF_config")

/*----------------------------------------------------------------------------*/
void EMIF_config(EMIF_Config *Config) {
  ioport EMIF_RegObj *regPtr = (CSL_EMIF_DATA).regs;
  int oldgie;

  oldgie = IRQ_globalDisable();

	(regPtr->gblctl1) = Config->gblctl1;
	(regPtr->gblctl2) = Config->gblctl2;
	(regPtr->ce1ctl1) = Config->ce1ctl1;
	(regPtr->ce1ctl2) = Config->ce1ctl2;
	(regPtr->ce0ctl1) = Config->ce0ctl1;
	(regPtr->ce0ctl2) = Config->ce0ctl2;
	(regPtr->ce2ctl1) = Config->ce2ctl1;
	(regPtr->ce2ctl2) = Config->ce2ctl2;
	(regPtr->ce3ctl1) = Config->ce3ctl1;
	(regPtr->ce3ctl2) = Config->ce3ctl2;
	(regPtr->sdctl1)  = Config->sdctl1;
	(regPtr->sdctl2)  = Config->sdctl2;
	(regPtr->sdrfr1)  = Config->sdrfr1;
	(regPtr->sdrfr2)  = Config->sdrfr2;
	(regPtr->sdext1)  = Config->sdext1;
	(regPtr->sdext2)  = Config->sdext2;
	(regPtr->ce1sec1) = Config->ce1sec1;
	(regPtr->ce0sec1) = Config->ce0sec1;
	(regPtr->ce2sec1) = Config->ce2sec1;
	(regPtr->ce3sec1) = Config->ce3sec1;
      (regPtr->cescr)   = Config->cescr;

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* EMIF_SUPPORT */
/******************************************************************************\
* End of emif_cfga.c
\******************************************************************************/
emifB_cfgb.c/   1049976999  0     0     0       4581      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... EMIF
* FILENAME...... emif_cfgb.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999 
*   MODIFIED: 12/06/2000 Modification for C54x.
*   MODIFIED: 05/18/2000 Modified for C55xx.
*   MODIFIED: 06/29/2001 added pragma for section per function
*   MODIFIED: 03/27/2003 Updated register names as per SPRU621A
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the Cache module)
*
*
*
\******************************************************************************/
#define _EMIF_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_emif.h> 

#if (CHIP_5509)
  #include <csl_chip.h>
#endif
 
#if (_EMIFB_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF static macro declarations
\****************************************/
/* See cache.h Romability */
 
 
/****************************************\
* EMIF static typedef declarations
\****************************************/

/****************************************\
* EMIF static function declarations
\****************************************/

/****************************************\
* EMIF Variable definitions : ROMability 
\****************************************/

/* Definition Romability See emif.h */


             
/****************************************\
* EMIF static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF global variable definitions
\****************************************/
/* Definition See emif.h */
/*----------------------------------------------------------------------------*/

             
/****************************************\
* EMIF global function definitions
\****************************************/

#pragma CODE_SECTION(EMIF_configArgs,".text:EMIF_configArgs")

/*----------------------------------------------------------------------------*/


void EMIF_configArgs(Uint16 gblctl1,Uint16 gblctl2,Uint16 ce1ctl1,
                     Uint16 ce1ctl2,Uint16 ce0ctl1,Uint16 ce0ctl2,
                     Uint16 ce2ctl1,Uint16 ce2ctl2,Uint16 ce3ctl1,
                     Uint16 ce3ctl2,Uint16 sdctl1,Uint16 sdctl2,
                     Uint16 sdrfr1,Uint16 sdrfr2,Uint16 sdext1,
                     Uint16 sdext2,Uint16 ce1sec1,Uint16 ce0sec1,
                     Uint16 ce2sec1,Uint16 ce3sec1, Uint16 cescr){

  ioport EMIF_RegObj *regPtr = (CSL_EMIF_DATA).regs;
  int oldgie;

  oldgie = IRQ_globalDisable();

	(regPtr->gblctl1) = gblctl1;
	(regPtr->gblctl2) = gblctl2;
	(regPtr->ce1ctl1) = ce1ctl1;
	(regPtr->ce1ctl2) = ce1ctl2;
	(regPtr->ce0ctl1) = ce0ctl1;
	(regPtr->ce0ctl2) = ce0ctl2;
	(regPtr->ce2ctl1) = ce2ctl1;
	(regPtr->ce2ctl2) = ce2ctl2;
	(regPtr->ce3ctl1) = ce3ctl1;
	(regPtr->ce3ctl2) = ce3ctl2;
	(regPtr->sdctl1)  = sdctl1;
	(regPtr->sdctl2)  = sdctl2;
	(regPtr->sdrfr1)  = sdrfr1;
	(regPtr->sdrfr2)  = sdrfr2;
	(regPtr->sdext1)  = sdext1;
	(regPtr->sdext2)  = sdext2;
	(regPtr->ce1sec1) = ce1sec1;
	(regPtr->ce0sec1) = ce0sec1;
	(regPtr->ce2sec1) = ce2sec1;
	(regPtr->ce3sec1) = ce3sec1;
      (regPtr->cescr)   = cescr;

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* EMIF_SUPPORT */
/******************************************************************************\
* End of emif_cfgb.c
\******************************************************************************/

emifB_gcfg.c/   1049977001  0     0     0       4234      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... EMIF
* FILENAME...... emif_gcfg.c
* DATE CREATED.. Thu  05/10/2001 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  05/10/2001
*   MODIFIED: 05/16/2001 renamed typedef EMIF_CONFIG->EMIF_Config
*   MODIFIED: 06/29/2001 added pragma for section per function
*   MODIFIED: 03/27/2003 Updated register names as per SPRU621A
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the Cache module)
*
*
*
\******************************************************************************/
#define _EMIF_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_emif.h> 
   
 
#if (_EMIFB_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF static macro declarations
\****************************************/
/* See cache.h Romability */
 
 
/****************************************\
* EMIF static typedef declarations
\****************************************/

/****************************************\
* EMIF static function declarations
\****************************************/

/****************************************\
* EMIF Variable definitions : ROMability 
\****************************************/

/* Definition Romability See emif.h */


             
/****************************************\
* EMIF static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* EMIF global variable definitions
\****************************************/
/* Definition See emif.h */
/*----------------------------------------------------------------------------*/

             
/****************************************\
* EMIF global function definitions
\****************************************/

#pragma CODE_SECTION(EMIF_getConfig,".text:EMIF_getConfig")

/*----------------------------------------------------------------------------*/
void EMIF_getConfig(EMIF_Config *Config) {

  ioport EMIF_RegObj *regPtr = (CSL_EMIF_DATA).regs;
  int oldgie;

  oldgie = IRQ_globalDisable();

	Config->gblctl1 = (regPtr->gblctl1);
	Config->gblctl2 = (regPtr->gblctl2);
	Config->ce1ctl1 = (regPtr->ce1ctl1);
	Config->ce1ctl2 = (regPtr->ce1ctl2);
	Config->ce0ctl1 = (regPtr->ce0ctl1);
	Config->ce0ctl2 = (regPtr->ce0ctl2);
	Config->ce2ctl1 = (regPtr->ce2ctl1);
	Config->ce2ctl2 = (regPtr->ce2ctl2);
	Config->ce3ctl1 = (regPtr->ce3ctl1);
	Config->ce3ctl2 = (regPtr->ce3ctl2);
	Config->sdctl1 = (regPtr->sdctl1);
	Config->sdctl2 = (regPtr->sdctl2);
	Config->sdrfr1 = (regPtr->sdrfr1);
	Config->sdrfr2 = (regPtr->sdrfr2);
	Config->sdext1 = (regPtr->sdext1);
	Config->sdext2 = (regPtr->sdext2);
	Config->ce1sec1 = (regPtr->ce1sec1);
	Config->ce0sec1 = (regPtr->ce0sec1);
	Config->ce2sec1 = (regPtr->ce2sec1);
	Config->ce3sec1 = (regPtr->ce3sec1);
      Config->cescr = (regPtr->cescr);

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* EMIF_SUPPORT */
/******************************************************************************\
* End of emif_gcfg.c
\******************************************************************************/
err_dhand.c/    1049977008  0     0     0       3359      `

/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ERR
* FILENAME...... ERR_dHandler.c
* DATE CREATED.. Tue 06/22/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/22/1999 
*   MODIFIED: 02/22/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 07/13/2000 Modified for C55x
*   MODIFIED: 06/29/2001 added pragma for section per function and updated
*                        for new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ERR module)
*
*
*
\******************************************************************************/
#define _ERR_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_err.h> 

#if (_ERR_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ERR static macro declarations
\****************************************/

/****************************************\
* ERR static typedef declarations
\****************************************/

/****************************************\
* ERR static function declarations
\****************************************/

/****************************************\
* ERR static variable definitions
\****************************************/
/* See err.h for global macro definitions */ 


/****************************************\
* ERR static function definitions
\****************************************/ 

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ERR global variable definitions
\****************************************/


/****************************************\
* ERR global function definitions
\****************************************/ 

#pragma CODE_SECTION(ERR_defaultHandler,".text:ERR_defaultHandler")

/*----------------------------------------------------------------------------*/
void ERR_defaultHandler(Uint32 Major, Uint32 Minor) {
  CSL_SYS_DATA.ErrCnt++;
  UNREFERENCED_PARAMETER(Major);
  UNREFERENCED_PARAMETER(Minor);
}

/*----------------------------------------------------------------------------*/
#endif /* ERR_SUPPORT */
/******************************************************************************\
* End of ERR_dHandler.c
\******************************************************************************/


err_getcnt.c/   1049977010  0     0     0       3248      `

/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ERR
* FILENAME...... ERR_getCount.c
* DATE CREATED.. Tue 06/22/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/22/1999 
*   MODIFIED: 02/22/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 07/13/2000 Modified for C55x
*   MODIFIED: 06/29/2001 added pragma for section per function and updated for
*                        new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ERR module)
*
*
*
\******************************************************************************/
#define _ERR_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_err.h> 

#if (_ERR_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ERR static macro declarations
\****************************************/

/****************************************\
* ERR static typedef declarations
\****************************************/

/****************************************\
* ERR static function declarations
\****************************************/

/****************************************\
* ERR static variable definitions
\****************************************/
/* See err.h for global macro definitions */ 


/****************************************\
* ERR static function definitions
\****************************************/ 
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ERR global variable definitions
\****************************************/


/****************************************\
* ERR global function definitions
\****************************************/ 

#pragma CODE_SECTION(ERR_getCount,".text:ERR_getCount")

/*----------------------------------------------------------------------------*/
Uint16 ERR_getCount() {
  return CSL_SYS_DATA.ErrCnt;
}/*----------------------------------------------------------------------------*/
#endif /* ERR_SUPPORT */
/******************************************************************************\
* End of ERR_getCount.c
\******************************************************************************/

err_ihand.c/    1049977011  0     0     0       3283      `

/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ERR
* FILENAME...... ERR_iHandler.c
* DATE CREATED.. Tue 06/22/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/22/1999 
*   MODIFIED: 02/22/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 07/13/2000 Modified for C55x
*   MODIFIED: 06/29/2001 added pragma for section per function and updated
*                        for new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ERR module)
*
*
*
\******************************************************************************/
#define _ERR_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_err.h>

#if (_ERR_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ERR static macro declarations
\****************************************/

/****************************************\
* ERR static typedef declarations
\****************************************/

/****************************************\
* ERR static function declarations
\****************************************/

/****************************************\
* ERR static variable definitions
\****************************************/
/* See err.h for global macro definitions */ 


/****************************************\
* ERR static function definitions
\****************************************/ 
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ERR global variable definitions
\****************************************/


/****************************************\
* ERR global function definitions
\****************************************/ 

#pragma CODE_SECTION(ERR_installHandler,".text:ERR_installHandler")

/*----------------------------------------------------------------------------*/
/* ErrFunc points the user's ErrHandler function */
void ERR_installHandler(ERR_Handler Handler) {

   CSL_SYS_DATA.ErrFunc = (Uint32)Handler;
}
#endif /* ERR_SUPPORT */
/******************************************************************************\
* End of ERR_iHandler.c
\******************************************************************************/


err_submit.c/   1049977013  0     0     0       3297      `

/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ERR
* FILENAME...... ERR_submit.c
* DATE CREATED.. Tue 06/22/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/22/1999 
*   MODIFIED: 02/22/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 07/13/2000 Modified for C55x
*   MODIFIED: 06/29/2001 added pragma for section per function and updated for
*                        new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ERR module)
*
*
*
\******************************************************************************/
#define _ERR_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_err.h> 

#if (_ERR_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ERR static macro declarations
\****************************************/

/****************************************\
* ERR static typedef declarations
\****************************************/

/****************************************\
* ERR static function declarations
\****************************************/

/****************************************\
* ERR static variable definitions
\****************************************/
/* See err.h for global macro definitions */ 


/****************************************\
* ERR static function definitions
\****************************************/ 

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ERR global variable definitions
\****************************************/


/****************************************\
* ERR global function definitions
\****************************************/ 

#pragma CODE_SECTION(ERR_submit,".text:ERR_submit")

/*----------------------------------------------------------------------------*/
  void ERR_submit(Uint32 Major, Uint32 Minor) {

  (*(ERR_Handler*)(CSL_SYS_DATA.ErrFunc))(Major,Minor); 
}
/*----------------------------------------------------------------------------*/
#endif /* ERR_SUPPORT */
/******************************************************************************\
* End of ERR_submit.c
\******************************************************************************/


gpio_cfg.c/     1049977015  0     0     0       1747      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_cfg.c
* DATE CREATED.. Tues 04/23/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  04/23/2002
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non-power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_chiphal.h>

#if (CHIP_5502_FAMILY)
   #if (_GPIO_SUPPORT)

   #include <csl_gpio.h>

   #pragma CODE_SECTION(GPIO_config,".text:GPIO_config")

   /*----------------------------------------------------------------------------*/
   void GPIO_config(GPIO_Handle hGpio, GPIO_Config *cfg) {
      GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;

      if (ptr->regIndx == _GPIO_NON_PARALLEL) {
         *((ioport Uint16 *)(ptr->dirReg)) = cfg->iodir;
         return;
      }
   #if (_GPIO_PARALLEL_SUPPORT)
      *((ioport Uint16 *)(ptr->enableReg)) = cfg->ioen & (ptr->pinsAllocated);
      *((ioport Uint16 *)(ptr->dirReg)) = cfg->iodir;
   #endif
   }
   #endif /* GPIO_SUPPORT */
#endif
/******************************************************************************\
* End of gpio_cfg.c
\******************************************************************************/

gpio_cfga.c/    1049977017  0     0     0       1909      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_cfga.c
* DATE CREATED.. Tues 04/23/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  04/23/2002
*   MODIFIED: 12/13/2002 merged 5502/5509/5510 support
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non-power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_chiphal.h>

#if (CHIP_5502_FAMILY)
   #if (_GPIO_SUPPORT)

   #include <csl_gpio.h>

   #pragma CODE_SECTION(GPIO_configArgs,".text:GPIO_configArgs")

   /*----------------------------------------------------------------------------*/
   #if (_GPIO_PARALLEL_SUPPORT)
    void GPIO_configArgs(GPIO_Handle hGpio, Uint32 enabMask, Uint16 direction) {
   #else
    void GPIO_configArgs(GPIO_Handle hGpio, Uint16 direction) {
   #endif
       GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
 

       if (ptr->regIndx == _GPIO_NON_PARALLEL) {
         *(ioport Uint16 *)(ptr->dirReg) = direction;
         return;
       }

   #if (_GPIO_PARALLEL_SUPPORT)
       *(ioport Uint16 *)(ptr->enableReg) = enabMask & (ptr->pinsAllocated);
   #endif    
 
    }
   #endif /* GPIO_SUPPORT */
#endif
/******************************************************************************\
* End of gpio_cfg.c
\******************************************************************************/

gpio_cfgall.c/  1070358978  0     0     0       1881      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_cfgall.c
* DATE CREATED.. Tues 04/23/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED: 04/23/2002
*   	   : 12/13/2002 merged 5502/5509/5510 support
*   	   : 12/02/2003 Fixed the typo in '#if' statement
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non-power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_chiphal.h>

#if (CHIP_5502_FAMILY)
   #if (_GPIO_SUPPORT)

   #include <csl_gpio.h>

   #pragma CODE_SECTION(GPIO_configAll,".text:GPIO_configAll")

   /*----------------------------------------------------------------------------*/
   void GPIO_configAll(GPIO_ConfigAll *gCfg) {

        GPIO_RSET(IODIR,gCfg->iodir);
   #if (_GPIO_PARALLEL_SUPPORT)
         GPIO_RSET(PGPIOEN0,gCfg->pgpioen0);
         GPIO_RSET(PGPIODIR0,gCfg->pgpiodir0);
         GPIO_RSET(PGPIOEN1,gCfg->pgpioen1);
         GPIO_RSET(PGPIODIR1,gCfg->pgpiodir1);
   #if (CHIP_5502)
         GPIO_RSET(PGPIOEN2,gCfg->pgpioen2);
         GPIO_RSET(PGPIODIR2,gCfg->pgpiodir2);
   #endif
   #endif
   }
   #endif /* GPIO_SUPPORT */
#endif
/******************************************************************************\
* End of gpio_cfgall.c
\******************************************************************************/

gpio_cfgallA.c/ 1070358978  0     0     0       2276      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_cfgall.c
* DATE CREATED.. Tues 04/23/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED: 04/23/2002
*          : 12/13/2002 merged 5502/5509/5510 support
*          : 12/02/2003 Fixed typo in '#if' statement
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non-power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_chiphal.h>

#if (CHIP_5502_FAMILY)

   #if (_GPIO_SUPPORT)

   #include <csl_gpio.h>

   #pragma CODE_SECTION(GPIO_configAllArgs,".text:GPIO_configAllArgs")

   /*----------------------------------------------------------------------------*/
   #if (CHIP_5502)
          void GPIO_configAllArgs(GPIO_Handle hGpio, Uint16 iodir, Uint16 pgpioen0, Uint16 pgpiodir0,
          Uint16 pgpioen1, Uint16 pgpiodir1, Uint16 pgpioen2, Uint16 pgpiodir2) {
   #elif (CHIP_5509)
          void GPIO_configAllArgs(GPIO_Handle hGpio, Uint16 iodir, Uint16 pgpioen0, Uint16 pgpiodir0,
          Uint16 pgpioen1, Uint16 pgpiodir1) {
   #else
          void GPIO_configAllArgs(GPIO_Handle hGpio, Uint16 iodir) {
   #endif

     GPIO_RSET(IODIR,iodir);

      #if (_GPIO_PARALLEL_SUPPORT)
         GPIO_RSET(PGPIOEN0,pgpioen0);
         GPIO_RSET(PGPIODIR0,pgpiodir0);
         GPIO_RSET(PGPIOEN1,pgpioen1);
         GPIO_RSET(PGPIODIR1,pgpiodir1);
    #if (CHIP_5502)
         GPIO_RSET(PGPIOEN2,pgpioen2);
         GPIO_RSET(PGPIODIR2,pgpiodir2);
   #endif
   #endif
   }
   #endif /* GPIO_SUPPORT */
#endif
/******************************************************************************\
* End of gpio_cfgall.c
\******************************************************************************/
gpio_close.c/   1065617103  0     0     0       1661      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_close.c
* DATE CREATED.. Tues 04/23/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED : 04/23/2002
*   MODIFIED: 12/13/2002 merge 5502/5509/5510 support
*   MODIFIED: 10/07/2003 Fixed GPIO_close() bug.
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non-power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_chiphal.h>

#if (CHIP_5502_FAMILY)

   #if (_GPIO_SUPPORT)

   #include <csl_gpio.h>

   #pragma CODE_SECTION(GPIO_close,".text:GPIO_close")

   /*----------------------------------------------------------------------------*/
   IDEF void GPIO_close(GPIO_Handle hGpio) {
      GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
      Uint16 regIndx = (ptr->regIndx);

      (CSL_SYS_DATA).GpioAllocMask[regIndx] = 0;
      ptr->pinsAllocated = 0x0000;
   }
  
   #endif /* GPIO_SUPPORT */
#endif
/******************************************************************************\
* End of gpio_open.c
\******************************************************************************/

gpio_dir.c/     1049977024  0     0     0       2281      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_pdir.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  07/31/2001
*   MODIFIED: 01/22/2002 Fixed problem with setting only to GPIO0
*   MODIFIED: 12/13/2002 merged 5502/5510/5509 support
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_gpio.h>

#if (CHIP_5502)

   #if (_GPIO_SUPPORT)

   #pragma CODE_SECTION(GPIO_pinDirection,".text:GPIO_pinDirection")

   /*------------------------------------------------------*/
   void GPIO_pinDirection(GPIO_Handle hGpio, Uint32 pinMask, Uint16 direction){
      GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
      Uint16 pins = (Uint16)(pinMask & 0xFFFFu);
      Uint16 allocMask = ptr->pinsAllocated;
      *((ioport Uint16 *)(ptr->dirReg)) = ((*((ioport Uint16 *)(ptr->dirReg))) 
                                          & (~(allocMask & pins))) | ((direction) ? pins:0x0000u);
   }
   #endif /* GPIO_SUPPORT */
#else 
   #if ((_GPIO_SUPPORT) && (!_GPIO_PGPIO_SUPPORT))

   #pragma CODE_SECTION(_GPIO_pinDirection,".text:_GPIO_pinDirection")

   /*------------------------------------------------------*/
   int _GPIO_pinDirection(Uint32 pinId, Uint16 direction){
      Uint16 pin = (Uint16)(pinId & 0xFFFFu);
      _GPIO_IODIR = (_GPIO_IODIR & ~(pin)) | ((direction) ? pin : 0);
      return ((_GPIO_IODIR & pin) ? 1:0);
   }
   #endif /* GPIO_SUPPORT */
#endif     /* CHIP_5502 */
/******************************************************************************\
* End of gpio_pdir.c
\******************************************************************************/

gpio_disab.c/   1065617103  0     0     0       2211      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_disab.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  07/31/2001
*   MODIFIED: 01/22/2002 changed to return single value
*   MODIFIED: 12/13/2002 merged 5502/5510/5509 support
*   MODIFIED: 10/07/2003 Fixed GPIO-pinDisable() bug.
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_gpio.h>

#if (CHIP_5502_FAMILY)
   #if (_GPIO_SUPPORT)

   #pragma CODE_SECTION(GPIO_pinDisable,".text:GPIO_pinDisable")

   /*------------------------------------------------------*/
   IDEF void GPIO_pinDisable(GPIO_Handle hGpio, Uint32 pinId){
     GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
     Uint16 allocMask;
     Uint16 pin = (Uint16)(pinId & 0xFFFFu);

      allocMask = ptr->pinsAllocated;
      if (ptr->regIndx == _GPIO_NON_PARALLEL) {
        return;
      }
      *((ioport Uint16 *)(ptr->enableReg)) = (*((ioport Uint16 *)(ptr->enableReg))) 
                                              & (~(allocMask & pin));

   }
  #endif /* GPIO_SUPPORT */
#else
   #if ((_GPIO_SUPPORT) && (!_GPIO_PGPIO_SUPPORT))

   #pragma CODE_SECTION(_GPIO_pinDisable,".text:_GPIO_pinDisable")

   /*------------------------------------------------------*/
   int _GPIO_pinDisable(Uint32 pinId){
     return 1;
   }
   #endif /* GPIO_SUPPORT */
#endif   /* CHIP_5502 */

/******************************************************************************\
* End of gpio_disab.c
\******************************************************************************/

gpio_enab.c/    1049977028  0     0     0       2231      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_enab.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  07/31/2001
*   MODIFIED: 01/22/2002 changed to return single value
*   MODIFIED: 12/09/2002 added conditional compilation for non-5502
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the power non-muxed GPIO module)
*               Enables pin function during idle/power-down
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_gpio.h>

#if ((_GPIO_SUPPORT) && (!_GPIO_PGPIO_SUPPORT))

#if (CHIP_5502_FAMILY)

  #pragma CODE_SECTION(GPIO_pinEnable,".text:GPIO_pinEnable")

  /*----------------------------------------------------------------------------*/
  void GPIO_pinEnable(GPIO_Handle hGpio, Uint32 pinId){
    GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
    Uint16 allocMask;
    Uint16 pin = (Uint16)(pinId & 0xFFFFu);

     allocMask = ptr->pinsAllocated;
     if (ptr->regIndx == _GPIO_NON_PARALLEL) {
       return;
     }
     *((ioport Uint16 *)(ptr->enableReg)) = *((ioport Uint16 *)(ptr->enableReg)) 
                                            | (allocMask & pin);

     }
  #endif /* GPIO_SUPPORT */

 #else
   #if ((_GPIO_SUPPORT) && (!_GPIO_PGPIO_SUPPORT))

   #pragma CODE_SECTION(_GPIO_pinEnable,".text:_GPIO_pinEnable")

   /*------------------------------------------------------*/
   int _GPIO_pinEnable(Uint32 pinId){
     return 1;
   }
   #endif /* GPIO_SUPPORT */
 #endif
/******************************************************************************\
* End of gpio_enab.c
\******************************************************************************/

gpio_open.c/    1065617104  0     0     0       1994      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_open.c
* DATE CREATED.. Tues 04/23/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED :   04/23/2002
*   MODIFIED:   10/06/2003 Fixed GPIO_open() bug.

*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non-power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_chiphal.h>

#if (_GPIO_SUPPORT)

#include <csl_gpio.h>

#if (CHIP_5502_FAMILY)

  #pragma CODE_SECTION(GPIO_open,".text:GPIO_open")

  /*----------------------------------------------------------------------------*/
  GPIO_Handle GPIO_open(Uint32 allocMask, Uint32 flags){
    Uint16 regIndx = (Uint16)((allocMask >> 16) & 0xFFFFu);
    Uint16 pinMask = (Uint16)(allocMask & 0xFFFFu); 
    Uint16 old_intm;
    GPIO_PrivateObj *ptr = INV;

    old_intm = IRQ_globalDisable();

     if (!((CSL_SYS_DATA).GpioAllocMask[regIndx] )) {
      (CSL_SYS_DATA).GpioAllocMask[regIndx] = pinMask; /*allocated;*/
      ptr = (GPIO_PrivateObj *)(&((CSL_GPIO_DATA).pinObj[regIndx]));
      ptr->regIndx = regIndx;
      ptr->pinsAllocated = pinMask;
    }

    IRQ_globalRestore(old_intm);

    return (GPIO_Handle)(ptr);
  }
  #endif /* CHIP_5502_FAMILY */
#endif /* GPIO_SUPPORT */
/******************************************************************************\
* End of gpio_open.c
\******************************************************************************/
gpio_read.c/    1049977031  0     0     0       2125      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_read.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  07/31/2001
*   MODIFIED: 01/22/2002 changed to return 1 pin value instead of
*                        several
*   MODIFIED: 12/13/2002 merged 5502/5509/5510 support
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non-power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_chiphal.h>

#include <csl_gpio.h>

#if (CHIP_5502_FAMILY)
  #if (_GPIO_SUPPORT)

  #pragma CODE_SECTION(GPIO_pinRead,".text:GPIO_pinRead")

  /*----------------------------------------------------------------------------*/
  int GPIO_pinRead(GPIO_Handle hGpio, Uint32 pinId){
    GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;  
    Uint16 pins = (Uint16)(pinId & 0xFFFFu);
    Uint16 val;
  
    val =  ((*((ioport Uint16 *)(ptr->datReg))) & (ptr->pinsAllocated & pins));
    return (val ? 1:0);
  }
#else
   #if ((_GPIO_SUPPORT) && (!_GPIO_PGPIO_SUPPORT))

   #pragma CODE_SECTION(_GPIO_pinRead,".text:_GPIO_pinRead")

   /*----------------------------------------------------------------------------*/
    int _GPIO_pinRead(Uint32 pinId){
     Uint16 pin = (Uint16)(pinId & 0xFFFFu);
     return ((_GPIO_IODATA & pin) ? 1:0);
   }
   #endif /* GPIO_SUPPORT */
#endif

#endif /* GPIO_SUPPORT */
/******************************************************************************\
* End of gpio_read.c
\******************************************************************************/

gpio_readA.c/   1049977032  0     0     0       1676      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_readA.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  04/23/2002
*   MODIFIED: 12/09/2002 added conditional compilation for non-5502 
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non-power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_chiphal.h>

#if (_GPIO_SUPPORT)

#include <csl_gpio.h>

#if (CHIP_5502_FAMILY)

#pragma CODE_SECTION(GPIO_pinReadAll,".text:GPIO_pinReadAll")

/*----------------------------------------------------------------------------*/
int GPIO_pinReadAll(GPIO_Handle hGpio, Uint32 pinMask){
  GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;  
  Uint16 pins = (Uint16)(pinMask & 0xFFFFu);
  Uint16 val;
  
  val =  ((*((ioport Uint16 *)(ptr->datReg))) & (ptr->pinsAllocated & pins));
  return (val);
}
#endif /* CHIP_5502_FAMILY */
#endif /* GPIO_SUPPORT */
/******************************************************************************\
* End of gpio_read.c
\******************************************************************************/
gpio_reset.c/   1049977034  0     0     0       1907      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_reset.c
* DATE CREATED.. Tues 04/23/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  04/23/2002
*   MODIFIED: 12/09/2002 added conditional compile for non-5502 devices
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non-power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_chiphal.h>

#if (_GPIO_SUPPORT)

#if (CHIP_5502_FAMILY)

#include <csl_gpio.h>

#pragma CODE_SECTION(GPIO_pinReset,".text:GPIO_pinReset")

/*----------------------------------------------------------------------------*/
void GPIO_pinReset(GPIO_Handle hGpio, Uint32 pinMask) {
  GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
  Uint16 allocMask = ptr->pinsAllocated;

#if (_GPIO_PARALLEL_SUPPORT) || (_GPIO_AGPIO_SUPPORT)
  *((ioport Uint16 *)(ptr->enableReg)) = *(ioport Uint16 *)(ptr->enableReg)
                                       & (~(allocMask & pinMask));
#endif
  *((ioport Uint16 *)(ptr->dirReg)) = (*((ioport Uint16 *)(ptr->dirReg)) &
                                    (~(allocMask & pinMask)));
}
#endif /* CHIP_5502_FAMILY */

#endif /* GPIO_SUPPORT */
/******************************************************************************\
* End of gpio_reset.c
\******************************************************************************/

gpio_write.c/   1049977036  0     0     0       2271      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_write.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  07/31/2001
*   MODIFIED: 01/22/2002 Fixed problem with write only to GPIO0
*   MODIFIED: 12/09/2002 merged 5502/5509/5510 support
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_chiphal.h>

#if (CHIP_5502_FAMILY)
  #if (_GPIO_SUPPORT)

  #include <csl_gpio.h>

  #pragma CODE_SECTION(GPIO_pinWrite,".text:GPIO_pinWrite")

  /*------------------------------------------------------*/
  void GPIO_pinWrite(GPIO_Handle hGpio, Uint32 pinMask, Uint16 val){
    GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;  
    Uint16 pins = (Uint16)(pinMask & 0xFFFFu);
    Uint16 allocMask = ptr->pinsAllocated;
     *((ioport Uint16 *)(ptr->datReg)) = ((*((ioport Uint16 *)(ptr->datReg))) 
                                         & (~(allocMask & pins))) | ((val) ? pins:0x0000u);
  }
  #endif
#else
   #if ((_GPIO_SUPPORT) && (!_GPIO_PGPIO_SUPPORT))

   #include <csl_gpio.h>
   
   #pragma CODE_SECTION(_GPIO_pinWrite,".text:_GPIO_pinWrite")

   /*------------------------------------------------------*/
   int _GPIO_pinWrite(Uint32 pinId, Uint16 val){
     Uint16 pin = (Uint16)(pinId & 0xFFFFu);
     _GPIO_IODATA = (_GPIO_IODATA & (~pin)) | ((val)? pin:0);
     return ((_GPIO_IODATA & pin) ? 1:0);
   }
   #endif /* GPIO_SUPPORT */
#endif /* CHIP_5502_FAMILY */
/******************************************************************************\
* End of gpio_write.c
\******************************************************************************/

gpio_writeA.c/  1049977038  0     0     0       1745      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_writeA.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  04/23/2002
*   MODIFIED: 12/09/2002 made conditional compile for non-5502 devices
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_gpio.h>

#if (CHIP_5502_FAMILY)

  #if (_GPIO_SUPPORT)

  #pragma CODE_SECTION(GPIO_pinWriteAll,".text:GPIO_pinWriteAll")

  /*------------------------------------------------------*/
  void GPIO_pinWriteAll(GPIO_Handle hGpio, Uint32 pinMask, Uint16 val){
    GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;  
    Uint16 pins = (Uint16)(pinMask & 0xFFFFu);
    Uint16 allocMask = ptr->pinsAllocated;
     *((ioport Uint16 *)(ptr->datReg)) = ((*((ioport Uint16 *)(ptr->datReg))) 
                                         & (~(allocMask & pins))) | val;
  }
  #endif /* GPIO_SUPPORT */
#endif /* CHIP_5502_FAMILY */
/******************************************************************************\
* End of gpio_write.c
\******************************************************************************/

gpt_cfg.c/      1049977040  0     0     0       4112      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_cfg.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 
*   MODIFIED : 03/12/2003 changed structure member names
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the 5502 General Purpose 64 bit timer)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT static macro declarations
\****************************************/
/* See gpt.h Romability */
 
/****************************************\
* GPT static typedef declarations
\****************************************/

/****************************************\
* GPT static function declarations
\****************************************/

/****************************************\
* GPT Variable definitions : ROMability 
\****************************************/

/* Definition Romability See GPT.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See GPT.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_config,".text:GPT_config")

/*----------------------------------------------------------------------------*/
void GPT_config(GPT_Handle hGpt, GPT_Config *Config) {
  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;

  GPT_ASSERT_HANDLE(hGpt,return);

    oldgie = IRQ_globalDisable();  
 
   (regPtr->gptgctl1) = 0x0000u;
   (regPtr->gptgpint) = Config->gptgpint;
   (regPtr->gptgpen) = Config->gptgpen;
   (regPtr->gptgpdir) = Config->gptgpdir;
   (regPtr->gptgpdat) = Config->gptgpdat;
   (regPtr->gptprd1) = Config->gptprd1;
   (regPtr->gptprd2) = Config->gptprd2;
   (regPtr->gptprd3) = Config->gptprd3;
   (regPtr->gptprd4) = Config->gptprd4;
   (regPtr->gptctl1) = Config->gptctl1;
   (regPtr->gptctl2) = Config->gptctl2;
   (regPtr->gptgctl1) = Config->gptgctl1;  
  
  IRQ_globalRestore(oldgie); 
 
}
/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of gpt_cfg.c
\******************************************************************************/

gpt_cfgb.c/     1049977041  0     0     0       3540      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_cfgB.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 Created for C6x
*   MODIFIED : 03/12/2003 changed structure member names
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the 5502 General Purpose Timer module)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_gpt.h>
   

#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See csl_gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_configArgs,".text:GPT_configArgs")

/*----------------------------------------------------------------------------*/
void GPT_configArgs(GPT_Handle hGpt, Uint16 gptemu, 
            Uint16 gptprd1,Uint16 gptprd2,Uint16 gptprd3,Uint16 gptprd4,
            Uint16 gptgpint,Uint16 gptgpen,Uint16 gptgpdir,Uint16 gptgpdat,
            Uint16 gptctl1,Uint16 gptctl2,Uint16 gptgctl1) {
  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;
  
  GPT_ASSERT_HANDLE(hGpt,return);
   
  oldgie = IRQ_globalDisable(); 
  
 

   (regPtr->gptgctl1) = 0x0000u;
   (regPtr->gptgpint) = gptgpint;
   (regPtr->gptgpen) = gptgpen;
   (regPtr->gptgpdir) = gptgpdir;
   (regPtr->gptgpdat) = gptgpdat;
   (regPtr->gptprd1) = gptprd1;
   (regPtr->gptprd2) = gptprd2;
   (regPtr->gptprd3) = gptprd3;
   (regPtr->gptprd4) = gptprd4;
   (regPtr->gptctl1) = gptctl1;
   (regPtr->gptctl2) = gptctl2;
   (regPtr->gptgctl1) = gptgctl1;  

  
  IRQ_globalRestore(oldgie); 
}

/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_cfgb.c
\******************************************************************************/

gpt_close.c/    1049977043  0     0     0       2806      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_close.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the TIMER module)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    
#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* GPT global function definitions
\****************************************/
#pragma CODE_SECTION(GPT_close,".text:GPT_close")

/*----------------------------------------------------------------------------*/
void GPT_close(GPT_Handle hGpt) {
  int oldgie;
  GPT_ASSERT_HANDLE(hGpt,return);
    oldgie = IRQ_globalDisable(); 


  CSL_SYS_DATA.GptAllocMask &= (~(1u<<((GPT_PrivateObj*)hGpt)->devNum));   
  GPT_reset(hGpt);
  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_close.c
\******************************************************************************/

gpt_gcfg.c/     1049977044  0     0     0       3606      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_gcfg.c
* DATE CREATED.. Sun 02/10/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*    CREATED:   02/10/2002
*   MODIFIED : 03/12/2003 changed structure member names
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the 5502 General Purpose Timer module)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    
#include "csl_irq.h"
#include "csl_chip.h"  
#include "csl.h"      
#include "csl_gpt.h"
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

             
/****************************************\
* GPT static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_getConfig,".text:GPT_getConfig")

/*----------------------------------------------------------------------------*/
void GPT_getConfig(GPT_Handle hGpt, GPT_Config *Config) {
  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;
  GPT_ASSERT_HANDLE(hGpt,return);

    oldgie = IRQ_globalDisable();  
  
  Config->gptemu  =  (regPtr->gptemu);
  Config->gptgpint =  (regPtr->gptgpint);
  Config->gptgpen =  (regPtr->gptgpen);
  Config->gptgpdir =  (regPtr->gptgpdir);
  Config->gptgpdat =  (regPtr->gptgpdat);
  Config->gptprd1 =  (regPtr->gptprd1);
  Config->gptprd2 =  (regPtr->gptprd2);
  Config->gptprd3 =  (regPtr->gptprd3);
  Config->gptprd4 =  (regPtr->gptprd4);
  Config->gptctl1 =  (regPtr->gptctl1);
  Config->gptctl2 =  (regPtr->gptctl2);
  Config->gptgctl1 =  (regPtr->gptgctl1); 
  IRQ_globalRestore(oldgie); 
 
}
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_gcfg.c
\******************************************************************************/

gpt_gcnt.c/     1049977046  0     0     0       3048      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_gcnt.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Get snapshot of Timer counter (5502))
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    
#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See csl_gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_getCnt,".text:GPT_getCnt")

/*----------------------------------------------------------------------------*/
void GPT_getCnt (GPT_Handle hGpt, Uint32 *tim34, Uint32 *tim12) {
   ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;
   Uint16 tim1,tim2,tim3,tim4;
   
   // Access TIM1 first to cause copy of tim2/3/4 to
   // shadow registers to preserve snapshot

   tim1 =  (regPtr->gptcnt1);  
   tim2 =  (regPtr->gptcnt2);
   tim3 =  (regPtr->gptcnt3);
   tim4 =  (regPtr->gptcnt4);

   *tim12 = ((Uint32)tim2 << 16u) | tim1;
   *tim34 = ((Uint32)tim4 << 16u) | tim3;
}
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_stop.c
\******************************************************************************/

gpt_init32.c/   1067582949  0     0     0       2482      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_init32.c
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:   02/10/2002 
*   MODIFIED : 10/28/2003 Fixed the bug to configure gptgctl1 register
*              03/12/2003 changed structure member names
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for initializing 32 bit Dual mode
*                for 5502 general purpose timer)
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_gpt.h>
 
#if (_GPT_SUPPORT)
             
/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_initDual32,".text:GPT_initDual32")

/*----------------------------------------------------------------------------*/
void GPT_initDual32(GPT_Handle hGpt, Uint16 dt1ctl, Uint16 dt2ctl, 
           Uint32 dt1prd, Uint32 dt2prd, Uint16 dt2prsc){
  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;

  GPT_ASSERT_HANDLE(hGpt,return);

    oldgie = IRQ_globalDisable();  
 
   (regPtr->gptgctl1) = 0x0000u;
   (regPtr->gptprd1) = dt1prd;
   (regPtr->gptprd2) = dt2prd;
   (regPtr->gptctl1) = dt1ctl;
   (regPtr->gptctl2) = dt2ctl;
   (regPtr->gptgctl1) = GPT_FMK(GPTGCTL1,TIMMODE,1) |
   						((dt2prsc & 0xF) << 8);  
  
  IRQ_globalRestore(oldgie); 
 
}
/*----------------------------------------------------------------------------*/

#endif /* _GPT_SUPPORT */
/******************************************************************************\
* End of gpt_init32.c
\******************************************************************************/

gpt_init64.c/   1049977049  0     0     0       3883      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_init64.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 
*   MODIFIED : 03/12/2003 changed structure member names
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for initializing 64 bit mode
*                for 5502 general purpose timer)
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT static macro declarations
\****************************************/
/* See gpt.h Romability */
 
/****************************************\
* GPT static typedef declarations
\****************************************/

/****************************************\
* GPT static function declarations
\****************************************/

/****************************************\
* GPT Variable definitions : ROMability 
\****************************************/

/* Definition Romability See GPT.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See GPT.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_init64,".text:GPT_init64")

/*----------------------------------------------------------------------------*/
void GPT_init64(GPT_Handle hGpt, Uint16 gptgctl, Uint16 dt12ctl, Uint32 prdHigh, Uint32 prdLow){
  int oldgie;
  
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;

  GPT_ASSERT_HANDLE(hGpt,return);

    oldgie = IRQ_globalDisable();  
 
  (regPtr->gptgctl1) = 0x0000u;
  (regPtr->gptprd1) = prdLow;
  (regPtr->gptprd2) = prdHigh;
  (regPtr->gptctl1) = dt12ctl;
  (regPtr->gptgctl1) = GPT_FMK(GPTGCTL1,TIMMODE,0);  
  
  IRQ_globalRestore(oldgie); 
 
}
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_init64.c
\******************************************************************************/


gpt_initC32.c/  1049977051  0     0     0       3928      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_initC32.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 
*   MODIFIED : 03/12/2003 changed structure member names
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for initializing 32 bit Chained mode
*                for 5502 general purpose timer)
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT static macro declarations
\****************************************/
/* See gpt.h Romability */
 
/****************************************\
* GPT static typedef declarations
\****************************************/

/****************************************\
* GPT static function declarations
\****************************************/

/****************************************\
* GPT Variable definitions : ROMability 
\****************************************/

/* Definition Romability See GPT.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See GPT.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_initChained32,".text:GPT_initChained32")

/*----------------------------------------------------------------------------*/
 void GPT_initChained32(GPT_Handle hGpt, Uint16 gctl, Uint16 ctl1,
           Uint32 prdHigh, Uint32 prdLow){

  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;

  GPT_ASSERT_HANDLE(hGpt,return);

    oldgie = IRQ_globalDisable();  
 
   (regPtr->gptgctl1) = 0x0000u;
   (regPtr->gptprd1) = prdLow;
   (regPtr->gptprd2) = prdHigh;
   (regPtr->gptctl1) = ctl1;
   (regPtr->gptgctl1) = gctl | GPT_FMK(GPTGCTL1,TIMMODE,3);  
  
  IRQ_globalRestore(oldgie); 
 
}
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_initC32.c
\******************************************************************************/

gpt_open.c/     1049977052  0     0     0       4076      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... TIM_open.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999 Created 
*   MODIFIED: 12/06/2000 Modification for C54x .
*   MODIFIED: 02/18/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 05/30/2000 Created for C55x .
*   MODIFIED: 06/28/2001 updated for new CSL initialization model and
*                        included pragma for individual section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the TIMER module)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    

#include "csl_gpt.h"
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT static macro declarations
\****************************************/
/* See csl_gpt.h Romability */


/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See csl_gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_open,".text:GPT_open")

/*----------------------------------------------------------------------------*/
GPT_Handle GPT_open(int DevNum, Uint32 Flags) {

  GPT_Handle hGpt = (GPT_Handle)INV;
  Uint16 dev  = DevNum;
  int oldgie;

  oldgie = IRQ_globalDisable();  
 
 
  #ifdef _MCRTE_DEBUG
  if (!((DevNum == -1)||(DevNum>=0&&GPT_DEVICE_CNT))) {
    ERR_submit(GPT_ERR_MAJOR, GPT_ERR_ALLOC);
     IRQ_globalRestore(oldgie);
    return (GPT_Handle) INV;
  }
  #endif

  if (DevNum==-1) {
    for (dev=0; dev<GPT_DEVICE_CNT; dev++) {
      if (!(CSL_SYS_DATA.GptAllocMask & (1u<<dev))){
        hGpt = GPT_hDev(dev);
       break;
      }
    }
  } else if (!(CSL_SYS_DATA.GptAllocMask & (1u<<dev))){
    hGpt = GPT_hDev(dev);
  }

  #ifdef _MCRTE_DEBUG
    if (hGpt == INV) {
      ERR_submit(GPT_ERR_MAJOR, GPT_ERR_INVALID_HANDLE);
      IRQ_restoreGie();
      return (GPT_Handle)INV;
  }
  #endif

  if (hGpt != INV) {
     CSL_SYS_DATA.GptAllocMask |= 1u<<dev;     
     if (Flags & GPT_OPEN_RESET) {
       GPT_reset(hGpt);
     }
  }

  IRQ_globalRestore(oldgie);
  return hGpt;
}

/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_open.c
\******************************************************************************/

gpt_rstt.c/     1049977054  0     0     0       3366      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_rst.c
* DATE CREATED.. Sun 02/10/2002
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the GPT module)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/
    
#include <csl_gpt.h>
   
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER static macro declarations
\****************************************/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_reset,".text:GPT_reset")

/*----------------------------------------------------------------------------*/
void GPT_reset(GPT_Handle hGpt) {
  int oldgie;
  Uint16 EventId;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;

  oldgie = IRQ_globalDisable();  
    
  if (hGpt == INV) {    
 
      GPT_reset(GPT_hDev0);
      GPT_reset(GPT_hDev1);  
       
  } 
  else {
      EventId  = GPT_getEventId(hGpt);
      /* stop timer */  
       (regPtr->gptgctl1) = 0x0000u; 
      /* Reset Period Value=0xFFFF */
       (regPtr->gptprd1) = 0x0000u;
       (regPtr->gptprd2) = 0x0000u;
       (regPtr->gptprd3) = 0x0000u;
       (regPtr->gptprd4) = 0x0000u;
      IRQ_disable(EventId);
      IRQ_clear(EventId);
  }
  IRQ_globalRestore(oldgie);

}

/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_rst.c
\******************************************************************************/

gpt_start.c/    1049977056  0     0     0       2843      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_start.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Starts Timer Operation - assumes timer is preconfigured)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See csl_gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_start,".text:GPT_start")

/*----------------------------------------------------------------------------*/
void GPT_start(GPT_Handle hGpt) {

  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs; 

  oldgie = IRQ_globalDisable(); 
    
      /* Take Tim12 and Tim34 out of reset */

   (regPtr->gptgctl1) |= 0x3u;

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_start.c
\******************************************************************************/


gpt_start12.c/  1049977057  0     0     0       2846      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_start12.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Starts Timer12 Operation - assumes timer is preconfigured)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See csl_gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_start12,".text:GPT_start12")

/*----------------------------------------------------------------------------*/
void GPT_start12(GPT_Handle hGpt) {

  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs; 

  oldgie = IRQ_globalDisable(); 
    
      /* Take Tim12  out of reset */

   (regPtr->gptgctl1) |= 0x1u;

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_start12.c
\******************************************************************************/

gpt_start34.c/  1049977059  0     0     0       2846      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_start34.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Starts Timer34 Operation - assumes timer is preconfigured)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See csl_gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_start34,".text:GPT_start34")

/*----------------------------------------------------------------------------*/
void GPT_start34(GPT_Handle hGpt) {

  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs; 

  oldgie = IRQ_globalDisable(); 
    
      /* Take Tim34  out of reset */

   (regPtr->gptgctl1) |= 0x2u;

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_start34.c
\******************************************************************************/

gpt_stop.c/     1049977060  0     0     0       2909      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_stop.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Stops Timer Operation - assumes timer is preconfigured)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    
#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See csl_gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_stop,".text:GPT_stop")

/*----------------------------------------------------------------------------*/
void GPT_stop(GPT_Handle hGpt) {
  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;

  oldgie = IRQ_globalDisable(); 
    
      /* stop timer */  
  (regPtr->gptgctl1) &= 0xFFFCu;

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_stop.c
\******************************************************************************/


gpt_stpgp12.c/  1049977062  0     0     0       2920      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_stop12.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Stops Timer Operation - assumes timer is preconfigured)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    
#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See csl_gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_stop12,".text:GPT_stop12")

/*----------------------------------------------------------------------------*/
void GPT_stop12(GPT_Handle hGpt) {
  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;

  oldgie = IRQ_globalDisable(); 
    
      /* stop timer */  
   (regPtr->gptgctl1) &= 0xFFFEu;

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_stop12.c
\******************************************************************************/

gpt_stpgp34.c/  1049977063  0     0     0       2922      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... GPT
* FILENAME...... gpt_stop34.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Stops Timer Operation - assumes timer is preconfigured)
*
*
*
\******************************************************************************/
#define _GPT_MOD_

/****************************************\
* include files
\****************************************/    
#include <csl_gpt.h>
   
 
#if (_GPT_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See csl_gpt.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma CODE_SECTION(GPT_stop34,".text:GPT_stop34")

/*----------------------------------------------------------------------------*/
void GPT_stop34(GPT_Handle hGpt) {
 
   int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;

  oldgie = IRQ_globalDisable(); 
    
      /* stop timer */  
   (regPtr->gptgctl1) &= 0xFFFDu;

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of gpt_stop.c
\******************************************************************************/

hpi_cfg.c/      1051540724  0     0     0       1611      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... HPI
* FILENAME...... hpi_cfg.c
* DATE CREATED.. Thur 03/21/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  03/21/2002
*------------------------------------------------------------------------------
* DESCRIPTION:  
\******************************************************************************/
#define _HPI_MOD_

#include <csl_chiphal.h>

#if (_HPI_SUPPORT)

#include <csl_hpi.h>

#pragma CODE_SECTION(HPI_config,".text:HPI_config")

/*----------------------------------------------------------------------------*/
/*------------------------------------------------------*/
void HPI_config(HPI_Config *Config) {
   ioport HPI_RegObj *rPtr = (ioport HPI_RegObj*)(_HPI_BASE_ADDR);
   Uint16 old_intm;

   old_intm = IRQ_globalDisable();
   
   rPtr->hpwremu = Config->hpwremu;
   rPtr->hgpioen = Config->hgpioen;
   rPtr->hgpiodir = Config->hgpiodir;
   rPtr->hpic = Config->hpic;

   IRQ_globalRestore(old_intm);
}
#endif /* HPI_SUPPORT */
/******************************************************************************\
* End of hpi_cfg.c
\******************************************************************************/

hpi_gcfg.c/     1051540723  0     0     0       1738      `
/******************************************************************************\
*           Copyright (C) 2003 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... HPI
* FILENAME...... hpi_gcfg.c
* DATE CREATED.. WED 04/23/2003
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  04/24/2003
*------------------------------------------------------------------------------
* DESCRIPTION:  
\******************************************************************************/
#define _HPI_MOD_

#include <csl_chiphal.h>

#if (_HPI_SUPPORT)

#include <csl_hpihal.h>
#include <csl_hpi.h>

#pragma CODE_SECTION(HPI_getConfig,".text:HPI_getConfig")

/*----------------------------------------------------------------------------*/
/*------------------------------------------------------*/
void HPI_getConfig(HPI_Config *Config) {
  Uint16 old_intm;
  ioport HPI_RegObj *rPtr = (ioport HPI_RegObj*)(_HPI_BASE_ADDR);
  
   old_intm = IRQ_globalDisable();
   
   Config->hpwremu = rPtr->hpwremu ;
   Config->hgpioen = rPtr->hgpioen;
   Config->hgpiodir = rPtr->hgpiodir;
   Config->hpic = rPtr->hpic ;
   IRQ_globalRestore(old_intm);
    
}
/*----------------------------------------------------------------------------*/

#endif /* HPI_SUPPORT */
/******************************************************************************\
* End of hpi_gcfg.c
\******************************************************************************/

i2c_cfg.c/      1049977064  0     0     0       1439      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_cfg.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (I2C initialization)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_chiphal.h>

#if (_I2C_SUPPORT)

#include <csl_i2c.h>

#pragma CODE_SECTION(I2C_config,".text:I2C_config")

void I2C_config(I2C_Config *Config) {

  int old_intm;

  old_intm = IRQ_globalDisable();  
  I2C_RSET(I2COAR,Config->i2coar);
  I2C_RSET(I2CIER,Config->i2cier);
  I2C_RSET(I2CPSC,Config->i2cpsc);	
  I2C_RSET(I2CCLKL,Config->i2cclkl);
  I2C_RSET(I2CCLKH,Config->i2cclkh);
  I2C_RSET(I2CCNT,Config->i2ccnt);
  I2C_RSET(I2CSAR,Config->i2csar);				 
  I2C_RSET(I2CMDR,Config->i2cmdr);
  I2C_RSET(I2CSTR,Config->i2cstr);
  I2C_RSET(I2CISRC,Config->i2cisrc);
  IRQ_globalRestore(old_intm);   



}
#endif


i2c_cfga.c/     1049977066  0     0     0       1499      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_cfga.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (I2C initialization)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_chiphal.h>

#if (_I2C_SUPPORT)

#include <csl_i2c.h>

#pragma CODE_SECTION(I2C_configArgs,".text:I2C_configArgs")

IDEF void I2C_configArgs(Uint16 i2coar,Uint16 i2cier,Uint16 i2cstr,Uint16 i2cclkl,Uint16 i2cclkh,Uint16 i2ccnt,Uint16 i2csar,Uint16 i2cmdr,Uint16 i2cisrc,Uint16 i2cpsc) {

  int old_intm;

  old_intm = IRQ_globalDisable();  
  I2C_RSET(I2COAR,i2coar);
  I2C_RSET(I2CIER,i2cier);
  I2C_RSET(I2CPSC,i2cpsc);	
  I2C_RSET(I2CCLKL,i2cclkl);
  I2C_RSET(I2CCLKH,i2cclkh);
  I2C_RSET(I2CCNT,i2ccnt);
  I2C_RSET(I2CSAR,i2csar);				 
  I2C_RSET(I2CMDR,i2cmdr);
  I2C_RSET(I2CSTR,i2cstr);
  I2C_RSET(I2CISRC,i2cisrc);
  IRQ_globalRestore(old_intm);   

}
#endif



i2c_dispat.c/   1049977068  0     0     0       1541      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_dispatch.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (Default Interrupt Service Routine for processing I2C ints)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_chiphal.h>

#if (_I2C_SUPPORT)

#include <csl_i2c.h>

#pragma CODE_SECTION(I2C_intrDispatch,".text:I2C_intrDispatch")

interrupt void I2C_intrDispatch(void)   {

  if (I2C_FGET(I2CIER,AL))
  	((void (*)(void))(CSL_I2C_DATA).I2C_isrDispatchTable[I2C_EVT_AL])();
 
  if (I2C_FGET(I2CIER,NACK))
  	((void (*)(void))(CSL_I2C_DATA).I2C_isrDispatchTable[I2C_EVT_NACK])();
  
  if (I2C_FGET(I2CIER,ARDY))
  	((void (*)(void))(CSL_I2C_DATA).I2C_isrDispatchTable[3])();
  
  if (I2C_FGET(I2CIER,RRDY))
  	((void (*)(void))(CSL_I2C_DATA).I2C_isrDispatchTable[4])();		
  	
  if (I2C_FGET(I2CIER,XRDY))
  	((void (*)(void))(CSL_I2C_DATA).I2C_isrDispatchTable[5])();
  	
}
#endif


i2c_edab.c/     1049977069  0     0     0       1169      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_edab.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (Disable one/or more I2C interrupts)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_chiphal.h>

#if (_I2C_SUPPORT)

#include <csl_i2c.h>

#pragma CODE_SECTION(I2C_eventDisable,".text:I2C_eventDisable")

void I2C_eventDisable(Uint16 ierMask)  {
  
   Uint16 temp = I2C_RGET(I2CIER) & (~ierMask);
   I2C_RSET(I2CIER,temp);
   
     if ( !(I2C_RGET(I2CIER) & 0x001F) )
           IRQ_disable(IRQ_EVT_I2C);

}

#endif


i2c_enab.c/     1049977071  0     0     0       1101      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_enab.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (Enable/mask one/or more I2C interrupts)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_i2c.h>

#if (_I2C_SUPPORT)

#pragma CODE_SECTION(I2C_eventEnable,".text:i2C_eventEnable")

void I2C_eventEnable(Uint16 isrmask)  {

   Uint16 temp;
     temp = I2C_RGET(I2CIER) | (isrmask);
     I2C_RSET(I2CIER,temp);
     IRQ_enable(IRQ_EVT_I2C);


}

#endif


i2c_gcfg.c/     1049977072  0     0     0       1461      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_gcfg.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (I2C initialization)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_chiphal.h>

#if (_I2C_SUPPORT)

#include <csl_i2c.h>

#pragma CODE_SECTION(I2C_getConfig,".text:I2C_getConfig")

void I2C_getConfig(I2C_Config *Config) {

  int old_intm;

  old_intm = IRQ_globalDisable();
  Config->i2coar = I2C_RGET(I2COAR);
  Config->i2cier = I2C_RGET(I2CIER);
  Config->i2cpsc = I2C_RGET(I2CPSC);
  Config->i2cclkl = I2C_RGET(I2CCLKL);
  Config->i2cclkh = I2C_RGET(I2CCLKH);
  Config->i2ccnt = I2C_RGET(I2CCNT);
  Config->i2csar = I2C_RGET(I2CSAR);
  Config->i2cmdr = I2C_RGET(I2CMDR);
  Config->i2cstr = I2C_RGET(I2CSTR);
  Config->i2cisrc = I2C_RGET(I2CISRC);
  IRQ_globalRestore(old_intm);   



}
#endif


i2c_gevid.c/    1049977073  0     0     0       978       `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_getevid.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (Returns IRQ Event Id for I2C)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_i2c.h>

#if (_I2C_SUPPORT)

#pragma CODE_SECTION(I2C_getEventId,".text:I2C_getEventId")

int I2C_getEventId(void) {

  return IRQ_EVT_I2C;
  
}
#endif
i2c_init.c/     1049977075  0     0     0       1597      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_init.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (I2C initialization)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_chiphal.h>

#if (_I2C_SUPPORT)

#include <csl_i2c.h>

#pragma CODE_SECTION(I2C_init,".text:I2C_init")

void I2C_init(I2C_Init *Init) {

  int old_intm;
  Uint16 IPSC_calc;

  old_intm = IRQ_globalDisable();  
  
  
  
  I2C_RSET(I2CMDR,I2C_I2CMDR_RMK(Init->free,0,0,0,1,1,Init->addrmode,0,Init->dlb,1,0,0,Init->bitbyte));
    
/* set own address */  

  I2C_RSET(I2COAR,Init->ownaddr); /* if slave, need to specify own address */
  
/* calculating the IPSC value */
   	
  IPSC_calc = (Init->sysinclock)/12;  /* must correct rounding issue */
  I2C_RSET(I2CPSC,IPSC_calc);
  
/* calculating the ICCLKL and ICCLKH register values */ 
  
  I2C_RSET(I2CCLKL,15);
  I2C_RSET(I2CCLKH,15);    
  
  IRQ_globalRestore(old_intm);   

}   /* end of init  */
#endif


i2c_read.c/     1074583740  0     0     0       3892      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_receive.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:    08/02/2001
*   MODIFIED :  01/06/2003  I2C enhancement - reducing scope of global int. disable and enable
*------------------------------------------------------------------------------
* DESCRIPTION:  (I2C receive data)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_chiphal.h>

#if (_I2C_SUPPORT)

#include <csl_i2c.h>

#pragma CODE_SECTION(I2C_read,".text:I2C_read")

int I2C_read(Uint16 *data,int length,int master,Uint16 slaveaddress,int transfermode,int timeout, int checkbus)  {

  int i,j,k,m;
  int old_intm;  
  Uint16 temp;
  
  //old_intm = IRQ_globalDisable();  
  
  /* set in receive mode */
  I2C_FSET(I2CMDR,TRX,0);
   
  if (master==1) {
   
  I2C_RSET(I2CSAR,slaveaddress); /* specify slave address */
  I2C_FSET(I2CMDR,MST,1);      /* turn master mode on */
  
  /* setting the transfer mode */

  if (transfermode==1) {   /* S-A-D..(n)..D-P mode */
  I2C_FSET(I2CMDR,RM,0);
  I2C_FSET(I2CMDR,STP,1);
  
  /* setting the data count in the ICCNT register */  
  I2C_RSET(I2CCNT,length);    
  }
  
  else if (transfermode==2) {   /* S-A-D..(n)..D mode  (repeat n times)*/
  I2C_FSET(I2CMDR,RM,0);
  I2C_FSET(I2CMDR,STP,0);
  }
  
  else if (transfermode==3) {   /* S-A-D-D-D ... (repeat continuous) mode */
  I2C_FSET(I2CMDR,RM,1);
  I2C_FSET(I2CMDR,STP,0);
  }
  
  else {                   /* if user specifies something else, go to idle mode */
  I2C_FSET(I2CMDR,RM,0);
  I2C_FSET(I2CMDR,STP,0);
  }
  
  }  /* end if master */
   
  else {
  
  I2C_FSET(I2CMDR,MST,0);  /* if not master, set to slave */
  
  }  /* end set up */ 
    
      
  if (checkbus==1) {
	  
  old_intm = IRQ_globalDisable(); 
  
  for (i=0;i<=timeout;i++)  {   /* check for bus busy */
  temp=I2C_FGET(I2CSTR,BB);
  if (temp==0) break; 
  }
  
  IRQ_globalRestore(old_intm);

  
  if (i>=timeout)  /* bus busy timeout error */
    return 1;  
  
  }  /* end of bus busy */
  
  
                          /* generate start condition */
    I2C_FSET(I2CMDR,STT,1);  
  
                           /* delay loop to receive data */
      for (i=0;i<32000;i++)  {
      asm (" NOP");
      }
       
  
  for (j=0;j<=timeout;j++)  {   /* check for DRR status */
  temp=I2C_FGET(I2CSTR,RRDY);
  if (temp==1) break; 
  }
    
  if (j>=timeout) 
  	return 2;         /* time out for receive DRR ready */ 
   
  
  *data++ = I2C_RGET(I2CDRR);  /* put first data value in DXR */
                 
  
  for (k=1;k<length;k++)  {   /* enter main loop for receiving data */
  
     
      for (i=0;i<32000;i++)  {
      asm (" NOP");
      }
     
    
  
  for (m=0;m<=timeout;m++)  {   /* check for DRR status */
  temp=I2C_FGET(I2CSTR,RRDY);
  if (temp==1) break; 
  }
    
  if (m>=timeout) 
  	return 4;         /* time out for transmit DRR ready */ 
  	
  *data++ = I2C_RGET(I2CDRR);  /* put next data value in DXR */
     
  
  } /* end of for loop */
  
                       /* last delay loop */
      for (i=0;i<32000;i++)  {
      asm (" NOP");
      }
                            
                                                      
 
  //IRQ_globalRestore(old_intm);
  
  return 0;
  
}  /* end of I2C_receive */

#endif
i2c_setcall.c/  1049977078  0     0     0       1490      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_setcall.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (Sets call back function for I2C interrupts)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_chiphal.h>

#if (_I2C_SUPPORT)

#include <csl_i2c.h>

#pragma CODE_SECTION(I2C_setCallback,".text:I2C_setCallBack")

void I2C_setCallback(I2C_IsrAddr *isrAddr) {

    (CSL_I2C_DATA).I2C_isrDispatchTable[I2C_EVT_AL] = (Uint32) (isrAddr->alAddr); 
    (CSL_I2C_DATA).I2C_isrDispatchTable[I2C_EVT_NACK] = (Uint32) (isrAddr->nackAddr); 
    (CSL_I2C_DATA).I2C_isrDispatchTable[3] = (Uint32) (isrAddr->ardyAddr); 
    (CSL_I2C_DATA).I2C_isrDispatchTable[4] = (Uint32) (isrAddr->rrdyAddr); 
    (CSL_I2C_DATA).I2C_isrDispatchTable[5] = (Uint32) (isrAddr->xrdyAddr); 
    
       
    IRQ_plug(IRQ_EVT_I2C, I2C_intrDispatch);         
}

#endif

i2c_setup.c/    1049977079  0     0     0       1666      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_setup.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*   MODIFIED: 04/04/2002 CHanged name of function to I2C_setup
*------------------------------------------------------------------------------
* DESCRIPTION:  (I2C initialization)
*
*
*
\******************************************************************************/
#define _I2C_MOD_

#include <csl_chiphal.h>

#if (_I2C_SUPPORT)

#include <csl_i2c.h>

#pragma CODE_SECTION(I2C_setup,".text:I2C_setup")

void I2C_setup(I2C_Setup *Init) {

  int old_intm;
  Uint16 IPSC_calc;

  old_intm = IRQ_globalDisable();  
  
  
  
  I2C_RSET(I2CMDR,I2C_I2CMDR_RMK(Init->free,0,0,0,1,1,Init->addrmode,0,Init->dlb,1,0,0,Init->bitbyte));
    
/* set own address */  

  I2C_RSET(I2COAR,Init->ownaddr); /* if slave, need to specify own address */
  
/* calculating the IPSC value */
   	
  IPSC_calc = (Init->sysinclock)/12;  /* must correct rounding issue */
  I2C_RSET(I2CPSC,IPSC_calc);
  
/* calculating the ICCLKL and ICCLKH register values */ 
  
  I2C_RSET(I2CCLKL,15);
  I2C_RSET(I2CCLKH,15);    
  
  IRQ_globalRestore(old_intm);   

}   /* end of init  */
#endif

i2c_write.c/    1074583740  0     0     0       4426      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... I2C
* FILENAME...... i2c_write.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:    08/02/2001
*   MODIFIED :  01/06/2003  I2C enhancement - reducing scope of global int. disable and enable 
*------------------------------------------------------------------------------
* DESCRIPTION:  (I2C send data)
*
*
*
\******************************************************************************/
#define _I2C_MOD_


#include <csl_i2c.h>

#if (_I2C_SUPPORT)

#pragma CODE_SECTION(I2C_write,".text:I2C_write")

int I2C_write(Uint16 *data,int length,int master,Uint16 slaveaddress,int transfermode,int timeout)  {


  int i,j,k,l,m;
  int old_intm;  
  Uint16 temp=1;
  
  //old_intm = IRQ_globalDisable();  
  
  /* set in transmit mode */
  I2C_FSET(I2CMDR,TRX,1);
  
  I2C_RSET(I2CCNT,length);    /* set the count register */
   
  if (master==1) {
   
  I2C_RSET(I2CSAR,slaveaddress); /* specify slave address */
  I2C_FSET(I2CMDR,MST,1);      /* turn master mode on */
  
  /* setting the transfer mode */

  if (transfermode==1) {   /* S-A-D..(n)..D-P mode */
  I2C_FSET(I2CMDR,RM,0);
  I2C_FSET(I2CMDR,STP,1);
  
  }
  
  
  else if (transfermode==2) {   /* S-A-D..(n)..D mode  (repeat n times)*/
  I2C_FSET(I2CMDR,RM,0);
  I2C_FSET(I2CMDR,STP,0);
  }
  
  else if (transfermode==3) {   /* S-A-D-D-D ... (repeat continuous) mode */
  I2C_FSET(I2CMDR,RM,1);
  I2C_FSET(I2CMDR,STP,0);
  }
  
  else {                   /* if user specifies something else, go to idle mode */
  I2C_FSET(I2CMDR,RM,0);
  I2C_FSET(I2CMDR,STP,0);
  }
  
  }  /* end if master */
   
  else {
  
  I2C_FSET(I2CMDR,MST,0);  /* if not master, set to slave */
  
  }  /* end set up */

  old_intm = IRQ_globalDisable();      
  
  for (i=0;i<=timeout;i++)  {   /* check for bus busy */
  temp=I2C_FGET(I2CSTR,BB);
  if (temp==0) break; 
  }
  IRQ_globalRestore(old_intm);
  
  if (i>=timeout) {  /* bus busy timeout error */
    //IRQ_globalRestore(old_intm);
    return 1;
  }  
  
              
  for (m=0;m<=timeout;m++)  {   /* check for DXR status before first write*/

  temp=I2C_FGET(I2CSTR,XRDY);
  if (temp==1) break;                  
  }
          
  if (m>=timeout) {
    //IRQ_globalRestore(old_intm);
    return 2;         /* time out for transmit DXR ready */   
  }
    
  I2C_RSET(I2CDXR,*data++);  /* put first data value in DXR */
  
                            /* generate start condition */
  I2C_FSET(I2CMDR,STT,1);
             
  
  for (k=1;k<length;k++)  {   /* enter main loop for transmitting data */
        
       
      for (i=0;i<32000;i++)  {  /* delay loop */
      asm (" NOP");
      }
                     
  for (l=0;l<=timeout;l++)  {   /* check for NACK status */
  temp=I2C_FGET(I2CSTR,NACK);
  if (temp==0) break; 
  }
    
  if (l>=timeout) { 
     //IRQ_globalRestore(old_intm);
     return 3;        /* No acknowledge bit is set, NACK error */
  }

  for (m=0;m<=timeout;m++)  {   /* check for DXR status */

  temp=I2C_FGET(I2CSTR,XRDY);
  if (temp==1) break; 
                 
  }
      
  if (m>=timeout) {
      //IRQ_globalRestore(old_intm);
  	return 4;         /* time out for transmit DXR ready */ 
  }
	
  I2C_RSET(I2CDXR,*data++);  /* put next data value in DXR */
    
  
  } /* end of for loop */
   
   for (j=0;j<10;j++) {    /* last delay loop for last data transferred*/
      for (i=0;i<32000;i++)  {
      asm (" NOP");
      }
      }
     
    for (l=0;l<=timeout;l++)  {   /* check for NACK status for last data byte transferred*/
  temp=I2C_FGET(I2CSTR,NACK);
  if (temp==0) break; 
  }
    
  if (l>=timeout) {
      //IRQ_globalRestore(old_intm); 
  	return 5;        /* No acknowledge bit is set, NACK error */                                                             
  }
   
  //IRQ_globalRestore(old_intm);

  return 0;
  
}  /* end of I2C_send */

#endif
icache_cfga.c/  1051539326  0     0     0       3972      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ICACHE
* FILENAME...... icache_cfga.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   06/20/1999 (BWC)  Created for C6x
*   12/06/2000 (FSCA) Modification for C54x.
*   05/18/2000 (IC) Modified for C55xx.
*   04/24/2002 (IC) Modified for C5502.
*   10 April 2003   added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ICACHE module)
*
*
*
\******************************************************************************/
#define _ICACHE_MOD_

/****************************************\
* include files
\****************************************/    
#include "csl_chip.h" 
#include "csl_icache.h" 
#include "csl.h"
   
 
#if (_ICACHE_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE static macro declarations
\****************************************/
/* See icache.h Romability */
 
 
/****************************************\
* ICACHE static typedef declarations
\****************************************/

/****************************************\
* ICACHE static function declarations
\****************************************/

/****************************************\
* ICACHE Variable definitions : ROMability 
\****************************************/

/* Definition Romability See icache.h */


             
/****************************************\
* ICACHE static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE global variable definitions
\****************************************/
/* Definition See icache.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any ICACHE devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* ICACHE global function definitions
\****************************************/

#pragma CODE_SECTION(ICACHE_config,".text:ICACHE_config")

/*----------------------------------------------------------------------------*/
void ICACHE_config(ICACHE_Config *Config) {



	ICACHE_RSET(ICGC, Config -> icgc);  
        #if (CHIP_5510) | (CHIP_5510PG2_0)    
        ICACHE_RSET(ICWC, Config -> icwc);
        ICACHE_RSET(ICRC1, Config -> icrc1);
	ICACHE_RSET(ICRTAG1, Config -> icrtag1);
        ICACHE_RSET(ICRC2, Config -> icrc2);
        ICACHE_RSET(ICRTAG2, Config -> icrtag2);
       #endif /* CHIP_5510 */

}
/*----------------------------------------------------------------------------*/

#endif /* ICACHE_SUPPORT */
/******************************************************************************\
* End of icache_cfga.c
\******************************************************************************/

icache_cfgb.c/  1051539325  0     0     0       4106      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ICACHE
* FILENAME...... icache_cfgb.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   06/20/1999 (BWC)  Created for C6x
*   12/06/2000 (FSCA) Modification for C54x.
*   05/18/2000 (IC) Modified for C55xx.
*   04/24/2002 (IC) Modified for C5502.
*   10 April 2003  added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ICACHE module)
*
*
*
\******************************************************************************/
#define _ICACHE_MOD_

/****************************************\
* include files
\****************************************/    
#include "csl_chip.h" 
#include "csl_icache.h" 
#include "csl.h"
   
 
#if (_ICACHE_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE static macro declarations
\****************************************/
/* See icache.h Romability */
 
 
/****************************************\
* ICACHE static typedef declarations
\****************************************/

/****************************************\
* ICACHE static function declarations
\****************************************/

/****************************************\
* ICACHE Variable definitions : ROMability 
\****************************************/

/* Definition Romability See icache.h */


             
/****************************************\
* ICACHE static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE global variable definitions
\****************************************/
/* Definition See icache.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any ICACHE devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* ICACHE global function definitions
\****************************************/

#pragma CODE_SECTION(ICACHE_configArgs,".text:ICACHE_configArgs")
/*----------------------------------------------------------------------------*/


#if (CHIP_5510) | (CHIP_5510PG2_0)   

  void ICACHE_configArgs(Uint16 icgc, Uint16 icwc, Uint16 icrc1, Uint16 icrtag1, Uint16 icrc2, Uint16 icrtag2) {

	ICACHE_RSET(ICGC, icgc);     
        ICACHE_RSET(ICWC, icwc);
        ICACHE_RSET(ICRC1, icrc1);
	ICACHE_RSET(ICRTAG1, icrtag1);
        ICACHE_RSET(ICRC2, icrc2);
        ICACHE_RSET(ICRTAG2, icrtag2);


}


#endif /* CHIP_5510 */
#if CHIP_5502

  void ICACHE_configArgs(Uint16 icgc) {

	ICACHE_RSET(ICGC, icgc);     

}


#endif /* CHIP_5502 */
/*----------------------------------------------------------------------------*/

#endif /* ICACHE_SUPPORT */
/******************************************************************************\
* End of icache_cfgb.c
\******************************************************************************/

icache_dsbl.c/  1051539324  0     0     0       3531      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ICACHE
* FILENAME...... icache_dsbl.c
* DATE CREATED.. Mon 02/18/2002 
* PROJECT....... 
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   02/18/2002 (IC)  Created for C55xx
*   04/23/2002 (IC)  Modified for C5502
*   10 April 2003    added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ICACHE module)
*
*
*
\******************************************************************************/
#define _ICACHE_MOD_

/****************************************\
* include files
\****************************************/    
#include "csl_chip.h" 
#include "csl_icache.h" 
#include "csl.h"
   
 
#if (_ICACHE_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE static macro declarations
\****************************************/
/* See icache.h Romability */
 
 
/****************************************\
* ICACHE static typedef declarations
\****************************************/

/****************************************\
* ICACHE static function declarations
\****************************************/

/****************************************\
* ICACHE Variable definitions : ROMability 
\****************************************/

/* Definition Romability See icache.h */


             
/****************************************\
* ICACHE static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE global variable definitions
\****************************************/
/* Definition See icache.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any ICACHE devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* ICACHE global function definitions
\****************************************/

#pragma CODE_SECTION(ICACHE_disable,".text:ICACHE_disable")

/*----------------------------------------------------------------------------*/
   void ICACHE_disable()  
{

	CHIP_FSET(ST3_55,CAEN,0);     

}
/*----------------------------------------------------------------------------*/

#endif /* ICACHE_SUPPORT */
/******************************************************************************\
* End of icache_dsbl.c
\******************************************************************************/


icache_enbl.c/  1051539323  0     0     0       3642      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ICACHE
* FILENAME...... icache_enable.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   06/20/1999 (BWC)  Created for C6x
*   12/06/2000 (FSCA) Modification for C54x.
*   05/18/2000 (IC) Modified for C55xx.
*   04/24/2002 (IC) Modified for 5502
*   10 April 2003   added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ICACHE module)
*
*
*
\******************************************************************************/
#define _ICACHE_MOD_

/****************************************\
* include files
\****************************************/    
#include <csl_chiphal.h> 
#include <csl_icache.h> 
#include <csl.h>
   
 
#if (_ICACHE_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE static macro declarations
\****************************************/
/* See icache.h Romability */
 
 
/****************************************\
* ICACHE static typedef declarations
\****************************************/

/****************************************\
* ICACHE static function declarations
\****************************************/

/****************************************\
* ICACHE Variable definitions : ROMability 
\****************************************/

/* Definition Romability See icache.h */


             
/****************************************\
* ICACHE static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE global variable definitions
\****************************************/
/* Definition See icache.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any ICACHE devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* ICACHE global function definitions
\****************************************/

#pragma CODE_SECTION(ICACHE_enable,".text:ICACHE_enable")

/*----------------------------------------------------------------------------*/
   void ICACHE_enable()  
{

	CHIP_FSET(ST3_55,CAEN,1);    
}
/*----------------------------------------------------------------------------*/

#endif /* _ICACHE_SUPPORT */
/******************************************************************************\
* End of icache_enable.c
\******************************************************************************/

icache_flush.c/ 1051539322  0     0     0       3355      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ICACHE
* FILENAME...... icache_flush.c
* DATE CREATED.. Mon 02/18/2002 
* PROJECT....... 
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   02/18/2002 (IC)  Created for C55xx
*   04/23/2002 (IC)  Modified for C5502
*  10 April 2003     added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ICACHE module)
*
*
*
\******************************************************************************/
#define _ICACHE_MOD_

/****************************************\
* include files
\****************************************/    
#include "csl_chip.h" 
#include "csl_icache.h" 
#include "csl.h"
   
 
#if (_ICACHE_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE static macro declarations
\****************************************/
/* See csl_icache.h Romability */
 
 
/****************************************\
* ICACHE static typedef declarations
\****************************************/

/****************************************\
* ICACHE static function declarations
\****************************************/

             
/****************************************\
* ICACHE static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE global variable definitions
\****************************************/
/* Definition See csl_icache.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any ICACHE devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* ICACHE global function definitions
\****************************************/

#pragma CODE_SECTION(ICACHE_flush,".text:ICACHE_flush")

/*----------------------------------------------------------------------------*/
   void ICACHE_flush()  
{

	CHIP_FSET(ST3_55,CACLR,1);     

}
/*----------------------------------------------------------------------------*/

#endif /* ICACHE_SUPPORT */
/******************************************************************************\
* End of icache_flush.c
\******************************************************************************/


icache_frz.c/   1051539321  0     0     0       3538      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... CACHE
* FILENAME...... icache_frz.c
* DATE CREATED.. Mon 02/18/2002 
* PROJECT....... 
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   02/18/2002 (IC)  Created for C55xx
*   04/23/2002 (IC)  Modified for C5502
*   10 April 2003    added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ICACHE module)
*
*
*
\******************************************************************************/
#define _ICACHE_MOD_

/****************************************\
* include files
\****************************************/    
#include "csl_chip.h" 
#include "csl_icache.h" 
#include "csl.h"
   
 
#if (_ICACHE_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE static macro declarations
\****************************************/
/* See csl_icache.h Romability */
 
 
/****************************************\
* ICACHE static typedef declarations
\****************************************/

/****************************************\
* ICACHE static function declarations
\****************************************/

/****************************************\
* ICACHE Variable definitions : ROMability 
\****************************************/

/* Definition Romability See csl_icache.h */


             
/****************************************\
* ICACHE static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE global variable definitions
\****************************************/
/* Definition See csl_icache.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any ICACHE devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* ICACHE global function definitions
\****************************************/

#pragma CODE_SECTION(ICACHE_freeze,".text:ICACHE_freeze")

/*----------------------------------------------------------------------------*/
   void ICACHE_freeze()  
{

	CHIP_FSET(ST3_55,CAFRZ,1);     

}
/*----------------------------------------------------------------------------*/

#endif /* ICACHE_SUPPORT */
/******************************************************************************\
* End of icache_frz.c
\******************************************************************************/

icache_init.c/  1051539320  0     0     0       4384      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ICACHE
* FILENAME...... icache_init.c
* DATE CREATED.. Tue 05/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   05/30/2000 (IC) Created
*   MODIFIED: 10 April 2003 added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ICACHE module)
*
*
*
\******************************************************************************/
#define _ICACHE_MOD_

/****************************************\
* include files
\****************************************/
#include "csl_chip.h" 
#include "csl_icache.h"
#include "csl.h"

#if (_ICACHE_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE static macro declarations
\****************************************/

/****************************************\
* ICACHE static typedef declarations
\****************************************/

/****************************************\
* ICACHE static function declarations
\****************************************/

/****************************************\
* ICACHE static variable definitions
\****************************************/
 

/****************************************\
* ICACHE static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE global variable definitions
\****************************************/
  
/****************************************\
* ICACHE global function definitions
\****************************************/

#if CHIP_5510

#pragma CODE_SECTION(ICACHE_init,".text;ICACHE_init")

 void ICACHE_init(ICACHE_Init *params)    

	
  {
	
	Uint16 r1tag, r2tag;
   /* Set Ramset Mode in GCR register */

	ICACHE_RSET(ICGC, params -> rmode);
	
   /* Initialize Ramset N-Way Control Registers*/
   
   	ICACHE_FSET(ICWC,WINIT, ICACHE_ICWC_WINIT_WINIT);
   	ICACHE_FSET(ICRC1,R1INIT, ICACHE_ICRC1_R1INIT_INIT);
  	ICACHE_FSET(ICRC2,R2INIT,ICACHE_ICRC2_R2INIT_INIT);    	
   /* Enable ICACHE */
	CHIP_FSET(ST3_55,CAEN,1);  

   /* Poll to validate enable */	
    	while(!ICACHE_FGET(ICST, IEN));

   /* Initialize tags according to rmode values */

   if ((params -> rmode) == ICACHE_ICGC_RMODE_1RAMSET)		/* 1 RAMSET */
	{ 	
	
	   r1tag = (Uint16)(((params -> r1addr)>>12)&0x0FFFu);
	   ICACHE_FSET(ICRTAG1, R1TAG, r1tag);
	   while(!ICACHE_FGET(ICRC1, R1TVALID));

  	} 

   if ((params -> rmode) == ICACHE_ICGC_RMODE_2RAMSET)		/* 2 RAMSET */
	{ 
	
	 r1tag = (Uint16)(((params -> r1addr)>>12)&0x0FFFu);
	 r2tag = (Uint16)(((params -> r2addr)>>12)&0x0FFFu);	
	   ICACHE_FSET(ICRTAG1, R1TAG, r1tag);
	   while(!ICACHE_FGET(ICRC1, R1TVALID));
	   ICACHE_FSET(ICRTAG2, R2TAG, r2tag);
	   while(!ICACHE_FGET(ICRC2, R2TVALID));

  	}

   if ((params -> rmode) == ICACHE_ICGC_RMODE_0RAMSET)		/* 0 RAMSET */
      {}


}
/*----------------------------------------------------------------------------*/

#endif /* CHIP_5510 */

#if CHIP_5502


 void ICACHE_setup()    

	
  {

     /* Initialize ICGC register */
	ICACHE_RSET(ICGC, 0xCE3C);

       /* Enable ICACHE */
	CHIP_FSET(ST3_55,CAEN,1); 

  }
#endif /* CHIP_5502 */

#endif /* ICACHE_SUPPORT */
/******************************************************************************\
* End of ICACHE_init.c
\******************************************************************************/

icache_setp.c/  1051539319  0     0     0       4388      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ICACHE
* FILENAME...... icache_init.c
* DATE CREATED.. Tue 05/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   05/30/2000 (IC) Created
*   MODIFIED: 10 April 2003 added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ICACHE module)
*
*
*
\******************************************************************************/
#define _ICACHE_MOD_

/****************************************\
* include files
\****************************************/
#include "csl_chip.h" 
#include "csl_icache.h"
#include "csl.h"

#if (_ICACHE_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE static macro declarations
\****************************************/

/****************************************\
* ICACHE static typedef declarations
\****************************************/

/****************************************\
* ICACHE static function declarations
\****************************************/

/****************************************\
* ICACHE static variable definitions
\****************************************/
 

/****************************************\
* ICACHE static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE global variable definitions
\****************************************/
  
/****************************************\
* ICACHE global function definitions
\****************************************/
#pragma CODE_SECTION(ICACHE_setup,".text;ICACHE_setup")

#if CHIP_5510


 void ICACHE_setup(ICACHE_Setup *params)    

	
  {
	
	Uint16 r1tag, r2tag;
   /* Set Ramset Mode in GCR register */

	ICACHE_RSET(ICGC, params -> rmode);
	
   /* Initialize Ramset N-Way Control Registers*/
   
   	ICACHE_FSET(ICWC,WINIT, ICACHE_ICWC_WINIT_WINIT);
   	ICACHE_FSET(ICRC1,R1INIT, ICACHE_ICRC1_R1INIT_INIT);
  	ICACHE_FSET(ICRC2,R2INIT,ICACHE_ICRC2_R2INIT_INIT);    	
   /* Enable ICACHE */
	CHIP_FSET(ST3_55,CAEN,1);  

   /* Poll to validate enable */	
    	while(!ICACHE_FGET(ICST, IEN));

   /* Initialize tags according to rmode values */

   if ((params -> rmode) == ICACHE_ICGC_RMODE_1RAMSET)		/* 1 RAMSET */
	{ 	
	
	   r1tag = (Uint16)(((params -> r1addr)>>12)&0x0FFFu);
	   ICACHE_FSET(ICRTAG1, R1TAG, r1tag);
	   while(!ICACHE_FGET(ICRC1, R1TVALID));

  	} 

   if ((params -> rmode) == ICACHE_ICGC_RMODE_2RAMSET)		/* 2 RAMSET */
	{ 
	
	 r1tag = (Uint16)(((params -> r1addr)>>12)&0x0FFFu);
	 r2tag = (Uint16)(((params -> r2addr)>>12)&0x0FFFu);	
	   ICACHE_FSET(ICRTAG1, R1TAG, r1tag);
	   while(!ICACHE_FGET(ICRC1, R1TVALID));
	   ICACHE_FSET(ICRTAG2, R2TAG, r2tag);
	   while(!ICACHE_FGET(ICRC2, R2TVALID));

  	}

   if ((params -> rmode) == ICACHE_ICGC_RMODE_0RAMSET)		/* 0 RAMSET */
      {}


}
/*----------------------------------------------------------------------------*/

#endif /* CHIP_5510 */

#if CHIP_5502


 void ICACHE_setup()    

	
  {

     /* Initialize ICGC register */
	ICACHE_RSET(ICGC, 0xCE3C);

       /* Enable ICACHE */
	CHIP_FSET(ST3_55,CAEN,1); 

  }
#endif /* CHIP_5502 */

#endif /* ICACHE_SUPPORT */
/******************************************************************************\
* End of ICACHE_init.c
\******************************************************************************/

icache_tset.c/  1051539318  0     0     0       3654      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ICACHE
* FILENAME...... icache_tset.c
* DATE CREATED.. Mon 02/18/2002 
* PROJECT....... 
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   02/18/2002 (IC) Created
*   10 April 2003   added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the CACHE module)
*
*
*
\******************************************************************************/
#define _ICACHE_MOD_

/****************************************\
* include files
\****************************************/
#include "csl_chip.h" 
#include "csl_icache.h"
#include "csl.h"

#if (_ICACHE_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE static macro declarations
\****************************************/

/****************************************\
* ICACHE static typedef declarations
\****************************************/

/****************************************\
* ICACHE static function declarations
\****************************************/

/****************************************\
* ICACHE static variable definitions
\****************************************/
 

/****************************************\
* ICACHE static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE global variable definitions
\****************************************/
  
/****************************************\
* ICACHE global function definitions
\****************************************/


#if (CHIP_5510) | (CHIP_5510PG2_0)

#pragma CODE_SECTION(ICACHE_tagset,".text:ICACHE_tagset")

 void ICACHE_tagset(ICACHE_Tagset *params) {    

	Uint16	rmode;
	Uint16 r1tag, r2tag;
    rmode = ICACHE_RGET(ICGC);

   /* Initialize tags according to rmode values */

   if (rmode == ICACHE_ICGC_RMODE_1RAMSET )		/* 1 RAMSET */
	{ 	
	
	   r1tag = (Uint16)(((params -> r1addr)>>12)&0x0FFFu);
	   ICACHE_FSET(ICRTAG1, R1TAG, r1tag);
	   while(ICACHE_FGET(ICRC1, R1TVALID));

  	} 

   if (rmode == ICACHE_ICGC_RMODE_2RAMSET)		/* 2 RAMSET */
	{ 	
	
	   r1tag = (Uint16)(((params -> r1addr)>>12)&0x0FFFu);
	   r2tag = (Uint16)(((params -> r2addr)>>12)&0x0FFFu);
	   ICACHE_FSET(ICRTAG1, R1TAG, r1tag);
	   while(ICACHE_FGET(ICRC1, R1TVALID));
	   ICACHE_FSET(ICRTAG2, R2TAG, r2tag);
	   while(ICACHE_FGET(ICRC2, R2TVALID));

  	}


}
/*----------------------------------------------------------------------------*/

#endif /* CHIP_5510 */

#endif /* ICACHE_SUPPORT */
/******************************************************************************\
* End of icache_tset.c
\******************************************************************************/

icache_ufrz.c/  1051539317  0     0     0       3545      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... ICACHE
* FILENAME...... icache_ufrz.c
* DATE CREATED.. Mon 02/18/2002 
* PROJECT....... 
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   02/18/2002 (IC)  Created for C55xx
*   04/23/2002 (IC)  Modified for C5502
*   10 Apri 2003     added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the ICACHE module)
*
*
*
\******************************************************************************/
#define _ICACHE_MOD_

/****************************************\
* include files
\****************************************/    
#include "csl_chip.h" 
#include "csl_icache.h" 
#include "csl.h"
   
 
#if (_ICACHE_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE static macro declarations
\****************************************/
/* See csl_icache.h Romability */
 
 
/****************************************\
* ICACHE static typedef declarations
\****************************************/

/****************************************\
* ICACHE static function declarations
\****************************************/

/****************************************\
* ICACHE Variable definitions : ROMability 
\****************************************/

/* Definition Romability See csl_icache.h */


             
/****************************************\
* ICACHE static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* ICACHE global variable definitions
\****************************************/
/* Definition See csl_icache.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any ICACHE devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* ICACHE global function definitions
\****************************************/

#pragma CODE_SECTION(ICACHE_unfreeze,".text:ICACHE_unfreeze")

/*----------------------------------------------------------------------------*/
   void ICACHE_unfreeze()  
{

	CHIP_FSET(ST3_55,CAFRZ,0);   

}
/*----------------------------------------------------------------------------*/

#endif /* ICACHE_SUPPORT */
/******************************************************************************\
* End of icache_ufrz.c
\******************************************************************************/


irq_cfga.c/     1049977096  0     0     0       1938      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... irq_cfga.c
* DATE CREATED.. Wed 06/19/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/19/2000
*   MODIFIED: 07/10/2000 Modified for TMS320C5510
*   MODIFIED: 03/22/2001 modified to support IRQ_IEMASK_SELF
*   MODIFIED: 06/29/2001 added pragma for section per function and updated
*                        for new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_config,".text:IRQ_config")

/*----------------------------------------------------------------------------*/
 void IRQ_config(Uint16 EventId, IRQ_Config *Config) {
   CSL_IRQ_DATA.IrqDispatchTable[EventId].funcAddr = Config->funcAddr;
   CSL_IRQ_DATA.IrqDispatchTable[EventId].ierMask = (Config->ierMask == IRQ_IEMASK_SELF)? 
                                                  ((Uint32)1u<<EventId) : Config->ierMask;
   CSL_IRQ_DATA.IrqDispatchTable[EventId].cacheCtrl = Config->cacheCtrl;
   CSL_IRQ_DATA.IrqDispatchTable[EventId].funcArg = Config->funcArg;
}
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of irq_cfga.c
\******************************************************************************/

irq_cfgb.c/     1049977098  0     0     0       1974      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... irq_cfgb.c
* DATE CREATED.. Wed 06/19/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/19/2000
*   MODIFIED: 07/10/2000 Modified for TMS320C5510
*   MODIFIED: 03/22/2001 modified for IRQ_IEMASK_SELF support
*   MODIFIED: 06/29/2001 added pragma for section per function and updated for
*                        new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_configArgs, ".text:IRQ_configArgs")

/*----------------------------------------------------------------------------*/
void IRQ_configArgs(Uint16 EventId, IRQ_IsrPtr funcAddr, Uint32 funcArg,
                 Uint32 ierMask, Uint32 cacheCtrl) {
  CSL_IRQ_DATA.IrqDispatchTable[EventId].funcAddr = funcAddr;
  CSL_IRQ_DATA.IrqDispatchTable[EventId].ierMask = (ierMask == IRQ_IEMASK_SELF)?
                                                 ((Uint32)1u<<EventId): ierMask;
  CSL_IRQ_DATA.IrqDispatchTable[EventId].cacheCtrl = cacheCtrl;
  CSL_IRQ_DATA.IrqDispatchTable[EventId].funcArg = funcArg; 
}
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of irq_cfgb.c
\******************************************************************************/

irq_clear.c/    1049977099  0     0     0       1716      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... irq_clear.c
* DATE CREATED.. Wed 06/19/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/19/2000
*   MODIFIED: 03/22/2001 modified to disable interrupts around IER update
*   MODIFIED: 06/29/2001 added pragma for section per function
*   MODIFIED: 01/18/2002 ficed IRQ mapping problem for INT1
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_clear,".text:IRQ_clear")

/*----------------------------------------------------------------------------*/
void IRQ_clear(Uint16 EventId) {   
  Uint16 bit, reg, mask;
  int old_intm;
  bit= EventId & 0xfu; 
  reg=((EventId & 0x10) >> 4);
  mask=IRQ_MASK16(bit);
  old_intm = IRQ_globalDisable();
  if (reg)
    _IFR1 = mask;
  else
    _IFR0 = mask;
  IRQ_globalRestore(old_intm);
}
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of IRQ_clear.c
\******************************************************************************/

irq_disa.c/     1049977101  0     0     0       2127      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... IRQ_disab.c
* DATE CREATED.. Wed 06/09/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/09/1999 Created
*   MODIFIED: 12/03/1999 Modified for TMS320C54xx
*   MODIFIED: 01/04/2000 Correction of EVENT Numbers
*                        Modification of IRQ_functions 
*   MODIFIED: 02/21/2000 C54x Romability .
*   MODIFIED: 06/19/2000 DSPBIOS integration
*   MODIFIED: 03/22/2001 modified to return old flag value
*   MODIFIED: 06/29/2001 added pragma for section per function
*   MODIFIED: 01/18/2002 fixed IRQ mapping problem for INT1
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_disable,".text:IRQ_disable")

/*----------------------------------------------------------------------------*/
int IRQ_disable(Uint16 EventId) { 
  Uint16 bit,reg,mask,prev;
  int old_intm,old_flag;

  bit= EventId & 0xfu; 
  reg=((EventId & 0x10) >> 4);
  mask=IRQ_MASK16(bit);
  old_intm = IRQ_globalDisable();
  prev = (reg) ? CHIP_RGET(IER1) : CHIP_RGET(IER0);
  old_flag = (prev & mask) >> bit;
  if (reg) 
    _IER1 &= ~mask;
  else 
    _IER0 &= ~mask; 
  IRQ_globalRestore(old_intm);
  return old_flag;
}                                 
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of IRQ_disab.c
\******************************************************************************/


irq_enab.c/     1049977102  0     0     0       2165      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... IRQ_enab.c
* DATE CREATED.. Wed 06/09/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/09/1999 
*   MODIFIED: 12/03/1999 Modified for TMS320C54xx
*   MODIFIED: 01/04/2000 Correction of EVENT Numbers
*                        Modification of IRQ_functions 
*   MODIFIED: 02/21/2000 C54x Romability .
*   MODIFIED: 06/19/2000 DSPBIOS integration
*   MODIFIED: 07/10/2000 Modified for TMS320C5510
*   MODIFIED: 03/22/2001 modified to return old flag value and disable
*                        interrupts about IER update
*   MODIFIED: 01/18/2002 fixed IRQ mapping problem for INT1
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_enable,".text:IRQ_enable")

/*--------------------------------------------------------------------*/
int IRQ_enable(Uint16 EventId) {
   Uint16 bit,reg,prev,value,mask;
   int old_intm, old_flag;

   bit= EventId & 0xfu; 
   reg=((EventId & 0x10) >> 4);
   mask= IRQ_MASK16(bit);
   old_intm = IRQ_globalDisable();
   prev = (reg) ? CHIP_RGET(IER1) : CHIP_RGET(IER0);
   old_flag = (prev & mask);
   value= (prev | mask);
   if (reg) 
     _IER1 = value;
   else 
    _IER0 = value; 
   IRQ_globalRestore(old_intm);
   return old_flag;
} 
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of IRQ_enab.c
\******************************************************************************/


irq_garg.c/     1049977104  0     0     0       1513      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... irq_garg.c
* DATE CREATED.. Wed 06/09/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/19/2000
*   MODIFIED: 07/10/2000 Modified for TMS320C5510
*   MODIFIED: 06/29/2001 added pragma for section per function and updated
*                        for new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_getArg,".text:IRQ_getArg")

/*----------------------------------------------------------------------------*/
Uint32 IRQ_getArg(Uint16 EventId){
 return CSL_IRQ_DATA.IrqDispatchTable[EventId].funcArg;
}
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of irq_garg.c
\******************************************************************************/


irq_gcfg.c/     1049977105  0     0     0       1738      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... irq_gcfg.c
* DATE CREATED.. Wed 06/09/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/19/2000
*   MODIFIED: 06/29/2001 added pragma for section per function and updated for
*                        new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_getConfig,".text:IRQ_getConfig")

/*----------------------------------------------------------------------------*/
void IRQ_getConfig(Uint16 EventId, IRQ_Config *Config) {
    Config->funcAddr = (IRQ_IsrPtr)(CSL_IRQ_DATA.IrqDispatchTable[EventId].funcAddr);
    Config->ierMask = CSL_IRQ_DATA.IrqDispatchTable[EventId].ierMask;
    Config->cacheCtrl = CSL_IRQ_DATA.IrqDispatchTable[EventId].cacheCtrl;
    Config->funcArg = CSL_IRQ_DATA.IrqDispatchTable[EventId].funcArg; 
}
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of irq_gcfg.c
\******************************************************************************/

irq_gdisab.c/   1049977107  0     0     0       1991      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... IRQ_globalDisable.c
* DATE CREATED.. Wed 06/09/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. csl_std.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/09/1999 
*   MODIFIED: 12/03/1999 Modified for TMS320C54xx
*   MODIFIED: 01/04/2000 Correction of EVENT Numbers
*                        Modification of IRQ_functions 
*   MODIFIED: 02/21/2000 C54x Romability .
*   MODIFIED: 06/19/2000 DSPBIOS integration
*   MODIFIED: 07/10/2000 Modified for TMS320C5510
*   MODIFIED: 06/29/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_globalDisable,".text:IRQ_globalDisable")

/*--------------------------------------------------------------------*/
int IRQ_globalDisable() {
   int old_intm = CHIP_FGET(ST1_55,INTM);
   asm("\tNOP                      ;====> CODE AUTO-GENERATED by CSL");
#ifdef ALGEBRAIC
   asm("\tBIT (ST1,#ST1_INTM) = #1                ;====> CODE AUTO-GENERATED by CSL");
#else     
   asm("\tBSET INTM                ;====> CODE AUTO-GENERATED by CSL");
#endif
   return old_intm;    
 }

#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of IRQ_globalEnable.c
\******************************************************************************/


irq_genab.c/    1049977108  0     0     0       1648      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... IRQ_genab.c
* DATE CREATED.. Thu 03/22/2001 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. csl_std.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  03/22/2001
*   MODIFIED: 06/29/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_globalEnable,".text:IRQ_globalEnable")

/*--------------------------------------------------------------------*/
 int IRQ_globalEnable() {
   int old_intm = CHIP_FGET(ST1_55,INTM);
   asm("\tNOP                      ;====> CODE AUTO-GENERATED by CSL");
#ifdef ALGEBRAIC
   asm("\tBIT(ST1,#ST1_INTM)=#0    ;====> CODE AUTO-GENERATED by CSL");
#else
   asm("\tBCLR INTM                ;====> CODE AUTO-GENERATED by CSL");
#endif
   return old_intm;    
 }
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of IRQ_genab.c
\******************************************************************************/

irq_grest.c/    1049977110  0     0     0       2197      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... IRQ_globalRestore.c
* DATE CREATED.. Wed 06/09/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. csl_std.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/09/1999 
*   MODIFIED: 12/03/1999 Modified for TMS320C54xx
*   MODIFIED: 01/04/2000 Corrrection of EVENT Numbers
*                        Modification of IRQ_functions 
*   MODIFIED: 02/21/2000 C54x Romability .
*   MODIFIED: 06/19/2000 DSPBIOS integration
*   MODIFIED: 08/05/2000 Modified for TMS320C5510
*   MODIFIED: 06/29/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_globalRestore,".text:IRQ_globalRestore")

/*--------------------------------------------------------------------*/
void IRQ_globalRestore(int gie) {
   if (gie) {
   asm("\tNOP                      ;====> CODE AUTO-GENERATED by CSL");
#ifdef ALGEBRAIC
   asm("\tBIT(ST1,#ST1_INTM)=#1 ;====> CODE AUTO-GENERATED by CSL");
#else
   asm("\tBSET INTM                ;====> CODE AUTO-GENERATED by CSL");
#endif
   }
   else {
   asm("\tNOP                      ;====> CODE AUTO-GENERATED by CSL");
#ifdef ALGEBRAIC
   asm("\tBIT(ST1,#ST1_INTM)=#0 ;====> CODE AUTO-GENERATED by CSL");
#else
   asm("\tBCLR INTM                ;====> CODE AUTO-GENERATED by CSL");
#endif
   } 

}
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of IRQ_globalRestore.c
\******************************************************************************/


irq_init.c/     1049977111  0     0     0       3045      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... IRQ
* FILENAME...... irq_init.c
* DATE CREATED.. Wed 06/09/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* IMPORTS....... none
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/09/1999 
*   MODIFIED: 12/02/1999 C54x Modification.
*   MODIFIED: 02/18/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 06/29/2001 added pragma for section per function and updated
*                        for new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_irq.h>

#if (_IRQ_SUPPORT)                                                               
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* IRQ static variable definitions
\****************************************/

/****************************************\
* IRQ static function definitions
\****************************************/
/* See for romability */     

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/
       
/****************************************\
* IRQ global variable definitions
\****************************************/

/* See definition under irq.h */

#pragma CODE_SECTION(_IRQ_init,".text:_IRQ_init")

/*----------------------------------------------------------------------------*/
void _IRQ_init(_IRQ_Dispatch *dispatchTable, Uint16 biosPresent){

   Uint16 i; 
  
  
   if (dispatchTable != INV) {
     CSL_IRQ_DATA.IrqDispatchTable = dispatchTable;
   }

   for (i=0; i<=IRQ_EVENT_CNT-1; i++)
    CSL_IRQ_DATA.IrqIntTable[i] = i;
   
   for(i=0; i<= IRQ_EVENT_CNT-1; i++)
    CSL_IRQ_DATA.IrqEventTable[i] = IRQ_MASK32(i);

    CSL_SYS_DATA.OsPresent = biosPresent;   
             
}

/*----------------------------------------------------------------------------*/

#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of irq_init.c
\******************************************************************************/


irq_map.c/      1049977113  0     0     0       1451      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... irq_map.c
* DATE CREATED.. Wed 06/09/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/19/2000
*   MODIFIED: 06/29/2001 added pragma for section per function and
*                        updated for new CSL intialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_map,".text:IRQ_map")

/*----------------------------------------------------------------------------*/
void IRQ_map(Uint16 EventId){
  CSL_IRQ_DATA.IrqIntTable[EventId] = IRQ_MASK32(EventId);
}
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of irq_map.c
\******************************************************************************/


irq_rest.c/     1049977115  0     0     0       1793      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... IRQ_rest.c
* DATE CREATED.. Thu 03/22/2001 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  03/22/2001 Created
*   MODIFIED: 06/29/2001 added pragma for section per function
*   MODIFIED: 01/18/2002 fixed IRG mapping problem for INT1
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_restore,".text:IRQ_restore")

/*--------------------------------------------------------------------*/
  void IRQ_restore(Uint16 EventId, Uint16 Old_flag) {
   Uint16 bit,reg,prev,value,mask;
   int old_intm;

   bit= EventId & 0xfu; 
   reg=((EventId & 0x10) >> 4);
   mask= IRQ_MASK16(bit);
   old_intm = IRQ_globalDisable();
   prev = (reg) ? CHIP_RGET(IER1) : CHIP_RGET(IER0);
   value= (prev & (~mask)) | (Old_flag << bit);
   if (reg) 
     _IER1 = value;
   else 
    _IER0  = value; 
   IRQ_globalRestore(old_intm);
} 
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of IRQ_rest.c
\******************************************************************************/


irq_sarg.c/     1049977117  0     0     0       1497      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... irq_sarg.c
* DATE CREATED.. Wed 06/09/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/19/2000
*   MODIFIED: 07/10/2000
*   MODIFIED: 06/29/2001 added pragma for section per function and
*                        updated for new CSL initialization/data model
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_setArg,".text:IRQ_setArg")

/*----------------------------------------------------------------------------*/
void IRQ_setArg(Uint16 EventId, Uint32 val){
 CSL_IRQ_DATA.IrqDispatchTable[EventId].funcArg = val;
}
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of irq_sarg.c
\******************************************************************************/


irq_setpri.c/   1049977118  0     0     0       1489      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... irq_setpri.c
* DATE CREATED.. Wed 06/19/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/15/2002
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

#pragma CODE_SECTION(IRQ_setPriority,".text:IRQ_setPriority")

/*----------------------------------------------------------------------------*/
void IRQ_setPriority(Uint16 EventId, Uint16 priority) {   
   Uint16 odd = EventId & 0x1;
   Uint16 regIndex = EventId > 1;
   Uint16 *regPtr = (CSL_IRQ_DATA).perRegs;

    PREG16(regPtr[regIndex]) |= (odd) ? (priority << 8) : priority;
 } 

#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of IRQ_clear.c
\******************************************************************************/


irq_setvecs.c/  1049977120  0     0     0       2058      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... irq_setvecs.c
* DATE CREATED.. Wed 06/09/1999 
* PROJECT....... MCRTE - multichannel runtime environment
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/09/1999
*   MODIFIED: 12/03/1999 Modified for TMS320C54xx
*   MODIFIED: 01/04/2000 Correction of EVENT Numbers
*                        Modification of IRQ_functions 
*   MODIFIED: 02/21/2000 C54x Romability .
*   MODIFIED: 07/11/2000 Modified for TMS320C5510 
*   MODIFIED: 03/22/2001 modified to disable interrupts around IVP updates
*   MODIFIED: 06/29/2001 added pragma for section per function
*   MODIFIED: 08/01/2001 removed IVPH update
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

//******************************************************************************/

#pragma CODE_SECTION(IRQ_setVecs,".text:IRQ_setVecs")

//******************************************************************************/
int IRQ_setVecs(Uint32 Ivpd) {
   int old_intm;
   Uint16 old_ivpd;
   Uint16 val = (Uint16)((Ivpd & 0xFFFFFF00)>>8);
   old_intm = IRQ_globalDisable();
   old_ivpd = _IVPD;
   _IVPD = val;
   _IVPH = val;
   IRQ_globalRestore(old_intm);
   return old_ivpd;
 }  
#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of irq_setvecs.c
\******************************************************************************/

irq_test.c/     1049977121  0     0     0       2220      `
/******************************************************************************\
+*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... IRQ_test.c
* DATE CREATED.. Wed 06/09/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. stdinc.h 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/09/1999 
*   MODIFIED: 12/03/1999 Modified for TMS320C54xx
*   MODIFIED: 01/04/2000 Correction of EVENT Numbers
*                        Modification of IRQ_functions 
*   MODIFIED: 02/21/2000 C54x Romability .
*   MODIFIED: 06/19/2000 DSPBIOS integration
*   MODIFIED: 07/10/2000 Modified for TMS320C5510
*   MODIFIED: 03/22/2001 modified to disable interrupts around IFR ref
*   MODIFIED: 03/23/2001 modified to use new CSL types to avoid conflict
*                        with DSPBIOS defined types.
*   MODIFIED: 06/29/2001 added pragma for section per function
*   MODIFIED: 01/18/2002 fixed EventID mapping problem for INT1
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the IRQ module)
*
*
*
\******************************************************************************/
#define _IRQ_MOD_

#include <csl_irq.h>

#if (_IRQ_SUPPORT)

//---------------------------------------------------------------

#pragma CODE_SECTION(IRQ_test,".text:IRQ_test")

//---------------------------------------------------------------
CSLBool IRQ_test(Uint16 EventId) {
  Uint16 bit,reg,mask;
  int old_intm;
  bit= EventId & 0xfu; 
  reg=((EventId & 0x10u) >> 4);
  mask=IRQ_MASK16(bit);
  old_intm = IRQ_globalDisable();
  bit = (CSLBool)( (reg?(_IFR1 & mask): (_IFR0 & mask)) != 0);
  IRQ_globalRestore(old_intm);
  return bit;
}

#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of IRQ_test.c
\******************************************************************************/

mcbsp_cfg.c/    1049977122  0     0     0       5620      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... mcbsp_cfg.c
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999 
*   MODIFIED: 01/25/2000 Modification for C54x DSP
*   MODIFIED: 02/23/2000 C54x ROMABILITY. 
*   MODIFIED: 06/02/2000 Modification for C55x DSP
*   MODIFIED: 06/29/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the MCBSP module)
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>    

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/



/* Map-register definition */
#define DRR1(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Drr1Addr)
#define DRR2(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Drr2Addr)
#define DXR1(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Dxr1Addr)
#define DXR2(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Dxr2Addr)
#define XMTEVENT(hMcbsp) (((MCBSP_PrivateObj*)hMcbsp)->XmtEvent)
#define RCVEVENT(hMcbsp) (((MCBSP_PrivateObj*)hMcbsp)->RcvEvent)
#define ALLOCATED(hMcbsp)(((MCBSP_PrivateObj*)hMcbsp)->Allocated)


/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions       
\****************************************/
 
 
  
/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_config,".text:MCBSP_config")

/*----------------------------------------------------------------------------*/
void MCBSP_config(MCBSP_Handle hMcbsp, MCBSP_Config *Config) {
  int oldgie;
  MCBSP_ASSERT_HANDLE(hMcbsp,return);
  

  oldgie = IRQ_globalDisable();                       

  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Spcr1Addr)=Config->spcr1;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Spcr2Addr)=Config->spcr2;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Rcr1Addr)=Config->rcr1;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Rcr2Addr)=Config->rcr2;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Xcr1Addr)=Config->xcr1;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Xcr2Addr)=Config->xcr2;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Srgr1Addr)=Config->srgr1;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Srgr2Addr)=Config->srgr2;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Mcr1Addr)=Config->mcr1;     
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Mcr2Addr)=Config->mcr2;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RceraAddr)=Config->rcera;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerbAddr)=Config->rcerb;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcercAddr)=Config->rcerc;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerdAddr)=Config->rcerd;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcereAddr)=Config->rcere;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerfAddr)=Config->rcerf;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcergAddr)=Config->rcerg;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerhAddr)=Config->rcerh;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XceraAddr)=Config->xcera;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerbAddr)=Config->xcerb;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcercAddr)=Config->xcerc;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerdAddr)=Config->xcerd;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcereAddr)=Config->xcere;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerfAddr)=Config->xcerf;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcergAddr)=Config->xcerg;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerhAddr)=Config->xcerh;  
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->PcrAddr)=Config->pcr;  
 
  IRQ_globalRestore(oldgie);

  return;
}
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MBSP_cfg.c
\******************************************************************************/

mcbsp_cfgb.c/   1049977124  0     0     0       6154      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... MCBSP_configB.c
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999 
*   MODIFIED: 01/25/2000 Modification for C54x DSP
*   MODIFIED: 02/23/2000 C54x ROMABILITY. 
*   MODIFIED: 06/02/2000 Modification for C55x DSP
*   MODIFIED: 06/29/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the MCBSP module)
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>    

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/



/* Map-register definition */
#define DRR1(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Drr1Addr)
#define DRR2(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Drr2Addr)
#define DXR1(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Dxr1Addr)
#define DXR2(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Dxr2Addr)
#define XMTEVENT(hMcbsp) (((MCBSP_PrivateObj*)hMcbsp)->XmtEvent)
#define RCVEVENT(hMcbsp) (((MCBSP_PrivateObj*)hMcbsp)->RcvEvent)
#define ALLOCATED(hMcbsp)(((MCBSP_PrivateObj*)hMcbsp)->Allocated)

/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions       
\****************************************/
 
/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_configArgs,".text:MCBSP_configArgs")

/*----------------------------------------------------------------------------*/
void MCBSP_configArgs(MCBSP_Handle hMcbsp,                        
                       Uint16 spcr1, Uint16 spcr2, 
                       Uint16 rcr1,  Uint16 rcr2, 
                       Uint16 xcr1,  Uint16 xcr2, 
                       Uint16 srgr1, Uint16 srgr2, 
                       Uint16 mcr1,  Uint16 mcr2, 
                       Uint16 pcr,   Uint16 rcera, 
                       Uint16 rcerb, Uint16 rcerc, 
                       Uint16 rcerd, Uint16 rcere, 
                       Uint16 rcerf, Uint16 rcerg, 
                       Uint16 rcerh, Uint16 xcera, 
                       Uint16 xcerb, Uint16 xcerc, 
                       Uint16 xcerd, Uint16 xcere, 
                       Uint16 xcerf, Uint16 xcerg, 
                       Uint16 xcerh 
                       ) {  
  
   int oldgie;
  MCBSP_ASSERT_HANDLE(hMcbsp,return);

  oldgie = IRQ_globalDisable(); 

  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Spcr1Addr)=spcr1;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Spcr2Addr)=spcr2;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Rcr1Addr)=rcr1;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Rcr2Addr)=rcr2;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Xcr1Addr)=xcr1;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Xcr2Addr)=xcr2;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Srgr1Addr)=srgr1;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Srgr2Addr)=srgr2;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Mcr1Addr)=mcr1;     
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Mcr2Addr)=mcr2;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RceraAddr)=rcera;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerbAddr)=rcerb;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcercAddr)=rcerc;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerdAddr)=rcerd;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcereAddr)=rcere;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerfAddr)=rcerf;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcergAddr)=rcerg;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerhAddr)=rcerh;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XceraAddr)=xcera;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerbAddr)=xcerb;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcercAddr)=xcerc;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerdAddr)=xcerd;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcereAddr)=xcere;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerfAddr)=xcerf;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcergAddr)=xcerg;
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerhAddr)=xcerh;  
  PREG16(((MCBSP_PrivateObj*)hMcbsp)->PcrAddr)=pcr;   
  IRQ_globalRestore(oldgie);

  return;
}      
 
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
 * End MCBSP_configB.c
\******************************************************************************/

mcbsp_cls.c/    1065617104  0     0     0       3731      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... MCBSP_close.c
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999 
*   MODIFIED: 01/25/2000 Modification for C54x DSP
*   MODIFIED: 02/23/2000 C54x ROMABILITY. 
*   MODIFIED: 06/02/2000 Modification for C55x DSP
*   MODIFIED: 06/29/2001 added pragma for section per function
*                        and updated for new CSL initialization model
*   MODIFIED: 10/06/2003 Fixed the typo in _MMC_SUPPORT
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the MCBSP module)
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>    

#if (_MMC_SUPPORT)
  #include <csl_chip.h>
#endif

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/

 
/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions       
\****************************************/
   
/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_close,".text:MCBSP_close")

/*----------------------------------------------------------------------------*/
void MCBSP_close(MCBSP_Handle hMcbsp) {
  int oldgie;
  Uint16 port;

  MCBSP_ASSERT_HANDLE(hMcbsp,return);

  oldgie = IRQ_globalDisable(); 
  port = ((MCBSP_PrivateObj*)hMcbsp)->Port;
  MCBSP_reset(hMcbsp);
  CSL_SYS_DATA.McbspPortAllocMask &= (~(1u<<port));
  #if (_MMC_SUPPORT)
  if (port)
    CSL_SYS_DATA.MmcAllocMask &= (~(1u<<(port-1)));
  #endif
  IRQ_globalRestore(oldgie);


  return;
}
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MCBSP_close.c
\******************************************************************************/


mcbsp_gcfg.c/   1049977127  0     0     0       5542      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... MCBSP_gcfg.c
* DATE CREATED.. Thu 05/10/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  05/10/2001
*   MODIFIED: 06/29/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the MCBSP module)
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>    

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/



/* Map-register definition */
#define DRR1(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Drr1Addr)
#define DRR2(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Drr2Addr)
#define DXR1(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Dxr1Addr)
#define DXR2(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Dxr2Addr)
#define XMTEVENT(hMcbsp) (((MCBSP_PrivateObj*)hMcbsp)->XmtEvent)
#define RCVEVENT(hMcbsp) (((MCBSP_PrivateObj*)hMcbsp)->RcvEvent)
#define ALLOCATED(hMcbsp)(((MCBSP_PrivateObj*)hMcbsp)->Allocated)


/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions       
\****************************************/
 
 
  
/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_getConfig,".text:MCBSP_getCOnfig")

/*----------------------------------------------------------------------------*/
void MCBSP_getConfig(MCBSP_Handle hMcbsp, MCBSP_Config *Config) {
  int oldgie;
  MCBSP_ASSERT_HANDLE(hMcbsp,return);
  

  oldgie = IRQ_globalDisable();                       

  Config->spcr1 = PREG16(((MCBSP_PrivateObj*)hMcbsp)->Spcr1Addr);
  Config->spcr2 = PREG16(((MCBSP_PrivateObj*)hMcbsp)->Spcr2Addr);
  Config->rcr1 = PREG16(((MCBSP_PrivateObj*)hMcbsp)->Rcr1Addr);
  Config->rcr2 = PREG16(((MCBSP_PrivateObj*)hMcbsp)->Rcr2Addr);
  Config->xcr1 = PREG16(((MCBSP_PrivateObj*)hMcbsp)->Xcr1Addr);
  Config->xcr2 = PREG16(((MCBSP_PrivateObj*)hMcbsp)->Xcr2Addr);
  Config->srgr1 = PREG16(((MCBSP_PrivateObj*)hMcbsp)->Srgr1Addr);
  Config->srgr2 = PREG16(((MCBSP_PrivateObj*)hMcbsp)->Srgr2Addr);
  Config->mcr1 = PREG16(((MCBSP_PrivateObj*)hMcbsp)->Mcr1Addr);     
  Config->mcr2 = PREG16(((MCBSP_PrivateObj*)hMcbsp)->Mcr2Addr);
  Config->rcera = PREG16(((MCBSP_PrivateObj*)hMcbsp)->RceraAddr);
  Config->rcerb = PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerbAddr);
  Config->rcerc = PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcercAddr);
  Config->rcerd = PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerdAddr);
  Config->rcere = PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcereAddr);
  Config->rcerf = PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerfAddr);
  Config->rcerg = PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcergAddr);
  Config->rcerh = PREG16(((MCBSP_PrivateObj*)hMcbsp)->RcerhAddr);
  Config->xcera = PREG16(((MCBSP_PrivateObj*)hMcbsp)->XceraAddr);
  Config->xcerb = PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerbAddr);
  Config->xcerc = PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcercAddr);
  Config->xcerd = PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerdAddr);
  Config->xcere = PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcereAddr);
  Config->xcerf = PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerfAddr);
  Config->xcerg = PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcergAddr);
  Config->xcerh = PREG16(((MCBSP_PrivateObj*)hMcbsp)->XcerhAddr);  
  Config->pcr = PREG16(((MCBSP_PrivateObj*)hMcbsp)->PcrAddr);  
 
  IRQ_globalRestore(oldgie);

  return;
}
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MCBSP_gcfg.c
\******************************************************************************/

mcbsp_open.c/   1065792317  0     0     0       5112      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... MCBSP_open.c
* DATE CREATED.. Fri 06/11/1999
* PROJECT....... Chips Support Library
* COMPONENT.....
* IMPORTS.......
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999 Created for C6x
*   MODIFIED: 01/25/2000 Modification for C54x DSP
*   MODIFIED: 02/23/2000 C54x ROMABILITY.
*   MODIFIED: 06/02/2000 Modification for C55x DSP
*   MODIFIED: 06/28/2001 added pragma for section per function
*   MODIFIED: 09/12/2003 Added Check for invalid port number
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the MCBSP module)
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>

#if (_MMC_SUPPORT)
   #include <csl_chip.h>
#endif

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/



/* Map-register definition */
#define DRR1(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Drr1Addr)
#define DRR2(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Drr2Addr)
#define DXR1(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Dxr1Addr)
#define DXR2(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Dxr2Addr)
#define XMTEVENT(hMcbsp) (((MCBSP_PrivateObj*)hMcbsp)->XmtEvent)
#define RCVEVENT(hMcbsp) (((MCBSP_PrivateObj*)hMcbsp)->RcvEvent)
#define ALLOCATED(hMcbsp)(((MCBSP_PrivateObj*)hMcbsp)->Allocated)

/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions
\****************************************/

/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_open,".text:MCBSP_open")

/*---/MCBSP_Handle -------------------------------------------------------------------------*/
MCBSP_Handle MCBSP_open(int DevNum, Uint32 Flags) {
  int oldgie;
  Uint16 portMask = 1u<<DevNum;
  Uint16 port = DevNum;

  MCBSP_Handle McbspPtr = INV;

  #ifdef _MCRTE_DEBUG
    if ((DevNum<0) || (DevNum>=MCBSP_PORT_CNT)) {
      ERR_submit(MCBSP_ERR_MAJOR, MCBSP_ERR_ALLOC);
      return (MCBSP_Handle)INV;
    }
  #endif


  if ((DevNum<MCBSP_PORT_ANY) || (DevNum>=MCBSP_PORT_CNT)) {
      return (MCBSP_Handle)INV;
  }

 oldgie = IRQ_globalDisable();

  if (DevNum == MCBSP_PORT_ANY) {
    for(port=0; port<= MCBSP_PORT_CNT-1;port++) {
      if (!(CSL_SYS_DATA.McbspPortAllocMask & (1u<<port))) {
        McbspPtr = MCBSP_HDEV(port);
        break;
      }
    }
  }
  else {
    if (!(CSL_SYS_DATA.McbspPortAllocMask & portMask)) {
      McbspPtr = MCBSP_HDEV(port);
    }
  }

  if (McbspPtr != INV) {
     CSL_SYS_DATA.McbspPortAllocMask |= 1u<<port;

     #if (_MMC_SUPPORT)
     if (port) {
         Uint16 mask;
         CSL_SYS_DATA.MmcAllocMask |= 1u<<(port-1);
         mask = (port==1) ? (0xFFF3u) : (0xFFCFu);
         _XBSR &= mask;
     }
     #endif

     if (Flags&MCBSP_OPEN_RESET) {
       MCBSP_reset((MCBSP_Handle)McbspPtr);
     }
  }


  IRQ_globalRestore(oldgie);

  MCBSP_ASSERT_HANDLE((MCBSP_Handle)McbspPtr,return INV);

   return (MCBSP_Handle)McbspPtr;
}

/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MCBSP_open.c
\******************************************************************************/

mcbsp_r16.c/    1049977129  0     0     0       3254      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... MCBSP_r16.c
* DATE CREATED.. Wed 05/16/2001 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  05/16/2001
*   MODIFIED: 07/02/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  Reads a 16 bit value from the MCBSP DRR1
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>    

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/


/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions       
\****************************************/
 
 
  
/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_read16,".text:MCBSP_read16")

/*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------*/
Uint16 MCBSP_read16(MCBSP_Handle _MCBSP) {
  Uint16 val;
  MCBSP_ASSERT_HANDLE(_MCBSP,return 0xFFFFFFFF);
  val = _PREG_GET(((MCBSP_PrivateObj*)_MCBSP)->Drr1Addr);
  return val;
}

/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MCBSP_r16.c
\******************************************************************************/

mcbsp_r32.c/    1065617104  0     0     0       3658      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... MCBSP_r32.c
* DATE CREATED.. Fri 06/11/1999
* PROJECT....... CSL - Chip Support Library
* COMPONENT.....
* IMPORTS.......
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999
*   MODIFIED: 01/25/2000  Modification for C54x DSP
*   MODIFIED: 02/23/2000  C54x ROMABILITY.
*   MODIFIED: 06/02/2000  Modification for C55x DSP
*   MODIFIED: 05/16/2001  Modified to insure true RRDY
*   MODIFIED: 06/28/2001  added pragma for section per function
*   MODIFIED: 09/25/2003  Removed rrdy polling from MCBSP_read32()
*------------------------------------------------------------------------------
* DESCRIPTION:  Reads a 32 bit value from the MCBSP DRR1/2
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/


/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions
\****************************************/



/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_read32,".text:MCBSP_read32")

/*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------*/
Uint32 MCBSP_read32(MCBSP_Handle _MCBSP) {
  Uint16 drr2, drr1;
  Uint32 val;
  MCBSP_ASSERT_HANDLE(_MCBSP,return 0xFFFFFFFF);
  drr2 = _PREG_GET(((MCBSP_PrivateObj*)_MCBSP)->Drr2Addr);
  drr1 = _PREG_GET(((MCBSP_PrivateObj*)_MCBSP)->Drr1Addr);
  val = (((Uint32)drr2<<16)&0xFFFF0000 )|(drr1 &0x0000FFFF);
  return val;
}

/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MCBSP_r32.c
\******************************************************************************/

mcbsp_read.c/   1049977132  0     0     0       3249      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... MCBSP_r16.c
* DATE CREATED.. Wed 05/16/2001 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  05/16/2001
*   MODIFIED: 07/02/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  Reads a 16 bit value from the MCBSP DRR1
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>    

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/


/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions       
\****************************************/
 
 
  
/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_read,".text:MCBSP_read")

/*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------*/
Uint16 MCBSP_read(MCBSP_Handle _MCBSP) {
  Uint16 val;
  MCBSP_ASSERT_HANDLE(_MCBSP,return 0xFFFFFFFF);
  val = _PREG_GET(((MCBSP_PrivateObj*)_MCBSP)->Drr1Addr);
  return val;
}

/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MCBSP_read.c
\******************************************************************************/


mcbsp_rst.c/    1049977134  0     0     0       6288      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... MCBSP_reset.c
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999 Created for C6x
*   MODIFIED: 01/25/2000 Modification for C54x DSP
*   MODIFIED: 02/23/2000 C54x ROMABILITY. 
*   MODIFIED: 06/02/2000 Modification for C55x DSP
*   MODIFIED: 06/28/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the MCBSP module)
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/
#include <csl.h>
#include <csl_irq.h> 
#include <csl_mcbsp.h>    

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/


/* Map-register definition */
#define DRR1(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Drr1Addr)
#define DRR2(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Drr2Addr)
#define DXR1(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Dxr1Addr)
#define DXR2(hMcbsp)  PREG16(((MCBSP_PrivateObj*)hMcbsp)->Dxr2Addr)
#define XMTEVENT(hMcbsp) (((MCBSP_PrivateObj*)hMcbsp)->XmtEvent)
#define RCVEVENT(hMcbsp) (((MCBSP_PrivateObj*)hMcbsp)->RcvEvent)
#define ALLOCATED(hMcbsp)(((MCBSP_PrivateObj*)hMcbsp)->Allocated)


/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions       
\****************************************/
 
 
  
/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_reset,".text:MCBSP_reset")

/*----------------------------------------------------------------------------*/
void MCBSP_reset(MCBSP_Handle hMcbsp) {
  int oldgie;


  MCBSP_ASSERT_HANDLE(hMcbsp,return);
  oldgie = IRQ_globalDisable(); 
      
  if (hMcbsp == INV) {
    MCBSP_reset(MCBSP_HDEV0);
    MCBSP_reset(MCBSP_HDEV1);
    MCBSP_reset(MCBSP_HDEV2);
 
  } else {              
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->Spcr1Addr,MCBSP_SPCR1_DEFAULT) ; 
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->Spcr2Addr,MCBSP_SPCR2_DEFAULT) ;
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->Rcr1Addr,MCBSP_RCR1_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->Rcr2Addr,MCBSP_RCR2_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->Xcr1Addr,MCBSP_XCR1_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->Xcr2Addr,MCBSP_XCR2_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->Srgr1Addr,MCBSP_SRGR1_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->Srgr2Addr,MCBSP_SRGR2_DEFAULT);   
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->Mcr1Addr,MCBSP_MCR1_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->Mcr2Addr,MCBSP_MCR2_DEFAULT); 
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->RceraAddr,MCBSP_RCERA_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->RcerbAddr,MCBSP_RCERB_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->RcercAddr,MCBSP_RCERC_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->RcerdAddr,MCBSP_RCERD_DEFAULT); 
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->RcereAddr,MCBSP_RCERE_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->RcerfAddr,MCBSP_RCERF_DEFAULT); 
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->RcergAddr,MCBSP_RCERG_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->RcerhAddr,MCBSP_RCERH_DEFAULT); 
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->XceraAddr,MCBSP_XCERA_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->XcerbAddr,MCBSP_XCERB_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->XcercAddr,MCBSP_XCERC_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->XcerdAddr,MCBSP_XCERD_DEFAULT); 
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->XcereAddr,MCBSP_XCERE_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->XcerfAddr,MCBSP_XCERF_DEFAULT); 
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->XcergAddr,MCBSP_XCERG_DEFAULT);  
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->XcerhAddr,MCBSP_XCERH_DEFAULT);      
    _PREG_SET(((MCBSP_PrivateObj*)hMcbsp)->PcrAddr,MCBSP_PCR_DEFAULT);     
    IRQ_disable(XMTEVENT(hMcbsp));    
    IRQ_disable(RCVEVENT(hMcbsp));
    IRQ_clear(XMTEVENT(hMcbsp));
    IRQ_clear(RCVEVENT(hMcbsp));
          
  }
  IRQ_globalRestore(oldgie);
     
  return;
}

/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MCBSP_reset.c
\******************************************************************************/

mcbsp_start.c/  1049977135  0     0     0       2085      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... MCBSP
* FILENAME...... MCBSP_start.c
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999  Created
*   MODIFIED: 11/18/1999  Modified for TMS320C54xx
*   MODIFIED: 02/15/2000  C54x Romability .
*   MODIFIED: 10/17/2000  Modified for TMS320C55xx
*   MODIFIED: 03/23/2001  Modified to use new CSL types to avoid DSPBIOS
*                         definition conflict
*   MODIFIED: 06/28/2001  added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the MCBSP module)
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

#include <csl_mcbsp.h> 
  
#if (_MCBSP_SUPPORT)

#pragma CODE_SECTION(MCBSP_start,".text:MCBSP_start")

/*----------------------------------------------------------------------------*/
CSLBool MCBSP_start(MCBSP_Handle hMcbsp, Uint16 StartMask, Uint32 SampleRateDelay) {
 
  MCBSP_ASSERT_HANDLE(hMcbsp,return FALSE);

  if (StartMask & (MCBSP_SRGR_START | MCBSP_SRGR_FRAMESYNC)) {
    MCBSP_FSETH(hMcbsp,SPCR2,GRST,1);
    MCBSP_FSETH(hMcbsp,SPCR2,FRST,1);
    while(SampleRateDelay > 0) --SampleRateDelay;
  }

  if (StartMask & MCBSP_RCV_START) {
    MCBSP_FSETH(hMcbsp,SPCR1,RRST,1);
  }
  if (StartMask & MCBSP_XMIT_START) {
    MCBSP_FSETH(hMcbsp,SPCR2,XRST,1);
  }
 return TRUE;
}
#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MCBSP_start.c
\******************************************************************************/


mcbsp_w16.c/    1049977137  0     0     0       3241      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... MCBSP_w16.c
* DATE CREATED.. Wed 05/16/2001
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  05/16/2001
*   MODIFIED: 07/02/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  Writes a 16 bit value to the MCBSP DXR1
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>    

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/


/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions       
\****************************************/
 
 
  
/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_write16,".text:MCBSP_write16")

/*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------*/
void MCBSP_write16(MCBSP_Handle _MCBSP,Uint16 Val) {
MCBSP_ASSERT_HANDLE(_MCBSP,return);
_PREG_SET((((MCBSP_PrivateObj*)_MCBSP)->Dxr1Addr),(Val));
}                            
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MCBSP_w16.c
\******************************************************************************/


mcbsp_w32.c/    1065617105  0     0     0       3366      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... MCBSP_w32.c
* DATE CREATED.. Wed 05/16/2001
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   MODIFIED: 06/28/2001 added pragma for section per function
*   MODIFIED: 09/25/2003 Removed xrdy polling from MCBSP_write32().
*------------------------------------------------------------------------------
* DESCRIPTION:  Writes a 32 bit value to the MCBSP DRR1/2
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>    

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/


/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions       
\****************************************/
 
 
  
/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_write32,".text:MCBSP_write32")

/*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------*/
void MCBSP_write32(MCBSP_Handle _MCBSP,Uint32 Val) {
  MCBSP_ASSERT_HANDLE(_MCBSP,return);
  _PREG_SET((((MCBSP_PrivateObj*)_MCBSP)->Dxr2Addr),(Val>>16));
  _PREG_SET((((MCBSP_PrivateObj*)_MCBSP)->Dxr1Addr),(Val&0x0000FFFF));
}                            
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MCBSP_w32.c
\******************************************************************************/

mcbsp_write.c/  1049977140  0     0     0       3237      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... MCBSP
* FILENAME...... MCBSP_write.c
* DATE CREATED.. Wed 05/16/2001
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  05/16/2001
*   MODIFIED: 07/02/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  Writes a 16 bit value to the MCBSP DXR1
*
*
*
\******************************************************************************/
#define _MCBSP_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_mcbsp.h>    

#if (_MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP static macro declarations
\****************************************/


/****************************************\
* MCBSP static typedef declarations
\****************************************/

/****************************************\
* MCBSP static function declarations
\****************************************/

/****************************************\
* MCBSP static variable definitions       
\****************************************/
 
 
  
/****************************************\
* MCBSP static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* MCBSP global variable definitions
\****************************************/

/****************************************\
* MCBSP global function definitions
\****************************************/

#pragma CODE_SECTION(MCBSP_write,".text:MCBSP_write")

/*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------*/
void MCBSP_write(MCBSP_Handle _MCBSP,Uint16 Val) {
MCBSP_ASSERT_HANDLE(_MCBSP,return);
_PREG_SET((((MCBSP_PrivateObj*)_MCBSP)->Dxr1Addr),(Val));
}                            
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of MCBSP_w16.c
\******************************************************************************/


mmc_allcid.c/   1049977142  0     0     0       2404      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_allcid.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Sends the broadcast SEND_ALL_CID command to identify
*              attached MMC cards. Function returns the CID information
*              for a responding card in the specified card ID object
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>


#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_sendAllCID,".text:MMC_sendALLCID")

/**************************************************************************
* MMC_sendAllCID(MMC_Handle mmc, MMC_CardIdObj *cid)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          cid     - pointer to card ID object
***************************************************************************/

int MMC_sendAllCID(MMC_Handle mmc, MMC_CardIdObj *cid) {
  
  Uint16 old_intm;
  Uint16 stat;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();

  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command
  
  MMC_RSET_H(mmc,MMCARGH,MMC_STUFF_BITS);
  MMC_RSET_H(mmc,MMCARGL,MMC_STUFF_BITS);
  MMC_RSET_H(mmc,MMCCMD,MMC_ALL_SEND_CID);
    
  // Wait for response done
  

  while ((stat=MMC_responseDone(mmc))==0) {
  }
  if (stat==MMC_RESPONSE_TIMEOUT)
    return 0;

  mmc->numCards++;

  MMC_getCardID(mmc, cid);

  IRQ_globalRestore(old_intm);

  return 1;
}
#endif
  
mmc_cfg.c/      1051539316  0     0     0       2551      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_cfg.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Writes values to MMC control registers specified in
*              MMC_Config structure passed as argument to call.
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>
#include <csl_emif.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_config,".text:MMC_config")

/**************************************************************************
* MMC_config(MMC_Handle mmc, MMC_Config *cfg)
*          mmc     - Handle for MMC device previously returned from call
*                    to MMC_open
*          cfg     - MMC Configuration structure containing value to be
*                    assigned to MMC control registers.
***************************************************************************/

void MMC_config(MMC_Handle mmc, MMC_Config *cfg){

  Uint16 old_intm;
  Uint16 resetMask = _MMC_MMCCTL_CMDRST_MK(1) | _MMC_MMCCTL_DATRST_MK(1);
  ioport MMC_MmcRegObj *regs;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();
  // Perform Initialization //
  regs = mmc->mmcRegs;

  // Place controller in reset before changing other values
  
  regs->mmcctl = resetMask; 
  regs->mmcctl = cfg->mmcctl & (~(resetMask));

  regs->mmcfclkctl = cfg->mmcfclkctl;
  regs->mmcclk =  cfg->mmcclk;
  regs->mmcim  = cfg->mmcim;
  regs->mmctor  = cfg->mmctor;
  regs->mmctod  = cfg->mmctod;
  regs->mmcblen = cfg->mmcblen;
  regs->mmcnblk = cfg->mmcnblk;
  regs->mmcctl &= 0xFFFC;     // Take MMC out of reset //

  IRQ_globalRestore(old_intm);
}
#endif

  

mmc_cfga.c/     1051539315  0     0     0       3219      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_cfga.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Writes values to MMC control registers specified in
*              arguments pased to function.
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

/**************************************************************************
* MMC_configArgs(MMC_Handle mmc, Uint16 mmcctl, Uint16 mmcfclk, Uint16 mmcclk,
*            Uint16 mmcie, Uint16 mmctor, Uint16 mmctod, Uint16 mmcblen,
*            Uint16 mmcnblk)
*          mmc     - Handle for MMC device previously returned from call
*                    to MMC_open
*          mmcctl  - Value to write to MMC control register MMCCTL
*          mmcfclk - Value to write to MMC function clock register MMCFCLK
*          mmcclk  - Value to write to MMC clock register MMCCLK
*          mmcie   - Value to write to MMC interrupt enable mask register MMCIE
*          mmctor  - Value to write to MMC response timeout register MMCTOR
*          mmctod  - Value to write to MMC data receive timeout reg MMCTOD
*          mmcblen - Value to write to MMC block length register MMCBLEN
*          mmcnblk - Value to write to MMC no blocks in transfer regsiter MMCNBLK
***************************************************************************/

#pragma CODE_SECTION(MMC_configArgs,".text:MMC_configArgs")

void MMC_configArgs(MMC_Handle mmc, Uint16 mmcctl, Uint16 mmcfclkctl, Uint16 mmcclk,
           Uint16 mmcim, Uint16 mmctor, Uint16 mmctod, Uint16 mmcblen,
           Uint16 mmcnblk) {

  Uint16 old_intm;
  Uint16 resetMask = _MMC_MMCCTL_CMDRST_MK(1) | _MMC_MMCCTL_DATRST_MK(1);
  ioport MMC_MmcRegObj *regs;


  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();
  // Perform Initialization //
  regs = mmc->mmcRegs;

  // Place controller in reset before changing other values
  
  regs->mmcctl = resetMask; 
  regs->mmcctl = mmcctl & (~(resetMask));

  regs->mmcfclkctl = mmcfclkctl;
  regs->mmcclk  = mmcclk;
  regs->mmcim  = mmcim;
  regs->mmctor  = mmctor;
  regs->mmctod  = mmctod;
  regs->mmcblen = mmcblen;
  regs->mmcnblk = mmcnblk;
  regs->mmcctl &= 0xFFFC;     // Take MMC out of reset //

  IRQ_globalRestore(old_intm);
}
#endif 

mmc_close.c/    1049977146  0     0     0       2264      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_close.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Modified:	Changed #include csl_ebselhal.h to csl_chiphal.h
*
*------------------------------------------------------------------------------
* DESCRIPTION: Closes specified MMC device, previously opened by call
*              to MMC_open() 
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>


#if (_MMC_SUPPORT)

#include <csl_chiphal.h>

#pragma CODE_SECTION(MMC_close,".text:MMC_close")

/**************************************************************************
* MMC_close(MMC_Handle mmc)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
***************************************************************************/

void MMC_close(MMC_Handle mmc) {
  Uint16 old_intm;
  Uint16 dev = mmc->devNum;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();

  // Place Controller in Reset //
  regs->mmcctl = 0x3u;

  // Clear all response registers *//
  MMC_clearResponse(mmc);
 

  // Free Allocated Port (for both MMC and MCBSP) //
  CSL_SYS_DATA.MmcAllocMask &= ~(1u << dev);
  CSL_SYS_DATA.McbspPortAllocMask &= ~(1u << (dev+1));

  // Set System Register to configure Port as MCBSP port //
  _XBSR &= ~(0x3u << (dev ? 4 : 2));

  IRQ_globalRestore(old_intm);

}
#endif
mmc_clrrsp.c/   1049977148  0     0     0       1923      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_clrrsp.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Clears all response registers associated with specified
*              MMC controller. 
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_clearResponse,".text:MMC_clearResponse")

/**************************************************************************
* MMC_clearResponse(MMC_Handle mmc)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
***************************************************************************/

void MMC_clearResponse(MMC_Handle mmc) {
  Uint16 old_intm;
  ioport Uint16 *rsp;
  Uint16 i;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();
  rsp = (Uint16 *)&(mmc->mmcRegs->mmcrsp);

  // Clear all response registers //
  for(i=0; i<= 7; i++)
    rsp[i] = 0;

  IRQ_globalRestore(old_intm);
}
#endif
 

mmc_desel.c/    1049977149  0     0     0       2418      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_desel.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: De-selects the given card. This function is valid in SPI
*              mode only. 
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>
#include <csl_gpio.h>
#include <csl_mcbsp.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_deselectCard,".text:MMC_deselectCard")

/**************************************************************************
* MMC_deselectCard(MMC_Handle mmc, MMC_CardObj *card)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          card    - Card to be de-selected
***************************************************************************/

void MMC_deselectCard(MMC_Handle mmc, MMC_CardObj *card) {
  Uint16 old_intm;
  Uint16 gpio;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();

  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command
  gpio = (Uint16) ((card->rca >> 28) & (0x000Fu));
  
  // If GPIO is non-zero, we are in SPI mode and need to
  // toggle pin.

  if (gpio==MMC_CSEN_PIN) {
    regs->mmcctl &= _MMC_MMCCTL_CSEN_CLR;
  }
  else {
    _GPIO_IODIR &= (~(card->rca));  // Configure pin as output 
    _GPIO_IODATA = _GPIO_IODATA & (~(card->rca));  // Drive 0 on output to de-select
  }

  IRQ_globalRestore(old_intm);

}
#endif  
mmc_disp0.c/    1051539314  0     0     0       2070      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_disp0.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: ISR dispatch function to service MMC0 isrs.
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_dispatch0,".text:MMC_dispatch0")

/**************************************************************************
* MMC_dispatch0()
*         Default ISR dispatch handler for MMC DEV0
***************************************************************************/

 interrupt void MMC_dispatch0() {
 
  Uint16 enabled;
  Uint16 flagged;
  Uint16 service;
  Uint16 j,i;
  ioport MMC_MmcRegObj *regs;
  MMC_CallBackPtr *callBackTable;
  MMC_Handle mmc = MMC_hDev0;

  regs = mmc->mmcRegs;

  enabled = regs->mmcim;
  flagged = regs->mmcst0;

  if (!(enabled & flagged))
    return;

  callBackTable = (MMC_CallBackPtr*)&(mmc->callBackTbl);
  service = enabled & flagged;
  
  j = 1;
  i = 0;

  while (j<=0x0800u) {
    if (j&service)
      if ((MMC_CallBackPtr)callBackTable[i])
        callBackTable[i]();
    j = j << 1u;
    ++i;
  }
}
#endif

  
mmc_disp1.c/    1051539313  0     0     0       2206      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_disp1.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: ISR disptach function for MMC1 callback functions.
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_dispatch1,".text:MMC_dispatch1")

/**************************************************************************
* MMC_dispatch0()
*         Default ISR dispatch handler for MMC DEV1
***************************************************************************/

 interrupt void MMC_dispatch1() {

  Uint16 enabled;
  Uint16 flagged;
  Uint16 service;
  Uint16 j;
  int i;
  ioport MMC_MmcRegObj *regs;
  MMC_CallBackPtr *callBackTable;
  MMC_Handle mmc = MMC_hDev1;
  
  asm(" NOP");
  asm(" NOP");
  asm(" NOP");
  asm(" NOP");
  asm(" NOP");
  asm(" NOP");
  asm(" NOP");

  regs = mmc->mmcRegs;

  enabled = regs->mmcim;
  flagged = regs->mmcst0;

  if (!(enabled & flagged))
    return;

  callBackTable = (MMC_CallBackPtr*)&(mmc->callBackTbl);
  service = enabled & flagged;
  
  j = 1;
  i = -1;

  while (j<=0x0800u) {
    ++i;
    if (j&service)
      if ((MMC_CallBackPtr)(callBackTable[i]))
        callBackTable[i]();
    j = j << 1u;
 
  }
}
#endif

  
mmc_drrdy.c/    1049977154  0     0     0       1676      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_drrdy.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Returns TRUE if receive register has new data and is
*              ready to be read. 
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_drrdy,".text:MMC_drrdy")

/**************************************************************************
* MMC_drrdy(MMC_Handle mmc)
*          mmc      - Handle of MMC device reserved by previous call to 
*                     MMC_open()
***************************************************************************/

int MMC_drrdy(MMC_Handle mmc) {

  MMC_ASSERT_HANDLE(mmc,return);  
  return MMC_FGET_H(mmc,MMCST0,DRRDY);
}  
#endif
mmc_dxrdy.c/    1049977156  0     0     0       1676      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_drrdy.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Returns TRUE if transmit register is empty and is
*              ready for new data. 
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_dxrdy,".text:MMC_dxrdy")

/**************************************************************************
* MMC_dxrdy(MMC_Handle mmc)
*          mmc      - Handle of MMC device reserved by previous call to 
*                     MMC_open()
***************************************************************************/

int MMC_dxrdy(MMC_Handle mmc) {

  MMC_ASSERT_HANDLE(mmc,return);  
  return MMC_FGET_H(mmc,MMCST0,DXRDY);
}
#endif
 
mmc_erase.c/    1049977157  0     0     0       4779      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_erase.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Erases a single block of data on MMC card
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/
#include <stdarg.h>
#include <csl.h>
#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_erase,".text:MMC_erase")

/**************************************************************************
* MMC_erase(MMC_Handle mmc, Uint32 startAddr, Uint32 endAddr, Uint16 wait,...);
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          startAddr - Start Address on MMC Card to be erased
*          endAddr   - Ending Address for block to erase
*          wait      - TRUE if function should wait for erase complete
*                      before returning
*          ...       Start of variable length argument list
*          untag     - Pointer to list of sectors to UNTAG from the erase group
*          numTags   - Number of sectors to UNTAG.
***************************************************************************/

int MMC_erase(MMC_Handle mmc, Uint32 startAddr, Uint32 endAddr, Uint16 flags,...){
  va_list argList;
  Uint16 old_intm;
  Uint16 numSectors;
  Uint32 *sectors;

  ioport MMC_MmcRegObj *regs;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();


  regs = mmc->mmcRegs;


  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command

  regs->mmcargh = (Uint16)((startAddr >> 16)& 0xFFFFu);
  regs->mmcargl = (Uint16)(startAddr & 0xFFFFu);
  regs->mmccmd = MMC_TAG_SECTOR_START;

  // Wait for response done
  MMC_getStatus(mmc,MMC_ST0_RSPDNE);
  while (!MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_RSPDNE)) {
    if (MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_TOUTRS ))
       return 0;
  }

  // Format and send command

  regs->mmcargh = (Uint16)((endAddr >> 16)& 0xFFFFu);
  regs->mmcargl = (Uint16)(endAddr & 0xFFFFu);
  regs->mmccmd = MMC_TAG_SECTOR_END;

  // Wait for response done

  // Wait for response done
  MMC_getStatus(mmc,MMC_ST0_RSPDNE);
  while (!MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_RSPDNE)) {
    if (MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_TOUTRS ))
       return 0;
  }

  // Check to see if there are any sectors to be untagged
  if (flags & MMC_UNTAG_ERASE_SECTORS){

    va_start(argList,flags);
    
    sectors = va_arg(argList, Uint32 *);
    numSectors = va_arg(argList, Uint16);
    va_end(argList);

    if (numSectors > 16)
      numSectors = 16;

    do{
      regs->mmcargh = (Uint16)(((*sectors)>>16) & 0xFFFFu);
      regs->mmcargl = (Uint16)((*sectors) & 0xFFFFu);
      regs->mmccmd = MMC_UNTAG_SECTOR;

      // Wait for response done
      MMC_getStatus(mmc,MMC_ST0_RSPDNE);
      while (!MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_RSPDNE)) {
       if (MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_TOUTRS ))
         return 0;
      }
      ++sectors;
    }while(--numSectors);
  }
  
  

  // Format and send command

  regs->mmcargh = MMC_STUFF_BITS;
  regs->mmcargl = MMC_STUFF_BITS;
  regs->mmccmd = MMC_ERASE|0x0100;  /* enable busy expect bit */

  // Wait for response done

  // Wait for response done
 
  MMC_getStatus(mmc,MMC_ST0_RSPDNE);
  while (!MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_RSPDNE)) {
    if (MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_TOUTRS ))
       return 0;
  }

  // Wait until card is no longer sending busy
/*
  if (flags & MMC_WAIT_FOR_DATDNE){
    while (!MMC_getStatus(mmc, MMC_USE_LAST_STATUS | MMC_ST0_DATDNE)){
      if(MMC_getStatus(mmc, MMC_USE_LAST_STATUS | MMC_ST0_TOUTRD))
        return 0;
    }
  }  */

 IRQ_globalRestore(old_intm);
 			      
 return 1;
}
#endif 

mmc_gcfg.c/     1051539312  0     0     0       2280      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_gcfg.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Writes values to MMC control registers specified in
*              MMC_Config structure passed as argument to call.
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>


#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_getConfig,".text:MMC_getConfig")

/**************************************************************************
* MMC_getConfig(MMC_Handle mmc, MMC_Config *cfg)
*          mmc     - Handle for MMC device previously returned from call
*                    to MMC_open
*          cfg     - MMC Configuration structure containing values of the 
*                    MMC control registers returned by the function.
***************************************************************************/

void MMC_getConfig(MMC_Handle mmc, MMC_Config *cfg){

  Uint16 old_intm;
  ioport MMC_MmcRegObj *regs;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();
  regs = mmc->mmcRegs;

  
  cfg->mmcctl = regs->mmcctl; 
  cfg->mmcfclkctl = regs->mmcfclkctl;
  cfg->mmcclk = regs->mmcclk;
  cfg->mmcim = regs->mmcim;
  cfg->mmctor = regs->mmctor;
  cfg->mmctod = regs->mmctod;
  cfg->mmcblen = regs->mmcblen;
  cfg->mmcnblk = regs->mmcnblk;

  IRQ_globalRestore(old_intm);
}
#endif

  
mmc_getcid.c/   1049977161  0     0     0       3024      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_getcid.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Parses CID information from MMC response registers. Assumes
*              either ALL_SEND_CID or SEND_CID command has already been
*              issued and response is complete.
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_getCardID,".text:MMC_getCardID")

/**************************************************************************
* MMC_getCardID(MMC_Handle mmc, MMC_CardIDObj *cid)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          cid     - pointer to card ID object
***************************************************************************/

void MMC_getCardID(MMC_Handle mmc, MMC_CardIdObj *cid) {
  Uint16 old_intm;
  Uint16 lo,hi;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();

  cid->yearCode      = (regs->mmcrsp.rsp0 >> 8   ) & 0xF; // 11:8
  cid->monthCode     = (regs->mmcrsp.rsp0 >> 12  ) & 0xF; // 12:15
  lo                 = (regs->mmcrsp.rsp1);// 39:16
  hi                 = (regs->mmcrsp.rsp2 & 0x00FF);
  cid->serialNumber  = ((Uint32)hi<<16) | lo;
  cid->fwRev         = (regs->mmcrsp.rsp2 >>8  ) & 0x000F;  // 43:40
  cid->hwRev         = (regs->mmcrsp.rsp2 >>12 ) & 0x000F;  // 47:44
  lo                 = (regs->mmcrsp.rsp6 >>8  ) & 0x00FF;  //127:104
  hi                 = (regs->mmcrsp.rsp7      ); 
  cid->mfgId         = ((Uint32)hi << 16) | lo;   	

  cid->productName[0] = ((regs->mmcrsp.rsp3) & 0xFF);
  cid->productName[1] = ((regs->mmcrsp.rsp3) >> 8) & 0xFF;
  cid->productName[2] = ((regs->mmcrsp.rsp4) & 0xFF);
  cid->productName[3] = ((regs->mmcrsp.rsp4) >> 8) & 0xFF;
  cid->productName[4] = ((regs->mmcrsp.rsp5) & 0xFF);
  cid->productName[5] = ((regs->mmcrsp.rsp5) >> 8) & 0xFF;
  cid->productName[6] = ((regs->mmcrsp.rsp6) & 0xFF);
  cid->productName[7] = 0;

  IRQ_globalRestore(old_intm);
}
#endif
 
mmc_getcsd.c/   1049977162  0     0     0       4200      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_getcsd.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Parses CSD information from MMC response registers. Assumes
*              either SEND_CSD command has already been issued and response
*              is complete.
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>


#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_getCardCsd,".text:MMC_getCardcsd")

/**************************************************************************
* MMC_getCardCSD(MMC_Handle mmc, MMC_CardCsdObj *csd)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          csd     - pointer to card CSD object
***************************************************************************/

void MMC_getCardCsd(MMC_Handle mmc, MMC_CardCsdObj *csd) {
  Uint16 old_intm;
  ioport Uint16 *regs;
  Uint16 lo;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();

      regs = (Uint16 *)&(mmc->mmcRegs->mmcrsp);

      csd->ecc                = (regs[0] >>  8  ) & 3;         // 9:8
      csd->tmpWriteProtect    = (regs[0] >>  12 ) & 1;       // 12:12
	csd->permWriteProtect   = (regs[0] >>  13 ) & 1;       // 13:13
      csd->copy               = (regs[0] >>  14 ) & 1;         // 14:14

      csd->writeBlPartial     = (regs[1] >>   5 ) & 1;    // 21:21 
      csd->writeBlLen         = (regs[1] >>   6 ) & 0xF;  // 25:22
      csd->r2wFactor          = (regs[1] >>  10 ) & 0x7;  // 28:26
      csd->defaultEcc         = (regs[1] >>  13 ) & 0x3;  // 30:29 
      csd->wpGrpEnable        = (regs[1] >>  15 ) & 1;    // 31:31
	
      csd->wpGrpSize          = (regs[2] & 0x1f);           // 36:32
      csd->eraseGrpSize       = (regs[2]  >>  5 ) & 0x1f;      // 41:37
      csd->sectorSize         = (regs[2]  >> 10 ) & 0x1f;      // 46:42
	lo                      = (regs[2]  >> 15 ) & 1;         // 49:47
      csd->cSizeMult          = ((regs[3] &  3  ) << 1) | lo;
	
      csd->vddWCurrMax        = (regs[3]  >> 2  ) & 0x7;         // 52:50
      csd->vddWCurrMin        = (regs[3]  >> 5  ) & 0x7;       // 55:53
      csd->vddRCurrMax        = (regs[3]  >> 8  ) & 0x7;       // 58:56
      csd->vddRCurrMin        = (regs[3]  >> 11 ) & 0x7;       // 61:59
	lo                      = (regs[3]  >> 14 ) & 0x3;       // 73:62
      csd->cSize              = ((regs[4]  & 0x3FF) << 2) | lo; 
      csd->dsrImp             = (regs[4] >> 12  ) & 1;           // 76:76
      csd->readBlkMisalign    = (regs[4]  >> 13  ) & 1;        // 77:77
      csd->writeBlkMisalign   = (regs[4]  >> 14  ) & 1;        // 78:78
      csd->readBlPartial      = (regs[4]  >> 15  ) & 1;    // 79:79
	
      csd->readBlLen          = (regs[5]) & 0xf;           // 83:80
      csd->ccc                = (regs[5] >>  4 ) & 0xfff;  // 95:84
	csd->tranSpeed          = (regs[6]) & 0xff;          // 103:96
      csd->nsac               = (regs[6]  >>  8 ) & 0xff;  // 111:104
	
      csd->taac               = (regs[7]) & 0xff;          // 119:112
      csd->mmcProt            = (regs[7]  >> 10 ) & 0xf;   // 125:122
      csd->csdStructure       = (regs[7]  >> 14 ) & 0x3;   // 127:126

  IRQ_globalRestore(old_intm);
}
#endif

  
mmc_getno.c/    1049977164  0     0     0       2226      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_setrca.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Returns the total number of card found in the system
*              when in Native mode. Also returns in pointer arguments
*              the number of those cards that are currently active
*              and the number that ar inactive (off-line)
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_getNumberOfCards,".text:MMC_getNumberOfCards")

/**************************************************************************
* MMC_getNumberOfCards(MMC_Handle mmc, Uint16 *active, Uint16 *inactive)
*          mmc      - Handle of MMC device reserved by previous call to 
*                     MMC_open()
*          active   - Pointer where to return number of active cards
*          inactive - Pointer to where to return number of inactive cards
* Returns - total number of cards in system (active + inactrive)
***************************************************************************/

int MMC_getNumberOfCards(MMC_Handle mmc, Uint16 *active, Uint16 *inactive) {

  MMC_ASSERT_HANDLE(mmc,return);

  *active = mmc->numCardsActive;
  *inactive = mmc->numCardsInactive;
  
  return mmc->numCards;
}
#endif
  
mmc_getnum.c/   1049977166  0     0     0       2226      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_setrca.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Returns the total number of card found in the system
*              when in Native mode. Also returns in pointer arguments
*              the number of those cards that are currently active
*              and the number that ar inactive (off-line)
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_getNumberOfCards,".text:MMC_getNumberOfCards")

/**************************************************************************
* MMC_getNumberOfCards(MMC_Handle mmc, Uint16 *active, Uint16 *inactive)
*          mmc      - Handle of MMC device reserved by previous call to 
*                     MMC_open()
*          active   - Pointer where to return number of active cards
*          inactive - Pointer to where to return number of inactive cards
* Returns - total number of cards in system (active + inactrive)
***************************************************************************/

int MMC_getNumberOfCards(MMC_Handle mmc, Uint16 *active, Uint16 *inactive) {

  MMC_ASSERT_HANDLE(mmc,return);

  *active = mmc->numCardsActive;
  *inactive = mmc->numCardsInactive;
  
  return mmc->numCards;
}
#endif
  
mmc_getstat.c/  1049977168  0     0     0       2397      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_getstat.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Returns the total number of card found in the system
*              when in Native mode. Also returns in pointer arguments
*              the number of those cards that are currently active
*              and the number that ar inactive (off-line)
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_getStatus,".text:MMC_getStatus")

/**************************************************************************
* MMC_getStatus(MMC_Handle mmc, Uint32 lmask)
*          mmc      - Handle of MMC device reserved by previous call to 
*                     MMC_open()
*         lmask     - mask of status flags to check
*  Returns contents of MMC ST0 register.
***************************************************************************/

int MMC_getStatus(MMC_Handle mmc, Uint32 lmask) {
  Uint16 mask = (Uint16)(lmask & 0xFFFFu);
  Uint16 flag = (((lmask>>16) & 0x8000u)>>15);
  Uint16 old_intm;
  Uint16 old_status;
  Uint16 value;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc,return);
  old_intm = IRQ_globalDisable();
  old_status = mmc->status;
  mmc->status = regs->mmcst0;
  if (flag)
    value = (old_status & mask) | (mmc->status & mask);
  else
    value = mmc->status & mask;

  
  IRQ_globalRestore(old_intm);

  return value;
}
#endif 

mmc_incrds.c/   1049977169  0     0     0       3483      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_initcrd.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Sends all broadcast commands in the Card initialization
*              sequence to get all CID/CSD information from all attached
*              cards.
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_initCards,".text:MMC_initCards")

/**************************************************************************
* MMC_initCards(MMC_Handle mmc, MMC_CardObj *cards, 
*                Uint16 maxCards, Uint16 hVddMask, Uint116 startRca)
*          mmc         - Handle of MMC device reserved by previous call to 
*                        MMC_open()
*          cards       - Pointer to an array of card objcts to initialize
*          hVddMask    - Mask to get voltage range only or to force cards
*                        outside of voltage range to go offline.
*          startRca    - Starting value for first assigned relative card
*                        address.
***************************************************************************/

int MMC_initCards(MMC_Handle mmc, MMC_CardObj *cards, Uint16 hVddMask, Uint16 startRca) {

  Uint16 old_intm;
  Uint16 rca = startRca;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();

  //---------------------------------------------------------
  // Send Broadcast Command to Place All Cards in Idle State
  //---------------------------------------------------------
  MMC_sendGoIdle(mmc);

  //---------------------------------------------------------
  // Determine if there are any cards which cannot
  // communicate in acceptable voltage range for host
  //---------------------------------------------------------
  mmc->numCardsInactive = MMC_sendOpCond(mmc,hVddMask,MMC_VOLTAGE_RANGE_ONLY);
  
  //---------------------------------------------------------
  // Place all unacceptable cards in Inactive state
  //---------------------------------------------------------
  MMC_sendOpCond(mmc,hVddMask,MMC_FORCE_CARDS_INACTIVE);

  //---------------------------------------------------------  
  // Get CID for all remaining Cards and Set Their
  // Relative Card Addresses
  //---------------------------------------------------------
  mmc->numCardsActive = 0;
  
  while(MMC_sendAllCID(mmc,&(cards[mmc->numCards].cid))) {
    MMC_setRca(mmc,&(cards[mmc->numCards-1]),rca);
    ++rca;
  }

  IRQ_globalRestore(old_intm);

  return mmc->numCards;
}
#endif
 

mmc_init.c/     1051539312  0     0     0       4182      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_init.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Changes control register settings based on control
*              parameters
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>
#include <csl_pwr.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_init,".text:MMC_init")

/**************************************************************************
*  MMC_init(
*    MMC_Handle mmc,           // Handle returned from call to MMC_open   
*    Uint16 dmaEnable,         // Enable/disable DMA for data read/write 
*    Uint16 dat3EdgeDetection, // Set level of edge detection for DAT3 pin 
*    Uint16 goIdle,            // Determines if MMC goes IDLE during IDLE instr 
*    Uint16 enableClkPin,      // Memory clk reflected on CLK Pin 
*    Uint32 fdiv,              // CPU CLK to MMC function clk divide down 
*    Uint32 cdiv,              // MMC function clk to memory clk divide down 
*    Uint16 rspTimeout,        // No. memory clks to wait before response timeout 
*    Uint16 dataTimeout,       // No. memory clks to wait before data timeout 
*    Uint16 blenOrCrc          // Sets Block Length for Native Mode or
*                                 Enables/disables CRC checking in SPI mode 
*
***************************************************************************/

int MMC_init(
    MMC_Handle mmc,           // Handle returned from call to MMC_open   
    Uint16 dmaEnable,         // Enable/disable DMA for data read/write 
    Uint16 dat3EdgeDetection, // Set level of edge detection for DAT3 pin 
    Uint16 goIdle,            // Determines if MMC goes IDLE during IDLE instr 
    Uint16 enableClkPin,      // Memory clk reflected on CLK Pin 
    Uint32 fdiv,              // CPU CLK to MMC function clk divide down 
    Uint32 cdiv,              // MMC function clk to memory clk divide down 
    Uint16 rspTimeout,        // No. memory clks to wait before response timeout 
    Uint16 dataTimeout,       // No. memory clks to wait before data timeout 
    Uint16 blenOrCrc          // Sets Block Length for Native Mode or
                              // Enables/disables CRC checking in SPI mode 
){

  ioport MMC_MmcRegObj *regs;
  Uint16 old_intm;

  MMC_ASSERT_HANDLE(mmc, return FALSE );

  old_intm = IRQ_globalDisable();

  // Perform Initialization //
  regs = mmc->mmcRegs;



  regs->mmcctl |= 0x3;          // Place controller in reset
  regs->mmcctl |= _MMC_MMCCTL_DMAEN_MK(dmaEnable) |
                  _MMC_MMCCTL_DATEG_MK(dat3EdgeDetection);

  regs->mmcfclkctl = _MMC_MMCFCLK_FDIV_MK(fdiv);
  regs->mmcclk = _MMC_MMCCLK_CDIV_MK(cdiv);

  if (goIdle) {
    regs->mmcfclkctl |= _MMC_MMCFCLK_IDLEEN_MK(1);
    _ICR |= 0x1u;
  }

  regs->mmctor = _MMC_MMCTOR_TOR_MK(rspTimeout);
  regs->mmctod = _MMC_MMCTOD_TOD_MK(dataTimeout);
  

  if (regs->mmcctl & _MMC_MMCCTL_SPIEN_MK(1)) {
    regs->mmcctl |= _MMC_MMCCTL_SPICRC_MK(blenOrCrc);
  } 
  else {
   regs->mmcblen = blenOrCrc;
  }


  regs->mmcctl &= 0xFFFC;     // Take MMC out of reset //
  
  if (enableClkPin)
    regs->mmcclk |= _MMC_MMCCLK_CLKEN_MK(1);

  IRQ_globalRestore(old_intm);

  return mmc->numCards;
}
#endif
 
mmc_open.c/     1049977172  0     0     0       2643      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_open.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Modified:	Changed #include csl_ebselhal.h to csl_chiphal.h
*
*------------------------------------------------------------------------------
* DESCRIPTION: Returns MMC_Handle to specified device and optionally
*              initializes the MMC registers. 
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>
#include <csl_pwr.h>
#include <csl_chiphal.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_open,".text:MMC_open")

/**************************************************************************
* MMC_open(Uint16 dev, Uint16 flags, void *mmcInit)
*          dev     - MMC device number (0 or 1)
*          
*          
***************************************************************************/

MMC_Handle MMC_open(int dev) {
  MMC_Handle mmc = (MMC_Handle)INV;
  Uint16 mmcMask = 1u << dev;
  Uint16 mcbspMask = 1u << (dev+1);
  Uint16 old_intm;

  old_intm = IRQ_globalDisable();

  // Check for correct device number //

  if (dev>1) return (MMC_Handle)INV;

  // Check to see if device is already in Use //
  if ((CSL_SYS_DATA.MmcAllocMask & (mmcMask)) ||
      (CSL_SYS_DATA.McbspPortAllocMask & (mcbspMask))
      )    
     return mmc;

  // Reserve MMC for use and also reserve corresponding MCBSP port //
  CSL_SYS_DATA.MmcAllocMask |= mmcMask;
  CSL_SYS_DATA.McbspPortAllocMask |= mcbspMask;

  // Set System Register to configure Port as MMC port //
  _XBSR |= MMC_SET_MMC_MODE << (dev ? 4 : 2);

  // Get MMC_Handle //
  mmc = &(CSL_MMC_DATA.mmc[dev]);

  // Set Default Interrupt Handler
  mmc->mmcDispatch = (dev == 0) ? &MMC_dispatch0 : &MMC_dispatch1;

  IRQ_globalRestore(old_intm);
  
  // return mmc handle
  return mmc;

}
#endif  

mmc_read.c/     1049977174  0     0     0       3767      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_read.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Reads a block of data from MMC card
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_read,".text:MMC_read")

/**************************************************************************
* MMC_read(MMC_Handle mmc, Uint32 cardAddr, Uint16 *buffer, Uint32 length)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          carAddr - Address on MMC Card where read starts
*          buffer  - Pointer to buffer where data should be stored
*          length  - number of bytes to transfer.
***************************************************************************/

int MMC_read(MMC_Handle mmc, Uint32 cardAddr, Uint16 *buffer, Uint32 length){
  Uint16 old_intm;
  Uint16 noWords;
  Uint16 ready;
  Uint16 error;
  Uint16 done;
  Uint16 crd;
  Uint32 lastAddr;
  ioport MMC_MmcRegObj *regs;

  MMC_ASSERT_HANDLE(mmc, return);

  old_intm = IRQ_globalDisable();

  noWords = length/2;
  lastAddr = cardAddr;
  error = 0;
  done = 0;
  crd = mmc->currentCard;

  regs = mmc->mmcRegs;
  regs->mmcblen = length;
  regs->mmcnblk = 1;


  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command
  
  if (MMC_FGET_H(mmc,MMCCTL,SPIEN)) {
  MMC_FSET_H(mmc,MMCCTL,CSEN,1);  //select card
  }

  regs->mmcargh = (Uint16)((cardAddr >> 16)& 0xFFFFu);
  regs->mmcargl = (Uint16)(cardAddr & 0xFFFFu);
  
  if (!(MMC_FGET_H(mmc,MMCCTL,SPIEN))) {
  regs->mmccmd = MMC_READ_SINGLE_BLOCK|0xA000;  //send command
  }
  
  else {
  regs->mmccmd = MMC_READ_SINGLE_BLOCK|0xE000;  // if spimode, add 80 init cycles
  }

  IRQ_globalRestore(old_intm);

 // Make sure command was accepted and card is ready 
    // Waiting to see if i must do a getStatus command for this

 // Read data

 do {
   do {
     ready = MMC_getStatus(mmc, MMC_ST0_DRRDY);
     error = MMC_getStatus(mmc, MMC_USE_LAST_STATUS | MMC_ST0_CRCRD | MMC_ST0_TOUTRD | MMC_ST0_SPIERR);
     // Checking for early DATDNE
     done  |= MMC_getStatus(mmc, MMC_USE_LAST_STATUS | MMC_ST0_DATDNE);

   }while(  !error && !ready  );
			
   if(ready){				  
     *buffer++ = regs->mmcdrr;
     lastAddr += 2;
   } 
    
			
 }while( !error && --noWords );  
      
 // Test to make sure that we see a DATDNE signal  
 if( (error == 0) && (done == 0) ) {
    MMC_waitForFlag(mmc,MMC_ST0_DATDNE | MMC_ST0_TOUTRD);
    error = mmc->status & MMC_ST0_TOUTRD;
 }  

 mmc->cards[crd].lastAddrRead = lastAddr;
 
 if (MMC_FGET_H(mmc,MMCCTL,SPIEN)) {
 MMC_FSET_H(mmc,MMCCTL,CSEN,0);
 }
 			      
 // Check for errors.
 return( error == 0 ? 0 : -1 );
}
#endif

  

mmc_rspdne.c/   1049977175  0     0     0       2204      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_rspdne.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Checks status register for response complete condition.
*              If timeout occurs before reponse done flag is set, function
*              returns an error condition of 0xFFFF = MMC_RESPONSE_TIMEOUT
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_responseDone,".text:MMC_responseDone")

/**************************************************************************
* MMC_setRca(MMC_Handle mmc, Uint16 rca)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          rca     - User assigned relative card address
***************************************************************************/

int MMC_responseDone(MMC_Handle mmc) {
  Uint16 old_intm;

  MMC_ASSERT_HANDLE(mmc, return);
  old_intm = IRQ_globalDisable();

  // Wait for response done

  MMC_getStatus(mmc,MMC_ST0_RSPDNE);
  while (!MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_RSPDNE)) {
    if (MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_TOUTRS ))
       return MMC_RESPONSE_TIMEOUT;
  }

  IRQ_globalRestore(old_intm);

  return 1;
}
#endif

  
mmc_savst.c/    1049977177  0     0     0       1867      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_savstat.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Saves current status of MMC
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPPORT)

#pragma CODE_SECTION(MMC_saveStatus,".text:MMC_saveStatus")

/**************************************************************************
* MMC_saveStatus(MMC_Handle mmc)
*          mmc      - Handle of MMC device reserved by previous call to 
*                     MMC_open()
*  Saves current contents of MMC ST0 register and saves it in MMC Handle
***************************************************************************/

int MMC_saveStatus(MMC_Handle mmc) {
  Uint16 old_intm;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();

  mmc->status = regs->mmcst0;

  IRQ_globalRestore(old_intm);

  return mmc->status;
}
#endif
 

mmc_savstat.c/  1049977179  0     0     0       1866      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_savstat.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Saves current status of MMC
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_saveStatus,".text:MMC_saveStatus")

/**************************************************************************
* MMC_saveStatus(MMC_Handle mmc)
*          mmc      - Handle of MMC device reserved by previous call to 
*                     MMC_open()
*  Saves current contents of MMC ST0 register and saves it in MMC Handle
***************************************************************************/

int MMC_saveStatus(MMC_Handle mmc) {
  Uint16 old_intm;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();

  mmc->status = regs->mmcst0;

  IRQ_globalRestore(old_intm);

  return mmc->status;
}
#endif
 
mmc_selcard.c/  1049977180  0     0     0       2796      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_selcard.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Selects the given card 
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>
#include <csl_gpio.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_selectCard,".text:MMC_selectCard")

/**************************************************************************
* MMC_selectCard(MMC_Handle mmc, MMC_CardObj *card)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          card    - Card to be selected
***************************************************************************/

int MMC_selectCard(MMC_Handle mmc, MMC_CardObj *card) {
  Uint16 old_intm;
  Uint16 rca;
  Uint16 gpio;

  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc,return);

  old_intm = IRQ_globalDisable();

  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command
  gpio = (Uint16) ((card->rca >> 16) & (0xFFFFu));
  rca = (Uint16)(card->rca & 0xFFFFu);
  
  // If GPIO is non-zero, we are in SPI mode and need to
  // toggle pin.

  if (gpio) {
    if (gpio==MMC_CSEN_PIN) {
    regs->mmcctl |= _MMC_MMCCTL_CSEN_MK(1);
    }
    else {
      _GPIO_IODIR &= (~(card->rca));    // Configure pin as output
      _GPIO_IODATA |= card->rca;        // Drive a 1 on pin to select
    }
    IRQ_globalRestore(old_intm);
  } 
  else {
    if (rca == 0) return 0;          // Zero is invalid, it is reserved

    regs->mmcargh = rca;  
    regs->mmcargl = MMC_STUFF_BITS;
    regs->mmccmd = MMC_SELECT_CARD;

    IRQ_globalRestore(old_intm);

    // Wait for response done

    MMC_waitForFlag(mmc, MMC_ST0_RSPDNE | MMC_ST0_TOUTRS);
    if (mmc->status & MMC_ST0_TOUTRS)
       return 0;

  }
  return 1;
}
#endif

  
mmc_send_op.c/  1049977182  0     0     0       2371      `
#define _MMC_MOD_

#include <csl_chiphal.h>

#if (_MMC_SUPPORT)

#include <csl_mmc.h>

#define VDD_32_33		0x0010  // 0x007f		
#define   OP_TIMEOUT     1024

/*should have a wide range of voltage-- between 2.6 and 3.6, but 3.3 is the preferred*/
#pragma CODE_SECTION(MMC_sendOpCond,".text:MMC_sendOpCond")
int MMC_sendOpCond(MMC_Handle mmc, Uint32 hVddMask)
{              
	Uint16 stat; 
	long op_timeout;
	static int Debug = 0;
	static unsigned long OpLoop; 
	             
	// Set flags to busy and fail             
	op_timeout       = OP_TIMEOUT;
	OpLoop           = 0;
	 
	// You will go through this loop at least twice.  The first time
	// you will apply your requested voltage level and receive a
	// busy.  The second time you re-apply your voltage level and
	// generaly get a not busy.  This indicates the card has
	// initialized.
	//  
    // Clear status
//    stat = pMMC->st0;     
    
	do
	{    
	    // For debug.  Want to know how many loops it takes.
		OpLoop++;
				              
		// Set minimal voltage range
		if (MMC_FGET_H(mmc,MMCCTL,SPIEN)) {
		
		MMC_FSET_H(mmc,MMCCTL,CSEN,1);		              
		
		MMC_RSET_H(mmc,MMCARGH,0);
		MMC_RSET_H(mmc,MMCARGL,0);
		MMC_RSET_H(mmc,MMCCMD,MMC_CMD1|MMC_RSP1|0x4000);	    
		}
		else {
		
		if (hVddMask < 128 | hVddMask > 4194304) {  /* mask must be within 8 - 23 (bit positions)*/
		return -1;
		}
				
		MMC_RSET_H(mmc,MMCARGH,(Uint16)((hVddMask >> 16)& 0xFFFFu));
		MMC_RSET_H(mmc,MMCARGL,(Uint16)(hVddMask & 0xFFFFu) );
		MMC_RSET_H(mmc,MMCCMD,MMC_SEND_OP_COND);
			    
		}
   		
		// Break on response fail  
		while ((stat=MMC_responseDone(mmc))==0) {
        }
        if (stat==MMC_RESPONSE_TIMEOUT)
            break;
 		// Resp = R3                      
        // Busy bit is in MSB of rsp7.  If '1' (not busy) then we are done.                  
      	stat = MMC_RGET_H(mmc,MMCRSP7);   
      	if (MMC_FGET_H(mmc,MMCCTL,SPIEN)) {
      	if( !stat )     {
	    	MMC_FSET_H(mmc,MMCCTL,CSEN,0);
	    	return( 0 );      	
	    	            }
      	}
      	
      	else {
	    if( stat & 0x8000 )
	    	return( 0 );
	    	}
	     	    	  
		if( !Debug )
			op_timeout--; 
					  	    	  
	}while( op_timeout > 0 );
	     
	// Timed out
	MMC_FSET_H(mmc,MMCCTL,CSEN,0);     
	return( -1 );
}  
#endif


mmc_sendop.c/   1049977184  0     0     0       2371      `
#define _MMC_MOD_

#include <csl_chiphal.h>

#if (_MMC_SUPPORT)

#include <csl_mmc.h>

#define VDD_32_33		0x0010  // 0x007f		
#define   OP_TIMEOUT     1024

/*should have a wide range of voltage-- between 2.6 and 3.6, but 3.3 is the preferred*/
#pragma CODE_SECTION(MMC_sendOpCond,".text:MMC_sendOpCond")
int MMC_sendOpCond(MMC_Handle mmc, Uint32 hVddMask)
{              
	Uint16 stat; 
	long op_timeout;
	static int Debug = 0;
	static unsigned long OpLoop; 
	             
	// Set flags to busy and fail             
	op_timeout       = OP_TIMEOUT;
	OpLoop           = 0;
	 
	// You will go through this loop at least twice.  The first time
	// you will apply your requested voltage level and receive a
	// busy.  The second time you re-apply your voltage level and
	// generaly get a not busy.  This indicates the card has
	// initialized.
	//  
    // Clear status
//    stat = pMMC->st0;     
    
	do
	{    
	    // For debug.  Want to know how many loops it takes.
		OpLoop++;
				              
		// Set minimal voltage range
		if (MMC_FGET_H(mmc,MMCCTL,SPIEN)) {
		
		MMC_FSET_H(mmc,MMCCTL,CSEN,1);		              
		
		MMC_RSET_H(mmc,MMCARGH,0);
		MMC_RSET_H(mmc,MMCARGL,0);
		MMC_RSET_H(mmc,MMCCMD,MMC_CMD1|MMC_RSP1|0x4000);	    
		}
		else {
		
		if (hVddMask < 128 | hVddMask > 4194304) {  /* mask must be within 8 - 23 (bit positions)*/
		return -1;
		}
				
		MMC_RSET_H(mmc,MMCARGH,(Uint16)((hVddMask >> 16)& 0xFFFFu));
		MMC_RSET_H(mmc,MMCARGL,(Uint16)(hVddMask & 0xFFFFu) );
		MMC_RSET_H(mmc,MMCCMD,MMC_SEND_OP_COND);
			    
		}
   		
		// Break on response fail  
		while ((stat=MMC_responseDone(mmc))==0) {
        }
        if (stat==MMC_RESPONSE_TIMEOUT)
            break;
 		// Resp = R3                      
        // Busy bit is in MSB of rsp7.  If '1' (not busy) then we are done.                  
      	stat = MMC_RGET_H(mmc,MMCRSP7);   
      	if (MMC_FGET_H(mmc,MMCCTL,SPIEN)) {
      	if( !stat )     {
	    	MMC_FSET_H(mmc,MMCCTL,CSEN,0);
	    	return( 0 );      	
	    	            }
      	}
      	
      	else {
	    if( stat & 0x8000 )
	    	return( 0 );
	    	}
	     	    	  
		if( !Debug )
			op_timeout--; 
					  	    	  
	}while( op_timeout > 0 );
	     
	// Timed out
	MMC_FSET_H(mmc,MMCCTL,CSEN,0);     
	return( -1 );
}  
#endif


mmc_setNat.c/   1051539311  0     0     0       2890      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_setnat.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Modified:	04/04/2002 Renamed function to MMC_setupNative
*      Modified:  05/07/2002 changed #include csl_ebselhal.h to csl_chiphal.h
*------------------------------------------------------------------------------
* DESCRIPTION: Initializes the MMC Controller for Native Mode 
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>
#include <csl_pwr.h>
#include <csl_chiphal.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_setupNative,".text:MMC_setupNative")

/**************************************************************************
* MMC_setupNative(Uint16 dev, MMC_SetupNative *mmcInit)
*          mmc     - MMC Handle
* 
*          mmcInit - pointer to structure contianing initial register
*                    configuration information
***************************************************************************/

void MMC_setupNative(MMC_Handle mmc, MMC_SetupNative *mmcInit) {
  ioport MMC_MmcRegObj *regs;
  Uint16 old_intm;

  MMC_SetupNative *init = (MMC_SetupNative*)mmcInit;
  
  MMC_ASSERT_HANDLE(mmc, return FALSE );

  old_intm = IRQ_globalDisable();
  

  // Perform Initialization //
  regs = mmc->mmcRegs;

  regs->mmcctl |= 0x3;          // Place controller in reset
  regs->mmcctl |= _MMC_MMCCTL_DMAEN_MK(init->dmaEnable) |
                 _MMC_MMCCTL_SPIEN_MK(0) |
                 _MMC_MMCCTL_DATEG_MK(init->dat3EdgeDetection);

  regs->mmcfclkctl = _MMC_MMCFCLK_FDIV_MK(init->fdiv);
  regs->mmcclk = _MMC_MMCCLK_CDIV_MK(init->cdiv);

  if (init->goIdle) {
    regs->mmcfclkctl |= _MMC_MMCFCLK_IDLEEN_MK(1);
    _ICR |= 0x1u;
  }

  regs->mmctor = _MMC_MMCTOR_TOR_MK(init->rspTimeout);
  regs->mmctod = _MMC_MMCTOD_TOD_MK(init->dataTimeout);
  regs->mmcblen = _MMC_MMCBLEN_BLEN_MK(init->blockLen);

  regs->mmcctl &= 0xFFFC;     // Take MMC out of reset //
  
  if (init->enableClkPin)
    regs->mmcclk |= _MMC_MMCCLK_CLKEN_MK(1);

  IRQ_globalRestore(old_intm);


}
#endif  
mmc_setSpi.c/   1051539310  0     0     0       2867      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_setSpi.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Modified:	04/04/2002 Changed function name to MMC_setupSpi
*      Modified:  05/07/2002 changed #include csl_ebselhal.h to csl_chiphal.h
*------------------------------------------------------------------------------
* DESCRIPTION: Initializes the MMC Controller for Native Mode 
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>
#include <csl_pwr.h>
#include <csl_chiphal.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_setupSpi,".text:MMC_setupSpi")

/**************************************************************************
* MMC_setupSpi(Uint16 dev, MMC_SetupSpi *mmcInit)
*          mmc     - MMC Handle
* 
*          mmcInit - pointer to structure contianing initial register
*                    configuration information
***************************************************************************/

void MMC_setupSpi(MMC_Handle mmc, MMC_SetupSpi *mmcInit) {
  ioport MMC_MmcRegObj *regs;
  Uint16 old_intm;

  MMC_SetupSpi *init = (MMC_SetupSpi*)mmcInit;
  
  MMC_ASSERT_HANDLE(mmc, return FALSE );

  old_intm = IRQ_globalDisable();
  

  // Perform Initialization //
  regs = mmc->mmcRegs;

  regs->mmcctl |= 0x3;          // Place controller in reset
  regs->mmcctl |= _MMC_MMCCTL_DMAEN_MK(init->dmaEnable) |
                 _MMC_MMCCTL_SPIEN_MK(1) |
                 _MMC_MMCCTL_SPICRC_MK(init->spiCrc) |
                 _MMC_MMCCTL_DATEG_MK(init->dat3EdgeDetection);

  regs->mmcfclkctl = _MMC_MMCFCLK_FDIV_MK(init->fdiv);
  regs->mmcclk = _MMC_MMCCLK_CDIV_MK(init->cdiv);

  if (init->goIdle) {
    regs->mmcfclkctl |= _MMC_MMCFCLK_IDLEEN_MK(1);
    _ICR |= 0x1u;
  }

  regs->mmctor = _MMC_MMCTOR_TOR_MK(init->rspTimeout);
  regs->mmctod = _MMC_MMCTOD_TOD_MK(init->dataTimeout);

  regs->mmcctl &= 0xFFFC;     // Take MMC out of reset //
  
  if (init->enableClkPin)
    regs->mmcclk |= _MMC_MMCCLK_CLKEN_MK(1);

  IRQ_globalRestore(old_intm);


}
#endif  

mmc_setcall.c/  1051539309  0     0     0       2900      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_setcall.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Halts current data transfer.
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_setCallBack,".text:MMC_setCallBack")

/**************************************************************************
* MMC_setCallBack(MMC_Handle mmc, MMC_CallBackObj *callBackFuncs)
*      mmc - Handle for MMC Device returned from call to MMC_open
*      callBackFuncs - pointer to MMC_CallBackObj containing predefined
*                      set of functions to call to service flagged 
*                      MMC interrupts       
***************************************************************************/

 void MMC_setCallBack(MMC_Handle mmc, Uint16 enableMask, MMC_CallBackObj *callBackFuncs) {
   Uint16 event;
   ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

   mmc->callBackTbl.mmcDatdneCallBack = callBackFuncs->mmcDatdneCallBack;
   mmc->callBackTbl.mmcBsydneCallBack = callBackFuncs->mmcBsydneCallBack;
   mmc->callBackTbl.mmcRspdneCallBack = callBackFuncs->mmcRspdneCallBack;
   mmc->callBackTbl.mmcToutrdCallBack = callBackFuncs->mmcToutrdCallBack;
   mmc->callBackTbl.mmcToutrsCallBack = callBackFuncs->mmcToutrsCallBack;
   mmc->callBackTbl.mmcCrcwrCallBack  = callBackFuncs->mmcCrcwrCallBack;
   mmc->callBackTbl.mmcCrcrdCallBack  = callBackFuncs->mmcCrcrdCallBack;
   mmc->callBackTbl.mmcCrcrsCallBack  = callBackFuncs->mmcCrcrsCallBack;
//   mmc->callBackTbl.mmcSpierrCallBack = callBackFuncs->mmcSpierrCallBack;
   mmc->callBackTbl.mmcDxrdyCallBack  = callBackFuncs->mmcDxrdyCallBack;
   mmc->callBackTbl.mmcDrrdyCallBack  = callBackFuncs->mmcDrrdyCallBack;
   mmc->callBackTbl.mmcDategCallBack  = callBackFuncs->mmcDategCallBack;

   regs->mmcim = enableMask;
   event = mmc->eventId;
   IRQ_clear(event);
   IRQ_plug(event, (IRQ_IsrPtr)(mmc->mmcDispatch));  

}

#endif
 
mmc_setcptr.c/  1049977190  0     0     0       1962      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_setcptr.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Sets the card pointer in MMC global status table
*              This function must be used if the application performs
*              system/card initialization outside of MMC_initCard function.
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_setCardPtr,".text:MMC_setCardPtr")

/**************************************************************************
* MMC_setCardPtr(MMC_Handle mmc, MMC_CardObj *cards)
*          mmc      - Handle of MMC device reserved by previous call to 
*                     MMC_open()
*          cards   - Pointer to set of card objects that define all cards
*                    connected to the MMC controller
***************************************************************************/

void MMC_setCardPtr(MMC_Handle mmc, MMC_CardObj *cards){

  MMC_ASSERT_HANDLE(mmc, return);

  mmc->cards = cards;
}
#endif
  
mmc_setrca.c/   1049977192  0     0     0       2551      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_setrca.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Sets the Relative Card Address for current card. Assumes
*              ALL_SEND_CID command has already been issued and response
*              is complete.
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_setRca,".text:MMC_setRca")

/**************************************************************************
* MMC_setRca(MMC_Handle mmc, Uint16 rca)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          rca     - User assigned relative card address
***************************************************************************/

int MMC_setRca(MMC_Handle mmc, MMC_CardObj *card, Uint16 rca) {
  Uint16 old_intm;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc, return);
  old_intm = IRQ_globalDisable();

  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command

  if(rca == 0) return 0;          // Zero is invalid, it is reserved

  regs->mmcargh = rca;
  regs->mmcargl = MMC_STUFF_BITS;
  regs->mmccmd = MMC_SET_RELATIVE_ADDR;

  // Wait for response done

  MMC_getStatus(mmc,MMC_ST0_RSPDNE);
  while (!MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_RSPDNE)) {
    if (MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_TOUTRS ))
       return 0;
  }

  IRQ_globalRestore(old_intm);

  card->rca = rca; 
  card->cardIndex = mmc->nextIndex;
  ++(mmc->nextIndex);

  return 1;
}
#endif

  

mmc_setsel.c/   1049977193  0     0     0       1954      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_setsel.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Associates GPIO or CS signal with specified Card
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/
#include <csl.h>
#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_setChipSelect,".text:MMC_setChipSelect")

/**************************************************************************
* MMC_setCHipSelect(MMC_Handle mmc, Uint16 gpioPin, MMC_CardObj *card)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          gpioPin - GPIO Pin identifier
*          card    - Pointer to card object
***************************************************************************/

void MMC_setChipSelect(MMC_Handle mmc, Uint16 gpioPin, MMC_CardObj *card) {

  MMC_ASSERT_HANDLE(mmc, return);
  
    GPIO_open(gpioPin,0);          // Reserve GPIO pin, but discard handle
    card->rca = gpioPin;
    mmc->currentCard = card->cardIndex;
}

#endif
 
mmc_stop.c/     1049977195  0     0     0       2166      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_stop.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Halts current data transfer.
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_stop,".text:MMC_stop")

/**************************************************************************
* MMC_stop(MMC_Handle mmc)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
***************************************************************************/

 int MMC_stop(MMC_Handle mmc) {
  Uint16 old_intm;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc, return);
  old_intm = IRQ_globalDisable();

  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command

  regs->mmcargh = MMC_STUFF_BITS;
  regs->mmcargl = MMC_STUFF_BITS;
  regs->mmccmd = MMC_STOP_TRANSMISSION;

  // Wait for response done

  MMC_getStatus(mmc,MMC_ST0_RSPDNE);
  while (!MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_RSPDNE)) {
    if (MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_TOUTRS ))
       return 0;
  }

  IRQ_globalRestore(old_intm);

  return 1;
}
#endif

  
mmc_toutrs.c/   1049977197  0     0     0       2549      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_setrca.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Sets the Relative Card Address for current card. Assumes
*              ALL_SEND_CID command has already been issued and response
*              is complete.
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_setRca,".text:MMC_setRca")

/**************************************************************************
* MMC_setRca(MMC_Handle mmc, Uint16 rca)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          rca     - User assigned relative card address
***************************************************************************/

int MMC_setRca(MMC_Handle mmc, MMC_CardObj *card, Uint16 rca) {
  Uint16 old_intm;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc,return);
  old_intm = IRQ_globalDisable();

  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command

  if(rca == 0) return 0;          // Zero is invalid, it is reserved

  regs->mmcargh = rca;
  regs->mmcargl = MMC_STUFF_BITS;
  regs->mmccmd = MMC_SET_RELATIVE_ADDR;

  // Wait for response done

  MMC_getStatus(mmc,MMC_ST0_RSPDNE);
  while (!MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_RSPDNE)) {
    if (MMC_getStatus(mmc,MMC_USE_LAST_STATUS | MMC_ST0_TOUTRS ))
       return 0;
  }

  IRQ_globalRestore(old_intm);

  card->rca = rca;
  card->cardIndex = mmc->nextIndex;
  ++(mmc->nextIndex);

  return 1;
}
#endif

  

mmc_waitfor.c/  1049977198  0     0     0       2159      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_waitfor.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Returns the total number of card found in the system
*              when in Native mode. Also returns in pointer arguments
*              the number of those cards that are currently active
*              and the number that ar inactive (off-line)
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_waitForFlag,".text:MMC_waitForFlag")

/**************************************************************************
* MMC_waitForFlag(MMC_Handle mmc, Uint16 mask)
*          mmc      - Handle of MMC device reserved by previous call to 
*                     MMC_open()
*          mask     - Mask of status flags to wait for (ST0)
*  Returns contents of MMC ST0 register.
***************************************************************************/

int MMC_waitForFlag(MMC_Handle mmc, Uint16 mask) {
  Uint16 done;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc,return);

 done = 0;
  while (!done) {
    mmc->status = regs->mmcst0;
    if (!((mmc->status & mask)==0))
       done = 1;
  }
  return done;
}
  
#endif

mmc_write.c/    1049977200  0     0     0       3924      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_write.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Writes a single block of data to MMC card
*
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/
#include <csl.h>
#include <csl_mmc.h>
#include <csl_emif.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_write, ".text:MMC_write")

/**************************************************************************
* MMC_write(MMC_Handle mmc, Uint32 cardAddr, Uint16 *buffer, Uint32 length)
*          mmc     - Handle of MMC device reserved by previous call to 
*                    MMC_open()
*          cardAddr - Start Address on MMC Card where data is to be written
*          buffer  - Pointer to buffer where data should be stored
*          length  - number of bytes to transfer.
***************************************************************************/

int MMC_write(MMC_Handle mmc, Uint32 cardAddr, void *buffer, Uint32 length) {
  Uint16 old_intm;
  Uint16 noWords;
  Uint16 tmp;
  Uint16 ready;
  Uint16 error;
  Uint16 done;
  Uint16 crdIndex;
  Uint32 lastAddr;
  Uint16 *buf = buffer;
  ioport MMC_MmcRegObj *regs;

  MMC_ASSERT_HANDLE(mmc, return);
  old_intm = IRQ_globalDisable();

  tmp = length>>1;
  noWords = tmp + (length-(tmp<<1));
  lastAddr = cardAddr;
  error = 0;
  done = 0;

  crdIndex = mmc->currentCard - 2;
  regs = mmc->mmcRegs;
  regs->mmcblen = length;
  regs->mmcnblk = 1;


  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command
  
  if (MMC_FGET_H(mmc,MMCCTL,SPIEN)) {
  MMC_FSET_H(mmc,MMCCTL,CSEN,1);  //select card
  }

  regs->mmcargh = (Uint16)((cardAddr >> 16)& 0xFFFFu);
  regs->mmcargl = (Uint16)(cardAddr & 0xFFFFu);
  regs->mmcdxr = *buf++;
  
  if (!(MMC_FGET_H(mmc,MMCCTL,SPIEN))) {
  regs->mmccmd = MMC_WRITE_BLOCK|0xA800;  //send command
  }
  
  else {
  regs->mmccmd = MMC_WRITE_BLOCK|0xE800;  // if spimode, add 80 init cycles
  }
  
  IRQ_globalRestore(old_intm);

 // Make sure command was accepted and card is ready 
 // Waiting to see if i must do a getStatus command for this

 // Write data

 do {
   do {
     ready = MMC_getStatus(mmc, MMC_ST0_DXRDY);
     error = MMC_getStatus(mmc, MMC_USE_LAST_STATUS | MMC_ST0_CRCWR | MMC_ST0_TOUTRD);
    
     // Checking for early DATDNE
     done  |= MMC_getStatus(mmc, MMC_USE_LAST_STATUS | MMC_ST0_DATDNE);

   }while(  !error && !ready  ); 
			
   if(ready){				  
     regs->mmcdxr = *buf++; 
     lastAddr += 2;
   }
			
 }while( !error && --noWords );  
      
 // Test to make sure that we see a DATDNE signal  
 if( (error == 0) && (done == 0) ) {
    MMC_waitForFlag(mmc,MMC_ST0_DATDNE | MMC_ST0_TOUTRD);
    error = mmc->status & MMC_ST0_TOUTRD;
 }  

 mmc->cards[crdIndex].lastAddrWritten = lastAddr;
 
 if (MMC_FGET_H(mmc,MMCCTL,SPIEN)) {
 MMC_FSET_H(mmc,MMCCTL,CSEN,0);
 }
 			      
 // Check for errors.
 return( error == 0 ? 0 : -1 );
}
#endif

  
mmc_xcidspi.c/  1049977202  0     0     0       2449      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_xcidspi.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Sends request to card in identification process to submit
*              its Card Identification Sturcture when operating in
*              SPI mode
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_getSpiCid,".text:MMC_getSpiCid")

/**************************************************************************
* MMC_getSpiCid(MMC_Handle mmc, MMC_CardIdObj *cid)
*          mmc         - Handle of MMC device reserved by previous call to 
*                        MMC_open()
*          cid         - Pointer to card identification object, where returned
*                        card information should be placed.
***************************************************************************/

int MMC_getSpiCid(MMC_Handle mmc, MMC_CardIdObj *cid) {

  Uint16 old_intm;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc, return);
  old_intm = IRQ_globalDisable();

  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command

  regs->mmcargh = MMC_STUFF_BITS;
  regs->mmcargl = MMC_STUFF_BITS;
  regs->mmccmd = MMC_SPI_SEND_CID;

  IRQ_globalRestore(old_intm);

  // Wait for Response

  MMC_waitForFlag(mmc, MMC_ST0_RSPDNE | MMC_ST0_TOUTRS);
  if (mmc->status | MMC_ST0_TOUTRS){
    return 0;
  }  
  
  IRQ_globalRestore(old_intm);

  return 1;

}
#endif

  

mmc_xcmd.c/     1049977203  0     0     0       2527      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_xcmd.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Sends a command to the currently selected card. Will optionally
*              wait for response
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_sendCmd,".text:MMC_sendCmd")

/**************************************************************************
* MMC_sendCmd(MMC_Handle mmc, Uint16 cmd, Uint16 argh, Uint16 argl, Uint16 waitForRsp)
*          mmc         - Handle of MMC device reserved by previous call to 
*                        MMC_open()
*          cmd         - Command to send to card
*          argh        - High part of command argument
*          argl        - Low part of command argument
*          waitForRsp  - If true, wait for respsonse before returning
***************************************************************************/

int MMC_sendCmd(MMC_Handle mmc, Uint16 cmd, Uint16 argh, 
                Uint16 argl, Uint16 waitForRsp) {

  Uint16 old_intm;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc, return);
  old_intm = IRQ_globalDisable();

  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command

  regs->mmcargh = argh;
  regs->mmcargl = argl;
  regs->mmccmd = cmd;

  IRQ_globalRestore(old_intm);

  // Wait for response done

  if (waitForRsp) {
    MMC_waitForFlag(mmc, MMC_ST0_RSPDNE | MMC_ST0_TOUTRS);
    if (mmc->status & MMC_ST0_TOUTRS)
       return 0;
  }

  return 1;
}
#endif

  

mmc_xcsd.c/     1049977204  0     0     0       2207      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_xcsd.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Sends request to card in identification process to submit
*              its Card Specific Data , CSD structure
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_sendCSD,".text:MMC_sendCSD")

/**************************************************************************
* MMC_sendCSD(MMC_Handle mmc)
*          mmc         - Handle of MMC device reserved by previous call to 
*                        MMC_open()
***************************************************************************/

int MMC_sendCSD(MMC_Handle mmc) {

  Uint16 old_intm;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc, return);

  old_intm = IRQ_globalDisable();

  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command

  regs->mmcargh = MMC_STUFF_BITS;
  regs->mmcargl = MMC_STUFF_BITS;
  regs->mmccmd = MMC_SEND_CSD;

  IRQ_globalRestore(old_intm);

  // Wait for Response

  MMC_waitForFlag(mmc, MMC_ST0_RSPDNE | MMC_ST0_TOUTRS);
  if (mmc->status & MMC_ST0_TOUTRS)
    return 0;

  IRQ_globalRestore(old_intm);

  return 1;

}
#endif

  

mmc_xgoidle.c/  1049977207  0     0     0       2409      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_xgoidle.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Sends broadcast GO_IDLE command
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/

#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_sendGoIdle,".text:MMC_sendGoIdle")

/**************************************************************************
* MMC_sendGoIdle(MMC_Handle mmc)
*          mmc         - Handle of MMC device reserved by previous call to 
*                        MMC_open()
***************************************************************************/

void MMC_sendGoIdle(MMC_Handle mmc) {

  Uint16 old_intm;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc, return);

  old_intm = IRQ_globalDisable();

  // Clear out response registers

  MMC_clearResponse(mmc);

  // Format and send command
  if (!(MMC_FGET_H(mmc,MMCCTL,SPIEN)))  {

  regs->mmcargh = MMC_STUFF_BITS;
  regs->mmcargl = MMC_STUFF_BITS;
  regs->mmccmd = MMC_GO_IDLE_STATE|0xC000;  //add 80 initialization cycles
  
  }
  
  if (MMC_FGET_H(mmc,MMCCTL,SPIEN)) {   //set card in SPI mode
  
  MMC_FSET_H(mmc,MMCCTL,CSEN,1);
  
  regs->mmcargh = MMC_STUFF_BITS;
  regs->mmcargl = MMC_STUFF_BITS;
  regs->mmccmd = MMC_CMD0|MMC_RSP1|0xC000;  //add 80 initialization cycl
  
  while (!MMC_FGET_H(mmc,MMCST0,RSPDNE)) {
  
  }
  
  MMC_FSET_H(mmc,MMCCTL,CSEN,0);
  
  }

  IRQ_globalRestore(old_intm);
}

#endif

  

mmc_xop.c/      1049977210  0     0     0       4096      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... mmc_xop.c
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: Sends braodcast request for cards to repond with their
*              operating voltage requirements Vdd. Returns the number
*              of cards that do not match the Vdd range specified in
*              the Host Vdd argument
\*************************************************************************/
#define _MMC_MOD_
/*************************************************************************\
* Included Header Files                                                  *
\*************************************************************************/
#include <stdarg.h>
#include <csl_mmc.h>

#if (_MMC_SUPPORT)

#pragma CODE_SECTION(MMC_sendOpCond,".text:MMC_sendOpCond")

/**************************************************************************
* MMC_sendOpCond(MMC_Handle mmc, Uint16 hVddMask, Uint16 flag, ...)
*          mmc         - Handle of MMC device reserved by previous call to 
*                        MMC_open()
*          hVddMask    - Mask of acceptable host voltage ranges for data xfr
*          flag        - One of:
*                         1. MMC_VOLTAGE_RANGE_ONLY -  (sends broadcast command
*                           with hVddMask of 0 to determine card ranges only
*                         2. MMC_FORCE_CARDS_INACTIVE - (sends broadcast msg
*                            with hVddMask set to force all cards that
*                            cannot operate in host voltage range to go 
*                            inactive
*          *VddCards   - When flags = MMC_VOLTAGE_RANGE_ONLY, this argument is used
*                       to return the logical OR of all the valid voltage
*                       ranges returned by the connected cards. This allows
*                       the application to adjust/choose a voltage range
*                       that is acceptable, if voltage is adjustable.
*                        
***************************************************************************/

int MMC_sendOpCond(MMC_Handle mmc, Uint16 hVddMask, Uint16 flag, ...) {

  va_list argList;
  Uint16 done=FALSE;
  Uint16 rspDone;
  Uint16 noCardsOutOfRange=0;
  Uint16 *VddCards;
  Uint16 VddCard=0x0000u;
  ioport MMC_MmcRegObj *regs = mmc->mmcRegs;

  MMC_ASSERT_HANDLE(mmc, return);

  while(!done) {
    // Clear out response registers

    MMC_clearResponse(mmc);

    // Format and send command
    if (flag == MMC_VOLTAGE_RANGE_ONLY) {
      regs->mmcargh = MMC_STUFF_BITS;
      regs->mmcargl = MMC_STUFF_BITS;
    } 
    else {
      regs->mmcargl = (hVddMask << 8 )& 0x00FF;
      regs->mmcargh = (hVddMask >> 8 )& 0x00FF;
    }
      
    
    regs->mmccmd = MMC_SEND_OP_COND;

   // Wait for Response

     rspDone = FALSE;
     while (!rspDone) {
       MMC_waitForFlag(mmc, MMC_ST0_RSPDNE | MMC_ST0_TOUTRS);
       if (mmc->status & MMC_ST0_TOUTRS) {
         rspDone = TRUE;
       }
     }

     if (!done) {
       VddCard |= regs->mmcrsp.rsp6;
       if ((VddCard & hVddMask) == 0x0000)
         ++noCardsOutOfRange;
   

       if (flag == MMC_VOLTAGE_RANGE_ONLY) {
          va_start(argList,flag);
          VddCards = va_arg(argList, Uint16 *);
          va_end(argList);
          *VddCards |= VddCard;
       }
     } /* If !done */
  } /* while !done */
  
  return noCardsOutOfRange;
}
#endif
  
pgpio_enab.c/   1074509100  0     0     0       1860      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... pgpio_penab.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  07/31/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the power non-muxed GPIO module)
*               Enables pin function during idle/power-down
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_gpio.h>

#if (_GPIO_PGPIO_SUPPORT)

#pragma CODE_SECTION(_PGPIO_pinEnable,".text:_PGPIO_pinEnable")

/*----------------------------------------------------------------------------*/
/*------------------------------------------------------*/
int _PGPIO_pinEnable(Uint32 pinId) {
  Uint16 dev = ((pinId >> 16) & 0xffffu);
  Uint16 pin = (pinId & 0xffffu);
  Uint16 pin2;

   switch (dev) {
    case GPIO_GPIO: 
                        pin2 = (pin >> 8) & 0x3fu;
                        _GPIO_GPIOEN |= pin2;
                        return _GPIO_GPIOEN;

    case GPIO_AGPIO:   
                        _GPIO_AGPIOEN |= pin;
                        return  _GPIO_AGPIOEN;

    default:            return 0;
 }
}
#endif /* GPIO_SUPPORT */
/******************************************************************************\
* End of pgpio_penab.c
\******************************************************************************/
pgpio_pdir.c/   1074509101  0     0     0       2422      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpio_pdir.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  07/31/2001
*   MODIFIED: 01/22/2002 changed implementation to access only 1 pin
*                        rather than mask several
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_gpio.h>

#if (_GPIO_PGPIO_SUPPORT)

#pragma CODE_SECTION(_PGPIO_pinDirection,".text:_PGPIO_pinDirection")

/*----------------------------------------------------------------------------*/
int _PGPIO_pinDirection(Uint32 pinId, Uint16 direction) {
  Uint16 dev = ((pinId >> 16) & 0xffffu);
  Uint16 pin = (Uint16)(pinId & 0xffffu);
  Uint16 pin1, pin2;
   switch (dev) {
    case GPIO_GPIO: 
                         pin1 = pin & 0xffu;
                         pin2 = (pin >> 8) & 0x3fu;
                        if (pin1) {
                           _GPIO_IODIR = (_GPIO_IODIR & (~(pin1)))
                                         | ((direction) ? pin1:0);
                           return ((_GPIO_IODIR & pin1) ? 1:0);
                        }
                        _GPIO_GPIODIR = (_GPIO_GPIODIR & (~(pin2)))
                                        | ((direction)?  pin2:0);
                        return ((_GPIO_GPIODIR & pin2)? 1:0);

    case GPIO_AGPIO:   
                        _GPIO_AGPIODIR = (_GPIO_AGPIODIR & (~(pin))) 
                                          | ((direction)? pin:0);
                        return ((_GPIO_AGPIODIR & pin) ? 1:0);

    default:            return 0;
  }
}
#endif /* GPIO_SUPPORT */
/******************************************************************************\
* End of pgpio_pdir.c
\******************************************************************************/
pgpio_pdis.c/   1074509101  0     0     0       1790      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... pgpio_pdisab.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  07/31/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_gpio.h>

#if (_GPIO_PGPIO_SUPPORT)

#pragma CODE_SECTION(_PGPIO_pinDisable,".text:_PGPIO_pinDisable")

/*----------------------------------------------------------------------------*/
int _PGPIO_pinDisable(Uint32 pinId) {
  Uint16 dev = ((pinId >> 16) & 0xffffu);
  Uint16 pin = (pinId & 0xffffu);
  Uint16 pin2;

   switch (dev) {
    case GPIO_GPIO: 
                        pin2 = ((pin >> 8) & 0x3fu);
                        _GPIO_GPIOEN &= ~(pin2);
                        return ((_GPIO_GPIOEN & pin2) ? 1:0);

    case GPIO_AGPIO:   
                        _GPIO_AGPIOEN &= ~(pin);
                        return  ((_GPIO_AGPIOEN & pin) ? 1:0);

 
    default:            return 0;
 }
}

#endif /* GPIO_SUPPORT */
/******************************************************************************\
* End of pgpio_pdisab.c
\******************************************************************************/
pgpio_read.c/   1074509102  0     0     0       2084      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... pgpio_pread.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  07/31/2001
*   MODIFIED: 01/22/2002 changed implenentation to read single pin
*                        rather than several
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_gpio.h>

#if (_GPIO_PGPIO_SUPPORT)

#pragma CODE_SECTION(_PGPIO_pinRead,".text:_PGPIO_pinRead")

/*----------------------------------------------------------------------------*/
int _PGPIO_pinRead(Uint32 pinId) {
  Uint16 dev = ((pinId >> 16) & 0xffffu);
  Uint16 pin = (pinId & 0xffffu);
  Uint16 pin1,pin2,val;

   switch (dev) {
    case GPIO_GPIO: 
                       pin1 = (pin & 0xffu);
                       pin2 = ((pin >> 8) & 0x3fu);
                       if (pin1) {
                          val = (_GPIO_IODATA & (pin1)) & (0xffu);
                       }
                       else {
                          val = ((_GPIO_GPIODATA & (pin2)) & 0x3fu);
                       }
                       return ((val) ? 1:0);
    case GPIO_AGPIO:   
                       return  ((_GPIO_AGPIODATA & pin) ? 1:0);

 
    default:           return 0;
  }
}
#endif /* GPIO_SUPPORT */
/******************************************************************************\
* End of pgpio_pread.c
\******************************************************************************/
pgpio_write.c/  1074509103  0     0     0       2411      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... pgpio_pwrite.c
* DATE CREATED.. Tues 07/31/2001
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  07/31/2001
*   MODIFIED: 01/22/2002 changed implementation to write a single pin
*                        rather than mask several
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the non power non-muxed GPIO module)
\******************************************************************************/
#define _GPIO_MOD_

#include <csl_gpio.h>

#if (_GPIO_PGPIO_SUPPORT)

#pragma CODE_SECTION(_PGPIO_pinWrite,".text:_PGPIO_pinWrite")

/*----------------------------------------------------------------------------*/
int _PGPIO_pinWrite(Uint32 pinId, Uint16 val) {
  Uint16 dev = ((pinId >> 16) & 0xffffu);
  Uint16 pin = (pinId & 0xffffu);
  Uint16 pin1,pin2;

   switch (dev) {
    case GPIO_GPIO: 
                        pin1 = (Uint16)(pin & 0xffu);
                        pin2 = (Uint16)((pin >> 8) & 0x3fu);
                        if (pin1) {
                            _GPIO_IODATA = (_GPIO_IODATA & (~pin1)) 
                                           | ((val) ? pin1:0);
                           return ((_GPIO_IODATA & pin1)? 1:0);
                        }
                        _GPIO_GPIODATA = (_GPIO_GPIODATA & (~(pin2)))
                                         | ((val)? pin2:0);
                        return ((_GPIO_GPIODATA & pin2)? 1:0);
    case GPIO_AGPIO:   
                        _GPIO_AGPIODATA = (_GPIO_AGPIODATA & ~pin) | 
                                         ((val) ? pin:0);
                        return  ((_GPIO_AGPIODATA & pin) ? 1:0);

    default:            return 0;
 }
}
#endif /* GPIO_SUPPORT */
/******************************************************************************\
* End of pgpio_pwrite.c
\******************************************************************************/

pll_cfg.c/      1074583743  0     0     0       5105      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... pll_cfg.c
* DATE CREATED.. Wed 06/06/2000
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/06/2000 created
*   MODIFIED: 04/17/2001 updated for 5510 PG2.0 support
*   MODIFIED: 06/28/2001 added pragma for section per function
*   MODIFIED: 01/28/2002 added PLL support for 5502
*   MODIFIED: 08/04/2003 Added CLKOUTSR register for 5502 PLL config sequence
*   MODIFIED: 09/25/2003 Renamed WAKEUP->WKEN
*   MODIFIED: 01/18/2004 Modified the direct register assignements to PLL_RSET(REG,val) 
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the PLL module)
\******************************************************************************/
#define _PLL_MOD_

#include <csl_emif.h>
#include <csl_pll.h>

#if (_PLLA_SUPPORT)

#pragma CODE_SECTION(PLL_config,".text:PLL_config")

/*----------------------------------------------------------------------------*/
void PLL_config(PLL_Config *pcfg) {
  Uint16  pllmult = pcfg->pllmult;
  Uint16  pllenab = 1;		//initialize to PLL mode

#if (_PLL_DIGITAL_SUPPORT)	//Digital PLL (5509)
  Uint16  iai = pcfg->iai;
  Uint16  iob = pcfg->iob;
  Uint16  plldiv = pcfg->div;
#else						//Analog PLL
  Uint16 vcoonoff = pcfg->vcoonoff;
  Uint16  plldiv = pcfg->plldiv;
  int i = 0;
#endif

  if (pllmult==1)
  	pllenab = 0;		// select bypass mode if the multiplier is 1

/*-------------------------------------------------------------*\
 * Place PLL in BYPASS mode
\*-------------------------------------------------------------*/

  PLL_FSET(CLKMD,PLLENABLE,0);


/*-------------------------------------------------------------*\
 * Check status to make use we are in BYPASS mode (LOCK != 0)
\*-------------------------------------------------------------*/

#if (_PLL_DIGITAL_SUPPORT)      //(CHIP_5509)Digital PLL
  while(PLL_FGET(CLKMD,LOCK));
#endif

/*-------------------------------------------------------------*\
 * Reconfigure CLKMD
\*-------------------------------------------------------------*/

#if (_PLL_DIGITAL_SUPPORT)  //(CHIP_5509 & CHIP_PG2_0)  Digital PLL
  _PLL_CLKMD_CFG(iai,iob,0,pllmult,plldiv,pllenab,plldiv);
  //val = PLL_CLKMD_RMK(iai,iob,0,pllmult,plldiv,pllenab,plldiv);
  //PLL_RSET(CLKMD, val);

#else
  _PLL_CLKMD_CFG(vcoonoff,pllmult,plldiv,pllenab);
#endif

/*-------------------------------------------------------------*\
 * Wait for PLL lock-up, LOCK == 1
\*-------------------------------------------------------------*/

#if (_PLL_DIGITAL_SUPPORT)   //(CHIP_5509)	//Digital PLL
	if (pllenab==1)
		while(!(PLL_FGET(CLKMD,LOCK)));
#else
	for (i=0; i<2000;i++)			// wait 2000 cycles for lock
 		asm(" nop" );

#endif
}

#endif /*PLLA_SUPPORT */

#if (_PLLB_SUPPORT)

#define wait_8_cycles {\
   Uint16 i;\
   for(i=0;i<=7;i++) {\
     asm("\tNOP ; CSL Generated Code");\
   }\
}

#pragma CODE_SECTION(PLL_config,".text:PLL_config")

/*----------------------------------------------------------------------------*/
void PLL_config(PLL_Config *pcfg) {

  Uint16 i;

  // Place PLL in ByPass Mode
  PLL_FSET(PLLCSR,PLLEN,0);

  // Wait some cycles (ideally 4 of slowest clock, we just pick
  // arbitrary value here)
  for(i=0;i<20;i++) {
    asm("\tnop ;CSL generated code");
  }

  // Place PLL in Reset Mode
  PLL_FSET(PLLCSR,PLLRST,1);

  // Configure PLL
     PLL_RSET(CLKMD,pcfg->clkmd);
     PLL_RSET(PLLDIV0,pcfg->plldiv0);
     PLL_RSET(PLLM, pcfg->pllm);
     PLL_RSET(OSCDIV1,pcfg->oscdiv1);

     PLL_RSET(PLLDIV3,pcfg->plldiv3);
	 wait_8_cycles;
     PLL_RSET(PLLDIV2,pcfg->plldiv2);
	 wait_8_cycles;
     PLL_RSET(PLLDIV1,pcfg->plldiv1);

     PLL_RSET(CK3SEL,PLL_CK3SEL_CK3SEL_PLL);
     PLL_RSET(WKEN, pcfg->wken);

  // Write to PLL control register making sure PLL
  // reset is not being written
     PLL_RSET(PLLCSR,(pcfg->pllcsr) & (~(0x80u)));

  // Wait for some time (should at least be 1ms)
  // the number used here is not a caluclated cycle count
  // but was chosen as generic value.
    for(i=0;i<=1000;i++){
     asm("\t nop  ; CSL generated code ");
    }

  // Release PLL from Reset
    PLL_FSET(PLLCSR,PLLRST,0);

  // Wait for Lock-Up & Oscillator Stable
    while (PLL_FGET(PLLCSR,LOCK) != 1){
    }

  // Put PLL in PLL mode
   PLL_FSET(PLLCSR,PLLEN,1);

   PLL_RSET(CLKOUTSR,pcfg->clkoutsr);

}
#endif    //PLLB_SUPPORT

/******************************************************************************\
* End of pll_cfg.c
\******************************************************************************/



pll_cfgb.c/     1074583744  0     0     0       5033      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... pll_cfgb.c
* DATE CREATED.. Wed 06/07/2000
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/07/2000 created
*   MODIFIED: 04/17/2001 updated for 5510 PG2 suppport
*   MODIFIED: 06/28/2001 added pragma for section per function
*   MODIFIED: 01/24/2002 fixed problem with CLKDIV support for 5510PG2
*   MODIFIED: 08/04/2003 Added CLKOUTSR register for 5502 PLL config sequence
*   MODIFIED: 09/25/2003 Renamed WAKEUP->WKEN
*   MODIFIED: 01/18/2004 Modified the direct register assignements to PLL_RSET(REG,val)
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the PLL module)
\\******************************************************************************/
#define _PLL_MOD_

#include <csl_emif.h>
#include <csl_pll.h>

#if (_PLLA_SUPPORT)

#pragma CODE_SECTION(PLL_configArgs,".text:PLL_configArgs")

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
#if (_PLL_DIGITAL_SUPPORT)
    void PLL_configArgs(Uint16 iai, Uint16 iob, Uint16 pllmult,\
  	  	Uint16 plldiv) {

#else
  void PLL_configArgs(Uint16 vcoonoff, Uint16 pllmult,Uint16 plldiv) {

   Uint16 i;
#endif

  Uint16 pllenab = 1;
  if (pllmult==1)
  	pllenab = 0;		// select bypass mode if the multiplier is 1

/*-------------------------------------------------------------*\
 * Place PLL in BYPASS mode
\*-------------------------------------------------------------*/

  PLL_FSET(CLKMD,PLLENABLE,0);

/*-------------------------------------------------------------*\
 * Check status to make use we are in BYPASS mode (LOCK != 0)
\*-------------------------------------------------------------*/

#if (_PLL_DIGITAL_SUPPORT)			// Digital PLL (5509, CHIP_PG2_0)
  while(PLL_FGET(CLKMD,LOCK));
#endif

/*-------------------------------------------------------------*\
 * Reconfigure CLKMD
\*-------------------------------------------------------------*/

#if (_PLL_DIGITAL_SUPPORT)  //
   _PLL_CLKMD_CFG(iai,iob,0,pllmult,plldiv,pllenab,plldiv);
#else
   _PLL_CLKMD_CFG(vcoonoff,pllmult,plldiv,pllenab);
#endif

/*-------------------------------------------------------------*\
 * Wait for PLL lock-up, LOCK == 1
\*-------------------------------------------------------------*/

#if (_PLL_DIGITAL_SUPPORT)  //	Digital PLL
	if (pllenab==1)
	   while(!(PLL_FGET(CLKMD,LOCK)));
#else
	for (i=0; i<2000;i++)			// wait 2000 cycles for lock
 		asm(" nop" );
#endif

}

#endif /* PLLA_SUPPORT */

#if (_PLLB_SUPPORT)

#define wait_8_cycles {\
   Uint16 i;\
   for(i=0;i<=7;i++) {\
     asm("\tNOP ; CSL Generated Code");\
   }\
}

#pragma CODE_SECTION(PLL_configArgs,".text:PLL_configArgs")

 void PLL_configArgs(Uint16 pllcsr,Uint16 pllm,Uint16 plldiv0,
                     Uint16 plldiv1,Uint16 plldiv2, Uint16 plldiv3,
                     Uint16 oscdiv1,Uint16 wken, Uint16 clkmd,
                     Uint16 clkoutsr) {

  Uint16 i;

  // Place PLL in ByPass Mode
  PLL_FSET(PLLCSR,PLLEN,0);

  // Wait some cycles (ideally 4 of slowest clock, we just pick
  // arbitrary value here)
  for(i=0;i<20;i++) {
    asm("\tnop ;CSL generated code");
  }

  // Place PLL in Reset Mode
  PLL_FSET(PLLCSR,PLLRST,1);

  // Configure PLL
     PLL_RSET(CLKMD , clkmd);
     PLL_RSET(PLLDIV0 , plldiv0);
     PLL_RSET(PLLM , pllm);
     PLL_RSET(OSCDIV1 , oscdiv1);

     PLL_RSET(PLLDIV3 , plldiv3);
     wait_8_cycles;
     PLL_RSET(PLLDIV2 , plldiv2);
     wait_8_cycles;
     PLL_RSET(PLLDIV1 , plldiv1);

     PLL_RSET(CK3SEL , PLL_CK3SEL_CK3SEL_PLL);
     PLL_RSET(WKEN  , wken);

  // Write to PLL control register making sure PLL
  // reset is not being written
     PLL_RSET(PLLCSR,(pllcsr) & (~(0x80u)));

  // Wait for some time (should at least be 1ms)
  // the number used here is not a caluclated cycle count
  // but was chosen as generic value.
    for(i=0;i<=1000;i++){
     asm("\t nop  ; CSL generated code ");
    }

  // Release PLL from Reset
    PLL_FSET(PLLCSR,PLLRST,0);

  // Wait for Lock-Up & Oscillator Stable
    while (PLL_FGET(PLLCSR,LOCK) != 1){
    }
  // Put PLL in PLL mode
   PLL_FSET(PLLCSR,PLLEN,1);

   PLL_RSET(CLKOUTSR , clkoutsr);

}
#endif /* PLLB_SUPPORT */

/******************************************************************************\
* End of pll_cfgb.c
\******************************************************************************/


pll_setf12.c/   1049977221  0     0     0       1765      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... pll_setfreq12.c
* DATE CREATED.. 07/03/2001
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
* 07/03/2001 (RP) created for TMS320C5510
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the PLL module)
*
* *********  C5510PG1.2 code   ********* 
*
*
\******************************************************************************/
#define _PLL_MOD_

#include <csl_pll.h>

#if (_PLL_SUPPORT) & (CHIP_5510PG1_2)


void PLL_setFreq12 (Uint16 mul, Uint16 div)
{

	Uint16 plldiv, pllmul, pllenab = 1;
	int i = 0;

// decide pll or bypass mode and adjust pllmul

	plldiv = 3;				// pll fractional mode
	pllmul = mul-1;

	if ((mul==1) && (div==1)) // pll bypass
	{	plldiv = 0;	
		pllenab =0;		
	}
	else
		if (div==1) 
			plldiv = 2;		// pll integer mode [1-15]
	    else 
	    	if (div==4) 
				pllmul = mul;	// pll 1/4 mode

// write to CLKMD register

	PLL_RSET(CLKMD, PLL_CLKMD_RMK(1,pllmul,plldiv,pllenab)); 


	for (i=0; i<2000;i++)			// wait 2000 cycles for lock
 		asm(" nop" );

}


#endif /*PLL_SUPPORT */
/******************************************************************************\
* End of pll_setFreq12.c
\******************************************************************************/


pll_setfrq.c/   1074583745  0     0     0       4129      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... pll_setfrq.c
* DATE CREATED.. 07/03/2001
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
* CREATED:  07/03/2001 (RP) created for TMS320C5509
* MODIFIED: 08/04/2003 CLKOUTSR register added in and CLKMD0 renamed to CLKMD
* MODIFIED: 01/18/2004 Modified the direct register assignements to PLL_RSET(REG,val)
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the PLL module)
*
*
\******************************************************************************/
#define _PLL_MOD_

#include <csl_chiphal.h>

#if (_PLL_SUPPORT)

#include <csl_pll.h>

#if (_PLLA_SUPPORT)

#if (!(_PLL_ANALOG_SUPPORT))

void PLL_setFreq (Uint16 mul, Uint16 div)
{

	Uint16 pllenab = 1;	

	if (mul==1) pllenab = 0;					// select bypass or pll mode

										// write to clkmd register
	PLL_RSET(CLKMD, PLL_CLKMD_RMK(0,1,0,mul,div-1,pllenab,div-1)); 						


	if (pllenab==1)
	    while (!PLL_FGET(CLKMD,LOCK)) ;  // wait for lock

}

#else

void PLL_setFreq (Uint16 mul, Uint16 div)
{

	Uint16 plldiv, pllmul, pllenab = 1;
	int i = 0;

// decide pll or bypass mode and adjust pllmul

	plldiv = 3;				// pll fractional mode
	pllmul = mul-1;

	if ((mul==1) && (div==1)) // pll bypass
	{	plldiv = 0;	
		pllenab =0;		
	}
	else
		if (div==1) 
			plldiv = 2;		// pll integer mode [1-15]
	    else 
	    	if (div==4) 
				pllmul = mul;	// pll 1/4 mode

// write to CLKMD register

	PLL_RSET(CLKMD, PLL_CLKMD_RMK(1,pllmul,plldiv,pllenab)); 


	for (i=0; i<2000;i++)			// wait 2000 cycles for lock
 		asm(" nop" );

}

#endif

#endif /*PLLA_SUPPORT */

#if (_PLLB_SUPPORT)

#define wait_8_cycles {\
     Uint16 i;\
     for(i=0;i<=7;i++){\
       asm("\tNOP ; CSL Generated Code");\
     }\
}

void PLL_setFreq (Uint16 mode, Uint16 mul, Uint16 div0, Uint16 div1, Uint16 div2,
                  Uint16 div3, Uint16 oscdiv) {

  Uint16 i;

  // Make sure Fast Devices governed by Sysclk1 (Timer, ect)are
  // faster than Slow devices (Uart,MCBSP) governed by
  // Sysclk2

  if (div2 < div1) {
    div2 = div1;
  }
  
  // Make sure Fast Devices governed by Sysclk1 (Timer, ect)are
  // faster than EMIF governed Sysclk3
  if (div3 < div1) {
    div3 = div1;
  }

  // Place PLL in ByPass Mode
  PLL_FSET(PLLCSR,PLLEN,0);
  
  // Wait some cycles (ideally 4 of slowest clock, we just pick
  // arbitrary value here)
  for(i=0;i<20;i++) {
    asm("\tnop ;CSL generated code");
  }
    
  // Place PLL in Reset Mode
  PLL_FSET(PLLCSR,PLLRST,1);    

  // Configure PLL
     PLL_RSET(PLLDIV0 , _PLL_PLLDIV0_D0EN_MK(1) | div0);
     PLL_RSET(PLLM   , mul);
     PLL_RSET(OSCDIV1 , _PLL_OSCDIV1_OD1EN_MK(1) | oscdiv);

     PLL_RSET(PLLDIV1 , _PLL_PLLDIV1_D1EN_MK(1) | div1);
     wait_8_cycles;
     PLL_RSET(PLLDIV2 , _PLL_PLLDIV2_D2EN_MK(1) | div2);
     wait_8_cycles;
     PLL_RSET(PLLDIV3 , _PLL_PLLDIV3_D3EN_MK(1) | div3);

  // Wait for some time (should at least be 1micro sec)
  // the number used here is not a caluclated cycle count
  // but was chosen as generic value.
    for(i=0;i<=1000;i++){
     asm("\t nop  ; CSL generated code ");
    }

  // Release PLL from Reset
    PLL_FSET(PLLCSR,PLLRST,0);

  // Wait for Lock-Up & Oscillator Stable
    while (PLL_FGET(PLLCSR,LOCK) != 1){
    }
  
 // Set PLL mode

     PLL_FSET(PLLCSR,PLLEN,mode);

}

#endif /* PLLB_SUPPORT */
#endif /* PLL_SUPPORT */

/******************************************************************************\
* End of pll_setfrq.c
\******************************************************************************/

pwr_pwrdn.c/    1061462362  0     0     0       1670      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PWR
* FILENAME...... pwr_pwrdn.c
* DATE CREATED.. Wed 06/06/2000
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED: 06/06/2000
*   MODIFIED:      07/06/2001 added code section pragma
*                  08/16/2001 fixed typo in asm statement
*   LAST MODIFIED: 08/21/2003 Added #if (CHIP_5502) 
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the PWR module)
\******************************************************************************/
#define _PWR_MOD_

#include <csl_irq.h>
#include <csl_pwr.h>

#if (_PWR_SUPPORT)

#if (CHIP_5502)

#else

#pragma CODE_SECTION(PWR_powerDown,".text:PWR_powerDown")

/*----------------------------------------------------------------------------*/
void PWR_powerDown(Uint16 wakeUpMode){
  if (wakeUpMode) {
    IRQ_globalEnable();
  }
  else {
    IRQ_globalDisable();
  }
    
  asm("\t IDLE   ;=====>NOTE: Automatic Code Generated by CSL");
}

#endif /* !(CHIP_5502) */

#endif /*PWR_SUPPORT */
/******************************************************************************\
* End of pwr_pwrdn.c
\******************************************************************************/
rtc_atime.c/    1049977226  0     0     0       1095      `
 /****************************************************************************/
/*  asctime v1.82                                                          */
/*  Copyright (c) 1993-2001  Texas Instruments Incorporated                 */
/****************************************************************************/
#define _RTC_MOD_

#if (_RTC_SUPPORT)

#include <csl_chiphal.h>
#include <csl_time.h> 
#include <csl_rtc.h>

extern _CODE_ACCESS int sprintf(char *_string, const char *_format, ...);

#pragma CODE_SECTION(RTC_asctime,".text:RTC_asctime")

_CODE_ACCESS char *RTC_asctime(const struct tm *timeptr)
{
    struct tm   tptr = *timeptr;
    static _DATA_ACCESS char result[26];

    RTC_mktime(&tptr);      /* MAKE SURE THIS A SANE TIME */

    sprintf(result, "%s %s%3d %02d:%02d:%02d %d\n",
		    CSL_RTC_DATA.day[tptr.tm_wday], 
                CSL_RTC_DATA.mon[tptr.tm_mon], 
                tptr.tm_mday, 
		    tptr.tm_hour, 
                tptr.tm_min, 
                tptr.tm_sec,
		    tptr.tm_year + 1900);

    return (result);
}
#endif

rtc_bcd2dec.c/  1065617105  0     0     0       3861      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... rtc_bcdtodec.c
* DATE CREATED.. 1/10/01
* PROJECT....... RTC
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   1/10/01 (AF) Created
*        Modified:      9/17/2003  Modified RTC_decToBcd() and RTC_bcdToDec()
*                                      to avoid rts55 library calls.
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

/****************************************\
* include files
\****************************************/
#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_rtc.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC static macro declarations
\****************************************/

/****************************************\
* RTC static typedef declarations
\****************************************/

/****************************************\
* RTC static function declarations
\****************************************/

/****************************************\
* RTC static variable definitions
\****************************************/

/****************************************\
* RTC static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC global variable definitions
\****************************************/

/****************************************\
* RTC global function definitions
\****************************************/

/*-------------------------------------------------------*\
 int RTC_decToBcd(int value):
 Changes decimal value to BCD value which is what RTC needs
 --------------------------------------------------*/



/*
RTC_decToBcd() => 16 * (dec_value / 10) + (dec_value % 10);
               => 6 * (dec_value / 10) + 10 * (dec_value / 10) + (dec_value % 10);
               => 6 * (dec_value / 10) + dec_value;
               Now (dec_value / 10) ~= (dec_value * A + B) >> C;
               For division by 10;
                  "(dec_value * 103) >> 10"  seems most optimal.
*/

#pragma CODE_SECTION(RTC_decToBcd,".text:RTC_decToBcd")

int RTC_decToBcd(int dec_value)
{
    /* note: designed to work for 100 > dec_value >= 0; */
    return (dec_value + 6 * (dec_value * 103 >> 10));
}

/* RTC_bcdToDec() =>  (10 * hex_value/16) + (hex_value % 16)
                  =>  hex_value - (6* hex_value/16)
*/

#pragma CODE_SECTION(RTC_bcdToDec,".text:RTC_bcdToDec")

int RTC_bcdToDec(int hex_value)
{
     /* note: designed to work for 0x100 > hex_value >= 0x00; */
   return (hex_value - 6 * (hex_value >> 4));
}

/*----------------------------------------------------------------------------*/

#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_bcdtodec.c
\******************************************************************************/


rtc_cfg.c/      1049977229  0     0     0       3432      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... rtc_cfg.c
* DATE CREATED.. 7/09/01
* PROJECT....... RTC
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   7/09/01 (IM) Created
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

/****************************************\
* include files
\****************************************/
#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_rtc.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC static macro declarations
\****************************************/

/****************************************\
* RTC static typedef declarations
\****************************************/

/****************************************\
* RTC static function declarations
\****************************************/

/****************************************\
* RTC static variable definitions
\****************************************/

/****************************************\
* RTC static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC global variable definitions
\****************************************/

/****************************************\
* RTC global function definitions
\****************************************/

#pragma CODE_SECTION(RTC_config,".text:RTC_config")

void RTC_config(RTC_Config *Config) {
  int old_intm;

  old_intm = IRQ_globalDisable();  

  RTC_RSET(RTCINTFL,0x70);			/* Clear flags in Register C */
  RTC_RSET(RTCINTEN,Config->rtcinten);	/* Set Register B - 12 or 24-hour mode */
  _SET_B;			/* Set bit SET in Register B to 1 */  

/* Set Data registers */
  RTC_RSET(RTCSEC,Config->rtcsec);
  RTC_RSET(RTCSECA,Config->rtcseca);
  RTC_RSET(RTCMIN,Config->rtcmin);
  RTC_RSET(RTCMINA,Config->rtcmina);
  RTC_RSET(RTCHOUR,Config->rtchour);
  RTC_RSET(RTCHOURA,Config->rtchoura);
  RTC_RSET(RTCDAYW,Config->rtcdayw);
  RTC_RSET(RTCDAYM,Config->rtcdaym);
  RTC_RSET(RTCMONTH,Config->rtcmonth);
  RTC_RSET(RTCYEAR,Config->rtcyear);    
  
  RTC_RSET(RTCPINTR,Config->rtcpintr);	/* Set Register A */

  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/

#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_cfg.c
\******************************************************************************/

rtc_cfga.c/     1049977230  0     0     0       3343      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... rtc_cfgA.c
* DATE CREATED.. 7/09/01
* PROJECT....... RTC
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   7/09/01 (IM) Created
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_rtc.h>

#if (_RTC_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC static macro declarations
\****************************************/

/****************************************\
* RTC static typedef declarations
\****************************************/

/****************************************\
* RTC static function declarations
\****************************************/

/****************************************\
* RTC static variable definitions
\****************************************/

/****************************************\
* RTC static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC global variable definitions
\****************************************/

/****************************************\
* RTC global function definitions
\****************************************/

#pragma CODE_SECTION(RTC_configArgs,".text:RTC_configArgs")

void RTC_configArgs(Uint16 rtcsec,Uint16 rtcseca,Uint16 rtcmin,Uint16 rtcmina,Uint16 rtchour,Uint16 rtchoura,Uint16 rtcdayw,
				   Uint16 rtcdaym,Uint16 rtcmonth,Uint16 rtcyear,Uint16 rtcpintr,Uint16 rtcinten)
{
  int old_intm;

   old_intm = IRQ_globalDisable(); 
    
  RTC_RSET(RTCPINTR,rtcpintr);
  _SET_B; 		 /* Set bit SET in Register B to 1 */  

  RTC_RSET(RTCSEC,rtcsec);
  RTC_RSET(RTCSECA,rtcseca);
  RTC_RSET(RTCMIN,rtcmin);
  RTC_RSET(RTCMINA,rtcmina);
  RTC_RSET(RTCHOUR,rtchour);
  RTC_RSET(RTCHOURA,rtchoura);
  RTC_RSET(RTCDAYW,rtcdayw);
  RTC_RSET(RTCDAYM,rtcdaym);
  RTC_RSET(RTCMONTH,rtcmonth);
  RTC_RSET(RTCYEAR,rtcyear);    
  RTC_RSET(RTCINTEN,rtcinten);
  
  IRQ_globalRestore(old_intm);   
}
/*----------------------------------------------------------------------------*/

#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_cfga.c
\******************************************************************************/


rtc_ctime.c/    1049977231  0     0     0       933       `
/*****************************************************************************/
/* ctime     v#####                                                          */
/* Copyright (c) 1999@%%%% Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CTIME
#define _CTIME

#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#define _CPP_STYLE_HEADER
#include <csl_time.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif  /* _RTC_SUPPORT */
#endif  /* #ifndef _CTIME */


rtc_ctime_.c/   1049977233  0     0     0       462       `
/****************************************************************************/
/*  ctime   v1.82                                                          */
/*  Copyright (c) 1993-2001  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _CTIME_

#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_time.h>


#endif  /* _RTC_SUPPORT */
rtc_diftime.c/  1049977234  0     0     0       1017      `
/****************************************************************************/
/*  RTC_difftime v1.82                                                      */
/*  Copyright (c) 1996-2001 Texas Instruments Incorporated                  */
/****************************************************************************/
#define _RTC_MOD_

#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#undef _INLINE
#include <csl_time.h>
#include <csl_rtc.h> 

#pragma CODE_SECTION(RTC_difftime,".text:RTC_difftime")

_CODE_ACCESS double RTC_difftime(time_t time1, time_t time0)
{
    /*----------------------------------------------------------------------*/
    /* THE FOLLOWING CONVERSION INSURES THAT ANY POSSIBLE DIFFERENCE IN THE */
    /* RANGE OF UNSIGNED LONG IS PROPERLY REPRESENTED IN THE RESULT.        */
    /*----------------------------------------------------------------------*/
    return ((time1 > time0) ?  (double)(time1 - time0)
	                    : -(double)(time0 - time1));
}
#endif

rtc_drv.c/      1049977236  0     0     0       1527      `
#define  _RTC_MOD_    

#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <stdio.h>
#include <string.h>
#include <csl_time.h>  
#include <csl_rtc.h>


/****************************************************************************/
/* Functions:                                                               */
/*    RTCTIME()    -    Get the time from RTC                               */
/*                                                                          */
/****************************************************************************/

 /* extern _CODE_ACCESS time_t RTCtime(void);      */
  
#pragma CODE_SECTION(RTCtime,".text:RTCtime")

/****************************************************************************/
/* RTCTIME()  -  Get the time from RTC                                      */
/****************************************************************************/
_CODE_ACCESS time_t RTCtime(void)
{                     

_DATA_ACCESS struct tm temp;
   time_t rtctime;   
 
   
   temp.tm_sec = RTC_bcdToDec(RTC_RGET(RTCSEC));
   temp.tm_min = RTC_bcdToDec(RTC_RGET(RTCMIN));     
   temp.tm_hour = RTC_bcdToDec(RTC_FGET(RTCHOUR,HR));  
   temp.tm_mday = RTC_bcdToDec(RTC_RGET(RTCDAYM)); 
   temp.tm_mon = RTC_bcdToDec(RTC_RGET(RTCMONTH)) - 1;    //RTC month starts at 1     
   temp.tm_year = RTC_bcdToDec(RTC_RGET(RTCYEAR)) + 100;   //RTC starts at 2000   
    
   rtctime = RTC_mktime(&temp);                
 
   return rtctime;         

}
#endif

rtc_edab.c/     1049977237  0     0     0       1607      `
/*****************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... RTC_edab.c
* DATE CREATED.. Sun 05/07/2001 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   05/06/2001   (IM) Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\*****************************************************************************/
#define _RTC_MOD_
/*----------------------------------------------------------------------------*/
/* INCLUDES                                                                   */
/*----------------------------------------------------------------------------*/
#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_rtc.h>

/*----------------------------------------------------------------------------*/
/* Function                                                                   */
/*----------------------------------------------------------------------------*/
void RTC_eventDisable(Uint16 ierMask)
{     
	Uint16 temp = RTC_RGET(RTCINTEN) & (~ierMask);
	RTC_RSET(RTCINTEN, temp);

        if ( !(RTC_RGET(RTCINTEN) & 0x70) )
            IRQ_disable(IRQ_EVT_RTC);
}
#endif /* RTC_SUPPORT */


rtc_enab.c/     1049977239  0     0     0       1562      `
/*****************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... RTC_enab.c
* DATE CREATED.. 05/03/2001 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   05/03/2001   (IM) Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\*****************************************************************************/
#define _RTC_MOD_
/*----------------------------------------------------------------------------*/
/* INCLUDES                                                                   */
/*----------------------------------------------------------------------------*/
#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_rtc.h>

/*----------------------------------------------------------------------------*/
/* Function                                                                   */
/*----------------------------------------------------------------------------*/
void RTC_eventEnable(Uint16 isrMask)
{     Uint16 temp;
	temp = RTC_RGET(RTCINTEN)|(isrMask);
        RTC_RSET(RTCINTEN, temp); 
        IRQ_enable(IRQ_EVT_RTC);
}

#endif /* RTC_SUPPORT */

rtc_gcfg.c/     1051539306  0     0     0       3489      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... rtc_gcfg.c
* DATE CREATED.. 7/09/01
* PROJECT....... RTC
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   7/09/01 (IM) Created
*  10 April 2003 added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

/****************************************\
* include files
\****************************************/
#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_rtc.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC static macro declarations
\****************************************/

/****************************************\
* RTC static typedef declarations
\****************************************/

/****************************************\
* RTC static function declarations
\****************************************/

/****************************************\
* RTC static variable definitions
\****************************************/

/****************************************\
* RTC static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC global variable definitions
\****************************************/

/****************************************\
* RTC global function definitions
\****************************************/

#pragma CODE_SECTION(RTC_getConfig,".text:RTC_getConfig")

 void RTC_getConfig(RTC_Config *Config) {
  int old_intm, old_set;
  old_intm = IRQ_globalDisable();  
  old_set = RTC_FGET(RTCINTEN, SET);

  while (RTC_FGET(RTCPINTR,UIP) != 0);

  _SET_B;		 /* Set bit SET in Register B to 1 */

  Config->rtcsec = RTC_RGET(RTCSEC);
  Config->rtcseca = RTC_RGET(RTCSECA);
  Config->rtcmin = RTC_RGET(RTCMIN);
  Config->rtcmina = RTC_RGET(RTCMINA);  
  Config->rtchour = RTC_RGET(RTCHOUR);
  Config->rtchoura = RTC_RGET(RTCHOURA);
  Config->rtcdayw = RTC_RGET(RTCDAYW);
  Config->rtcdaym = RTC_RGET(RTCDAYM);
  Config->rtcmonth = RTC_RGET(RTCMONTH);
  Config->rtcyear = RTC_RGET(RTCYEAR);
  Config->rtcpintr = RTC_RGET(RTCPINTR);
  Config->rtcinten = RTC_RGET(RTCINTEN);

  RTC_FSET(RTCINTEN, SET, old_set);

  IRQ_globalRestore(old_intm);   
}            

/*----------------------------------------------------------------------------*/

#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_getCfg.c
\******************************************************************************/


rtc_gdate.c/    1051539306  0     0     0       3149      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... rtc_gdate.c
* DATE CREATED.. 7/09/01
* PROJECT....... RTC
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   7/09/01 (IM) Created
*  10 April 2003 added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

/****************************************\
* include files
\****************************************/
#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_rtc.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC static macro declarations
\****************************************/

/****************************************\
* RTC static typedef declarations
\****************************************/

/****************************************\
* RTC static function declarations
\****************************************/

/****************************************\
* RTC static variable definitions
\****************************************/

/****************************************\
* RTC static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC global variable definitions
\****************************************/

/****************************************\
* RTC global function definitions
\****************************************/

#pragma CODE_SECTION(RTC_getDate,".text:RTC_getDate")

void RTC_getDate(RTC_Date *myDate) {
  int old_intm, old_set;
  old_intm = IRQ_globalDisable();  
  old_set = RTC_FGET(RTCINTEN, SET);

  while (RTC_FGET(RTCPINTR,UIP) != 0);
  _SET_B;		 /* Set bit SET in Register B to 1 */

  myDate->year = RTC_RGET(RTCYEAR);
  myDate->month = RTC_FGET(RTCMONTH,MONTH);
  myDate->daym = RTC_FGET(RTCDAYM,DATE);
  myDate->dayw = RTC_FGET(RTCDAYW,DAY);

  RTC_FSET(RTCINTEN, SET, old_set);

  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/

#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_getDate.c
\******************************************************************************/


rtc_gevid.c/    1049977243  0     0     0       976       `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... rtc_gevid.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  08/02/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (Returns IRQ Event Id for RTC)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

#include <csl_rtc.h>

#if (_RTC_SUPPORT)

#pragma CODE_SECTION(RTC_getEventId,".text:RTC_getEventId")

int RTC_getEventId(void) {

  return IRQ_EVT_RTC;
  
}
#endif
rtc_gmtime.c/   1049977244  0     0     0       757       `
/****************************************************************************/
/*  RTC_gmtime v1.82                                                        */
/*  Copyright (c) 1993-2001  Texas Instruments Incorporated                 */
/****************************************************************************/
#define _RTC_MOD_

#if (_RTC_SUPPORT)

#include <csl_time.h>
#include <csl_rtc.h>


#pragma CODE_SECTION(RTC_gmtime,".text:RTC_gmtime")

_CODE_ACCESS struct tm *RTC_gmtime(const time_t *timer)
{
    time_t gtime = CSL_RTC_DATA._tz.timezone; /* DIFFERENCE BETWEEN CURRENT TIME ZONE    */
				 /* AND GMT IN SECONDS                      */

    if (timer) gtime += *timer;
    return (RTC_localtime(&gtime));
}
#endif


rtc_gtime.c/    1051539305  0     0     0       3151      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... rtc_gtime.c
* DATE CREATED.. 7/09/01
* PROJECT....... RTC
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   7/09/01 (IM) Created
*   10 April 2003  added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

/****************************************\
* include files
\****************************************/
#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_rtc.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC static macro declarations
\****************************************/

/****************************************\
* RTC static typedef declarations
\****************************************/

/****************************************\
* RTC static function declarations
\****************************************/

/****************************************\
* RTC static variable definitions
\****************************************/

/****************************************\
* RTC static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC global variable definitions
\****************************************/

/****************************************\
* RTC global function definitions
\****************************************/

#pragma CODE_SECTION(RTC_getTime,".text:RTC_getTime")

void RTC_getTime(RTC_Time *myTime) {
  int old_intm, old_set;

/* Only a 24-hour mode is supported */

  old_intm = IRQ_globalDisable();  
  old_set = RTC_FGET(RTCINTEN, SET);

  while (RTC_FGET(RTCPINTR,UIP) != 0);

  _SET_B;		 /* Set bit SET in Register B to 1 */

  myTime->second = RTC_RGET(RTCSEC);
  myTime->minute = RTC_RGET(RTCMIN);
  myTime->hour = RTC_FGET(RTCHOUR,HR); 
  
  RTC_FSET(RTCINTEN, SET, old_set);

  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/

#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_getTime.c
\******************************************************************************/


rtc_ltime.c/    1049977247  0     0     0       3212      `
/****************************************************************************/
/*  RTC_localtime v1.82                                                     */
/*  Copyright (c) 1993-2001  Texas Instruments Incorporated                 */
/****************************************************************************/
#define _RTC_MOD_

#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_time.h>
#include <csl_rtc.h>
#include <limits.h>

#define SECS_IN_MIN (time_t)60
#define MINS_IN_HR  (time_t)60
#define HRS_IN_DAY  (time_t)24
#define SECS_IN_HR  (SECS_IN_MIN * MINS_IN_HR)
#define SECS_IN_DAY (SECS_IN_HR * HRS_IN_DAY)
 
#define LEAPYEAR(y) (    (y+1900) % 4   == 0                               \
			 && ((y+1900) % 100 != 0 || (y+1900) % 400 == 0))

#define DAYS_IN_YR(y) ((time_t)365 + LEAPYEAR(y))

#pragma CODE_SECTION(RTC_localtime,".text:RTC_localtime")
 
_CODE_ACCESS struct tm *RTC_localtime(const time_t *timer)
{
    struct tm local;
    time_t ltime  = timer ? *timer : 0;
 
    local.tm_sec  = 0;
    local.tm_min  = 0;
    local.tm_hour = 0;
    local.tm_mday = 1;
    local.tm_mon  = 0;
    local.tm_year = 0;
 
    if (timer == 0 || ltime == (time_t)-1) return &local;
 
#if INT_MAX <= 32767
    /*------------------------------------------------------------------*/
    /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */
    /* REPRESENTED IN SIGNED INTS.                                      */
    /*------------------------------------------------------------------*/
    local.tm_sec   =  ltime % SECS_IN_MIN;
    local.tm_min   = (ltime / SECS_IN_MIN) % MINS_IN_HR;
    local.tm_hour  = (ltime / SECS_IN_HR)  % HRS_IN_DAY;
 
    /*------------------------------------------------------------------*/
    /* CONVERT ltime TO NUMBER OF DAYS                                  */
    /*------------------------------------------------------------------*/
    ltime /= SECS_IN_DAY;
 
    /*------------------------------------------------------------------*/
    /* TO DETERMINE THE YEAR, INSTEAD OF DIVIDING BY 365, DO A SUBTRACT */
    /* LOOP THAT ACCOUNTS FOR LEAP YEARS.                               */
    /*------------------------------------------------------------------*/
    {
	int year = 0;
	while (ltime >= DAYS_IN_YR(year))
	{
	    ltime -= DAYS_IN_YR(year);
	    ++year;
	}
     
	local.tm_year  = year;
	local.tm_mday += ltime;
    }
 
#else
    /*------------------------------------------------------------------*/
    /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */
    /* REPRESENTED IN SIGNED INTS.                                      */
    /*------------------------------------------------------------------*/
    if ((int)ltime < 0)
    {
	local.tm_sec  = ltime % 60; 
	local.tm_min  = ltime / 60; 
    }
    else local.tm_sec = ltime;
#endif
 
    /*------------------------------------------------------------------*/
    /* MAKE VALUES IN local INTO A VALID TIME.                          */
    /*------------------------------------------------------------------*/
    RTC_mktime(&local);
    return &local;
}
#endif
rtc_mktime.c/   1049977249  0     0     0       5051      `
/****************************************************************************/
/*  RTC_mktime v1.82                                                        */
/*  Copyright (c) 1993-2001  Texas Instruments Incorporated                 */
/****************************************************************************/
#define  _RTC_MOD_          

#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_time.h>
#include <csl_rtc.h>
#include <limits.h>      
#include <stdio.h>
 
 

#define JAN11900    (time_t)1                   
#define DAYS_IN_YR  (time_t)365     
#define SECS_IN_MIN (time_t)60 
#define MINS_IN_HR  (time_t)60 
#define HRS_IN_DAY  (time_t)24 
#define SECS_IN_HR  (SECS_IN_MIN * MINS_IN_HR)
#define SECS_IN_DAY (SECS_IN_HR  * HRS_IN_DAY)
#define SECS_IN_YR  (DAYS_IN_YR  * SECS_IN_DAY)

/* THE FOLLOWING MACRO DETERMINES IF ADDING k TO x CAUSES OVERFLOW */

#define OVERFLOW(x,k) (((x) > 0) == ((k) > 0) &&          \
                       ((unsigned)(x)       <= INT_MAX) != \
		       ((unsigned)((x)+(k)) <= INT_MAX))

#define LEAPYEAR(y)   ( ((y + 1900) % 4 == 0) &&      \
                       (((y + 1900) % 100 != 0) || ((y + 1900) % 400 == 0)) )

#pragma CODE_SECTION(RTC_mktime,".text:RTC_mktime")

_CODE_ACCESS time_t RTC_mktime(register struct tm *tptr)
{
   time_t   result;
   time_t   daycount;
   int      mdays;
   int      adjust;
    
   /*-----------------------------------------------------------------*/
   /* HANDLE SECONDS.  IF TOO MANY OR TOO FEW, MODIFY MINUTES.        */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_sec < 0) ? -((unsigned)(-tptr->tm_sec + 59) / 60) 
			       : (tptr->tm_sec / 60);

   if (OVERFLOW(tptr->tm_min, adjust)) return((time_t) -1);
   tptr->tm_min += adjust;
   tptr->tm_sec -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE MINUTES.  IF TOO MANY OR TOO FEW, MODIFY HOURS           */
   /*-----------------------------------------------------------------*/
  
   adjust = (tptr->tm_min < 0) ? -((unsigned)(-tptr->tm_min + 59) / 60) 
			       : (tptr->tm_min / 60);

   if (OVERFLOW(tptr->tm_hour, adjust)) return((time_t) -1);
   tptr->tm_hour += adjust;
   tptr->tm_min  -= adjust * 60;
 


   /*-----------------------------------------------------------------*/
   /* HANDLE HOURS.    IF TOO MANY OR TOO FEW, MODIFY DAYS            */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_hour < 0) ? -((unsigned)(-tptr->tm_hour + 23) / 24) 
			        : (tptr->tm_hour / 24);

   if (OVERFLOW(tptr->tm_mday, adjust)) return((time_t) -1);
   tptr->tm_mday += adjust;
   tptr->tm_hour -= adjust * 24;

   for (;;)
   {
      /*-----------------------------------------------------------------*/
      /* HANDLE MONTHS.   IF TOO MANY OR TOO FEW, MODIFY YEARS           */
      /*-----------------------------------------------------------------*/ 

      adjust = (tptr->tm_mon < 0) ? -((unsigned)(-tptr->tm_mon + 11) / 12) 
				  : (tptr->tm_mon / 12);

      if (OVERFLOW(tptr->tm_year, adjust)) return((time_t) -1);
      tptr->tm_year += adjust;            

      tptr->tm_mon  -= adjust * 12;

      /*-----------------------------------------------------------------*/
      /* HANDLE DAYS.     IF TOO MANY OR TOO FEW, MODIFY MONTHS          */
      /*-----------------------------------------------------------------*/
      if (tptr->tm_mday <= 0)
      { 
	   tptr->tm_mon--;  
           tptr->tm_mday += CSL_RTC_DATA.mon_len[tptr->tm_mon < 0 ? 11 : tptr->tm_mon] + 
		        ((tptr->tm_mon == 1) && ((tptr->tm_year % 4) == 0));
	   continue;
      }

      /*-----------------------------------------------------------------*/
      /* CALCULATE NUMBER OF DAYS IN THIS MONTH.                         */
      /*-----------------------------------------------------------------*/
      mdays = CSL_RTC_DATA.mon_len[tptr->tm_mon] + 
		( (tptr->tm_mon == 1) && LEAPYEAR(tptr->tm_year) );

      if (tptr->tm_mday > mdays) 
	{ tptr->tm_mday -= mdays; tptr->tm_mon++; }
      else break;

   }	/* end for */

   /*--------------------------------------------------------------------*/
   /* WE CAN NOW BE SURE THAT ALL FIELDS IN THE TIME STRUCTURE ARE RIGHT */
   /*--------------------------------------------------------------------*/ 

   tptr->tm_yday = CSL_RTC_DATA.mon_day[tptr->tm_mon]  + tptr->tm_mday - 1 +
                   ( (tptr->tm_mon > 1) && LEAPYEAR(tptr->tm_year) );

   daycount      = tptr->tm_year * DAYS_IN_YR  + 
	           ((tptr->tm_year - 1) / 4)   + tptr->tm_yday;

   result        = daycount      * SECS_IN_DAY + 
	           tptr->tm_hour * SECS_IN_HR  +
	           tptr->tm_min  * SECS_IN_MIN + tptr->tm_sec;
   
   tptr->tm_wday  = (JAN11900 + daycount) % 7; 
   tptr->tm_isdst = CSL_RTC_DATA._tz.daylight;
   

   return result;
}
#endif


rtc_reset.c/    1051539304  0     0     0       1914      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... RTC
* FILENAME...... rtc_reset.c
* DATE CREATED.. Tue 27/02/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:		27/02/2002 (IM).  
*   LAST MODIFIED:	10 April 2003  added #pragam CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (Resets the RTC registers to their default (power-on) values)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

#include <csl_rtc.h>
#include <csl.h>


#if (_RTC_SUPPORT)

#pragma CODE_SECTION(RTC_reset,".text:RTC_reset")

/*----------------------------------------------------------------------------*/
void RTC_reset() {
  int oldgie;
    
  RTC_Config myConfig = {
     0x0,    /* Seconds */
     0x0,    /* Seconds Alarm */
     0x0,    /* Minutes */
     0x0,    /* Minutes Alarm */
     0x0,    /* Hour */
     0x0,    /* Hours Alarm */
     0x0,    /* Day of the week and day alarm */
     0x0,    /* Day of the month */
     0x0,    /* Month */
     0x0,    /* Year */
     0x0,    /* Register A - RTCPINTR */
     0x80,   /*Register B - RTCINTEN */
  };
  oldgie = IRQ_globalDisable(); 

  RTC_config(&myConfig); 

  IRQ_globalRestore(oldgie);

}
#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_reset.c
\******************************************************************************/


rtc_salarm.c/   1051539303  0     0     0       3451      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... rtc_sAlarm.c
* DATE CREATED.. 7/09/01
* PROJECT....... RTC
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   7/09/01 (IM) Created
*  22/02/02 (IM) Removed the call to _RESET_B which starts the RTC running
*		     Removed the call to _SET_AIE which enables the Alarm interrupt
*  27/02/02 (IM) Changed setting of hour alarm to set entire register, not 
*				 just HAR field, to accomodate 'Don't care' condition.
*  10 April 2003 added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

/****************************************\
* include files
\****************************************/

#include <csl_rtc.h>

#if (_RTC_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC static macro declarations
\****************************************/

/****************************************\
* RTC static typedef declarations
\****************************************/

/****************************************\
* RTC static function declarations
\****************************************/

/****************************************\
* RTC static variable definitions
\****************************************/

/****************************************\
* RTC static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC global variable definitions
\****************************************/

/****************************************\
* RTC global function definitions
\****************************************/

#pragma CODE_SECTION(RTC_setAlarm,".text:RTC_setAlarm")

void RTC_setAlarm(RTC_Alarm *myAlarm) {
  int old_intm;
  old_intm = IRQ_globalDisable();  

/* Only a 24-hour mode is supported */

  _SET_B; 		 /* Set bit SET in Register B to 1 */  

  /* RTC_FSET(RTCINTEN, TM, 1); */
  RTC_FSET(RTCDAYW,DAEN, 1);
  RTC_FSET(RTCSECA,SAR,myAlarm->alsecond); 
  RTC_FSET(RTCMINA,MAR,myAlarm->alminute);
  //RTC_FSET(RTCHOURA,HAR,myAlarm->alhour);
  RTC_RSET(RTCHOURA,myAlarm->alhour);
  RTC_FSET(RTCDAYW,DAR,myAlarm->aldayw);

  IRQ_globalRestore(old_intm);   

}


/*----------------------------------------------------------------------------*/

#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_setAlarm.c
\******************************************************************************/


rtc_scback.c/   1070367897  0     0     0       2944      `
/*****************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... RTC_scback.c
* DATE CREATED.. 05/07/2001 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   05/03/2001	(IM) Created 
*   Modified	(IM) Removed 2nd and 3rd arguments
*	26/02/2002	(IM) Added manual clearing of interrupt flags in Reg C
*   12/02/2003       Added underscore '_' prefix for private API
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\*****************************************************************************/

/*----------------------------------------------------------------------------*/
/* INCLUDES                                                                   */
/*----------------------------------------------------------------------------*/
#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_irq.h>
#include <csl_rtc.h>

#pragma CODE_SECTION(RTC_setCallback,".text:RTC_setCallback")

/*----------------------------------------------------------------------------*/
/* Function                                                                   */
/*----------------------------------------------------------------------------*/
void RTC_setCallback(RTC_IsrAddr *isrAddr)
{    
	int perTemp, alTemp, updateTemp;
	
	perTemp = (RTC_EVT_PERIODIC) >> 4;	// [4]
	alTemp = (RTC_EVT_ALARM) >> 4;   	// [2]
	updateTemp = (RTC_EVT_UPDATE) >> 4;	// [1]
	    
    (CSL_RTC_DATA).RTC_isrDispatchTable[perTemp] = (Uint32)(isrAddr->periodicAddr); 
    (CSL_RTC_DATA).RTC_isrDispatchTable[alTemp] = (Uint32)(isrAddr->alarmAddr); 
    (CSL_RTC_DATA).RTC_isrDispatchTable[updateTemp] = (Uint32) (isrAddr->updateAddr); 
  
    IRQ_plug(IRQ_EVT_RTC, _RTC_intrDispatch);
     
}

/* Private function */
interrupt void _RTC_intrDispatch(void)
{
      
    asm("\tNOP                       ;====> RTC interrupt routine");   
          
    if (RTC_FGET(RTCINTFL, PF)) {
	    ((void (*)(void))(CSL_RTC_DATA).RTC_isrDispatchTable[(RTC_EVT_PERIODIC) >> 4])();  
	    RTC_FSET(RTCINTFL, PF, 1);	
    }

    if (RTC_FGET(RTCINTFL, AF)) {
	    ((void (*)(void))(CSL_RTC_DATA).RTC_isrDispatchTable[(RTC_EVT_ALARM) >> 4])();	 
	    RTC_FSET(RTCINTFL, AF, 1);	
    }	    
	    
    if (RTC_FGET(RTCINTFL, UF)) {
	    ((void (*)(void))(CSL_RTC_DATA).RTC_isrDispatchTable[(RTC_EVT_UPDATE) >> 4])();	       
	    RTC_FSET(RTCINTFL, UF, 1);	
    }	    
	    
	/* Clear flags in Register C */
	//RTC_RSET(RTCINTFL, 0x70);	
}

#endif /* RTC_SUPPORT */
rtc_sdate.c/    1049977255  0     0     0       3088      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... rtc_setDate.c
* DATE CREATED.. 7/09/01
* PROJECT....... RTC
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   7/09/01 (IM) Created
*  22/02/02 (IM) Removed the call to _RESET_B which starts the RTC running
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

/****************************************\
* include files
\****************************************/
#include <csl_chiphal.h>


#if (_RTC_SUPPORT)

#include <csl_rtc.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC static macro declarations
\****************************************/

/****************************************\
* RTC static typedef declarations
\****************************************/

/****************************************\
* RTC static function declarations
\****************************************/

/****************************************\
* RTC static variable definitions
\****************************************/

/****************************************\
* RTC static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC global variable definitions
\****************************************/

/****************************************\
* RTC global function definitions
\****************************************/

#pragma CODE_SECTION(RTC_setDate,".text:RTC_setDate")

void RTC_setDate(RTC_Date *myDate) {
  int old_intm;

  old_intm = IRQ_globalDisable();  

  _SET_B; 		 /* Set bit SET in Register B to 1 */  

  RTC_RSET(RTCYEAR,myDate->year);
  RTC_FSET(RTCMONTH,MONTH,myDate->month);
  RTC_FSET(RTCDAYM,DATE,myDate->daym);
  RTC_FSET(RTCDAYW,DAEN, 0);
  RTC_FSET(RTCDAYW,DAY,myDate->dayw);

  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/

#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_setDate.c
\******************************************************************************/

rtc_setper.c/   1049977256  0     0     0       2891      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... rtc_setPerInt.c
* DATE CREATED.. 7/09/01
* PROJECT....... RTC
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   7/09/01 (IM) Created
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

/****************************************\
* include files
\****************************************/
#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_rtc.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC static macro declarations
\****************************************/

/****************************************\
* RTC static typedef declarations
\****************************************/

/****************************************\
* RTC static function declarations
\****************************************/

/****************************************\
* RTC static variable definitions
\****************************************/

/****************************************\
* RTC static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC global variable definitions
\****************************************/

/****************************************\
* RTC global function definitions
\****************************************/

#pragma CODE_SECTION(RTC_setPeriodicInterval,".text:RTC_setPeriodicInterval")

void RTC_setPeriodicInterval(Uint16 interval) { /* Set periodic interrupt rate (see RS table) */
  int old_intm;
  old_intm = IRQ_globalDisable();  

  RTC_FSET(RTCPINTR,RS,interval);

  IRQ_globalRestore(old_intm);   

}


/*----------------------------------------------------------------------------*/

#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_setPerInt.c
\******************************************************************************/


rtc_settim.c/   1049977258  0     0     0       3094      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... RTC
* FILENAME...... rtc_setTime.c
* DATE CREATED.. 7/09/01
* PROJECT....... RTC
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   7/09/01 (IM) Created
*  22/02/02 (IM) Removed the call to _RESET_B which starts the RTC running
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the RTC module)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

/****************************************\
* include files
\****************************************/
#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_rtc.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC static macro declarations
\****************************************/

/****************************************\
* RTC static typedef declarations
\****************************************/

/****************************************\
* RTC static function declarations
\****************************************/

/****************************************\
* RTC static variable definitions
\****************************************/

/****************************************\
* RTC static function definitions
\****************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* RTC global variable definitions
\****************************************/

/****************************************\
* RTC global function definitions
\****************************************/

#pragma CODE_SECTION(RTC_setTime,".text:RTC_setTime")

void RTC_setTime(RTC_Time *myTime) {
  /* time is set for the default mode of 24-hour */

  int old_intm;
  old_intm = IRQ_globalDisable();  

  _SET_B; 		 /* Set bit SET in Register B to 1 */  

  RTC_FSET(RTCINTEN, TM, 1);
  RTC_RSET(RTCSEC,myTime->second); 
  RTC_RSET(RTCMIN,myTime->minute);
  RTC_FSET(RTCHOUR,HR,myTime->hour);
	
  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/

#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_setTime.c
\******************************************************************************/

rtc_start.c/    1051539302  0     0     0       1455      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... RTC
* FILENAME...... rtc_start.c
* DATE CREATED.. Mo 09/10/2001
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:		09/10/2001 (IM).  
*   LAST MODIFIED:	10 April 2003  added #pragma CODE_SECTION
*------------------------------------------------------------------------------
* DESCRIPTION:  (Starts the RTC)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

#include <csl_rtc.h>
#include <csl.h>


#if (_RTC_SUPPORT)

#pragma CODE_SECTION(RTC_start,".text:RTC_start")

/*----------------------------------------------------------------------------*/
void RTC_start() {
  int oldgie;

  oldgie = IRQ_globalDisable(); 
    
  _RESET_B;		 /* Set bit SET in Register B to 0 */

  IRQ_globalRestore(oldgie);

}
#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_start.c
\******************************************************************************/


rtc_stop.c/     1051539301  0     0     0       1445      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... RTC
* FILENAME...... rtc_stop.c
* DATE CREATED.. Tue 27/02/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:		27/02/2002 (IM).  
*   MODIFIED: 10 April 2003  added #pragma CODE_SECTION	
*------------------------------------------------------------------------------
* DESCRIPTION:  (Stops the RTC)
*
*
*
\******************************************************************************/
#define _RTC_MOD_

#include <csl_rtc.h>
#include <csl.h>


#if (_RTC_SUPPORT)

#pragma CODE_SECTION(RTC_stop,".text:RTC_stop")

/*----------------------------------------------------------------------------*/
void RTC_stop() {
  int oldgie;

  oldgie = IRQ_globalDisable(); 
    
  _SET_B;		 /* Set bit SET in Register B to 1 */

  IRQ_globalRestore(oldgie);

}
#endif /* RTC_SUPPORT */
/******************************************************************************\
* End of rtc_stop.c
\******************************************************************************/


rtc_strtime.c/  1049977262  0     0     0       3695      `
/****************************************************************************/
/*  RTC_strftime v1.82                                                      */
/*  Copyright (c) 1993-2001  Texas Instruments Incorporated                 */
/****************************************************************************/

#define _RTC_MOD_

#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_time.h>
#include <csl_rtc.h>
#include <string.h>

extern int  sprintf(char *_string, const char *_format, ...);


#pragma CODE_SECTION(RTC_strftime,".text:RTC_strftime")


_CODE_ACCESS size_t RTC_strftime(char            *out,
	                     size_t           maxsize, 
	                     const char      *format,
	                     const struct tm *time)
{
    struct tm tt = *time; 
    int       count = 0;
    char      buf[37];

    RTC_mktime(&tt);     /* MAKE SURE THIS IS A LEGITIMATE TIME */

    for (;;)
    {
	while ((count < maxsize) && *format && (*format != '%'))
	{
	    count++;
	    *out++ = *format++;
	}

	if (count >= maxsize) return 0;
	if (*format == '\0')  { *out = 0; return count; }

	switch (*++format)
	{
	    case '%' : strcpy(buf, "%");                              break;
	    case 'z' : strcpy(buf, CSL_RTC_DATA._tz.dstname);         break;
	    case 'Z' : strcpy(buf, CSL_RTC_DATA._tz.tzname);                       break;

	    case 'A' : strcpy (buf, CSL_RTC_DATA.fday[tt.tm_wday]);                break;
	    case 'a' : strncpy(buf, CSL_RTC_DATA.fday[tt.tm_wday], 3); buf[3] = 0; break;
	    case 'B' : strcpy (buf, CSL_RTC_DATA.fmon[tt.tm_mon]);                 break;
	    case 'b' : strncpy(buf, CSL_RTC_DATA.fmon[tt.tm_mon], 3);  buf[3] = 0; break;
	    case 'c' : sprintf(buf, "%s %s%3d %02d:%02d:%02d %d",
			       CSL_RTC_DATA.fday[tt.tm_wday], 
                         CSL_RTC_DATA.fmon[tt.tm_mon],
			       tt.tm_mday, tt.tm_hour, tt.tm_min,
			       tt.tm_sec, tt.tm_year + 1900);         break;

	    case 'I' : sprintf(buf, "%02d", tt.tm_hour ? 
			                    tt.tm_hour % 12 : 12);    break;
	    case 'H' : sprintf(buf, "%02d", tt.tm_hour);              break;
	    case 'M' : sprintf(buf, "%02d", tt.tm_min);               break;
	    case 'S' : sprintf(buf, "%02d", tt.tm_sec);               break;
	    case 'j' : sprintf(buf, "%03d", tt.tm_yday + 1);          break;
	    case 'd' : sprintf(buf, "%02d", tt.tm_mday);              break;
	    case 'w' : sprintf(buf, "%1d",  tt.tm_wday);              break;
	    case 'm' : sprintf(buf, "%02d", tt.tm_mon + 1);           break;
	    case 'y' : sprintf(buf, "%02d", tt.tm_year % 100);        break;
	    case 'Y' : sprintf(buf, "%4d", 1900 + tt.tm_year);        break;

	    case 'p' : strcpy(buf, tt.tm_hour >= 12 ? "PM":"AM");     break;

	    case 'W' : sprintf(buf, "%02d", tt.tm_yday / 7 +
			       (tt.tm_yday % 7 >= (tt.tm_wday + 6) % 7));
	    							      break;
	    case 'U' : sprintf(buf, "%02d", tt.tm_yday / 7 +
			       (tt.tm_yday % 7 >= tt.tm_wday));       break;

	    case 'x' : sprintf(buf, "%3s %d, %d", 
                         CSL_RTC_DATA.fmon[tt.tm_mon], 
			       tt.tm_mday, tt.tm_year + 1900);        break;
	    case 'X' : sprintf(buf, "%02d:%02d:%02d", tt.tm_hour, 
			       tt.tm_min, tt.tm_sec);                 break;
	}

	/*-------------------------------------------------------------*/
	/* IF THIS STRING WILL FIT IN BUFFER, APPEND IT.               */
	/*-------------------------------------------------------------*/
	if ((count += strlen(buf)) > maxsize) return 0;
	strcpy(out, buf);
	out += strlen(buf);
	format++;
    }
}
#endif

rtc_time.c/     1049977264  0     0     0       734       `
/*****************************************************************************/
/*  TIME.C v1.82                                                            */
/*  Copyright (c) 1995-2001 Texas Instruments Incorporated                   */
/*****************************************************************************/
#define  _RTC_MOD_    

#include <csl_chiphal.h>

#if (_RTC_SUPPORT)

#include <csl_time.h> 
#include <csl_rtc.h> 
#include <stdio.h>

extern _CODE_ACCESS time_t RTCtime();

#pragma CODE_SECTION(RTC_time,".text:RTC_time")

_CODE_ACCESS time_t RTC_time(time_t *timer) 
{
   time_t result;

   result = (time_t)RTCtime();   
   if(timer) *timer = result;   

   return(result);
}
#endif

rtc_tmzone.c/   1049977265  0     0     0       351       `
/*****************************************************************************/
/*  _tz v1.82                                                                */
/*  Copyright (c) 1993-2001  Texas Instruments Incorporated                  */
/*****************************************************************************/
#include <csl_time.h>



tim_cfg.c/      1049977267  0     0     0       4126      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... tim_cfg.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... MCRTE - multichannel runtime environment
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999 
*   MODIFIED: 12/06/2000 Modification for C54x .
*   MODIFIED: 02/18/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 05/30/2000 Created for C55x .
*   MODIFIED: 06/28/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the TIMER module)
*
*
*
\******************************************************************************/
#define _TIMER_MOD_

/****************************************\
* include files
\****************************************/    


#include <csl_chiphal.h>  
 
#if (_TIMER_SUPPORT)
#include <csl_timer.h>
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER static macro declarations
\****************************************/
/* See timer.h Romability */
 
/****************************************\
* TIMER static typedef declarations
\****************************************/

/****************************************\
* TIMER static function declarations
\****************************************/

/****************************************\
* TIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See timer.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(TIMER_config,".text:TIMER_config")

/*----------------------------------------------------------------------------*/
void TIMER_config(TIMER_Handle hTimer, TIMER_Config *Config) {
  int oldgie;
  TIMER_ASSERT_HANDLE(hTimer,return);

    oldgie = IRQ_globalDisable();  
 
  PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr) = 0x0010;  
  PREG16(((TIMER_PrivateObj*)hTimer)->PrdAddr) = Config->prd;
  PREG16(((TIMER_PrivateObj*)hTimer)->PrscAddr)= Config->prsc;
  TIMER_FSETH(hTimer,TCR,TLB,1);
  PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr) = Config->tcr | 0x0010;
 /* TIMER_FSETH(hTimer,TCR,TLB,0); */
  
  
  IRQ_globalRestore(oldgie); 
 
}
/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of tim_cfga.c
\******************************************************************************/

tim_cfgb.c/     1049977268  0     0     0       4122      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... tim_cfgB.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999 Created for C6x
*   MODIFIED: 12/06/2000 Modification for C54x .
*   MODIFIED: 02/18/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 05/30/2000 Created for C55x .
*   MODIFIED: 06/28/2001 aded pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the TIMER module)
*
*
*
\******************************************************************************/
#define _TIMER_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_chiphal.h>

   

#if (_TIMER_SUPPORT)

#include <csl_timer.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER static macro declarations
\****************************************/
/* See timer.h Romability */
 
/****************************************\
* TIMER static typedef declarations
\****************************************/

/****************************************\
* TIMER static function declarations
\****************************************/

/****************************************\
* TIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See timer.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(TIMER_configArgs,".text:TIMER_configArgs")

/*----------------------------------------------------------------------------*/
void TIMER_configArgs(TIMER_Handle hTimer, Uint16 tcr, Uint16 prd, Uint16 prsc) {
  int oldgie;
  TIMER_ASSERT_HANDLE(hTimer,return);
  oldgie = IRQ_globalDisable(); 
  

  PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr) = 0x0010;
  PREG16(((TIMER_PrivateObj*)hTimer)->PrdAddr) = prd;
  PREG16(((TIMER_PrivateObj*)hTimer)->PrscAddr) = prsc;
  TIMER_FSETH(hTimer,TCR,TLB,1);
  PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr) = tcr | 0x0010;   
  TIMER_FSETH(hTimer,TCR,TLB,0);

  
  IRQ_globalRestore(oldgie); 
}

/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of tim_cfgb.c
\******************************************************************************/

tim_close.c/    1049977270  0     0     0       4336      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... tim_close.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999 
*   MODIFIED: 12/06/2000 Modification for C54x .
*   MODIFIED: 02/18/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 05/30/2000 Created for C55x .
*   MODIFIED: 06/28/2001 updated for new CSL initialization model &
*                        pragma for individual code section/per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the TIMER module)
*
*
*
\******************************************************************************/
#define _TIMER_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_chiphal.h>   
 
#if (_TIMER_SUPPORT)

#include <csl_timer.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER static macro declarations
\****************************************/
/* See timer.h Romability */

#define ALLOCATED(hTimer) (((TIMER_PrivateObj *)hTimer)->Allocated)
#define EVENTID(hTimer)   (((TIMER_PrivateObj*)hTimer)->EventId)  
#define TCR(hTimer) PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr)
#define PRD(hTimer) PREG16(((TIMER_PrivateObj*)hTimer)->PrdAddr)
#define TIM(hTimer) PREG16(((TIMER_PrivateObj*)hTimer)->TimAddr) 
#define PRSC(hTimer) PREG16(((TIMER_PrivateObj*)hTimer)->PrscAddr) 
 
 
/****************************************\
* TIMER static typedef declarations
\****************************************/

/****************************************\
* TIMER static function declarations
\****************************************/

/****************************************\
* TIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See timer.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/
#pragma CODE_SECTION(TIMER_close,".text:TIMER_close")

/*----------------------------------------------------------------------------*/
void TIMER_close(TIMER_Handle hTimer) {
  int oldgie;
  TIMER_ASSERT_HANDLE(hTimer,return);
    oldgie = IRQ_globalDisable(); 


  CSL_SYS_DATA.TimerAllocMask &= (~(1u<<((TIMER_PrivateObj*)hTimer)->Timer));   
  TIMER_reset(hTimer);
  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of tim_close.c
\******************************************************************************/

tim_gcfg.c/     1049977271  0     0     0       3749      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... tim_gcfg.c
* DATE CREATED.. Thu 05/10/2001 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*    CREATED:   05/10/2001
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the TIMER module)
*
*
*
\******************************************************************************/
#define _TIMER_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_chiphal.h>

#if (_TIMER_SUPPORT)

     
#include <csl_timer.h>
   
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER static macro declarations
\****************************************/
/* See timer.h Romability */
 
/****************************************\
* TIMER static typedef declarations
\****************************************/

/****************************************\
* TIMER static function declarations
\****************************************/

/****************************************\
* TIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See timer.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(TIMER_getConfig,".text:TIMER_getConfig")

/*----------------------------------------------------------------------------*/
void TIMER_getConfig(TIMER_Handle hTimer, TIMER_Config *Config) {
  int oldgie;
  TIMER_ASSERT_HANDLE(hTimer,return);

    oldgie = IRQ_globalDisable();  
 
  Config->tcr = PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr);  
  Config->prd = PREG16(((TIMER_PrivateObj*)hTimer)->PrdAddr);
  Config->prsc = PREG16(((TIMER_PrivateObj*)hTimer)->PrscAddr);
 
  IRQ_globalRestore(oldgie); 
 
}
/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of tim_gcfg.c
\******************************************************************************/


tim_open.c/     1061462363  0     0     0       5224      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... TIM_open.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999 Created 
*   MODIFIED: 12/06/2000 Modification for C54x .
*   MODIFIED: 02/18/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 05/30/2000 Created for C55x .
*   MODIFIED: 06/28/2001 updated for new CSL initialization model and
*                        included pragma for individual section per function
*   MODIFIED: 07/22/2003 Fixed the typo 'Timer_open' in the CODE_SECTION pragma.
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the TIMER module)
*
*
*
\******************************************************************************/
#define _TIMER_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_chiphal.h>
 
#if (_TIMER_SUPPORT)

#include <csl_timer.h>
   
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER static macro declarations
\****************************************/
/* See timer.h Romability */

#define ALLOCATED(hTimer) (((TIMER_PrivateObj *)hTimer)->Allocated)
#define EVENTID(hTimer)   (((TIMER_PrivateObj*)hTimer)->EventId)  
#define TCR(hTimer) PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr)
#define PRD(hTimer) PREG16(((TIMER_PrivateObj*)hTimer)->PrdAddr)
#define TIM(hTimer) PREG16(((TIMER_PrivateObj*)hTimer)->TimAddr) 
#define PRSC(hTimer) PREG16(((TIMER_PrivateObj*)hTimer)->PrscAddr) 
 
 
/****************************************\
* TIMER static typedef declarations
\****************************************/

/****************************************\
* TIMER static function declarations
\****************************************/

/****************************************\
* TIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See timer.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(TIMER_open,".text:TIMER_open")

/*----------------------------------------------------------------------------*/
TIMER_Handle TIMER_open(int DevNum, Uint16 Flags) {

  TIMER_Handle hTimer = INV;
  Uint16 dev  = DevNum;
  int oldgie;

  oldgie = IRQ_globalDisable();  
 
 
  #ifdef _MCRTE_DEBUG
  if (!((DevNum == -1)||(DevNum>=0&&TIMER_DEVICE_CNT))) {
    ERR_submit(TIMER_ERR_MAJOR, TIMER_ERR_ALLOC);
     IRQ_globalRestore(oldgie);
    return (TIMER_Handle) INV;
  }
  #endif

  if (DevNum==-1) {
    for (dev=0; dev<TIMER_DEVICE_CNT; dev++) {
      if (!(CSL_SYS_DATA.TimerAllocMask & (1u<<dev))){
        hTimer = TIMER_hDev(dev);
       break;
      }
    }
  } else if (!(CSL_SYS_DATA.TimerAllocMask & (1u<<dev))){
    hTimer = TIMER_hDev(dev);
  }

  #ifdef _MCRTE_DEBUG
    if (hTimer == INV) {
      ERR_submit(TIMER_ERR_MAJOR, TIMER_ERR_INVALID_HANDLE);
      IRQ_restoreGie();
      return (TIMER_Handle)INV;
  }
  #endif

  if (hTimer != INV) {
     CSL_SYS_DATA.TimerAllocMask |= 1u<<dev;     
     if (Flags & TIMER_OPEN_RESET) {
       TIMER_reset(hTimer);
     }
  }

  IRQ_globalRestore(oldgie);
  return hTimer;
}

/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of TIM_open.c
\******************************************************************************/

tim_rstt.c/     1049977274  0     0     0       4704      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... tim_rst.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999
*   MODIFIED: 12/06/2000 Modification for C54x .
*   MODIFIED: 02/18/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 05/30/2000 (NNS) Created for C55x .
*   MODIFIED: 06/28/2001 included pragma for creation of code section per
*              function
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the TIMER module)
*
*
*
\******************************************************************************/
#define _TIMER_MOD_

/****************************************\
* include files
\****************************************/
    

   
#include <csl_chiphal.h>  
 
#if (_TIMER_SUPPORT)

#include <csl_timer.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER static macro declarations
\****************************************/
/* See timer.h Romability */

#define ALLOCATED(hTimer) (((TIMER_PrivateObj *)hTimer)->Allocated)
#define EVENTID(hTimer)   (((TIMER_PrivateObj*)hTimer)->EventId)  
#define TCR(hTimer)       PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr)
#define PRD(hTimer)       PREG16(((TIMER_PrivateObj*)hTimer)->PrdAddr)
#define TIM(hTimer)       PREG16(((TIMER_PrivateObj*)hTimer)->TimAddr) 
#define PRSC(hTimer)      PREG16(((TIMER_PrivateObj*)hTimer)->PrscAddr)  
 
/****************************************\
* TIMER static typedef declarations
\****************************************/

/****************************************\
* TIMER static function declarations
\****************************************/

/****************************************\
* TIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See timer.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(TIMER_reset,".text:TIMER_reset")

/*----------------------------------------------------------------------------*/
void TIMER_reset(TIMER_Handle hTimer) {
  int oldgie;
  Uint16 EventId;

  oldgie = IRQ_globalDisable();  
    
  if (hTimer == INV) {    
 
      TIMER_reset(TIMER_hDev0);
      TIMER_reset(TIMER_hDev1);  
       
  } 
  else {
      EventId  = TIMER_getEventId(hTimer);
      /* stop timer */  
      TIMER_FSETH(hTimer,TCR,TSS,1); 
      /* Reset Period Value=0xFFFF */
      TIMER_RSETH(hTimer,PRD,0xFFFF);
      TIMER_FSETH(hTimer,TCR,TLB,1);
      /* Reset Bit Value */
      TIMER_RSETH(hTimer,TCR,TIMER_TCR_DEFAULT);
      IRQ_disable(EventId);
      IRQ_clear(EventId);
  }
  IRQ_globalRestore(oldgie);

}

/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of tim_rst.c
\******************************************************************************/

tim_start.c/    1049977276  0     0     0       3937      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... tim_start.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999 
*   MODIFIED: 12/06/2000 Modification for C54x .
*   MODIFIED: 02/18/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 05/30/2000 Created for C55x .
*   MODIFIED: 06/28/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (Starts Timer Operation - assumes timer is preconfigured)
*
*
*
\******************************************************************************/
#define _TIMER_MOD_

/****************************************\
* include files
\****************************************/    


#include <csl_chiphal.h>   

#if (_TIMER_SUPPORT)

#include <csl_timer.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER static macro declarations
\****************************************/
/* See timer.h Romability */
 
 
/****************************************\
* TIMER static typedef declarations
\****************************************/

/****************************************\
* TIMER static function declarations
\****************************************/

/****************************************\
* TIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See timer.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(TIMER_start,".text:TIMER_start")

/*----------------------------------------------------------------------------*/
void TIMER_start(TIMER_Handle hTimer) {
  int oldgie;
  Uint16 old_tcr;

  oldgie = IRQ_globalDisable(); 
    
      /* stop timer */  
  old_tcr = _PREG_GET(((TIMER_PrivateObj*)(hTimer))->TcrAddr);
  _PREG_SET(((TIMER_PrivateObj*)(hTimer))->TcrAddr, (old_tcr & (_TIMER_TCR_TLB_CLR & _TIMER_TCR_TSS_CLR)));
  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of tim_start.c
\******************************************************************************/


tim_stop.c/     1049977277  0     0     0       3884      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... tim_stop.c
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999 Created for C6x
*   MODIFIED: 12/06/2000 Modification for C54x .
*   MODIFIED: 02/18/2000 C54x Romability ( All static variable were removed) .
*   MODIFIED: 05/30/2000 Created for C55x .
*   MODIFIED: 06/28/2001 added pragma for section per function
*------------------------------------------------------------------------------
* DESCRIPTION:  (Starts Timer Operation - assumes timer is preconfigured)
*
*
*
\******************************************************************************/
#define _TIMER_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_chiphal.h> 
 
#if (_TIMER_SUPPORT)

#include <csl_timer.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER static macro declarations
\****************************************/
/* See timer.h Romability */ 
 
/****************************************\
* TIMER static typedef declarations
\****************************************/

/****************************************\
* TIMER static function declarations
\****************************************/

/****************************************\
* TIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See timer.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(TIMER_stop,".text:TIMER_stop")

/*----------------------------------------------------------------------------*/
void TIMER_stop(TIMER_Handle hTimer) {
  int oldgie;

  oldgie = IRQ_globalDisable(); 
    
      /* stop timer */  
  TIMER_FSETH(hTimer,TCR,TSS,1);

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of tim_stop.c
\******************************************************************************/

tim_tinout.c/   1049977279  0     0     0       4776      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... tim_tinout.c
* DATE CREATED.. Sun 05/29/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  05/29/2000 
*   MODIFIED: 06/28/2001 added pragma for section per function
*   MODIFIED: 08/13/2002 fixed register access problem
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the TIMER module)
*
*
*
\******************************************************************************/
#define _TIMER_MOD_

/****************************************\
* include files
\****************************************/    
#include <csl_chiphal.h>

#if (_TIMER_SUPPORT)

#include <csl_timer.h>
   
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER static macro declarations
\****************************************/
/* See timer.h Romability */

#define ALLOCATED(hTimer) (((TIMER_PrivateObj *)hTimer)->Allocated)
#define EVENTID(hTimer)   (((TIMER_PrivateObj*)hTimer)->EventId)  
#define TCR(hTimer)       PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr)
#define PRD(hTimer)       PREG16(((TIMER_PrivateObj*)hTimer)->PrdAddr)
#define TIM(hTimer)       PREG16(((TIMER_PrivateObj*)hTimer)->TimAddr) 
#define PRSC(hTimer)      PREG16(((TIMER_PrivateObj*)hTimer)->PrscAddr)  
 
/****************************************\
* TIMER static typedef declarations
\****************************************/

/****************************************\
* TIMER static function declarations
\****************************************/

/****************************************\
* TIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See timer.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(TIMER_tintoutCfg,".text:TIMER_tintoutCfg")

/*----------------------------------------------------------------------------*/
void TIMER_tintoutCfg(TIMER_Handle hTimer, Uint16 idleen, Uint16 func, Uint16 pwid, Uint16 cp, Uint16 polar) {
  Uint16 tcrMask = TIMER_TCR_RMK(
                     idleen,
                     func,
                     0,             /* TLB    */
                     0,             /* SOFT   */
                     0,             /* FREE   */
                     pwid,          /* PWID   */
                     0,             /* ARB    */
                     0,             /* TSS    */
                     cp,            /* CP     */
                     polar,         /* POLAR  */
                     0);            /* DATOUT */
 
  int oldgie;

  oldgie = IRQ_globalDisable();

     PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr) |= 0x0010;
     PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr) |= tcrMask;

  IRQ_globalRestore(oldgie);
      
}


/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of tim_tinout.c
\******************************************************************************/

ur_cfg.c/       1049977284  0     0     0       2268      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... uart_cfga.c
* DATE CREATED.. Sun 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\******************************************************************************/
#define _UART_MOD_

/****************************************\
* include files
\****************************************/  

#include <csl_irq.h>
 
#if (_UART_SUPPORT)

#include <csl_uart.h> 
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

#pragma CODE_SECTION(UART_config,".text:UART_config")
/****************************************\
* UART global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
 void UART_config(UART_Config *config) {
  int old_intm;
  old_intm = IRQ_globalDisable();  

  UART_FSET(URLCR, DLAB, 1);
  UART_RSET(URDLL, config->dll);  
  UART_RSET(URDLM, config->dlm);  
  
  UART_RSET(URLCR, config->lcr);  
  UART_RSET(URFCR, 0x7);  
  UART_RSET(URFCR, config->fcr);  
  UART_FSET(URMCR, LOOP, config->mcr);  

  //clear IER first to make sure UART work properly
  UART_FSET(URLCR, DLAB, 0);
  UART_RSET(URIER, UART_NOINT);
 
  IRQ_globalRestore(old_intm);   
}
/*----------------------------------------------------------------------------*/

#endif /* UART_SUPPORT */
/******************************************************************************\
* End of uart_cfga.c
\******************************************************************************/

ur_cfgb.c/      1049977286  0     0     0       2273      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... uart_cfgb.c
* DATE CREATED.. 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   02/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\******************************************************************************/
#define _UART_MOD_

/****************************************\
* include files
\****************************************/  

#include <csl_irq.h>
 
#if (_UART_SUPPORT)

#include <csl_uart.h> 
#pragma CODE_SECTION(UART_configArgs,".text:UART_configArgs")

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* UART global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
 void UART_configArgs(Uint16 dll, Uint16 dlm, Uint16 lcr, Uint16 fcr, Uint16 mcr) {
  int old_intm;
  old_intm = IRQ_globalDisable();  

  UART_FSET(URLCR, DLAB, 1);  
  UART_RSET(URDLL, dll);  
  UART_RSET(URDLM, dlm);
    
  UART_RSET(URLCR, lcr);  
  UART_RSET(URFCR, 0x7);  
  UART_RSET(URFCR, fcr);  
  UART_RSET(URMCR, mcr);  

  //clear IER first to make sure UART work properly
  UART_FSET(URLCR, DLAB, 0);
  UART_RSET(URIER, UART_NOINT);
 
  IRQ_globalRestore(old_intm);   
}
/*----------------------------------------------------------------------------*/

#endif /* UART_SUPPORT */
/******************************************************************************\
* End of uart_cfgb.c
\******************************************************************************/


ur_evtdisa.c/   1049977287  0     0     0       1733      `
/*****************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... UART_eventDisable.c
* DATE CREATED.. Sun 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\*****************************************************************************/
#define _UART_MOD_

/*----------------------------------------------------------------------------*/
/* INCLUDES                                                                   */
/*----------------------------------------------------------------------------*/
#include <csl.h>
#include <csl_irq.h>

#if (_UART_SUPPORT)
#include <csl_uart.h>
#pragma CODE_SECTION(UART_eventDisable,".text:UART_eventDisable")
/*----------------------------------------------------------------------------*/
/* Function                                                                   */
/*----------------------------------------------------------------------------*/
void UART_eventDisable(Uint16 ierMask)
{
        UART_FSET(URLCR,DLAB,0);
//        UART_RAND(URIER,~ierMask);
        UART_RAOI(URIER,ierMask,0x0000,0x0000);
        if ( !(UART_RGET(URIER) & 0x0F) )
            IRQ_disable(IRQ_EVT_UART);
}
#endif /* UART_SUPPORT */


ur_evtenab.c/   1049977288  0     0     0       1683      `
/*****************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... UART_intrEnable.c
* DATE CREATED.. Sun 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\*****************************************************************************/
#define _UART_MOD_

/*----------------------------------------------------------------------------*/
/* INCLUDES                                                                   */
/*----------------------------------------------------------------------------*/
#include <csl.h>
#include <csl_irq.h>

#if (_UART_SUPPORT)
#include <csl_uart.h>
#pragma CODE_SECTION(UART_eventEnable,".text:UART_eventEnable")
/*----------------------------------------------------------------------------*/
/* Function                                                                   */
/*----------------------------------------------------------------------------*/
void UART_eventEnable(Uint16 isrMask)
{
        UART_FSET(URLCR,DLAB,0);
//        UART_ROR(URIER,isrMask); 
        UART_RAOI(URIER,0xFFFF, (isrMask), 0x0000);
        IRQ_enable(IRQ_EVT_UART);
}
#endif /* UART_SUPPORT */


ur_fgtc.c/      1049977290  0     0     0       2971      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... uart_fgtc.c
* DATE CREATED.. 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*  This routine reads a character from the uart.                            
*                                                                           
*  Parameters:                                                              
*      - None                                                               
*                                                                           
*  Return:                                                                  
*  - If character available, returns character as non-sign extended int     
*  - If no character available, returns EOF                                 
*
*
*
\******************************************************************************/
#define _UART_MOD_

/****************************************\
* include files
\****************************************/  
#include <csl_irq.h>

#if (_UART_SUPPORT)
#include <csl_uart.h> 
#pragma CODE_SECTION(UART_fgetc,".text:UART_fgetc")
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* UART global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

CSLBool UART_fgetc(int *c, Uint32 timeout)
{
    Uint16 i = 0;
    Uint16 temp;

    //DLAB=0
    UART_FSET(URLCR, DLAB, 0);

    if (timeout!=0)                 /* check for timeout */
    {    
      for (i=0;i<=timeout;i++)  {   /* check for DR */
        temp=UART_FGET(URLSR,DR);
        if (temp==1) break; 
      }
  
      if (i>=timeout)               /* timeout error */
        return FALSE;  
    }   
    else                            /* no timeout */
    {
      while( !UART_FGET(URLSR,DR) );
    } 
 
    *c = UART_RGET(URRBR);
    return TRUE;
    
}
#endif /* UART_SUPPORT */
/******************************************************************************\
* End of uart_fgtc.c
\******************************************************************************/

ur_fgts.c/      1074509104  0     0     0       3621      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... uart_fgts.c
* DATE CREATED.. 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*  This routine reads a string from the uart. The string will be read upto  
*  a newline or until the buffer is filled. The string is always NULL       
*  terminated and does not have any newline character removed.              
*                                                                           
*  Parameters:                                                              
*      - pbuf - an area of memory to use for character storage              
*      - bufSize - the size of that memory area in characters (must include 
*                  space for the NULL terminator).                          
*                                                                           
*                                                                           
*  Return:                                                                  
*  - On Success, returns pointer to string                                  
*  - On Failure, returns NULL pointer                                       
*
*
*
\******************************************************************************/
#define _UART_MOD_

/****************************************\
* include files
\****************************************/  
#include <csl_irq.h>
#if (_UART_SUPPORT)
#include <csl_uart.h> 
#pragma CODE_SECTION(UART_fgets,".text:UART_fgets")
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* UART global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
CSLBool UART_fgets(char* pBuf, Uint16 bufSize, Uint32 timeout)
{
  int cnt = bufSize;
  int temp, i;
  
  //DLAB=0
  UART_FSET(URLCR, DLAB, 0);

  if (timeout!=0)
  {
    while (cnt--)
    {
        for(i=0; i<=timeout; i++)
        {
            temp=UART_FGET(URLSR,DR);
            if(temp == 1) break;
        }
        
        if (i>=timeout)
            return FALSE;
            
        *pBuf = UART_RGET(URRBR);
        if ((*pBuf == '\n') ||
            (*pBuf == '\r'))
        {
            *(pBuf) = '\0';

			break;
        }
        pBuf++;
    }
  }
  else
  {
    while (cnt--)
    {
        //wait for RX buffer full
        while( !UART_FGET(URLSR,DR) );

        *pBuf = UART_RGET(URRBR);
        if ((*pBuf == '\n') ||
            (*pBuf == '\r'))
        {
            *(pBuf) = '\0';

			break;
        }
        pBuf++;
    }
  }
  *pBuf = '\0';

  return TRUE;
}
#endif /* UART_SUPPORT */
/******************************************************************************\
* End of uart_fgts.c
\******************************************************************************/

ur_fptc.c/      1049977293  0     0     0       2910      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... uart_fptc.c
* DATE CREATED.. 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*  This routine writes a character to the uart.                             
*                                                                           
*  Parameters:                                                              
*      - c - The character, as an int, to be sent to the uart.              
*                                                                           
*  Return:                                                                  
*  - On Success, returns character written                                  
*  - On Failure, returns EOF                                                
*
*
*
\******************************************************************************/
#define _UART_MOD_

/****************************************\
* include files
\****************************************/  
#include <csl_irq.h>
#if (_UART_SUPPORT)
#include <csl_uart.h> 
#pragma CODE_SECTION(UART_fputc,".text:UART_fputc")
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* UART global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
CSLBool UART_fputc(const int c, Uint32 timeout)
{
    int i, temp;
    
    //DLAB=0
    UART_FSET(URLCR, DLAB, 0);
    if (timeout!=0)                 /* check for timeout */
    {    
      for (i=0;i<=timeout;i++)  {   /* check for DR */
        temp=UART_FGET(URLSR,THRE);
        if (temp==1) break; 
      }
  
      if (i>=timeout)               /* timeout error */
        return FALSE;  
    }   
    else                            /* no timeout */
    {    
      //wait for TX buffer empty
      while( !UART_FGET(URLSR,THRE) );
    }

    UART_RSET(URTHR,c);
    
    return TRUE;
}
#endif /* UART_SUPPORT */
/******************************************************************************\
* End of uart_fptc.c
\******************************************************************************/
ur_fpts.c/      1049977294  0     0     0       3157      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... uart_fpts.c
* DATE CREATED.. Sun 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*  This routine writes a string to the uart. The NULL terminator is not     
*  written and a newline is not added to the output.                        
*                                                                           
*  Parameters:                                                              
*      - pbuf - an area of memory containing the string to be written.      
*                                                                           
*                                                                           
*  Return:                                                                  
*  - On Success, returns 0                                                  
*  - On Failure, returns non-0                                              
*                                                                           
*
*
*
\******************************************************************************/
#define _UART_MOD_

/****************************************\
* include files
\****************************************/  
#include <csl_irq.h>
#if (_UART_SUPPORT)
#include <csl_uart.h> 
#pragma CODE_SECTION(UART_fputs,".text:UART_fputs")
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* UART global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
CSLBool UART_fputs(const char* pBuf, Uint32 timeout)
{
    int temp, i;

    //DLAB=0
    UART_FSET(URLCR, DLAB, 0);
    
  if (timeout!=0)
  {
    while (*pBuf != '\0')
    {
        for(i=0; i<=timeout; i++)
        {
            temp=UART_FGET(URLSR,THRE);
            if(temp == 1) break;
        }
        
        if (i>=timeout)
            return FALSE;

        UART_RSET(URTHR, *pBuf++);
    }
  }
  else
  {    
    while (*pBuf != '\0')
    {
        //wait for TX buffer empty
        while( !UART_FGET(URLSR,THRE) );
        UART_RSET(URTHR, *pBuf++);
    }
  }    
  return TRUE;
}
#endif /* UART_SUPPORT */
/******************************************************************************\
* End of uart_fpts.c
\******************************************************************************/

ur_gcfg.c/      1049977296  0     0     0       2377      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... uart_gcfga.c
* DATE CREATED.. 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\******************************************************************************/
#define _UART_MOD_

/****************************************\
* include files
\****************************************/  
#include <csl_irq.h>
#if (_UART_SUPPORT)
#include <csl_uart.h> 
#pragma CODE_SECTION(UART_getConfig,".text:UART_getConfig")
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* UART global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
 void UART_getConfig(UART_Config *config) {
  int temp;
  int old_intm;
  old_intm = IRQ_globalDisable();  

  config->lcr = UART_RGET(URLCR);  
  
  temp = (config->lcr & _UART_URLCR_DLAB_MASK) >>_UART_URLCR_DLAB_SHIFT;  
  UART_FSET(URLCR, DLAB, 1);
  config->dll = UART_RGET(URDLL);  
  config->dlm = UART_RGET(URDLM);  
  UART_FSET(URLCR, DLAB, temp);


//Note: FCR is a write only register, when read back, it will be IIR.
//Only FIFO enable bits was obtained from IIR here
  config->fcr = UART_FGET(URIIR, FIENR);  
  config->mcr = UART_RGET(URMCR);  
 
  IRQ_globalRestore(old_intm);   
}
/*----------------------------------------------------------------------------*/

#endif /* UART_SUPPORT */
/******************************************************************************\
* End of uart_gcfga.c
\******************************************************************************/


ur_getEId.c/    1049977297  0     0     0       1825      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... uart_getEventId.c
* DATE CREATED.. Sun 01/18/2002
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\******************************************************************************/
#define _UART_MOD_

/****************************************\
* include files
\****************************************/  
#include <csl_irq.h>
#if (_UART_SUPPORT)
#include <csl_uart.h> 
#pragma CODE_SECTION(UART_getEventId,".text:UART_getEventId")
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* UART global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
 Uint16 UART_getEventId() {
  return IRQ_EVT_UART;
}
/*----------------------------------------------------------------------------*/

#endif /* UART_SUPPORT */
/******************************************************************************\
* End of uart_cfga.c
\******************************************************************************/


ur_getp.c/      1049977299  0     0     0       2249      `
/*****************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... UART_getParams.c
* DATE CREATED.. Sun 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\*****************************************************************************/
#define _UART_MOD_

/*----------------------------------------------------------------------------*/
/* INCLUDES                                                                   */
/*----------------------------------------------------------------------------*/
#include <csl.h>
#include <csl_irq.h>
#if (_UART_SUPPORT)
#include <csl_uart.h>
#pragma CODE_SECTION(UART_getSetup,".text:UART_getParams")
/*----------------------------------------------------------------------------*/
/* Function                                                                   */
/*----------------------------------------------------------------------------*/
void UART_getSetup(UART_Setup *params)
{
    Int16 old_intm;
    Uint16 temp1;
    old_intm = IRQ_globalDisable();  

    //DLAB = 1
    UART_FSET(URLCR,DLAB,1);
    temp1 = UART_RGET(URDLM) << UART_HIGHBYTE_SHIFT;
    params->baud = temp1 | (UART_HIGHBYTE_MASK & UART_RGET(URDLL));
    //DLAB = 0
    UART_FSET(URLCR,DLAB,0);

    temp1 = UART_RGET(URLCR);
    params->wordLength = temp1 & _UART_URLCR_WLS_MASK;
    params->stopBits = temp1 & _UART_URLCR_STB_MASK;
    params->parity = (temp1 & UART_PARITY_MASK);
        

    //FIFO control. 
    params->fifoControl = UART_FGET(URIIR, FIENR);    

    //Loopback control
    params->loopBackEnable = UART_RGET(URMCR) & _UART_URMCR_LOOP_MASK;    

    IRQ_globalRestore(old_intm);    
    return;
}
#endif /* UART_SUPPORT */

ur_read.c/      1049977300  0     0     0       2502      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... uart_read.c
* DATE CREATED.. 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\******************************************************************************/
#define _UART_MOD_

/****************************************\
* include files
\****************************************/  
#include <csl_irq.h>

#if (_UART_SUPPORT)
#include <csl_uart.h> 

#pragma CODE_SECTION(UART_read,".text:UART_read")
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* UART global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
CSLBool UART_read(char *pBuf, Uint16 length, Uint32 timeout ) 
{
    int i, temp;
    
    UART_FSET(URLCR, DLAB, 0);

    if (timeout!=0)
    {      
        while( length-- )
        {
            for(i=0; i<=timeout; i++)
            {
                temp=UART_FGET(URLSR,DR);
                if(temp == 1) break;
            }
        
            if (i>=timeout)
                return FALSE;
            
            *pBuf++ = UART_RGET(URRBR);
        }     
    }
    else            
    {                   
        while( length-- )
        {
            /* wait for RX empty */
            while(!UART_FGET(URLSR,DR));
            *pBuf++ = UART_RGET(URRBR);
        }
    }    
    
    return TRUE;
}
/*----------------------------------------------------------------------------*/

#endif /* UART_SUPPORT */
/******************************************************************************\
* End of uart_read.c
\******************************************************************************/

ur_sbrate.c/    1074593845  0     0     0       2106      `
/*****************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... UART_setupBaudRate.c
* DATE CREATED.. Sun 01/18/2002
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\*****************************************************************************/
#define _UART_MOD_

#include <csl.h>

/*----------------------------------------------------------------------------*/
/* INCLUDES                                                                   */
/*----------------------------------------------------------------------------*/
#if (_UART_SUPPORT)
#include <csl_uart.h>

#pragma CODE_SECTION(UART_setupBaudRate,".text:UART_setupBaudRate")

/*----------------------------------------------------------------------------*/
/* Function                                                                   */
/*----------------------------------------------------------------------------*/
void UART_setupBaudRate(Uint16 clkInput, Uint16 baudRate)
{
    Uint16 tempbaud;

    //----------------------------BAUD RATE SETUP----------------------------
    
    //Symbolic constants for baud rates in csl_uart.h are for 64MHz UART CLK
    //For any other UART CLK= c MHz, the formula for baud rate is:
    //  (c * baud_rate_for_64MHz) / 64
    
    tempbaud = (Uint16)(((Uint32)clkInput * (Uint32)baudRate) >> 6);

    //DLAB = 1
    UART_FSET(URLCR, DLAB, 1);
    UART_RSET(URDLL, (tempbaud & 0xFF));
    UART_RSET(URDLM, (tempbaud >> 8));
    //DLAB = 0
    UART_FSET(URLCR, DLAB, 0);    
   
    return;
}
#endif /* _UART_SUPPORT */

ur_scback.c/    1065617105  0     0     0       3149      `
/*****************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... uart_setCallback.c
* DATE CREATED.. Sun 01/18/2002
* PROJECT....... Chip Support Library
* COMPONENT.....
* IMPORTS.......
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created
*   09/11/2003   Modified  Checks the address validity in UART_intrDispatch.
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\*****************************************************************************/
#define _UART_MOD_

/*----------------------------------------------------------------------------*/
/* INCLUDES                                                                   */
/*----------------------------------------------------------------------------*/
#include <csl.h>
#include <csl_irq.h>

#if (_UART_SUPPORT)
#include <csl_uart.h>

#pragma CODE_SECTION(UART_setCallback,".text:UART_setCallback")
/*----------------------------------------------------------------------------*/
/* Function                                                                   */
/*----------------------------------------------------------------------------*/
void UART_setCallback(UART_IsrAddr *isrAddr)
{
//    UART_isrDispatchTable[UART_EVT_DSSI] = (Uint32) (isrAddr->dssiAddr);
    (CSL_UART_DATA).UART_isrDispatchTable[UART_EVT_TBEI] =
                  (Uint32) (isrAddr->tbeiAddr);
    (CSL_UART_DATA).UART_isrDispatchTable[UART_EVT_RBFI] =
                  (Uint32) (isrAddr->rbfiAddr);
    (CSL_UART_DATA).UART_isrDispatchTable[UART_EVT_LSI] =
                  (Uint32) (isrAddr->lsiAddr);
    (CSL_UART_DATA).UART_isrDispatchTable[UART_EVT_CTOI] =
                  (Uint32) (isrAddr->ctoiAddr);
    (CSL_UART_DATA).UART_isrDispatchTable[UART_EVT_DSSI] =
                  (Uint32) (isrAddr->dssiAddr);

    IRQ_plug(IRQ_EVT_UART, UART_intrDispatch);

}

/* Private function */
//interrupt void UART_intrDispatch(void)
//{
//    Uint16 EventId;
//
//    EventId = (UART_RGET(URIIR) & 0x0E) >> 1; // get IID bits
//
//    ((void (*)(void))((CSL_UART_DATA).UART_isrDispatchTable[EventId]))();
//
//    return;
//
//}
interrupt void UART_intrDispatch(void)
{
  Uint16 lcl_URIIR;
  Uint16 EventId;
// check for valid interrupt
    lcl_URIIR  = UART_RGET(URIIR);
    if ((lcl_URIIR & 0x01) == 1) ; //bit 0 = 1 means no interrupt pending
    { // decipher valid interrupt code and get table offset
    EventId = (lcl_URIIR & 0x0E) >> 1; // get IID bits
    // call indicated interrupt routine
     if (((void (*)(void))((CSL_UART_DATA).UART_isrDispatchTable[EventId]))) // check for valid address
        ((void (*)(void))((CSL_UART_DATA).UART_isrDispatchTable[EventId]))();
  }// endif

return;
}


#endif /* UART_SUPPORT */

ur_setup.c/     1049977305  0     0     0       2253      `
/*****************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... UART_setup.c
* DATE CREATED.. Sun 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\*****************************************************************************/
#define _UART_MOD_

/*----------------------------------------------------------------------------*/
/* INCLUDES                                                                   */
/*----------------------------------------------------------------------------*/
#include <csl.h>
#include <csl_irq.h>

#if (_UART_SUPPORT)
#include <csl_uart.h>

#pragma CODE_SECTION(UART_setup,".text:UART_setup")
/*----------------------------------------------------------------------------*/
/* Function                                                                   */
/*----------------------------------------------------------------------------*/
void UART_setup(UART_Setup *params)
{

    /* Set BSR to disable SP2MODE */
     CHIP_FSET(XBSR, SP2MODE,0) ;

    /* disable all UART events */
    UART_FSET(URLCR,DLAB,0);
    UART_RSET(URIER, UART_NOINT);

    /* reset and possibly enable FIFOs */
    UART_RSET(URFCR, 0x7);
    UART_RSET(URFCR, params->fifoControl); 

    /* set DLL and DLM to values appropriate for the required baudrate */
    UART_setupBaudRate (params->clkInput, params->baud);

    
    /* setup word size, stop bits, parity */
    UART_RSET(URLCR, params->wordLength | params->stopBits | params->parity);

    
    /* setup loopback control */
    UART_RSET(URMCR, params->loopBackEnable);            

    
    /* UART out of reset */
    UART_resetOff();
    
    
    return;
}
#endif /* UART_SUPPORT */

ur_write.c/     1049977307  0     0     0       2374      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... UART
* FILENAME...... uart_write.c
* DATE CREATED.. Sun 01/18/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   01/18/2002   Created 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the UART module)
*
*
*
\******************************************************************************/
#define _UART_MOD_

/****************************************\
* include files
\****************************************/  
#include <csl_irq.h>
#if (_UART_SUPPORT)
#include <csl_uart.h> 

#pragma CODE_SECTION(UART_write,".text:UART_write")
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* UART global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
CSLBool UART_write(char *pBuf, Uint16 length, Uint32 timeout) 
{
    int temp, i;

    UART_FSET(URLCR, DLAB, 0);
  
  if (timeout!=0)
  {
    while( length-- )
    {
        for(i=0; i<=timeout; i++)
        {
            temp=UART_FGET(URLSR,THRE);
            if(temp == 1) break;
        }
        
        if (i>=timeout)
            return FALSE;

        UART_RSET(URTHR, *pBuf++);
    }
  }
  else
  {    
    
    while( length-- )
    {
        /* wait for TX empty */
        while( !UART_FGET(URLSR,THRE) );
        UART_RSET(URTHR, *pBuf++);
    }
  }
  return TRUE;
}
/*----------------------------------------------------------------------------*/

#endif /* UART_SUPPORT */
/******************************************************************************\
* End of uart_write.c
\******************************************************************************/

usb_aball.c/    1049977308  0     0     0       4265      `
/******************************************************************************/
/* Name     : USB_abortAllTransaction                                         */
/*                                                                            */
/* Catagory : Software Control                                                */
/*                                                                            */
/* Purpose  : Terminate all the data transfer in progress and free up the     */
/*            the endpoints to post new data transfer requests                */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum     : USB device number, enumerated data type of USB_DevNum.        */
/*              Only USB0 is active currently                                 */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if successful, else USB_FALSE                                     */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    10 Jan 2001                                                    */
/*                                                                            */
/* Modified:   02/20/01 $MH$                                                  */
/*                                                                            */
/* Renamed from  USB_killAllTransaction( ) to USB_abortAllTransaction( )      */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

extern USB_GlobalVars_struct USB_GlobalVars;

#pragma CODE_SECTION (vUSB_abortAllTransaction, ".text:vUSB_abortAllTransaction")

/*
01/10/01 $MH$
Stop all transactions in progress and reset the endpoint handles
*/

// USB_Boolean USB_abortAllTransaction(USB_DevNum DevNum)
USB_Boolean vUSB_abortAllTransaction(USB_DevNum DevNum)
{
  Uint16                ii;
  USB_EpHandle          hEpx;
  USB_Boolean           ret_stat        = USB_TRUE;
  /* USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)USB_GLOBALVAR_BASE; */

  for(ii = 0; ii < 16; ii++)
  {
      hEpx = (USB_EpHandle )(((Uint32)USB_GlobalVars.EpHandleTable[ii][2]) |
                             (((Uint32)USB_GlobalVars.EpHandleTable[ii][1]) << 8) |
                             (((Uint32)USB_GlobalVars.EpHandleTable[ii][0]) << 16));

      if(hEpx != (USB_EpHandle )0)
      {
        if(!USB_abortTransaction(hEpx))
        ret_stat = USB_FALSE;
      }
    }

  return(ret_stat);
}

#endif


usb_abrttr.c/   1049977309  0     0     0       5265      `
/******************************************************************************/
/* Name     : USB_abortTransaction                                            */
/*                                                                            */
/* Catagory : Data Transfer                                                   */
/*                                                                            */
/* Purpose  : Terminate the data transfer in progress and free up the endpoint*/
/*            to post a new data transfer request                             */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : None                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if successful, else USB_FALSE                                     */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint associated with the data       */
/* transfer in progress                                                       */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/* Modified:   02/20/01 $MH$                                                  */
/*                                                                            */
/* Renamed from  USB_killTransaction( ) to USB_abortTransaction( )            */           
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>


#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_abortTransaction, ".text:vUSB_abortTransaction")

/*
12/21/00 $MH$
Stop transaction if any in progress and update the endpoint handle
so a new transaction can be initiated.

** CHECK WITH JDK - WHAT WILL HAPPEN IF EPO BCNT REG NAK-BIT IS SET
   IN THE MIDDLE OF A TRANSFER  **
   
 - IT MAY BE A GOOD IDEA ONLY STOP DMA TRANSACTION AND NOT MESS WITH 
   END POINT 0 TRANSACTION  
*/

// USB_Boolean USB_abortTransaction(USB_EpHandle hEp)
USB_Boolean vUSB_abortTransaction(USB_EpHandle hEp)
{
  USB_DMA_Context *USB_DMA     = (USB_DMA_Context *)hEp->DMA_SAddr;
  USB_EP0_RegBlk  *USB_EP0Reg  = (USB_EP0_RegBlk *)hEp->EDReg_SAddr;
  Uint16          Endpt        = (Uint16)hEp->EpNum;

// return if the endpoint is servicing host port
if(hEp->XferType == USB_HPORT) return(USB_FALSE);

  // if other than EP0
  if(Endpt % 8)
  {
    /*
    set STP bit of DMA control reg,
    init X/Y buffer Count reg ,
    */
    /*
    USB_EDB->X_EPBCNT  = (Endpt / 8) ? USB_EPBCNT_NAK : 0;
    USB_EDB->Y_EPBCNT  = (Endpt / 8) ? USB_EPBCNT_NAK : 0;
    */
    if((USB_DMA->DCTL && USBDCTL_GO) | (USB_DMA->DCTL && USBDCTL_RLD))
        USB_DMA->DCTL    = USBDCTL_STP;
        
    USB_DMA->DSIZ    = 0;
    USB_DMA->DADL    = 0;
    USB_DMA->DADH    = 0;
    USB_DMA->DCT     = 0;
    USB_DMA->DRSZ    = 0;
    USB_DMA->DRAL    = 0;
    USB_DMA->DRAH    = 0;
  }
  
  else
  {
    /* 
    set NAK bit of EP0 BCNT reg
    clear TotBytCnt field of EP0 handle
    */
    
    USB_EP0Reg->CT = USBEPCT_NAK;
  }
  
  /* 
  clear TotBytCnt field of endpoint handle
  clear Flags field of endpoint handle
  */
  hEp->DataFlags    = 0x00;
  hEp->Status       = 0x00;
  hEp->TotBytCnt    = 0x00;
  hEp->BytInThisSeg = 0x00;
  hEp->pBuffer      = NULL;
  hEp->pNextBuffer  = NULL;
  hEp->EventFlag    = 0x00;

  return(USB_TRUE);
}

#endif

usb_antrfc.c/   1049977311  0     0     0       5785      `
/******************************************************************************/
/* Name     : _USB_addInterface                                               */
/*                                                                            */
/* Catagory : Device Initialization                                           */
/*                                                                            */
/* Purpose  : Include additional endpoint to the existing configuration       */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEpObj[] : Pointer to a NULL terminated array of handles of initialized    */
/*            endpoint objects.  Max number of handles in the array can not   */
/*            be more than 16 (excluding the NULL handle)                     */
/*                                                                            */
/* NumOfEp  : Number of elements in the hEpObj[] array                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if additional endpoints are successfully added to the existing    */
/* device configuration, else USB_FALSE                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Once USB_config is called, to add another interface to the current device  */
/* call _USB_addInterface( ). This routine only initialize the endpoint       */
/* register and set endpoint dma intrpt mask bits, and updates the            */
/* USB_GlobalVars with endpoint related information.  This routine does not   */
/* reconfig EP0 regs                                                          */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    22 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>


#if (_USB_SUPPORT)

extern USB_GlobalVars_struct USB_GlobalVars;

#pragma CODE_SECTION (_vUSB_addInterface, ".text:_vUSB_addInterface")

//USB_Boolean _USB_addInterface(USB_DevNum   DevNum,
//                              USB_EpHandle hEpObj[],
//                              Uint16       NumOfEp)

USB_Boolean _vUSB_addInterface(USB_DevNum   DevNum,
                              USB_EpHandle hEpObj[],
                              Uint16       NumOfEp)
{
  Uint16 ii, EpIndex, BufBaseAddrX, BufBaseAddrY,EpBuffEndAddr;

  /* USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)USB_GLOBALVAR_BASE; */

  /* initialize EDB   */

  for(ii=1; ii<=NumOfEp; ii++)
  {
    EpIndex = (Uint16)(hEpObj[ii-1]->EpNum);
    if(EpIndex % 8)          /* if not EP0 config EP regs      */
    {
     BufBaseAddrX  = (Uint16)((USB_GlobalVars.NextEpBuffStartAddr[0]<<8)|
                              (USB_GlobalVars.NextEpBuffStartAddr[1]&0xFF));
     BufBaseAddrY  = BufBaseAddrX + hEpObj[ii-1]->MaxPktSiz;
     EpBuffEndAddr = BufBaseAddrY + hEpObj[ii-1]->MaxPktSiz;
     if(EpBuffEndAddr <= USB_SRAM_END)         /* if not endpoint buf addr overflow */
       {
          _USB_configEndpt(hEpObj[ii-1], USBEPCNF_INIT, BufBaseAddrX, BufBaseAddrY);
          // start address of next endpoint buffer
          // USB_GlobalVars->NextEpBuffStartAddr = EpBuffEndAddr;
          USB_GlobalVars.NextEpBuffStartAddr[0] = (EpBuffEndAddr>>8) & 0xFF;
          USB_GlobalVars.NextEpBuffStartAddr[1] = EpBuffEndAddr & 0xFF;
       }
     else
          return(USB_FALSE);                   /* if endpoint buf addr overflow */
    }  /* end of if */
    else
    {
      return(USB_FALSE);                   /* if endpoint buf addr overflow */
    }  /* end of if-else */
  }    /* end of for(ii=1; ii<=NumOfEp; ii++) */

  return(USB_TRUE);
}

#endif

usb_byterm.c/   1049977312  0     0     0       4824      `
/******************************************************************************/
/* Name     : USB_bytesRemaining                                              */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : Find out number of bytes waiting to be transferred from the     */
/*            previously posted data transfer request                         */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* Number of bytes remaining to be transferred. Return value is 0xFFFF if     */
/* USB_IOFLAG_EOLL flag used while posting the transfer request       */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint data moves pass through.       */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:        28 Nov 2000                                                */
/* Last Modified:  21 Feb 2001                                                */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_bytesRemaining, ".text:vUSB_bytesRemaining")

/* ----------------------------------------------------------------------------
 Give the number of bytes remained to be transferred in the endpoint buffer.
 11/28/00 $MH$:  Incomplete
 12/05/00 $MH$:  made changes to support linked list in USB_postTransaction( )
 ----------------------------------------------------------------------------*/
// USB_BYTE_COUNT USB_bytesRemaining(USB_EpHandle hEp)
USB_BYTE_COUNT vUSB_bytesRemaining(USB_EpHandle hEp)
{
  USB_DMA_Context *USB_DMA               = (USB_DMA_Context *)hEp->DMA_SAddr;
  Uint16 Endpt                = (Uint16)hEp->EpNum;
  Uint16 BytesInDMA              = 0x00;  
  /*
  12/04/00 $MH$
  USB_EP0_RegBlk *USB_EP0Reg             = (USB_EP0_RegBlk *)hEp->EDReg_SAddr;
  USB_Boolean ret_stat;
  */
#ifdef USE_BIOS
  Uint16 int_status = HWI_disable();
#endif

  if((Endpt % 8) && !(hEp->DataFlags & USB_IOFLAG_EOLL))
  {
    /* -----------------------------------------------------------------------
    For DMA transfers, the number of bytes transferred is indicated by DMA
    transfer count. So, the number of bytes to be transferred would be:

    1. DMA transfer size - DMA transfer count if RLD is not set.
    2. DMA transfer size + DMA reload size - DMA transfer count if RLD is set.
     -----------------------------------------------------------------------*/

    if(USB_DMA->DCTL & USBDCTL_GO)
    {
      BytesInDMA = USB_DMA->DSIZ - USB_DMA->DCT;
      if(USB_DMA->DCTL & USBDCTL_RLD)
      {
        BytesInDMA += USB_DMA->DRSZ;
      }
    }
  }
#ifdef USE_BIOS
  HWI_enable(int_status);
#endif

  return(hEp->TotBytCnt + BytesInDMA);
}
#endif
usb_cfgpt.c/    1049977314  0     0     0       10358     `
/******************************************************************************/
/* Name     : _USB_configEndpt                                                */
/*                                                                            */
/* Catagory : Initialization (private function)                              */
/*                                                                            */
/* Purpose  : Configure an endpoint descriptor block and DMA registers        */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp          : Handle to an endpoint object to be initialized              */
/*                                                                            */
/* EPxConfRegVal: 8-bit value to be written to Endpoint Config regsiter       */
/*                                                                            */
/* BufBaseAddrX : Xbuffer base address in the USB buffer RAM                  */
/*                                                                            */
/* BufBaseAddrY : Xbuffer base address in the USB buffer RAM                  */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the initialization is successful, else USB_FLASE               */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The event handler should be in void Fxn(void) form. Using the INTERRUPT    */
/* is not necessary.  Once the program control branches to Fxn the user's     */
/* code is free to call other functions or event post DSP?BIOS SWI            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:       24 Nov 2000                                                 */
/*                                                                            */
/******************************************************************************/


/* --------------------------11/24/00 $MH$: working --------------------------
 Configure the USB interface. Initialize all the endpoints. For endpoint 0,
 it would be done by configuring the CONF and BYTE COUNT registers. For all
 other endpoints, the Endpoint Descriptor Blocks and DMA Contexts need to be
 initialized.

 02/26/01 $MH$ added host endpt config code
 
 08/26/02 $MH$ fixed ISO endpt size reg configuration (3 msb of 10 bit value)
 08/27/02 $MH$ enable ISO endpt DMA interrupt - bug fix 
 ----------------------------------------------------------------------------*/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

extern USB_GlobalVars_struct USB_GlobalVars;

#pragma CODE_SECTION (_vUSB_configEndpt, ".text:_vUSB_configEndpt")

// USB_Boolean _USB_configEndpt(USB_EpHandle hEp,
//                            Uint16 EPxConfRegVal,
//                            Uint16 BufBaseAddrX,
//                            Uint16 BufBaseAddrY)

USB_Boolean _vUSB_configEndpt(USB_EpHandle hEp,
                            Uint16 EPxConfRegVal,
                            Uint16 BufBaseAddrX,
                            Uint16 BufBaseAddrY)
{

  USB_Boolean           ret_stat        = USB_FALSE;
  Uint16                ii              = (Uint16)hEp->EpNum;
  USB_EDRegBlk          *USB_EDB        = (USB_EDRegBlk *)hEp->EDReg_SAddr;
  /* USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)USB_GLOBALVAR_BASE; */

//#ifdef usb_phase3
  USB_IsoInRegBlk  *USB_EDBISOIN  = (USB_IsoInRegBlk *)hEp->EDReg_SAddr;
  USB_IsoOutRegBlk *USB_EDBISOOUT = (USB_IsoOutRegBlk *)hEp->EDReg_SAddr;
//#endif

  USB_EP0_RegBlk   *USB_EP0Reg    = (USB_EP0_RegBlk *)hEp->EDReg_SAddr;


  if(ii % 8)   /* Initialize Endpoint Descriptor Blocks */
  {
    switch(hEp->XferType)
    {
      case USB_BULK :
      case USB_INTR :
      case USB_HPORT:

           USB_EDB->CNF  = (EPxConfRegVal & 0xBF);  /* make sure ISO-bit = 0 */
           USB_EDB->BAX = (BufBaseAddrX>>4);
    /* -------------------------------------------------
     NAK is set for IN endpoints, but OUT endpoints are
     made ready for data by clearing the NAK bit.
     --------------------------------------------------*/
           USB_EDB->CTX  = (ii / 8) ? USBEPCT_NAK : 0;
     /*      USB_EDB->X_EPBCNT  = USB_EPBCNT_NAK;              */
           USB_EDB->BAY    = (BufBaseAddrY>>4);
           USB_EDB->CTY  = (ii / 8) ? USBEPCT_NAK : 0;
     /*      USB_EDB->Y_EPBCNT  = USB_EPBCNT_NAK;              */
           USB_EDB->SIZ   = (hEp->MaxPktSiz & 0x7F);

           if(hEp->XferType != USB_HPORT)         // if bulk or intr endpt
           {
             //_USB_enableDmaIntrpt(USB0, hEp);    /* enable USB DMA interrupt */
             _USB_EN_DMA_INTR(USB0, hEp->EpNum);
           }
//#ifdef usb_phase3
           else
           {
             if(ii / 8)                            // if in endpt
                USBHEPSEL = ((USBHEPSEL & 0x8F) | (( hEp->EpNum & 0x7) << 4));
             else                                  // if out endpt
                USBHEPSEL = ((USBHEPSEL & 0xF8) | ( hEp->EpNum & 0x7));

             // enable the host intr - intr flag are cleared when USB_REG_VECINT is
             // read in USB_init( ) routine
             if(hEp->EventMask & USB_EVENT_HINT)
                USBHCTL |= USBHCTL_HIE;     // enable host intr

             if(hEp->EventMask & USB_EVENT_HERR)
                USBHCTL |= USBHCTL_HERRIE;    // enable host err intr

             // enable host mode if both host endpts are selected
             if(((USBHEPSEL & 0x70)>>4) && (USBHEPSEL & 0x07))
                USBHCTL |= USBHCTL_EN;
           }
//#endif  // usb_phase3
             ret_stat = USB_TRUE;
           break;

   /* --------------------$MH$---------------------------
     Need code for phase III iso support
     make sure ISO-bit = 1
     ----------------------------------------------------*/
      case USB_ISO:

//#ifdef usb_phase3
           if(ii / 8)                            // ISO IN
           {
             USB_EDBISOIN->CNF = ((EPxConfRegVal & 0xC0)|0x40);   // set ISO-bit
           // $MH$ 08/26/02 USB ISO endpt size bug fix  
           //USB_EDBISOIN->SIZH = ((hEp->MaxPktSiz & 0x0380)>>6); // load upper 3 bits of max pkt siz
             USB_EDBISOIN->SIZH = ((hEp->MaxPktSiz & 0x0380)>>7); // load upper 3 bits of max pkt siz
           }
           else                                  // ISO OUT
           {
             USB_EDBISOOUT->CNF = (((EPxConfRegVal & 0xC0)|0x40)    // set ISO-bit
           // $MH$ 08/26/02 USB ISO endpt size bug fix
           //                     |((hEp->MaxPktSiz & 0x0380)>>6)); // upper 3 bits of max pkt siz
                                  |((hEp->MaxPktSiz & 0x0380)>>7)); // upper 3 bits of max pkt siz

             USB_EDBISOOUT->CTXH &= 0xF8;         // clr high 3 bits of X_BCNT reg
             USB_EDBISOOUT->CTYH &= 0xF8;         // clr upper 3 bits of Y_BCNT reg
           }

           // following registers are same for iso and non-iso mode
           USB_EDB->BAX    = (BufBaseAddrX>>4);
           USB_EDB->BAY    = (BufBaseAddrY>>4);
           USB_EDB->SIZ   = (hEp->MaxPktSiz & 0x7F);
           // set NAK for IN Endpts but clear NAK for OUT Endpts
           // so they are ready to receive data
           USB_EDB->CTX  = (ii / 8) ? USBEPCT_NAK : 0;
           USB_EDB->CTY  = (ii / 8) ? USBEPCT_NAK : 0;
           
           // $MH$ 08/27/02  enable USB DMA interrupt - bug fix
             _USB_EN_DMA_INTR(USB0, hEp->EpNum);
             
//#endif // usb_phase3

           break;

      default:
           break;
    }                                        /* end of switch(EPxType)  */
  }                                          /* end of if(ii % 8)       */
  else                                       /* config control endpoint */
  {
    USB_EP0Reg->CNF  = EPxConfRegVal;
    USB_EP0Reg->CT = USBEPCT_NAK;
    //_USB_enableEpIntrpt(USB0, hEp);            /* enable endpoint intrpt */
    _USB_EN_EP_INTR(USB0, hEp->EpNum);
    ret_stat = USB_TRUE;
  }                                           /* end of else            */

  /*
  register endpoint handle in the endpoint handle table
  */
  USB_GlobalVars.EpHandleTable[ii][2] = (Uint16)((Uint32)hEp & 0xFF);
  USB_GlobalVars.EpHandleTable[ii][1] = (Uint16)(((Uint32)hEp >> 8) & 0xFF);
  USB_GlobalVars.EpHandleTable[ii][0] = (Uint16)(((Uint32)hEp >> 16) & 0xFF);

  // if SOF interrupt selected then set flag
  if(hEp->EventMask & USB_EVENT_SOF)
       USB_GlobalVars.FlagSOF = USB_TRUE;

  return(ret_stat);
}                                  /* end of _USB_configEndpt(..)  */

#endif

usb_clrstal.c/  1049977316  0     0     0       3888      `
/******************************************************************************/
/* Name     : USB_clearEndptStall                                             */
/*                                                                            */
/* Catagory : Device Control                                                  */
/*                                                                            */
/* Purpose  : Clear an endpoint stall                                         */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint to bring out of stall          */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_clearEndptStall, ".text:vUSB_clearEndPtStall")

/* ----------------------------------------------------------------------------
 Clear the STALL on the endpoint. Requests to the endpoint will be handled
 after the call returns.
 11/29/00$MH$: Modified
 12/01/00 $MH$: 
 Replaced by the vUSB_clearEndpointStall(USB_DevNum DevNum,Uint16 EpNum)
 12/18/00 $MH$ reinstated
 ----------------------------------------------------------------------------*/
// void USB_clearEndptStall(USB_EpHandle hEp)
void vUSB_clearEndptStall(USB_EpHandle hEp)
{
  USB_EDRegBlk   *USB_EDB      = (USB_EDRegBlk *)hEp->EDReg_SAddr;
  USB_EP0_RegBlk *USB_EP0Reg   = (USB_EP0_RegBlk *)hEp->EDReg_SAddr;
  Uint16         EpIndex       = (Uint16)hEp->EpNum;

  if(EpIndex % 8)       //clear STALLed Endpoints other than OUT EP0 and IN EP0 
  {
    USB_EDB->CNF &= ~USBEPCNF_STALL;
  }
  else                  // clear STALLed EP0 (IN or OUT)
  {
    USB_EP0Reg->CNF &= ~USBEPCNF_STALL;
  }

  return;
}

#endif

usb_condev.c/   1049977318  0     0     0       3559      `
/******************************************************************************/
/* Name     :  USB_connectDev                                                 */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Connect the USB module to upstream port (D+ pullup enabled)    */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_connectDev, ".text:vUSB_connectDev")

void vUSB_connectDev(DevNum)
{
  USBCTL |= USBCTL_CONN;
}

#endif

usb_ddmain.c/   1049977320  0     0     0       3876      `
/******************************************************************************/
/* Name     : _USB_disableDmaIntrpt                                           */
/*                                                                            */
/* Catagory : Device Initialization (private function)                       */
/*                                                                            */
/* Purpose  : Disable the endpoint DMA interrupt.  Affected endpoint is       */
/*            determined by the endpoint objects passed to the function       */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the endpoint DMA interrupt is successfully disabled,           */
/* else USB_FALSE                                                             */    
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>

#if (_USB_SUPPORT)

#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>


#pragma CODE_SECTION (_vUSB_disableDmaIntrpt, ".text:_vUSB_disableDmaIntrpt")

// USB_Boolean _USB_disableDmaIntrpt(USB_DevNum DevNum, USB_EpHandle hEp)
USB_Boolean _vUSB_disableDmaIntrpt(USB_DevNum DevNum, USB_EpHandle hEp)
{
  Uint16 EpIndex    = (Uint16)hEp->EpNum;
  Uint16 bit_addr;
  
  if(!(EpIndex % 8)) return(USB_FALSE);   /* no DMA intrpt for endpoint0 */
  
  bit_addr = EpIndex & 0x07; /* addr of endpoint intrpt mask bit */
  
  if(EpIndex & 0x08)         /* test for in-endpoints */
  {  
    USBIDIE &= ~(1 << bit_addr);
  }
  else                       /* out-endpoint */
  {  
    USBODIE &= ~(1 << bit_addr);
  }
  return(USB_TRUE);        
}

#endif
usb_discon.c/   1049977321  0     0     0       3638      `
/******************************************************************************/
/* Name     :  vUSB_disconnectDev                                             */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Disconnect the USB module from the upstream port               */
/*             (D+ pullup disabled)                                           */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_disconnectDev, ".text:vUSB_disconnectDev")

void vUSB_disconnectDev(USB_DevNum DevNum)
{
  USBCTL &= ~USBCTL_CONN;
}

#endif

usb_disint.c/   1049977323  0     0     0       3703      `
/******************************************************************************/
/* Name     : _USB_disableEpIntrpt                                            */
/*                                                                            */
/* Catagory : Device Initialization (private function)                       */
/*                                                                            */
/* Purpose  : Disable the endpoint interrupt. Affected endpoint is determined */
/*            by the endpoint objects passed to the function                  */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the endpoint interrupt is successfully disabled,else USB_FALSE */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (_vUSB_disableEpIntrpt, ".text:_vUSB_disableEpIntrpt")

// USB_Boolean _USB_disableEpIntrpt(USB_DevNum DevNum, USB_EpHandle hEp)
USB_Boolean _vUSB_disableEpIntrpt(USB_DevNum DevNum, USB_EpHandle hEp)
{
  Uint16 EpIndex    = (Uint16)hEp->EpNum;
  Uint16 bit_addr;
  
  bit_addr = EpIndex & 0x07; /* addr of endpoint intrpt mask bit */
  
  if(EpIndex & 0x08)         /* test for in-endpoints */
  {  
    USBIEPIE &= ~(1 << bit_addr);
  }
  else                       /* out-endpoint */
  {  
    USBOEPIE &= ~(1 << bit_addr);
  }
  return(USB_TRUE);        
}
#endif


usb_drvr.c/     1049977325  0     0     0       36896     `
/******************************************************************************/
/* usb_drvr.c                                                                 */
/*                                                                            */
/* This is proprietary information, not to be published -- TI INTERNAL DATA   */
/* Copyright (C) 1999, Texas Instruments, Inc.  All Rights Reserved.          */
/*                                                                            */
/* USB event dispatcher and generic endpoint data handler routines.           */
/*                                                                            */
/* Author: MH                                                                 */
/* Date: 24 Nov 2000                                                          */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*    Modified:                                                               */
/*    11/30/00 $MH$                                                           */
/*    02/20/01 $MH$                                                           */
/*    Added following linked list handling features to the Control and DMA    */
/*    endpoint drivers.                                                       */
/*    Data Buffer Supported:  a. Single buffer                                */
/*                            b. Multiple buffer in the form of linked list   */
/*                                                                            */
/*    End of transfer at:     a. TotBytCnt = 0 (with/without a short packet   */
/*                            b. End of linked list(         "             )  */
/*                            c. Either of the above two condition happens    */
/*                               first                                        */
/*                                                                            */
/*    Linked list handling:   a. Treat every linked list as a single data     */
/*                               buffer.                                      */
/*                            b. Concatenate all the linked list to create    */
/*                               a large data buffer                          */
/*                                                                            */
/* 03/05/01 $MH$ Added code to keep track of actual number of bytes xferred   */
/* specially for OUT xfers terminated short.  DMA keeps track of actual number*/
/* of bytes moved in from a OUT transfer, for the rest of the endpoints       */
/* software will update the 1st word of a buffer with the actual number bytes */
/* moved in(out) of the data buffer                                           */
/*                                                                            */
/* 03 May 2001 $MH$                                                           */
/* Added #pragma directive to allocate code in ".usb_drvr" section instead of */
/* default .text section                                                      */
/*                                                                            */
/* 28 Sep 2001 $MH$                                                           */
/* Converted INTERRUPT _vUSB_isr() to void vUSB_evDispatch(void), so the      */
/* module can be used with DSP/BIOS                                           */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <_csl.h>

#if (_USB_SUPPORT)

#include <csl_usb.h>
#include <_csl_usb.h>
#include <csl_usbhal.h>
#include <_csl_usbdrvr.h>



#pragma CODE_SECTION (_vUSB_procCtrlOutTransaction, ".text:usb_drvr")

// void _USB_procCtrlOutTransaction(USB_EpHandle hOutEp0)
void _vUSB_procCtrlOutTransaction(USB_EpHandle hOutEp0)
{
  Uint16 ii, bytes_in;
  USB_EP0_RegBlk *USB_EP0Reg  = (USB_EP0_RegBlk *)hOutEp0->EDReg_SAddr;
  ioport Uchar   *ptr         = (ioport Uchar *)hOutEp0->DMA_SAddr;

  /* -----------------12/13/99 1:34AM------------------
  if ready receive data
   --------------------------------------------------*/
  if((hOutEp0->DataFlags & USB_IOFLAG_DATAREQ) && (USB_EP0Reg->CT & USBEPCT_NAK))
  {
    bytes_in = USB_EP0Reg->CT & ~USBEPCT_NAK;

    if(hOutEp0->DataFlags & USB_IOFLAG_0BYTREQ)
    {

      if(bytes_in < hOutEp0->MaxPktSiz)
      {
         hOutEp0->DataFlags &= ~USB_IOFLAG_0BYTREQ;

        if((hOutEp0->TotBytCnt == 0)||((hOutEp0->BytInThisSeg == 0) &&
                                      (hOutEp0->pNextBuffer == NULL)))
          {
            hOutEp0->DataFlags &= ~USB_IOFLAG_DATAREQ;
            hOutEp0->EventFlag |= USB_EVENT_EOT;
          }
      }

    }

    else
    { // 03/06/01 $MH$ added this if statement to terminate transfer if data
      // block terminated unexpectedly with a short packet in CAT mode
      if((bytes_in < hOutEp0->MaxPktSiz)&&(hOutEp0->DataFlags & USB_IOFLAG_CAT))
      {
        hOutEp0->DataFlags &= ~USB_IOFLAG_DATAREQ;
        hOutEp0->EventFlag |= USB_EVENT_EOT;
      }

      for(ii=0; ii<= bytes_in; ii++, ptr++)
      {
        if((hOutEp0->TotBytCnt == 0) || ((hOutEp0->pNextBuffer == NULL) && (hOutEp0->BytInThisSeg == 0)))
        {
          if((ii == hOutEp0->MaxPktSiz) && !(hOutEp0->DataFlags & USB_IOFLAG_NOSHORT))
            {
              hOutEp0->DataFlags |= USB_IOFLAG_0BYTREQ;
            }
          else
            {
              hOutEp0->DataFlags &= ~USB_IOFLAG_DATAREQ;
              hOutEp0->EventFlag |= USB_EVENT_EOT;
            }
          break;
        }
        else if(hOutEp0->BytInThisSeg == 0)
        {
          if(ii == hOutEp0->MaxPktSiz)
          {
            if(!(hOutEp0->DataFlags & USB_IOFLAG_NOSHORT) && !(hOutEp0->DataFlags & USB_IOFLAG_CAT))
              {
                hOutEp0->DataFlags |= USB_IOFLAG_0BYTREQ;
              }
          }
          _USB_gotoNextList(hOutEp0);

          if(!(hOutEp0->DataFlags & USB_IOFLAG_CAT))
              break;
        }
        else if(ii == bytes_in)
             {
               if((bytes_in < hOutEp0->MaxPktSiz) && !(hOutEp0->DataFlags & USB_IOFLAG_CAT))
                 {
                   if(hOutEp0->pNextBuffer == NULL)
                   {
                     hOutEp0->DataFlags &= ~USB_IOFLAG_DATAREQ;
                     hOutEp0->EventFlag |= USB_EVENT_EOT;
                   }
                   else
                     _USB_gotoNextList(hOutEp0);
                 }
               break;
             }

           if(hOutEp0->pBuffer != NULL)
           {

             if(hOutEp0->DataFlags & USB_IOFLAG_BYTE)        /* USB second byte                      */
               {
                 if(hOutEp0->DataFlags & USB_IOFLAG_SWAP)
                    *(hOutEp0->pBuffer) |= (*ptr)&0x00FF;       /* lo byte - swap                       */
                 else
                    *(hOutEp0->pBuffer) |= (*ptr)<<8;           /* hi byte - no swap                    */

                 hOutEp0->pBuffer++;
                 hOutEp0->DataFlags &= ~USB_IOFLAG_BYTE;     /* flag next byte as USB first byte     */
               }
             else                                                 /* USB first byte                       */
               {
                 if(hOutEp0->DataFlags & USB_IOFLAG_SWAP)
                    *(hOutEp0->pBuffer) = ((*ptr)<<8);          /* hi byte - swap                       */
                 else
                    *(hOutEp0->pBuffer) = (*ptr)&0x00FF;        /* lo byte - no swap                    */

                 hOutEp0->DataFlags |= USB_IOFLAG_BYTE;      /* flag next byte as USB second byte    */
               }

             }                                    // if(hOutEp0->pBuffer != NULL)

           /* -----------------11/30/00 $MH$------------------
             if BytInThisSeg = 0 then call link list handle routine
             instead of calling the routine and let it test BytInThisSeg
             counter
           --------------------------------------------------*/
           hOutEp0->BytInThisSeg--;         // decrement # bytes remained to transfer

           if(!(hOutEp0->DataFlags & USB_IOFLAG_EOLL))
                hOutEp0->TotBytCnt--;

           // 03/13/01 $MH$ moved the following instructions inside the if(hOutEp0->pBuffer != NULL)
           // above
           if(hOutEp0->XferBytCnt != NULL)
           (*hOutEp0->XferBytCnt)++;          // increment # bytes actually transfer

      }  /*for(ii=0; ii<= bytes_in; ii++, ptr++) */
    }    /* else  */


  } /* if(ready to receive data) */


 /* 01/08/01 $MH$: if New transaction yet clear EP0 OUT BCNT reg and NAK bit       to start data receiving */

  if(hOutEp0->DataFlags & USB_IOFLAG_NEW)
    {
       hOutEp0->DataFlags &= ~USB_IOFLAG_NEW;
       hOutEp0->DataFlags |= USB_IOFLAG_DATAREQ;
       if(hOutEp0->TotBytCnt == 0)
          hOutEp0->DataFlags |= USB_IOFLAG_DATAREQ;
    }

  if(hOutEp0->DataFlags & USB_IOFLAG_DATAREQ)
    {
       USB_EP0Reg->CT  = 0x00;
    }
}



/* -----------------11/30/00 $MH$  ----------------
Replaced USB_in_out_struct with USB_EpHandle
 --------------------------------------------------*/

#pragma CODE_SECTION (_vUSB_procCtrlInTransaction, ".text:usb_drvr")

//void _USB_procCtrlInTransaction(USB_EpHandle hInEp0)
void _vUSB_procCtrlInTransaction(USB_EpHandle hInEp0)
{
  int ii;
  USB_EP0_RegBlk *USB_EP0Reg = (USB_EP0_RegBlk *)hInEp0->EDReg_SAddr;

  /* ----------------11/30/00 $MH$------------------------
     since there is no DMA for EP0, use hOutEp0->DMA_SAddr
     to hold EP0 data buffer start addr
  -------------------------------------------------------*/
  ioport Uint16 *ptr = (ioport Uint16 *)hInEp0->DMA_SAddr;

  if(hInEp0->DataFlags & USB_IOFLAG_NEW)
  {
     hInEp0->DataFlags &= ~USB_IOFLAG_NEW;
     hInEp0->DataFlags |=  USB_IOFLAG_DATAREQ;
     if(hInEp0->TotBytCnt == 0)
        hInEp0->DataFlags |=  USB_IOFLAG_0BYTREQ;
  }

  /* -----------------12/9/99 3:16PM-------------------
  Transmit any data, if available
   --------------------------------------------------*/
  if((hInEp0->DataFlags & USB_IOFLAG_DATAREQ) && (USB_EP0Reg->CT & USBEPCT_NAK))
  {
    if(hInEp0->DataFlags & USB_IOFLAG_0BYTREQ)
    {
      ii = 0;
      hInEp0->DataFlags &= ~USB_IOFLAG_0BYTREQ;

      if((hInEp0->TotBytCnt == 0) || ((hInEp0->BytInThisSeg == 0) &&
                                      (hInEp0->pNextBuffer == NULL)))
      {
        hInEp0->DataFlags &= ~USB_IOFLAG_DATAREQ;
      }

    }
    else
    {
      for(ii=0; ii <= hInEp0->MaxPktSiz; ii++, ptr++)
      {

        if((hInEp0->TotBytCnt == 0) || ((hInEp0->pNextBuffer == NULL) && (hInEp0->BytInThisSeg == 0)))
        {
          if((ii == hInEp0->MaxPktSiz) && !(hInEp0->DataFlags & USB_IOFLAG_NOSHORT))
            {
              hInEp0->DataFlags |= USB_IOFLAG_0BYTREQ;
              //break;
            }
          else
            {
              hInEp0->DataFlags &= ~USB_IOFLAG_DATAREQ;
              //break;
            }
          break;
        }
        else if(hInEp0->BytInThisSeg == 0)
        {
          if(ii == hInEp0->MaxPktSiz)
          {
            if(!(hInEp0->DataFlags & USB_IOFLAG_NOSHORT) && !(hInEp0->DataFlags & USB_IOFLAG_CAT))
              {
                hInEp0->DataFlags |= USB_IOFLAG_0BYTREQ;
                //break;
              }
            //break;
          }
          _USB_gotoNextList(hInEp0);
                                                      // 03/26/01 $MH$ - bug fix
          if(!(hInEp0->DataFlags & USB_IOFLAG_CAT) || (ii == hInEp0->MaxPktSiz))
              break;
        }
        else if(ii == hInEp0->MaxPktSiz)
                break;


        if(hInEp0->DataFlags & USB_IOFLAG_BYTE)    /* USB second byte - MSB */
        {
           if (hInEp0->DataFlags & USB_IOFLAG_SWAP)
             *ptr = (*(hInEp0->pBuffer))&0x00FF;
           else
             *ptr = (*(hInEp0->pBuffer))>>8;       /* hi byte - no swap */

           hInEp0->pBuffer++;
           hInEp0->DataFlags &= ~USB_IOFLAG_BYTE;
        }
        else      /* USB first byte - LSB */
        {
           if (hInEp0->DataFlags & USB_IOFLAG_SWAP)
             *ptr = (*(hInEp0->pBuffer))>>8;       /* hi byte - swap */
           else
             *ptr = (*(hInEp0->pBuffer))&0x00FF;    /* lo byte - no swap */

           hInEp0->DataFlags |= USB_IOFLAG_BYTE;
        }

        /* -----------------11/30/00 $MH$------------------
        if BytInThisSeg = 0 then call link list handle routine
        instead of calling the routine and let it test BytInThisSeg
        counter
        --------------------------------------------------*/
        hInEp0->BytInThisSeg--;          // decrement # bytes remained to transfer

        if(!(hInEp0->DataFlags & USB_IOFLAG_EOLL))
           hInEp0->TotBytCnt--;

        if(hInEp0->XferBytCnt != NULL)      // 03/13/01 $MH$ to handle 0 byte ACK
           (*hInEp0->XferBytCnt)++;      // increment # bytes actually transfer



      }        /* for   */

    }          /* else */


    /* -----------------10/27/2000 3:24AM----------------
    Write the byte count to be transmitted.
     --------------------------------------------------*/
    USB_EP0Reg->CT = ii;

#ifdef DEBUG
    LOG_printf(&LOG_debug,"USB_proc_in: wrote %d bytes, %d bytes left\n",
      ii,USB_bytesRemaining(hInEp0));
#endif
  }   /* if xmit data is available */
}

/*
12/05/00 $MH$
function to process DMA endpoint transactions
needs work
*/

//*******************   03/08/01 $MH$ LIMITATIONS  ********************
//
//  This limitation apply only for Out Endpoints if and only if the
//  the data buffer is a linked list and USB_IOFLAG_CAT is set.  In
//  such condition if the host prematurely terminates the data transfer
//  (with or without a short packet) the driver fills up the data buffer
//  of the current node of the linked list and then waits for more data
//  from host to fill up the data buffers of the rest of the linked list.
//  This means the posted transation is still in progress and a call to
//  the routine USB_isTransactionDone(..) will return USB_FALSE.
//  If the current node happen to be the very last node of the linked
//  list the driver will treat this as a termination of transfer and
//  a call to the routine USB_isTransactionDone(..) will return USB_TRUE
//
//  Since the driver programs the DMA GO and RLD registers at the same time
//  (whenever possible) in order to move data more efficiently, if is beyond
//  the scope of the driver to anticipate an early termination of data
//  transfer and not program the DMA RLD registers
//
//  WORK AROUND:  If you have doubt that the host may prematurely termainate
//  the transfer then do not use the USB_IOFLAG_CAT flag with a linked list
//  for OUT transfers.
//
//  Affected Endpoints:  OUT[1..7]
//
//  THIS DOES NOT EFFECT ENDPOINT 0 IN/OUT TRANSFERS,  since endpoint0
//  trnasfer are not done by the USB dedicated DMA
//
//***********************************************************************

#pragma CODE_SECTION (_vUSB_procDmaTransaction, ".text:usb_drvr")

// USB_Boolean _USB_procDmaTransaction(USB_EpHandle hEp)

USB_Boolean _vUSB_procDmaTransaction(USB_EpHandle hEp)
{
  USB_DMA_Context *USB_DMA   = (USB_DMA_Context *)hEp->DMA_SAddr;
  Uint16 dma_ctrl_mask       = 0x00;
  Uint16 bytes_to_move = 0x00;


  /* -------------------------------------------------
  Following code is for DMA-enabled endpoints.
  --------------------------------------------------*/

    /* Is the byte order Big Endian? */
  if(hEp->DataFlags & USB_IOFLAG_SWAP) dma_ctrl_mask |= USBDCTL_END;

  /* Check to see if CAT must be set */
  if(hEp->DataFlags & USB_IOFLAG_CAT) dma_ctrl_mask |= USBDCTL_CAT;

  /* Check to see if SHT must be set */
  if(!(hEp->DataFlags & USB_IOFLAG_NOSHORT)) dma_ctrl_mask |= USBDCTL_SHT;

  switch(hEp->XferType)
  {
  /* -------------------------------------------------
      process bulk or interrupt transaction
  --------------------------------------------------*/
   case USB_BULK:
   case USB_INTR:
   case USB_ISO:
   {
        /* if both DMA GO and RLD bits are set then return false */
        if((USB_DMA->DCTL & USBDCTL_GO) && (USB_DMA->DCTL & USBDCTL_RLD))
            return(USB_FALSE);

        /* if DMA is free and a transaction is waiting */
        if(!(USB_DMA->DCTL & USBDCTL_GO) && (hEp->DataFlags & USB_IOFLAG_DATAREQ))
        {
          /* if buffer sent in incorrect format */
          // if(hEp->TotBytCnt < hEp->BytInThisSeg) return(USB_FALSE);

          /* Start a new DMA transfer */
          USB_DMA->DCT = 0;           /* shouldn't setting the GO bit clears the counter */
          /* how does Bytes work if it is not the 1st transaction of a xfer */
              /* ?? */

          /* convert word addr to byte addr and then load DMA regs */
          USB_DMA->DADL  = (((unsigned long)hEp->pBuffer) << 1) & 0xFFFF;
          USB_DMA->DADH  = (((unsigned long)hEp->pBuffer) >> 15) & 0xFFFF;
          /* USB_DMA->DMACTL = 0; - ?? */

          /* Set the GO bit to initiate DMA - may get interrupt by the time
             program sets the RLD, so it is better to GO and RLD at the same
             time
          USB_DMA->DMACTL = dma_ctrl_mask | USB_DMACTL_GO;
          */
          dma_ctrl_mask |= USBDCTL_GO;
          /* Check to see if GO was successful */
          /*if(!(USB_DMA->DMACTL & USB_DMACTL_GO)) return(USB_FALSE);*/

          if(hEp->DataFlags & USB_IOFLAG_EOLL)
            {
              bytes_to_move = hEp->BytInThisSeg;
            }
          else
            {
              bytes_to_move = (hEp->TotBytCnt < hEp->BytInThisSeg) ?
                               hEp->TotBytCnt : hEp->BytInThisSeg;
              hEp->TotBytCnt -= bytes_to_move;
            }

          USB_DMA->DSIZ = bytes_to_move;

          if(hEp->EpNum / 8)                     // if IN Endpt
             *hEp->XferBytCnt = bytes_to_move;   // increment # bytes actually transfer

          /* process linked list */

          // 02/14/01 $MH$ - replaced
          //if(hEp->DataFlags & USB_IOFLAG_LNK)
          //{
          //   if(hEp->TotBytCnt > 0)
          //      _USB_gotoNextList(hEp);
          //   else
          //      dma_ctrl_mask &= ~USB_DMACTL_CAT;
          //}

          // 02/15/01 $MH$ - replaced
          //if((hEp->pNextBuffer != NULL) && (hEp->TotBytCnt > 0))
          //   _USB_gotoNextList(hEp);
          //else
          //    dma_ctrl_mask &= ~USB_DMACTL_CAT;
          //
          if((hEp->pNextBuffer == NULL) || (hEp->TotBytCnt <= 0))
            {
              hEp->DataFlags &= ~USB_IOFLAG_DATAREQ;   /* flag EOT          */
              dma_ctrl_mask &= ~USBDCTL_CAT;             /* clear CAT if set  */
            }
          else
              _USB_gotoNextList(hEp);                       /* goto next link    */

        }


        /* How about DMA reload -  is it available, specially when hEp->TotBytCnt > 0  */
        if(!(USB_DMA->DCTL & USBDCTL_RLD) && (hEp->DataFlags & USB_IOFLAG_DATAREQ))
        {
          /* if buffer sent in incorrect format */
          // if(hEp->TotBytCnt < hEp->BytInThisSeg) return(USB_FALSE);
          /* check if link list and number of links are even then skip reload
             and clear the USB_IOFLAG_LNK from hEp->DataFlags so the _USB_evDispatch()will
             call this function agian to program the DMA without setting the CAT bit
          */
          if(((hEp->TotBytCnt <= hEp->BytInThisSeg) ||(hEp->pNextBuffer == NULL))
            && (hEp->DataFlags & USB_IOFLAG_CAT))
          {
             hEp->DataFlags &= ~USB_IOFLAG_CAT;
          }
          else
          {


             /* convert word addr to byte addr and then load DMA regs */
             USB_DMA->DRAL = (((unsigned long)hEp->pBuffer) << 1) & 0xFFFF;
             USB_DMA->DRAH = (((unsigned long)hEp->pBuffer) >> 15) & 0xFFFF;

             /* Enable the next transfer
             USB_DMA->DMACTL = (dma_ctrl_mask | USB_DMACTL_RLD);
             */
             dma_ctrl_mask |= USBDCTL_RLD;
             /* Check to see if RLD was successful */
             /* if(!(USB_DMA->DMACTL & USB_DMACTL_RLD)) */

             /* Reload failed. Increment the reload fail counter. */
             /* -----------------10/24/2000 6:01PM----------------
             The compiler doesn't like this.  Do we really need a
             reload fail counter?  I do see how it could be useful...
                            -- JDK
             USB_GlobalVars->ReloadCount[Endpoint]++;
             --------------------------------------------------*/
             /*  return(USB_FALSE);                             */

             if(hEp->DataFlags & USB_IOFLAG_EOLL)
               {
                 bytes_to_move = hEp->BytInThisSeg;
               }
             else
               {
                 bytes_to_move = (hEp->TotBytCnt < hEp->BytInThisSeg) ?
                                  hEp->TotBytCnt : hEp->BytInThisSeg;
                 hEp->TotBytCnt -= bytes_to_move;
               }

             /* Setup Reload transfer       */
             USB_DMA->DRSZ = bytes_to_move;

             if(hEp->EpNum / 8)                      // if IN Endpt
                *hEp->XferBytCnt = bytes_to_move;    // increment # bytes actually transfer

             /* process linked list */

             // 02/14/01 $MH$ - replaced
             // if((hEp->DataFlags & USB_IOFLAG_LNK) && (hEp->TotBytCnt > 0))

             // 02/14/01 $MH$ - replaced
             //if((hEp->pNextBuffer != NULL) && (hEp->TotBytCnt > 0))
             //    _USB_gotoNextList(hEp);

             if((hEp->pNextBuffer == NULL) || (hEp->TotBytCnt <= 0))
                hEp->DataFlags &= ~USB_IOFLAG_DATAREQ;          /* flag EOT          */
             else
                _USB_gotoNextList(hEp);                              /* goto next link    */
          }
        }

        USB_DMA->DCTL = dma_ctrl_mask;
        return(USB_TRUE);

   } /* case INTR  */

//   case USB_ISO:
//           return(USB_FALSE);

   default:            /* error if other xfer req */
           return(USB_FALSE);
 } /* end of switch(hEp->XferType)  */
}




#pragma CODE_SECTION (_vUSB_gotoNextList, ".text:usb_drvr")

// void _USB_gotoNextList(USB_EpHandle hEp)
void _vUSB_gotoNextList(USB_EpHandle hEp)
{
 /* -----------------11/30/00 $MH$--------------------------------------
  following two instructins are moved in the caller function
  hEp->BytInThisSeg--;
  if(hEp->BytInThisSeg == 0)
  {
  --------------------------------------------------*/
// 02/14/01 $MH$
//    if(hEp->pNextBuffer != NULL)
//    {
      hEp->BytInThisSeg = hEp->pNextBuffer->Bytes;
      hEp->pBuffer = hEp->pNextBuffer->pBuffer;
      hEp->pNextBuffer = hEp->pNextBuffer->pNextBuffer;

      hEp->XferBytCnt = hEp->pBuffer;
      *hEp->XferBytCnt = 0x0000;            // clear XferBytCnt field

      // if not OUT DMA endpoint advance the buffer pointer to the begining
      // of the actual data buffer
      if((hEp->EpNum == 0) || (hEp->EpNum == 8) || (hEp->EpNum / 8))
          hEp->pBuffer++;

      if(hEp->DataFlags & USB_IOFLAG_SWAP)
      {
        hEp->DataFlags |= USB_IOFLAG_BYTE;
      }
      else
      {
        hEp->DataFlags &= ~USB_IOFLAG_BYTE;
      }
//    }
}

/******************************************************************************/
/*  _USB_isr.c                                                                */
/*                                                                            */
/*  Renamed:   vUSB_evDispatch                                                */
/*                                                                            */
/*  This is the USB task dispatcher. It sets the events based on the eventss  */
/*  and calls the respective event handler routine pointed by the approprite  */
/*  endpoint object.  The event handler routines are supplied to the endpoint */
/*  object during the endpoint object initialization phase                    */
/*                                                                            */
/* Author: MH                                                                 */
/* Date: 24 Nov 2000                                                          */
/* Based on : Venkat Raghavan (TI India)                                      */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*    Modified: 10 Jan 01 $MH$                                                */
/*                                                                            */
/*    Replaced USB_in_out_structs with USB_EpHandles.  Use USB_DevNum if      */
/*    multiple USB module is supported in the future.                         */
/*                                                                            */
/*    Last modified: 02 Apr 01 $MH$                                           */
/*                                                                            */
/*    Moved _USB_isr( ) from usb_disptch.c to put all the USB driver code in  */
/*    single file                                                             */
/*                                                                            */
/* 28 Sep 2001 $MH$                                                           */
/*                                                                            */
/* Converted INTERRUPT _vUSB_isr() to void _vUSB_evDispatch(void), so the     */
/* module can be used with DSP/BIOS                                           */
/*                                                                            */
/******************************************************************************/

#define USBCTL_ACTIVE (USBCTL_CONN | USBCTL_FEN | USBCTL_FRSTE)

/*
12/13/00 $MH$:  replaced
extern USB_GlobalVars_struct USB_GlobalVars;
with USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)((unsigned long)USB_SRAM_END);
*/

extern USB_GlobalVars_struct USB_GlobalVars;

// extern USB_GlobalVars_struct *USB_GlobalVars;

// #pragma CODE_SECTION (_vUSB_isr, ".text:usb_drvr")
// interrupt void _USB_isr()
// interrupt void _vUSB_isr()

#pragma CODE_SECTION (vUSB_evDispatch, ".text:usb_drvr")

void vUSB_evDispatch(void)
{
  // Uchar jj;
  Uint16 ii;
  Uint16 Vector, EpIndex;
  Uint16 usb_bus_events = 0;
  /*12/01/00 $MH$:
  Replaced USB_in_out_structs with USB_EpHandles
  USB_INOUT_STRUCT *USB_in, *USB_out;
  */
  USB_EpHandle hEpx, hEp0In, hEp0Out;
  USB_EP0_RegBlk *USB_EP0InReg, *USB_EP0OutReg;

  /* SETUP packet can be found at 0x6700 in Amadeus */
  ioport Uint16 *USB_SetupPkt = (ioport Uint16 *)USBSUP_BUF;
  /* USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)USB_GLOBALVAR_BASE; */

  hEp0In  = (USB_EpHandle )(((unsigned long)USB_GlobalVars.EpHandleTable[8][2]) |
                            (((unsigned long)USB_GlobalVars.EpHandleTable[8][1]) << 8) |
                            (((unsigned long)USB_GlobalVars.EpHandleTable[8][0]) << 16));

  hEp0Out = (USB_EpHandle )(((unsigned long)USB_GlobalVars.EpHandleTable[0][2]) |
                            (((unsigned long)USB_GlobalVars.EpHandleTable[0][1]) << 8) |
                            (((unsigned long)USB_GlobalVars.EpHandleTable[0][0]) << 16));

  USB_EP0InReg  = (USB_EP0_RegBlk *)hEp0In->EDReg_SAddr;
  USB_EP0OutReg = (USB_EP0_RegBlk *)hEp0Out->EDReg_SAddr;


  /* Read the vector to be serviced next */
  Vector = USBINTSRC;

  /* init hEp with EP0 OUT handle */




  /* -----------------10/27/2000 0:38AM----------------
  Record the event in the EventTable.
   --------------------------------------------------*/
  if((Vector >= USBINTSRC_ODMARLD1) && (Vector <= USBINTSRC_IDMAGO7))
  {
    EpIndex = (Vector - USBINTSRC_DMA_START) >> 1;

    hEpx = (USB_EpHandle )(((unsigned long)USB_GlobalVars.EpHandleTable[EpIndex][2]) |
                           (((unsigned long)USB_GlobalVars.EpHandleTable[EpIndex][1]) << 8) |
                           (((unsigned long)USB_GlobalVars.EpHandleTable[EpIndex][0]) << 16));

    /*
    12/24/00 $MH$
    change proc_in proc_out and proc_DMA to set USB_EVENT_EOT
    before exiting the routines - else the following code won't work
    */

    if(!USB_isTransactionDone(hEpx))
        _USB_procDmaTransaction(hEpx);

    else    /* transaction done so call the event isr */
    {
      hEpx->EventFlag |= USB_EVENT_EOT;
      if((hEpx->EventMask & USB_EVENT_EOT) && (hEpx->Fxn != (USB_EVENT_ISR)0))
         hEpx->Fxn();
    }
  }

  else
  {
    switch(Vector)
    {
      case USBINTSRC_IEP0:
      {
        /*
        01/09/01 $MH$: call USB_proc_in again if the transaction is not done or a 0-byte
                       short packet is necessary to end the transfer,  if USB_isTransactionDone(hEp0In)
                       returns TRUE and USB_IOFLAG_NEW means 0-byte short packet required.
                       USB_IOFLAG_NEW can be replaced with USB_IOFLAG_DATAREQ to make
                       the code more sensible to the reader.
        */
        //if((!USB_isTransactionDone(hEp0In)) || (hEp0In->DataFlags & (USB_IOFLAG_DATAREQ | USB_IOFLAG_NEW)))
        //if((!USB_isTransactionDone(hEp0In)) || (hEp0In->DataFlags & USB_IOFLAG_DATAREQ))
        if(hEp0In->DataFlags & USB_IOFLAG_DATAREQ)
           _USB_procCtrlInTransaction(hEp0In);

        else
        {
          hEp0In->EventFlag |= USB_EVENT_EOT;

          /*
          01/10/01 $MH$:
          if EP0 OUT transfer pending then start the transfer - this code is necessary to
          by pass the USB module restrictions:- clearing both EP0 IN and OUT NAK at the same
          causes the module to fail data transfer
          */
          //if(USB_isTransactionDone(hEp0Out)) _USB_procCtrlOutTransaction(hEp0Out);

          if(hEp0Out->DataFlags & (USB_IOFLAG_DATAREQ | USB_IOFLAG_NEW))
          _USB_procCtrlOutTransaction(hEp0Out);

          /*
          01/10/01 $MH$:
          if EventMask is set call function associated with USB_EVENT_EOT
          */
          if((hEp0In->EventMask & USB_EVENT_EOT) && (hEp0In->Fxn != (USB_EVENT_ISR)0))
             hEp0In->Fxn();
        }

        break;
      }

      /*
      12/12/00 $MH$:
      if one of the following events took place no need for retrieving
      EP0 handle since hEp has already been initialized with EP0 OUT
      handle at the beginning of this ISR
      */
      /*
      12/24/00 $MH$
      change proc_out to set USB_EVENT_EOT
      before exiting the routines - else the following code won't work
      */
      case USBINTSRC_OEP0:
      {
        if(hEp0Out->DataFlags & USB_IOFLAG_DATAREQ)
           _USB_procCtrlOutTransaction(hEp0Out);

        if(hEp0Out->EventFlag & USB_EVENT_EOT)
        {
          /*
          01/10/01 $MH$:
          if EP0 IN transfer pending then start the transfer - this code is necessary to
          by pass the USB module restrictions:- clearing both EP0 IN and OUT NAK at the same
          causes the module to fail data transfer
          */
          //if((!USB_isTransactionDone(hEp0In)) || (hEp0In->DataFlags & (USB_IOFLAG_DATAREQ | USB_IOFLAG_NEW)))
          if(hEp0In->DataFlags & (USB_IOFLAG_DATAREQ | USB_IOFLAG_NEW))
             _USB_procCtrlInTransaction(hEp0In);

          /*
          01/10/01 $MH$:
          if EventMask is set call function associated with USB_EVENT_EOT
          */
          if((hEp0Out->EventMask & USB_EVENT_EOT) && (hEp0Out->Fxn != (USB_EVENT_ISR)0))
             hEp0Out->Fxn();
        }

        break;
      }

      case USBINTSRC_RSTR:
      {
        usb_bus_events = USB_EVENT_RESET;
        break;
      }

      case USBINTSRC_SUSR:
      {
        usb_bus_events = USB_EVENT_SUSPEND;
        break;
      }

      case USBINTSRC_RESR:
      {
        usb_bus_events = USB_EVENT_RESUME;
        break;
      }

      case USBINTSRC_SETUP:
      case USBINTSRC_STPOW:
      {
        /* -----------------10/27/2000 1:57AM----------------
        Do we need not to call the SETUP handler if STPOW is
         set and we got a SETUP (not STPOW) event?  Having
         STPOW set would mean that we'll get here again.
          -- JDK
         --------------------------------------------------*/

        /*
        01/05/01 $MH$:  prepare endpoint0 in and out for handling setup packet
        both endpoint NAK bits have to set for handling early hand shake
        */
        usb_bus_events = USB_EVENT_SETUP;
        USBCTL = USBCTL_ACTIVE | USBCTL_SETUP;

        /*
        01/08/01 $MH$:  check bmRequest Type, if data IN set DIR for handshake
                        else data in OUT, let the DIR be 0 in order to avoid
                        getting interrupt on the 0 byte handshake packet
        */

        if(USB_SetupPkt[0] & 0x80)
           USBCTL |= USBCTL_DIR;
        /*
        set NAK bit of EP0 IN BCNT reg
        clear TotBytCnt field of EP0 IN handle
        clear Flags field of EP0 IN handle
        */

        USB_EP0InReg->CT     = USBEPCT_NAK;
        hEp0In->DataFlags    = 0x00;
        hEp0In->Status       = 0x00;
        hEp0In->TotBytCnt    = 0x00;
        hEp0In->BytInThisSeg = 0x00;
        hEp0In->pBuffer      = NULL;
        hEp0In->pNextBuffer  = NULL;
        hEp0In->EventFlag    = 0x00;

        /*
        set NAK bit of EP0 IN BCNT reg
        clear TotBytCnt field of EP0 IN handle
        clear Flags field of EP0 IN handle
        */

        USB_EP0OutReg->CT     = USBEPCT_NAK;
        hEp0Out->DataFlags    = 0x00;
        hEp0Out->Status       = 0x00;
        hEp0Out->TotBytCnt    = 0x00;
        hEp0Out->BytInThisSeg = 0x00;
        hEp0Out->pBuffer      = NULL;
        hEp0Out->pNextBuffer  = NULL;
        hEp0Out->EventFlag    = 0x00;

        break;
      }

      case USBINTSRC_SOF:
      {
        usb_bus_events = USB_EVENT_SOF;
        break;
      }

      case USBINTSRC_PRESOF:
      {
        usb_bus_events = USB_EVENT_PSOF;
        break;
      }

      case USBINTSRC_HINT:
      {
        usb_bus_events = USB_EVENT_HINT;
        break;
      }

      case USBINTSRC_HERR:
      {
        usb_bus_events = USB_EVENT_HERR;
        break;
      }

      default: break;
    }
  }

  /* -----------------01/05/00 $MH$ ----------------
  if event is other than endpoint event
   --------------------------------------------------*/
  if(usb_bus_events)
  {
    // 04/14/01 $MH$: bug fix
    // jj = USB_GlobalVars->ActiveEndptNos;

    for(ii = 0; ii < MAX_ENDPT; ii++)
    {
      hEpx = (USB_EpHandle )(((unsigned long)USB_GlobalVars.EpHandleTable[ii][2]) |
                             (((unsigned long)USB_GlobalVars.EpHandleTable[ii][1]) << 8) |
                             (((unsigned long)USB_GlobalVars.EpHandleTable[ii][0]) << 16));

      if((hEpx != (USB_EpHandle )0) && (hEpx->EventMask & usb_bus_events) &&
         (hEpx->Fxn != (USB_EVENT_ISR)0))
      {
         hEpx->EventFlag |= usb_bus_events;
         hEpx->Fxn();
      }
    }
  }

  /*
  01/08/01 $MH$:  if returning from SETUP packet handler clear the SETUP and STPOW
                  flag by writing 1 to the USB STATUS register
                  ** NOT A GOOD IDEA IF THE EVENTS ARE HANDLED BY SWI **  for now
                  leaving the burden of clearing the SETUP and STPOW flag on the
                  users.
  */
  // clear setup and setup overwrite flag if set
  if(usb_bus_events == USB_EVENT_SETUP)
     USBIF |= USB_INT_SETUP|USB_INT_STPOW;

  return;
}

#endif
usb_edmain.c/   1049977327  0     0     0       3867      `
/******************************************************************************/
/* Name     : _USB_enableDmaIntrpt                                            */
/*                                                                            */
/* Catagory : Device Initialization (private function)                        */
/*                                                                            */
/* Purpose  : Enable the endpoint DMA interrupt.  Affected endpoint is        */
/*            determined by the endpoint objects passed to the function       */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the endpoint DMA interrupt is successfully enabled,            */
/* else USB_FALSE                                                             */    
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (_vUSB_enableDmaIntrpt, ".text:_vUSB_enableDmaIntrpt")

// USB_Boolean _USB_enableDmaIntrpt(USB_DevNum DevNum, USB_EpHandle hEp)
USB_Boolean _vUSB_enableDmaIntrpt(USB_DevNum DevNum, USB_EpHandle hEp)
{
  Uint16 EpIndex    = (Uint16)hEp->EpNum;
  Uint16 bit_addr;
  
  if(!(EpIndex % 8)) return(USB_FALSE);   /* no DMA intrpt for endpoint0 */
  
  bit_addr = EpIndex & 0x07; /* addr of endpoint intrpt mask bit */
  
  if(EpIndex & 0x08)         /* test for in-endpoints */
  {  
    USBIDIE |= (1 << bit_addr);
  }
  else                       /* out-endpoint */
  {  
    USBODIE |= (1 << bit_addr);
  }
  return(USB_TRUE);        
}

#endif

usb_enepin.c/   1049977329  0     0     0       3698      `
/******************************************************************************/
/* Name     : _USB_enableEpIntrpt                                             */
/*                                                                            */
/* Catagory : Device Initialization (private function)                       */
/*                                                                            */
/* Purpose  : Enable the endpoint interrupt.  Affected endpoint is determined */
/*            by the endpoint objects passed to the function               */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the endpoint interrupt is successfully enabled, else USB_FALSE */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (_vUSB_enableEpIntrpt, ".text:_vUSB_enableEpIntrpt")

// USB_Boolean _USB_enableEpIntrpt(USB_DevNum DevNum, USB_EpHandle hEp)
USB_Boolean _vUSB_enableEpIntrpt(USB_DevNum DevNum, USB_EpHandle hEp)
{
  Uint16 EpIndex    = (Uint16)hEp->EpNum;
  Uint16 bit_addr;
  
  bit_addr = EpIndex & 0x07; /* addr of endpoint intrpt mask bit */
  
  if(EpIndex & 0x08)         /* test for in-endpoints */
  {  
    USBIEPIE |= (1 << bit_addr);
  }
  else                       /* out-endpoint */
  {  
    USBOEPIE |= (1 << bit_addr);
  }
  return(USB_TRUE);        
}

#endif


usb_epn2h.c/    1049977330  0     0     0       4736      `
/******************************************************************************/
/* Name     : USB_epNumToHandle                                               */
/*                                                                            */
/* Catagory : Misc                                                            */
/*                                                                            */
/* Purpose  : Retrieve an handle to an endpoint                               */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* Endpt    : 8-bit endpoint number as specified in the USB specification     */
/*            0x00 -> Endpt 0 Out, 0x01 -> Endpt 1 Out ....                   */
/*            0x80 -> Endpt 0 In,  0x81 -> Endpt 1 In  ....                   */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* An handle to the endpoint object if a valid endpoint object exists, else   */
/* a NULL handle                                                              */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* This routine is helpful when the application does not have any prior       */
/* knowledge of the endpoint it is dealing with.  For example, if the host    */
/* requests to stall an endpoint the application can read the endpoint number */
/* from the setup packet, retrieve the handle to this endpoint by calling     */
/* USB_epNumToHandle(..), and call USB_stallEndpt(..) with the handle to      */
/* stall the ednpoint;                                                        */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    12 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>


#if (_USB_SUPPORT)

extern USB_GlobalVars_struct USB_GlobalVars;

#pragma CODE_SECTION (vUSB_epNumToHandle, ".text:vUSB_epNumToHandle.usb_api")

/*
12/12/00 $MH$
Function to retrieve endpoint handle by passing actual endpoint
number as a parameter.  This function may come handy during USB SETUP
request handling
*/
// USB_EpHandle USB_epNumToHandle(USB_DevNum DevNum, Uchar Endpt)
USB_EpHandle vUSB_epNumToHandle(USB_DevNum DevNum, Uchar Endpt)
{
  USB_EpHandle          hEp;
  /* USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)USB_GLOBALVAR_BASE; */

  // generate endpoint index from actual endpoint number
  Uint16 EpIndex = ((Endpt & 0x80)>>4)|(Endpt & 0x07);

  hEp = (USB_EpHandle )(((Uint32)(USB_GlobalVars.EpHandleTable[EpIndex][2] & 0xFF)) |
                        (((Uint32)(USB_GlobalVars.EpHandleTable[EpIndex][1] & 0xFF)) << 8) |
                        (((Uint32)(USB_GlobalVars.EpHandleTable[EpIndex][0] & 0xFF)) << 16));
  return(hEp);
}
#endif
usb_getev.c/    1049977332  0     0     0       3943      `
/******************************************************************************/
/* Name     : USB_getEvents                                                   */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : Get all the pending USB_EVENTS associated with a particular     */
/*            USB endpoint                                                    */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* ORed combination of all the pending USB_EVENTS associated with the         */
/* particular endpoint                                                        */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Calling this routine also clears all the pending USB_ENENTS associated     */
/* with the particular endpoint                                               */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/* Modified    01/10/01 $MH$                                                  */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>


#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_getEvents, ".text:vUsb_getEvents")

// USB_EVENT_MASK USB_getEvents(USB_EpHandle hEp)
USB_EVENT_MASK vUSB_getEvents(USB_EpHandle hEp)
{
  Uint16 Events;
  Events         = hEp->EventFlag;
  hEp->EventFlag = 0;
  return(Events);
}
#endif

usb_gfrano.c/   1049977333  0     0     0       3276      `
/******************************************************************************/
/* Name     :  USB_getFrameNo                                                 */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Read current USB frame number                                  */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* Current USB Frame Number                                                   */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_getFrameNo, ".text:vUSB_getFrameNo")

Uint16 vUSB_getFrameNo(USB_DevNum DevNum)
{
   return(((USBFNUMH & 0x07)<<8) | (USBFNUML & 0xFF));
}

#endif

usb_global.c/   1051539301  0     0     0       1336      `
/******************************************************************************/
/* Name     : usb_global.c                                                    */
/*                                                                            */
/* Catagory :                                                                 */
/*                                                                            */
/* Purpose  : To relocate USB Global Vars from USB RAM to DSP RAM to          */
/*            redure USB and DMA+McBSP contension                             */
/*                                                                            */
/* Author   : $mh$                                                            */
/*            Modified: 03/19/2003 to avoid compile if USB is not supported   */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
#include <csl_chiphal.h>

#if _USB_SUPPORT
  #include <_csl_usb.h>

  #pragma DATA_SECTION (USB_GlobalVars, ".csldata:USB_data")

  USB_GlobalVars_struct USB_GlobalVars;
#endif

usb_gspack.c/   1049977337  0     0     0       4349      `
/******************************************************************************/
/* Name     : USB_getSetupPacket                                              */
/*                                                                            */
/* Catagory : Data Transfer                                                   */
/*                                                                            */
/* Purpose  : Read the setup packet from the setup data buffer                */
/*                                                                            */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum     : USB device number, enumerated data type of USB_DevNum.        */
/*              Only USB0 is active currently                                 */
/*                                                                            */
/* *USB_Setup : Pointer to a structure of type USB_SetupStruct.               */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if successful else USB_FALSE. If successful successful USB_Setup  */
/* structure holds the new setup packet                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/

/* ---------------------------------------------------------------------------
 Read the SETUP packet. 
 11/28/00 $MH$ Added DevNum for future use for DSP with multiple USB module
 ----------------------------------------------------------------------------*/
#define _USB_MOD

#include <csl_chiphal.h>

#if (_USB_SUPPORT)

#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>


#pragma CODE_SECTION (vUSB_getSetupPacket, ".text:vUSB_getSetupPacket")

// USB_Boolean USB_getSetupPacket(USB_DevNum DevNum, USB_SetupStruct *USB_Setup)
USB_Boolean vUSB_getSetupPacket(USB_DevNum DevNum, USB_SetupStruct *USB_Setup)
{
  // SETUP packet can be found at 0x6700 of 5509 i/o space
  ioport Uint16 *Setup_pkt = (ioport Uint16 *)USBSUP_BUF;

  // Read the SETUP packet */
  USB_Setup->New           = 1;
  USB_Setup->bmRequestType = Setup_pkt[0];
  USB_Setup->bRequest      = Setup_pkt[1];
  USB_Setup->wValue        = Setup_pkt[2] | (Setup_pkt[3]<<8);
  USB_Setup->wIndex        = Setup_pkt[4] | (Setup_pkt[5]<<8);
  USB_Setup->wLength       = Setup_pkt[6] | (Setup_pkt[7]<<8);

  return(USB_TRUE);
}

#endif

usb_gstall.c/   1049977338  0     0     0       3993      `
/******************************************************************************/
/* Name     : USB_getEndptStall                                               */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : Find out if an endpoint is stalled                              */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the endpoint is stalled, otherwise USB_FALSE                   */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle selects the endpoint                                   */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_getEndptStall, ".text:vUSB_getEndptStall")

/* -----------------------------------------------------------------------
   Get the status of the STALL on the endpoint. If the endpoint is STALLed,
   the function returns USB_TRUE.
   11/29/00$MH$: Modified
   12/01/00 $MH$: 
   Replaced by the vUSB_getEndpointStall(USB_DevNum DevNum,Uint16 EpNum)
   12/18/00 $MH$ reinstated
 ----------------------------------------------------------------------------*/
// USB_Boolean USB_getEndptStall(USB_EpHandle hEp)
USB_Boolean vUSB_getEndptStall(USB_EpHandle hEp)
{
  USB_EDRegBlk   *USB_EDB    = (USB_EDRegBlk *)hEp->EDReg_SAddr;
  USB_EP0_RegBlk *USB_EP0Reg = (USB_EP0_RegBlk *)hEp->EDReg_SAddr;
  Uint16         EpIndex     = (Uint16)hEp->EpNum;
  USB_Boolean    ret_stat    = USB_FALSE;

  if(EpIndex % 8)       // for endpoints other than OUT EP0 and IN EP0 
  {
    if(USB_EDB->CNF & USBEPCNF_STALL) 
       ret_stat= USB_TRUE;
  }
  else                    // for EP0 (IN or OUT) 
  {
    if(USB_EP0Reg->CNF & USBEPCNF_STALL)
       ret_stat= USB_TRUE;
  }

  return(ret_stat);
}

#endif

usb_gtrmsta.c/  1049977340  0     0     0       3601      `


/******************************************************************************/
/* Name     : USB_getRemoteWakeupStat                                         */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : get the status of the Remote Wakeup Feature (whether the        */
/*            the feature is set or clear in the software)                    */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the Remote Wakeup Feature is enabled in the software.          */
/* USB_FALSE if the Remote Wakeup Feature is disabled in the software.        */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* An application must chech if the remote wakeup feature is set by the host  */
/* before calling USB_issueRemoteWakeup( )                                    */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    31 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

extern USB_GlobalVars_struct USB_GlobalVars;

#pragma CODE_SECTION (vUSB_getRemoteWakeupStat, ".text:vUSB_getRemoteWakeupStat")

USB_Boolean vUSB_getRemoteWakeupStat(USB_DevNum DevNum)
{
  /* USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)USB_GLOBALVAR_BASE; */
  return(USB_GlobalVars.RemoteWkpStat);
}
#endif


usb_init.c/     1049977342  0     0     0       10206     `
/******************************************************************************/
/* Name     : USB_init                                                        */
/*                                                                            */
/* Catagory : Device Initialization                                           */
/*                                                                            */
/* Purpose  : Configure the USB module                                        */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : None                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum     : USB device number, enumerated data type of USB_DevNum.        */
/*              Only USB0 is active currently                                 */
/*                                                                            */
/* hEpObj[]   : Pointer to a NULL terminated array of handles of initialized  */
/*              endpoint objects.  Max number of handles in the array can not */
/*              be more than 16 (excluding the NULL handle)                   */
/*                                                                            */
/* PSofTmrCnt : 8-bit counter value for the pre SOF timer                     */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the device configuration is successful, else USB_FALSE         */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Upon sucessful return from the function call the USB module is completely  */
/* for operation (all the regs are configured and unmasked interrupts         */
/* are enabled).  Once the USB module is configured the user's code needs to  */
/* unmask the USB interrupt mask bit in the IER0 reg of DSP and enable the    */
/* DSP global interrupt.  Finally the user's code should call the macro       */
/* USB_CONNECT(USB0) to connect the usb module to the USB bus                 */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    24 Nov 2000                                                    */
/*                                                                            */
/* 28 Feb 01 $MH$                                                             */
/* Changed name from USB_config( ) to USB_setParams( ) to comply with CSL     */
/* standard                                                                   */
/*                                                                            */
/* 18 Jul 01 $MH$                                                             */
/* Changed name from USB_setParams( ) to USB_init( ) to comply with CSL       */
/* standard                                                                   */
/*                                                                            */
/* 27 Aug 02 $MH$                                                             */
/* added capability to handle non multiple of 16-byte ISO max endpt size      */
/*                                                                            */
/******************************************************************************/


 /* --------------------------11/27/00 $MH$-----------------------------------
 Configure the USB interface. Initialize all the endpoints in the linked list.
 For endpoint 0, it would be done by configuring the CONF and BYTE COUNT
 registers.  For all other endpoints, initialize the Endpoint Descriptor Blocks
 and DMA Contexts.  - works
 Once this routine is called, to add another interface to the current device
 call _USB_configInterface( )
 ----------------------------------------------------------------------------*/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

extern USB_GlobalVars_struct USB_GlobalVars;

#pragma CODE_SECTION (vUSB_init, ".text:vUSB_init")

//USB_Boolean USB_init(USB_DevNum   DevNum,
//                     USB_EpHandle hEp[],
//                     Uchar        PSofTmrCnt)

USB_Boolean vUSB_init(USB_DevNum   DevNum,
                      USB_EpHandle hEp[],
                      Uchar        PSofTmrCnt)
{
  USB_Boolean           ret_stat        = USB_FALSE;
  USB_DMA_Context       *USB_DMA        = (USB_DMA_Context *)((Uint32)USB_DMA_REG_START);
  /* USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)USB_GLOBALVAR_BASE; */

  Uint16 ii, EpIndex, BufBaseAddrX, BufBaseAddrY, EpBuffEndAddr;

  /*
  12/21/00 $MH$:   reset USB firmware internal variables
  */
  _USB_resetFirmwareEnv(DevNum);

  /* -----------------10/26/2000 11:01PM---------------
  Take the USB module out of reset.
   --------------------------------------------------*/
  USBIDLCTL |= USBIDLCTL_USBEN;
  USBCTL       &= 0x90;                /* reset USBCTL reg */


  /*
  12/24/00 $MH$:   Enable USB PLL and wait until PLL locked
  01/16/01 $NH$:   move USB PLL init code to USB_initPLL( )
  */

  /*
  Reset the device address to 0
  */
  USBADDR = 0x00;

    /*
  Clear all the USB intrpt mask reg bits
  */
  USBIDIE   = 0x00;
  USBODIE   = 0x00;
  USBIEPIE  = 0x00;
  USBOEPIE  = 0x00;

  /*
  Clear USB interrupt status reg - specially for clearing SETUP and STPOW bit
  */
  USBIF = 0xFF;

  /* Clear all pending USB interrupts
   - use DevNum in the future to select the vect reg
   */
  while(USBINTSRC);

  /* Initialize DMA context - in future use DevNum to calculate the DMA context block*/
  for(ii=1; ii<MAX_ENDPT; ii++)
  {
    USB_DMA[ii].DCTL      = 0;
    USB_DMA[ii].DSIZ      = 0;
    USB_DMA[ii].DADL      = 0;
    USB_DMA[ii].DADH      = 0;
    USB_DMA[ii].DCT       = 0;
    USB_DMA[ii].DRSZ      = 0;
    USB_DMA[ii].DRAL      = 0;
    USB_DMA[ii].DRAH      = 0;
  }

  USBPSOFTMR = (PSofTmrCnt & 0xFF);      /* update PreSOF timer Count */

  /* initialize EDB   */

  for(ii=0; ((ii < MAX_ENDPT) && (hEp[ii] != NULL)); ii++)
  {
    ret_stat = USB_TRUE;
    EpIndex = (Uint16)(hEp[ii]->EpNum);
    if(!(EpIndex % 8))          /* if endpoint0                          */
    {
      _USB_configEndpt(hEp[ii], USBCNF0_INIT, 0x00, 0x00);
      USB_GlobalVars.ActiveEndptNos += 1;
    }
    else                        /* Initialize Endpoint Descriptor Blocks */
    {
     BufBaseAddrX  = (Uint16)((USB_GlobalVars.NextEpBuffStartAddr[0]<<8)|
                              (USB_GlobalVars.NextEpBuffStartAddr[1]&0xFF));
                              
     BufBaseAddrY  = BufBaseAddrX + hEp[ii]->MaxPktSiz;
     
     // 08/27/02 $MH$ fix for non multiple of 16-byte ISO max endpt size
     if((hEp[ii]->XferType == USB_ISO)&&(hEp[ii]->MaxPktSiz & 0x0F))
        BufBaseAddrY  = (BufBaseAddrY + 0x10)&0xFFF0;
     
     EpBuffEndAddr = BufBaseAddrY + hEp[ii]->MaxPktSiz;
     
     // 08/27/02 $MH$ fix for non multiple of 16-byte ISO max endpt size
     if((hEp[ii]->XferType == USB_ISO)&&(hEp[ii]->MaxPktSiz & 0x0F))
        EpBuffEndAddr  = (EpBuffEndAddr + 0x10)&0xFFF0;
        
     if(EpBuffEndAddr <= USB_SRAM_END)         /* if not endpoint buf addr overflow */
       {
          _USB_configEndpt(hEp[ii], USBEPCNF_INIT, BufBaseAddrX, BufBaseAddrY);
          // start address of next endpoint buffer
          // USB_GlobalVars->NextEpBuffStartAddr = EpBuffEndAddr;
          USB_GlobalVars.NextEpBuffStartAddr[0] = (EpBuffEndAddr>>8) & 0xFF;
          USB_GlobalVars.NextEpBuffStartAddr[1] = EpBuffEndAddr & 0xFF;
          // increment active endpt count
          USB_GlobalVars.ActiveEndptNos += 1;
       }
     else
       {
         // reset number of active endpoints
         USB_GlobalVars.ActiveEndptNos = 0x00;
         ret_stat = USB_FALSE;
         break;
       }  /* if endpoint buf addr overflow */
    }     /* end of if-else */

  }       /* end of for(ii=1; ii<=NumOfEp; ii++) */


  /*
  Enable USB bus event interrupts - use DevNum in the future.
  USB intrpt mask reg bits are set in the USB_postTransaction( )
  and the mask bits are reset USB_isr at the end of each transaction.
  */
  if(ret_stat == USB_TRUE)          /* if the configuration went well so far */
  {
    USBIE = USBIE_INIT;             /* enable USB interrupts only  */

    if(USB_GlobalVars.FlagSOF)
       USBIE |= USB_INT_SOF;

    if((PSofTmrCnt & 0xFF) != 0x00)  /* preSOF timer count > 0                */
                                     /* enable USB interrupts along with PSOF */
       USBIE |= USB_INT_PSOF;

    USBCTL |= USBCTL_INIT;           /* enable USB function         */
  }

  return(ret_stat);
}
#endif

usb_initpll.c/  1049977343  0     0     0       4443      `
/******************************************************************************/
/* Name     : USB_initPLL                                                     */
/*                                                                            */
/* Catagory : Device Control                                                  */
/*                                                                            */
/* Purpose  : Initailize USB PLL to generate clock for the USB module         */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : C55x PLL init routine                                           */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* inclk      : Input clock (supplied at CLKIN pin) frequency ( in MHz)       */
/*                                                                            */
/* outclk     : Desired clock frequency (in MHz) for the USB moduel, the      */
/*              outclk must be 48 MHz for the proper operation of the USB     */
/*              module.                                                       */
/*                                                                            */
/* plldiv     : Input clock (supplied at CLKIN pin) devide down value, used   */
/*              for USB PLL enable as well as USB PLL bypass mode             */
/*                                                                            */
/*============================================================================*/
/* Return Value:   None                                                       */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* pllmult = (outclk * (plldiv+1)) / inclk                                    */
/*                                                                            */
/* if pllmult > 1                                                             */
/*		outclk = (pllmult / (plldiv + 1)) * inclk                         */
/*                                                                            */
/* if pllmult < 1                                                             */
/*		outclk = (1 / (plldiv + 1)) * inclk                               */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    16 Jan 2001                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_initPLL, ".text:vUsb_initPLL")

// void USB_initPLL(Uint16 inclk, Uint16 outclk, Uint16 plldiv)
void vUSB_initPLL(Uint16 inclk, Uint16 outclk, Uint16 plldiv)
{
  Uint16 pllmult = (outclk * (plldiv+1)) / inclk;

  plldiv &= 0x3u;

  USB_CLKMD &= ~(1<<USB_PLL_ENABLE);        // force into BYPASS mode (b4=0)

  while (USB_CLKMD & (1<<USB_PLL_LOCK));    // wait for BYPASS mode to be active

  USB_CLKMD = ((1<<USB_PLL_IOB)|(pllmult<<USB_PLL_MULT)|(plldiv<<USB_PLL_DIV)|
	          (plldiv<<USB_PLL_BYPASS_DIV)|(1<<USB_PLL_ENABLE));

	if (pllmult > 1) // if pllmult > 1, wait for PLL mode to be active 
	{
		while (!(USB_CLKMD & (1<<USB_PLL_LOCK)));
	}
}
#endif


usb_initpt.c/   1049977345  0     0     0       8040      `
/******************************************************************************/
/* Name     : USB_initEndptObj                                                */
/*                                                                            */
/* Catagory : Initialization                                                  */
/*                                                                            */
/* Purpose  : Initialize an endpoint object                                   */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEp      : Handle to an endpoint object to be initialized                  */
/*                                                                            */
/* EpNum    : USB endpoint number of enumarated data type USB_EpNum           */
/*                                                                            */
/* XferType : Type of data transfer will be implemented with this endpoint    */
/*                                                                            */
/* MaxPktSiz: Max data packet size supported by the endpoint                  */
/*                                                                            */
/* EvMsk    : ORed combination of USB Interrupt Events to be broadcasted      */
/*            to the associated event handler                                 */
/*                                                                            */
/* Fxn      : Associated event handler routine                                */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the initialization is successful, else USB_FLASE               */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The event handler should be in void Fxn(void) form. Using the INTERRUPT    */
/* is not necessary.  Once the program control branches to Fxn the user's     */
/* code is free to call other functions or event post DSP?BIOS SWI            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:       24 Nov 2000                                                 */
/* Last Modified: 05 Jan 2001                                                 */
/*                                                                            */
/* 08/27/02 $MH$ added check for max endpt size to 1023 (10bit value) bytes   */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_initEndptObj, ".text:vUSB_initEndptObj")

/* --------------------------11/27/00 $MH$----------------------------------
 Initialize USB endpoint handle
 01/05/00 added EventMask and EventFlag for Event broad casting capabilities 
 ----------------------------------------------------------------------------*/
 
//USB_Boolean USB_initEndptObj(USB_DevNum      DevNum,
//                              USB_EpHandle   hEp,
//                              USB_EpNum      EpNum, 
//                              USB_XferType   XferType,
//                              Uint16         MaxPktSiz,
//                              Uint16         EvMsk,
//                              USB_EVENT_ISR  Fxn)
                              
USB_Boolean vUSB_initEndptObj(USB_DevNum      DevNum,
                              USB_EpHandle   hEp,
                              USB_EpNum      EpNum, 
                              USB_XferType   XferType,
                              Uint16         MaxPktSiz,
                              Uint16         EvMsk,
                              USB_EVENT_ISR  Fxn)                              
{
  USB_Boolean ret_stat       = USB_FALSE;
  Uint16 ii                  = (Uint16)EpNum;
  USB_EDRegBlk *USB_EDB      = (USB_EDRegBlk *)USB_EDB_START;
  USB_DMA_Context *USB_DMA   = (USB_DMA_Context *)USB_DMA_REG_START;
  
  
  hEp->DataFlags    = 0x0000;
  hEp->Status       = 0x0000;
  hEp->EpNum        = EpNum;
  hEp->XferType     = XferType;
  hEp->MaxPktSiz    = MaxPktSiz & 0x3FF;  // $MH$ 08/27/02 check for max endpt size
  hEp->TotBytCnt    = 0x0000;
  hEp->BytInThisSeg = 0x0000;
  hEp->pBuffer      = NULL;
  hEp->pNextBuffer  = NULL;
  hEp->EventMask    = EvMsk;
  hEp->EventFlag    = 0x00;
  hEp->Fxn          = Fxn;
  
  switch(EpNum)
  {
    case USB_OUT_EP0 : /* use DevNum to calculate appropriate reg addr if future
                          DSPs support multiple USB_Module                      */
                       hEp->EDReg_SAddr  = (Uint32)USBOCNF0_ADDR;
                       /* since there is no DMA for EP0, use hEp->DMA_SAddr
                          to hold EP0 data buffer start addr, use DevNum to 
                          calculate appropriate data buffer start addr if future
                          DSPs support multiple USB_Module                      */
                       hEp->DMA_SAddr    = (Uint32)USBOEP0_BUF;
                       ret_stat = USB_TRUE;
                       break;
    
    case USB_IN_EP0  : /* use DevNum to calculate appropriate reg addr if future
                          DSPs support multiple USB_Module                      */
                       hEp->EDReg_SAddr  = (Uint32)USBICNF0_ADDR;
                       /* since there is no DMA for EP0, use hEp->DMA_SAddr
                          to hold EP0 data buffer start addr, use DevNum to 
                          calculate appropriate data buffer start addr if future
                          DSPs support multiple USB_Module                      */
                       hEp->DMA_SAddr    = (Uint32)USBIEP0_BUF;
                       ret_stat = USB_TRUE;
                       break;
                       
    default          : hEp->EDReg_SAddr  = (Uint32)(&USB_EDB[ii]);
                       hEp->DMA_SAddr    = (Uint32)(&USB_DMA[ii]);
                       ret_stat = USB_TRUE;
                       break;
  }          /* switch(EPxIndex) */
  return(ret_stat);
}
#endif
usb_isrmwk.c/   1049977347  0     0     0       3902      `
/******************************************************************************/
/* Name     : USB_issueRemoteWakeup                                           */
/*                                                                            */
/* Catagory : Device Control                                                  */
/*                                                                            */
/* Purpose  : Issue a remote wakeup signal to the host.                       */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Host must set the remote wake up feature first. An application must chech  */
/* if the remote wake-up feature is before generating a remote wake-up signal */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

extern USB_GlobalVars_struct USB_GlobalVars;

#pragma CODE_SECTION (vUSB_issueRemoteWakeup, ".text:vUSB_issueRemoteWakeup")

USB_Boolean vUSB_issueRemoteWakeup(DevNum)
{
   USB_Boolean ret_stat;
   /* USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)USB_GLOBALVAR_BASE; */

   if(USB_GlobalVars.RemoteWkpStat)
   {
      USBCTL |= USBCTL_RWUP;
      ret_stat = USB_TRUE;
   }

   else
      ret_stat = USB_TRUE;

   return(ret_stat);
}

#endif
usb_istdon.c/   1049977349  0     0     0       4358      `
/******************************************************************************/
/* Name     : USB_isTransactionDone                                           */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : Find out the status of the previously posted data transfer      */
/*            request                                                         */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE, if the previously posted transfer is completed, else USB_FLASE.  */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint data will pass through.        */
/* It is a good idea to call this function before posting a data transfer     */
/* request                                                                    */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:        28 Nov 2000                                                */
/* Last Modified:  10 Jan 2001                                                */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_isTransactionDone, ".text:vUSB_isTransactionDone")

/* ----------------------------------------------------------------------------
  Return the status of the previous transaction.
  Modified 11/28/00 $MH$
           12/05/00 $MH$
           01/09/01 $MH$: test if USB_IOFLAG_DATAREQ is cleared to determine
                          if the transaction is done - for now it's not implemented
 ----------------------------------------------------------------------------*/
// USB_Boolean USB_isTransactionDone(USB_EpHandle hEp)
USB_Boolean vUSB_isTransactionDone(USB_EpHandle hEp)
{
  USB_DMA_Context *USB_DMA    = (USB_DMA_Context *)hEp->DMA_SAddr;
  USB_EP0_RegBlk  *USB_EP0Reg = (USB_EP0_RegBlk *)hEp->EDReg_SAddr;
  Uint16          Endpt       = (Uint16)hEp->EpNum;
  USB_Boolean     ret_stat;

  if(Endpt % 8)
  {
    ret_stat = ((USB_DMA->DCTL & USBDCTL_GO) || 
                (hEp->DataFlags & USB_IOFLAG_DATAREQ)) ? USB_FALSE : USB_TRUE;
  }
  
  else
  {
   ret_stat = ((USB_EP0Reg->CT & USBEPCT_NAK) && !(hEp->DataFlags & 
               (USB_IOFLAG_DATAREQ | USB_IOFLAG_NEW))) ? USB_TRUE : USB_FALSE;
  }

  return(ret_stat);
}

#endif

usb_peekev.c/   1049977350  0     0     0       3962      `
/******************************************************************************/
/* Name     : USB_peekEvents                                                  */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : Read all the pending USB_EVENTS associated with a particular    */
/*            USB endpoint                                                    */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* ORed combination of all the pending USB_EVENTS associated with the         */
/* particular endpoint                                                        */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Calling this routine does not clear the pending USB_ENENTS associated      */
/* the particular endpoint                                                    */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:       28 Nov 2000                                                 */
/*                                                                            */
/* Last Modified: 21 Fev 2001                                                 */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_peekEvents, ".text:vUSB_peekEvents")

// USB_EVENT_MASK USB_peekEvents(USB_EpHandle hEp)
USB_EVENT_MASK vUSB_peekEvents(USB_EpHandle hEp)
{
  return(hEp->EventFlag);
}

#endif

usb_ptrans.c/   1049977352  0     0     0       8877      `
/******************************************************************************/
/* Name     : USB_postTransaction                                             */
/*                                                                            */
/* Catagory : Data Transfer                                                   */
/*                                                                            */
/* Purpose  : Transmit and receive USB data through an endpoint               */
/*                                                                            */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/* ByteCnt  : Total number of bytes in the buffer pointed by *Data            */
/*                                                                            */
/* *Data    : A pointer to a data buffer or to a linked list of type          */
/*            USB_DataStruct                                                  */
/*                                                                            */
/* Flags    : ORed combination of USB Data Transfer Flags                     */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_FALSE, if the previously posted transfer is not completed. USB_TRUE    */
/* if the data transfer request was posted successfully.                      */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint data moving in or out of the   */
/* USB module. At the end of the data transfer the USB event dispatcher will  */
/* call the associated event handler routine if the USB_TRANSACTIN_DONE event */
/* mask is set and an event handler routine is supplied during the endpoint   */
/* object initialization                                                      */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:        28 Nov 2000                                                */
/* Last Modified:  10 Jan 2001                                                */
/*                                                                            */
/* 03/05/01 $MH$ Added code to keep track of actual number of bytes xferred   */
/* specially for OUT xfers terminated short.  DMA keeps track of actual number*/
/* of bytes moved in from a OUT transfer, for the rest of the endpoints       */
/* software will update the 1st word of a buffer with the actual number bytes */
/* moved in(out) of the data buffer                                           */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

extern USB_GlobalVars_struct USB_GlobalVars;

#pragma CODE_SECTION (vUSB_postTransaction, ".text:vUSB_postTransaction")

/* ----------------------------------------------------------------------------
 Prepare the endpoint for the next transaction. If the endpoint is anything
 other than 0, prepare DMA transaction, or else, prepare transaction via the
 DMA. The data can be just a set of bytes or a linked list, in which case, each
 data parameter belongs to a USB_DataStruct structure.
 Modified 11/28/00 $MH$:
 ----------------------------------------------------------------------------*/
//USB_Boolean USB_postTransaction(USB_EpHandle      hEp,
//                                     Uint16       Bytes,
//                                     void         *Data,
//                                     USB_IOFLAGS  Flags)

USB_Boolean vUSB_postTransaction(USB_EpHandle     hEp,
                                     Uint16       Bytes,
                                     void         *Data,
                                     USB_IOFLAGS  Flags)
{
  USB_EpHandle hEp0In, hEp0Out;

  /* USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)USB_GLOBALVAR_BASE; */

  /* do not prepare a new transaction if previous transaction in progress */
  // 03/05/01 $MH$ added check for endpt obj belongs to HPORT
  if((hEp->XferType == USB_HPORT) || (!USB_isTransactionDone(hEp))) return(USB_FALSE);

  hEp->DataFlags = USB_IOFLAG_NEW | (Flags & (USB_IOFLAG_LNK | USB_IOFLAG_CAT |
                   USB_IOFLAG_EOLL | USB_IOFLAG_NOSHORT | USB_IOFLAG_SWAP));

  hEp->EventFlag &= ~USB_EVENT_EOT;

  if(hEp->DataFlags & USB_IOFLAG_EOLL)
     hEp->TotBytCnt = 0xFFFF;
  else
     hEp->TotBytCnt = Bytes;

  // If a linked list being transferred
  if(Flags & USB_IOFLAG_LNK)
  {
    hEp->BytInThisSeg   = ((USB_DataStruct *)Data)->Bytes;
    hEp->pBuffer        = ((USB_DataStruct *)Data)->pBuffer;
    hEp->pNextBuffer    = ((USB_DataStruct *)Data)->pNextBuffer;
  }

  else
  {
    hEp->BytInThisSeg   = Bytes;
    hEp->pBuffer        = Data;
    hEp->pNextBuffer    = NULL;
  }

  // 03/05/01 $MH$ keep track of the 1st word of the buffer to store actual number
  // of bytes moved in (out) and also advance the pBuffer to the next word which is
  // in fact the start of the actual data.  For OUT DMA endpoints this is done by
  // the DMA so for the OUT DMA endpoints we will decrement the pointer before
  // posting the DMA endpoint transfer

  hEp->XferBytCnt = hEp->pBuffer;
  if(hEp->pBuffer != NULL)            // to handle NULL data passed
  {                                   // only handled for EP0 IN/OUT
    hEp->pBuffer++;                   // NULL data pointer is not supported for any other endpts
    *hEp->XferBytCnt = 0x0000;        // clear XferBytCnt field
  }

  switch(hEp->EpNum)
  {
    case USB_OUT_EP0:                 // OUT_EP0 transaction

         hEp0In  = (USB_EpHandle )(((Uint32)USB_GlobalVars.EpHandleTable[8][2]) |
                                   (((Uint32)USB_GlobalVars.EpHandleTable[8][1]) << 8) |
                                   (((Uint32)USB_GlobalVars.EpHandleTable[8][0]) << 16));

         if(USB_isTransactionDone(hEp0In) && (!(hEp0In->DataFlags & USB_IOFLAG_DATAREQ)))
         _USB_procCtrlOutTransaction(hEp);

         break;

    case USB_IN_EP0:                  // IN_EP0 transaction

         hEp0Out = (USB_EpHandle )(((Uint32)USB_GlobalVars.EpHandleTable[0][2]) |
                                   (((Uint32)USB_GlobalVars.EpHandleTable[0][1]) << 8) |
                                   (((Uint32)USB_GlobalVars.EpHandleTable[0][0]) << 16));

         if(USB_isTransactionDone(hEp0Out))
         _USB_procCtrlInTransaction(hEp);

         break;

    default:
         hEp->DataFlags &= ~USB_IOFLAG_NEW;
         hEp->DataFlags |= USB_IOFLAG_DATAREQ;

         // if OUT DMA endpoint decrement the buffer pointer to the XferBytCnt
         // so the DMA can update this field
         if(!(hEp->EpNum / 8))  hEp->pBuffer--;
         _USB_procDmaTransaction(hEp);     /* rest - DMA transaction required */
         break;                            /* should we test the DMA endpoint instead of relying on default */
  }                                        /* end of switch( )  */
  return(USB_TRUE);
}

#endif

usb_rstdev.c/   1049977354  0     0     0       3739      `
/******************************************************************************/
/* Name     :  USB_resetDev                                                   */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Reset the USB module.                                          */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Once the module has been reset, all the control and status registers are   */
/* returned to powerup reset values and the USB module is diconnected from    */
/* the upstream port.                                                         */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

#pragma CODE_SECTION (vUSB_resetDev, ".text:vUSB_resetDev")

void vUSB_resetDev(USB_DevNum DevNum)
{
    (USBGCTL |= USBGCTL_RST);
}
#endif
      

usb_rstfirm.c/  1049977356  0     0     0       4497      `
/******************************************************************************/
/* Name     : _USB_resetFirmwareEnv                                           */
/*                                                                            */
/* Catagory : Firmware Initialization (private function)                     */
/*                                                                            */
/* Purpose  : Reset the internal USB firmware variable to a known state       */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the internal firmware variables are reset to a known state,    */
/* else USB_FALSE                                                             */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>
#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>

#if (_USB_SUPPORT)

extern USB_GlobalVars_struct USB_GlobalVars;

#pragma CODE_SECTION (_vUSB_resetFirmwareEnv, ".text:_vUSB_resetFirmwareEnv")

// USB_Boolean _USB_resetFirmwareEnv(USB_DevNum DevNum)
USB_Boolean _vUSB_resetFirmwareEnv(USB_DevNum DevNum)
{
  Uint16 ii;
  USB_Boolean ret_stat = USB_TRUE;
  /* USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)USB_GLOBALVAR_BASE; */

  /*
  init endpoint handle table, endpoint event table, and endpoint reload count table
  */
  for(ii = 0; ii < 16; ii++)
  {
    /*
    init endpoint handle table
    */
    USB_GlobalVars.EpHandleTable[ii][2] = 0x00;
    USB_GlobalVars.EpHandleTable[ii][1] = 0x00;
    USB_GlobalVars.EpHandleTable[ii][0] = 0x00;

    /*
    init endpoint reload count table

    USB_GlobalVars->ReloadCount[ii] = 0x00;
    */
  }


  /*
  Mark the buffer (USB SRAM) start addr for next endpoint to be initialized.
  The variable is used to check USB SRAM overflow in USB_config and _USB_configInterface
  routine

  */
  USB_GlobalVars.NextEpBuffStartAddr[0] = ((USB_SRAM_START - USB_DMA_REG_START)>>8)&0xFF;
  USB_GlobalVars.NextEpBuffStartAddr[1] =  (USB_SRAM_START - USB_DMA_REG_START)&0xFF;


  // init USB remore wakeup status
  USB_GlobalVars.RemoteWkpStat = USB_FALSE;

  // clear USB SOF interrupt option flag
  USB_GlobalVars.FlagSOF = USB_FALSE;

  // reset number of active endpoints
  USB_GlobalVars.ActiveEndptNos = 0x00;

  return(ret_stat);
}
#endif



usb_sdevad.c/   1049977358  0     0     0       3339      `
/******************************************************************************/
/* Name     :  USB_setDevAddr                                                 */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Set USB device address                                         */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* addr     : 7-bit USB device address                                        */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>

#if (_USB_SUPPORT)

#include <csl_usb.h>
#include <_csl_usb.h>
#include <csl_usb.h>


#pragma CODE_SECTION (vUSB_setDevAddr, ".text:vUSB_setDevAddr")

void vUSB_setDevAddr(USB_DevNum DevNum, Uchar addr)
{
  USBADDR = addr & 0x7F;
}  
#endif


usb_setwk.c/    1049977359  0     0     0       4277      `
/******************************************************************************/
/* Name     : USB_setRemoteWakeup                                             */
/*                                                                            */
/* Catagory : Software Control                                                */
/*                                                                            */
/* Purpose  : Set of clear Remote Wakeup Feature                              */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* RmtWkpStat:  If USB_TRUE the driver will set remote wakeup feature         */
/*              and a subsequent call to USB_issueRemoteWakeup( ) will cause  */
/*              the driver to generate a remote signal on the bus             */
/*                                                                            */
/*              If USB_FALSE the driver will clear remote wakeup feature      */
/*              and a subsequent call to USB_issueRemoteWakeup( ) will not    */
/*              generate a remote signal on the bus                           */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Host must set the remote wake up feature first. An application must chech  */
/* if the remote wake-up feature is before generating a remote wake-up signal */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    31 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/
#define _USB_MOD

#include <csl_chiphal.h>

#if (_USB_SUPPORT)

#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>


extern USB_GlobalVars_struct USB_GlobalVars;

#pragma CODE_SECTION (vUSB_setRemoteWakeup, ".text:vUSB_setRemoteWakeup")

void vUSB_setRemoteWakeup(USB_DevNum DevNum, USB_Boolean RmtWkpStat)
{
   /* USB_GlobalVars_struct *USB_GlobalVars = (USB_GlobalVars_struct *)USB_GLOBALVAR_BASE; */
   USB_GlobalVars.RemoteWkpStat         = RmtWkpStat;
}
#endif


usb_stalpt.c/   1049977361  0     0     0       4661      `
/******************************************************************************/
/* Name     : USB_stallEndpt                                                  */
/*                                                                            */
/* Catagory : Device Control                                                  */
/*                                                                            */
/* Purpose  : Stall an endpoint                                               */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint to stall                       */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/


/* ---------------------------------------------------------------------------
 STALL the corresponding endpoint. Further requests to the endpoint will
 see a STALL on the endpoint.
 11/29/00 $MH$: Modified
 12/01/00 $MH$: 
 Replaced by the vUSB_stallEndpoint(USB_DevNum DevNum,Uint16 EpNum)
 12/18/00 $MH$ reinstated
 
 Last Modified: 6th May 2002
 Modified by  : Ruchika
 Modification : The TOGGLE bit in the EDB Configuration register is cleared to 
 				indicate the next buffer to be the X buffer
  	            The USBALT register set to indicate that DMA points to the DATA0 
  	            buffer.
 ---------------------------------------------------------------------------*/
#define _USB_MOD

#include <csl_chiphal.h>

#if (_USB_SUPPORT)

#include <csl_usbhal.h>
#include <_csl_usb.h>
#include <csl_usb.h>


#pragma CODE_SECTION (vUSB_stallEndpt, ".text:vUSB_stallEndpt")

void vUSB_stallEndpt(USB_EpHandle hEp)
{
  USB_EDRegBlk *USB_EDB       = (USB_EDRegBlk *)hEp->EDReg_SAddr;
  USB_EP0_RegBlk *USB_EP0Reg  = (USB_EP0_RegBlk *)hEp->EDReg_SAddr;
  Uint16 EpIndex              = (Uint16)hEp->EpNum;
#ifndef DISABLE_USB_TOGGLE_BUGFIX
  Uint16 AltMask;
#endif

  if(EpIndex % 8)       /* STALL endpoints other than OUT EP0 and IN EP0 */
  {
    USB_EDB->CNF |= USBEPCNF_STALL;
    
#ifndef DISABLE_USB_TOGGLE_BUGFIX
    /* USB DMA should point to the DATA0 (X buffer) */
    /* Check if the register value at 0x5840 is clear or not 
       If not then the bit can be cleared by writing a 1 to it */

    USB_EDB->CNF &=0x00DF ;

    AltMask = 0x1 << hEp->EpNum; /* Compute the Mask Value*/

    /*If TRUE then the DMA is currently pointing to the Y buffer */
    if (USBALT & AltMask)
    {
      USBALT|=AltMask;           
    }
#endif         
  }
  else                  /* STALL the EP0 (IN or OUT) */
  {
    USB_EP0Reg->CNF |= USBEPCNF_STALL;
  }
  
  return;
}
#endif

wdtB_close.c/   1049977366  0     0     0       3134      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... WDTIM
* FILENAME...... wdtB_close.c
* DATE CREATED.. Tues 03/26/2002 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  03/26/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Open function for 5502 Watchdog timer)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_wdtim.h>
   
 
#if (_WDTIMB_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT static macro declarations
\****************************************/
/* See gpt.h Romability */
 
/****************************************\
* GPT static typedef declarations
\****************************************/

/****************************************\
* GPT static function declarations
\****************************************/

/****************************************\
* GPT Variable definitions : ROMability 
\****************************************/

/* Definition Romability See GPT.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* WDTIM global variable definitions
\****************************************/
/* Definition See csl_wdtim.h */
/*----------------------------------------------------------------------------*/
             
/****************************************\
* WDTIM global function definitions
\****************************************/

#pragma CODE_SECTION(WDTIM_close,".text:WDTIM_close")

/*----------------------------------------------------------------------------*/
 void WDTIM_close(WDTIM_Handle h) {
  CSL_SYS_DATA.WdtAllocMask = 0x0000u;
}
/*----------------------------------------------------------------------------*/

#endif /* WDTIMB_SUPPORT */
/******************************************************************************\
* End of wdtB_close.c
\******************************************************************************/

wdtB_open.c/    1049977368  0     0     0       3172      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... WDTIM
* FILENAME...... wdtB_open.c
* DATE CREATED.. Tues 03/26/2002 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  03/26/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Open function for 5502 Watchdog timer)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_wdtim.h>
   
 
#if (_WDTIMB_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT static macro declarations
\****************************************/
/* See gpt.h Romability */
 
/****************************************\
* GPT static typedef declarations
\****************************************/

/****************************************\
* GPT static function declarations
\****************************************/

/****************************************\
* GPT Variable definitions : ROMability 
\****************************************/

/* Definition Romability See GPT.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* WDTIM global variable definitions
\****************************************/
/* Definition See csl_wdtim.h */
/*----------------------------------------------------------------------------*/
             
/****************************************\
* WDTIM global function definitions
\****************************************/

#pragma CODE_SECTION(WDTIM_open,".text:WDTIM_open")

/*----------------------------------------------------------------------------*/
WDTIM_Handle WDTIM_open(void) {
  CSL_SYS_DATA.WdtAllocMask = 0x0001u;
  return (WDTIM_Handle)(&(CSL_WDTIM_DATA)); 
}
/*----------------------------------------------------------------------------*/

#endif /* WDTIMB_SUPPORT */
/******************************************************************************\
* End of wdtB_open.c
\******************************************************************************/

wdtimB_cfg.c/   1049977369  0     0     0       4300      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... WDTIM
* FILENAME...... wdtim_cfg.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the 5502 General Purpose 64 bit timer)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_wdtim.h>
   
 
#if (_WDTIMB_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT static macro declarations
\****************************************/
/* See gpt.h Romability */
 
/****************************************\
* GPT static typedef declarations
\****************************************/

/****************************************\
* GPT static function declarations
\****************************************/

/****************************************\
* GPT Variable definitions : ROMability 
\****************************************/

/* Definition Romability See GPT.h */


             
/****************************************\
* TIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* TIMER global variable definitions
\****************************************/
/* Definition See csl_wdtim.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* TIMER global function definitions
\****************************************/

#pragma CODE_SECTION(WDTIM_config,".text:WDTIM_config")

/*----------------------------------------------------------------------------*/
void WDTIM_config(WDTIM_Handle hWdt, WDTIM_Config *Config) {
  int oldgie;
  ioport WDTIM_RegObj *regPtr =((CSL_WdtimDataObj *)(hWdt))->regs;
  Uint16 tcr2_val = Config->wdtwctl2 & (_WDTIM_WDTWCTL2_WDKEY_CLR);
  Uint16 tcr1_val = Config->wdtwctl1 & (_WDTIM_WDTWCTL1_WDEN_CLR);

    oldgie = IRQ_globalDisable();  
 
   (regPtr->wdtgctl1) = 0x0000u;
   (regPtr->wdtemu)   = Config->wdtemu;
   (regPtr->wdtgpint) = Config->wdtgpint;
   (regPtr->wdtgpen) = Config->wdtgpen;
   (regPtr->wdtgpdir) = Config->wdtgpdir;
   (regPtr->wdtgpdat) = Config->wdtgpdat;
   (regPtr->wdtprd1) = Config->wdtprd1;
   (regPtr->wdtprd2) = Config->wdtprd2;
   (regPtr->wdtprd3) = Config->wdtprd3;
   (regPtr->wdtprd4) = Config->wdtprd4;
   (regPtr->wdtctl1) = Config->wdtctl1;
   (regPtr->wdtctl2) = Config->wdtctl2;
   (regPtr->wdtgctl1) = Config->wdtgctl1;  
   (regPtr->wdtwctl1) = tcr1_val;
   (regPtr->wdtwctl2) = tcr2_val;
  
  IRQ_globalRestore(oldgie); 
 
}
/*----------------------------------------------------------------------------*/

#endif /* WDTIMB_SUPPORT */
/******************************************************************************\
* End of wdtim_cfg.c
\******************************************************************************/

wdtimB_cfgb.c/  1049977371  0     0     0       3739      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... WDTIM
* FILENAME...... wdtim_cgpB.c
* DATE CREATED.. Sun 02/10/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  02/10/2002 Created for C6x
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the 5502 General Purpose Timer module)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

/****************************************\
* include files
\****************************************/    

#include <csl_wdtim.h>
   

#if (_WDTIMB_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* GPT global variable definitions
\****************************************/
/* Definition See csl_wdtim.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will e defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* GPT global function definitions
\****************************************/

#pragma CODE_SECTION(WDTIM_configArgs,".text:WDTIM_configArgs")

/*----------------------------------------------------------------------------*/
void WDTIM_configArgs(WDTIM_Handle hWdt, Uint16 wdtemu, 
            Uint16 wdtprd1,Uint16 wdtprd2,Uint16 wdtprd3,Uint16 wdtprd4,
            Uint16 wdtgpint,Uint16 wdtgpen,Uint16 wdtgpdir,Uint16 wdtgpdat,
            Uint16 wdtctl1,Uint16 wdtctl2,Uint16 wdtgctl1,
            Uint16 wdtwctl1, Uint16 wdtwctl2){
  int oldgie;
  Uint16 tcr2_val = wdtwctl2 & (_WDTIM_WDTWCTL2_WDKEY_CLR);
  Uint16 tcr1_val = wdtwctl1 & _WDTIM_WDTWCTL1_WDEN_CLR;
  
  ioport WDTIM_RegObj *regPtr =((CSL_WdtimDataObj *)(hWdt))->regs;

  oldgie = IRQ_globalDisable(); 


   (regPtr->wdtgctl1) = 0x0000u;
   (regPtr->wdtemu)   = wdtemu;
   (regPtr->wdtgpint) = wdtgpint;
   (regPtr->wdtgpen) = wdtgpen;
   (regPtr->wdtgpdir) = wdtgpdir;
   (regPtr->wdtgpdat) = wdtgpdat;
   (regPtr->wdtprd1) = wdtprd1;
   (regPtr->wdtprd2) = wdtprd2;
   (regPtr->wdtprd3) = wdtprd3;
   (regPtr->wdtprd4) = wdtprd4;
   (regPtr->wdtctl1) = wdtctl1;
   (regPtr->wdtctl2) = wdtctl2;
   (regPtr->wdtgctl1) = wdtgctl1;  
   (regPtr->wdtwctl1) = tcr1_val;  
   (regPtr->wdtwctl2) = tcr2_val;  

  
  IRQ_globalRestore(oldgie); 
}

/*----------------------------------------------------------------------------*/

#endif /* GPT_SUPPORT */
/******************************************************************************\
* End of wdtim_cfgb.c
\******************************************************************************/


wdtimB_gcfg.c/  1049977373  0     0     0       3600      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... WDT
* FILENAME...... wdtimB_gcfg.c
* DATE CREATED.. Sun 02/10/2002
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*    CREATED:   02/10/2002
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the 5502 General Purpose Timer module)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

/****************************************\
* include files
\****************************************/    
#include <_csl.h>      
#include <csl_chiphal.h>
   
 
#if (_WDTIMB_SUPPORT)

#include <csl_wdtim.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

             
/****************************************\
* WDT static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* WDT global variable definitions
\****************************************/
/* Definition See WDT.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will be defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* WDT global function definitions
\****************************************/

#pragma CODE_SECTION(WDTIM_getConfig,".text:WDTIM_getConfig")

/*----------------------------------------------------------------------------*/
void WDTIM_getConfig(WDTIM_Handle hWdt, WDTIM_Config *Config) {
  int oldgie;
  ioport WDTIM_RegObj *regPtr =((CSL_WdtimDataObj *)(hWdt))->regs;

    oldgie = IRQ_globalDisable();  
  
  Config->wdtemu  = (regPtr->wdtemu);
  Config->wdtgpint = (regPtr->wdtgpint);
  Config->wdtgpen = (regPtr->wdtgpen);
  Config->wdtgpdir = (regPtr->wdtgpdir);
  Config->wdtgpdat = (regPtr->wdtgpdat);
  Config->wdtprd1 = (regPtr->wdtprd1);
  Config->wdtprd2 = (regPtr->wdtprd2);
  Config->wdtprd3 = (regPtr->wdtprd3);
  Config->wdtprd4 = (regPtr->wdtprd4);
  Config->wdtctl1 = (regPtr->wdtctl1);
  Config->wdtctl2 = (regPtr->wdtctl2);
  Config->wdtgctl1 = (regPtr->wdtgctl1); 
  Config->wdtwctl1 = (regPtr->wdtwctl1);
  Config->wdtwctl2 = (regPtr->wdtwctl2);

  IRQ_globalRestore(oldgie); 
 
}
/*----------------------------------------------------------------------------*/

#endif /* WDTIMB_SUPPORT */
/******************************************************************************\
* End of wdt_gcfg.c
\******************************************************************************/

wdtimB_srvc.c/  1049977374  0     0     0       1660      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... WDTIMER
* FILENAME...... wdtim_srvc.c
* DATE CREATED.. Fri 07/28/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:		07/28/2000.  
*   LAST MODIFIED:	(IM) 01/02/2001 Modified for Amadeus
*------------------------------------------------------------------------------
* DESCRIPTION:  (Start sequence for Watch Dog Timer, assumes preconfig)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

#include <csl_chiphal.h>

#if (_WDTIMB_SUPPORT)

#include <csl_wdtim.h>

#pragma CODE_SECTION(WDTIM_service,".text:WDTIM_service")

/*----------------------------------------------------------------------------*/
void WDTIM_service(WDTIM_Handle hWdt) {
 int old_intm;
  ioport WDTIM_RegObj *regPtr =((CSL_WdtimDataObj *)(hWdt))->regs;

  old_intm = IRQ_globalDisable();

 
  regPtr->wdtwctl2 = WDTIM_WDTWCTL2_WDKEY_PREACTIVE;
  regPtr->wdtwctl2 = WDTIM_WDTWCTL2_WDKEY_ACTIVE;  
  IRQ_globalRestore(old_intm);
}
#endif /* WDTIM_SUPPORT */
/******************************************************************************\
* End of wdtim_srvc.c
\******************************************************************************/

wdtimB_strt.c/  1067582950  0     0     0       1744      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... WDTIMER
* FILENAME...... wdtim_strt.c
* DATE CREATED.. Fri 07/28/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:		07/28/2000.  
*   LAST MODIFIED:	10/28/2003 Corrected the sequence to start watchdog timer
*					01/02/2001 Modified for Amadeus
*------------------------------------------------------------------------------
* DESCRIPTION:  (Start sequence for Watch Dog Timer, assumes preconfig)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

#include <csl_chiphal.h>

#if (_WDTIMB_SUPPORT)

#include <csl_wdtim.h>

#pragma CODE_SECTION(WDTIM_wdStart,".text:WDTIM_wdStart")

/*----------------------------------------------------------------------------*/
void WDTIM_wdStart(WDTIM_Handle hWdt) {
 int old_intm;
  ioport WDTIM_RegObj *regPtr =((CSL_WdtimDataObj *)(hWdt))->regs;

  old_intm = IRQ_globalDisable();

  regPtr->wdtwctl1 |= _WDTIM_WDTWCTL1_WDEN_MK(1);
  regPtr->wdtwctl2 = WDTIM_WDTWCTL2_WDKEY_PREACTIVE;
  regPtr->wdtwctl2 = WDTIM_WDTWCTL2_WDKEY_ACTIVE;  
  IRQ_globalRestore(old_intm);
}
#endif /* _WDTIMB_SUPPORT */
/******************************************************************************\
* End of wdtimB_strt.c
\******************************************************************************/

wdtim_cfg.c/    1049977378  0     0     0       3683      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... TIMER
* FILENAME...... wdtim_cfga.c
* DATE CREATED.. Fri 07/28/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*  CREATED:		07/28/2000
*  LAST MODIFIED: (IM) 01/02/2001 Modified for Amadeus
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the TIMER module)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

/****************************************\
* include files
\****************************************/  
#include <csl_chiphal.h>
 
#if (_WDTIMA_SUPPORT)

#include <csl_wdtim.h> 

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* WDTIM static macro declarations
\****************************************/
/* See csl_wdtim.h Romability */
 
 
/****************************************\
* WDTIMER static typedef declarations
\****************************************/

/****************************************\
* WDTIMER static function declarations
\****************************************/

/****************************************\
* WDTIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* WDTIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* WDTIMER global variable definitions
\****************************************/
/* Definition See csl_wdtim.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see which if any timer devices  */
/* are in use by BIOS. These symbols will be defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* WDTIMER global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
void WDTIM_config(WDTIM_Config *Config) {
  int old_intm;
  Uint16 tcr2_val = Config->wdtcr2 & (_WDTIM_WDTCR2_WDKEY_CLR & _WDTIM_WDTCR2_WDEN_CLR);

  old_intm = IRQ_globalDisable();  
  WDTIM_RSET(WDTCR,Config->wdtcr);
  WDTIM_RSET(WDPRD,Config->wdprd);
  WDTIM_RSET(WDTCR2,tcr2_val);
  IRQ_globalRestore(old_intm);   

}
/*----------------------------------------------------------------------------*/

#endif /* WDTIM_SUPPORT */
/******************************************************************************\
* End of wdtim_cfg.c
\******************************************************************************/


wdtim_cfgb.c/   1049977379  0     0     0       3770      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... WDTIMER
* FILENAME...... wdtim_cfgb.c
* DATE CREATED.. Fri 07/28/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*  CREATED:		07/28/2000
*  LAST MODIFIED:	(IM) 01/02/2001 Modified for Amadeus
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the WDTIMER module)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

/****************************************\
* include files
\****************************************/  
#include <csl_chiphal.h>
 
#if (_WDTIMA_SUPPORT)

#include <csl_wdtim.h> 

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* WDTIM static macro declarations
\****************************************/
/* See csl_wdtim.h Romability */
 
 
/****************************************\
* WDTIMER static typedef declarations
\****************************************/

/****************************************\
* WDTIMER static function declarations
\****************************************/

/****************************************\
* WDTIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See timer.h */


             
/****************************************\
* WDTIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* WDTIMER global variable definitions
\****************************************/
/* Definition See csl_wdtim.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see which if any timer devices  */
/* are in use by BIOS. These symbols will be defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* WDTIMER global function definitions
\****************************************/

#pragma CODE_SECTION(WDTIM_configArgs,".text:WDTIM_configArgs")

/*----------------------------------------------------------------------------*/
void WDTIM_configArgs(Uint16 wdtcr, Uint16 wdtcr2, Uint16 wdprd) {
  int old_intm;
  Uint16 tcr2_val = wdtcr2 & (_WDTIM_WDTCR2_WDEN_CLR & _WDTIM_WDTCR2_WDKEY_CLR);

   old_intm = IRQ_globalDisable(); 
    
   WDTIM_RSET(WDPRD,wdprd);
   WDTIM_RSET(WDTCR,wdtcr); 
   WDTIM_RSET(WDTCR2,tcr2_val);
  
  IRQ_globalRestore(old_intm);   
}
/*----------------------------------------------------------------------------*/

#endif /* WDTIM_SUPPORT */
/******************************************************************************\
* End of wdtim_cfgb.c
\******************************************************************************/

wdtim_gcfg.c/   1049977381  0     0     0       3680      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... WDTIMER
* FILENAME...... wdtim_gcfg.c
* DATE CREATED.. Fri 07/28/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... 
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*  CREATED:		07/28/2000
*  LAST MODIFIED:	(IM) 01/02/2001 Modified for Amadeus
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the WDTIMER module)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

/****************************************\
* include files
\****************************************/  
#include <csl_chiphal.h>
 
#if (_WDTIMA_SUPPORT)

#include <csl_wdtim.h> 

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* WDTIM static macro declarations
\****************************************/
/* See csl_wdtim.h Romability */
 
 
/****************************************\
* WDTIMER static typedef declarations
\****************************************/

/****************************************\
* WDTIMER static function declarations
\****************************************/

/****************************************\
* WDTIMER Variable definitions : ROMability 
\****************************************/

/* Definition Romability See wdtimer.h */


             
/****************************************\
* WDTIMER static function definitions
\****************************************/

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* WDTIMER global variable definitions
\****************************************/
/* Definition See csl_wdtim.h */
/*----------------------------------------------------------------------------*/
/* DSP/BIOS symbols that CSL needs to check to see what if any timer devices  */
/* are in use by BIOS. These symbols will be defined in the BIOS linker        */
/* command file generated by gconf.                                           */
/* See C6xx */
             
/****************************************\
* WDTIMER global function definitions
\****************************************/

#pragma CODE_SECTION(WDTIM_getConfig,".text:WDTIM_getConfig")

/*----------------------------------------------------------------------------*/
void WDTIM_getConfig(WDTIM_Config *Config) {
  int old_intm;
  old_intm = IRQ_globalDisable();  
  Config->wdtcr2 = WDTIM_RGET(WDTCR2);
  Config->wdprd = WDTIM_RGET(WDPRD);
  Config->wdtcr = WDTIM_RGET(WDTCR);   
  IRQ_globalRestore(old_intm);   
}
/*----------------------------------------------------------------------------*/

#endif /* WDTIM_SUPPORT */
/******************************************************************************\
* End of wdtim_gcfg.c
\******************************************************************************/

wdtim_srvc.c/   1051539300  0     0     0       1799      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... WDTIMER
* FILENAME...... wdtim_srvc.c
* DATE CREATED.. Fri 07/28/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:		07/28/2000.  
*   MODIFIED:	(IM) 01/02/2001 Modified for Amadeus
*   MODIFIED: 08/13/2002 fixed bit-field access problem
*------------------------------------------------------------------------------
* DESCRIPTION:  (Start sequence for Watch Dog Timer, assumes preconfig)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

#include <csl_chiphal.h>

#if (_WDTIMA_SUPPORT)

#include <csl_wdtim.h>

#pragma CODE_SECTION(WDTIM_service,".text:WDTIM_service")

/*----------------------------------------------------------------------------*/
void WDTIM_service() {
 Uint16 old_wdtcr2;
 int old_intm;

  old_intm = IRQ_globalDisable();

  old_wdtcr2 = WDTIM_RGET(WDTCR2);

  WDTIM_FSETS(WDTCR2,WDKEY,PREACTIVE);
  WDTIM_RSET(WDTCR2,
    ((old_wdtcr2 & _WDTIM_WDTCR2_WDKEY_CLR) | _WDTIM_WDTCR2_WDEN_MK(WDTIM_WDTCR2_WDEN_ENABLE) | 
      _WDTIM_WDTCR2_WDKEY_MK(WDTIM_WDTCR2_WDKEY_ACTIVE)));

  IRQ_globalRestore(old_intm);
}
#endif /* WDTIM_SUPPORT */
/******************************************************************************\
* End of wdtim_start.c
\******************************************************************************/


wdtim_start.c/  1049977384  0     0     0       1687      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... WDTIMER
* FILENAME...... wdtim_start.c
* DATE CREATED.. Tu 09/11/2001
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:		09/11/2001.  
*   LAST MODIFIED:	(IM) 01/02/2001 Modified for Amadeus
*------------------------------------------------------------------------------
* DESCRIPTION:  (Start sequence for Watch Dog Timer, assumes preconfig)
*
*
*
\******************************************************************************/
#define _WDTIM_MOD_

#include <csl_chiphal.h>

#if (_WDTIMA_SUPPORT)

#include <csl_wdtim.h>

#pragma CODE_SECTION(WDTIM_start,".text:WDTIM_start")

/*----------------------------------------------------------------------------*/
void WDTIM_start() {
 Uint16 old_wdtcr2;
 int old_intm;

  old_intm = IRQ_globalDisable();

  old_wdtcr2 = WDTIM_RGET(WDTCR2);

  WDTIM_FSETS(WDTCR2,WDKEY,PREACTIVE);
  WDTIM_RSET(WDTCR2,
    ((old_wdtcr2 & _WDTIM_WDTCR2_WDKEY_CLR) | WDTIM_WDTCR2_WDEN_ENABLE | WDTIM_WDTCR2_WDKEY_ACTIVE));

  IRQ_globalRestore(old_intm);
}
#endif /* WDTIM_SUPPORT */
/******************************************************************************\
* End of wdtim_start.c
\******************************************************************************/



_csl.h/         1049976789  0     0     0       1194      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... CFG - HAL configuration module
* FILENAME...... _csl_std.h
* DATE CREATED.. 03/11/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       08/9/2001 
*------------------------------------------------------------------------------
* DESCRIPTION:  (Internal standard header file for all Modules)
*
*
*
\******************************************************************************/


#ifndef __CSL_STD_H_
#define __CSL_STD_H_

#include <csl_chiphal.h>
#include <csl_datasz.h>
#include <csl_csldat.h>
#include <csl_irq.h>
#include <csl_err.h>

#endif
/******************************************************************************\
* End of _csl.h
\******************************************************************************/

_csl_gpio.h/    1049976791  0     0     0       9514      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... _csl_gpio.h
* DATE CREATED.. Fri 06/09/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. 
* VERSION....... 1.00
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:    06/09/2000 created for C5510
*   MODIFIED:   04/16/2001 updated module name and other header comments
*   MODIFIED:   01/22/2002 fixed pinDir and pinWrit so they dont affect
*                          just PIN0
*   MODIFIED:   04/04/2002 added GPIO_PIN definitions
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GPIO module)
*
*
*
\******************************************************************************/
#ifndef _GPIO_H_
#define _GPIO_H_

#include <_csl.h>
#include <csl_gpiohal.h>

#if (_GPIO_SUPPORT) | (_GPIO_PGPIO_SUPPORT)
/****************************************\
* GIO scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _GPIO_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/****************************************\
* GIO static macro declarations          
\****************************************/
 
#define GPIO_DEV0    (0)

#if (!(_GPIO_PGPIO_SUPPORT))
#define GPIO_PIN0            (((Uint32)(GPIO_GPIO) << 16) | 0x0001u)
#define GPIO_PIN1            (((Uint32)(GPIO_GPIO) << 16) | 0x0002u)
#define GPIO_PIN2            (((Uint32)(GPIO_GPIO) << 16) | 0x0004u)
#define GPIO_PIN3            (((Uint32)(GPIO_GPIO) << 16) | 0x0008u)
#define GPIO_PIN4            (((Uint32)(GPIO_GPIO) << 16) | 0x0010u)
#define GPIO_PIN5            (((Uint32)(GPIO_GPIO) << 16) | 0x0020u)
#define GPIO_PIN6            (((Uint32)(GPIO_GPIO) << 16) | 0x0040u)
#define GPIO_PIN7            (((Uint32)(GPIO_GPIO) << 16) | 0x0080u)

#define GPIO_INPUT           (0x0000u)
#define GPIO_OUTPUT          (0x0001u)
#endif

/* Configure GIO (General Purpose I/O) Pins */
#define GPIO_IODIR_IODIR0_EN         (0x0001u)
#define GPIO_IODIR_IODIR1_EN         (0x0002u)
#define GPIO_IODIR_IODIR2_EN         (0x0004u)
#define GPIO_IODIR_IODIR3_EN         (0x0008u)
#define GPIO_IODIR_IODIR4_EN         (0x0010u)
#define GPIO_IODIR_IODIR5_EN         (0x0020u)
#define GPIO_IODIR_IODIR6_EN         (0x0040u)
#define GPIO_IODIR_IODIR7_EN         (0x0080u)

#define GPIO_IODIR_IODIR0            (0x0001u)
#define GPIO_IODIR_IODIR1            (0x0002u)
#define GPIO_IODIR_IODIR2            (0x0004u)
#define GPIO_IODIR_IODIR3            (0x0008u)
#define GPIO_IODIR_IODIR4            (0x0010u)
#define GPIO_IODIR_IODIR5            (0x0020u)
#define GPIO_IODIR_IODIR6            (0x0040u)
#define GPIO_IODIR_IODIR7            (0x0080u)

#define GPIO_IODIR_IO0DIR            (0x0001u)
#define GPIO_IODIR_IO1DIR            (0x0002u)
#define GPIO_IODIR_IO2DIR            (0x0004u)
#define GPIO_IODIR_IO3DIR            (0x0008u)
#define GPIO_IODIR_IO4DIR            (0x0010u)
#define GPIO_IODIR_IO5DIR            (0x0020u)
#define GPIO_IODIR_IO6DIR            (0x0040u)
#define GPIO_IODIR_IO7DIR            (0x0080u)

#define GPIO_IODATA_IOD0_O	       (0x0001u)
#define GPIO_IODATA_IOD1_O           (0x0002u)
#define GPIO_IODATA_IOD2_O           (0x0004u)
#define GPIO_IODATA_IOD3_O           (0x0008u)
#define GPIO_IODATA_IOD4_O           (0x0010u)
#define GPIO_IODATA_IOD5_O           (0x0020u)
#define GPIO_IODATA_IOD6_O           (0x0040u)
#define GPIO_IODATA_IOD7_O           (0x0080u)

#define GPIO_IODATA_IO0DIR_OUTPUT	 (0x0001u)
#define GPIO_IODATA_IO1DIR_OUTPUT    (0x0002u)
#define GPIO_IODATA_IO2DIR_OUTPUT    (0x0004u)
#define GPIO_IODATA_IO3DIR_OUTPUT    (0x0008u)
#define GPIO_IODATA_IO4DIR_OUTPUT    (0x0010u)
#define GPIO_IODATA_IO5DIR_OUTPUT    (0x0020u)
#define GPIO_IODATA_IO6DIR_OUTPUT    (0x0040u)
#define GPIO_IODATA_IO7DIR_OUTPUT    (0x0080u)


#define GPIO_IODATA_IOD0_I           (0x0000u)
#define GPIO_IODATA_IOD1_I           (0x0000u)
#define GPIO_IODATA_IOD2_I           (0x0000u)
#define GPIO_IODATA_IOD3_I           (0x0000u)
#define GPIO_IODATA_IOD4_I           (0x0000u)
#define GPIO_IODATA_IOD5_I           (0x0000u)
#define GPIO_IODATA_IOD6_I           (0x0000u)
#define GPIO_IODATA_IOD7_I           (0x0000u)

#define GPIO_IODATA_IO0DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO1DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO2DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO3DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO4DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO5DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO6DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO7DIR_INPUT      (0x0000u)

/****************************************\
* GIO static typedef declarations
\****************************************/
/*******************************************\
* GIO: global macro definition : ROMABILITY
\*******************************************/  
/* Reserved ROM Area by giodata.h */     

/*===========================================================================*\
*  GPIO IODIR Macros
*
* Fields:
*  (RW) IO7DIR
*  (RW) IO6DIR
*  (RW) IO5DIR
*  (RW) IO4DIR
*  (RW) IO3DIR
*  (RW) IO2DIR
*  (RW) IO1DIR
*  (RW) IO0DIR
\*==========================================================================*/



/*---------------------------------------*\
* GPIO_IODIR_MK Macro
\*---------------------------------------*/

#define GPIO_IODIR_RMK(io7, io6, io5, io4, io3,\
                        io2, io1, io0 )\
  (Uint16) ( GPIO_FMK(IODIR,IO7DIR,io7)    |\
             GPIO_FMK(IODIR,IO6DIR,io6)    |\
             GPIO_FMK(IODIR,IO5DIR,io5)    |\
             GPIO_FMK(IODIR,IO4DIR,io4)    |\
             GPIO_FMK(IODIR,IO3DIR,io3)    |\
             GPIO_FMK(IODIR,IO2DIR,io2)    |\
             GPIO_FMK(IODIR,IO1DIR,io1)    |\
             GPIO_FMK(IODIR,IO0DIR,io0)    \
)

/*===========================================================================*\
* GPIO IODATA
*
* Fields:
*  (RW) IO7D
*  (RW) IO6D
*  (RW) IO5D
*  (RW) IO4D
*  (RW) IO3D
*  (RW) IO2D
*  (RW) IO1D
*  (RW) IO0D
\*==========================================================================*/

/*---------------------------------------*\
* GPIO_IODATA_MK Macro
\*---------------------------------------*/

#define GPIO_IODATA_RMK(io0,io1,io2,io3,io4,io5,io6,io7)(\
(Uint16) (	GPIO_FMK(IODATA,IO0D,io0) |	\
		GPIO_FMK(IODATA,IO1D,io1) |	\
		GPIO_FMK(IODATA,IO2D,io2) |	\
		GPIO_FMK(IODATA,IO3D,io3) |	\
		GPIO_FMK(IODATA,IO4D,io4) |	\
		GPIO_FMK(IODATA,IO5D,io5) |	\
		GPIO_FMK(IODATA,IO6D,io6) |	\
		GPIO_FMK(IODATA,IO7D,io7) 	\
	   ))

/***************************************\
* Overload GPIO functions
\***************************************/
#define GPIO_pinEnable        _GPIO_pinEnable
#define GPIO_pinDisable       _GPIO_pinDisable
#define GPIO_pinDirection     _GPIO_pinDirection
#define GPIO_pinRead          _GPIO_pinRead
#define GPIO_pinWrite         _GPIO_pinWrite

/****************************************\
* GIO function declarations        
\****************************************/
IDECL  int _GPIO_pinEnable(Uint32 pinId);
IDECL  int _GPIO_pinDisable(Uint32 pinId);
IDECL  int _GPIO_pinDirection(Uint32 pinId, Uint16 direction);
IDECL  int _GPIO_pinRead(Uint32 pinId);
IDECL  int _GPIO_pinWrite(Uint32 pinId, Uint16 val);

/****************************************\
* GPIO Inline Functions
\****************************************/

#ifdef USEDEFS

/*------------------------------------------------------*/
IDEF int _GPIO_pinEnable(Uint32 pinId){
  return 1;
}
/*------------------------------------------------------*/
IDEF int _GPIO_pinDisable(Uint32 pinId){
  return 1;
}
/*------------------------------------------------------*/
IDEF int _GPIO_pinDirection(Uint32 pinId, Uint16 direction){
   Uint16 pin = (Uint16)(pinId & 0xFFFFu);
  _GPIO_IODIR = (_GPIO_IODIR & ~(pin)) | ((direction) ? pin:0);
  return ((_GPIO_IODIR & pin) ? 1:0);
}
/*------------------------------------------------------*/
IDEF int _GPIO_pinRead(Uint32 pinId){
  Uint16 pin = (Uint16)(pinId & 0xFFFFu);
  return ((_GPIO_IODIR & pin) ? 1:0);
}
/*------------------------------------------------------*/
IDEF int _GPIO_pinWrite(Uint32 pinId, Uint16 val){
  Uint16 pin = (Uint16)(pinId & 0xFFFFu);
  _GPIO_IODIR = (_GPIO_IODIR & (~pin)) | ((val) ? pin:0);
  return ((_GPIO_IODIR & pin) ? 1:0);
}
#endif  // USEDEFS

#else
  #ifndef _GPIO_MOD_ 			/* GPIO_SUPPORT */
    #error GPIO Module Not Supported on Specified Target TEST!!!  
  #endif
#endif 					/* GPIO_SUPPORT */

#endif 					/* _GPIO_H_ */
/******************************************************************************\
* End of _csl_gpio.h
\******************************************************************************/
_csl_gpiodat.h/ 1051539356  0     0     0       1192      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpiodat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   
*   MODIFIED: 10 APril 2003 added reference for CSL_GpioData for .csldata size
*                          fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GIO module)
*       Reserved Area for GIO Data 
*
*
\******************************************************************************/
#ifndef _GPIO_DATA_H_
  #define _GPIO_DATA_H_
  #define CSL_GPIODATAINIT\
  { 0x0000u }

  typedef struct {
   Uint16 GpioReserved;
  } CSL_GpioDataObj;

extern CSL_GpioDataObj CSL_GpioData;

#define CSL_GPIO_DATA  CSL_GpioData

#endif
_csl_gpiohal.h/ 1049976793  0     0     0       11843     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... _csl_gpiohal.h
* DATE CREATED.. Mon 06/05/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. csl_stdinc.h, csl_chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       06/05/2000 (AP) created
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments  
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the GPIO module)
*
* Registers Covered:
*   (RW) _GPIO_IODIR
*   (RW) _GPIO_IODATA
\******************************************************************************/

#ifndef _GPIOHAL_H_
#define _GPIOHAL_H_

#include <csl_chiphal.h>

#if (_GPIO_SUPPORT)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _GPIO_IODIR
\*============================================================================*/
#define _GPIO_IODIR_ADDR				(0x3400u)
#define _GPIO_IODIR                       	PREG16(_GPIO_IODIR_ADDR)
#define _IODIR                              	_GPIO_IODIR

/*============================================================================*\
* (RW) _GPIO_IODATA
\*============================================================================*/
#define _GPIO_IODATA_ADDR				(0x3401u)
#define _GPIO_IODATA                       	PREG16(_GPIO_IODATA_ADDR)
#define _IODATA                              	_GPIO_IODATA

/*============================================================================*\
* Generic GPIO register/field get and set macros
\*============================================================================*/


/*===========================================================================*\
* _GPIO_IODIR
*
* Fields:
*  (RW) _GPIO_IODIR_IO7DIR
*  (RW) _GPIO_IODIR_IO6DIR
*  (RW) _GPIO_IODIR_IO5DIR
*  (RW) _GPIO_IODIR_IO4DIR
*  (RW) _GPIO_IODIR_IO3DIR
*  (RW) _GPIO_IODIR_IO2DIR
*  (RW) _GPIO_IODIR_IO1DIR
*  (RW) _GPIO_IODIR_IO0DIR
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO7DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO7DIR_SHIFT		(0x0007u)
#define _GPIO_IODIR_IO7DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO7DIR_SHIFT)
#define _GPIO_IODIR_IO7DIR_MASK       	(_GPIO_IODIR_IO7DIR_MK(0x0001u))
#define _GPIO_IODIR_IO7DIR_CLR        	(~(_GPIO_IODIR_IO7DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO6DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO6DIR_SHIFT		(0x0006u)
#define _GPIO_IODIR_IO6DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO6DIR_SHIFT)
#define _GPIO_IODIR_IO6DIR_MASK       	(_GPIO_IODIR_IO6DIR_MK(0x0001u))
#define _GPIO_IODIR_IO6DIR_CLR        	(~(_GPIO_IODIR_IO6DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO5DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO5DIR_SHIFT		(0x0005u)
#define _GPIO_IODIR_IO5DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO5DIR_SHIFT)
#define _GPIO_IODIR_IO5DIR_MASK       	(_GPIO_IODIR_IO5DIR_MK(0x0001u))
#define _GPIO_IODIR_IO5DIR_CLR        	(~(_GPIO_IODIR_IO5DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO4DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO4DIR_SHIFT		(0x0004u)
#define _GPIO_IODIR_IO4DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO4DIR_SHIFT)
#define _GPIO_IODIR_IO4DIR_MASK       	(_GPIO_IODIR_IO4DIR_MK(0x0001u))
#define _GPIO_IODIR_IO4DIR_CLR        	(~(_GPIO_IODIR_IO4DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO3DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO3DIR_SHIFT		(0x0003u)
#define _GPIO_IODIR_IO3DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO3DIR_SHIFT)
#define _GPIO_IODIR_IO3DIR_MASK       	(_GPIO_IODIR_IO3DIR_MK(0x0001u))
#define _GPIO_IODIR_IO3DIR_CLR        	(~(_GPIO_IODIR_IO3DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO2DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO2DIR_SHIFT		(0x0002u)
#define _GPIO_IODIR_IO2DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO2DIR_SHIFT)
#define _GPIO_IODIR_IO2DIR_MASK       	(_GPIO_IODIR_IO2DIR_MK(0x0001u))
#define _GPIO_IODIR_IO2DIR_CLR        	(~(_GPIO_IODIR_IO2DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO1DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO1DIR_SHIFT		(0x0001u)
#define _GPIO_IODIR_IO1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO1DIR_SHIFT)
#define _GPIO_IODIR_IO1DIR_MASK       	(_GPIO_IODIR_IO1DIR_MK(0x0001u))
#define _GPIO_IODIR_IO1DIR_CLR        	(~(_GPIO_IODIR_IO1DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO0DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO0DIR_SHIFT		(0x0000u)
#define _GPIO_IODIR_IO0DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO0DIR_SHIFT)
#define _GPIO_IODIR_IO0DIR_MASK       	(_GPIO_IODIR_IO0DIR_MK(0x0001u))
#define _GPIO_IODIR_IO0DIR_CLR        	(~(_GPIO_IODIR_IO0DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODIR_ADDR,						\
    		(Uint16) (	_GPIO_IODIR_IO0DIR_MK(io0) 		|	\
				_GPIO_IODIR_IO1DIR_MK(io1) 		|	\
				_GPIO_IODIR_IO2DIR_MK(io2) 		|	\
				_GPIO_IODIR_IO3DIR_MK(io3) 		|	\
				_GPIO_IODIR_IO4DIR_MK(io4) 		|	\
				_GPIO_IODIR_IO5DIR_MK(io5) 		|	\
				_GPIO_IODIR_IO6DIR_MK(io6) 		|	\
				_GPIO_IODIR_IO7DIR_MK(io7) 			\
	             ))

/*===========================================================================*\
* _GPIO_IODATA
*
* Fields:
*  (RW) _GPIO_IODATA_IO7D
*  (RW) _GPIO_IODATA_IO6D
*  (RW) _GPIO_IODATA_IO5D
*  (RW) _GPIO_IODATA_IO4D
*  (RW) _GPIO_IODATA_IO3D
*  (RW) _GPIO_IODATA_IO2D
*  (RW) _GPIO_IODATA_IO1D
*  (RW) _GPIO_IODATA_IO0D
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO7D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO7D_SHIFT		(0x0007u)
#define _GPIO_IODATA_IO7D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO7D_SHIFT)
#define _GPIO_IODATA_IO7D_MASK       	(_GPIO_IODATA_IO7D_MK(0x0001u))
#define _GPIO_IODATA_IO7D_CLR        	(~(_GPIO_IODATA_IO7D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO6D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO6D_SHIFT		(0x0006u)
#define _GPIO_IODATA_IO6D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO6D_SHIFT)
#define _GPIO_IODATA_IO6D_MASK       	(_GPIO_IODATA_IO6D_MK(0x0001u))
#define _GPIO_IODATA_IO6D_CLR        	(~(_GPIO_IODATA_IO6D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO5D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO5D_SHIFT		(0x0005u)
#define _GPIO_IODATA_IO5D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO5D_SHIFT)
#define _GPIO_IODATA_IO5D_MASK       	(_GPIO_IODATA_IO5D_MK(0x0001u))
#define _GPIO_IODATA_IO5D_CLR        	(~(_GPIO_IODATA_IO5D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO4D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO4D_SHIFT		(0x0004u)
#define _GPIO_IODATA_IO4D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO4D_SHIFT)
#define _GPIO_IODATA_IO4D_MASK       	(_GPIO_IODATA_IO4D_MK(0x0001u))
#define _GPIO_IODATA_IO4D_CLR        	(~(_GPIO_IODATA_IO4D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO3D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO3D_SHIFT		(0x0003u)
#define _GPIO_IODATA_IO3D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO3D_SHIFT)
#define _GPIO_IODATA_IO3D_MASK       	(_GPIO_IODATA_IO3D_MK(0x0001u))
#define _GPIO_IODATA_IO3D_CLR        	(~(_GPIO_IODATA_IO3D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO2D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO2D_SHIFT		(0x0002u)
#define _GPIO_IODATA_IO2D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO2D_SHIFT)
#define _GPIO_IODATA_IO2D_MASK       	(_GPIO_IODATA_IO2D_MK(0x0001u))
#define _GPIO_IODATA_IO2D_CLR        	(~(_GPIO_IODATA_IO2D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO1D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO1D_SHIFT		(0x0001u)
#define _GPIO_IODATA_IO1D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO1D_SHIFT)
#define _GPIO_IODATA_IO1D_MASK       	(_GPIO_IODATA_IO1D_MK(0x0001u))
#define _GPIO_IODATA_IO1D_CLR        	(~(_GPIO_IODATA_IO1D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO0D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO0D_SHIFT		(0x0000u)
#define _GPIO_IODATA_IO0D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO0D_SHIFT)
#define _GPIO_IODATA_IO0D_MASK       	(_GPIO_IODATA_IO0D_MK(0x0001u))
#define _GPIO_IODATA_IO0D_CLR        	(~(_GPIO_IODATA_IO0D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODATA_ADDR,						\
    		(Uint16) (	_GPIO_IODATA_IO0D_MK(io0) 		|	\
				_GPIO_IODATA_IO1D_MK(io1) 		|	\
				_GPIO_IODATA_IO2D_MK(io2) 		|	\
				_GPIO_IODATA_IO3D_MK(io3) 		|	\
				_GPIO_IODATA_IO4D_MK(io4) 		|	\
				_GPIO_IODATA_IO5D_MK(io5) 		|	\
				_GPIO_IODATA_IO6D_MK(io6) 		|	\
				_GPIO_IODATA_IO7D_MK(io7) 			\
	             ))

#else
    #ifndef _GPIO_MOD_
	#error GPIO Hal Module Not Supported on Specified Target
    #endif
#endif
#endif

_csl_pgpio.h/   1074509095  0     0     0       22490     `
 /******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PGPIO
* FILENAME...... csl_pgpio.h
* DATE CREATED.. Fri 06/09/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. 
* VERSION....... 1.00
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:         06/09/2000 created for C5510
*   LAST MODIFIED:   04/16/2001 updated module name and other header comments
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the PGPIO module,
*                which manipulaes pins that have powerdown/idle enable modes)
*
*
*
\******************************************************************************/
#ifndef _PGPIO_H_
#define _PGPIO_H_

#include <_csl.h>
#include <_csl_gpiohal.h>
#include <_csl_pgpiohal.h>
#include <_csl_pgpiodat.h>


#if (_GPIO_PGPIO_SUPPORT)
/****************************************\
* GIO scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _GPIO_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/****************************************\
* GIO static macro declarations          
\****************************************/
 
#define GPIO_DEV0    (0)


#define GPIO_INPUT                (0)
#define GPIO_OUTPUT               (1)

/* Define Pin ID's for All Possible GPIO Pins */

#define GPIO_GPIO                 (0x0000u)
#define GPIO_AGPIO                (0x1000u)


#define GPIO_PIN0            (((Uint32)(GPIO_GPIO) << 16) | 0x0001u)
#define GPIO_PIN1            (((Uint32)(GPIO_GPIO) << 16) | 0x0002u)
#define GPIO_PIN2            (((Uint32)(GPIO_GPIO) << 16) | 0x0004u)
#define GPIO_PIN3            (((Uint32)(GPIO_GPIO) << 16) | 0x0008u)
#define GPIO_PIN4            (((Uint32)(GPIO_GPIO) << 16) | 0x0010u)
#define GPIO_PIN5            (((Uint32)(GPIO_GPIO) << 16) | 0x0020u)
#define GPIO_PIN6            (((Uint32)(GPIO_GPIO) << 16) | 0x0040u)
#define GPIO_PIN7            (((Uint32)(GPIO_GPIO) << 16) | 0x0080u)
#define GPIO_PIN8            (((Uint32)(GPIO_GPIO) << 16) | 0x0100u)
#define GPIO_PIN9            (((Uint32)(GPIO_GPIO) << 16) | 0x0200u)
#define GPIO_PIN10           (((Uint32)(GPIO_GPIO) << 16) | 0x0400u)
#define GPIO_PIN11           (((Uint32)(GPIO_GPIO) << 16) | 0x0800u)
#define GPIO_PIN12           (((Uint32)(GPIO_GPIO) << 16) | 0x1000u)
#define GPIO_PIN13           (((Uint32)(GPIO_GPIO) << 16) | 0x2000u)

#define AGPIO_PIN0           (((Uint32)(GPIO_AGPIO) << 16) | 0x0001u)
#define AGPIO_PIN1           (((Uint32)(GPIO_AGPIO) << 16) | 0x0002u)
#define AGPIO_PIN2           (((Uint32)(GPIO_AGPIO) << 16) | 0x0004u)
#define AGPIO_PIN3           (((Uint32)(GPIO_AGPIO) << 16) | 0x0008u)
#define AGPIO_PIN4           (((Uint32)(GPIO_AGPIO) << 16) | 0x0010u)
#define AGPIO_PIN5           (((Uint32)(GPIO_AGPIO) << 16) | 0x0020u)
#define AGPIO_PIN6           (((Uint32)(GPIO_AGPIO) << 16) | 0x0040u)
#define AGPIO_PIN7           (((Uint32)(GPIO_AGPIO) << 16) | 0x0080u)
#define AGPIO_PIN8           (((Uint32)(GPIO_AGPIO) << 16) | 0x0100u)
#define AGPIO_PIN9           (((Uint32)(GPIO_AGPIO) << 16) | 0x0200u)
#define AGPIO_PIN10          (((Uint32)(GPIO_AGPIO) << 16) | 0x0400u)
#define AGPIO_PIN11          (((Uint32)(GPIO_AGPIO) << 16) | 0x0800u)
#define AGPIO_PIN12          (((Uint32)(GPIO_AGPIO) << 16) | 0x1000u)
#define AGPIO_PIN13          (((Uint32)(GPIO_AGPIO) << 16) | 0x2000u)
#define AGPIO_PIN14          (((Uint32)(GPIO_AGPIO) << 16) | 0x4000u)
#define AGPIO_PIN15          (((Uint32)(GPIO_AGPIO) << 16) | 0x8000u)



/* Configure GIO (General Purpose I/O) Pins */
#define GPIO_IODIR_IO0_EN         (0x00000001u)
#define GPIO_IODIR_IO1_EN         (0x00000002u)
#define GPIO_IODIR_IO2_EN         (0x00000004u)
#define GPIO_IODIR_IO3_EN         (0x00000008u)
#define GPIO_IODIR_IO4_EN         (0x00000010u)
#define GPIO_IODIR_IO5_EN         (0x00000020u)
#define GPIO_IODIR_IO6_EN         (0x00000040u)
#define GPIO_IODIR_IO7_EN         (0x00000080u)
#define GPIO_IODIR_IO8_EN         (0x00010000u)
#define GPIO_IODIR_IO9_EN         (0x00020000u)
#define GPIO_IODIR_IO10_EN        (0x00040000u)
#define GPIO_IODIR_IO11_EN        (0x00080000u)
#define GPIO_IODIR_IO12_EN        (0x00100000u)
#define GPIO_IODIR_IO13_EN        (0x00200000u)

#define GPIO_IODIR_IODIR0         (0x0001u)
#define GPIO_IODIR_IODIR1         (0x0002u)
#define GPIO_IODIR_IODIR2         (0x0004u)
#define GPIO_IODIR_IODIR3         (0x0008u)
#define GPIO_IODIR_IODIR4         (0x0010u)
#define GPIO_IODIR_IODIR5         (0x0020u)
#define GPIO_IODIR_IODIR6         (0x0040u)
#define GPIO_IODIR_IODIR7         (0x0080u)
#define GPIO_IODIR_IODIR8         (0x00010000u)
#define GPIO_IODIR_IODIR9         (0x00020000u)
#define GPIO_IODIR_IODIR10        (0x00040000u)
#define GPIO_IODIR_IODIR11        (0x00080000u)
#define GPIO_IODIR_IODIR12        (0x00100000u)
#define GPIO_IODIR_IODIR13        (0x00200000u)

#define GPIO_IODIR_IO0DIR         (0x0001u)
#define GPIO_IODIR_IO1DIR         (0x0002u)
#define GPIO_IODIR_IO2DIR         (0x0004u)
#define GPIO_IODIR_IO3DIR         (0x0008u)
#define GPIO_IODIR_IO4DIR         (0x0010u)
#define GPIO_IODIR_IO5DIR         (0x0020u)
#define GPIO_IODIR_IO6DIR         (0x0040u)
#define GPIO_IODIR_IO7DIR         (0x0080u)
#define GPIO_IODIR_IO8DIR         (0x00010000u)
#define GPIO_IODIR_IO9DIR         (0x00020000u)
#define GPIO_IODIR_IO10DIR        (0x00040000u)
#define GPIO_IODIR_IO11DIR        (0x00080000u)
#define GPIO_IODIR_IO12DIR        (0x00100000u)
#define GPIO_IODIR_IO13DIR        (0x00200000u)

#define GPIO_IODATA_IOD0_O	    (0x00000001u)
#define GPIO_IODATA_IOD1_O        (0x00000002u)
#define GPIO_IODATA_IOD2_O        (0x00000004u)
#define GPIO_IODATA_IOD3_O        (0x00000008u)
#define GPIO_IODATA_IOD4_O        (0x00000010u)
#define GPIO_IODATA_IOD5_O        (0x00000020u)
#define GPIO_IODATA_IOD6_O        (0x00000040u)
#define GPIO_IODATA_IOD7_O        (0x00000080u)
#define GPIO_IODATA_IOD8_O        (0x00010000u)
#define GPIO_IODATA_IOD9_O        (0x00020000u)
#define GPIO_IODATA_IOD10_O       (0x00040000u)
#define GPIO_IODATA_IOD11_O       (0x00080000u)
#define GPIO_IODATA_IOD12_O       (0x00100000u)
#define GPIO_IODATA_IOD13_O       (0x00200000u)

#define GPIO_IODATA_IO0D_OUTPUT   (0x00000001u)
#define GPIO_IODATA_IO1D_OUTPUT   (0x00000002u)
#define GPIO_IODATA_IO2D_OUTPUT   (0x00000004u)
#define GPIO_IODATA_IO3D_OUTPUT   (0x00000008u)
#define GPIO_IODATA_IO4D_OUTPUT   (0x00000010u)
#define GPIO_IODATA_IO5D_OUTPUT   (0x00000020u)
#define GPIO_IODATA_IO6D_OUTPUT   (0x00000040u)
#define GPIO_IODATA_IO7D_OUTPUT   (0x00000080u)
#define GPIO_IODATA_IO8D_OUTPUT   (0x00010000u)
#define GPIO_IODATA_IO9D_OUTPUT   (0x00020000u)
#define GPIO_IODATA_IO10D_OUTPUT  (0x00040000u)
#define GPIO_IODATA_IO11D_OUTPUT  (0x00080000u)
#define GPIO_IODATA_IO12D_OUTPUT  (0x00100000u)
#define GPIO_IODATA_IO13D_OUTPUT  (0x00200000u)

#define GPIO_IODATA_IOD0_I        (0x00000000u)
#define GPIO_IODATA_IOD1_I        (0x00000000u)
#define GPIO_IODATA_IOD2_I        (0x00000000u)
#define GPIO_IODATA_IOD3_I        (0x00000000u)
#define GPIO_IODATA_IOD4_I        (0x00000000u)
#define GPIO_IODATA_IOD5_I        (0x00000000u)
#define GPIO_IODATA_IOD6_I        (0x00000000u)
#define GPIO_IODATA_IOD7_I        (0x00000000u)
#define GPIO_IODATA_IOD8_I        (0x00000000u)
#define GPIO_IODATA_IOD9_I        (0x00000000u)
#define GPIO_IODATA_IOD10_I       (0x00000000u)
#define GPIO_IODATA_IOD11_I       (0x00000000u)
#define GPIO_IODATA_IOD12_I       (0x00000000u)
#define GPIO_IODATA_IOD13_I       (0x00000000u)

#define GPIO_IODATA_IO0D_INPUT   (0x00000000u)
#define GPIO_IODATA_IO1D_INPUT   (0x00000000u)
#define GPIO_IODATA_IO2D_INPUT   (0x00000000u)
#define GPIO_IODATA_IO3D_INPUT   (0x00000000u)
#define GPIO_IODATA_IO4D_INPUT   (0x00000000u)
#define GPIO_IODATA_IO5D_INPUT   (0x00000000u)
#define GPIO_IODATA_IO6D_INPUT   (0x00000000u)
#define GPIO_IODATA_IO7D_INPUT   (0x00000000u)
#define GPIO_IODATA_IO8D_INPUT   (0x00000000u)
#define GPIO_IODATA_IO9D_INPUT   (0x00000000u)
#define GPIO_IODATA_IO10D_INPUT  (0x00000000u)
#define GPIO_IODATA_IO11D_INPUT  (0x00000000u)
#define GPIO_IODATA_IO12D_INPUT  (0x00000000u)
#define GPIO_IODATA_IO13D_INPUT  (0x00000000u)


/****************************************\
* GIO static typedef declarations
\****************************************/
/*******************************************\
* GIO: global macro definition : ROMABILITY
\*******************************************/  
/* Reserved ROM Area by giodata.h */ 
    
/*===========================================================================*\
*  GPIO IODIR Macros
*
* Fields:
*  (RW) IO7DIR
*  (RW) IO6DIR
*  (RW) IO5DIR
*  (RW) IO4DIR
*  (RW) IO3DIR
*  (RW) IO2DIR
*  (RW) IO1DIR
*  (RW) IO0DIR
\*==========================================================================*/



/*---------------------------------------*\
* GPIO_IODIR_MK Macro
\*---------------------------------------*/

#define GPIO_IODIR_RMK(io7, io6, io5, io4, io3,\
                        io2, io1, io0 )\
  (Uint16) ( GPIO_FMK(IODIR,IO7DIR,io7)    |\
             GPIO_FMK(IODIR,IO6DIR,io6)    |\
             GPIO_FMK(IODIR,IO5DIR,io5)    |\
             GPIO_FMK(IODIR,IO4DIR,io4)    |\
             GPIO_FMK(IODIR,IO3DIR,io3)    |\
             GPIO_FMK(IODIR,IO2DIR,io2)    |\
             GPIO_FMK(IODIR,IO1DIR,io1)    |\
             GPIO_FMK(IODIR,IO0DIR,io0)    \
)

#define GPIO_IODIR_RMKS(io7, io6, io5, io4, io3,\
                        io2, io1, io0 )\
  (Uint16) ( GPIO_FMKS(IODIR,IO7DIR,io7)    |\
             GPIO_FMKS(IODIR,IO6DIR,io6)    |\
             GPIO_FMKS(IODIR,IO5DIR,io5)    |\
             GPIO_FMKS(IODIR,IO4DIR,io4)    |\
             GPIO_FMKS(IODIR,IO3DIR,io3)    |\
             GPIO_FMKS(IODIR,IO2DIR,io2)    |\
             GPIO_FMKS(IODIR,IO1DIR,io1)    |\
             GPIO_FMKS(IODIR,IO0DIR,io0)    \
)

/*===========================================================================*\
* GPIO IODATA
*
* Fields:
*  (RW) IO7D
*  (RW) IO6D
*  (RW) IO5D
*  (RW) IO4D
*  (RW) IO3D
*  (RW) IO2D
*  (RW) IO1D
*  (RW) IO0D
\*==========================================================================*/

/*---------------------------------------*\
* GPIO_IODATA_MK Macro
\*---------------------------------------*/

#define GPIO_IODATA_RMK(io0,io1,io2,io3,io4,io5,io6,io7)(\
(Uint16) (	GPIO_FMK(IODATA,IO0D,io0) 		|	\
		GPIO_FMK(IODATA,IO1D,io1) 		|	\
		GPIO_FMK(IODATA,IO2D,io2) 		|	\
		GPIO_FMK(IODATA,IO3D,io3) 		|	\
		GPIO_FMK(IODATA,IO4D,io4) 		|	\
		GPIO_FMK(IODATA,IO5D,io5) 		|	\
		GPIO_FMK(IODATA,IO6D,io6) 		|	\
		GPIO_FMK(IODATA,IO7D,io7) 			\
	   ))

#define GPIO_IODATA_RMKS(io0,io1,io2,io3,io4,io5,io6,io7)(\
(Uint16) (	GPIO_FMKS(IODATA,IO0D,io0) 		|	\
		GPIO_FMKS(IODATA,IO1D,io1) 		|	\
		GPIO_FMKS(IODATA,IO2D,io2) 		|	\
		GPIO_FMKS(IODATA,IO3D,io3) 		|	\
		GPIO_FMKS(IODATA,IO4D,io4) 		|	\
		GPIO_FMKS(IODATA,IO5D,io5) 		|	\
		GPIO_FMKS(IODATA,IO6D,io6) 		|	\
		GPIO_FMKS(IODATA,IO7D,io7) 			\
	   ))

/*===========================================================================*\
*  GPIO GPIODIR Macros
*
* Fields:
*  (RW) IO7DIR
*  (RW) IO6DIR
*  (RW) IO5DIR
*  (RW) IO4DIR
*  (RW) IO3DIR
*  (RW) IO2DIR
*  (RW) IO1DIR
*  (RW) IO0DIR
*  (RW) IO8DIR
*  (RW) IO9DIR
*  (RW) IO10DIR
*  (RW) IO11DIR
*  (RW) IO12DIR
*  (RW) IO13DIR
\*==========================================================================*/



/*---------------------------------------*\
* GPIO_GPIODIR0_RMK Macro
\*---------------------------------------*/

#define GPIO_GPIODIR_RMK(io8, io9, io10, io11, io12,io13)\
  (Uint16) ( GPIO_FMK(GPIODIR,IO8DIR,io8)    |\
             GPIO_FMK(GPIODIR,IO9DIR,io9)    |\
             GPIO_FMK(GPIODIR,IO10DIR,io10)  |\
             GPIO_FMK(GPIODIR,IO11DIR,io11)  |\
             GPIO_FMK(GPIODIR,IO12DIR,io12)  |\
             GPIO_FMK(GPIODIR,IO13DIR,io13)  \
)

#define GPIO_GPIOEN_RMK(io8, io9, io10, io11, io12, io13)\
  (Uint16) ( GPIO_FMK(GPIOEN,IO8,io8)    |\
             GPIO_FMK(GPIOEN,IO9,io9)    |\
             GPIO_FMK(GPIOEN,IO10,io10)  |\
             GPIO_FMK(GPIOEN,IO11,io11)  |\
             GPIO_FMK(GPIOEN,IO12,io12)  |\
             GPIO_FMK(GPIOEN,IO13,io13)  \
)

#define GPIO_GPIODIR_RMKS(io8, io9, io10, io11, io12,io13)\
  (Uint16) ( GPIO_FMKS(GPIODIR,IO8DIR,io8)    |\
             GPIO_FMKS(GPIODIR,IO9DIR,io9)    |\
             GPIO_FMKS(GPIODIR,IO10DIR,io10)  |\
             GPIO_FMKS(GPIODIR,IO11DIR,io11)  |\
             GPIO_FMKS(GPIODIR,IO12DIR,io12)  |\
             GPIO_FMKS(GPIODIR,IO13DIR,io13)  \
)

#define GPIO_GPIOEN_RMKS(io8, io9, io10, io11, io12, io13)\
  (Uint16) ( GPIO_FMKS(GPIOEN,IO8,io8)    |\
             GPIO_FMKS(GPIOEN,IO9,io9)    |\
             GPIO_FMKS(GPIOEN,IO10,io10)  |\
             GPIO_FMKS(GPIOEN,IO11,io11)  |\
             GPIO_FMKS(GPIOEN,IO12,io12)  |\
             GPIO_FMKS(GPIOEN,IO13,io13)  \
)

/*===========================================================================*\
* GPIO GPIODATA
*
* Fields:
*  (RW) IO7D
*  (RW) IO6D
*  (RW) IO5D
*  (RW) IO4D
*  (RW) IO3D
*  (RW) IO2D
*  (RW) IO1D
*  (RW) IO0D
*  (RW) IO8D
*  (RW) IO9D
*  (RW) I010D
*  (RW) IO11D
*  (RW) IO12D
*  (RW) IO13D
\*==========================================================================*/

/*---------------------------------------*\
* GPIO_GPIODATA_RMK Macro
\*---------------------------------------*/
#define GPIO_GPIODATA_RMK(io8,io9,io10,io11,io12,io13)(\
(Uint16) (	GPIO_FMK(GPIODATA,IO8D,io8) 	 |\
		GPIO_FMK(GPIODATA,IO9D,io9) 	 |\
		GPIO_FMK(GPIODATA,IO10D,io10) |\
		GPIO_FMK(GPIODATA,IO11D,io11) |\
		GPIO_FMK(GPIODATA,IO12D,io12) |\
		GPIO_FMK(GPIODATA,IO13D,io13) \
	   ))

#define GPIO_GPIODATA_RMKS(io8,io9,io10,io11,io12,io13)(\
(Uint16) (	GPIO_FMKS(GPIODATA,IO8D,io8)   |\
		GPIO_FMKS(GPIODATA,IO9D,io9)   |\
		GPIO_FMKS(GPIODATA,IO10D,io10) |\
		GPIO_FMKS(GPIODATA,IO11D,io11) |\
		GPIO_FMKS(GPIODATA,IO12D,io12) |\
		GPIO_FMKS(GPIODATA,IO13D,io13) \
	   ))

#define GPIO_AGPIODATA_RMK(io8,io9,io10,io11,io12,io13)(\
(Uint16) (	GPIO_FMK(AGPIODATA,IO8D,io8) 	 |\
		GPIO_FMK(AGPIODATA,IO9D,io9) 	 |\
		GPIO_FMK(AGPIODATA,IO10D,io10) |\
		GPIO_FMK(AGPIODATA,IO11D,io11) |\
		GPIO_FMK(AGPIODATA,IO12D,io12) |\
		GPIO_FMK(AGPIODATA,IO13D,io13) \
	   ))

#define GPIO_AGPIODATA_RMKS(io8,io9,io10,io11,io12,io13)(\
(Uint16) (	GPIO_FMKS(AGPIODATA,IO8D,io8)   |\
		GPIO_FMKS(AGPIODATA,IO9D,io9)   |\
		GPIO_FMKS(AGPIODATA,IO10D,io10) |\
		GPIO_FMKS(AGPIODATA,IO11D,io11) |\
		GPIO_FMKS(AGPIODATA,IO12D,io12) |\
		GPIO_FMKS(AGPIODATA,IO13D,io13) \
	   ))

#define GPIO_AGPIOEN_RMK(io8, io9, io10, io11, io12, io13)\
  (Uint16) ( GPIO_FMK(AGPIOEN,IO8,io8)    |\
             GPIO_FMK(AGPIOEN,IO9,io9)    |\
             GPIO_FMK(AGPIOEN,IO10,io10)  |\
             GPIO_FMK(AGPIOEN,IO11,io11)  |\
             GPIO_FMK(AGPIOEN,IO12,io12)  |\
             GPIO_FMK(AGPIOEN,IO13,io13)  \
)
#define GPIO_AGPIOEN_RMKS(io8, io9, io10, io11, io12, io13)\
  (Uint16) ( GPIO_FMKS(AGPIOEN,IO8,io8)    |\
             GPIO_FMKS(AGPIOEN,IO9,io9)    |\
             GPIO_FMKS(AGPIOEN,IO10,io10)  |\
             GPIO_FMKS(AGPIOEN,IO11,io11)  |\
             GPIO_FMKS(AGPIOEN,IO12,io12)  |\
             GPIO_FMKS(AGPIOEN,IO13,io13)  \
)

#define GPIO_AGPIODIR_RMK(io8, io9, io10, io11, io12, io13)\
  (Uint16) ( GPIO_FMK(AGPIODIR,IO8DIR,io8)    |\
             GPIO_FMK(AGPIODIR,IO9DIR,io9)    |\
             GPIO_FMK(AGPIODIR,IO10DIR,io10)  |\
             GPIO_FMK(AGPIODIR,IO11DIR,io11)  |\
             GPIO_FMK(AGPIODIR,IO12DIR,io12)  |\
             GPIO_FMK(AGPIODIR,IO13DIR,io13)  \
)

#define GPIO_AGPIODIR_RMKS(io8, io9, io10, io11, io12, io13)\
  (Uint16) ( GPIO_FMKS(AGPIODIR,IO8DIR,io8)    |\
             GPIO_FMKS(AGPIODIR,IO9DIR,io9)    |\
             GPIO_FMKS(AGPIODIR,IO10DIR,io10)  |\
             GPIO_FMKS(AGPIODIR,IO11DIR,io11)  |\
             GPIO_FMKS(AGPIODIR,IO12DIR,io12)  |\
             GPIO_FMKS(AGPIODIR,IO13DIR,io13)  \
)

/****************************************\
* Overload GPIO pin functions           
\****************************************/

#define GPIO_pinEnable              _PGPIO_pinEnable
#define GPIO_pinDisable             _PGPIO_pinDisable
#define GPIO_pinDirection           _PGPIO_pinDirection
#define GPIO_pinRead                _PGPIO_pinRead
#define GPIO_pinWrite               _PGPIO_pinWrite

/****************************************\
* GPIO function declarations        
\****************************************/
IDECL int _PGPIO_pinEnable(Uint32 pinId);
IDECL int _PGPIO_pinDisable(Uint32 pinId);
IDECL int _PGPIO_pinDirection(Uint32 pinId, Uint16 direction);
IDECL int _PGPIO_pinRead(Uint32 pinId);
IDECL int _PGPIO_pinWrite(Uint32 pinId, Uint16 value);


/*****************************************\
* GPIO Inline Functions
\*****************************************/

#ifdef  USEDEFS

/*------------------------------------------------------------------------------*/
IDEF int _PGPIO_pinEnable(Uint32 pinId) {
  Uint16 dev = ((pinId >> 16) & 0xffffu);
  Uint16 pin = (pinId & 0xffffu);
  Uint16 pin2;

   switch (dev) {
    case GPIO_GPIO: 
                        pin2 = (pinId >> 8) & 0x3fu;
                        _GPIO_GPIOEN |= pin2;
                        return _GPIO_GPIOEN;

    case GPIO_AGPIO:   
                        _GPIO_AGPIOEN |= pin;
                        return  _GPIO_AGPIOEN;

    default:            return 0;
 }
}

/*----------------------------------------------------------------------------*/
IDEF int _PGPIO_pinDisable(Uint32 pinId) {
  Uint16 dev = ((pinId >> 16) & 0xffffu);
  Uint16 pin = (pinId & 0xffffu);
  Uint16 pin2;

   switch (dev) {
    case GPIO_GPIO: 
                        pin2 = ((pin >> 8) & 0x3fu);
                        _GPIO_GPIOEN &= ~(pin2);
                        return ((_GPIO_GPIOEN & pin2) ? 1:0);

    case GPIO_AGPIO:   
                        _GPIO_AGPIOEN &= ~(pin);
                        return  ((_GPIO_AGPIOEN & pin) ? 1:0);

 
    default:            return 0;
 }
}
/*----------------------------------------------------------------------------*/
IDEF int _PGPIO_pinDirection(Uint32 pinId, Uint16 direction) {
  Uint16 dev = ((pinId >> 16) & 0xffffu);
  Uint16 pin = (Uint16)(pinId & 0xffffu);
  Uint16 pin1, pin2;
   switch (dev) {
    case GPIO_GPIO: 
                         pin1 = pinId & 0xffu;
                         pin2 = (pinId >> 8) & 0x3fu;
                        if (pin1) {
                           _GPIO_IODIR = (_GPIO_IODIR & (~(pin1)))
                                         | ((direction) ? pin1:0);
                           return ((_GPIO_IODIR & pin1) ? 1:0);
                        }
                        _GPIO_GPIODIR = (_GPIO_GPIODIR & (~(pin2)))
                                        | ((direction)?  pin2:0);
                        return ((_GPIO_GPIODIR & pin2)? 1:0);

    case GPIO_AGPIO:   
                        _GPIO_AGPIODIR = (_GPIO_AGPIODIR & (~(pin))) 
                                          | ((direction)? pin:0);
                        return ((_GPIO_AGPIODIR & pin) ? 1:0);

    default:            return 0;
  }
}
/*----------------------------------------------------------------------------*/
IDEF int _PGPIO_pinWrite(Uint32 pinId, Uint16 val) {
  Uint16 dev = ((pinId >> 16) & 0xffffu);
  Uint16 pin = (pinId & 0xffffu);
  Uint16 pin1,pin2;

   switch (dev) {
    case GPIO_GPIO: 
                        pin1 = (Uint16)(pin & 0xffu);
                        pin2 = (Uint16)((pin >> 8) & 0x3fu);
                        if (pin1) {
                            _GPIO_IODATA = (_GPIO_IODATA & (~pin1)) 
                                           | ((val) ? pin1:0);
                           return ((_GPIO_IODATA & pin1)? 1:0);
                        }
                        _GPIO_GPIODATA = (_GPIO_GPIODATA & (~(pin2)))
                                         | ((val)? pin2:0);
                        return ((_GPIO_GPIODATA & pin2)? 1:0);
    case GPIO_AGPIO:   
                        _GPIO_AGPIODATA = (_GPIO_AGPIODATA & ~pin) | 
                                         ((val) ? pin:0);
                        return  ((_GPIO_AGPIODATA & pin) ? 1:0);

    default:            return 0;
 }
}
/*----------------------------------------------------------------------------*/
IDEF int _PGPIO_pinRead(Uint32 pinId) {
  Uint16 dev = ((pinId >> 16) & 0xffffu);
  Uint16 pin = (pinId & 0xffffu);
  Uint16 pin1,pin2,val;

   switch (dev) {
    case GPIO_GPIO: 
                       pin1 = (pin & 0xffu);
                       pin2 = ((pin >> 8) & 0x3fu);
                       if (pin1) {
                          val = (_GPIO_IODATA & (pin1)) & (0xffu);
                       }
                       else {
                          val = ((_GPIO_GPIODATA & (pin2)) & 0x3fu);
                       }
                       return ((val) ? 1:0);
    case GPIO_AGPIO:   
                       return  ((_GPIO_AGPIODATA & pin) ? 1:0);

 
    default:           return 0;
  }
}
#endif   /* USEDEFS */
#else
  #ifndef _GPIO_MOD_ 			/* PGPIO_SUPPORT */
     #error PGPIO Module Not Supported on Specified Target TEST!!!
  #endif  
#endif 					/* PGPIO_SUPPORT */

#endif
/******************************************************************************\
* End of csl_PGPIO.h
\******************************************************************************/
_csl_pgpiodat.h/1051539354  0     0     0       1220      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PGPIO
* FILENAME...... _csl_pgpiodat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... Chip Suport Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   
*   MODIFIED: 10 Apr 2003 added reference for CSL_GpioData for .csldata size
*                         fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GIO module)
*       Reserved Area for GIO Data 
*
*
\******************************************************************************/
#ifndef _GPIO_DATA_H_
  #define _GPIO_DATA_H_


  #define CSL_GPIODATAINIT\
  { 0x0000u } /* Reserved */
 


  typedef struct {
    Uint16 gpioReserved;
  } CSL_GpioDataObj;

extern CSL_GpioDataObj   CSL_GpioData;

#define CSL_GPIO_DATA    CSL_GpioData

#endif
_csl_pgpiohal.h/1049976799  0     0     0       27935     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_pgpiohal.h
* DATE CREATED.. Mon 06/05/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. csl_stdinc.h, csl_chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       06/05/2000 (AP) created
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments  
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the GPIO module)
*
* Registers Covered:
*   (RW) _GPIO_GPIOEN
*   (RW) _GPIO_AGPIOEN
*   (RW) _GPIO_GPIODIR
*   (RW) _GPIO_AGPIODIR
*   (RW) _GPIO_GPIODATA
*   (RW) _GPIO_AGPIODATA
\******************************************************************************/

#ifndef _PGPIOHAL_H_
#define _PGPIOHAL_H_

#include <csl_chiphal.h>

#if (_GPIO_PGPIO_SUPPORT)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _GPIO_AGPIOEN
\*============================================================================*/
#define _GPIO_AGPIOEN_ADDR				(0x4400u)
#define _GPIO_AGPIOEN                       	PREG16(_GPIO_AGPIOEN_ADDR)
#define _AGPIOEN                              	_GPIO_AGPIOEN

/*============================================================================*\
* (RW) _GPIO_AGPIODIR
\*============================================================================*/
#define _GPIO_AGPIODIR_ADDR				(0x4401u)
#define _GPIO_AGPIODIR                       	PREG16(_GPIO_AGPIODIR_ADDR)
#define _AGPIODIR                              	_GPIO_AGPIODIR

/*============================================================================*\
* (RW) _GPIO_AGPIODATA
\*============================================================================*/
#define _GPIO_AGPIODATA_ADDR				(0x4402u)
#define _GPIO_AGPIODATA                       	PREG16(_GPIO_AGPIODATA_ADDR)
#define _AGPIODATA                            	_GPIO_AGPIODATA

/*============================================================================*\
* (RW) _GPIO_GPIOEN
\*============================================================================*/
#define _GPIO_GPIOEN_ADDR				(0x4403u)
#define _GPIO_GPIOEN                       	PREG16(_GPIO_GPIOEN_ADDR)
#define _GPIOEN                              	_GPIO_GPIOEN

/*============================================================================*\
* (RW) _GPIO_GPIODIR
\*============================================================================*/
#define _GPIO_GPIODIR_ADDR				(0x4404u)
#define _GPIO_GPIODIR                       	PREG16(_GPIO_GPIODIR_ADDR)
#define _GPIODIR                              	_GPIO_GPIODIR

/*============================================================================*\
* (RW) _GPIO_GPIODATA
\*============================================================================*/
#define _GPIO_GPIODATA_ADDR				(0x4405u)
#define _GPIO_GPIODATA                       	PREG16(_GPIO_GPIODATA_ADDR)
#define _GPIODATA                            	_GPIO_GPIODATA


/*============================================================================*\
* Generic GPIO register/field get and set macros
\*============================================================================*/

#define GPIO_ADDR(Reg)                    _GPIO_##Reg##_ADDR
#define GPIO_RGET(Reg)                    _PREG_GET(GPIO_ADDR(##Reg))
#define GPIO_RSET(Reg,Val)                _PREG_SET(GPIO_ADDR(##Reg),Val)
#define GPIO_RAOI(Reg,AND,OR,INV)         _PREG_AOI(GPIO_ADDR(##Reg),AND,OR,INV)
#define GPIO_FGET(Reg,Field)              _PFIELD_GET(GPIO_ADDR(##Reg),_GPIO_##Reg##_##Field)
#define GPIO_FSET(Reg,Field,Val)\
   _PFIELD_SET(GPIO_ADDR(Reg), _GPIO_##Reg##_##Field, Val)
#define GPIO_FSETS(Reg,Field,Sym)\
   GPIO_FSET(Reg,##Field,GPIO_##Reg##_##Field##_##Sym)
#define GPIO_FAOI(Reg,Field,AND,OR,INV)  _PFIELD_AOI(GPIO_ADDR(Reg),_GPIO_##Reg##_##Field,AND,OR,INV)
#define GPIO_FMK(Reg,Field,Val)          _GPIO_##Reg##_##Field##_MK(Val)
#define GPIO_FMKS(Reg,Field,Sym)         GPIO_FMK(##Reg,##Field,GPIO_##Reg##_##Field##_##Sym)


/*===========================================================================*\
* _GPIO_GPIODIR
*
* Fields:
*  (RW) _GPIO_GPIODIR_IO13DIR
*  (RW) _GPIO_GPIODIR_IO12DIR
*  (RW) _GPIO_GPIODIR_IO11DIR
*  (RW) _GPIO_GPIODIR_IO10DIR
*  (RW) _GPIO_GPIODIR_IO9DIR
*  (RW) _GPIO_GPIODIR_IO8DIR
\*==========================================================================*/


/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO13DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO13DIR_SHIFT		(0x0005u)
#define _GPIO_GPIODIR_IO13DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO13DIR_SHIFT)
#define _GPIO_GPIODIR_IO13DIR_MASK       	(_GPIO_GPIODIR_IO13DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO13DIR_CLR        	(~(_GPIO_GPIODIR_IO13DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO12DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO12DIR_SHIFT		(0x0004u)
#define _GPIO_GPIODIR_IO12DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO12DIR_SHIFT)
#define _GPIO_GPIODIR_IO12DIR_MASK       	(_GPIO_GPIODIR_IO12DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO12DIR_CLR        	(~(_GPIO_GPIODIR_IO12DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO11DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO11DIR_SHIFT		(0x0003u)
#define _GPIO_GPIODIR_IO11DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO11DIR_SHIFT)
#define _GPIO_GPIODIR_IO11DIR_MASK       	(_GPIO_GPIODIR_IO11DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO11DIR_CLR        	(~(_GPIO_GPIODIR_IO11DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO10DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO10DIR_SHIFT		(0x0002u)
#define _GPIO_GPIODIR_IO10DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO10DIR_SHIFT)
#define _GPIO_GPIODIR_IO10DIR_MASK       	(_GPIO_GPIODIR_IO10DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO10DIR_CLR        	(~(_GPIO_GPIODIR_IO10DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO9DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO9DIR_SHIFT		(0x0001u)
#define _GPIO_GPIODIR_IO9DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO9DIR_SHIFT)
#define _GPIO_GPIODIR_IO9DIR_MASK       	(_GPIO_GPIODIR_IO9DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO9DIR_CLR        	(~(_GPIO_GPIODIR_IO9DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO8DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO8DIR_SHIFT		(0x0000u)
#define _GPIO_GPIODIR_IO8DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO8DIR_SHIFT)
#define _GPIO_GPIODIR_IO8DIR_MASK       	(_GPIO_GPIODIR_IO8DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO8DIR_CLR        	(~(_GPIO_GPIODIR_IO8DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_CFG(io8,io9,io10,io11,io12,io13)  \
	HPREG_SET(_GPIO_GPIODIR_ADDR,						\
    		(Uint16) (	_GPIO_GPIODIR_IO0DIR_MK(io8) 		|	\
				_GPIO_GPIODIR_IO1DIR_MK(io9) 		|	\
				_GPIO_GPIODIR_IO2DIR_MK(io10) 		|	\
				_GPIO_GPIODIR_IO3DIR_MK(io11) 		|	\
				_GPIO_GPIODIR_IO4DIR_MK(io12) 		|	\
				_GPIO_GPIODIR_IO5DIR_MK(io13) 		|	\
				_GPIO_GPIODIR_IO6DIR_MK(io14) 		|	\
				_GPIO_GPIODIR_IO7DIR_MK(io15) 			\
	             ))

/*===========================================================================*\
* _GPIO_GPIODATA
*
* Fields:
*  (RW) _GPIO_GPIODATA_IO13D
*  (RW) _GPIO_GPIODATA_IO12D
*  (RW) _GPIO_GPIODATA_IO11D
*  (RW) _GPIO_GPIODATA_IO10D
*  (RW) _GPIO_GPIODATA_IO9D
*  (RW) _GPIO_GPIODATA_IO8D
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO13D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO13D_SHIFT		(0x0005u)
#define _GPIO_GPIODATA_IO13D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO13D_SHIFT)
#define _GPIO_GPIODATA_IO13D_MASK       	(_GPIO_GPIODATA_IO13D_MK(0x0001u))
#define _GPIO_GPIODATA_IO13D_CLR        	(~(_GPIO_GPIODATA_IO13D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO12D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO12D_SHIFT		(0x0004u)
#define _GPIO_GPIODATA_IO12D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO12D_SHIFT)
#define _GPIO_GPIODATA_IO12D_MASK       	(_GPIO_GPIODATA_IO12D_MK(0x0001u))
#define _GPIO_GPIODATA_IO12D_CLR        	(~(_GPIO_GPIODATA_IO12D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO11D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO11D_SHIFT		(0x0003u)
#define _GPIO_GPIODATA_IO11D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO11D_SHIFT)
#define _GPIO_GPIODATA_IO11D_MASK       	(_GPIO_GPIODATA_IO11D_MK(0x0001u))
#define _GPIO_GPIODATA_IO11D_CLR        	(~(_GPIO_GPIODATA_IO11D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO10D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO10D_SHIFT		(0x0002u)
#define _GPIO_GPIODATA_IO10D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO10D_SHIFT)
#define _GPIO_GPIODATA_IO10D_MASK       	(_GPIO_GPIODATA_IO10D_MK(0x0001u))
#define _GPIO_GPIODATA_IO10D_CLR        	(~(_GPIO_GPIODATA_IO10D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO9D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO9D_SHIFT		(0x0001u)
#define _GPIO_GPIODATA_IO9D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO9D_SHIFT)
#define _GPIO_GPIODATA_IO9D_MASK       	(_GPIO_GPIODATA_IO9D_MK(0x0001u))
#define _GPIO_GPIODATA_IO9D_CLR        	(~(_GPIO_GPIODATA_IO9D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO8D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO8D_SHIFT		(0x0000u)
#define _GPIO_GPIODATA_IO8D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO8D_SHIFT)
#define _GPIO_GPIODATA_IO8D_MASK       	(_GPIO_GPIODATA_IO8D_MK(0x0001u))
#define _GPIO_GPIODATA_IO8D_CLR        	(~(_GPIO_GPIODATA_IO8D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_CFG(io8,io9,io10,io11,io12,io13)  \
	HPREG_SET(_GPIO_GPIODATA_ADDR,						\
    		(Uint16) (	_GPIO_GPIODATA_IO8D_MK(io8) 		|	\
				_GPIO_GPIODATA_IO9D_MK(io9) 		|	\
				_GPIO_GPIODATA_IO10D_MK(io10) 		|	\
				_GPIO_GPIODATA_IO11D_MK(io11) 		|	\
				_GPIO_GPIODATA_IO12D_MK(io12) 		|	\
				_GPIO_GPIODATA_IO13D_MK(io13) 			\
	             ))

/*===========================================================================*\
* _GPIO_GPIOEN
*
* Fields:
*  (RW) _GPIO_GPIOEN_IO13
*  (RW) _GPIO_GPIOEN_IO12
*  (RW) _GPIO_GPIOEN_IO11
*  (RW) _GPIO_GPIOEN_IO10
*  (RW) _GPIO_GPIOEN_IO9
*  (RW) _GPIO_GPIOEN_IO8
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO13
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO13_SHIFT		(0x0005u)
#define _GPIO_GPIOEN_IO13_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO13_SHIFT)
#define _GPIO_GPIOEN_IO13_MASK       	(_GPIO_GPIOEN_IO13_MK(0x0001u))
#define _GPIO_GPIOEN_IO13_CLR        	(~(_GPIO_GPIOEN_IO13_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO12
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO12_SHIFT		(0x0004u)
#define _GPIO_GPIOEN_IO12_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO12_SHIFT)
#define _GPIO_GPIOEN_IO12_MASK       	(_GPIO_GPIOEN_IO12_MK(0x0001u))
#define _GPIO_GPIOEN_IO12_CLR        	(~(_GPIO_GPIOEN_IO12_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO11
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO11_SHIFT		(0x0003u)
#define _GPIO_GPIOEN_IO11_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO11_SHIFT)
#define _GPIO_GPIOEN_IO11_MASK       	(_GPIO_GPIOEN_IO11_MK(0x0001u))
#define _GPIO_GPIOEN_IO11_CLR        	(~(_GPIO_GPIOEN_IO11_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO10
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO10_SHIFT		(0x0002u)
#define _GPIO_GPIOEN_IO10_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO10_SHIFT)
#define _GPIO_GPIOEN_IO10_MASK       	(_GPIO_GPIOEN_IO10_MK(0x0001u))
#define _GPIO_GPIOEN_IO10_CLR        	(~(_GPIO_GPIOEN_IO10_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO9
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO9_SHIFT		(0x0001u)
#define _GPIO_GPIOEN_IO9_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO9_SHIFT)
#define _GPIO_GPIOEN_IO9_MASK       	(_GPIO_GPIOEN_IO9_MK(0x0001u))
#define _GPIO_GPIOEN_IO9_CLR        	(~(_GPIO_GPIOEN_IO9_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO8D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO8_SHIFT		(0x0000u)
#define _GPIO_GPIOEN_IO8_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO8_SHIFT)
#define _GPIO_GPIOEN_IO8_MASK       	(_GPIO_GPIOEN_IO8_MK(0x0001u))
#define _GPIO_GPIOEN_IO8_CLR        	(~(_GPIO_GPIOEN_IO8_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_CFG(io8,io9,io10,io11,io12,io13)  \
	HPREG_SET(_GPIO_GPIOEN_ADDR,						\
    		(Uint16) (	_GPIO_GPIOEN_IO8_MK(io8) 		|	\
				_GPIO_GPIOEN_IO9_MK(io9) 		|	\
				_GPIO_GPIOEN_IO10_MK(io10) 		|	\
				_GPIO_GPIOEN_IO11_MK(io11) 		|	\
				_GPIO_GPIOEN_IO12_MK(io12) 		|	\
				_GPIO_GPIOEN_IO13_MK(io13) 			\
	             ))

/*===========================================================================*\
* _GPIO_AGPIODIR
*
* Fields:
*  (RW) _GPIO_AGPIODIR_IO13DIR
*  (RW) _GPIO_AGPIODIR_IO12DIR
*  (RW) _GPIO_AGPIODIR_IO11DIR
*  (RW) _GPIO_AGPIODIR_IO10DIR
*  (RW) _GPIO_AGPIODIR_IO9DIR
*  (RW) _GPIO_AGPIODIR_IO8DIR
\*==========================================================================*/


/*==========================================================================*\
* (RW) _GPIO_AGPIODIR_IO13DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODIR_IO13DIR_SHIFT		(0x0005u)
#define _GPIO_AGPIODIR_IO13DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODIR_IO13DIR_SHIFT)
#define _GPIO_AGPIODIR_IO13DIR_MASK       	(_GPIO_AGPIODIR_IO13DIR_MK(0x0001u))
#define _GPIO_AGPIODIR_IO13DIR_CLR        	(~(_GPIO_AGPIODIR_IO13DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODIR_IO12DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODIR_IO12DIR_SHIFT		(0x0004u)
#define _GPIO_AGPIODIR_IO12DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODIR_IO12DIR_SHIFT)
#define _GPIO_AGPIODIR_IO12DIR_MASK       	(_GPIO_AGPIODIR_IO12DIR_MK(0x0001u))
#define _GPIO_AGPIODIR_IO12DIR_CLR        	(~(_GPIO_AGPIODIR_IO12DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODIR_IO11DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODIR_IO11DIR_SHIFT		(0x0003u)
#define _GPIO_AGPIODIR_IO11DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODIR_IO11DIR_SHIFT)
#define _GPIO_AGPIODIR_IO11DIR_MASK       	(_GPIO_AGPIODIR_IO11DIR_MK(0x0001u))
#define _GPIO_AGPIODIR_IO11DIR_CLR        	(~(_GPIO_AGPIODIR_IO11DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODIR_IO10DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODIR_IO10DIR_SHIFT		(0x0002u)
#define _GPIO_AGPIODIR_IO10DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODIR_IO10DIR_SHIFT)
#define _GPIO_AGPIODIR_IO10DIR_MASK       	(_GPIO_AGPIODIR_IO10DIR_MK(0x0001u))
#define _GPIO_AGPIODIR_IO10DIR_CLR        	(~(_GPIO_AGPIODIR_IO10DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODIR_IO9DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODIR_IO9DIR_SHIFT		(0x0001u)
#define _GPIO_AGPIODIR_IO9DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODIR_IO9DIR_SHIFT)
#define _GPIO_AGPIODIR_IO9DIR_MASK       	(_GPIO_AGPIODIR_IO9DIR_MK(0x0001u))
#define _GPIO_AGPIODIR_IO9DIR_CLR        	(~(_GPIO_AGPIODIR_IO9DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODIR_IO8DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODIR_IO8DIR_SHIFT		(0x0000u)
#define _GPIO_AGPIODIR_IO8DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODIR_IO8DIR_SHIFT)
#define _GPIO_AGPIODIR_IO8DIR_MASK       	(_GPIO_AGPIODIR_IO8DIR_MK(0x0001u))
#define _GPIO_AGPIODIR_IO8DIR_CLR        	(~(_GPIO_AGPIODIR_IO8DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODIR 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODIR_CFG(io8,io9,io10,io11,io12,io13)  \
	HPREG_SET(_GPIO_AGPIODIR_ADDR,						\
    		(Uint16) (	_GPIO_AGPIODIR_IO0DIR_MK(io8) 		|	\
				_GPIO_AGPIODIR_IO1DIR_MK(io9) 		|	\
				_GPIO_AGPIODIR_IO2DIR_MK(io10) 		|	\
				_GPIO_AGPIODIR_IO3DIR_MK(io11) 		|	\
				_GPIO_AGPIODIR_IO4DIR_MK(io12) 		|	\
				_GPIO_AGPIODIR_IO5DIR_MK(io13) 		|	\
				_GPIO_AGPIODIR_IO6DIR_MK(io14) 		|	\
				_GPIO_AGPIODIR_IO7DIR_MK(io15) 			\
	             ))

/*===========================================================================*\
* _GPIO_AGPIODATA
*
* Fields:
*  (RW) _GPIO_AGPIODATA_IO13D
*  (RW) _GPIO_AGPIODATA_IO12D
*  (RW) _GPIO_AGPIODATA_IO11D
*  (RW) _GPIO_AGPIODATA_IO10D
*  (RW) _GPIO_AGPIODATA_IO9D
*  (RW) _GPIO_AGPIODATA_IO8D
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_AGPIODATA_IO13D
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODATA_IO13D_SHIFT		(0x0005u)
#define _GPIO_AGPIODATA_IO13D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODATA_IO13D_SHIFT)
#define _GPIO_AGPIODATA_IO13D_MASK       	(_GPIO_AGPIODATA_IO13D_MK(0x0001u))
#define _GPIO_AGPIODATA_IO13D_CLR        	(~(_GPIO_AGPIODATA_IO13D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODATA_IO12D
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODATA_IO12D_SHIFT		(0x0004u)
#define _GPIO_AGPIODATA_IO12D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODATA_IO12D_SHIFT)
#define _GPIO_AGPIODATA_IO12D_MASK       	(_GPIO_AGPIODATA_IO12D_MK(0x0001u))
#define _GPIO_AGPIODATA_IO12D_CLR        	(~(_GPIO_AGPIODATA_IO12D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODATA_IO11D
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODATA_IO11D_SHIFT		(0x0003u)
#define _GPIO_AGPIODATA_IO11D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODATA_IO11D_SHIFT)
#define _GPIO_AGPIODATA_IO11D_MASK       	(_GPIO_AGPIODATA_IO11D_MK(0x0001u))
#define _GPIO_AGPIODATA_IO11D_CLR        	(~(_GPIO_AGPIODATA_IO11D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODATA_IO10D
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODATA_IO10D_SHIFT		(0x0002u)
#define _GPIO_AGPIODATA_IO10D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODATA_IO10D_SHIFT)
#define _GPIO_AGPIODATA_IO10D_MASK       	(_GPIO_AGPIODATA_IO10D_MK(0x0001u))
#define _GPIO_AGPIODATA_IO10D_CLR        	(~(_GPIO_AGPIODATA_IO10D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODATA_IO9D
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODATA_IO9D_SHIFT		(0x0001u)
#define _GPIO_AGPIODATA_IO9D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODATA_IO9D_SHIFT)
#define _GPIO_AGPIODATA_IO9D_MASK       	(_GPIO_AGPIODATA_IO9D_MK(0x0001u))
#define _GPIO_AGPIODATA_IO9D_CLR        	(~(_GPIO_AGPIODATA_IO9D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODATA_IO8D
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODATA_IO8D_SHIFT		(0x0000u)
#define _GPIO_AGPIODATA_IO8D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIODATA_IO8D_SHIFT)
#define _GPIO_AGPIODATA_IO8D_MASK       	(_GPIO_AGPIODATA_IO8D_MK(0x0001u))
#define _GPIO_AGPIODATA_IO8D_CLR        	(~(_GPIO_AGPIODATA_IO8D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIODATA 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIODATA_CFG(io8,io9,io10,io11,io12,io13)  \
	HPREG_SET(_GPIO_AGPIODATA_ADDR,						\
    		(Uint16) (	_GPIO_AGPIODATA_IO8D_MK(io8) 		|	\
				_GPIO_AGPIODATA_IO9D_MK(io9) 		|	\
				_GPIO_AGPIODATA_IO10D_MK(io10) 		|	\
				_GPIO_AGPIODATA_IO11D_MK(io11) 		|	\
				_GPIO_AGPIODATA_IO12D_MK(io12) 		|	\
				_GPIO_AGPIODATA_IO13D_MK(io13) 			\
	             ))

/*===========================================================================*\
* _GPIO_AGPIOEN
*
* Fields:
*  (RW) _GPIO_AGPIOEN_IO13
*  (RW) _GPIO_AGPIOEN_IO12
*  (RW) _GPIO_AGPIOEN_IO11
*  (RW) _GPIO_AGPIOEN_IO10
*  (RW) _GPIO_AGPIOEN_IO9
*  (RW) _GPIO_AGPIOEN_IO8
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_AGPIOEN_IO13
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIOEN_IO13_SHIFT		(0x0005u)
#define _GPIO_AGPIOEN_IO13_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIOEN_IO13_SHIFT)
#define _GPIO_AGPIOEN_IO13_MASK       	(_GPIO_AGPIOEN_IO13_MK(0x0001u))
#define _GPIO_AGPIOEN_IO13_CLR        	(~(_GPIO_AGPIOEN_IO13_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIOEN_IO12
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIOEN_IO12_SHIFT		(0x0004u)
#define _GPIO_AGPIOEN_IO12_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIOEN_IO12_SHIFT)
#define _GPIO_AGPIOEN_IO12_MASK       	(_GPIO_AGPIOEN_IO12_MK(0x0001u))
#define _GPIO_AGPIOEN_IO12_CLR        	(~(_GPIO_AGPIOEN_IO12_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIOEN_IO11
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIOEN_IO11_SHIFT		(0x0003u)
#define _GPIO_AGPIOEN_IO11_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIOEN_IO11_SHIFT)
#define _GPIO_AGPIOEN_IO11_MASK       	(_GPIO_AGPIOEN_IO11_MK(0x0001u))
#define _GPIO_AGPIOEN_IO11_CLR        	(~(_GPIO_AGPIOEN_IO11_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIOEN_IO10
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIOEN_IO10_SHIFT		(0x0002u)
#define _GPIO_AGPIOEN_IO10_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIOEN_IO10_SHIFT)
#define _GPIO_AGPIOEN_IO10_MASK       	(_GPIO_AGPIOEN_IO10_MK(0x0001u))
#define _GPIO_AGPIOEN_IO10_CLR        	(~(_GPIO_AGPIOEN_IO10_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIOEN_IO9
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIOEN_IO9_SHIFT		(0x0001u)
#define _GPIO_AGPIOEN_IO9_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIOEN_IO9_SHIFT)
#define _GPIO_AGPIOEN_IO9_MASK       	(_GPIO_AGPIOEN_IO9_MK(0x0001u))
#define _GPIO_AGPIOEN_IO9_CLR        	(~(_GPIO_AGPIOEN_IO9_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIOEN_IO8D
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIOEN_IO8_SHIFT		(0x0000u)
#define _GPIO_AGPIOEN_IO8_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_AGPIOEN_IO8_SHIFT)
#define _GPIO_AGPIOEN_IO8_MASK       	(_GPIO_AGPIOEN_IO8_MK(0x0001u))
#define _GPIO_AGPIOEN_IO8_CLR        	(~(_GPIO_AGPIOEN_IO8_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_AGPIOEN 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_AGPIOEN_CFG(io8,io9,io10,io11,io12,io13)  \
	HPREG_SET(_GPIO_AGPIOEN_ADDR,						\
    		(Uint16) (	_GPIO_AGPIOEN_IO8_MK(io8) 		|	\
				_GPIO_AGPIOEN_IO9_MK(io9) 		|	\
				_GPIO_AGPIOEN_IO10_MK(io10) 		|	\
				_GPIO_AGPIOEN_IO11_MK(io11) 		|	\
				_GPIO_AGPIOEN_IO12_MK(io12) 		|	\
				_GPIO_AGPIOEN_IO13_MK(io13) 			\
	             ))

#else
   #ifndef _GPIO_MOD_
	#error GPIO Hal Module Not Supported on Specified Target
   #endif
#endif
#endif

_csl_usb.h/     1049976800  0     0     0       85532     `
/******************************************************************************/
/* File Name: _usb_api.h, 04 Feb 2001                                         */
/*                                                                            */
/* This is proprietary information, not to be published -- TI INTERNAL DATA   */
/* Copyright (C) 1999, Texas Instruments, Inc.  All Rights Reserved.          */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Author: MH                                                                 */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/*                                                                            */
/* Private header file for USB firmware API.                                  */
/* Do not make any changes to the content of this file                        */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/*                                                                            */
/* Modified last: 04 Feb 2001                                                 */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
 
#ifndef __CSL_USB_H
#define __CSL_USB_H

#include <_csl.h>

#if (_USB_SUPPORT)

#include <csl_usbhal.h>
#include <csl_usb.h>
#include <_csl_usbdrvr.h>
#include <_csl_usb_apimap.h>

/******************************************************************************/
/*                                                                            */
/*                          Symbolic Constants                                */
/*                                                                            */
/******************************************************************************/

#define MAX_ENDPT    16                 /* max number of endpoints supported  */

/******************************************************************************/
/*                                                                            */
/*               Initialization constants for USB module config               */
/*                                                                            */
/******************************************************************************/

#define USBIE_INIT        (USB_INT_RSTR|USB_INT_RESR|USB_INT_SUSR|USB_INT_SETUP|USB_INT_STPOW)
/*#define XY_SIZE_INIT      0x40*/
#define USBCNF0_INIT      (USBEPCNF_UBME|USBEPCNF_USBIE)
/*
#define USB_EPXCNF_INIT   (USBEPCNF_DBUF)
*/
#define USBEPCNF_INIT     (USBEPCNF_UBME|USBEPCNF_DBUF|USBEPCNF_USBIE)
#define USBCTL_INIT       (USBCTL_FEN | USBCTL_FRSTE)

/******************************************************************************/
/*                                                                            */
/*               Internal Flags used by USB data transfer APIs                */
/*                                                                            */
/******************************************************************************/

/* 02/15/01 $MH$ - redefined USB_INOUT_FLAGS */
/* Low byte is allocated for user's flags, high byte for internal flags */
/*#define USB_INOUT_FLAGS_NEW      0x0001   */  /* for internal use               */
/*#define USB_INOUT_FLAGS_BYTE     0x0002   */  /* for internal use               */
/*#define USB_INOUT_FLAGS_STALL    0x0004   */  /* for internal use               */
/*#define USB_INOUT_FLAGS_RESET    0x0008   */  /* for internal use               */
/*#define USB_INOUT_FLAGS_DATAREQ  0x0020   */  /* for internal use               */
/*#define USB_INOUT_FLAGS_ISOCH    0x0100   */  /* for internal use               */


/*#define USB_INOUT_FLAGS_NEW      0x0100   */  /* for internal use               */
/*#define USB_INOUT_FLAGS_DATAREQ  0x0200   */  /* for internal use               */ 
/*#define USB_INOUT_FLAGS_BYTE     0x0400   */  /* for internal use               */ 
/*#define USB_INOUT_FLAGS_0BYTREQ  0x0800   */  /* for internal use               */ 
/*#define USB_INOUT_FLAGS_ISO      0x1000   */  /* for internal use - not in use  */ 
/*#define USB_INOUT_FLAGS_STALL    0x2000   */  /* for internal use - not in use  */ 
/*#define USB_INOUT_FLAGS_RESET    0x4000   */  /* for internal use - not in use  */

#define USB_IOFLAG_NEW           0x0100     /* for internal use               */
#define USB_IOFLAG_DATAREQ       0x0200     /* for internal use               */
#define USB_IOFLAG_BYTE          0x0400     /* for internal use               */
#define USB_IOFLAG_0BYTREQ       0x0800     /* for internal use               */
#define USB_IOFLAG_ISO           0x1000     /* for internal use - not in use  */
#define USB_IOFLAG_STALL         0x2000     /* for internal use - not in use  */
#define USB_IOFLAG_RESET         0x4000     /* for internal use - not in use  */

/****************************12/05/00 $MH$*************************************/
/*   Endpoint transfer status indicator for hEp->status field                 */
/*                                                                            */
/*   This symbolic constants not currrently used by the API                   */
/******************************************************************************/

#define USB_IOSTAT_NONE         0x0000    /* none                             */
#define USB_IOSTAT_IN_PROG      0x0001    /* previous transaction in progress */
#define USB_IOSTAT_DONE         0x0002    /* previous transaction done        */

            
/******************************************************************************/
/*                                                                            */
/*                           Enumerated Data Types                            */
/*                                                                            */
/******************************************************************************/           

/****************************12/22/00 $MH$:************************************/
/*   USB_setParams flags - used to selectively config endpoint regs,             */
/*   intrpt regs, firmware env (internal vars) or all                         */
/*                                                                            */
/*   This enum data type is not currrently used by the API                    */
/******************************************************************************/

typedef enum
{
  USB_CFG_FLAG_NONE    = 0x0000,
  USB_CFG_FLAG_NEW_DEV = 0x0001,
  USB_CFG_FLAG_IF_ONLY = 0x0002
  
}USB_CFG_FLAGS;

/******************************************************************************/
/*                                                                            */
/*                             USB_RST_FLAG                                   */
/*                                                                            */
/******************************************************************************/

typedef enum
{
  USB_RST_SOFT = 0,
  USB_RST_HARD = 1
  
}USB_RST_FLAG;


/******************************************************************************/
/*                                                                            */
/*                           USB Data Structures                              */
/*                                                                            */
/******************************************************************************/            
            


/******************************************************************************/
/*                                                                            */
/*                                USB MACROS                                  */
/*                                                                            */
/******************************************************************************/

#define _USB_EN_EP_INTR(DevNum, EpIndex) \
         ((EpIndex & 0x08) ? (USBIEPIE |= (1 << (EpIndex & 0x07))) : \
                             (USBOEPIE |= (1 << (EpIndex & 0x07))))

#define _USB_DIS_EP_INTR(DevNum, EpIndex) \
         ((EpIndex & 0x08) ? (USBIEPIE &= ~(1 << (EpIndex & 0x07))) : \
                             (USBOEPIE &= ~(1 << (EpIndex & 0x07))))
                             
#define _USB_EN_DMA_INTR(DevNum, EpIndex) \
         ((EpIndex & 0x08) ? (USBIDIE |= (1 << (EpIndex & 0x07))) : \
                             (USBODIE |= (1 << (EpIndex & 0x07))))

#define _USB_DIS_DMA_INTR(DevNum, EpIndex) \
         ((EpIndex & 0x08) ? (USBIDIE &= ~(1 << (EpIndex & 0x07))) : \
                             (USBODIE &= ~(1 << (EpIndex & 0x07))))
                             
/******************************************************************************/
/* Name     :  USB_CONNECT                                                    */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Connect the USB module to upstream port (D+ pullup enabled)    */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/* 03/30/01 $MH$ replaced by functoin USB_connectDev(DevNum)                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/

/*#define USB_CONNECT(DevNum) \
 *        (USBCTL |= USBCTL_CONN)                              */

/******************************************************************************/
/* Name     :  USB_DISCONNECT                                                 */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Disconnect the USB module from the upstream port               */
/*             (D+ pullup disabled)                                           */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* 03/30/01 $MH$ replaced by functoin USB_disconnectDev(DevNum)               */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/

/*#define USB_DISCONNECT(DevNum) \
 *        (USBCTL &= ~USBCTL_CONN) */
        
/******************************************************************************/
/* Name     : USB_ISSUE_REMOTE_WAKEUP                                         */
/*                                                                            */
/* Catagory : Device Control                                                  */
/*                                                                            */
/* Purpose  : Issue a remote wakeup signal to the host.                       */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Host must set the remote wake up feature first. An application must chech  */
/* if the remote wake-up feature is before generating a remote wake-up signal */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/

/*#define USB_ISSUE_REMOTE_WAKEUP(DevNum) \
 *        (USBCTL |= USBCTL_RWUP) */

/******************************************************************************/
/* Name     :  USB_RESET                                                      */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Reset the USB module.                                          */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Once the module has been reset, all the control and status registers are   */
/* returned to powerup reset values and the USB module is diconnected from    */
/* the upstream port.                                                         */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/

/*#define USB_RESET(DevNum) \
 *        (USBGCTL |= USBGCTL_RST) */
        
/******************************************************************************/
/* Name     :  USB_ENABLE_BUS_INTRPT                                          */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Enable the USB bus related interrupts defined in USBMSK reg    */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* mask  :    8-bit mask to enable selective interrupts.  Interrupts are      */
/*            if the respective mask bits are set                             */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* USB bus related interrupts are the ones defined in the USB Interrupt Enable*/
/* Register (USBIE)                                                           */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/ 
        
/*#define USB_ENABLE_BUS_INTRPT(DevNum, mask) \
 *        (USBIE |= (mask & 0xFF)) */
        
/******************************************************************************/
/* Name     :  USB_DISABLE_BUS_INTRPT                                         */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Disable the USB bus related interrupts defined in USBMSK reg   */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* mask  :    8-bit mask to disable selective interrupts.  Interrupts are     */
/*            when the mask bits are set                                      */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* USB bus related interrupts are the ones defined in the USB Interrupt Enable*/
/* Register (USBIE)                                                           */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/

/*#define USB_DISABLE_BUS_INTRPT(DevNum, mask) \
 *        (USBIE &= ~(mask & 0xFF)) */
        
/******************************************************************************/
/* Name     :  USB_CLR_BUS_INTRPT_FLAG                                        */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Clear the USB bus related interrupts flag bits of USBIF reg    */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* mask  :    8-bit mask to clear selective interrupts flags. Interrupt flags */
/*            when the respective mask bits are set                           */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* USB bus related interrupts are the ones defined in the USB Interrupt Enable*/
/* Register (USBIE)                                                           */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/
        
/*#define USB_CLR_BUS_INTRPT_FLAG(DevNum, mask) \
 *        (USBIF |= (mask & 0xFF)) */
        
/******************************************************************************/
/* Name     :  USB_CLR_SETUP_EV_FLAG                                          */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Clear the USB setup packet received interrupt flag bit of      */
/*             USBIF reg                                                      */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/

/*#define USB_CLR_SETUP_EV_FLAG(DevNum) \
 *        (USBIF |= USB_INT_SETUP) */
        
/******************************************************************************/
/* Name     :  USB_CLR_STPOW_EV_FLAG                                          */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Clear the USB setup packet overwrite interrupt flag bit of     */
/*             USBIF reg                                                      */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/
        
/*#define USB_CLR_STPOW_EV_FLAG(DevNum) \
 *        (USBIF |= USB_INT_STPOW) */
        
/******************************************************************************/
/* Name     :  USB_SET_EP0_CONT_STALL                                         */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Stall USB control endpoints for indefinite period.             */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Once the stall is set, the controll endpoints will reject all the following*/
/* setup and endpoint 0 tokens until the continous stall is cleared by calling*/
/* USB_CLR_EP0_CONT_STALL macro                                               */
/*                                                                            */
/* It is helpful to stall the control endpoints for indefinite time before    */
/* reading the setup packet to make sure the content of setup data buffer is  */
/* not corrupted by a new setup packet.                                       */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/ 

/*#define USB_SET_EP0_CONT_STALL(DevNum) \
 *        (USBCTL |= USBCTL_SETUP) */
        
/******************************************************************************/
/* Name     :  USB_CLR_EP0_CONT_STALL                                         */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Clear the indefinite stall of the control endpoints.           */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Brings control endpoints out of indefinite stall mode.  Control endpoints  */
/* enters indefinite stall mode when USB_SET_EP0_CONT_STALL macro is called   */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/

/*#define USB_CLR_EP0_CONT_STALL(DevNum) \
 *        (USBIF |= USB_INT_SETUP) */

/******************************************************************************/
/* Name     :  USB_SET_EP0_DATA_DIR                                           */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Sets/Clears the DIR bit of USB Device Control(USBCTL) Register */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* DataDir  : Direction of endpoint 0 data transfer (USB_EP0DataDir type)     */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*             The DIR bit of USBCTL register determines how endpoint 0 should*/
/*             respond to the data and handshake phase of a control transfer  */                     
/*                                                                            */
/*             If the direction is set to EP0_DATA_OUT the USB will expect a  */
/*             OUT packet from the host and the USB module won't generate an  */
/*             interrupt at the end of a 0 byte handshake packet from the     */
/*             target to host.  If the direction is set to EP0_DATA_OUT and   */
/*             an IN token arrives the USB module will stall enpoint 0.       */
/*                                                                            */
/*             If the direction is set to EP0_DATA_IN the USB will expect an  */
/*             IN token from the host and the USB module won't generate an    */
/*             interrupt when a 0 byte handshake packet arrives from the host */
/*             If the direction is set to EP0_DATA_IN and a OUt token arrives */
/*             the USB module will stall the enpoint 0.                       */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/

/*#define USB_SET_EP0_DATA_DIR(DevNun, DataDir) \
 *        ((DataDir) ? (USBCTL |= USBCTL_DIR) : (USBCTL &= ~USBCTL_DIR)) */
        
/******************************************************************************/
/* Name     :  USB_SET_ADDR                                                   */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Set USB device address                                         */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* addr     : 7-bit USB device address                                        */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    05 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/

/*#define USB_SET_ADDR(DevNum, addr) \
 *        (USBADDR = addr & 0x7F) */
        
 
/******************************************************************************/
/* Name     :  USB_GET_FRM_NO                                                 */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Read current USB frame number                                  */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* Current USB Frame Number                                                   */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    07 Feb 2001                                                    */
/*                                                                            */
/******************************************************************************/

/*#define USB_GET_FRM_NO(DevNum) \
 *        (((USBFNUMH & 0x07)<<8) | (USBFNUML & 0xFF)) */




/******************************************************************************/
/*                                                                            */
/*                             USB API Prototypes                             */
/*                                                                            */
/******************************************************************************/

/******************************************************************************/
/* Name     : _USB_resetFirmwareEnv                                           */
/*                                                                            */
/* Catagory : Firmware Initialization (private function)                     */
/*                                                                            */
/* Purpose  : Reset the internal USB firmware variable to a known state       */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the internal firmware variables are reset to a known state,    */
/* else USB_FALSE                                                             */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/

USB_Boolean _USB_resetFirmwareEnv(USB_DevNum DevNum);

/******************************************************************************/
/* Name     : _USB_enableDmaIntrpt                                            */
/*                                                                            */
/* Catagory : Device Initialization (private function)                        */
/*                                                                            */
/* Purpose  : Enable the endpoint DMA interrupt.  Affected endpoint is        */
/*            determined by the endpoint objects passed to the function       */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the endpoint DMA interrupt is successfully enabled,            */
/* else USB_FALSE                                                             */    
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
USB_Boolean _USB_enableDmaIntrpt(USB_DevNum DevNum, USB_EpHandle hEp);

/******************************************************************************/
/* Name     : _USB_disableDmaIntrpt                                           */
/*                                                                            */
/* Catagory : Device Initialization (private function)                       */
/*                                                                            */
/* Purpose  : Disable the endpoint DMA interrupt.  Affected endpoint is       */
/*            determined by the endpoint objects passed to the function       */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the endpoint DMA interrupt is successfully disabled,           */
/* else USB_FALSE                                                             */    
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
USB_Boolean _USB_disableDmaIntrpt(USB_DevNum DevNum, USB_EpHandle hEp);

/******************************************************************************/
/* Name     : _USB_enableEpIntrpt                                             */
/*                                                                            */
/* Catagory : Device Initialization (private function)                       */
/*                                                                            */
/* Purpose  : Enable the endpoint interrupt.  Affected endpoint is determined */
/*            by the endpoint objects passed to the function                  */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the endpoint interrupt is successfully enabled, else USB_FALSE */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
USB_Boolean _USB_enableEpIntrpt(USB_DevNum DevNum, USB_EpHandle hEp);

/******************************************************************************/
/* Name     : _USB_disableEpIntrpt                                            */
/*                                                                            */
/* Catagory : Device Initialization (private function)                       */
/*                                                                            */
/* Purpose  : Disable the endpoint interrupt. Affected endpoint is determined */
/*            by the endpoint objects passed to the function                  */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the endpoint interrupt is successfully disabled,else USB_FALSE */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
USB_Boolean _USB_disableEpIntrpt(USB_DevNum DevNum, USB_EpHandle hEp);

/******************************************************************************/
/* Name     : _USB_configEndpt                                                */
/*                                                                            */
/* Catagory : Initialization (private function)                              */
/*                                                                            */
/* Purpose  : Configure an endpoint descriptor block and DMA registers        */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp          : Handle to an endpoint object to be initialized              */
/*                                                                            */
/* EPxConfRegVal: 8-bit value to be written to Endpoint Config regsiter       */
/*                                                                            */
/* BufBaseAddrX : Xbuffer base address in the USB buffer RAM                  */
/*                                                                            */
/* BufBaseAddrY : Xbuffer base address in the USB buffer RAM                  */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the initialization is successful, else USB_FLASE               */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The event handler should be in void Fxn(void) form. Using the INTERRUPT    */
/* is not necessary.  Once the program control branches to Fxn the user's     */
/* code is free to call other functions or event post DSP?BIOS SWI            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:       24 Nov 2000                                                 */
/*                                                                            */
/******************************************************************************/
USB_Boolean _USB_configEndpt(USB_EpHandle  hEpx,
                             Uint16        EPxConfRegVal,
                             Uint16        BufBaseAddrX,
                             Uint16        BufBaseAddrY);
                             
                             
/******************************************************************************/
/* Name     : _USB_addInterface                                               */
/*                                                                            */
/* Catagory : Device Initialization                                           */
/*                                                                            */
/* Purpose  : Include additional endpoint to the existing configuration       */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEpObj[] : Pointer to a NULL terminated array of handles of initialized    */
/*            endpoint objects.  Max number of handles in the array can not   */
/*            be more than 16 (excluding the NULL handle)                     */
/*                                                                            */
/* NumOfEp  : Number of elements in the hEpObj[] array                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if additional endpoints are successfully added to the existing    */
/* device configuration, else USB_FALSE                                       */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Once USB_init is called, to add another interface to the current device  */
/* call _USB_addInterface( ). This routine only initialize the endpoint       */
/* register and set endpoint dma intrpt mask bits, and updates the            */
/* USB_GlobalVars with endpoint related information.  This routine does not   */
/* reconfig EP0 regs                                                          */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    22 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/

USB_Boolean _USB_addInterface(USB_DevNum DevNum, USB_EpHandle hEpObj[], Uint16 NumOfEp);

/* -----------------10/23/2000 3:29PM----------------
 Software allocated memory locations.
 These are locations within the USB SRAM which are
 hard allocated for use in the USB driver.  These
 locations are essentially global variables which
 cannot be relocated and do not consume any regular
 DSP memory.
 Allocate the memory with:
 #pragma DATA_SECTION (USB_GlobalVars, ".usb$globals");
 USB_GlobalVars_struct USB_GlobalVars;
 --------------------------------------------------*/

/* base address for USB_GlobalVars 0x6580@IO (inside USB
 * buffer RAM  */
/* The base address is in a different location for the DA250 */
/* If removing this causes problems, I need to know in which files -- JDK */
/* #define USB_GLOBALVAR_BASE      0x6580 */

typedef Uint16 USB_EP_HANDLE_VECTOR[3];

/*
02/02/01 $MH$ redefined usb global structure with smaller
number of fields.
allocating gloval vars in the DSP data memory for test purpose
use (1) for test and debug, use (2) in the final version
*/

/* (1)
 * define global vars in data space to work around UBS+DMA+McBSP problem 
 -- $mh$ 02/25/03 */

typedef struct
{
  USB_EP_HANDLE_VECTOR  EpHandleTable[16];
  Uint16                NextEpBuffStartAddr[2];
  USB_Boolean           RemoteWkpStat;
  USB_Boolean           FlagSOF;      
  Uchar                 ActiveEndptNos;

} USB_GlobalVars_struct;

/* (2)
 * define global vars as varaiable in io space.
 
typedef ioport struct
{
  USB_EP_HANDLE_VECTOR  EpHandleTable[16];
  Uint16                NextEpBuffStartAddr[2];
  USB_Boolean           RemoteWkpStat;
  USB_Boolean           FlagSOF;      
  Uchar                 ActiveEndptNos;

} USB_GlobalVars_struct;   */


/******************************************************************************/
/*   03/23/01 $MH$                                                            */
/*                                                                            */
/*                  Vectored Prototypes for USB API                           */
/*                                                                            */
/******************************************************************************/

USB_EVENT_MASK vUSB_getEvents(USB_EpHandle hEp);
USB_EVENT_MASK vUSB_peekEvents(USB_EpHandle hEp);
USB_Boolean vUSB_getSetupPacket(USB_DevNum DevNum, USB_SetupStruct *USB_Setup);
USB_Boolean vUSB_postTransaction(USB_EpHandle    hEp,
                                 Uint16          ByteCnt,
                                 void            *Data,
                                 USB_IOFLAGS     Flags);
USB_Boolean vUSB_isTransactionDone(USB_EpHandle hEp);
USB_BYTE_COUNT vUSB_bytesRemaining(USB_EpHandle hEp);
USB_Boolean vUSB_abortTransaction(USB_EpHandle hEp);
USB_Boolean vUSB_abortAllTransaction(USB_DevNum DevNum);
void vUSB_stallEndpt(USB_EpHandle hEp);
void vUSB_clearEndptStall(USB_EpHandle hEp);
USB_Boolean vUSB_getEndptStall(USB_EpHandle hEp);
USB_EpHandle vUSB_epNumToHandle(USB_DevNum DevNum, Uchar Endpt);
USB_Boolean vUSB_initEndptObj(USB_DevNum     DevNum,
                              USB_EpHandle   hEp,
                              USB_EpNum      EpNum, 
                              USB_XferType   XferType,
                              Uint16         MaxPktSiz,
                              Uint16         EvMsk,
                              USB_EVENT_ISR  Fxn);
USB_Boolean vUSB_init(USB_DevNum    DevNum, 
                      USB_EpHandle  hEpObj[], 
                      Uchar         PSofTmrCnt);
                          
/* 03/30/01 $MH$ */
void vUSB_initPLL(Uint16 inclk, Uint16 outclk, Uint16 plldiv);
void vUSB_connectDev(USB_DevNum DevNum);
void vUSB_disconnectDev(USB_DevNum DevNum);
void vUSB_setRemoteWakeup(USB_DevNum DevNum, USB_Boolean RmtWkpStat);
USB_Boolean vUSB_getRemoteWakeupStat(USB_DevNum DevNum);
USB_Boolean vUSB_issueRemoteWakeup(USB_DevNum DevNum);
void vUSB_resetDev(USB_DevNum DevNum);
void vUSB_setDevAddr(USB_DevNum DevNum, Uchar addr);
Uint16 vUSB_getFrameNo(USB_DevNum DevNum);                          



/******************************************************************************/
/*   03/23/01 $MH$                                                            */
/*                                                                            */
/*                  Vectored Prototypes for USB API(internal)                 */
/*                                                                            */
/******************************************************************************/
USB_Boolean _vUSB_resetFirmwareEnv(USB_DevNum DevNum);
USB_Boolean _vUSB_enableDmaIntrpt(USB_DevNum DevNum, USB_EpHandle hEp);
USB_Boolean _vUSB_disableDmaIntrpt(USB_DevNum DevNum, USB_EpHandle hEp);
USB_Boolean _vUSB_enableEpIntrpt(USB_DevNum DevNum, USB_EpHandle hEp);
USB_Boolean _vUSB_disableEpIntrpt(USB_DevNum DevNum, USB_EpHandle hEp);
USB_Boolean _vUSB_configEndpt(USB_EpHandle  hEpx,
                             Uint16        EPxConfRegVal,
                             Uint16        BufBaseAddrX,
                             Uint16        BufBaseAddrY);
USB_Boolean _vUSB_addInterface(USB_DevNum DevNum, USB_EpHandle hEpObj[], Uint16 NumOfEp);

/* 09/28/01 $MH$ */
void vUSB_evDispatch(void);

#endif

#else   /* _USB_SUPPORT */
  #ifndef _USB_MOD
    error USB Module Not Supported on Specified Target Device
  #endif
#endif

_csl_usb_apimap/1049976801  1     0     0       5037      `
/********************************************************************
** _cls_usb_apimap.h                                               **
**                                                                 **
** Copyright (c) 2003, Texas Instruments, Inc.                     **
** All rights reserved.                                            **
**                                                                 **
** TMS320VC5509 USB API map file                                   **
**                                                                 **
** Author: MH                                                      **
**                                                                 **
*********************************************************************/
#ifndef __CSL_USB_APIMAP_H
#define __CSL_USB_APIMAP_H

#define   USB_getEvents                 vUSB_getEvents              
#define   USB_peekEvents                vUSB_peekEvents                                              
#define   USB_getSetupPacket            vUSB_getSetupPacket                                                                     
#define   USB_postTransaction           vUSB_postTransaction                                                                    
#define   USB_isTransactionDone         vUSB_isTransactionDone                                                                   
#define   USB_bytesRemaining            vUSB_bytesRemaining                                                                     
#define   USB_stallEndpt                vUSB_stallEndpt                                                                         
#define   USB_clearEndptStall           vUSB_clearEndptStall                                                                    
#define   USB_getEndptStall             vUSB_getEndptStall                                                                      
#define   USB_initEndptObj              vUSB_initEndptObj
#define   USB_init                      vUSB_init
#define   USB_epNumToHandle             vUSB_epNumToHandle
#define   USB_abortTransaction          vUSB_abortTransaction                                                                      
#define   USB_abortAllTransaction       vUSB_abortAllTransaction
#define   USB_connectDev                vUSB_connectDev                                                                         
#define   USB_disconnectDev             vUSB_disconnectDev                                                                                                                                     
#define   USB_setRemoteWakeup           vUSB_setRemoteWakeup
#define   USB_getRemoteWakeupStat       vUSB_getRemoteWakeupStat
#define   USB_issueRemoteWakeup         vUSB_issueRemoteWakeup                                                                                                                         
#define   USB_resetDev                  vUSB_resetDev                                                   
#define   USB_setDevAddr                vUSB_setDevAddr                                                                                                                              
#define   USB_getFrameNo                vUSB_getFrameNo                                      
#define   USB_initPLL                   vUSB_initPLL 
#define   USB_evDispatch                vUSB_evDispatch   
                                                                        
#define   _USB_configEndpt              _vUSB_configEndpt                                                                                 
#define   _USB_addInterface             _vUSB_addInterface                                                                           
#define   _USB_resetFirmwareEnv         _vUSB_resetFirmwareEnv                                                                       
#define   _USB_enableEpIntrpt           _vUSB_enableEpIntrpt                                                                        
#define   _USB_disableEpIntrpt          _vUSB_disableEpIntrpt                                                                        
#define   _USB_enableDmaIntrpt          _vUSB_enableDmaIntrpt                                                                  
#define   _USB_disableDmaIntrpt         _vUSB_disableDmaIntrpt
#define   _USB_procCtrlOutTransaction   _vUSB_procCtrlOutTransaction                                                                               
#define   _USB_procCtrlInTransaction    _vUSB_procCtrlInTransaction                                                                        
#define   _USB_procDmaTransaction       _vUSB_procDmaTransaction
#define   _USB_gotoNextList             _vUSB_gotoNextList                                                                               
                                                                                          
#endif                                                                    

_csl_usbdrvr.h/ 1049976803  0     0     0       2137      `
/******************************************************************************/
/* $Id: _csl_usbdrvr.h,v 1.1.1.1 2001/08/16 16:12:53 a0323633 Exp $MH$                                             */
/*                                                                            */
/* This is proprietary information, not to be published -- TI INTERNAL DATA   */
/* Copyright (C) 1999, Texas Instruments, Inc.  All Rights Reserved.          */
/*                                                                            */
/* Header file for generic USB endpoint driver routine                        */
/* request handler can ask the control dispatcher to handle.                  */
/*                                                                            */
/******************************************************************************/

#ifndef __CSL_USBDRVR_H
#define __CSL_USBDRVR_H

#include <_csl.h>

#if (_USB_SUPPORT)

void         _USB_procCtrlInTransaction(USB_EpHandle hInEp0);
void         _USB_procCtrlOutTransaction(USB_EpHandle hOutEp0);
USB_Boolean  _USB_procDmaTransaction(USB_EpHandle hEp);
void         _USB_gotoNextList(USB_EpHandle hEp);
void         USB_evDispatch(void);

/******************************************************************************/
/*   03/23/01 $MH$                                                            */
/*                                                                            */
/*                  Vectored Prototypes for USB API                           */
/*                                                                            */
/******************************************************************************/
void         _vUSB_procCtrlInTransaction(USB_EpHandle hInEp0);
void         _vUSB_procCtrlOutTransaction(USB_EpHandle hOutEp0);
USB_Boolean  _vUSB_procDmaTransaction(USB_EpHandle hEp);
void         _vUSB_gotoNextList(USB_EpHandle hEp);
void         vUSB_evDispatch(void);

#else
  #ifndef _USB_MOD
     error USB Module Not Supported on Specified Target Device
  #endif
#endif   /* _USB_SUPPORT */
#endif

_csl_usbstd.h/  1049976804  0     0     0       1082      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.                *
*                           All Rights Reserved                               *
*                                                                             *
*                                                                             *
*                                                                             *
*******************************************************************************
* Name:  usb_stdinc.h                                                         *
*                                                                             *
\******************************************************************************/


#ifndef _USB_STDINC_H_
#define _USB_STDINC_H_


/*typedef unsigned char	Uchar;*/
/*typedef unsigned short	Uint16;*/
/*typedef unsigned long 	Uint32;*/
/*typedef short		    Int16;*/
/*typedef long		    Int32;*/
/*typedef void *          Handle;*/

#endif
csl.h/          1049976816  0     0     0       3996      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... CSL - chip support library service layer interface
* FILENAME...... csl.h
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:         06/11/1999  Created
*   MODIFIED:        11/13/1999  Modified for TMS320C54xx
*   MODIFIED:        04/12/2001  Changed CSL_version
*   MODIFIED:       04/16/2001  updated CSL_init
*   MODIFIED:        07/29/2002  removed static declaration of _CSL_init()
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the CSL library)
*
*
*
\******************************************************************************/
#ifndef _CSL_H_
#define _CSL_H_   

#include <_csl.h>

/****************************************\
* CSL scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" 
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _CSL_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/****************************************\
* CSL global macro declarations
\****************************************/

/****************************************\
* CSL global typedef declarations
\****************************************/
   
/****************************************\
* CSL global variable declarations
\****************************************/

/****************************************\
* CSL global function declarations
\****************************************/

CSLAPI void CSL5510_LIB_();
CSLAPI void CSL5510_PG1_0_LIB_();
CSLAPI void CSL5510_PG1_2_LIB_();
CSLAPI void CSL5510_PG2_0_LIB_();
CSLAPI void CSL5510_PG2_1_LIB_();
CSLAPI void CSL5510_PG2_2_LIB_();

CSLAPI void CSL5509_LIB_();
CSLAPI void CSL5509A_LIB_();
CSLAPI void CSL5502_LIB_();

CSLAPI void _CSL_init(Uint16 osPresent);


#ifndef _CSL_MOD_
/****************************************\
* CSL inline function declarations
\****************************************/
static inline void CSL_init(void);

/*******************************************************************************\
* Setup (non Rom model) or retrieve (ROM model) address of global data
\*******************************************************************************/
/* ROM Area */

/*******************************************************************************\
* Chip Support Library Global Initialization Function
\*******************************************************************************/
static inline void CSL_init(void) {

  #if (CHIP_5510)
    CSL5510_LIB_();
  #elif (CHIP_5510PG1_0)
    CSL5510_PG1_LIB_();
  #elif (CHIP_5510PG1_2)
    CSL5510_PG1_2_LIB_();

  #elif (CHIP_5510PG2_0)
    CSL5510_PG2_0_LIB_();
  #elif (CHIP_5510PG2_1)
    CSL5510_PG2_1_LIB_();
  #elif (CHIP_5510PG2_2)
    CSL5510_PG2_2_LIB_();

  #elif (CHIP_5509)
    CSL5509_LIB_();
  #elif (CHIP_5509A)
    CSL5509A_LIB_();
  #elif (CHIP_5502)
    CSL5502_LIB_();
  #endif


   _CSL_init(0);     // Call _CSL_init with 0 for operating system
                     // flag


  }  
#else
  CSLAPI void CSL_init(void);
#endif

#endif /* _CSL_H_ */
/******************************************************************************\
* End of csl.h
\******************************************************************************/

csl_adc.h/      1049976818  0     0     0       8982      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... ADC
* FILENAME...... csl_adc.h
* DATE CREATED.. Fri Jun 29 15:39:48 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*   Created:  Fri Jun 29 15:39:48 2001 (Automatic generation)
*   Modified: 01/24/2002 Changed ADCCCR references to ADCCTL in
*                        symbolic constants	
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the ADC module 
*
\*************************************************************************/

#ifndef _CSL_ADC_H_
#define _CSL_ADC_H_

#include <_csl.h>
#include <csl_adchal.h>
	 

#if (_ADC_SUPPORT) 

/*----------------------------------------------------------------*\
*	 ADC scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _ADC_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/****************************************\
* ADC global macro declarations
\****************************************/

/* error codes */
#define ADC_ERR_MAJOR		   (ERR_BASE_ADC) 
#define ADC_ERR_ALLOC		   (0x00000000) 
#define ADC_ERR_INVALID_HANDLE  (0x00000001) 

/* ============================================================== */
 /* Make ADCCLKCTL register values based on symbolic constants  */

#define ADC_ADCCLKCTL_RMK(idleen,cpuclkdiv)\
 ((Uint16) ( \
  ( ADC_FMK(ADCCLKCTL,IDLEEN,idleen))|\
  ( ADC_FMK(ADCCLKCTL,CPUCLKDIV,cpuclkdiv))\
)\
 )

#define ADC_ADCCLKCTL_RMKS(idleen_sym,cpuclkdiv_sym)\
 ((Uint16) ( \
  ( ADC_FMKS(ADCCLKCTL,IDLEEN,idleen_sym))|\
  ( ADC_FMKS(ADCCLKCTL,CPUCLKDIV,cpuclkdiv_sym))\
)\
 )

/*  Default ADCCLKCTL register value  */

#define ADC_ADCCLKCTL_IDLEEN_NOIDLE             (0x0000u)
#define ADC_ADCCLKCTL_IDLEEN_IDLE               (0x0001u)
#define ADC_ADCCLKCTL_IDLEEN_DEFAULT            ADC_ADCCLKTCTL_IDLEN_NOIDLE

/*  ADCCLKCTL field values  */


/* ============================================================== */
 /* Make ADCCLKDIV register values based on symbolic constants  */

#define ADC_ADCCLKDIV_RMK(samptimediv,convratediv)\
 ((Uint16) ( \
  ( ADC_FMK(ADCCLKDIV,SAMPTIMEDIV,samptimediv))|\
  ( ADC_FMK(ADCCLKDIV,CONVRATEDIV,convratediv))\
)\
 )

#define ADC_ADCCLKDIV_RMKS(samptimediv_sym,convratediv_sym)\
 ((Uint16) ( \
  ( ADC_FMKS(ADCCLKDIV,SAMPTIMEDIV,samptimediv_sym))|\
  ( ADC_FMKS(ADCCLKDIV,CONVRATEDIV,convratediv_sym))\
)\
 )

/*  Default ADCCLKDIV register value  */

/*  ADCCLKDIV field values  */


/* ============================================================== */
 /* Make ADCCTL register values based on symbolic constants  */

#define ADC_ADCCTL_RMK(adcstart,chselect)\
 ((Uint16) ( \
  ( ADC_FMK(ADCCTL,ADCSTART,adcstart))|\
  ( ADC_FMK(ADCCTL,CHSELECT,chselect))\
)\
 )

#define ADC_ADCCTL_RMKS(adcstart_sym,chselect_sym)\
 ((Uint16) ( \
  ( ADC_FMKS(ADCCTL,ADCSTART,adcstart_sym))|\
  ( ADC_FMKS(ADCCTL,CHSELECT,chselect_sym))\
)\
 )

/*  Default ADCCTL register value  */

/*  ADCCTL field values  */


/* ============================================================== */
 /* Make ADCDATA register values based on symbolic constants  */

#define ADC_ADCDATA_RMK(chselect)\
 ((Uint16) ( \
  ( ADC_FMK(ADCDATA,CHSELECT,chselect))\
)\
 )

#define ADC_ADCDATA_RMKS(chselect_sym)\
 ((Uint16) ( \
  ( ADC_FMKS(ADCDATA,CHSELECT,chselect_sym))\
)\
 )

/*  ADCCDR field values  */

	#define ADC_ADCCDR_CONVRATEDIV_2DIV			(000000u)
	#define ADC_ADCCDR_CONVRATEDIV_4DIV			(0x0001u)
	#define ADC_ADCCDR_CONVRATEDIV_6DIV			(0x0002u)
	#define ADC_ADCCDR_CONVRATEDIV_8DIV			(0x0003u)
	#define ADC_ADCCDR_CONVRATEDIV_10DIV		(0x0004u)
	#define ADC_ADCCDR_CONVRATEDIV_12DIV		(0x0005u)
	#define ADC_ADCCDR_CONVRATEDIV_14DIV		(0x0006u)
	#define ADC_ADCCDR_CONVRATEDIV_16DIV		(0x0007u)
	#define ADC_ADCCDR_CONVRATEDIV_18DIV		(0x0008u)
	#define ADC_ADCCDR_CONVRATEDIV_20DIV		(0x0009u)
	#define ADC_ADCCDR_CONVRATEDIV_22DIV		(0x000au)
	#define ADC_ADCCDR_CONVRATEDIV_24DIV		(0x000bu)
	#define ADC_ADCCDR_CONVRATEDIV_26DIV		(0x000cu)
	#define ADC_ADCCDR_CONVRATEDIV_28DIV		(0x000du)
	#define ADC_ADCCDR_CONVRATEDIV_30DIV		(0x000eu)
	#define ADC_ADCCDR_CONVRATEDIV_32DIV		(0x000fu)
	#define ADC_ADCCDR_CONVRATEDIV_DEFAULT		ADC_ADCCDR_CONVRATEDIV_2DIV

	#define ADC_ADCCDR_SAMPTIMEDIV_OF(x)         ((Uint16)(x))


/*  ADCCTL field values  */

	#define ADC_ADCCTL_ADCSTART_OFF			(000000u)
	#define ADC_ADCCTL_ADCSTART_ON			(0x0001u)
	#define ADC_ADCCTL_ADCSTART_DEFAULT		ADC_ADCCTL_ADCSTART_OFF

	#define ADC_ADCCTL_CHSELECT_AIN0			(000000u)
	#define ADC_ADCCTL_CHSELECT_AIN1			(0x0001u)
	#define ADC_ADCCTL_CHSELECT_AIN2			(0x0002u)
	#define ADC_ADCCTL_CHSELECT_AIN3			(0x0003u)
      #define ADC_ADCCTL_CHSELECT_OFF                 (0x0007u)
	#define ADC_ADCCTL_CHSELECT_DEFAULT		ADC_ADCCTL_CHSELECT_OFF

/*  ADCDR field values  */

	#define ADC_ADCDR_ADCBUSY_AVAIL			(000000u)
	#define ADC_ADCDR_ADCBUSY_BUSY			(0x0001u)
	#define ADC_ADCDR_ADCBUSY_DEFAULT		ADC_ADCDR_ADCBUSY_AVAIL

	#define ADC_ADCDR_CHSELECT_AIN0			(000000u)
	#define ADC_ADCDR_CHSELECT_AIN1			(0x0001u)
	#define ADC_ADCDR_CHSELECT_AIN2			(0x0002u)
	#define ADC_ADCDR_CHSELECT_AIN3			(0x0003u)
      #define ADC_ADCDR_CHSELECT_OFF                  (0x0007u)
	#define ADC_ADCDR_CHSELECT_DEFAULT		ADC_ADCDR_CHSELECT_OFF

/*  ADCCCR field values  */

	#define ADC_ADCCCR_IDLEEN_ACTIVE			(000000u)
	#define ADC_ADCCCR_IDLEEN_DISABLE		      (0x0001u)
	#define ADC_ADCCCR_IDLEEN_DEFAULT		ADC_ADCCCR_IDLEEN_ACTIVE

      #define ADC_ADCCCR_IDLEEN_NOIDLE                (0x0000u)
      #define ADC_ADCCCR_IDLEEN_IDLE                  (0x0001u)

	#define ADC_ADCCCR_CPUCLKDIV_OF(x)              ((Uint16)(x))

/*************************************************\
 ADC global typedef declarations 
\*************************************************/

typedef struct {
	Uint16 adcctl;
	Uint16 adcclkdiv;
	Uint16 adcclkctl;
} ADC_Config;

/*************************************************\
* ADC global variable declarations
\*************************************************/


/*************************************************\
* ADC global function declarations
\*************************************************/




IDECL void ADC_config(ADC_Config *myConfig);
IDECL void ADC_configArgs(Uint16 adcctl,Uint16 adcclkdiv,Uint16 adcclkctl);
IDECL void ADC_getConfig(ADC_Config *myConfig);
CSLAPI void ADC_setFreq(int sysclkdiv, int convratediv, int sampletimediv);
CSLAPI void ADC_read(int channelnumber,Uint16 *data,int length);

/*************************************************\
* ADC inline function declarations
\*************************************************/


#ifdef USEDEFS



/*----------------------------------------------------------------------------*/

IDEF void ADC_config(ADC_Config *Config) {

int old_intm;

  old_intm = IRQ_globalDisable();  
  ADC_RSET(ADCCTL,Config->adcctl);
  ADC_RSET(ADCCLKDIV,Config->adcclkdiv);
  ADC_RSET(ADCCLKCTL,Config->adcclkctl);
  IRQ_globalRestore(old_intm);   


}

IDEF void ADC_getConfig(ADC_Config *Config) {

  int old_intm;

  old_intm = IRQ_globalDisable();
  Config->adcctl = ADC_RGET(ADCCTL);
  Config->adcclkdiv = ADC_RGET(ADCCLKDIV);
  Config->adcclkctl = ADC_RGET(ADCCLKCTL);
  IRQ_globalRestore(old_intm);   


}


IDEF void ADC_configArgs(Uint16 adcctl,Uint16 adcclkdiv,Uint16 adcclkctl) {

int old_intm;

  old_intm = IRQ_globalDisable();  
  ADC_RSET(ADCCTL,adcctl);
  ADC_RSET(ADCCLKDIV,adcclkdiv);	
  ADC_RSET(ADCCLKCTL,adcclkctl);
  IRQ_globalRestore(old_intm);   



}



/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /*USEDEFS */

#else
   #ifndef _ADC_MOD_
	#error ADC Hal Module Not Supported on Specified Target
   #endif
#endif  /* _ADC_SUPPORT  */

#endif  /* _CSL_ADCHAL_H  */

/******************************************************************************\
*     
*      End of csl_adc.h 
*
\******************************************************************************/
csl_adchal.h/   1049976819  0     0     0       12982     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... ADC
* FILENAME...... csl_adchal.h
* DATE CREATED.. Fri Jun 29 15:39:48 2001
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Fri Jun 29 15:39:48 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL HAL interface file for the ADC module 
*
* Registers covered:
*
* 		 Note: Add registers description here
*	 ADCCTL		- 
*	 ADCDATA		- 
*	 ADCCLKCTL		- 
*	 ADCCLKCTL		- 
*
\*************************************************************************/

#ifndef _CSL_ADCHAL_H_
#define _CSL_ADCHAL_H_

#include <csl_chiphal.h>

#if (_ADC_SUPPORT) 

/*----------------------------------------------------------------*\
*	 ADC scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _ADC_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/*----------------------------------------------------------------*\
*		 Address Macros			
\*----------------------------------------------------------------*/

/*--------------------- Register: ADCCTL -----------------------*/
#define _ADC_ADCCTL_ADDR		(0x6800u)
#define _ADC_ADCCTL			PREG16(_ADC_ADCCTL_ADDR)
#define ADCCTL			_ADC_ADCCTL


/*--------------------- Register: ADCDATA -----------------------*/
#define _ADC_ADCDATA_ADDR		(0x6801u)
#define _ADC_ADCDATA			PREG16(_ADC_ADCDATA_ADDR)
#define ADCDATA			_ADC_ADCDATA


/*--------------------- Register: ADCCLKCTL -----------------------*/
#define _ADC_ADCCLKDIV_ADDR             (0x6802u)
#define _ADC_ADCCLKDIV                 PREG16(_ADC_ADCCLKDIV_ADDR)
#define ADCCLKDIV                       _ADC_ADCCLKDIV


/*--------------------- Register: ADCCLKCTL -----------------------*/
#define _ADC_ADCCLKCTL_ADDR		(0x6803u)
#define _ADC_ADCCLKCTL			PREG16(_ADC_ADCCLKCTL_ADDR)
#define ADCCLKCTL			_ADC_ADCCLKCTL



/*----------------------------------------------------------------*\
*		 Register Macros		
\*----------------------------------------------------------------*/

#define ADC_ADDR(Reg)		  _ADC_##Reg##_ADDR
#define ADC_RGET(Reg)		  _ADC_##Reg##_GET
#define ADC_RSET(Reg,Val)		  _ADC_##Reg##_SET(Val)
#define ADC_FGET(Reg,Field)		  _ADC_##Reg##_FGET(##Field)
#define ADC_FSET(Reg,Field,Val)		  _ADC_##Reg##_FSET(##Field, Val)
#define ADC_FMK(Reg,Field,Val)		  _ADC_##Reg##_##Field##_MK(Val)
#define ADC_RAOI(Reg,AND,OR,INV)		  _ADC_##Reg##_AOI(AND,OR,INV)
#define ADC_FAOI(Reg,Field,AND,OR,INV)	  _ADC_##Reg##_FAOI(##Field,AND,OR,INV)
#define ADC_FMKS(Reg,Field,Sym)\
	  _ADC_##Reg##_##Field##_MK(ADC_##Reg##_##Field##_##Sym)
#define ADC_FSETS(Reg,Field,Sym)\
	  _ADC_FSET(Reg,##Field,ADC_##Reg##_##Field##_##Sym)

/*----------------------------------------------------------------*\
*		 Non-handle Registers Macros		
\*----------------------------------------------------------------*/


/*--------------------- Register: ADCCTL -----------------------*/
#define _ADC_ADCCTL_GET		  _PREG_GET(_ADC_ADCCTL_ADDR) 
#define _ADC_ADCCTL_SET(Val)		  _PREG_SET(_ADC_ADCCTL_ADDR,Val)
#define _ADC_ADCCTL_FGET(Field)	  _PFIELD_GET(_ADC_ADCCTL_ADDR, _ADC_ADCCTL_##Field)
#define _ADC_ADCCTL_FSET(Field,Val)	  _PFIELD_SET(_ADC_ADCCTL_ADDR, _ADC_ADCCTL_##Field, Val)
#define _ADC_ADCCTL_AOI(AND,OR,INV)	  _PREG_AOI(_ADC_ADCCTL_ADDR,AND,OR,INV)
#define _ADC_ADCCTL_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_ADC_ADCCTL_ADDR, _ADC_ADCCTL_##Field,AND,OR,INV)


/*--------------------- Register: ADCDATA -----------------------*/
#define _ADC_ADCDATA_GET		  _PREG_GET(_ADC_ADCDATA_ADDR) 
#define _ADC_ADCDATA_SET(Val)		  _PREG_SET(_ADC_ADCDATA_ADDR,Val)
#define _ADC_ADCDATA_FGET(Field)	  _PFIELD_GET(_ADC_ADCDATA_ADDR, _ADC_ADCDATA_##Field)
#define _ADC_ADCDATA_FSET(Field,Val)	  _PFIELD_SET(_ADC_ADCDATA_ADDR, _ADC_ADCDATA_##Field, Val)
#define _ADC_ADCDATA_AOI(AND,OR,INV)	  _PREG_AOI(_ADC_ADCDATA_ADDR,AND,OR,INV)
#define _ADC_ADCDATA_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_ADC_ADCDATA_ADDR, _ADC_ADCDATA_##Field,AND,OR,INV)


/*--------------------- Register: ADCCLKCTL -----------------------*/
#define _ADC_ADCCLKCTL_GET		  _PREG_GET(_ADC_ADCCLKCTL_ADDR) 
#define _ADC_ADCCLKCTL_SET(Val)		  _PREG_SET(_ADC_ADCCLKCTL_ADDR,Val)
#define _ADC_ADCCLKCTL_FGET(Field)	  _PFIELD_GET(_ADC_ADCCLKCTL_ADDR, _ADC_ADCCLKCTL_##Field)
#define _ADC_ADCCLKCTL_FSET(Field,Val)	  _PFIELD_SET(_ADC_ADCCLKCTL_ADDR, _ADC_ADCCLKCTL_##Field, Val)
#define _ADC_ADCCLKCTL_AOI(AND,OR,INV)	  _PREG_AOI(_ADC_ADCCLKCTL_ADDR,AND,OR,INV)
#define _ADC_ADCCLKCTL_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_ADC_ADCCLKCTL_ADDR, _ADC_ADCCLKCTL_##Field,AND,OR,INV)


/*--------------------- Register: ADCCLKDIV -----------------------*/
#define _ADC_ADCCLKDIV_GET                _PREG_GET(_ADC_ADCCLKDIV_ADDR) 
#define _ADC_ADCCLKDIV_SET(Val)           _PREG_SET(_ADC_ADCCLKDIV_ADDR,Val)
#define _ADC_ADCCLKDIV_FGET(Field)        _PFIELD_GET(_ADC_ADCCLKDIV_ADDR, _ADC_ADCCLKDIV_##Field)
#define _ADC_ADCCLKDIV_FSET(Field,Val)    _PFIELD_SET(_ADC_ADCCLKDIV_ADDR, _ADC_ADCCLKDIV_##Field, Val)
#define _ADC_ADCCLKDIV_AOI(AND,OR,INV)    _PREG_AOI(_ADC_ADCCLKDIV_ADDR,AND,OR,INV)
#define _ADC_ADCCLKDIV_FAOI(Field,AND,OR,INV)\
        _PFIELD_AOI(_ADC_ADCCLKDIV_ADDR, _ADC_ADCCLKDIV_##Field,AND,OR,INV)



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the ADCCTL register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _ADC_ADCCTL	 - Note: Add description here
*
* Fields:
*	(RW)   _ADC_ADCCTL_CHSELECT	
*	(RW)   _ADC_ADCCTL_ADCSTART	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _ADC_ADCCTL_CHSELECT:	
\*----------------------------------------------------------------*/

#define _ADC_ADCCTL_CHSELECT_SHIFT		(0x000cu)
#define _ADC_ADCCTL_CHSELECT_MK(n)		(((Uint16)(n) & 0x0007u) << _ADC_ADCCTL_CHSELECT_SHIFT)
#define _ADC_ADCCTL_CHSELECT_MASK		(_ADC_ADCCTL_CHSELECT_MK(0x0007u))
#define _ADC_ADCCTL_CHSELECT_CLR		(~(_ADC_ADCCTL_CHSELECT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _ADC_ADCCTL_ADCSTART:	
\*----------------------------------------------------------------*/

#define _ADC_ADCCTL_ADCSTART_SHIFT		(0x000fu)
#define _ADC_ADCCTL_ADCSTART_MK(n)		(((Uint16)(n) & 0x0001u) << _ADC_ADCCTL_ADCSTART_SHIFT)
#define _ADC_ADCCTL_ADCSTART_MASK		(_ADC_ADCCTL_ADCSTART_MK(0x0001u))
#define _ADC_ADCCTL_ADCSTART_CLR		(~(_ADC_ADCCTL_ADCSTART_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the ADCDATA register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _ADC_ADCDATA	 - Note: Add description here
*
* Fields:
*	(R)   _ADC_ADCDATA_ADCDATA	
*	(RW)   _ADC_ADCDATA_CHSELECT	
*	(R)   _ADC_ADCDATA_ADCBUSY	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _ADC_ADCDATA_ADCDATA:	
\*----------------------------------------------------------------*/

#define _ADC_ADCDATA_ADCDATA_SHIFT		(000000u)
#define _ADC_ADCDATA_ADCDATA_MK(n)		(((Uint16)(n) & 0x03ffu) << _ADC_ADCDATA_ADCDATA_SHIFT)
#define _ADC_ADCDATA_ADCDATA_MASK		(_ADC_ADCDATA_ADCDATA_MK(0x03ffu))
#define _ADC_ADCDATA_ADCDATA_CLR		(~(_ADC_ADCDATA_ADCDATA_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _ADC_ADCDATA_CHSELECT:	
\*----------------------------------------------------------------*/

#define _ADC_ADCDATA_CHSELECT_SHIFT		(0x000cu)
#define _ADC_ADCDATA_CHSELECT_MK(n)		(((Uint16)(n) & 0x0007u) << _ADC_ADCDATA_CHSELECT_SHIFT)
#define _ADC_ADCDATA_CHSELECT_MASK		(_ADC_ADCDATA_CHSELECT_MK(0x0007u))
#define _ADC_ADCDATA_CHSELECT_CLR		(~(_ADC_ADCDATA_CHSELECT_MASK))



/*----------------------------------------------------------------*\
*   (R)  _ADC_ADCDATA_ADCBUSY:	
\*----------------------------------------------------------------*/

#define _ADC_ADCDATA_ADCBUSY_SHIFT		(0x000fu)
#define _ADC_ADCDATA_ADCBUSY_MK(n)		(((Uint16)(n) & 0x0001u) << _ADC_ADCDATA_ADCBUSY_SHIFT)
#define _ADC_ADCDATA_ADCBUSY_MASK		(_ADC_ADCDATA_ADCBUSY_MK(0x0001u))
#define _ADC_ADCDATA_ADCBUSY_CLR		(~(_ADC_ADCDATA_ADCBUSY_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the ADCCLKCTL register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _ADC_ADCCLKCTL	 - Note: Add description here
*
* Fields:
*       (RW)   _ADC_ADCCLKCTL_CPUCLKDIV 
*	(RW)   _ADC_ADCCLKCTL_IDLEEN	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _ADC_ADCCLKCTL_CPUCLKDIV: 
\*----------------------------------------------------------------*/

#define _ADC_ADCCLKCTL_CPUCLKDIV_SHIFT               (000000u)
#define _ADC_ADCCLKCTL_CPUCLKDIV_MK(n)               (((Uint16)(n) & 0x00ffu) << _ADC_ADCCLKCTL_CPUCLKDIV_SHIFT)
#define _ADC_ADCCLKCTL_CPUCLKDIV_MASK                (_ADC_ADCCLKCTL_CPUCLKDIV_MK(0x00ffu))
#define _ADC_ADCCLKCTL_CPUCLKDIV_CLR         (~(_ADC_ADCCLKCTL_CPUCLKDIV_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _ADC_ADCCLKCTL_IDLEEN:	
\*----------------------------------------------------------------*/

#define _ADC_ADCCLKCTL_IDLEEN_SHIFT		(0x0008u)
#define _ADC_ADCCLKCTL_IDLEEN_MK(n)		(((Uint16)(n) & 0x0001u) << _ADC_ADCCLKCTL_IDLEEN_SHIFT)
#define _ADC_ADCCLKCTL_IDLEEN_MASK		(_ADC_ADCCLKCTL_IDLEEN_MK(0x0001u))
#define _ADC_ADCCLKCTL_IDLEEN_CLR		(~(_ADC_ADCCLKCTL_IDLEEN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the ADCCLKDIV register                
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _ADC_ADCCLKDIV         - Note: Add description here
*
* Fields:
*       (RW)   _ADC_ADCCLKDIV_CONVRATEDIV 
*       (RW)   _ADC_ADCCLKDIV_SAMPTIMEDIV 
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _ADC_ADCCLKDIV_CONVRATEDIV: 
\*----------------------------------------------------------------*/

#define _ADC_ADCCLKDIV_CONVRATEDIV_SHIFT                (000000u)
#define _ADC_ADCCLKDIV_CONVRATEDIV_MK(n)                (((Uint16)(n) & 0x001fu) << _ADC_ADCCLKDIV_CONVRATEDIV_SHIFT)
#define _ADC_ADCCLKDIV_CONVRATEDIV_MASK         (_ADC_ADCCLKDIV_CONVRATEDIV_MK(0x001fu))
#define _ADC_ADCCLKDIV_CONVRATEDIV_CLR          (~(_ADC_ADCCLKDIV_CONVRATEDIV_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _ADC_ADCCLKDIV_SAMPTIMEDIV: 
\*----------------------------------------------------------------*/

#define _ADC_ADCCLKDIV_SAMPTIMEDIV_SHIFT                (0x0008u)
#define _ADC_ADCCLKDIV_SAMPTIMEDIV_MK(n)                (((Uint16)(n) & 0x000fu) << _ADC_ADCCLKDIV_SAMPTIMEDIV_SHIFT)
#define _ADC_ADCCLKDIV_SAMPTIMEDIV_MASK         (_ADC_ADCCLKDIV_SAMPTIMEDIV_MK(0x000fu))
#define _ADC_ADCCLKDIV_SAMPTIMEDIV_CLR          (~(_ADC_ADCCLKDIV_SAMPTIMEDIV_MASK))


#else
   #ifndef _ADC_MOD_
	#error ADC Hal Module Not Supported on Specified Target
   #endif
#endif  /* _ADC_SUPPORT  */

#endif  /* _CSL_ADCHAL_H  */

/******************************************************************************\
*     
*      End of csl_ADChal.h 
*
\******************************************************************************/
csl_bct.h/      1049976821  0     0     0       21696     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... BCT
* FILENAME...... csl_bct.h
* DATE CREATED.. Tue Feb 19 12:02:53 2002
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Tue Feb 19 12:02:53 2002 (Automatic generation)
*	 Modified:	    03/21/2003 Modified register names and fields
*                       as per SPRU618A. 
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the BCT module 
*
\*************************************************************************/

#ifndef _CSL_BCT_H_
#define _CSL_BCT_H_

#include <csl.h>
#include <csl_std.h>
#include <csl_chiphal.h>

#if ((_BCT_SUPPORT) & (BIOS_CNT))

#include <csl_bcthal.h>
#include <csl_gpt.h>

/*----------------------------------------------------------------*\
*	 BCT scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _BCT_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/****************************************\
* BCT global macro declarations
\****************************************/

/* error codes */
#define BCT_ERR_MAJOR		   (ERR_BASE_BCT) 
#define BCT_ERR_ALLOC		   (0x00000000) 
#define BCT_ERR_INVALID_HANDLE  (0x00000001) 


#define _BCT_Obj                (CSL_BCT_DATA)

/* ============================================================== */
 /* Make BCTCLK register values based on symbolic constants  */

/*  BCTCLK field values  */

	#define BCT_BCTCLK_CLKDIV_DIV0	       (0x0000u) 
	#define BCT_BCTCLK_CLKDIV_DIV1	       (0x0001u) 
	#define BCT_BCTCLK_CLKDIV_DIV2	       (0x0002u) 
	#define BCT_BCTCLK_CLKDIV_DIV4	       (0x0004u) 
	#define BCT_BCTCLK_CLKDIV_DIV8	       (0x0008u)
	#define BCT_BCTCLK_CLKDIV_DEFAULT      BCT_BCTCLK_CLKDIV_DIV0


/*  Default BCTCLK register value  */

/* ============================================================== */
 /* Make BCTCNT1 register values based on symbolic constants  */

/*  BCTCNT1 field values  */

	#define BCT_BCTCNT1_CNT_OF(x)			((Uint16)(x))
	#define BCT_BCTCNT1_CNT_DEFAULT		BCT_BCTCNT1_CNT_OF(0x0000u)


#define BCT_BCTCNT1_RMK(cnt)\
 ((Uint16) ( \
  ( BCT_FMK(BCTCNT1,CNT,cnt))\
)\
 )

#define BCT_BCTCNT1_RMKS(cnt_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTCNT1,CNT,cnt_sym))\
)\
 )

/*  Default BCTCNT1 register value  */

/* ============================================================== */
 /* Make BCTCNT2 register values based on symbolic constants  */

/*  BCTCNT2 field values  */

	#define BCT_BCTCNT2_CNT_OF(x)			((Uint16)(x))
	#define BCT_BCTCNT2_CNT_DEFAULT		BCT_BCTCNT2_CNT_OF(0x0000u)


#define BCT_BCTCNT2_RMK(cnt)\
 ((Uint16) ( \
  ( BCT_FMK(BCTCNT2,CNT,cnt))\
)\
 )

#define BCT_BCTCNT2_RMKS(cnt_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTCNT2,CNT,cnt_sym))\
)\
 )

/*  Default BCTCNT2 register value  */

/* ============================================================== */
 /* Make BCTCNT3 register values based on symbolic constants  */

/*  BCTCNT3 field values  */

	#define BCT_BCTCNT3_CNT_OF(x)			((Uint16)(x))
	#define BCT_BCTCNT3_CNT_DEFAULT		BCT_BCTCNT3_CNT_OF(0x0000u)


#define BCT_BCTCNT3_RMK(cnt)\
 ((Uint16) ( \
  ( BCT_FMK(BCTCNT3,CNT,cnt))\
)\
 )

#define BCT_BCTCNT3_RMKS(cnt_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTCNT3,CNT,cnt_sym))\
)\
 )

/*  Default BCTCNT3 register value  */

/* ============================================================== */
 /* Make BCTCNT4 register values based on symbolic constants  */

/*  BCTCNT4 field values  */

	#define BCT_BCTCNT4_CNT_OF(x)			((Uint16)(x))
	#define BCT_BCTCNT4_CNT_DEFAULT		BCT_BCTCNT4_CNT_OF(0x0000u)

#define BCT_BCTCNT4_RMK(cnt)\
 ((Uint16) ( \
  ( BCT_FMK(BCTCNT4,CNT,cnt))\
)\
 )

#define BCT_BCTCNT4_RMKS(cnt_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTCNT4,CNT,cnt_sym))\
)\
 )

/*  Default BCTCNT4 register value  */

/* ============================================================== */
 /* Make BCTCTL1 register values based on symbolic constants  */

/*  BCTCTL1 field values  */

	#define BCT_BCTCTL1_TIEN_NOT_GATED			(000000u) 
	#define BCT_BCTCTL1_TIEN_GATED_BY_TINP			(0x0001u) 
	#define BCT_BCTCTL1_TIEN_DEFAULT		BCT_BCTCTL1_TIEN_NOT_GATED 

	#define BCT_BCTCTL1_CLKSRC_VBUS				(000000u) 
	#define BCT_BCTCTL1_CLKSRC_INPUT_PIN			(0x0001u) 
	#define BCT_BCTCTL1_CLKSRC_DEFAULT		BCT_BCTCTL1_CLKSRC_VBUS 

	#define BCT_BCTCTL1_ENAMODE_DISABLED			(000000u) 
	#define BCT_BCTCTL1_ENAMODE_ONCE			(0x0001u) 
	#define BCT_BCTCTL1_ENAMODE_CONTINUOUS			(0x0002u) 
	#define BCT_BCTCTL1_ENAMODE_DEFAULT		BCT_BCTCTL1_ENAMODE_DISABLED 

	#define BCT_BCTCTL1_PWID_INACTIVE_1CYCLE		(000000u) 
	#define BCT_BCTCTL1_PWID_INACTIVE_2CYCLES		(0x0001u) 
	#define BCT_BCTCTL1_PWID_INACTIVE_3CYCLES		(0x0002u) 
	#define BCT_BCTCTL1_PWID_INACTIVE_4CYCLES		(0x0003u) 
	#define BCT_BCTCTL1_PWID_DEFAULT		BCT_BCTCTL1_PWID_INACTIVE_1CYCLES 

	#define BCT_BCTCTL1_CP_CLOCK_MODE			(0x0001u) 
	#define BCT_BCTCTL1_CP_PULSE_MODE			(000000u) 
	#define BCT_BCTCTL1_CP_DEFAULT			BCT_BCTCTL1_CP_PULSE_MODE 

	#define BCT_BCTCTL1_INVIN_INVERT_OUTPUT			(0x0001u) 
	#define BCT_BCTCTL1_INVIN_DONT_INVERT_OUTPUT		(000000u) 
	#define BCT_BCTCTL1_INVIN_DEFAULT		BCT_BCTCTL1_INVIN_DONT_INVERT_OUTPUT 

	#define BCT_BCTCTL1_INVOUT_INVERT_OUTPUT		(0x0001u) 
	#define BCT_BCTCTL1_INVOUT_DONT_INVERT_OUTPUT		(000000u) 
	#define BCT_BCTCTL1_INVOUT_DEFAULT		BCT_BCTCTL1_INVOUT_DONT_INVERT_OUTPUT 

	#define BCT_BCTCTL1_TSTAT_HIGH				(0x0001u) 
	#define BCT_BCTCTL1_TSTAT_LOW				(000000u) 
 
#define BCT_BCTCTL1_RMK(tien,clksrc,enamode,pwid,cp,invin,invout)\
 ((Uint16) ( \
  ( BCT_FMK(BCTCTL1,TIEN,tien))|\
  ( BCT_FMK(BCTCTL1,CLKSRC,clksrc))|\
  ( BCT_FMK(BCTCTL1,ENAMODE,enamode))|\
  ( BCT_FMK(BCTCTL1,PWID,pwid))|\
  ( BCT_FMK(BCTCTL1,CP,cp))|\
  ( BCT_FMK(BCTCTL1,INVIN,invin))|\
  ( BCT_FMK(BCTCTL1,INVOUT,invout))\
)\
 ) 
 
#define BCT_BCTCTL1_RMKS(tien_sym,clksrc_sym,enamode_sym,pwid_sym,cp_sym,invin_sym,invout_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTCTL1,TIEN,tien_sym))|\
  ( BCT_FMKS(BCTCTL1,CLKSRC,clksrc_sym))|\
  ( BCT_FMKS(BCTCTL1,ENAMODE,enamode_sym))|\
  ( BCT_FMKS(BCTCTL1,PWID,pwid_sym))|\
  ( BCT_FMKS(BCTCTL1,CP,cp_sym))|\
  ( BCT_FMKS(BCTCTL1,INVIN,invin_sym))|\
  ( BCT_FMKS(BCTCTL1,INVOUT,invout_sym))\
)\
 ) 
 
/*  Default BCTCTL1 register value  */ 




/* ============================================================== */
 /* Make BCTCTL2 register values based on symbolic constants  */

/*  BCTCTL2 field values  */


/* ============================================================== */

	#define BCT_BCTCTL2_TIEN_NOT_GATED			(000000u) 
	#define BCT_BCTCTL2_TIEN_GATED_BY_TINP			(0x0001u) 
	#define BCT_BCTCTL2_TIEN_DEFAULT		BCT_BCTCTL2_TIEN_NOT_GATED 
 
	#define BCT_BCTCTL2_CLKSRC_VBUS				(000000u) 
	#define BCT_BCTCTL2_CLKSRC_INPUT_PIN			(0x0001u) 
	#define BCT_BCTCTL2_CLKSRC_DEFAULT		BCT_BCTCTL2_CLKSRC_VBUS 
 
	#define BCT_BCTCTL2_ENAMODE_DISABLED			(000000u) 
	#define BCT_BCTCTL2_ENAMODE_ONCE			(0x0001u) 
	#define BCT_BCTCTL2_ENAMODE_CONTINUOUS			(0x0002u) 
	#define BCT_BCTCTL2_ENAMODE_DEFAULT		BCT_BCTCTL2_ENAMODE_DISABLED 
 
	#define BCT_BCTCTL2_PWID_INACTIVE_1CYCLE		(000000u) 
	#define BCT_BCTCTL2_PWID_INACTIVE_2CYCLES		(0x0001u) 
	#define BCT_BCTCTL2_PWID_INACTIVE_3CYCLES		(0x0002u) 
	#define BCT_BCTCTL2_PWID_INACTIVE_4CYCLES		(0x0003u) 
	#define BCT_BCTCTL2_PWID_DEFAULT		BCT_BCTCTL2_PWID_INACTIVE_1CYCLE 
 
	#define BCT_BCTCTL2_CP_CLOCK_MODE			(0x0001u) 
	#define BCT_BCTCTL2_CP_PULSE_MODE			(000000u) 
	#define BCT_BCTCTL2_CP_DEFAULT			BCT_BCTCTL2_CP_PULSE_MODE 
 
	#define BCT_BCTCTL2_INVIN_INVERT_OUTPUT			(0x0001u) 
	#define BCT_BCTCTL2_INVIN_DONT_INVERT_OUTPUT		(000000u) 
	#define BCT_BCTCTL2_INVIN_DEFAULT		BCT_BCTCTL2_INVIN_DONT_INVERT_OUTPUT 
 
	#define BCT_BCTCTL2_INVOUT_INVERT_OUTPUT		(0x0001u) 
	#define BCT_BCTCTL2_INVOUT_DONT_INVERT_OUTPUT		(000000u) 
	#define BCT_BCTCTL2_INVOUT_DEFAULT		BCT_BCTCTL2_INVOUT_DONT_INVERT_OUTPUT 
 
	#define BCT_BCTCTL2_TSTAT_HIGH				(0x0001u) 
	#define BCT_BCTCTL2_TSTAT_LOW				(000000u) 
 
 
#define BCT_BCTCTL2_RMK(tien,clksrc,enamode,pwid,cp,invin,invout)\
 ((Uint16) ( \
  ( BCT_FMK(BCTCTL2,TIEN,tien))|\
  ( BCT_FMK(BCTCTL2,CLKSRC,clksrc))|\
  ( BCT_FMK(BCTCTL2,ENAMODE,enamode))|\
  ( BCT_FMK(BCTCTL2,PWID,pwid))|\
  ( BCT_FMK(BCTCTL2,CP,cp))|\
  ( BCT_FMK(BCTCTL2,INVIN,invin))|\
  ( BCT_FMK(BCTCTL2,INVOUT,invout))\
)\
 ) 
 
#define BCT_BCTCTL2_RMKS(tien_sym,clksrc_sym,enamode_sym,pwid_sym,cp_sym,invin_sym,invout_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTCTL2,TIEN,tien_sym))|\
  ( BCT_FMKS(BCTCTL2,CLKSRC,clksrc_sym))|\
  ( BCT_FMKS(BCTCTL2,ENAMODE,enamode_sym))|\
  ( BCT_FMKS(BCTCTL2,PWID,pwid_sym))|\
  ( BCT_FMKS(BCTCTL2,CP,cp_sym))|\
  ( BCT_FMKS(BCTCTL2,INVIN,invin_sym))|\
  ( BCT_FMKS(BCTCTL2,INVOUT,invout_sym))\
)\
 ) 
 
/*  Default BCTCTL2 register value  */ 
 
/* ============================================================== */ 
/* Make BCTEMU register values based on symbolic constants  */ 
 
/*  BCTEMU field values  */ 
 
	#define BCT_BCTEMU_FREE_ON  		(000000u) 
	#define BCT_BCTEMU_FREE_OFF			(000001u) 
    #define BCT_BCTEMU_FREE_DEFAULT     BCT_BCTEMU_FREE_ON 
          
    #define BCT_BCTEMU_SOFT_ON  		(000000u) 
	#define BCT_BCTEMU_SOFT_OFF			(000001u) 
    #define BCT_BCTEMU_SOFT_DEFAULT     BCT_BCTEMU_SOFT_ON 
         

/*  Default BCTEMU register value  */

/* ============================================================== */ 
/* Make BCTGPEN register values based on symbolic constants  */ 
 
/*  BCTGPEN field values  */ 
 
	#define BCT_BCTGPEN_TOUT1EN_TIMER_OUTPUT		(000000u) 
	#define BCT_BCTGPEN_TOUT1EN_GPIO_PIN			(0x0001u) 
	#define BCT_BCTGPEN_TOUT1EN_DEFAULT		    BCT_BCTGPEN_TOUT1EN_TIMER_OUTPUT 
 
	#define BCT_BCTGPEN_TIN1EN_TIMER_INPUT			(000000u) 
	#define BCT_BCTGPEN_TIN1EN_GPIO_PIN			    (0x0001u) 
	#define BCT_BCTGPEN_TIN1EN_DEFAULT		    BCT_BCTGPEN_TIN1EN_TIMER_INPUT 
 
 
#define BCT_BCTGPEN_RMK(tout1en,tin1en)\
 ((Uint16) ( \
  ( BCT_FMK(BCTGPEN,TOUT1EN,tout1en))|\
  ( BCT_FMK(BCTGPEN,TIN1EN,tin1en))\
)\
 ) 
 
#define BCT_BCTGPEN_RMKS(tout1en_sym,tin1en_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTGPEN,TOUT1EN,tout1en_sym))|\
  ( BCT_FMKS(BCTGPEN,TIN1EN,tin1en_sym))\
)\
 ) 
 
/*  Default BCTGPEN register value  */ 
 
 
/* ============================================================== */
 /* Make BCTGCTL1 register values based on symbolic constants  */

/*  BCTGCTL1 field values  */

	#define BCT_BCTGCTL1_TDDR34_OF(x)		((Uint16)(x))
	#define BCT_BCTGCTL1_TDDR34_DEFAULT		BCT_BCTGCTL1_TDDR34_OF(0)

	#define BCT_BCTGCTL1_PSC34_OF(x)		((Uint16)(x))
	#define BCT_BCTGCTL1_PSC34_DEFAULT		BCT_BCTGCTL1_PSC34_OF(0)

	#define BCT_BCTGCTL1_TIMMODE_64BIT_GPTIM			(000000u)
	#define BCT_BCTGCTL1_TIMMODE_32BIT_DUAL			(0x0001u)
	#define BCT_BCTGCTL1_TIMMODE_32BIT_CHAINED			(0x0003u)
	#define BCT_BCTGCTL1_TIMMODE_DEFAULT		BCT_BCTGCTL1_TIMMODE_64BIT_GPTIM

	#define BCT_BCTGCTL1_TIM34RS_IN_RESET			(000000u)
	#define BCT_BCTGCTL1_TIM34RS_NOT_IN_RESET			(0x0001u)
	#define BCT_BCTGCTL1_TIM34RS_DEFAULT		BCT_BCTGCTL1_TIM34RS_IN_RESET

	#define BCT_BCTGCTL1_TIM12RS_IN_RESET			(000000u)
	#define BCT_BCTGCTL1_TIM12RS_NOT_IN_RESET			(0x0001u)
	#define BCT_BCTGCTL1_TIM12RS_DEFAULT		BCT_BCTGCTL1_TIM12RS_IN_RESET


#define BCT_BCTGCTL1_RMK(psc34,timmode,tim34rs,tim12rs)\
 ((Uint16) ( \
  ( BCT_FMK(BCTGCTL1,PSC34,psc34))|\
  ( BCT_FMK(BCTGCTL1,TIMMODE,timmode))|\
  ( BCT_FMK(BCTGCTL1,TIM34RS,tim34rs))|\
  ( BCT_FMK(BCTGCTL1,TIM12RS,tim12rs))\
)\
 )

#define BCT_BCTGCTL1_RMKS(psc34_sym,timmode_sym,tim34rs_sym,tim12rs_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTGCTL1,PSC34,psc34_sym))|\
  ( BCT_FMKS(BCTGCTL1,TIMMODE,timmode_sym))|\
  ( BCT_FMKS(BCTGCTL1,TIM34RS,tim34rs_sym))|\
  ( BCT_FMKS(BCTGCTL1,TIM12RS,tim12rs_sym))\
)\
 )

/*  Default BCTGCTL1 register value  */

/* ============================================================== */

/* Make BCTGPDAT register values based on symbolic constants  */ 
 
/*  BCTGPDAT field values  */ 
 

	#define BCT_BCTGPDAT_TOUT1DAT_HIGH			(0x0001u) 
	#define BCT_BCTGPDAT_TOUT1DAT_LOW			(000000u) 
	#define BCT_BCTGPDAT_TOUT1DAT_DEFAULT		BCT_BCTGPDAT_TOUT1DAT_LOW 
 
	#define BCT_BCTGPDAT_TIN1DAT_HIGH			(0x0001u) 
	#define BCT_BCTGPDAT_TIN1DAT_LOW			(000000u) 
	#define BCT_BCTGPDAT_TIN1DAT_DEFAULT		BCT_BCTGPDAT_TIN1DAT_LOW 
 
#define BCT_BCTGPDAT_RMK(tout1dat,tin1dat)\
 ((Uint16) ( \
  ( BCT_FMK(BCTGPDAT,TOUT1DAT,tout1dat))|\
  ( BCT_FMK(BCTGPDAT,TIN1DAT,tin1dat))\
)\
 ) 
 
#define BCT_BCTGPDAT_RMKS(tout1dat_sym,tin1dat_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTGPDAT,TOUT1DAT,tout1dat_sym))|\
  ( BCT_FMKS(BCTGPDAT,TIN1DAT,tin1dat_sym))\
)\
 ) 


/*  Default BCTGPDAT register value  */

/* ============================================================== */

/* Make BCTGPDIR register values based on symbolic constants  */ 
 
/*  BCTGPDIR field values  */ 
 
	
	#define BCT_BCTGPDIR_TOUT1DIR_GPIO_INPUT			(000000u) 
	#define BCT_BCTGPDIR_TOUT1DIR_GPIO_OUTPUT			(0x0001u) 
	#define BCT_BCTGPDIR_TOUT1DIR_DEFAULT			BCT_BCTGPDIR_TOUT1DIR_GPIO_INPUT 
 
	#define BCT_BCTGPDIR_TIN1DIR_GPIO_INPUT				(000000u) 
	#define BCT_BCTGPDIR_TIN1DIR_GPIO_OUTPUT			(0x0001u) 
	#define BCT_BCTGPDIR_TIN1DIR_DEFAULT			BCT_BCTGPDIR_TIN1DIR_GPIO_INPUT 
 
#define BCT_BCTGPDIR_RMK(tout1dir,tin1dir)\
 ((Uint16) ( \
  ( BCT_FMK(BCTGPDIR,TOUT1DIR,tout1dir))|\
  ( BCT_FMK(BCTGPDIR,TIN1DIR,tin1dir))\
)\
 ) 
 
#define BCT_BCTGPDIR_RMKS(tout1dir_sym,tin1dir_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTGPDIR,TOUT1DIR,tout1dir_sym))|\
  ( BCT_FMKS(BCTGPDIR,TIN1DIR,tin1dir_sym))\
)\
 ) 

/*  Default BCTGPDIR register value  */

/* ============================================================== */

 /* Make BCTGPINT register values based on symbolic constants  */ 
 
/*  BCTGPINT field values  */ 
 
	
    #define BCT_BCTGPINT_TIN1INV_DISABLE		(0x0000u)  
	#define BCT_BCTGPINT_TIN1INV_ENABLE			(000001u) 
	#define BCT_BCTGPINT_TIN1INV_DEFAULT		BCT_BCTGPINT_TIN1INV_DISABLE
 
	#define BCT_BCTGPINT_TIN1INT_DISABLE		(0x0000u)  
	#define BCT_BCTGPINT_TIN1INT_ENABLE			(000001u) 
	#define BCT_BCTGPINT_TIN1INT_DEFAULT		BCT_BCTGPINT_TIN1INT_DISABLE
	
	
#define BCT_BCTGPINT_RMK(tin1inv,tin1int)\
 ((Uint16) ( \
  ( BCT_FMK(BCTGPINT,TIN1INV,tin1inv))|\
  ( BCT_FMK(BCTGPINT,TIN1INT,tin1int))\
)\
 ) 
 
#define BCT_BCTGPINT_RMKS(tin1inv_sym,tin1int_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTGPINT,TIN1INV,tin1inv_sym))|\
  ( BCT_FMKS(BCTGPINT,TIN1INT,tin1int_sym))\
)\
 ) 
 

/*  Default BCTGPINT register value  */

/* ============================================================== */
 /* Make BCTPID1 register values based on symbolic constants  */

/*  BCTPID1 field values  */

	#define BCT_BCTPID1_CLASS_CLASS			(000000u)
	#define BCT_BCTPID1_CLASS_DEFAULT		BCT_BCTPID1_CLASS_CLASS

	#define BCT_BCTPID1_REVISION_REVISION			(000000u)
	#define BCT_BCTPID1_REVISION_DEFAULT		BCT_BCTPID1_REVISION_REVISION


/*  Default BCTPID1 register value  */

/* ============================================================== */
 /* Make BCTPID2 register values based on symbolic constants  */

/*  BCTPID2 field values  */

	#define BCT_BCTPID2_TYPE_TYPE			(000000u)
	#define BCT_BCTPID2_TYPE_DEFAULT		BCT_BCTPID2_TYPE_TYPE


/*  Default BCTPID2 register value  */

/* ============================================================== */
 /* Make BCTPRD1 register values based on symbolic constants  */

/*  BCTPRD1 field values  */

	#define BCT_BCTPRD1_PRD_OF(x)			((Uint16)(x))
	#define BCT_BCTPRD1_PRD_DEFAULT		BCT_BCTPRD1_PRD_OF(x)


#define BCT_BCTPRD1_RMK(prd)\
 ((Uint16) ( \
  ( BCT_FMK(BCTPRD1,PRD,prd))\
)\
 )

#define BCT_BCTPRD1_RMKS(prd_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTPRD1,PRD,prd_sym))\
)\
 )

/*  Default BCTPRD1 register value  */

/* ============================================================== */
 /* Make BCTPRD2 register values based on symbolic constants  */

/*  BCTPRD2 field values  */

	#define BCT_BCTPRD2_PRD_OF(x)			((Uint16)(x))
	#define BCT_BCTPRD2_PRD_DEFAULT		BCT_BCTPRD2_PRD_OF(x)


#define BCT_BCTPRD2_RMK(prd)\
 ((Uint16) ( \
  ( BCT_FMK(BCTPRD2,PRD,prd))\
)\
 )

#define BCT_BCTPRD2_RMKS(prd_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTPRD2,PRD,prd_sym))\
)\
 )

/*  Default BCTPRD2 register value  */

/* ============================================================== */
 /* Make BCTPRD3 register values based on symbolic constants  */

/*  BCTPRD3 field values  */

	#define BCT_BCTPRD3_PRD_OF(x)			((Uint16)(x))
	#define BCT_BCTPRD3_PRD_DEFAULT		BCT_BCTPRD3_PRD_OF(x)


#define BCT_BCTPRD3_RMK(prd)\
 ((Uint16) ( \
  ( BCT_FMK(BCTPRD3,PRD,prd))\
)\
 )

#define BCT_BCTPRD3_RMKS(prd_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTPRD3,PRD,prd_sym))\
)\
 )

/*  Default BCTPRD3 register value  */

/* ============================================================== */
/* Make BCTPRD4 register values based on symbolic constants  */

/*  BCTPRD4 field values  */

	#define BCT_BCTPRD4_PRD_OF(x)			((Uint16)(x))
	#define BCT_BCTPRD4_PRD_DEFAULT		BCT_BCTPRD4_PRD_OF(x)


#define BCT_BCTPRD4_RMK(prd)\
 ((Uint16) ( \
  ( BCT_FMK(BCTPRD4,PRD,prd))\
)\
 )

#define BCT_BCTPRD4_RMKS(prd_sym)\
 ((Uint16) ( \
  ( BCT_FMKS(BCTPRD4,PRD,prd_sym))\
)\
 )

/*  Default BCTPRD4 register value  */
/*************************************************\
 BCT global typedef declarations 
\*************************************************/

typedef struct {
	Uint16 bctemu;
	Uint16 bctgpint;
	Uint16 bctgpen;
	Uint16 bctgpdir;
	Uint16 bctgpdat;
	Uint16 bctprd1;
	Uint16 bctprd2;
	Uint16 bctprd3;
	Uint16 bctprd4;
	Uint16 bctctl1;
	Uint16 bctctl2;
	Uint16 bctgctl1;
} BCT_Config;

typedef struct {
       Uint16 private;
} BCT_Private, *BCT_Handle;

/*************************************************\
* BCT global variable declarations
\*************************************************/


/*************************************************\
* BCT global function declarations
\*************************************************/


#define BCT_initDual32(h, dt1ctl, dt2ctl,dt1prd, dt2prd, dt2prsc)\
  GPT_initDual32((GPT_Handle)(h), dt1ctl, dt2ctl, dt1prd, dt2prd, dt2prsc)

#define BCT_init64(h,gptgctl,dt12ctl,prdHigh,prdLow)\
  GPT_init64((GPT_Handle)(h),gptgctl,dt12ctl,prdHigh,prdLow)

#define BCT_initChained32(h,gctl, ctl1, prdHigh, prdLow)\
  GPT_initChained32((GPT_Handle)(h), (Uint16)(gctl), (Uint16)(ctl1),\
                     (Uint32)(prdHigh), (Uint32)(prdLow))

#define BCT_getPID(h,type,class,revision)\
  GPT_getPID((GPT_Handle)(h), (Uint16 *)(type), (Uint16 *)(class),\
             (Uint16 *)(revision))

#define BCT_getCnt(h,hi32, lo32)\
  GPT_getCnt((GPT_Handle)(h),(Uint32*) hi32, (Uint32*) lo32)

#define BCT_start12(h)\
  GPT_start12((GPT_Handle)(h))

#define BCT_start34(h)\
  GPT_start34((GPT_Handle)(h))

#define BCT_stop(h)\
  GPT_stop((GPT_Handle)(h))

#define BCT_stop12(h)\
  GPT_stop12((GPT_Handle)(h))

#define BCT_stop34(h)\
  GPT_stop34((GPT_Handle)(h))

#define BCT_config(h,myConfig)\
  GPT_config((GPT_Handle)(h),(GPT_Config *)myConfig)

#define BCT_configArgs(h,bctemu,\
             bctprd1,  bctprd2,  bctprd3,  bctprd4,\
             bctgpint, bctgpen,  bctgpdir, bctgpdat,\
             bctctl1,  bctctl2,  bctgctl1)\
   GPT_configArgs((GPT_Handle)(h), bctemu,\
             bctprd1,  bctprd2,  bctprd3,  bctprd4,\
             bctgpint, bctgpen,  bctgpdir, bctgpdat,\
             bctctl1,  bctctl2,  bctgctl1)

#define BCT_getConfig(h,myConfig)\
    GPT_getConfig((GPT_Handle)h, myConfig)

/*************************************************\
* BCT inline function declarations
\*************************************************/

IDECL BCT_Handle BCT_open(void);
IDECL void BCT_close(BCT_Handle h);

#ifdef USEDEFS


/*----------------------------------------------------------------------------*/
IDECL BCT_Handle BCT_open(){
   CSL_SYS_DATA.BctAllocMask = 1;
   return (BCT_Handle)(&(CSL_BCT_DATA));
}
/*----------------------------------------------------------------------------*/
IDECL void BCT_close(BCT_Handle h){
   CSL_SYS_DATA.BctAllocMask = 0;
}
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /*USEDEFS */

#else
  #ifndef _BCT_MOD_
    	#error BCT Hal Module Not Supported on Specified Target
  #endif
#endif  /* _BCT_SUPPORT  */

#endif  /* _CSL_BCTHAL_H  */

/******************************************************************************\
*     
*      End of csl_bct.h 
*
\******************************************************************************/
csl_bctdat.h/   1051539353  0     0     0       2136      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... BCT (Bios Counter)
* FILENAME...... csl_bctdat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED: 02/19/2002
*   MODIFIED: 10 April 2003 added reference for CSL_BctData for .csldata size
*                           fix
*------------------------------------------------------------------------------
* DESCRIPTION:  
*       Reserved ROM Area for Bios Counter Data 
*
*
\******************************************************************************/
#ifndef _CSL_BCT_DATA_H_
#define _CSL_BCT_DATA_H_

#include <csl_std.h>
#include <csl_chiphal.h>

#if (_BCT_SUPPORT)    /* 5502 */
   typedef struct {
 	volatile Uint16 bctpid1;
	volatile Uint16 bctpid2;
	volatile Uint16 bctemu;
	volatile Uint16 bctclk;
	volatile Uint16 bctgpint;
	volatile Uint16 bctgpen;
	volatile Uint16 bctgpdir;
	volatile Uint16 bctgpdat;
	volatile Uint16 bctcnt1;
	volatile Uint16 bctcnt2;
	volatile Uint16 bctcnt3;
	volatile Uint16 bctcnt4;
	volatile Uint16 bctprd1;
	volatile Uint16 bctprd2;
	volatile Uint16 bctprd3;
	volatile Uint16 bctprd4;
	volatile Uint16 bctctl1;
	volatile Uint16 bctctl2;
	volatile Uint16 bctgctl1;
  } BCT_RegObj, *BCT_RegPtr;

  #define CSL_BCTDATAINIT\
   { 0x0000u, 0x0000u, (BCT_RegPtr)0x7800u  }   /* Start of Bios Counter Regs */

  typedef struct {
    Uint16 devNum;
    Uint16 EventId;
    BCT_RegPtr regs;
  }CSL_BctDataObj;
#else
  #define CSL_BCTDATAINIT\
   { 0x0000u  }  /* BCT EventId (dummy this has none) */

  typedef struct {
    Uint16 BCT_reserved;
  }CSL_BctDataObj;
 
#endif  /* BCT_SUPPORT */

extern CSL_BctDataObj CSL_BctData;

#define CSL_BCT_DATA  CSL_BctData

#endif
csl_bcthal.h/   1049976824  0     0     0       49578     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... BCT
* FILENAME...... csl_bcthal.h
* DATE CREATED.. Tue Feb 19 12:02:53 2002
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Tue Feb 19 12:02:53 2002 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL HAL interface file for the BCT module 
*
* Registers covered:
*
* 		 Note: Add registers description here
*	 BCTPID1		- 
*	 BCTPID1		- 
*	 BCTPID2		- 
*	 BCTPID2		- 
*	 BCTEMU		- 
*	 BCTEMU		- 
*	 BCTCLK		- 
*	 BCTCNT1		- 
*	 BCTCNT2		- 
*	 BCTCNT3		- 
*	 BCTCNT4		- 
*	 BCTPRD1		- 
*	 BCTPRD2		- 
*	 BCTPRD3		- 
*	 BCTPRD4		- 
*	 BCTCLK	    	- 
*	 BCTGPINT		- 
*	 BCTGPEN		- 
*	 BCTGPDIR		- 
*	 BCTGPDAT		- 
*	 BCTCTL1		- 
*	 BCTCTL2		- 
*	 BCTGCTL1		- 
*
\*************************************************************************/

#ifndef _CSL_BCTHAL_H_
#define _CSL_BCTHAL_H_

#include <csl_chiphal.h>

#if (_BCT_SUPPORT) 

/*----------------------------------------------------------------*\
*	 BCT scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _BCT_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/*----------------------------------------------------------------*\
*		 Address Macros			
\*----------------------------------------------------------------*/

/*--------------------- Register: BCTPID1 -----------------------*/
#define _BCT_BCTPID1_ADDR		(0x7800u)
#define _BCT_BCTPID1			PREG16(_BCT_BCTPID1_ADDR)
#define BCTPID1			_BCT_BCTPID1


/*--------------------- Register: BCTPID2 -----------------------*/
#define _BCT_BCTPID2_ADDR		(0x7801u)
#define _BCT_BCTPID2			PREG16(_BCT_BCTPID2_ADDR)
#define BCTPID2			_BCT_BCTPID2


/*--------------------- Register: BCTEMU -----------------------*/
#define _BCT_BCTEMU_ADDR		(0x7802u)
#define _BCT_BCTEMU			PREG16(_BCT_BCTEMU_ADDR)
#define BCTEMU			_BCT_BCTEMU


/*--------------------- Register: BCTCLK -----------------------*/
#define _BCT_BCTCLK_ADDR		(0x7803u)
#define _BCT_BCTCLK			PREG16(_BCT_BCTCLK_ADDR)
#define BCTCLK			_BCT_BCTCLK


/*--------------------- Register: BCTCNT1 -----------------------*/
#define _BCT_BCTCNT1_ADDR		(0x7808u)
#define _BCT_BCTCNT1			PREG16(_BCT_BCTCNT1_ADDR)
#define BCTCNT1			_BCT_BCTCNT1


/*--------------------- Register: BCTCNT2 -----------------------*/
#define _BCT_BCTCNT2_ADDR		(0x7809u)
#define _BCT_BCTCNT2			PREG16(_BCT_BCTCNT2_ADDR)
#define BCTCNT2			_BCT_BCTCNT2


/*--------------------- Register: BCTCNT3 -----------------------*/
#define _BCT_BCTCNT3_ADDR		(0x780Au)
#define _BCT_BCTCNT3			PREG16(_BCT_BCTCNT3_ADDR)
#define BCTCNT3			_BCT_BCTCNT3


/*--------------------- Register: BCTCNT4 -----------------------*/
#define _BCT_BCTCNT4_ADDR		(0x780Bu)
#define _BCT_BCTCNT4			PREG16(_BCT_BCTCNT4_ADDR)
#define BCTCNT4			_BCT_BCTCNT4


/*--------------------- Register: BCTPRD1 -----------------------*/
#define _BCT_BCTPRD1_ADDR		(0x780Cu)
#define _BCT_BCTPRD1			PREG16(_BCT_BCTPRD1_ADDR)
#define BCTPRD1			_BCT_BCTPRD1


/*--------------------- Register: BCTPRD2 -----------------------*/
#define _BCT_BCTPRD2_ADDR		(0x780Du)
#define _BCT_BCTPRD2			PREG16(_BCT_BCTPRD2_ADDR)
#define BCTPRD2			_BCT_BCTPRD2


/*--------------------- Register: BCTPRD3 -----------------------*/
#define _BCT_BCTPRD3_ADDR		(0x780Eu)
#define _BCT_BCTPRD3			PREG16(_BCT_BCTPRD3_ADDR)
#define BCTPRD3			_BCT_BCTPRD3


/*--------------------- Register: BCTPRD4 -----------------------*/
#define _BCT_BCTPRD4_ADDR		(0x780Fu)
#define _BCT_BCTPRD4			PREG16(_BCT_BCTPRD4_ADDR)
#define BCTPRD4			_BCT_BCTPRD4


/*--------------------- Register: BCTGPINT -----------------------*/
#define _BCT_BCTGPINT_ADDR		(0x7804u)
#define _BCT_BCTGPINT			PREG16(_BCT_BCTGPINT_ADDR)
#define BCTGPINT			_BCT_BCTGPINT


/*--------------------- Register: BCTGPEN -----------------------*/
#define _BCT_BCTGPEN_ADDR		(0x7805u)
#define _BCT_BCTGPEN			PREG16(_BCT_BCTGPEN_ADDR)
#define BCTGPEN			_BCT_BCTGPEN


/*--------------------- Register: BCTGPDIR -----------------------*/
#define _BCT_BCTGPDIR_ADDR		(0x7807u)
#define _BCT_BCTGPDIR			PREG16(_BCT_BCTGPDIR_ADDR)
#define BCTGPDIR			_BCT_BCTGPDIR


/*--------------------- Register: BCTGPDAT -----------------------*/
#define _BCT_BCTGPDAT_ADDR		(0x7806u)
#define _BCT_BCTGPDAT			PREG16(_BCT_BCTGPDAT_ADDR)
#define BCTGPDAT			_BCT_BCTGPDAT


/*--------------------- Register: BCTCTL1 -----------------------*/
#define _BCT_BCTCTL1_ADDR		(0x7810u)
#define _BCT_BCTCTL1			PREG16(_BCT_BCTCTL1_ADDR)
#define BCTCTL1     			_BCT_BCTCTL1


/*--------------------- Register: BCTCTL2 -----------------------*/
#define _BCT_BCTCTL2_ADDR		(0x7811u)
#define _BCT_BCTCTL2			PREG16(_BCT_BCTCTL2_ADDR)
#define BCTCTL2			        _BCT_BCTCTL2


/*--------------------- Register: BCTGCTL1 -----------------------*/
#define _BCT_BCTGCTL1_ADDR		(0x7812u)
#define _BCT_BCTGCTL1			PREG16(_BCT_BCTGCTL1_ADDR)
#define BCTGCTL1			_BCT_BCTGCTL1



/*----------------------------------------------------------------*\
*		 Register Macros		
\*----------------------------------------------------------------*/

#define BCT_ADDR(Reg)		  _BCT_##Reg##_ADDR
#define BCT_RGET(Reg)		  _BCT_##Reg##_GET
#define BCT_RSET(Reg,Val)		  _BCT_##Reg##_SET(Val)
#define BCT_FGET(Reg,Field)		  _BCT_##Reg##_FGET(Field)
#define BCT_FSET(Reg,Field,Val)		  _BCT_##Reg##_FSET(Field, Val)
#define BCT_FMK(Reg,Field,Val)		  _BCT_##Reg##_##Field##_MK(Val)
#define BCT_RAOI(Reg,AND,OR,INV)		  _BCT_##Reg##_AOI(AND,OR,INV)
#define BCT_FAOI(Reg,Field,AND,OR,INV)	  _BCT_##Reg##_FAOI(Field,AND,OR,INV)
#define BCT_FMKS(Reg,Field,Sym)\
	  _BCT_##Reg##_##Field##_MK(BCT_##Reg##_##Field##_##Sym)
#define BCT_FSETS(Reg,Field,Sym)\
	  _BCT_FSET(Reg,Field,BCT_##Reg##_##Field##_##Sym)

#define BCT_ADDRH(h,Reg)		  _BCT_##Reg##_ADDR
#define BCT_RGETH(h,Reg)		  _BCT_##Reg##_GET
#define BCT_RSETH(h,Reg,Val)		  _BCT_##Reg##_SET(Val)
#define BCT_FGETH(h,Reg,Field)		  _BCT_##Reg##_FGET(Field)
#define BCT_FSETH(h,Reg,Field,Val)		  _BCT_##Reg##_FSET(Field, Val)
#define BCT_FMKH(h,Reg,Field,Val)		  _BCT_##Reg##_##Field##_MK(Val)
#define BCT_RAOIH(h,Reg,AND,OR,INV)		  _BCT_##Reg##_AOI(AND,OR,INV)
#define BCT_FAOIH(h,Reg,Field,AND,OR,INV)	  _BCT_##Reg##_FAOI(Field,AND,OR,INV)
#define BCT_FMKSH(h,Reg,Field,Sym)\
	  _BCT_##Reg##_##Field##_MK(BCT_##Reg##_##Field##_##Sym)
#define BCT_FSETSH(h,Reg,Field,Sym)\
	  _BCT_FSET(Reg,Field,BCT_##Reg##_##Field##_##Sym)

/*----------------------------------------------------------------*\
*		 Non-handle Registers Macros		
\*----------------------------------------------------------------*/


/*--------------------- Register: BCTPID1 -----------------------*/
#define _BCT_BCTPID1_GET		  _PREG_GET(_BCT_BCTPID1_ADDR) 
#define _BCT_BCTPID1_SET(Val)		  _PREG_SET(_BCT_BCTPID1_ADDR,Val)
#define _BCT_BCTPID1_FGET(Field)	  _PFIELD_GET(_BCT_BCTPID1_ADDR, _BCT_BCTPID1_##Field)
#define _BCT_BCTPID1_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTPID1_ADDR, _BCT_BCTPID1_##Field, Val)
#define _BCT_BCTPID1_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTPID1_ADDR,AND,OR,INV)
#define _BCT_BCTPID1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTPID1_ADDR, _BCT_BCTPID1_##Field,AND,OR,INV)


/*--------------------- Register: BCTPID1 -----------------------*/
#define _BCT_BCTPID1_GET		  _PREG_GET(_BCT_BCTPID1_ADDR) 
#define _BCT_BCTPID1_SET(Val)		  _PREG_SET(_BCT_BCTPID1_ADDR,Val)
#define _BCT_BCTPID1_FGET(Field)	  _PFIELD_GET(_BCT_BCTPID1_ADDR, _BCT_BCTPID1_##Field)
#define _BCT_BCTPID1_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTPID1_ADDR, _BCT_BCTPID1_##Field, Val)
#define _BCT_BCTPID1_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTPID1_ADDR,AND,OR,INV)
#define _BCT_BCTPID1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTPID1_ADDR, _BCT_BCTPID1_##Field,AND,OR,INV)


/*--------------------- Register: BCTPID2 -----------------------*/
#define _BCT_BCTPID2_GET		  _PREG_GET(_BCT_BCTPID2_ADDR) 
#define _BCT_BCTPID2_SET(Val)		  _PREG_SET(_BCT_BCTPID2_ADDR,Val)
#define _BCT_BCTPID2_FGET(Field)	  _PFIELD_GET(_BCT_BCTPID2_ADDR, _BCT_BCTPID2_##Field)
#define _BCT_BCTPID2_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTPID2_ADDR, _BCT_BCTPID2_##Field, Val)
#define _BCT_BCTPID2_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTPID2_ADDR,AND,OR,INV)
#define _BCT_BCTPID2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTPID2_ADDR, _BCT_BCTPID2_##Field,AND,OR,INV)


/*--------------------- Register: BCTPID2 -----------------------*/
#define _BCT_BCTPID2_GET		  _PREG_GET(_BCT_BCTPID2_ADDR) 
#define _BCT_BCTPID2_SET(Val)		  _PREG_SET(_BCT_BCTPID2_ADDR,Val)
#define _BCT_BCTPID2_FGET(Field)	  _PFIELD_GET(_BCT_BCTPID2_ADDR, _BCT_BCTPID2_##Field)
#define _BCT_BCTPID2_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTPID2_ADDR, _BCT_BCTPID2_##Field, Val)
#define _BCT_BCTPID2_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTPID2_ADDR,AND,OR,INV)
#define _BCT_BCTPID2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTPID2_ADDR, _BCT_BCTPID2_##Field,AND,OR,INV)


/*--------------------- Register: BCTEMU -----------------------*/
#define _BCT_BCTEMU_GET		  _PREG_GET(_BCT_BCTEMU_ADDR) 
#define _BCT_BCTEMU_SET(Val)		  _PREG_SET(_BCT_BCTEMU_ADDR,Val)
#define _BCT_BCTEMU_FGET(Field)	  _PFIELD_GET(_BCT_BCTEMU_ADDR, _BCT_BCTEMU_##Field)
#define _BCT_BCTEMU_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTEMU_ADDR, _BCT_BCTEMU_##Field, Val)
#define _BCT_BCTEMU_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTEMU_ADDR,AND,OR,INV)
#define _BCT_BCTEMU_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTEMU_ADDR, _BCT_BCTEMU_##Field,AND,OR,INV)


/*--------------------- Register: BCTEMU -----------------------*/
#define _BCT_BCTEMU_GET		  _PREG_GET(_BCT_BCTEMU_ADDR) 
#define _BCT_BCTEMU_SET(Val)		  _PREG_SET(_BCT_BCTEMU_ADDR,Val)
#define _BCT_BCTEMU_FGET(Field)	  _PFIELD_GET(_BCT_BCTEMU_ADDR, _BCT_BCTEMU_##Field)
#define _BCT_BCTEMU_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTEMU_ADDR, _BCT_BCTEMU_##Field, Val)
#define _BCT_BCTEMU_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTEMU_ADDR,AND,OR,INV)
#define _BCT_BCTEMU_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTEMU_ADDR, _BCT_BCTEMU_##Field,AND,OR,INV)


/*--------------------- Register: BCTCLK -----------------------*/
#define _BCT_BCTCLK_GET		  _PREG_GET(_BCT_BCTCLK_ADDR) 
#define _BCT_BCTCLK_SET(Val)		  _PREG_SET(_BCT_BCTCLK_ADDR,Val)
#define _BCT_BCTCLK_FGET(Field)	  _PFIELD_GET(_BCT_BCTCLK_ADDR, _BCT_BCTCLK_##Field)
#define _BCT_BCTCLK_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTCLK_ADDR, _BCT_BCTCLK_##Field, Val)
#define _BCT_BCTCLK_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTCLK_ADDR,AND,OR,INV)
#define _BCT_BCTCLK_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTCLK_ADDR, _BCT_BCTCLK_##Field,AND,OR,INV)


/*--------------------- Register: BCTCNT1 -----------------------*/
#define _BCT_BCTCNT1_GET		  _PREG_GET(_BCT_BCTCNT1_ADDR) 
#define _BCT_BCTCNT1_SET(Val)		  _PREG_SET(_BCT_BCTCNT1_ADDR,Val)
#define _BCT_BCTCNT1_FGET(Field)	  _PFIELD_GET(_BCT_BCTCNT1_ADDR, _BCT_BCTCNT1_##Field)
#define _BCT_BCTCNT1_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTCNT1_ADDR, _BCT_BCTCNT1_##Field, Val)
#define _BCT_BCTCNT1_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTCNT1_ADDR,AND,OR,INV)
#define _BCT_BCTCNT1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTCNT1_ADDR, _BCT_BCTCNT1_##Field,AND,OR,INV)


/*--------------------- Register: BCTCNT2 -----------------------*/
#define _BCT_BCTCNT2_GET		  _PREG_GET(_BCT_BCTCNT2_ADDR) 
#define _BCT_BCTCNT2_SET(Val)		  _PREG_SET(_BCT_BCTCNT2_ADDR,Val)
#define _BCT_BCTCNT2_FGET(Field)	  _PFIELD_GET(_BCT_BCTCNT2_ADDR, _BCT_BCTCNT2_##Field)
#define _BCT_BCTCNT2_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTCNT2_ADDR, _BCT_BCTCNT2_##Field, Val)
#define _BCT_BCTCNT2_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTCNT2_ADDR,AND,OR,INV)
#define _BCT_BCTCNT2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTCNT2_ADDR, _BCT_BCTCNT2_##Field,AND,OR,INV)


/*--------------------- Register: BCTCNT3 -----------------------*/
#define _BCT_BCTCNT3_GET		  _PREG_GET(_BCT_BCTCNT3_ADDR) 
#define _BCT_BCTCNT3_SET(Val)		  _PREG_SET(_BCT_BCTCNT3_ADDR,Val)
#define _BCT_BCTCNT3_FGET(Field)	  _PFIELD_GET(_BCT_BCTCNT3_ADDR, _BCT_BCTCNT3_##Field)
#define _BCT_BCTCNT3_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTCNT3_ADDR, _BCT_BCTCNT3_##Field, Val)
#define _BCT_BCTCNT3_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTCNT3_ADDR,AND,OR,INV)
#define _BCT_BCTCNT3_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTCNT3_ADDR, _BCT_BCTCNT3_##Field,AND,OR,INV)


/*--------------------- Register: BCTCNT4 -----------------------*/
#define _BCT_BCTCNT4_GET		  _PREG_GET(_BCT_BCTCNT4_ADDR) 
#define _BCT_BCTCNT4_SET(Val)		  _PREG_SET(_BCT_BCTCNT4_ADDR,Val)
#define _BCT_BCTCNT4_FGET(Field)	  _PFIELD_GET(_BCT_BCTCNT4_ADDR, _BCT_BCTCNT4_##Field)
#define _BCT_BCTCNT4_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTCNT4_ADDR, _BCT_BCTCNT4_##Field, Val)
#define _BCT_BCTCNT4_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTCNT4_ADDR,AND,OR,INV)
#define _BCT_BCTCNT4_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTCNT4_ADDR, _BCT_BCTCNT4_##Field,AND,OR,INV)


/*--------------------- Register: BCTPRD1 -----------------------*/
#define _BCT_BCTPRD1_GET		  _PREG_GET(_BCT_BCTPRD1_ADDR) 
#define _BCT_BCTPRD1_SET(Val)		  _PREG_SET(_BCT_BCTPRD1_ADDR,Val)
#define _BCT_BCTPRD1_FGET(Field)	  _PFIELD_GET(_BCT_BCTPRD1_ADDR, _BCT_BCTPRD1_##Field)
#define _BCT_BCTPRD1_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTPRD1_ADDR, _BCT_BCTPRD1_##Field, Val)
#define _BCT_BCTPRD1_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTPRD1_ADDR,AND,OR,INV)
#define _BCT_BCTPRD1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTPRD1_ADDR, _BCT_BCTPRD1_##Field,AND,OR,INV)


/*--------------------- Register: BCTPRD2 -----------------------*/
#define _BCT_BCTPRD2_GET		  _PREG_GET(_BCT_BCTPRD2_ADDR) 
#define _BCT_BCTPRD2_SET(Val)		  _PREG_SET(_BCT_BCTPRD2_ADDR,Val)
#define _BCT_BCTPRD2_FGET(Field)	  _PFIELD_GET(_BCT_BCTPRD2_ADDR, _BCT_BCTPRD2_##Field)
#define _BCT_BCTPRD2_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTPRD2_ADDR, _BCT_BCTPRD2_##Field, Val)
#define _BCT_BCTPRD2_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTPRD2_ADDR,AND,OR,INV)
#define _BCT_BCTPRD2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTPRD2_ADDR, _BCT_BCTPRD2_##Field,AND,OR,INV)


/*--------------------- Register: BCTPRD3 -----------------------*/
#define _BCT_BCTPRD3_GET		  _PREG_GET(_BCT_BCTPRD3_ADDR) 
#define _BCT_BCTPRD3_SET(Val)		  _PREG_SET(_BCT_BCTPRD3_ADDR,Val)
#define _BCT_BCTPRD3_FGET(Field)	  _PFIELD_GET(_BCT_BCTPRD3_ADDR, _BCT_BCTPRD3_##Field)
#define _BCT_BCTPRD3_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTPRD3_ADDR, _BCT_BCTPRD3_##Field, Val)
#define _BCT_BCTPRD3_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTPRD3_ADDR,AND,OR,INV)
#define _BCT_BCTPRD3_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTPRD3_ADDR, _BCT_BCTPRD3_##Field,AND,OR,INV)


/*--------------------- Register: BCTPRD4 -----------------------*/
#define _BCT_BCTPRD4_GET		  _PREG_GET(_BCT_BCTPRD4_ADDR) 
#define _BCT_BCTPRD4_SET(Val)		  _PREG_SET(_BCT_BCTPRD4_ADDR,Val)
#define _BCT_BCTPRD4_FGET(Field)	  _PFIELD_GET(_BCT_BCTPRD4_ADDR, _BCT_BCTPRD4_##Field)
#define _BCT_BCTPRD4_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTPRD4_ADDR, _BCT_BCTPRD4_##Field, Val)
#define _BCT_BCTPRD4_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTPRD4_ADDR,AND,OR,INV)
#define _BCT_BCTPRD4_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTPRD4_ADDR, _BCT_BCTPRD4_##Field,AND,OR,INV)


/*--------------------- Register: BCTGPINT -----------------------*/
#define _BCT_BCTGPINT_GET		  _PREG_GET(_BCT_BCTGPINT_ADDR) 
#define _BCT_BCTGPINT_SET(Val)		  _PREG_SET(_BCT_BCTGPINT_ADDR,Val)
#define _BCT_BCTGPINT_FGET(Field)	  _PFIELD_GET(_BCT_BCTGPINT_ADDR, _BCT_BCTGPINT_##Field)
#define _BCT_BCTGPINT_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTGPINT_ADDR, _BCT_BCTGPINT_##Field, Val)
#define _BCT_BCTGPINT_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTGPINT_ADDR,AND,OR,INV)
#define _BCT_BCTGPINT_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTGPINT_ADDR, _BCT_BCTGPINT_##Field,AND,OR,INV)


/*--------------------- Register: BCTGPEN -----------------------*/
#define _BCT_BCTGPEN_GET		  _PREG_GET(_BCT_BCTGPEN_ADDR) 
#define _BCT_BCTGPEN_SET(Val)		  _PREG_SET(_BCT_BCTGPEN_ADDR,Val)
#define _BCT_BCTGPEN_FGET(Field)	  _PFIELD_GET(_BCT_BCTGPEN_ADDR, _BCT_BCTGPEN_##Field)
#define _BCT_BCTGPEN_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTGPEN_ADDR, _BCT_BCTGPEN_##Field, Val)
#define _BCT_BCTGPEN_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTGPEN_ADDR,AND,OR,INV)
#define _BCT_BCTGPEN_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTGPEN_ADDR, _BCT_BCTGPEN_##Field,AND,OR,INV)



/*--------------------- Register: BCTGPDIR -----------------------*/
#define _BCT_BCTGPDIR_GET		  _PREG_GET(_BCT_BCTGPDIR_ADDR) 
#define _BCT_BCTGPDIR_SET(Val)		  _PREG_SET(_BCT_BCTGPDIR_ADDR,Val)
#define _BCT_BCTGPDIR_FGET(Field)	  _PFIELD_GET(_BCT_BCTGPDIR_ADDR, _BCT_BCTGPDIR_##Field)
#define _BCT_BCTGPDIR_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTGPDIR_ADDR, _BCT_BCTGPDIR_##Field, Val)
#define _BCT_BCTGPDIR_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTGPDIR_ADDR,AND,OR,INV)
#define _BCT_BCTGPDIR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTGPDIR_ADDR, _BCT_BCTGPDIR_##Field,AND,OR,INV)


/*--------------------- Register: BCTGPDAT -----------------------*/
#define _BCT_BCTGPDAT_GET		  _PREG_GET(_BCT_BCTGPDAT_ADDR) 
#define _BCT_BCTGPDAT_SET(Val)		  _PREG_SET(_BCT_BCTGPDAT_ADDR,Val)
#define _BCT_BCTGPDAT_FGET(Field)	  _PFIELD_GET(_BCT_BCTGPDAT_ADDR, _BCT_BCTGPDAT_##Field)
#define _BCT_BCTGPDAT_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTGPDAT_ADDR, _BCT_BCTGPDAT_##Field, Val)
#define _BCT_BCTGPDAT_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTGPDAT_ADDR,AND,OR,INV)
#define _BCT_BCTGPDAT_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTGPDAT_ADDR, _BCT_BCTGPDAT_##Field,AND,OR,INV)


/*--------------------- Register: BCTCTL1 -----------------------*/
#define _BCT_BCTCTL1_GET		  _PREG_GET(_BCT_BCTCTL1_ADDR) 
#define _BCT_BCTCTL1_SET(Val)		  _PREG_SET(_BCT_BCTCTL1_ADDR,Val)
#define _BCT_BCTCTL1_FGET(Field)	  _PFIELD_GET(_BCT_BCTCTL1_ADDR, _BCT_BCTCTL1_##Field)
#define _BCT_BCTCTL1_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTCTL1_ADDR, _BCT_BCTCTL1_##Field, Val)
#define _BCT_BCTCTL1_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTCTL1_ADDR,AND,OR,INV)
#define _BCT_BCTCTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTCTL1_ADDR, _BCT_BCTCTL1_##Field,AND,OR,INV)


/*--------------------- Register: BCTCTL2 -----------------------*/
#define _BCT_BCTCTL2_GET		  _PREG_GET(_BCT_BCTCTL2_ADDR) 
#define _BCT_BCTCTL2_SET(Val)		  _PREG_SET(_BCT_BCTCTL2_ADDR,Val)
#define _BCT_BCTCTL2_FGET(Field)	  _PFIELD_GET(_BCT_BCTCTL2_ADDR, _BCT_BCTCTL2_##Field)
#define _BCT_BCTCTL2_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTCTL2_ADDR, _BCT_BCTCTL2_##Field, Val)
#define _BCT_BCTCTL2_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTCTL2_ADDR,AND,OR,INV)
#define _BCT_BCTCTL2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTCTL2_ADDR, _BCT_BCTCTL2_##Field,AND,OR,INV)


/*--------------------- Register: BCTGCTL1 -----------------------*/
#define _BCT_BCTGCTL1_GET		  _PREG_GET(_BCT_BCTGCTL1_ADDR) 
#define _BCT_BCTGCTL1_SET(Val)		  _PREG_SET(_BCT_BCTGCTL1_ADDR,Val)
#define _BCT_BCTGCTL1_FGET(Field)	  _PFIELD_GET(_BCT_BCTGCTL1_ADDR, _BCT_BCTGCTL1_##Field)
#define _BCT_BCTGCTL1_FSET(Field,Val)	  _PFIELD_SET(_BCT_BCTGCTL1_ADDR, _BCT_BCTGCTL1_##Field, Val)
#define _BCT_BCTGCTL1_AOI(AND,OR,INV)	  _PREG_AOI(_BCT_BCTGCTL1_ADDR,AND,OR,INV)
#define _BCT_BCTGCTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_BCT_BCTGCTL1_ADDR, _BCT_BCTGCTL1_##Field,AND,OR,INV)



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTGCTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTGCTL1	 - Note: Add description here
*
* Fields:
*	(RW)   _BCT_BCTGCTL1_TIM12RS	
*	(RW)   _BCT_BCTGCTL1_TIM34RS	
*	(RW)   _BCT_BCTGCTL1_TIMMODE	
*	(RW)   _BCT_BCTGCTL1_PSC34	
*	(R)   _BCT_BCTGCTL1_TDDR34	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGCTL1_TIM12RS:	
\*----------------------------------------------------------------*/

#define _BCT_BCTGCTL1_TIM12RS_SHIFT		(000000u)
#define _BCT_BCTGCTL1_TIM12RS_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTGCTL1_TIM12RS_SHIFT)
#define _BCT_BCTGCTL1_TIM12RS_MASK		(_BCT_BCTGCTL1_TIM12RS_MK(0x0001u))
#define _BCT_BCTGCTL1_TIM12RS_CLR		(~(_BCT_BCTGCTL1_TIM12RS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGCTL1_TIM34RS:	
\*----------------------------------------------------------------*/

#define _BCT_BCTGCTL1_TIM34RS_SHIFT		(0x0001u)
#define _BCT_BCTGCTL1_TIM34RS_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTGCTL1_TIM34RS_SHIFT)
#define _BCT_BCTGCTL1_TIM34RS_MASK		(_BCT_BCTGCTL1_TIM34RS_MK(0x0001u))
#define _BCT_BCTGCTL1_TIM34RS_CLR		(~(_BCT_BCTGCTL1_TIM34RS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGCTL1_TIMMODE:	
\*----------------------------------------------------------------*/

#define _BCT_BCTGCTL1_TIMMODE_SHIFT		(0x0002u)
#define _BCT_BCTGCTL1_TIMMODE_MK(n)		(((Uint16)(n) & 0x0003u) << _BCT_BCTGCTL1_TIMMODE_SHIFT)
#define _BCT_BCTGCTL1_TIMMODE_MASK		(_BCT_BCTGCTL1_TIMMODE_MK(0x0003u))
#define _BCT_BCTGCTL1_TIMMODE_CLR		(~(_BCT_BCTGCTL1_TIMMODE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGCTL1_PSC34:	
\*----------------------------------------------------------------*/

#define _BCT_BCTGCTL1_PSC34_SHIFT		(0x0008u)
#define _BCT_BCTGCTL1_PSC34_MK(n)		(((Uint16)(n) & 0x000fu) << _BCT_BCTGCTL1_PSC34_SHIFT)
#define _BCT_BCTGCTL1_PSC34_MASK		(_BCT_BCTGCTL1_PSC34_MK(0x000fu))
#define _BCT_BCTGCTL1_PSC34_CLR		(~(_BCT_BCTGCTL1_PSC34_MASK))



/*----------------------------------------------------------------*\
*   (R)  _BCT_BCTGCTL1_TDDR34:	
\*----------------------------------------------------------------*/

#define _BCT_BCTGCTL1_TDDR34_SHIFT		(0x000cu)
#define _BCT_BCTGCTL1_TDDR34_MK(n)		(((Uint16)(n) & 0x000fu) << _BCT_BCTGCTL1_TDDR34_SHIFT)
#define _BCT_BCTGCTL1_TDDR34_MASK		(_BCT_BCTGCTL1_TDDR34_MK(0x000fu))
#define _BCT_BCTGCTL1_TDDR34_CLR		(~(_BCT_BCTGCTL1_TDDR34_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTGPDIR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTGPDIR	 - Note: Add description here
*
* Fields:
*	(RW)   _BCT_BCTGPDIR_TIN1DIR	
*	(RW)   _BCT_BCTGPDIR_TOUT1DIR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGPDIR_TIN1DIR:	
\*----------------------------------------------------------------*/

#define _BCT_BCTGPDIR_TIN1DIR_SHIFT		(000000u)
#define _BCT_BCTGPDIR_TIN1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTGPDIR_TIN1DIR_SHIFT)
#define _BCT_BCTGPDIR_TIN1DIR_MASK		(_BCT_BCTGPDIR_TIN1DIR_MK(0x0001u))
#define _BCT_BCTGPDIR_TIN1DIR_CLR		(~(_BCT_BCTGPDIR_TIN1DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGPDIR_TOUT1DIR:	
\*----------------------------------------------------------------*/

#define _BCT_BCTGPDIR_TOUT1DIR_SHIFT		(0x0001u)
#define _BCT_BCTGPDIR_TOUT1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTGPDIR_TOUT1DIR_SHIFT)
#define _BCT_BCTGPDIR_TOUT1DIR_MASK		(_BCT_BCTGPDIR_TOUT1DIR_MK(0x0001u))
#define _BCT_BCTGPDIR_TOUT1DIR_CLR		(~(_BCT_BCTGPDIR_TOUT1DIR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTPRD1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTPRD1	 - Note: Add description here
*
* Fields:
*	(RW)   _BCT_BCTPRD1_PRD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTPRD1_PRD:	
\*----------------------------------------------------------------*/

#define _BCT_BCTPRD1_PRD_SHIFT		(000000u)
#define _BCT_BCTPRD1_PRD_MK(n)		(((Uint16)(n) & 0xffffu) << _BCT_BCTPRD1_PRD_SHIFT)
#define _BCT_BCTPRD1_PRD_MASK		(_BCT_BCTPRD1_PRD_MK(0xffffu))
#define _BCT_BCTPRD1_PRD_CLR		(~(_BCT_BCTPRD1_PRD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTCNT1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTCNT1	 - Note: Add description here
*
* Fields:
*	(RW)   _BCT_BCTCNT1_CNT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCNT1_CNT:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCNT1_CNT_SHIFT		(000000u)
#define _BCT_BCTCNT1_CNT_MK(n)		(((Uint16)(n) & 0xffffu) << _BCT_BCTCNT1_CNT_SHIFT)
#define _BCT_BCTCNT1_CNT_MASK		(_BCT_BCTCNT1_CNT_MK(0xffffu))
#define _BCT_BCTCNT1_CNT_CLR		(~(_BCT_BCTCNT1_CNT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTPRD2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTPRD2	 - Note: Add description here
*
* Fields:
*	(RW)   _BCT_BCTPRD2_PRD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTPRD2_PRD:	
\*----------------------------------------------------------------*/

#define _BCT_BCTPRD2_PRD_SHIFT		(000000u)
#define _BCT_BCTPRD2_PRD_MK(n)		(((Uint16)(n) & 0xffffu) << _BCT_BCTPRD2_PRD_SHIFT)
#define _BCT_BCTPRD2_PRD_MASK		(_BCT_BCTPRD2_PRD_MK(0xffffu))
#define _BCT_BCTPRD2_PRD_CLR		(~(_BCT_BCTPRD2_PRD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTCNT2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTCNT2	 - Note: Add description here
*
* Fields:
*	(RW)   _BCT_BCTCNT2_CNT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCNT2_CNT:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCNT2_CNT_SHIFT		(000000u)
#define _BCT_BCTCNT2_CNT_MK(n)		(((Uint16)(n) & 0xffffu) << _BCT_BCTCNT2_CNT_SHIFT)
#define _BCT_BCTCNT2_CNT_MASK		(_BCT_BCTCNT2_CNT_MK(0xffffu))
#define _BCT_BCTCNT2_CNT_CLR		(~(_BCT_BCTCNT2_CNT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTCTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTCTL1	 - Note: Add description here
*
* Fields:
*	(R)   _BCT_BCTCTL1_TSTAT	
*	(RW)   _BCT_BCTCTL1_INVOUT	
*	(RW)   _BCT_BCTCTL1_INVIN	
*	(RW)   _BCT_BCTCTL1_CP	
*	(RW)   _BCT_BCTCTL1_PWID	
*	(RW)   _BCT_BCTCTL1_ENAMODE	
*	(RW)   _BCT_BCTCTL1_CLKSRC	
*	(RW)   _BCT_BCTCTL1_TIEN	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _BCT_BCTCTL1_TSTAT:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL1_TSTAT_SHIFT		(000000u)
#define _BCT_BCTCTL1_TSTAT_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL1_TSTAT_SHIFT)
#define _BCT_BCTCTL1_TSTAT_MASK		(_BCT_BCTCTL1_TSTAT_MK(0x0001u))
#define _BCT_BCTCTL1_TSTAT_CLR		(~(_BCT_BCTCTL1_TSTAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL1_INVOUTP:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL1_INVOUT_SHIFT		(0x0001u)
#define _BCT_BCTCTL1_INVOUT_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL1_INVOUT_SHIFT)
#define _BCT_BCTCTL1_INVOUT_MASK		(_BCT_BCTCTL1_INVOUT_MK(0x0001u))
#define _BCT_BCTCTL1_INVOUT_CLR		(~(_BCT_BCTCTL1_INVOUT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL1_INVIN:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL1_INVIN_SHIFT		(0x0002u)
#define _BCT_BCTCTL1_INVIN_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL1_INVIN_SHIFT)
#define _BCT_BCTCTL1_INVIN_MASK		(_BCT_BCTCTL1_INVIN_MK(0x0001u))
#define _BCT_BCTCTL1_INVIN_CLR		(~(_BCT_BCTCTL1_INVIN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL1_CP:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL1_CP_SHIFT		(0x0003u)
#define _BCT_BCTCTL1_CP_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL1_CP_SHIFT)
#define _BCT_BCTCTL1_CP_MASK		(_BCT_BCTCTL1_CP_MK(0x0001u))
#define _BCT_BCTCTL1_CP_CLR		(~(_BCT_BCTCTL1_CP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL1_PWID:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL1_PWID_SHIFT		(0x0004u)
#define _BCT_BCTCTL1_PWID_MK(n)		(((Uint16)(n) & 0x0003u) << _BCT_BCTCTL1_PWID_SHIFT)
#define _BCT_BCTCTL1_PWID_MASK		(_BCT_BCTCTL1_PWID_MK(0x0003u))
#define _BCT_BCTCTL1_PWID_CLR		(~(_BCT_BCTCTL1_PWID_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL1_ENAMODE:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL1_ENAMODE_SHIFT		(0x0006u)
#define _BCT_BCTCTL1_ENAMODE_MK(n)		(((Uint16)(n) & 0x0003u) << _BCT_BCTCTL1_ENAMODE_SHIFT)
#define _BCT_BCTCTL1_ENAMODE_MASK		(_BCT_BCTCTL1_ENAMODE_MK(0x0003u))
#define _BCT_BCTCTL1_ENAMODE_CLR		(~(_BCT_BCTCTL1_ENAMODE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL1_CLKSRC:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL1_CLKSRC_SHIFT		(0x0008u)
#define _BCT_BCTCTL1_CLKSRC_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL1_CLKSRC_SHIFT)
#define _BCT_BCTCTL1_CLKSRC_MASK		(_BCT_BCTCTL1_CLKSRC_MK(0x0001u))
#define _BCT_BCTCTL1_CLKSRC_CLR		(~(_BCT_BCTCTL1_CLKSRC_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL1_TIEN:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL1_TIEN_SHIFT		(0x0009u)
#define _BCT_BCTCTL1_TIEN_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL1_TIEN_SHIFT)
#define _BCT_BCTCTL1_TIEN_MASK		(_BCT_BCTCTL1_TIEN_MK(0x0001u))
#define _BCT_BCTCTL1_TIEN_CLR		(~(_BCT_BCTCTL1_TIEN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTPRD3 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTPRD3	 - Note: Add description here
*
* Fields:
*	(RW)   _BCT_BCTPRD3_PRD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTPRD3_PRD:	
\*----------------------------------------------------------------*/

#define _BCT_BCTPRD3_PRD_SHIFT		(000000u)
#define _BCT_BCTPRD3_PRD_MK(n)		(((Uint16)(n) & 0xffffu) << _BCT_BCTPRD3_PRD_SHIFT)
#define _BCT_BCTPRD3_PRD_MASK		(_BCT_BCTPRD3_PRD_MK(0xffffu))
#define _BCT_BCTPRD3_PRD_CLR		(~(_BCT_BCTPRD3_PRD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTCNT3 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTCNT3	 - Note: Add description here
*
* Fields:
*	(RW)   _BCT_BCTCNT3_CNT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCNT3_CNT:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCNT3_CNT_SHIFT		(000000u)
#define _BCT_BCTCNT3_CNT_MK(n)		(((Uint16)(n) & 0xffffu) << _BCT_BCTCNT3_CNT_SHIFT)
#define _BCT_BCTCNT3_CNT_MASK		(_BCT_BCTCNT3_CNT_MK(0xffffu))
#define _BCT_BCTCNT3_CNT_CLR		(~(_BCT_BCTCNT3_CNT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTCLK register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTCLK	 - Note: Add description here
*
* Fields:
*	(R)   _BCT_BCTCLK_VBUSCR	
*
\******************************************************************************/


/*----------------------------------------------------------------*\
*   (R)  _BCT_BCTCLK_VBUSCR:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCLK_VBUSCR_SHIFT		(000000u)
#define _BCT_BCTCLK_VBUSCR_MK(n)		(((Uint16)(n) & 0x000fu) << _BCT_BCTCLK_VBUSCR_SHIFT)
#define _BCT_BCTCLK_VBUSCR_MASK		(_BCT_BCTCLK_VBUSCR_MK(0x000fu))
#define _BCT_BCTCLK_VBUSCR_CLR		(~(_BCT_BCTCLK_VBUSCR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTPRD4 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTPRD4	 - Note: Add description here
*
* Fields:
*	(RW)   _BCT_BCTPRD4_PRD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTPRD4_PRD:	
\*----------------------------------------------------------------*/

#define _BCT_BCTPRD4_PRD_SHIFT		(000000u)
#define _BCT_BCTPRD4_PRD_MK(n)		(((Uint16)(n) & 0xffffu) << _BCT_BCTPRD4_PRD_SHIFT)
#define _BCT_BCTPRD4_PRD_MASK		(_BCT_BCTPRD4_PRD_MK(0xffffu))
#define _BCT_BCTPRD4_PRD_CLR		(~(_BCT_BCTPRD4_PRD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTCNT4 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTCNT4	 - Note: Add description here
*
* Fields:
*	(R)   _BCT_BCTCNT4_CNT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _BCT_BCTCNT4_CNT:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCNT4_CNT_SHIFT		(000000u)
#define _BCT_BCTCNT4_CNT_MK(n)		(((Uint16)(n) & 0xffffu) << _BCT_BCTCNT4_CNT_SHIFT)
#define _BCT_BCTCNT4_CNT_MASK		(_BCT_BCTCNT4_CNT_MK(0xffffu))
#define _BCT_BCTCNT4_CNT_CLR		(~(_BCT_BCTCNT4_CNT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTPID1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTPID1	 - Note: Add description here
*
* Fields:
*	(R)   _BCT_BCTPID1_REVISION	
*	(R)   _BCT_BCTPID1_CLASS	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _BCT_BCTPID1_REVISION:	
\*----------------------------------------------------------------*/

#define _BCT_BCTPID1_REVISION_SHIFT		(000000u)
#define _BCT_BCTPID1_REVISION_MK(n)		(((Uint16)(n) & 0x00ffu) << _BCT_BCTPID1_REVISION_SHIFT)
#define _BCT_BCTPID1_REVISION_MASK		(_BCT_BCTPID1_REVISION_MK(0x00ffu))
#define _BCT_BCTPID1_REVISION_CLR		(~(_BCT_BCTPID1_REVISION_MASK))



/*----------------------------------------------------------------*\
*   (R)  _BCT_BCTPID1_CLASS:	
\*----------------------------------------------------------------*/

#define _BCT_BCTPID1_CLASS_SHIFT		(0x0008u)
#define _BCT_BCTPID1_CLASS_MK(n)		(((Uint16)(n) & 0x00ffu) << _BCT_BCTPID1_CLASS_SHIFT)
#define _BCT_BCTPID1_CLASS_MASK		(_BCT_BCTPID1_CLASS_MK(0x00ffu))
#define _BCT_BCTPID1_CLASS_CLR		(~(_BCT_BCTPID1_CLASS_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTPID2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTPID2	 - Note: Add description here
*
* Fields:
*	(R)   _BCT_BCTPID2_TYPE	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _BCT_BCTPID2_TYPE:	
\*----------------------------------------------------------------*/

#define _BCT_BCTPID2_TYPE_SHIFT		(000000u)
#define _BCT_BCTPID2_TYPE_MK(n)		(((Uint16)(n) & 0x007fu) << _BCT_BCTPID2_TYPE_SHIFT)
#define _BCT_BCTPID2_TYPE_MASK		(_BCT_BCTPID2_TYPE_MK(0x007fu))
#define _BCT_BCTPID2_TYPE_CLR		(~(_BCT_BCTPID2_TYPE_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTCTL2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTCTL2	 - Note: Add description here
*
* Fields:
*	(R)   _BCT_BCTCTL2_TSTAT	
*	(RW)   _BCT_BCTCTL2_INVOUT
*	(RW)   _BCT_BCTCTL2_INVIN	
*	(RW)   _BCT_BCTCTL2_CP	
*	(RW)   _BCT_BCTCTL2_PWID	
*	(RW)   _BCT_BCTCTL2_ENAMODE	
*	(RW)   _BCT_BCTCTL2_CLKSRC	
*	(RW)   _BCT_BCTCTL2_TIEN	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _BCT_BCTCTL2_TSTAT:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL2_TSTAT_SHIFT		(000000u)
#define _BCT_BCTCTL2_TSTAT_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL2_TSTAT_SHIFT)
#define _BCT_BCTCTL2_TSTAT_MASK		(_BCT_BCTCTL2_TSTAT_MK(0x0001u))
#define _BCT_BCTCTL2_TSTAT_CLR		(~(_BCT_BCTCTL2_TSTAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL2_INVOUT:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL2_INVOUT_SHIFT		(0x0001u)
#define _BCT_BCTCTL2_INVOUT_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL2_INVOUT_SHIFT)
#define _BCT_BCTCTL2_INVOUT_MASK		(_BCT_BCTCTL2_INVOUT_MK(0x0001u))
#define _BCT_BCTCTL2_INVOUT_CLR		(~(_BCT_BCTCTL2_INVOUT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL2_INVIN:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL2_INVIN_SHIFT		(0x0002u)
#define _BCT_BCTCTL2_INVIN_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL2_INVIN_SHIFT)
#define _BCT_BCTCTL2_INVIN_MASK		(_BCT_BCTCTL2_INVIN_MK(0x0001u))
#define _BCT_BCTCTL2_INVIN_CLR		(~(_BCT_BCTCTL2_INVIN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL2_CP:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL2_CP_SHIFT		(0x0003u)
#define _BCT_BCTCTL2_CP_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL2_CP_SHIFT)
#define _BCT_BCTCTL2_CP_MASK		(_BCT_BCTCTL2_CP_MK(0x0001u))
#define _BCT_BCTCTL2_CP_CLR		(~(_BCT_BCTCTL2_CP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL2_PWID:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL2_PWID_SHIFT		(0x0004u)
#define _BCT_BCTCTL2_PWID_MK(n)		(((Uint16)(n) & 0x0003u) << _BCT_BCTCTL2_PWID_SHIFT)
#define _BCT_BCTCTL2_PWID_MASK		(_BCT_BCTCTL2_PWID_MK(0x0003u))
#define _BCT_BCTCTL2_PWID_CLR		(~(_BCT_BCTCTL2_PWID_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL2_ENAMODE:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL2_ENAMODE_SHIFT		(0x0006u)
#define _BCT_BCTCTL2_ENAMODE_MK(n)		(((Uint16)(n) & 0x0003u) << _BCT_BCTCTL2_ENAMODE_SHIFT)
#define _BCT_BCTCTL2_ENAMODE_MASK		(_BCT_BCTCTL2_ENAMODE_MK(0x0003u))
#define _BCT_BCTCTL2_ENAMODE_CLR		(~(_BCT_BCTCTL2_ENAMODE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL2_CLKSRC:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL2_CLKSRC_SHIFT		(0x0008u)
#define _BCT_BCTCTL2_CLKSRC_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL2_CLKSRC_SHIFT)
#define _BCT_BCTCTL2_CLKSRC_MASK		(_BCT_BCTCTL2_CLKSRC_MK(0x0001u))
#define _BCT_BCTCTL2_CLKSRC_CLR		(~(_BCT_BCTCTL2_CLKSRC_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTCTL2_TIEN:	
\*----------------------------------------------------------------*/

#define _BCT_BCTCTL2_TIEN_SHIFT		(0x0009u)
#define _BCT_BCTCTL2_TIEN_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTCTL2_TIEN_SHIFT)
#define _BCT_BCTCTL2_TIEN_MASK		(_BCT_BCTCTL2_TIEN_MK(0x0001u))
#define _BCT_BCTCTL2_TIEN_CLR		(~(_BCT_BCTCTL2_TIEN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTGPDAT register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTGPDAT	 - Note: Add description here
*
* Fields:
*	(RW)   _BCT_BCTGPDAT_TIN1DAT	
*	(RW)   _BCT_BCTGPDAT_TOUT1DAT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGPDAT_TIN1DAT:	
\*----------------------------------------------------------------*/

#define _BCT_BCTGPDAT_TIN1DAT_SHIFT		(000000u)
#define _BCT_BCTGPDAT_TIN1DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTGPDAT_TIN1DAT_SHIFT)
#define _BCT_BCTGPDAT_TIN1DAT_MASK		(_BCT_BCTGPDAT_TIN1DAT_MK(0x0001u))
#define _BCT_BCTGPDAT_TIN1DAT_CLR		(~(_BCT_BCTGPDAT_TIN1DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGPDAT_TOUT1DAT:	
\*----------------------------------------------------------------*/

#define _BCT_BCTGPDAT_TOUT1DAT_SHIFT		(000000u)
#define _BCT_BCTGPDAT_TOUT1DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTGPDAT_TOUT1DAT_SHIFT)
#define _BCT_BCTGPDAT_TOUT1DAT_MASK		(_BCT_BCTGPDAT_TOUT1DAT_MK(0x0001u))
#define _BCT_BCTGPDAT_TOUT1DAT_CLR		(~(_BCT_BCTGPDAT_TOUT1DAT_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTGPEN register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTGPEN	 - Note: Add description here
*
* Fields:
*	(RW)   _BCT_BCTGPEN_TIN1EN	
*	(RW)   _BCT_BCTGPEN_TOUT1EN	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGPEN_TIN1EN:	
\*----------------------------------------------------------------*/

#define _BCT_BCTGPEN_TIN1EN_SHIFT		(000000u)
#define _BCT_BCTGPEN_TIN1EN_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTGPEN_TIN1EN_SHIFT)
#define _BCT_BCTGPEN_TIN1EN_MASK		(_BCT_BCTGPEN_TIN1EN_MK(0x0001u))
#define _BCT_BCTGPEN_TIN1EN_CLR		(~(_BCT_BCTGPEN_TIN1EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGPEN_TOUT1EN:	
\*----------------------------------------------------------------*/

#define _BCT_BCTGPEN_TOUT1EN_SHIFT		(0x0001u)
#define _BCT_BCTGPEN_TOUT1EN_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTGPEN_TOUT1EN_SHIFT)
#define _BCT_BCTGPEN_TOUT1EN_MASK		(_BCT_BCTGPEN_TOUT1EN_MK(0x0001u))
#define _BCT_BCTGPEN_TOUT1EN_CLR		(~(_BCT_BCTGPEN_TOUT1EN_MASK))




/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTEMU register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTEMU	 - Note: Add description here
*
* Fields:
*	(R)   _BCT_BCTEMU_FREE	
*	(R)   _BCT_BCTEMU_SOFT
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _BCT_BCTEMU_FREE:	
\*----------------------------------------------------------------*/

#define _BCT_BCTEMU_FREE_SHIFT		(000000u)
#define _BCT_BCTEMU_FREE_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTEMU_FREE_SHIFT)
#define _BCT_BCTEMU_FREE_MASK		(_BCT_BCTEMU_FREE_MK(0x0001u))
#define _BCT_BCTEMU_FREE_CLR		(~(_BCT_BCTEMU_FREE_MASK))


/*----------------------------------------------------------------*\
*   (R)  _BCT_BCTEMU_SOFT:	
\*----------------------------------------------------------------*/

#define _BCT_BCTEMU_SOFT_SHIFT		(000001u)
#define _BCT_BCTEMU_SOFT_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTEMU_SOFT_SHIFT)
#define _BCT_BCTEMU_SOFT_MASK		(_BCT_BCTEMU_SOFT_MK(0x0001u))
#define _BCT_BCTEMU_SOFT_CLR		(~(_BCT_BCTEMU_SOFT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the BCTGPINT register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _BCT_BCTGPINT	 - GPIO interrupt control register
*
* Fields:
*       (RW)   _BCT_BCTGPINT_TIN1INT	  
*       (RW)   _BCT_BCTGPINT_TIN1INV	  

\******************************************************************************/


/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGPINT_TIN1INT:
\*----------------------------------------------------------------*/

#define _BCT_BCTGPINT_TIN1INT_SHIFT		(000000u)
#define _BCT_BCTGPINT_TIN1INT_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTGPINT_TIN1INT_SHIFT)
#define _BCT_BCTGPINT_TIN1INT_MASK		(_BCT_BCTGPINT_TIN1INT_MK(0x0001u))
#define _BCT_BCTGPINT_TIN1INT_CLR		(~(_BCT_BCTGPINT_TIN1INT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _BCT_BCTGPINT_TIN1INV:
\*----------------------------------------------------------------*/

#define _BCT_BCTGPINT_TIN1INV_SHIFT		(000004u)
#define _BCT_BCTGPINT_TIN1INV_MK(n)		(((Uint16)(n) & 0x0001u) << _BCT_BCTGPINT_TIN1INV_SHIFT)
#define _BCT_BCTGPINT_TIN1INV_MASK		(_BCT_BCTGPINT_TIN1INV_MK(0x0001u))
#define _BCT_BCTGPINT_TIN1INV_CLR		(~(_BCT_BCTGPINT_TIN1INV_MASK))






#elif (!(_BCT_MOD))
	#error BCT Hal Module Not Supported on Specified Target
#endif  /* _BCT_SUPPORT  */

#endif  /* _CSL_BCTHAL_H  */

/******************************************************************************\
*     
*      End of csl_bcthal.h 
*
\******************************************************************************/
csl_chip.h/     1061462360  0     0     0       27923     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... CHIP
* FILENAME...... csl_chip.h
* DATE CREATED.. Thu 08/19/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... 
* PREREQUISITS.. csl_stdinc.h, csl_stdinchal.h, csl_chiphal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:        08/19/1999 Created
*   MODIFIED:       11/23/1999 Modified for TMS320C54xx
*                   7/27/2000  Modified for TMS320C55xx
*                   04/12/2001 updated header comments
*   LAST MODIFIED:  08/21/2003 Modified CLKOFF bit ENABLE/DISABLE macros
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the CHIP module)
*
*
*
\******************************************************************************/
#ifndef _CHIP_H_
#define _CHIP_H_
 
#include <csl_std.h>
#include <csl_chiphal.h>
 
#if (_CHIP_SUPPORT)
/****************************************\
* CHIP scope and inline control macros
\****************************************/

#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _DMA_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif
/****************************************\
* CHIP global macro declarations
\****************************************/
#define CHIP_ENDIAN_LITTLE 1

// Make Macros for IER0

#define CHIP_IER0_DMAC5_ENABLE  (0x1u)
#define CHIP_IER0_DMAC5_DISABLE (0x0u)
#define CHIP_IER0_DMAC5_DEFAULT (CHIP_IER0_DMAC5_DISABLE)

#define CHIP_IER0_DMAC4_ENABLE  (0x1u)
#define CHIP_IER0_DMAC4_DISABLE (0x0u)
#define CHIP_IER0_DMAC4_DEFAULT (CHIP_IER0_DMAC4_DISABLE)

#define CHIP_IER0_XINT2_ENABLE  (0x1u)
#define CHIP_IER0_XINT2_DISABLE (0x0u)
#define CHIP_IER0_XINT2_DEFAULT (CHIP_IER0_XINT2_DISABLE)

#define CHIP_IER0_RINT2_ENABLE  (0x1u)
#define CHIP_IER0_RINT2_DISABLE (0x0u)
#define CHIP_IER0_RINT2_DEFAULT (CHIP_IER0_RINT2_DISABLE)

#define CHIP_IER0_INT3_ENABLE  (0x1u)
#define CHIP_IER0_INT3_DISABLE (0x0u)
#define CHIP_IER0_INT3_DEFAULT (CHIP_IER0_INT3_DISABLE)

#define CHIP_IER0_DSPINT_ENABLE  (0x1u)
#define CHIP_IER0_DSPINT_DISABLE (0x0u)
#define CHIP_IER0_DSPINT_DEFAULT (CHIP_IER0_DSPINT_DISABLE)

#define CHIP_IER0_DMAC1_ENABLE  (0x1u)
#define CHIP_IER0_DMAC1_DISABLE (0x0u)
#define CHIP_IER0_DMAC1_DEFAULT (CHIP_IER0_DMAC1_DISABLE)

#define CHIP_IER0_XINT1_ENABLE  (0x1u)
#define CHIP_IER0_XINT1_DISABLE (0x0u)
#define CHIP_IER0_XINT1_DEFAULT (CHIP_IER0_XINT1_DISABLE)

#define CHIP_IER0_RINT1_ENABLE  (0x1u)
#define CHIP_IER0_RINT1_DISABLE (0x0u)
#define CHIP_IER0_RINT1_DEFAULT (CHIP_IER0_RINT1_DISABLE)

#define CHIP_IER0_RINT0_ENABLE  (0x1u)
#define CHIP_IER0_RINT0_DISABLE (0x0u)
#define CHIP_IER0_RINT0_DEFAULT (CHIP_IER0_RINT0_DISABLE)

#define CHIP_IER0_TINT0_ENABLE  (0x1u)
#define CHIP_IER0_TINT0_DISABLE (0x0u)
#define CHIP_IER0_TINT0_DEFAULT (CHIP_IER0_TINT0_DISABLE)

#define CHIP_IER0_INT2_ENABLE  (0x1u)
#define CHIP_IER0_INT2_DISABLE (0x0u)
#define CHIP_IER0_INT2_DEFAULT (CHIP_IER0_INT2_DISABLE)

#define CHIP_IER0_INT0_ENABLE  (0x1u)
#define CHIP_IER0_INT0_DISABLE (0x0u)
#define CHIP_IER0_INT0_DEFAULT (CHIP_IER0_INT0_DISABLE)

#define CHIP_IER0_RMK(dmac5, dmac4, xint2, rint2, int3, dspint, dmac1,\
                       xint1, rint1, rint0, tint0, int2, int0)(\
  (Uint16) ( CHIP_FMK(IER0,DMAC5,dmac5)   |\
             CHIP_FMK(IER0,DMAC4,dmac4)   |\
             CHIP_FMK(IER0,XINT2,xint2)   |\
             CHIP_FMK(IER0,RINT2,rint2)   |\
             CHIP_FMK(IER0,INT3,int3)     |\
             CHIP_FMK(IER0,DSPINT,dspint) |\
             CHIP_FMK(IER0,DMAC1,dmac1)   |\
             CHIP_FMK(IER0,XINT1,xint1)   |\
             CHIP_FMK(IER0,RINT1,rint1)   |\
             CHIP_FMK(IER0,RINT0,rint0)   |\
             CHIP_FMK(IER0,TINT0,tint0)   |\
             CHIP_FMK(IER0,INT2,int2)     |\
             CHIP_FMK(IER0,INT0,int0)     )\
 )


#define CHIP_IER0_RMKS(dmac5_s, dmac4_s, xint2_s, rint2_s, int3_s, dspint_s, dmac1_s,\
                       xint1_s, rint1_s, rint0_s, tint0_s, int2_s, int0_s)(\
  (Uint16) ( CHIP_FMKS(IER0,DMAC5,dmac5_s)   |\
             CHIP_FMKS(IER0,DMAC4,dmac4_s)   |\
             CHIP_FMKS(IER0,XINT2,xint2_s)   |\
             CHIP_FMKS(IER0,RINT2,rint2_s)   |\
             CHIP_FMKS(IER0,INT3,int3_s)     |\
             CHIP_FMKS(IER0,DSPINT,dspint_s) |\
             CHIP_FMKS(IER0,DMAC1,dmac1_s)   |\
             CHIP_FMKS(IER0,XINT1,xint1_s)   |\
             CHIP_FMKS(IER0,RINT1,rint1_s)   |\
             CHIP_FMKS(IER0,RINT0,rint0_s)   |\
             CHIP_FMKS(IER0,TINT0,tint0_s)   |\
             CHIP_FMKS(IER0,INT2,int2_s)     |\
             CHIP_FMKS(IER0,INT0,int0_s)     )\
 )

// Make Macros For IER1

#define CHIP_IER1_INT5_ENABLE   (0x1u)
#define CHIP_IER1_INT5_DISABLE  (0x0u)
#define CHIP_IER1_INT5_DEFAULT  (CHIP_IER1_INT5_DISABLE)

#define CHIP_IER1_TINT1_ENABLE   (0x1u)
#define CHIP_IER1_TINT1_DISABLE  (0x0u)
#define CHIP_IER1_TINT1_DEFAULT  (CHIP_IER1_TINT1_DISABLE)

#define CHIP_IER1_DMAC3_ENABLE   (0x1u)
#define CHIP_IER1_DMAC3_DISABLE  (0x0u)
#define CHIP_IER1_DMAC3_DEFAULT  (CHIP_IER1_DMAC3_DISABLE)

#define CHIP_IER1_DMAC2_ENABLE   (0x1u)
#define CHIP_IER1_DMAC2_DISABLE  (0x0u)
#define CHIP_IER1_DMAC2_DEFAULT  (CHIP_IER1_DMAC2_DISABLE)

#define CHIP_IER1_INT4_ENABLE   (0x1u)
#define CHIP_IER1_INT4_DISABLE  (0x0u)
#define CHIP_IER1_INT4_DEFAULT  (CHIP_IER1_INT4_DISABLE)

#define CHIP_IER1_DMAC0_ENABLE   (0x1u)
#define CHIP_IER1_DMAC0_DISABLE  (0x0u)
#define CHIP_IER1_DMAC0_DEFAULT  (CHIP_IER1_DMAC0_DISABLE)

#define CHIP_IER1_XINT0_ENABLE   (0x1u)
#define CHIP_IER1_XINT0_DISABLE  (0x0u)
#define CHIP_IER1_XINT0_DEFAULT  (CHIP_IER1_XINT0_DISABLE)

#define CHIP_IER1_INT1_ENABLE   (0x1u)
#define CHIP_IER1_INT1_DISABLE  (0x0u)
#define CHIP_IER1_INT1_DEFAULT  (CHIP_IER1_INT1_DISABLE)


#define CHIP_IER1_RMK(int5, tint1, dmac3, dmac2, int4, dmac0, xint0, int1)(\
  (Uint16)( CHIP_FMK(IER1,INT5,int5)   |\
            CHIP_FMK(IER1,TINT1,tint1) |\
            CHIP_FMK(IER1,DMAC3,dmac3) |\
            CHIP_FMK(IER1,DMAC2,dmac2) |\
            CHIP_FMK(IER1,INT4,int4)   |\
            CHIP_FMK(IER1,DMAC0,dmac0) |\
            CHIP_FMK(IER1,XINT0,xint0) |\
            CHIP_FMK(IER1,INT1,int1)   )\
)

#define CHIP_IER1_RMKS(int5_s, tint1_s, dmac3_s, dmac2_s, int4_s, dmac0_s, xint0_s, int1_s)(\
  (Uint16)( CHIP_FMKS(IER1,INT5,int5_s)   |\
            CHIP_FMKS(IER1,TINT1,tint1_s) |\
            CHIP_FMKS(IER1,DMAC3,dmac3_s) |\
            CHIP_FMKS(IER1,DMAC2,dmac2_s) |\
            CHIP_FMKS(IER1,INT4,int4_s)   |\
            CHIP_FMKS(IER1,DMAC0,dmac0_s) |\
            CHIP_FMKS(IER1,XINT0,xint0_s) |\
            CHIP_FMKS(IER1,INT1,int1_s)   )\
)
// Make Macros for IFR0

#define CHIP_IFR0_DMAC5_ENABLE  (0x1u)
#define CHIP_IFR0_DMAC5_DISABLE (0x0u)
#define CHIP_IFR0_DMAC5_DEFAULT (CHIP_IFR0_DMAC5_DISABLE)

#define CHIP_IFR0_DMAC4_ENABLE  (0x1u)
#define CHIP_IFR0_DMAC4_DISABLE (0x0u)
#define CHIP_IFR0_DMAC4_DEFAULT (CHIP_IFR0_DMAC4_DISABLE)

#define CHIP_IFR0_XINT2_ENABLE  (0x1u)
#define CHIP_IFR0_XINT2_DISABLE (0x0u)
#define CHIP_IFR0_XINT2_DEFAULT (CHIP_IFR0_XINT2_DISABLE)

#define CHIP_IFR0_RINT2_ENABLE  (0x1u)
#define CHIP_IFR0_RINT2_DISABLE (0x0u)
#define CHIP_IFR0_RINT2_DEFAULT (CHIP_IFR0_RINT2_DISABLE)

#define CHIP_IFR0_INT3_ENABLE  (0x1u)
#define CHIP_IFR0_INT3_DISABLE (0x0u)
#define CHIP_IFR0_INT3_DEFAULT (CHIP_IFR0_INT3_DISABLE)

#define CHIP_IFR0_DSPINT_ENABLE  (0x1u)
#define CHIP_IFR0_DSPINT_DISABLE (0x0u)
#define CHIP_IFR0_DSPINT_DEFAULT (CHIP_IFR0_DSPINT_DISABLE)

#define CHIP_IFR0_DMAC1_ENABLE  (0x1u)
#define CHIP_IFR0_DMAC1_DISABLE (0x0u)
#define CHIP_IFR0_DMAC1_DEFAULT (CHIP_IFR0_DMAC1_DISABLE)

#define CHIP_IFR0_XINT1_ENABLE  (0x1u)
#define CHIP_IFR0_XINT1_DISABLE (0x0u)
#define CHIP_IFR0_XINT1_DEFAULT (CHIP_IFR0_XINT1_DISABLE)

#define CHIP_IFR0_RINT1_ENABLE  (0x1u)
#define CHIP_IFR0_RINT1_DISABLE (0x0u)
#define CHIP_IFR0_RINT1_DEFAULT (CHIP_IFR0_RINT1_DISABLE)

#define CHIP_IFR0_RINT0_ENABLE  (0x1u)
#define CHIP_IFR0_RINT0_DISABLE (0x0u)
#define CHIP_IFR0_RINT0_DEFAULT (CHIP_IFR0_RINT0_DISABLE)

#define CHIP_IFR0_TINT0_ENABLE  (0x1u)
#define CHIP_IFR0_TINT0_DISABLE (0x0u)
#define CHIP_IFR0_TINT0_DEFAULT (CHIP_IFR0_TINT0_DISABLE)

#define CHIP_IFR0_INT2_ENABLE  (0x1u)
#define CHIP_IFR0_INT2_DISABLE (0x0u)
#define CHIP_IFR0_INT2_DEFAULT (CHIP_IFR0_INT2_DISABLE)

#define CHIP_IFR0_INT0_ENABLE  (0x1u)
#define CHIP_IFR0_INT0_DISABLE (0x0u)
#define CHIP_IFR0_INT0_DEFAULT (CHIP_IFR0_INT0_DISABLE)

#define CHIP_IFR0_RMK(dmac5, dmac4, xint2, rint2, int3, dspint, dmac1,\
                       xint1, rint1, rint0, tint0, int2, int0)(\
  (Uint16) ( CHIP_FMK(IFR0,DMAC5,dmac5)   |\
             CHIP_FMK(IFR0,DMAC4,dmac4)   |\
             CHIP_FMK(IFR0,XINT2,xint2)   |\
             CHIP_FMK(IFR0,RINT2,rint2)   |\
             CHIP_FMK(IFR0,INT3,int3)     |\
             CHIP_FMK(IFR0,DSPINT,dspint) |\
             CHIP_FMK(IFR0,DMAC1,dmac1)   |\
             CHIP_FMK(IFR0,XINT1,xint1)   |\
             CHIP_FMK(IFR0,RINT1,rint1)   |\
             CHIP_FMK(IFR0,RINT0,rint0)   |\
             CHIP_FMK(IFR0,TINT0,tint0)   |\
             CHIP_FMK(IFR0,INT2,int2)     |\
             CHIP_FMK(IFR0,INT0,int0)     )\
 )


#define CHIP_IFR0_RMKS(dmac5_s, dmac4_s, xint2_s, rint2_s, int3_s, dspint_s, dmac1_s,\
                       xint1_s, rint1_s, rint0_s, tint0_s, int2_s, int0_s)(\
  (Uint16) ( CHIP_FMKS(IFR0,DMAC5,dmac5_s)   |\
             CHIP_FMKS(IFR0,DMAC4,dmac4_s)   |\
             CHIP_FMKS(IFR0,XINT2,xint2_s)   |\
             CHIP_FMKS(IFR0,RINT2,rint2_s)   |\
             CHIP_FMKS(IFR0,INT3,int3_s)     |\
             CHIP_FMKS(IFR0,DSPINT,dspint_s) |\
             CHIP_FMKS(IFR0,DMAC1,dmac1_s)   |\
             CHIP_FMKS(IFR0,XINT1,xint1_s)   |\
             CHIP_FMKS(IFR0,RINT1,rint1_s)   |\
             CHIP_FMKS(IFR0,RINT0,rint0_s)   |\
             CHIP_FMKS(IFR0,TINT0,tint0_s)   |\
             CHIP_FMKS(IFR0,INT2,int2_s)     |\
             CHIP_FMKS(IFR0,INT0,int0_s)     )\
 )

// Make Macros For IFR1

#define CHIP_IFR1_INT5_ENABLE   (0x1u)
#define CHIP_IFR1_INT5_DISABLE  (0x0u)
#define CHIP_IFR1_INT5_DEFAULT  (CHIP_IFR1_INT5_DISABLE)

#define CHIP_IFR1_TINT1_ENABLE   (0x1u)
#define CHIP_IFR1_TINT1_DISABLE  (0x0u)
#define CHIP_IFR1_TINT1_DEFAULT  (CHIP_IFR1_TINT1_DISABLE)

#define CHIP_IFR1_DMAC3_ENABLE   (0x1u)
#define CHIP_IFR1_DMAC3_DISABLE  (0x0u)
#define CHIP_IFR1_DMAC3_DEFAULT  (CHIP_IFR1_DMAC3_DISABLE)

#define CHIP_IFR1_DMAC2_ENABLE   (0x1u)
#define CHIP_IFR1_DMAC2_DISABLE  (0x0u)
#define CHIP_IFR1_DMAC2_DEFAULT  (CHIP_IFR1_DMAC2_DISABLE)

#define CHIP_IFR1_INT4_ENABLE   (0x1u)
#define CHIP_IFR1_INT4_DISABLE  (0x0u)
#define CHIP_IFR1_INT4_DEFAULT  (CHIP_IFR1_INT4_DISABLE)

#define CHIP_IFR1_DMAC0_ENABLE   (0x1u)
#define CHIP_IFR1_DMAC0_DISABLE  (0x0u)
#define CHIP_IFR1_DMAC0_DEFAULT  (CHIP_IFR1_DMAC0_DISABLE)

#define CHIP_IFR1_XINT0_ENABLE   (0x1u)
#define CHIP_IFR1_XINT0_DISABLE  (0x0u)
#define CHIP_IFR1_XINT0_DEFAULT  (CHIP_IFR1_XINT0_DISABLE)

#define CHIP_IFR1_INT1_ENABLE   (0x1u)
#define CHIP_IFR1_INT1_DISABLE  (0x0u)
#define CHIP_IFR1_INT1_DEFAULT  (CHIP_IFR1_INT1_DISABLE)


#define CHIP_IFR1_RMK(int5, tint1, dmac3, dmac2, int4, dmac0, xint0, int1)\
  (Uint16)( CHIP_FMK(IFR1,INT5,int5)   |\
            CHIP_FMK(IFR1,TINT1,tint1) |\
            CHIP_FMK(IFR1,DMAC3,dmac3) |\
            CHIP_FMK(IFR1,DMAC2,dmac2) |\
            CHIP_FMK(IFR1,INT4,int4)   |\
            CHIP_FMK(IFR1,DMAC0,dmac0) |\
            CHIP_FMK(IFR1,XINT0,xint0) |\
            CHIP_FMK(IFR1,INT1,int1)   \
)

#define CHIP_IFR1_RMKS(int5_s, tint1_s, dmac3_s, dmac2_s, int4_s, dmac0_s, xint0_s, int1_s)\
  (Uint16)( CHIP_FMKS(IFR1,INT5,int5_s)   |\
            CHIP_FMKS(IFR1,TINT1,tint1_s) |\
            CHIP_FMKS(IFR1,DMAC3,dmac3_s) |\
            CHIP_FMKS(IFR1,DMAC2,dmac2_s) |\
            CHIP_FMKS(IFR1,INT4,int4_s)   |\
            CHIP_FMKS(IFR1,DMAC0,dmac0_s) |\
            CHIP_FMKS(IFR1,XINT0,xint0_s) |\
            CHIP_FMKS(IFR1,INT1,int1_s)   \
)

// Make Macros for ST0

#define CHIP_ST0_55_ACOV2_ON      (0x1u)
#define CHIP_ST0_55_ACOV2_OFF     (0x0u)
#define CHIP_ST0_55_ACOV2_DEFAULT  CHIP_ST0_55_ACOV2_OFF

#define CHIP_ST0_55_ACOV3_ON      (0x1u)
#define CHIP_ST0_55_ACOV3_OFF     (0x0u)
#define CHIP_ST0_55_ACOV3_DEFAULT  CHIP_ST0_55_ACOV3_OFF

#define CHIP_ST0_55_TC1_ON      (0x1u)
#define CHIP_ST0_55_TC1_OFF     (0x0u)
#define CHIP_ST0_55_TC1_DEFAULT  CHIP_ST0_55_TC1_OFF

#define CHIP_ST0_55_TC2_ON      (0x1u)
#define CHIP_ST0_55_TC2_OFF     (0x0u)
#define CHIP_ST0_55_TC2_DEFAULT  CHIP_ST0_55_TC2_OFF

#define CHIP_ST0_55_CARRY_ON      (0x1u)
#define CHIP_ST0_55_CARRY_OFF     (0x0u)
#define CHIP_ST0_55_CARRY_DEFAULT  CHIP_ST0_55_CARRY_OFF

#define CHIP_ST0_55_ACOV0_ON      (0x1u)
#define CHIP_ST0_55_ACOV0_OFF     (0x0u)
#define CHIP_ST0_55_ACOV0_DEFAULT  CHIP_ST0_55_ACOV0_OFF

#define CHIP_ST0_55_ACOV1_ON      (0x1u)
#define CHIP_ST0_55_ACOV1_OFF     (0x0u)
#define CHIP_ST0_55_ACOV1_DEFAULT  CHIP_ST0_55_ACOV1_OFF

#define CHIP_ST0_55_DP_OF(x)      ((Uint16)(x))
#define CHIP_ST0_55_DP_DEFAULT    (0x0u)


#define CHIP_ST0_55_RMK(acov2, acov3, tc1, tc2, carry, acov0, acov1, dp)(\
(Uint16) ( CHIP_FMK(ST0_55,ACOV2,acov2)   |\
           CHIP_FMK(ST0_55,ACOV3,acov3)   |\
           CHIP_FMK(ST0_55,TC1,tc1)       |\
           CHIP_FMK(ST0_55,TC2,tc2)       |\
           CHIP_FMK(ST0_55,CARRY,carry)   |\
           CHIP_FMK(ST0_55,ACOV0,acov0)   |\
           CHIP_FMK(ST0_55,ACOV1,acov1)   |\
           CHIP_FMK(ST0_55,DP,dp)         )\
)

#define CHIP_ST0_55_RMKS(acov2_s, acov3_s, tc1_s, tc2_s, carry_s, acov0_s, acov1_s, dp_s)(\
(Uint16) ( CHIP_FMK(ST0_55,ACOV2,acov2_s)   |\
           CHIP_FMK(ST0_55,ACOV3,acov3_s)   |\
           CHIP_FMK(ST0_55,TC1,tc1_s)       |\
           CHIP_FMK(ST0_55,TC2,tc2_s)       |\
           CHIP_FMK(ST0_55,CARRY,carry_s)   |\
           CHIP_FMK(ST0_55,ACOV0,acov0_s)   |\
           CHIP_FMK(ST0_55,ACOV1,acov1_s)   |\
           CHIP_FMK(ST0_55,DP,dp_s) )       \
)


// Make Macros for ST1

#define CHIP_ST1_55_BRAF_ON       (0x1u)
#define CHIP_ST1_55_BRAF_OFF      (0x0u)
#define CHIP_ST1_55_BRAF_DEFAULT  CHIP_ST1_55_BRAF_OFF

#define CHIP_ST1_55_CPL_ON        (0x1u)
#define CHIP_ST1_55_CPL_OFF       (0x0u)
#define CHIP_ST1_55_CPL_DEFAULT   CHIP_ST1_55_CPL_OFF

#define CHIP_ST1_55_XF_ON         (0x1u)
#define CHIP_ST1_55_XF_OFF        (0x0u)
#define CHIP_ST1_55_XF_DEFAULT    CHIP_ST1_55_XF_OFF

#define CHIP_ST1_55_HM_ON         (0x1u)
#define CHIP_ST1_55_HM_OFF        (0x0u)
#define CHIP_ST1_55_HM_DEFAULT    CHIP_ST1_55_HM_OFF


#define CHIP_ST1_55_INTM_ON       (0x1u)
#define CHIP_ST1_55_INTM_OFF      (0x0u)
#define CHIP_ST1_55_INTM_DEFAULT  CHIP_ST1_55_INTM_OFF

#define CHIP_ST1_55_M40_ON        (0x1u)
#define CHIP_ST1_55_M40_OFF       (0x0u)
#define CHIP_ST1_55_M40_DEFAULT   CHIP_ST1_55_M40_OFF

#define CHIP_ST1_55_SATD_ON       (0x1u)
#define CHIP_ST1_55_SATD_OFF      (0x0u)
#define CHIP_ST1_55_SATD_DEFAULT  CHIP_ST1_55_SATD_OFF

#define CHIP_ST1_55_SXMD_ON       (0x1u)
#define CHIP_ST1_55_SXMD_OFF      (0x0u)
#define CHIP_ST1_55_SXMD_DEFAULT  CHIP_ST1_55_SXMD_OFF

#define CHIP_ST1_55_C16_ON        (0x1u)
#define CHIP_ST1_55_C16_OFF       (0x0u)
#define CHIP_ST1_55_C16_DEFAULT   CHIP_ST1_55_C16_OFF

#define CHIP_ST1_55_FRCT_ON        (0x1u)
#define CHIP_ST1_55_FRCT_OFF       (0x0u)
#define CHIP_ST1_55_FRCT_DEFAULT   CHIP_ST1_55_FRCT_OFF

#define CHIP_ST1_55_C54CM_ON        (0x1u)
#define CHIP_ST1_55_C54CM_OFF       (0x0u)
#define CHIP_ST1_55_C54CM_DEFAULT   CHIP_ST1_55_C54CM_OFF

#define CHIP_ST1_55_ASM_OF(x)       ((Uint16)(x))
#define CHIP_ST1_55_ASM_DEFAULT     (0x0u)


#define CHIP_ST1_55_RMK(braf, cpl, xf, hm, intm, m40, satd, sxmd, c16, frct,\
                         c54cm, asm)(\
(Uint16) (CHIP_FMK(ST1_55,BRAF,braf)   |\
          CHIP_FMK(ST1_55,CPL,cpl)     |\
          CHIP_FMK(ST1_55,XF,xf)       |\
          CHIP_FMK(ST1_55,HM,hm)       |\
          CHIP_FMK(ST1_55,INTM,intm)   |\
          CHIP_FMK(ST1_55,M40,m40)     |\
          CHIP_FMK(ST1_55,SATD,satd)   |\
          CHIP_FMK(ST1_55,SXMD,sxmd)   |\
          CHIP_FMK(ST1_55,C16,c16)     |\
          CHIP_FMK(ST1_55,FRCT,frct)   |\
          CHIP_FMK(ST1_55,C54CM,c54cm) |\
          CHIP_FMK(ST1_55,ASM,asm) )    \
)

#define CHIP_ST1_55_RMKS(braf_s, cpl_s, xf_s, hm_s, intm_s, m40_s, satd_s, sxmd_s, c16_s, frct_s,\
                         c54cm_s, asm_s)(\
(Uint16) (CHIP_FMK(ST1_55,BRAF,braf_s)   |\
          CHIP_FMK(ST1_55,CPL,cpl_s)     |\
          CHIP_FMK(ST1_55,XF,xf_s)       |\
          CHIP_FMK(ST1_55,HM,hm_s)       |\
          CHIP_FMK(ST1_55,INTM,intm_s)   |\
          CHIP_FMK(ST1_55,M40,m40_s)     |\
          CHIP_FMK(ST1_55,SATD,satd_s)   |\
          CHIP_FMK(ST1_55,SXMD,sxmd_s)   |\
          CHIP_FMK(ST1_55,C16,c16_s)     |\
          CHIP_FMK(ST1_55,FRCT,frct_s)   |\
          CHIP_FMK(ST1_55,C54CM,c54cm_s) |\
          CHIP_FMK(ST1_55,ASM,asm_s) )   \
)

// Make Macros for ST2

#define CHIP_ST2_55_ARMS_ON         (0x1u)
#define CHIP_ST2_55_ARMS_OFF        (0x0u)
#define CHIP_ST2_55_ARMS_DEFAULT    CHIP_ST2_55_ARMS_OFF

#define CHIP_ST2_55_DBGM_ON         (0x1u)
#define CHIP_ST2_55_DBGM_OFF        (0x0u)
#define CHIP_ST2_55_DBGM_DEFAULT    CHIP_ST2_55_DBGM_OFF

#define CHIP_ST2_55_EALLOW_ON       (0x1u)
#define CHIP_ST2_55_EALLOW_OFF      (0x0u)
#define CHIP_ST2_55_EALLOW_DEFAULT  CHIP_ST2_55_EALLOW_OFF

#define CHIP_ST2_55_RDM_ON          (0x1u)
#define CHIP_ST2_55_RDM_OFF         (0x0u)
#define CHIP_ST2_55_RDM_DEFAULT     CHIP_ST2_55_RDM_OFF

#define CHIP_ST2_55_CDPLC_ON        (0x1u)
#define CHIP_ST2_55_CDPLC_OFF       (0x0u)
#define CHIP_ST2_55_CDPLC_DEFAULT   CHIP_ST2_55_CDPLC_OFF

#define CHIP_ST2_55_AR7LC_ON        (0x1u)
#define CHIP_ST2_55_AR7LC_OFF       (0x0u)
#define CHIP_ST2_55_AR7LC_DEFAULT   CHIP_ST2_55_AR7LC_OFF

#define CHIP_ST2_55_AR6LC_ON        (0x1u)
#define CHIP_ST2_55_AR6LC_OFF       (0x0u)
#define CHIP_ST2_55_AR6LC_DEFAULT   CHIP_ST2_55_AR6LC_OFF

#define CHIP_ST2_55_AR5LC_ON        (0x1u)
#define CHIP_ST2_55_AR5LC_OFF       (0x0u)
#define CHIP_ST2_55_AR5LC_DEFAULT   CHIP_ST2_55_AR5LC_OFF

#define CHIP_ST2_55_AR4LC_ON        (0x1u)
#define CHIP_ST2_55_AR4LC_OFF       (0x0u)
#define CHIP_ST2_55_AR4LC_DEFAULT   CHIP_ST2_55_AR4LC_OFF

#define CHIP_ST2_55_AR3LC_ON        (0x1u)
#define CHIP_ST2_55_AR3LC_OFF       (0x0u)
#define CHIP_ST2_55_AR3LC_DEFAULT   CHIP_ST2_55_AR3LC_OFF

#define CHIP_ST2_55_AR2LC_ON        (0x1u)
#define CHIP_ST2_55_AR2LC_OFF       (0x0u)
#define CHIP_ST2_55_AR2LC_DEFAULT   CHIP_ST2_55_AR2LC_OFF

#define CHIP_ST2_55_AR1LC_ON        (0x1u)
#define CHIP_ST2_55_AR1LC_OFF       (0x0u)
#define CHIP_ST2_55_AR1LC_DEFAULT   CHIP_ST2_55_AR1LC_OFF

#define CHIP_ST2_55_AR0LC_ON        (0x1u)
#define CHIP_ST2_55_AR0LC_OFF       (0x0u)
#define CHIP_ST2_55_AR0LC_DEFAULT   CHIP_ST2_55_AR0LC_OFF

#define CHIP_ST2_55_RMK(arms, dbgm, eallow, rdm, cdplc, ar7lc, ar6lc, ar5lc,\
                         ar4lc, ar3lc,ar2lc,ar1lc,ar0lc)(\
(Uint16) ( CHIP_FMK(ST2_55,ARMS,arms)     |\
           CHIP_FMK(ST2_55,DBGM,dbgm)     |\
           CHIP_FMK(ST2_55,EALLOW,eallow) |\
           CHIP_FMK(ST2_55,RDM,rdm)       |\
           CHIP_FMK(ST2_55,CDPLC,cdplc)   |\
           CHIP_FMK(ST2_55,AR7LC,ar7lc)   |\
           CHIP_FMK(ST2_55,AR6LC,ar6lc)   |\
           CHIP_FMK(ST2_55,AR5LC,ar5lc)   |\
           CHIP_FMK(ST2_55,AR4LC,ar4lc)   |\
           CHIP_FMK(ST2_55,AR3LC,ar3lc)   |\
           CHIP_FMK(ST2_55,AR2LC,ar2lc)   |\
           CHIP_FMK(ST2_55,AR1LC,ar1lc)   |\
           CHIP_FMK(ST2_55,AR0LC,ar0lc)   )\
)

#define CHIP_ST2_55_RMKS(arms_s, dbgm_s, eallow_s, rdm_s, cdplc_s,\
                          ar7lc_s, ar6lc_s, ar5lc_s, ar4lc_s, ar3lc_s,\
                          ar2lc_s,ar1lc_s,ar0lc_s)(\
(Uint16) ( CHIP_FMKS(ST2_55,ARMS,arms_s)     |\
           CHIP_FMKS(ST2_55,DBGM,dbgm_s)     |\
           CHIP_FMKS(ST2_55,EALLOW,eallow_s) |\
           CHIP_FMKS(ST2_55,RDM,rdm_s)       |\
           CHIP_FMKS(ST2_55,CDPLC,cdplc_s)   |\
           CHIP_FMKS(ST2_55,AR7LC,ar7lc_s)   |\
           CHIP_FMKS(ST2_55,AR6LC,ar6lc_s)   |\
           CHIP_FMKS(ST2_55,AR5LC,ar5lc_s)   |\
           CHIP_FMKS(ST2_55,AR4LC,ar4lc_s)   |\
           CHIP_FMKS(ST2_55,AR3LC,ar3lc_s)   |\
           CHIP_FMKS(ST2_55,AR2LC,ar2lc_s)   |\
           CHIP_FMKS(ST2_55,AR1LC,ar1lc_s)   |\
           CHIP_FMKS(ST2_55,AR0LC,ar0lc_s)   )\
)

// Make Macros for ST3

#define CHIP_ST3_55_CAFRZ_ENABLE    (0x1u)
#define CHIP_ST3_55_CAFRZ_DISABLE   (0x0u)
#define CHIP_ST3_55_CAFRZ_DEFAULT   CHIP_ST3_55_CAFRZ_DISABLE

#define CHIP_ST3_55_CAEN_ON         (0x1u)
#define CHIP_ST3_55_CAEN_OFF        (0x0u)
#define CHIP_ST3_55_CAEN_DEFAULT    CHIP_ST3_55_CAEN_OFF

#define CHIP_ST3_55_CACLR_ENABLE    (0x1u)
#define CHIP_ST3_55_CACLR_DISABLE   (0x0u)
#define CHIP_ST3_55_CACLR_DEFAULT   CHIP_ST3_55_CACLR_DISABLE

#define CHIP_ST3_55_HINT_ENABLE     (0x1u)
#define CHIP_ST3_55_HINT_DISABLE    (0x0u)
#define CHIP_ST3_55_HINT_DEFAULT    CHIP_ST3_55_HINT_DISABLE

#define CHIP_ST3_55_CBERR_ON        (0x1u)
#define CHIP_ST3_55_CBERR_OFF       (0x0u)
#define CHIP_ST3_55_CBERR_DEFAULT   CHIP_ST3_55_CBERR_OFF

#define CHIP_ST3_55_MPNMC_ON        (0x1u)
#define CHIP_ST3_55_MPNMC_OFF       (0x0u)
#define CHIP_ST3_55_MPNMC_DEFAULT   CHIP_ST3_55_MPNMC_OFF

#define CHIP_ST3_55_SATA_ON         (0x1u)
#define CHIP_ST3_55_SATA_OFF        (0x0u)
#define CHIP_ST3_55_SATA_DEFAULT    CHIP_ST3_55_SATA_OFF

#define CHIP_ST3_55_AVIS_ON         (0x1u)
#define CHIP_ST3_55_AVIS_OFF        (0x0u)
#define CHIP_ST3_55_AVIS_DEFAULT    CHIP_ST3_55_AVIS_OFF

#define CHIP_ST3_55_CLKOFF_ENABLE   (0x0u)
#define CHIP_ST3_55_CLKOFF_DISABLE  (0x1u)
#define CHIP_ST3_55_CLKOFF_DEFAULT  CHIP_ST3_55_CLKOFF_ENABLE

#define CHIP_ST3_55_SMUL_ON         (0x1u)
#define CHIP_ST3_55_SMUL_OFF        (0x0u)
#define CHIP_ST3_55_SMUL_DEFAULT    CHIP_ST3_55_SMUL_OFF

#define CHIP_ST3_55_SST_ON         (0x1u)
#define CHIP_ST3_55_SST_OFF        (0x0u)
#define CHIP_ST3_55_SST_DEFAULT    CHIP_ST3_55_SST_OFF

#define CHIP_ST3_55_RMK(cafrz, caen, caclr, hint, cberr, mpnmc, sata, avis,\
                        clkoff, smul, sst)\
(Uint16) ( CHIP_FMK(ST3_55,CAFRZ,cafrz)   |\
           CHIP_FMK(ST3_55,CAEN,caen)     |\
           CHIP_FMK(ST3_55,CACLR,caclr)   |\
           CHIP_FMK(ST3_55,HINT,hint)     |\
           CHIP_FMK(ST3_55,CBERR,cberr)   |\
           CHIP_FMK(ST3_55,MPNMC,mpnmc)   |\
           CHIP_FMK(ST3_55,SATA,sata)     |\
           CHIP_FMK(ST3_55,AVIS,avis)     |\
           CHIP_FMK(ST3_55,CLKOFF,clkoff) |\
           CHIP_FMK(ST3_55,SMUL,smul)     |\
           CHIP_FMK(ST3_55,SST,sst)        \
)

#define CHIP_ST3_55_RMKS(cafrz, caen, caclr, hint, cberr, mpnmc, sata, avis,\
                         clkoff, smul, sst)\
(Uint16) ( CHIP_FMKS(ST3_55,CAFRZ,cafrz)   |\
           CHIP_FMKS(ST3_55,CAEN,caen)     |\
           CHIP_FMKS(ST3_55,CACLR,calcr)   |\
           CHIP_FMKS(ST3_55,HINT,hint)     |\
           CHIP_FMKS(ST3_55,CBERR,cberr)   |\
           CHIP_FMKS(ST3_55,MPNMC,mpnmc)   |\
           CHIP_FMKS(ST3_55,SATA,sata)     |\
           CHIP_FMKS(ST3_55,AVIS,avis)     |\
           CHIP_FMKS(ST3_55,CLKOFF,clkoff) |\
           CHIP_FMKS(ST3_55,SMUL,smul)     |\
           CHIP_FMKS(ST3_55,SST,sst)        \
)

// Make Macros for IVPD

#define CHIP_IVPD_IVPD_OF(x)            ((Uint16)(x))

#define CHIP_IVPD_RMK(ivpd)             (Uint16) (CHIP_FMK(IVPD,IVPD,ivpd))  
#define CHIP_IVPD_RMKS(ivpd)            (Uint16) (CHIP_FMKS(IVPD,IVPD,ivpd)) 

// Make Macros for IVPH

#define CHIP_IVPH_IVPH_OF(x)            ((Uint16)(x))

#define CHIP_IVPH_RMK(ivph)             (Uint16) (CHIP_FMK(IVPH,IVPH,ivph))  
#define CHIP_IVPH_RMKS(ivph)            (Uint16) (CHIP_FMKS(IVPH,IVPH,ivph)) 

// Make macros for PDP

#define CHIP_PDP_PDP_OF(x)              ((Uint16)(x))

#define CHIP_PDP_RMK(pdp)               (Uint16) (CHIP_FMK(PDP,PDP,pdp))  
#define CHIP_PDP_RMKS(pdp)              (Uint16) (CHIP_FMKS(PDP,PDP,pdp)) 


#define CHIP_DIEIDL_ADDR                (0x3800u)
#define CHIP_DIEIDH_ADDR                (0x3802u)
#define CHIP_REVID_ADDR                 (0x3804u)

#define CHIP_REVID_5509PG1_0            (0x8050u)
#define CHIP_REVID_5509                 (0x2502u)


#define   CHIP_getDieId_Low32()         ((Uint32) _PREG32_GET(CHIP_DIEIDL_ADDR))

#define   CHIP_getDieId_High32()        ((Uint32) _PREG32_GET(CHIP_DIEIDH_ADDR))

#define  CHIP_getRevId()                ((Uint16) _PREG_GET(CHIP_REVID_ADDR))


#define  CHIP_getEndian {\
        CHIP_ENDIAN_LITTLE\
}

/****************************************\
* CHIP global macro declarations
\****************************************/   

#if (CHIP_5509)
#define CHIP_XBSR_SP2_MCBSP (0x0000u)
#define CHIP_XBSR_SP2_MST   (0x0003u)
#define CHIP_XBSR_SP2_MMC   (0x0002u)

#define CHIP_XBSR_SP1_MCBSP (0x0000u)
#define CHIP_XBSR_SP1_MST   (0x0003u)
#define CHIP_XBSR_SP1_MMC   (0x0002u)

#define CHIP_XBSR_PP_EMIF   (0x0001u)
#define CHIP_XBSR_PP_GPIO   (0x0002u)
#define CHIP_XBSR_PP_EHPI   (0x0002u)


#define CHIP_XBSR_RMK(clkout,oscdis,emifx2,sp2,sp1,pp)\
 (Uint16) (  _CHIP_XBSR_CLKOUT_MK(clkout)  |\
             _CHIP_XBSR_OSCDIS_MK(oscdis)  |\
             _CHIP_XBSR_EMIFX2_MK(emifx2)  |\
             _CHIP_XBSR_SP2_MK(sp2)        |\
             _CHIP_XBSR_SP1_MK(sp1)        \
 )

#define CHIP_XBSR_RMKS(clkout,oscdis,emifx2,sp2,sp1,pp)\
 (Uint16) (  _CHIP_FMKS(XBSR,CLKOUT,clkout)  |\
             _CHIP_FMKS(XBSR,OSCDIS,oscdis)  |\
             _CHIP_FMKS(XBSR,EMIFX2,emifx2)  |\
             _CHIP_FMKS(XBSR,SP2,sp2)        |\
             _CHIP_FMKS(XBSR,SP1,sp1)        \
 )

#define CHIP_XBSR_DEFAULT       (0x0003u)

#endif
  
/*******************************************\
* CHIP global macro definition : ROMABILITY
\*******************************************/ 
/* Reserved ROM Area for Chip Data */
            
/* None Data used by CHIP functions */

/****************************************\
* CHIP global typedef declarations
\****************************************/

/****************************************\
* CHIP global variable declarations
\****************************************/

/****************************************\
* CHIP global function declarations
\****************************************/

/****************************************\
* CHIP inline function declarations
\****************************************/

/****************************************\
* CHIP inline function definitions
\****************************************/

#endif /* _CHIP_SUPPORT */
#endif /* _CHIP_H_ */
/******************************************************************************\
* End of CHIP.h
\******************************************************************************/


csl_chipdat.h/  1049976827  0     0     0       1071      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... CHIP
* FILENAME...... csl_chipdata.h
* CHIP CREATED.. Thu 03/30/2000 
* PROJECT....... Chip Support Library (CSL)
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   MODIFIED: 06/19/2000
*   LAST MODIFIED: 05/31/2001 Updated for new initialization model
*------------------------------------------------------------------------------
* DESCRIPTION:  (CHIP Module Initialization Data)
*
*
\******************************************************************************/
#ifndef _CSL_CHIP_DATA_H_
#define _CSL_CHIP_DATA_H_

  #define CSL_CHIPDATAINIT\
  { 0x0000  /* Reserved */\
  }

  typedef struct {
    Uint16 ChipReserved;
  } CSL_ChipDataObj;

#endif

csl_chiphal.h/  1065617099  0     0     0       107360    `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... CHIP
* FILENAME...... csl_chiphal.h
* DATE CREATED.. Thu 08/19/1999
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:   08/19/1999 Created
*   MODIFIED:  05/11/2000 modified for TMS320C55xx
*   MODIFIED:  04/16 2001 modified for 5510PG2
*   MODIFIED:  07/02/2001 modifid for 5509PG1 & PG2
*   MODIFIED:  04/04/2002 added ICACHE support
*   MODIFIED:  07/26/2002 added 5510PG2_1, 5510PG2_2 support
*   MODIFIED:  09/17/2002 fixed problem with #ifdef CHIP_TYPE inconsistencies
*   MODIFIED:  10/23/2002 Added 5509PG1_0, 5509PG2_0 CHIPTYPES for c035 support
*   MODIFIED:  11/22/2002 Removed 5509PG1_0 support, changed 5509PG2_0 support
*                         to 5509A; added entries to XBSR register for new
*                         EMIF refresh enable fields.
*   MODIFIED:  11/26/2002 Added _EMIF_SELFREFRESH_SUPPORT
*   MODIFIED:  04/23/2002 modified for 5502
*   MODIFIED:  12/09/2002 merged 5510/5509 CSL with 5502 CSL
*   MOIDIFED:  03/18/2003 added _BCT_SUPPORT definition to SUPPORT matrix
*   MODIFIED:  07/03/2003 Removed c16*CHIP_NONE to avoid remarks.
*   MODIFIED:  10/06/2003 Corrected _CHIP_XBCR_ADDR 
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the CHIP module)
* 
* CHIP Control Registers Covered
*   CHIP_ST0_55  - control status register 0
*   CHIP_ST1_55  - control status register 1
*   CHIP_ST2_55  - control status register 2
*   CHIP_ST3_55  - control status register 3
*   CHIP_IFR0    - interrupt flag register 0
*   CHIP_IFR1    - interrupt flag register 1
*   CHIP_IMR0    - interrupt mask register 0
*   CHIP_IMR1    - interrupt mask register 1
*   CHIP_PDP     - peripheral data page register
*   CHIP_SYSR    - System Control Register (PG2 5510)
*
\******************************************************************************/
#ifndef _CHIPHAL_H_
#define _CHIPHAL_H_
/****************************************\
* include files
\****************************************/
#include <csl_std.h>
#include <csl_stdhal.h>


#ifdef CHIP_5502
   #undef CHIP_5502
   #define CHIP_5502 1
#else
   #define CHIP_5502 0
#endif


#ifdef CHIP_5509
   #undef CHIP_5509
   #define CHIP_5509 1
#else
   #define CHIP_5509 0
#endif

#ifdef CHIP_5509A
   #undef CHIP_5509A
   #define CHIP_5509A 1
#else
   #define CHIP_5509A 0
#endif


#ifdef CHIP_5510
   #undef CHIP_5510
   #define CHIP_5510 1
#else
   #define CHIP_5510 0
#endif

#ifdef CHIP_5510PG1_0
   #undef CHIP_5510PG1_0
   #define CHIP_5510PG1_0 1
#else
   #define CHIP_5510PG1_0 0
#endif

#ifdef CHIP_5510PG2_0
   #undef CHIP_5510PG2_0
   #define CHIP_5510PG2_0 1
#else
   #define CHIP_5510PG2_0 0
#endif


#ifdef CHIP_5510PG2_1
   #undef CHIP_5510PG2_1
   #define CHIP_5510PG2_1 1
#else
   #define CHIP_5510PG2_1 0
#endif

#ifdef CHIP_5510PG2_2
   #undef CHIP_5510PG2_2
   #define CHIP_5510PG2_2 1
#else
   #define CHIP_5510PG2_2 0
#endif

#ifdef CHIP_5510PG1_2
   #undef CHIP_5510PG1_2
   #define CHIP_5510PG1_2 1
#else
   #define CHIP_5510PG1_2 0
#endif

#if CHIP_5510PG1_0
  #undef CHIP_5510
  #define CHIP_5510    1
#endif

#if CHIP_5510PG1_2
#undef CHIP_5510
#define CHIP_5510 1
#endif

#if (CHIP_5510PG2_1) || (CHIP_5510PG2_2)
  #undef CHIP_5510PG2_0
  #define CHIP_5510PG2_0 1
#endif


#ifndef BIOS_CNT
   #define BIOS_CNT 0
#endif

#ifndef OS_BIOS
#define OS_BIOS 0
#endif

#ifndef OS_SPOX
#define OS_SPOX 0
#endif

#ifndef OS_BARACUDA
#define OS_BARACUDA 0
#endif

#if ((CHIP_5510)==0) & ((CHIP_5510PG1_0)==0) & ((CHIP_5510PG1_2)==0) & ((CHIP_5510PG2_0)==0) 
  #define CSL_CHIP_GRPA 0
  #define CHIP_5510_FAMILY 0
#else
  #define CSL_CHIP_GRPA 1
  #define CHIP_5510_FAMILY 1
#endif

#if ((CHIP_5509)==0) & ((CHIP_5509A)==0)
  #define CSL_CHIP_GRPB 0
  #define CHIP_5509_FAMILY 0
#else
  #define CSL_CHIP_GRPB 1
  #define CHIP_5509_FAMILY 1
#endif

#if (CHIP_5502==0)
  #define CSL_CHIP_GRPC 0
  #define CHIP_5502_FAMILY 0
#else
  #define CSL_CHIP_GRPC 1
  #define CHIP_5502_FAMILY 1
#endif

#if (CSL_CHIP_GRPA == 0) & (CSL_CHIP_GRPB == 0) & (CSL_CHIP_GRPC == 0)
#error NO CHIP DEFINED
#endif

#define CHIP_NONE 0

#define SUPPORT(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15)\
 ( c0*CHIP_5510 ||\
   c1*CHIP_5510PG1_2 ||\
   c2*CHIP_5510PG2_0 ||\
   c3*CHIP_5509 ||\
   c4*CHIP_5509A ||\
   c5*CHIP_5502 ||\
   c6*CHIP_NONE ||\
   c7*CHIP_NONE ||\
   c8*CHIP_NONE ||\
   c9*CHIP_NONE ||\
   c10*CHIP_NONE ||\
   c11*CHIP_NONE ||\
   c12*CHIP_NONE ||\
   c13*CHIP_NONE ||\
   c14*CHIP_NONE ||\
   c15*CHIP_NONE\
   )



/*----------------------------------------------------------------*/
/*                                  5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 */
/*                                  5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 */
/*                                  1 1 1 0 0 0 x x x x x x x x x */
/*                                  0 0 9 9 9 2 x x x x x x x x x */
/*                                  P P P x A x x x x x x x x x x */
/*                                  x 1 2 x x x x x x x x x x x x */
/*                                  x 2 0 x x x x x x x x x x x x */
/*----------------------------------------------------------------*/
#define _CHIP_55XX          SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _CHIP_SUPPORT       SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _CHIP_CPU_ID        SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _ICACHE_SUPPORT     SUPPORT(1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0)
#define _CSLINIT_SUPPORT    SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _CSLLIB_SUPPORT     SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _DMA_SUPPORT        SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _DMA_DST_AND_SRC_INDEX_SUPPORT\
                            SUPPORT(0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0)
#define _ERR_SUPPORT        SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _EBSEL_SUPPORT      SUPPORT(0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _GPIO_SUPPORT       SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _GPIO_PARALLEL_SUPPORT\
                            SUPPORT(0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _GPIO_PGPIO_SUPPORT\
                            SUPPORT(0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _GPIO_AGPIO_SUPPORT\
                            SUPPORT(0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _HPI_SUPPORT        SUPPORT(0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0)
#define _IRQ_SUPPORT        SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _MCBSP_SUPPORT      SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _SIG_SUPPORT        SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _TIMER_SUPPORT      SUPPORT(1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _GPT_SUPPORT        SUPPORT(0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0)
#define _BCT_SUPPORT        SUPPORT(0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0)
#define _EMIF_SUPPORT       SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _EMIFA_SUPPORT      SUPPORT(1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _EMIFB_SUPPORT      SUPPORT(0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0)
#define _EMIF_SELFREFRESH_SUPPORT\
                            SUPPORT(0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0)

#define _DAT_SUPPORT        SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _PWR_SUPPORT        SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _SECUREID_SUPPORT   SUPPORT(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
#define _WDTIM_SUPPORT      SUPPORT(0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _WDTIMA_SUPPORT     SUPPORT(0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _WDTIMB_SUPPORT     SUPPORT(0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0)
#define _I2C_SUPPORT        SUPPORT(0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _UART_SUPPORT       SUPPORT(0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0)
/*#define _UHPI_SUPPORT       SUPPORT(0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0)*/
#define _USB_SUPPORT        SUPPORT(0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _PLL_SUPPORT        SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _PLLA_SUPPORT       SUPPORT(1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _PLLB_SUPPORT       SUPPORT(0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0)
#define _PLL_DIGITAL_SUPPORT\
                            SUPPORT(0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _PLL_CLKDIV_SUPPORT\
                            SUPPORT(0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _PLL_ANALOG_SUPPORT\
                            SUPPORT(1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
#define _CSIDR_SUPPORT      SUPPORT(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define _MMC_SUPPORT        SUPPORT(0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _MST_SUPPORT        SUPPORT(0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _ADC_SUPPORT        SUPPORT(0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _RTC_SUPPORT        SUPPORT(0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _MMC_SUPPORT        SUPPORT(0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _MST_SUPPORT        SUPPORT(0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _ADC_SUPPORT        SUPPORT(0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define _RTC_SUPPORT        SUPPORT(0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0)

/*----------------------------------------------------------------*/

/******************************************************************\
* Generic Reigster and Bit Field Manipulation Macros
\******************************************************************/
#define CHIP_ADDR(Reg)               _CHIP_##Reg##_ADDR
#define CHIP_RGET(Reg)               _CHIP_##Reg##_GET
#define CHIP_RSET(Reg,Val)           _CHIP_##Reg##_SET(Val)
#define CHIP_FGET(Reg,Field)         _CHIP_##Reg##_FGET(##Field)
#define CHIP_FSET(Reg,Field,Val)     _CHIP_##Reg##_FSET(##Field,Val)
#define CHIP_FMK(Reg,Field,Val)      _CHIP_##Reg##_##Field##_MK(Val)
#define CHIP_FMKS(Reg,Field,Sym)     CHIP_FMK(##Reg,##Field,##Reg##_##Field##_##Sym)
 
/******************************************************************\
* Bit Field Manipulation and Data Type Definition Macros
\******************************************************************/

/******************************************************************************\
* _CHIP_ST0_55 - control status register 0
*
* Fields:
*   (RW) _CHIP_ST0_55_ACOV2
*   (RW) _CHIP_ST0_55_ACOV3
*   (RW) _CHIP_ST0_55_TC1
*   (RW) _CHIP_ST0_55_TC2
*   (RW) _CHIP_ST0_55_CARRY
*   (RW) _CHIP_ST0_55_ACOV0
*   (RW) _CHIP_ST0_55_ACOV1
*   (RW) _CHIP_ST0_55_DP
*
\******************************************************************************/
#define _CHIP_ST0_55_ADDR     (0x0002u)
#define _CHIP_ST0_55          REG16(_CHIP_ST0_55_ADDR)
#define _ST0_55                _CHIP_ST0_55

#define _CHIP_ST0_55_GET\
   _REG_GET(CHIP_ADDR(ST0_55))

#define _CHIP_ST0_55_SET(Val)\
   _REG_SET(CHIP_ADDR(ST0_55), Val)

#define _CHIP_ST0_55_FGET(Field)\
 _FIELD_GET(CHIP_ADDR(ST0_55),_CHIP_ST0_55_##Field)

#define _CHIP_ST0_55_FSET(Field,Val)\
 _FIELD_SET(CHIP_ADDR(ST0_55),_CHIP_ST0_55_##Field,Val)


/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST0_55_ACOV2: overflow flag fr Acc #2
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST0_55_ACOV2_SHIFT          (0x000Fu)
#define _CHIP_ST0_55_ACOV2_MK(n)          (((Uint16)(n) & 0x0001u) << _CHIP_ST0_55_ACOV2_SHIFT)
#define _CHIP_ST0_55_ACOV2_MASK           (_CHIP_ST0_55_ACOV2_MK(1))
#define _CHIP_ST0_55_ACOV2_CLR            (~(_CHIP_ST0_55_ACOV2_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST0_55_ACOV3: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST0_55_ACOV3_SHIFT          (0x000Eu)
#define _CHIP_ST0_55_ACOV3_MK(n)          (((Uint16)(n) & 0x0001u) << _CHIP_ST0_55_ACOV3_SHIFT)
#define _CHIP_ST0_55_ACOV3_MASK           (_CHIP_ST0_55_ACOV3_MK(1))
#define _CHIP_ST0_55_ACOV3_CLR            (~(_CHIP_ST0_55_ACOV3_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST0_55_TC1: test bit 1
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST0_55_TC1_SHIFT           (0x000Du)
#define _CHIP_ST0_55_TC1_MK(n)           (((Uint16)(n) & 0x0001u) << _CHIP_ST0_55_TC1_SHIFT)
#define _CHIP_ST0_55_TC1_MASK            (_CHIP_ST0_55_TC1_MK(1))
#define _CHIP_ST0_55_TC1_CLR             (~(_CHIP_ST0_55_TC1_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST0_55_TC2: test bit 2
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST0_55_TC2_SHIFT           (0x000Cu)
#define _CHIP_ST0_55_TC2_MK(n)           (((Uint16)(n) & 0x0001u) << _CHIP_ST0_55_TC2_SHIFT)
#define _CHIP_ST0_55_TC2_MASK            (_CHIP_ST0_55_TC2_MK(1))
#define _CHIP_ST0_55_TC2_CLR             (~(_CHIP_ST0_55_TC2_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST0_55_CARRY: test bit 2
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST0_55_CARRY_SHIFT         (0x000Bu)
#define _CHIP_ST0_55_CARRY_MK(n)         (((Uint16)(n) & 0x0001u) << _CHIP_ST0_55_CARRY_SHIFT)
#define _CHIP_ST0_55_CARRY_MASK          (_CHIP_ST0_55_CARRY_MK(1))
#define _CHIP_ST0_55_CARRY_CLR           (~(_CHIP_ST0_55_CARRY_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST0_55_ACOV0: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST0_55_ACOV0_SHIFT         (0x000Au)
#define _CHIP_ST0_55_ACOV0_MK(n)         (((Uint16)(n) & 0x0001u) << _CHIP_ST0_55_ACOV0_SHIFT)
#define _CHIP_ST0_55_ACOV0_MASK          (_CHIP_ST0_55_ACOV0_MK(1))
#define _CHIP_ST0_55_ACOV0_CLR           (~(_CHIP_ST0_55_ACOV0_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST0_55_ACOV1: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST0_55_ACOV1_SHIFT          (0x0009u)
#define _CHIP_ST0_55_ACOV1_MK(n)          (((Uint16)(n) & 0x0001u) << _CHIP_ST0_55_ACOV1_SHIFT)
#define _CHIP_ST0_55_ACOV1_MASK           (_CHIP_ST0_55_ACOV1_MK(1))
#define _CHIP_ST0_55_ACOV1_CLR            (~(_CHIP_ST0_55_ACOV1_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST0_55_DP: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST0_55_DP_SHIFT            (0x0000u)
#define _CHIP_ST0_55_DP_MK(n)            (((Uint16)(n) & 0x00FFu) << _CHIP_ST0_55_DP_SHIFT)
#define _CHIP_ST0_55_DP_MASK             (_CHIP_ST0_55_DP_MK(0x00FFu))
#define _CHIP_ST0_55_DP_CLR              (~(_CHIP_ST0_55_DP_MASK))

#define _CHIP_ST0_55_CFG(acov2, acov3, tc1, tc2, carry, acov0, acov1, dp)\
 _ST0_55 = (Uint16) ( _CHIP_ST0_55_ACOV2_MK(acov2)   |\
                      _CHIP_ST0_55_ACOV3_MK(acov3)   |\
                      _CHIP_ST0_55_TC1_MK(tc1)       |\
                      _CHIP_ST0_55_TC2_MK(tc2)       |\
                      _CHIP_ST0_55_CARRY_MK(carry)   |\
                      _CHIP_ST0_55_ACOV0_MK(acov0)   |\
                      _CHIP_ST0_55_ACOV1_MK(acov1)   |\
                      _CHIP_ST0_55_DP_MK(dp)         \
           )


/******************************************************************************\
* _CHIP_ST1_55 - control status register 0
*
* Fields:
*   (RW) _CHIP_ST1_55_BRAF
*   (RW) _CHIP_ST1_55_CPL
*   (RW) _CHIP_ST1_55_XF
*   (RW) _CHIP_ST1_55_HM
*   (RW) _CHIP_ST1_55_INTM
*   (RW) _CHIP_ST1_55_M40
*   (RW) _CHIP_ST1_55_SATD
*   (RW) _CHIP_ST1_55_SXMD
*   (RW) _CHIP_ST1_55_C16
*   (RW) _CHIP_ST1_55_FRCT
*   (RW) _CHIP_ST1_55_C54CM
*   (RW) _CHIP_ST1_55_ASM
*
\******************************************************************************/
#define _CHIP_ST1_55_ADDR     (0x0003u)
#define _CHIP_ST1_55          REG16(_CHIP_ST1_55_ADDR)
#define _ST1_55                _CHIP_ST1_55

#define _CHIP_ST1_55_GET\
   _REG_GET(CHIP_ADDR(ST1_55))

#define _CHIP_ST1_55_SET(Val)\
   _REG_SET(CHIP_ADDR(ST1_55), Val)

#define _CHIP_ST1_55_FGET(Field)\
 _FIELD_GET(CHIP_ADDR(ST1_55),_CHIP_ST1_55_##Field)

#define _CHIP_ST1_55_FSET(Field,Val)\
 _FIELD_SET(CHIP_ADDR(ST1_55),_CHIP_ST1_55_##Field,Val)
  

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_BRAF: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_BRAF_SHIFT            (0x000Fu)
#define _CHIP_ST1_55_BRAF_MK(n)            (((Uint16)(n) & 0x0001u) << _CHIP_ST1_55_BRAF_SHIFT)
#define _CHIP_ST1_55_BRAF_MASK             (_CHIP_ST1_55_BRAF_MK(1))
#define _CHIP_ST1_55_BRAF_CLR              (~(_CHIP_ST1_55_BRAF_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_CPL: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_CPL_SHIFT             (0x000Eu)
#define _CHIP_ST1_55_CPL_MK(n)             (((Uint16)(n) & 0x0001u) << _CHIP_ST1_55_CPL_SHIFT)
#define _CHIP_ST1_55_CPL_MASK              (_CHIP_ST1_55_CPL_MK(1))
#define _CHIP_ST1_55_CPL_CLR               (~(_CHIP_ST1_55_CPL_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_XF: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_XF_SHIFT              (0x000Du)
#define _CHIP_ST1_55_XF_MK(n)              (((Uint16)(n) & 0x0001u) << _CHIP_ST1_55_XF_SHIFT)
#define _CHIP_ST1_55_XF_MASK               (_CHIP_ST1_55_XF_MK(1))
#define _CHIP_ST1_55_XF_CLR                (~(_CHIP_ST1_55_XF_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_HM: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_HM_SHIFT              (0x000Cu)
#define _CHIP_ST1_55_HM_MK(n)              (((Uint16)(n) & 0x0001u) << _CHIP_ST1_55_HM_SHIFT)
#define _CHIP_ST1_55_HM_MASK               (_CHIP_ST1_55_HM_MK(1))
#define _CHIP_ST1_55_HM_CLR                (~(_CHIP_ST1_55_HM_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_INTM: global maksable interrupt enable/disable
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_INTM_SHIFT            (0x000Bu)
#define _CHIP_ST1_55_INTM_MK(n)            (((Uint16)(n) & 0x0001u) << _CHIP_ST1_55_INTM_SHIFT)
#define _CHIP_ST1_55_INTM_MASK             (_CHIP_ST1_55_INTM_MK(1))
#define _CHIP_ST1_55_INTM_CLR              (~(_CHIP_ST1_55_INTM_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_M40: 40 bit arithmetic
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_M40_SHIFT             (0x000Au)
#define _CHIP_ST1_55_M40_MK(n)             (((Uint16)(n) & 0x0001u) << _CHIP_ST1_55_M40_SHIFT)
#define _CHIP_ST1_55_M40_MASK              (_CHIP_ST1_55_M40_MK(1))
#define _CHIP_ST1_55_M40_CLR               (~(_CHIP_ST1_55_M40_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_SATD: perform saturation on overflow/underflow
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_SATD_SHIFT           (0x0009u)
#define _CHIP_ST1_55_SATD_MK(n)           (((Uint16)(n) & 0x0001u) << _CHIP_ST1_55_SATD_SHIFT)
#define _CHIP_ST1_55_SATD_MASK            (_CHIP_ST1_55_SATD_MK(1))
#define _CHIP_ST1_55_SATD_CLR             (~(_CHIP_ST1_55_SATD_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_SXMD: sign extension mode bit
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_SXMD_SHIFT           (0x0008u)
#define _CHIP_ST1_55_SXMD_MK(n)           (((Uint16)(n) & 0x0001u) << _CHIP_ST1_55_SXMD_SHIFT)
#define _CHIP_ST1_55_SXMD_MASK            (_CHIP_ST1_55_SXMD_MK(1))
#define _CHIP_ST1_55_SXMD_CLR             (~(_CHIP_ST1_55_SXMD_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_C16: dual mode 16 bit arithmetic
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_C16_SHIFT            (0x0007u)
#define _CHIP_ST1_55_C16_MK(n)            (((Uint16)(n) & 0x0001u) << _CHIP_ST1_55_C16_SHIFT)
#define _CHIP_ST1_55_C16_MASK             (_CHIP_ST1_55_C16_MK(1))
#define _CHIP_ST1_55_C16_CLR              (~(_CHIP_ST1_55_C16_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_FRCT: left shift by one on multiply (fractional math)
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_FRCT_SHIFT            (0x0006u)
#define _CHIP_ST1_55_FRCT_MK(n)            (((Uint16)(n) & 0x0001u) << _CHIP_ST1_55_FRCT_SHIFT)
#define _CHIP_ST1_55_FRCT_MASK             (_CHIP_ST1_55_FRCT_MK(1))
#define _CHIP_ST1_55_FRCT_CLR              (~(_CHIP_ST1_55_FRCT_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_C54CM: C54x compatability mode bit
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_C54CM_SHIFT          (0x0005u)
#define _CHIP_ST1_55_C54CM_MK(n)          (((Uint16)(n) & 0x0001u) << _CHIP_ST1_55_C54CM_SHIFT)
#define _CHIP_ST1_55_C54CM_MASK           (_CHIP_ST1_55_C54CM_MK(1))
#define _CHIP_ST1_55_C54CM_CLR            (~(_CHIP_ST1_55_C54CM_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST1_55_ASM: arithmetic shift
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST1_55_ASM_SHIFT          (0x0000u)
#define _CHIP_ST1_55_ASM_MK(n)          (((Uint16)(n) & 0x001Fu) << _CHIP_ST1_55_ASM_SHIFT)
#define _CHIP_ST1_55_ASM_MASK           (_CHIP_ST1_55_ASM_MK(0x001Fu))
#define _CHIP_ST1_55_ASM_CLR            (~(_CHIP_ST1_55_ASM_MASK))

#define _CHIP_ST1_55_CFG(braf, cpl, xf, hm, intm, m40, satd, sxmd, c16, frct,\
                         c54cm, asm)\
  _ST1_55 = (Uint16) (_CHIP_ST1_55_BRAF_MK(braf)   |\
                      _CHIP_ST1_55_CPL_MK(cpl)     |\
                      _CHIP_ST1_55_XF_MK(xf)       |\
                      _CHIP_ST1_55_HM_MK(hm)       |\
                      _CHIP_ST1_55_INTM_MK(intm)   |\
                      _CHIP_ST1_55_M40_MK(m40)     |\
                      _CHIP_ST1_55_SATD_MK(satd)   |\
                      _CHIP_ST1_55_SXMD_MK(sxmd)   |\
                      _CHIP_ST1_55_C16_MK(c16)     |\
                      _CHIP_ST1_55_FRCT_MK(frct)   |\
                      _CHIP_ST1_55_C54CM_MK(c54cm) |\
                      _CHIP_ST1_55_ASM_MK(asm)     \
           )


/******************************************************************************\
* _CHIP_ST2_55 - control status register 2
*
* Fields:
*   (RW) _CHIP_ST2_55_ARMS
*   (RW) _CHIP_ST2_55_DBGM
*   (RW) _CHIP_ST2_55_EALLOW
*   (RW) _CHIP_ST2_55_EALLOW
*   (RW) _CHIP_ST2_55_RDM
*   (RW) _CHIP_ST2_55_CDPLC
*   (RW) _CHIP_ST2_55_AR7LC
*   (RW) _CHIP_ST2_55_AR6LC
*   (RW) _CHIP_ST2_55_AR5LC
*   (RW) _CHIP_ST2_55_AR4LC
*   (RW) _CHIP_ST2_55_AR3LC
*   (RW) _CHIP_ST2_55_AR2LC
*   (RW) _CHIP_ST2_55_AR1LC
*   (RW) _CHIP_ST2_55_AR0LC
*
\******************************************************************************/
#define _CHIP_ST2_55_ADDR     (0x004Bu)
#define _CHIP_ST2_55          REG16(_CHIP_ST2_55_ADDR)
#define _ST2_55                _CHIP_ST2_55

#define _CHIP_ST2_55_GET\
   _REG_GET(CHIP_ADDR(ST2_55))

#define _CHIP_ST2_55_SET(Val)\
   _REG_SET(CHIP_ADDR(ST2_55), Val)

#define _CHIP_ST2_55_FGET(Field)\
 _FIELD_GET(CHIP_ADDR(ST2_55),_CHIP_ST2_55_##Field)

#define _CHIP_ST2_55_FSET(Field,Val)\
 _FIELD_SET(CHIP_ADDR(ST2_55),_CHIP_ST2_55_##Field,Val)


/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_ARMS: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_ARMS_SHIFT            (0x000Fu)
#define _CHIP_ST2_55_ARMS_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_ST2_55_ARMS_SHIFT)
#define _CHIP_ST2_55_ARMS_MASK             (_CHIP_ST2_55_ARMS_MK(1))
#define _CHIP_ST2_55_ARMS_CLR              (~(_CHIP_ST2_55_ARMS_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_DBGM: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_DBGM_SHIFT            (0x000Cu)
#define _CHIP_ST2_55_DBGM_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_ST2_55_DBGM_SHIFT)
#define _CHIP_ST2_55_DBGM_MASK             (_CHIP_ST2_55_DBGM_MK(1))
#define _CHIP_ST2_55_DBGM_CLR              (~(_CHIP_ST2_55_DBGM_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_EALLOW: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_EALLOW_SHIFT           (0x000Bu)
#define _CHIP_ST2_55_EALLOW_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST2_55_EALLOW_SHIFT)
#define _CHIP_ST2_55_EALLOW_MASK            (_CHIP_ST2_55_EALLOW_MK(1))
#define _CHIP_ST2_55_EALLOW_CLR             (~(_CHIP_ST2_55_EALLOW_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_RDM: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_RDM_SHIFT             (0x000Au)
#define _CHIP_ST2_55_RDM_MK(n)             (((Uint16)n & 0x0001u) << _CHIP_ST2_55_RDM_SHIFT)
#define _CHIP_ST2_55_RDM_MASK              (_CHIP_ST2_55_RDM_MK(1))
#define _CHIP_ST2_55_RDM_CLR               (~(_CHIP_ST2_55_RDM_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_CDPLC: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_CDPLC_SHIFT           (0x0008u)
#define _CHIP_ST2_55_CDPLC_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST2_55_CDPLC_SHIFT)
#define _CHIP_ST2_55_CDPLC_MASK            (_CHIP_ST2_55_CDPLC_MK(1))
#define _CHIP_ST2_55_CDPLC_CLR             (~(_CHIP_ST2_55_CDPLC_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_CDPLC: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_CDPLC_SHIFT           (0x0008u)
#define _CHIP_ST2_55_CDPLC_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST2_55_CDPLC_SHIFT)
#define _CHIP_ST2_55_CDPLC_MASK            (_CHIP_ST2_55_CDPLC_MK(1))
#define _CHIP_ST2_55_CDPLC_CLR             (~(_CHIP_ST2_55_CDPLC_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_AR7LC: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_AR7LC_SHIFT           (0x0007u)
#define _CHIP_ST2_55_AR7LC_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST2_55_AR7LC_SHIFT)
#define _CHIP_ST2_55_AR7LC_MASK            (_CHIP_ST2_55_AR7LC_MK(1))
#define _CHIP_ST2_55_AR7LC_CLR             (~(_CHIP_ST2_55_AR7LC_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_AR6LC: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_AR6LC_SHIFT           (0x0006u)
#define _CHIP_ST2_55_AR6LC_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST2_55_AR6LC_SHIFT)
#define _CHIP_ST2_55_AR6LC_MASK            (_CHIP_ST2_55_AR6LC_MK(1))
#define _CHIP_ST2_55_AR6LC_CLR             (~(_CHIP_ST2_55_AR6LC_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_AR5LC: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_AR5LC_SHIFT           (0x0005u)
#define _CHIP_ST2_55_AR5LC_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST2_55_AR5LC_SHIFT)
#define _CHIP_ST2_55_AR5LC_MASK            (_CHIP_ST2_55_AR5LC_MK(1))
#define _CHIP_ST2_55_AR5LC_CLR             (~(_CHIP_ST2_55_AR5LC_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_AR4LC: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_AR4LC_SHIFT           (0x0004u)
#define _CHIP_ST2_55_AR4LC_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST2_55_AR4LC_SHIFT)
#define _CHIP_ST2_55_AR4LC_MASK            (_CHIP_ST2_55_AR4LC_MK(1))
#define _CHIP_ST2_55_AR4LC_CLR             (~(_CHIP_ST2_55_AR4LC_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_AR3LC: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_AR3LC_SHIFT           (0x0003u)
#define _CHIP_ST2_55_AR3LC_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST2_55_AR3LC_SHIFT)
#define _CHIP_ST2_55_AR3LC_MASK            (_CHIP_ST2_55_AR3LC_MK(1))
#define _CHIP_ST2_55_AR3LC_CLR             (~(_CHIP_ST2_55_AR3LC_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_AR2LC: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_AR2LC_SHIFT           (0x0002u)
#define _CHIP_ST2_55_AR2LC_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST2_55_AR2LC_SHIFT)
#define _CHIP_ST2_55_AR2LC_MASK            (_CHIP_ST2_55_AR2LC_MK(1))
#define _CHIP_ST2_55_AR2LC_CLR             (~(_CHIP_ST2_55_AR2LC_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_AR1LC: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_AR1LC_SHIFT           (0x0001u)
#define _CHIP_ST2_55_AR1LC_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST2_55_AR1LC_SHIFT)
#define _CHIP_ST2_55_AR1LC_MASK            (_CHIP_ST2_55_AR1LC_MK(1))
#define _CHIP_ST2_55_AR1LC_CLR             (~(_CHIP_ST2_55_AR1LC_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST2_55_AR0LC: overflow flag fr Acc #3
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST2_55_AR0LC_SHIFT           (0x0000u)
#define _CHIP_ST2_55_AR0LC_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST2_55_AR0LC_SHIFT)
#define _CHIP_ST2_55_AR0LC_MASK            (_CHIP_ST2_55_AR0LC_MK(1))
#define _CHIP_ST2_55_AR0LC_CLR             (~(_CHIP_ST2_55_AR0LC_MASK))

#define _CHIP_ST2_55_CFG(arms, dbgm, eallow, rdm, cdplc, ar7lc, ar6lc, ar5lc,\
                         ar4lc, ar3lc,ar2lc,ar1lc,ar0lc)\
  _ST2_55 = (Uint16) ( _CHIP_ST2_55_ARMS_MK(arms)     |\
                      _CHIP_ST2_55_DBGM_Mk(dbgm)     |\
                      _CHIP_ST2_55_EALLOW_MK(eallow) |\
                      _CHIP_ST2_55_RDM_MK(rdm)       |\
                      _CHIP_ST2_55_CDPLC_MK(cdplc)   |\
                      _CHIP_ST2_55_AR7LC_MK(ar7lc)   |\
                      _CHIP_ST2_55_AR6LC_MK(ar6lc)   |\
                      _CHIP_ST2_55_AR5LC_MK(ar5lc)   |\
                      _CHIP_ST2_55_AR4LC_MK(ar4lc)   |\
                      _CHIP_ST2_55_AR3LC_MK(ar3lc)   |\
                      _CHIP_ST2_55_AR2LC_MK(ar2lc)   |\
                      _CHIP_ST2_55_AR1LC_MK(ar1lc)   |\
                      _CHIP_ST2_55_AR0LC_MK(ar0lc)   |\
           )


/******************************************************************************\
* _CHIP_ST3_55 - control status register 2
*
* Fields:
*   (RW) _CHIP_ST3_55_CAFRZ
*   (RW) _CHIP_ST3_55_CAEN
*   (RW) _CHIP_ST3_55_CACLR
*   (RW) _CHIP_ST3_55_HINT
*   (RW) _CHIP_ST3_55_CBERR
*   (RW) _CHIP_ST3_55_MPNMC
*   (RW) _CHIP_ST3_55_SATA
*   (RW) _CHIP_ST3_55_AVIS
*   (RW) _CHIP_ST3_55_CLKOFF
*   (RW) _CHIP_ST3_55_SMUL
*   (RW) _CHIP_ST3_55_SST
*
\******************************************************************************/
#define _CHIP_ST3_55_ADDR     (0x004u)
#define _CHIP_ST3_55          REG16(_CHIP_ST3_55_ADDR)
#define _ST3_55                _CHIP_ST3_55

#define _CHIP_ST3_55_GET\
   _REG_GET(_CHIP_ST3_55_ADDR)

#define _CHIP_ST3_55_SET(Val)\
   _REG_SET(_CHIP_ST3_55_ADDR, Val)

#define _CHIP_ST3_55_FGET(Field)\
 _FIELD_GET(CHIP_ADDR(ST3_55),_CHIP_ST3_55_##Field)

#define _CHIP_ST3_55_FSET(Field,Val)\
 _FIELD_SET(CHIP_ADDR(ST3_55),_CHIP_ST3_55_##Field,Val)
  


/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST3_55_CAFRZ: CACHE FREEZE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST3_55_CAFRZ_SHIFT            (0x000Fu)
#define _CHIP_ST3_55_CAFRZ_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_ST3_55_CAFRZ_SHIFT)
#define _CHIP_ST3_55_CAFRZ_MASK             (_CHIP_ST3_55_CAFRZ_MK(1))
#define _CHIP_ST3_55_CAFRZ_CLR              (~(_CHIP_ST3_55_CAFRZ_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST3_55_CAEN: CACHE ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST3_55_CAEN_SHIFT             (0x000Eu)
#define _CHIP_ST3_55_CAEN_MK(n)             (((Uint16)n & 0x0001u) << _CHIP_ST3_55_CAEN_SHIFT)
#define _CHIP_ST3_55_CAEN_MASK              (_CHIP_ST3_55_CAEN_MK(1))
#define _CHIP_ST3_55_CAEN_CLR               (~(_CHIP_ST3_55_CAEN_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST3_55_CACLR: CACHE CLEAR
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST3_55_CACLR_SHIFT            (0x000Du)
#define _CHIP_ST3_55_CACLR_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_ST3_55_CACLR_SHIFT)
#define _CHIP_ST3_55_CACLR_MASK             (_CHIP_ST3_55_CACLR_MK(1))
#define _CHIP_ST3_55_CACLR_CLR              (~(_CHIP_ST3_55_CACLR_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST3_55_HINT: HOST INTERRUPT?
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST3_55_HINT_SHIFT             (0x000Cu)
#define _CHIP_ST3_55_HINT_MK(n)             (((Uint16)n & 0x0001u) << _CHIP_ST3_55_HINT_SHIFT)
#define _CHIP_ST3_55_HINT_MASK              (_CHIP_ST3_55_HINT_MK(1))
#define _CHIP_ST3_55_HINT_CLR               (~(_CHIP_ST3_55_HINT_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST3_55_CBERR: CACHE BOUNDARY ERROR
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST3_55_CBERR_SHIFT            (0x0007u)
#define _CHIP_ST3_55_CBERR_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_ST3_55_CBERR_SHIFT)
#define _CHIP_ST3_55_CBERR_MASK             (_CHIP_ST3_55_CBERR_MK(1))
#define _CHIP_ST3_55_CBERR_CLR              (~(_CHIP_ST3_55_CBERR_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST3_55_MPNMC: CACHE BOUNDARY ERROR
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST3_55_MPNMC_SHIFT            (0x0006u)
#define _CHIP_ST3_55_MPNMC_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_ST3_55_MPNMC_SHIFT)
#define _CHIP_ST3_55_MPNMC_MASK             (_CHIP_ST3_55_MPNMC_MK(1))
#define _CHIP_ST3_55_MPNMC_CLR              (~(_CHIP_ST3_55_MPNMC_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST3_55_SATA: CACHE BOUNDARY ERROR
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST3_55_SATA_SHIFT           (0x0005u)
#define _CHIP_ST3_55_SATA_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST3_55_SATA_SHIFT)
#define _CHIP_ST3_55_SATA_MASK            (_CHIP_ST3_55_SATA_MK(1))
#define _CHIP_ST3_55_SATA_CLR             (~(_CHIP_ST3_55_SATA_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST3_55_AVIS: CACHE BOUNDARY ERROR
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST3_55_AVIS_SHIFT           (0x0004u)
#define _CHIP_ST3_55_AVIS_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST3_55_AVIS_SHIFT)
#define _CHIP_ST3_55_AVIS_MASK            (_CHIP_ST3_55_AVIS_MK(1))
#define _CHIP_ST3_55_AVIS_CLR             (~(_CHIP_ST3_55_AVIS_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST3_55_CLKOFF: CACHE BOUNDARY ERROR
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST3_55_CLKOFF_SHIFT         (0x0002u)
#define _CHIP_ST3_55_CLKOFF_MK(n)         (((Uint16)n & 0x0001u) << _CHIP_ST3_55_CLKOFF_SHIFT)
#define _CHIP_ST3_55_CLKOFF_MASK          (_CHIP_ST3_55_CLKOFF_MK(1))
#define _CHIP_ST3_55_CLKOFF_CLR           (~(_CHIP_ST3_55_CLKOFF_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST3_55_SMUL: CACHE BOUNDARY ERROR
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST3_55_SMUL_SHIFT           (0x0001u)
#define _CHIP_ST3_55_SMUL_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST3_55_SMUL_SHIFT)
#define _CHIP_ST3_55_SMUL_MASK            (_CHIP_ST3_55_SMUL_MK(1))
#define _CHIP_ST3_55_SMUL_CLR             (~(_CHIP_ST3_55_SMUL_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_ST3_55_SST: CACHE BOUNDARY ERROR
\*----------------------------------------------------------------------------*/ 
#define _CHIP_ST3_55_SST_SHIFT           (0x0000u)
#define _CHIP_ST3_55_SST_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_ST3_55_SST_SHIFT)
#define _CHIP_ST3_55_SST_MASK            (_CHIP_ST3_55_SST_MK(1))
#define _CHIP_ST3_55_SST_CLR             (~(_CHIP_ST3_55_SST_MASK))

#define _CHIP_ST3_55_CFG(cafrz, caen, caclr, hint, cberr, mpnmc, sata, avis,\
                         clkoff, smul, sst)\
  _ST3_55 =   (Uint16) ( _CHIP_ST3_55_CAFRZ_MK(cafrz)   |\
                        _CHIP_ST3_55_CAEN_MK(caen)     |\
                        _CHIP_ST3_55_CACLR_MK(calcr)   |\
                        _CHIP_ST3_55_HINT_MK(hint)     |\
                        _CHIP_ST3_55_CBERR_MK(cberr)   |\
                        _CHIP_ST3_55_MPNMC_MK(mpnmc)   |\
                        _CHIP_ST3_55_SATA_MK(sata)     |\
                        _CHIP_ST3_55_AVIS_MK(avis)     |\
                        _CHIP_ST3_55_CLKOFF_MK(clkoff) |\
                        _CHIP_ST3_55_SMUL_MK(smul)     |\
                        _CHIP_ST3_55_SST_MK(sst)        \
             )

/******************************************************************************\
* _CHIP_IER0 - INTERRUPT ENABLE/MASK REGISTER #0
*
* Fields:
*   (RW) _CHIP_IER0_DMAC5
*   (RW) _CHIP_IER0_DMAC4
*   (RW) _CHIP_IER0_XINT2
*   (RW) _CHIP_IER0_RINT2
*   (RW) _CHIP_IER0_INT3
*   (RW) _CHIP_IER0_DSPINT
*   (RW) _CHIP_IER0_DMAC1
*   (RW) _CHIP_IER0_XINT1
*   (RW) _CHIP_IER0_RINT1
*   (RW) _CHIP_IER0_RINT0
*   (RW) _CHIP_IER0_TINT0
*   (RW) _CHIP_IER0_INT2
*   (RW) _CHIP_IER0_INT0
*
\******************************************************************************/
#define _CHIP_IER0_ADDR     (0x0000u)
#define _CHIP_IER0          REG16(_CHIP_IER0_ADDR)
#define _IER0                _CHIP_IER0

#define _CHIP_IER0_GET\
   _REG_GET(CHIP_ADDR(IER0))

#define _CHIP_IER0_SET(Val)\
   _REG_SET(CHIP_ADDR(IER0), Val)

#define _CHIP_IER0_FGET(Field)\
 _FIELD_GET(CHIP_ADDR(IER0),_CHIP_IER0_##Field)

#define _CHIP_IER0_FSET(Field,Val)\
 _FIELD_SET(CHIP_ADDR(IER0),_CHIP_IER0_##Field,Val)
  

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_DMAC5: DMA CHANNEL 5 INTERRUPT ENABLE BIT
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_DMAC5_SHIFT            (0x000Fu)
#define _CHIP_IER0_DMAC5_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IER0_DMAC5_SHIFT)
#define _CHIP_IER0_DMAC5_MASK             (_CHIP_IER0_DMAC5_MK(1))
#define _CHIP_IER0_DMAC5_CLR              (~(_CHIP_IER0_DMAC5_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_DMAC4: DMA CHANNEL 4 INTERRUPT ENABLE BIT
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_DMAC4_SHIFT            (0x000Eu)
#define _CHIP_IER0_DMAC4_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IER0_DMAC4_SHIFT)
#define _CHIP_IER0_DMAC4_MASK             (_CHIP_IER0_DMAC4_MK(1))
#define _CHIP_IER0_DMAC4_CLR              (~(_CHIP_IER0_DMAC4_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_XINT2: SERIAL PORT #2 TRANSMIT INTERRUPT ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_XINT2_SHIFT            (0x000Du)
#define _CHIP_IER0_XINT2_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IER0_XINT2_SHIFT)
#define _CHIP_IER0_XINT2_MASK             (_CHIP_IER0_XINT2_MK(1))
#define _CHIP_IER0_XINT2_CLR              (~(_CHIP_IER0_XINT2_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_RINT2: SERIAL PORT #2 RECEIVE INTERRUPT ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_RINT2_SHIFT            (0x000Cu)
#define _CHIP_IER0_RINT2_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IER0_RINT2_SHIFT)
#define _CHIP_IER0_RINT2_MASK             (_CHIP_IER0_RINT2_MK(1))
#define _CHIP_IER0_RINT2_CLR              (~(_CHIP_IER0_RINT2_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_INT3: EXTERNAL USER INTERRUPT #3 ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_INT3_SHIFT             (0x000Bu)
#define _CHIP_IER0_INT3_MK(n)             (((Uint16)n & 0x0001u) << _CHIP_IER0_INT3_SHIFT)
#define _CHIP_IER0_INT3_MASK              (_CHIP_IER0_INT3_MK(1))
#define _CHIP_IER0_INT3_CLR               (~(_CHIP_IER0_INT3_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_DSPINT: HOST TO DSP INTERRUPT ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_DSPINT_SHIFT          (0x000Au)
#define _CHIP_IER0_DSPINT_MK(n)          (((Uint16)n & 0x0001u) << _CHIP_IER0_DSPINT_SHIFT)
#define _CHIP_IER0_DSPINT_MASK           (_CHIP_IER0_DSPINT_MK(1))
#define _CHIP_IER0_DSPINT_CLR            (~(_CHIP_IER0_DSPINT_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_DMAC1: DMA CHANNEL #1 INTERRUPT ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_DMAC1_SHIFT           (0x0009u)
#define _CHIP_IER0_DMAC1_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_IER0_DMAC1_SHIFT)
#define _CHIP_IER0_DMAC1_MASK            (_CHIP_IER0_DMAC1_MK(1))
#define _CHIP_IER0_DMAC1_CLR             (~(_CHIP_IER0_DMAC1_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_XINT1: SERIAL PORT #1 TRANSMIT INTERRUPT ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_XINT1_SHIFT           (0x0007u)
#define _CHIP_IER0_XINT1_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_IER0_XINT1_SHIFT)
#define _CHIP_IER0_XINT1_MASK            (_CHIP_IER0_XINT1_MK(1))
#define _CHIP_IER0_XINT1_CLR             (~(_CHIP_IER0_XINT1_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_RINT1: SERIAL PORT #1 RECEIVE INTERRUPT ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_RINT1_SHIFT           (0x0006u)
#define _CHIP_IER0_RINT1_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_IER0_RINT1_SHIFT)
#define _CHIP_IER0_RINT1_MASK            (_CHIP_IER0_RINT1_MK(1))
#define _CHIP_IER0_RINT1_CLR             (~(_CHIP_IER0_RINT1_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_RINT0: SERIAL PORT #0 INTERRUPT ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_RINT0_SHIFT           (0x0005u)
#define _CHIP_IER0_RINT0_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_IER0_RINT0_SHIFT)
#define _CHIP_IER0_RINT0_MASK            (_CHIP_IER0_RINT0_MK(1))
#define _CHIP_IER0_RINT0_CLR             (~(_CHIP_IER0_RINT0_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_TINT0: TIMER #0 INTERRUPT ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_TINT0_SHIFT           (0x0004u)
#define _CHIP_IER0_TINT0_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_IER0_TINT0_SHIFT)
#define _CHIP_IER0_TINT0_MASK            (_CHIP_IER0_TINT0_MK(1))
#define _CHIP_IER0_TINT0_CLR             (~(_CHIP_IER0_TINT0_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_INT2: EXTERNAL USER #2 INTERRUPT ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_INT2_SHIFT            (0x0003u)
#define _CHIP_IER0_INT2_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IER0_INT2_SHIFT)
#define _CHIP_IER0_INT2_MASK             (_CHIP_IER0_INT2_MK(1))
#define _CHIP_IER0_INT2_CLR              (~(_CHIP_IER0_INT2_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER0_INT0: EXTERNAL USER #1 INTERRUPT ENABLE
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER0_INT0_SHIFT            (0x0002u)
#define _CHIP_IER0_INT0_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IER0_INT0_SHIFT)
#define _CHIP_IER0_INT0_MASK             (_CHIP_IER0_INT0_MK(1))
#define _CHIP_IER0_INT0_CLR              (~(_CHIP_IER0_INT0_MASK))

#define _CHIP_IER0_CFG(dmac5, dmac4, xint2, rint2, int3, dspint, dmac1,\
                       xint1, rint1, rint0, tint0, int2, int0)\
 _IER0 = (Uint16) ( _CHIP_IER0_DMAC5_MK(dmac5)   |\
                    _CHIP_IER0_DMAC4_MK(dmac4)   |\
                    _CHIP_IER0_XINT2_MK(xint2)   |\
                    _CHIP_IER0_RINT2_MK(rint2)   |\
                    _CHIP_IER0_INT3_MK(int3)     |\
                    _CHIP_IER0_DSPINT_MK(dspint) |\
                    _CHIP_IER0_DMAC1_MK(dmac1)   |\
                    _CHIP_IER0_XINT1_MK(xint1)   |\
                    _CHIP_IER0_RINT1_MK(rint1)   |\
                    _CHIP_IER0_RINT0_MK(rint0)   |\
                    _CHIP_IER0_TINT0_MK(tint0)   |\
                    _CHIP_IER0_INT2_MK(int2)     |\
                    _CHIP_IER0_INT0_MK(int0)     \
        )


/******************************************************************************\
* _CHIP_IER1 - control status register 2
*
* Fields:
*   (RW) _CHIP_IER1_INT5
*   (RW) _CHIP_IER1_TINT1
*   (RW) _CHIP_IER1_DMAC3
*   (RW) _CHIP_IER1_DMAC2
*   (RW) _CHIP_IER1_INT4
*   (RW) _CHIP_IER1_DMAC0
*   (RW) _CHIP_IER1_XINT0
*   (RW) _CHIP_IER1_INT1
*
\******************************************************************************/
#define _CHIP_IER1_ADDR     (0x0045u)
#define _CHIP_IER1          REG16(_CHIP_IER1_ADDR)
#define _IER1                _CHIP_IER1

#define _CHIP_IER1_GET\
   _REG_GET(CHIP_ADDR(IER1))

#define _CHIP_IER1_SET(Val)\
   _REG_SET(CHIP_ADDR(IER1),Val)

#define _CHIP_IER1_FGET(Field)\
 _FIELD_GET(CHIP_ADDR(IER1),_CHIP_IER1_##Field)

#define _CHIP_IER1_FSET(Field,Val)\
 _FIELD_SET(CHIP_ADDR(IER1),_CHIP_IER1_##Field,Val)
  

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER1_INT5: EXTERNAL USER #5 INTERRUPT ENABLE BIT
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER1_INT5_SHIFT            (0x0007u)
#define _CHIP_IER1_INT5_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IER1_INT5_SHIFT)
#define _CHIP_IER1_INT5_MASK             (_CHIP_IER1_INT5_MK(1))
#define _CHIP_IER1_INT5_CLR              (~(_CHIP_IER1_INT5_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER1_TINT1: TIMER #1 INTERRUPT ENABLE BIT
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER1_TINT1_SHIFT            (0x0006u)
#define _CHIP_IER1_TINT1_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IER1_TINT1_SHIFT)
#define _CHIP_IER1_TINT1_MASK             (_CHIP_IER1_TINT1_MK(1))
#define _CHIP_IER1_TINT1_CLR              (~(_CHIP_IER1_TINT1_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER1_DMAC3: DMA CHANNEL #3 INTERRUPT ENABLE BIT
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER1_DMAC3_SHIFT            (0x0005u)
#define _CHIP_IER1_DMAC3_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IER1_DMAC3_SHIFT)
#define _CHIP_IER1_DMAC3_MASK             (_CHIP_IER1_DMAC3_MK(1))
#define _CHIP_IER1_DMAC3_CLR              (~(_CHIP_IER1_DMAC3_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER1_DMAC2: DMA CHANNEL #2 INTERRUPT ENABLE BIT
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER1_DMAC2_SHIFT            (0x0004u)
#define _CHIP_IER1_DMAC2_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IER1_DMAC2_SHIFT)
#define _CHIP_IER1_DMAC2_MASK             (_CHIP_IER1_DMAC2_MK(1))
#define _CHIP_IER1_DMAC2_CLR              (~(_CHIP_IER1_DMAC2_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER1_INT4: EXTERNAL USER #4 INTERRUPT ENABLE BIT
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER1_INT4_SHIFT             (0x0003u)
#define _CHIP_IER1_INT4_MK(n)             (((Uint16)n & 0x0001u) << _CHIP_IER1_INT4_SHIFT)
#define _CHIP_IER1_INT4_MASK              (_CHIP_IER1_INT4_MK(1))
#define _CHIP_IER1_INT4_CLR               (~(_CHIP_IER1_INT4_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER1_DMAC0: DMA CHANNEL #0 INTERRUPT ENABLE BIT
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER1_DMAC0_SHIFT             (0x0002u)
#define _CHIP_IER1_DMAC0_MK(n)             (((Uint16)n & 0x0001u) << _CHIP_IER1_DMAC0_SHIFT)
#define _CHIP_IER1_DMAC0_MASK              (_CHIP_IER1_DMAC0_MK(1))
#define _CHIP_IER1_DMAC0_CLR               (~(_CHIP_IER1_DMAC0_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER1_XINT0: SERIAL PORT #0 TRANSMIT INTERRUPT ENABLE BIT
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER1_XINT0_SHIFT             (0x0001u)
#define _CHIP_IER1_XINT0_MK(n)             (((Uint16)n & 0x0001u) << _CHIP_IER1_XINT0_SHIFT)
#define _CHIP_IER1_XINT0_MASK              (_CHIP_IER1_XINT0_MK(1))
#define _CHIP_IER1_XINT0_CLR               (~(_CHIP_IER1_XINT0_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IER1_INT1: EXTERNAL USER #1 INTERRUPT ENABLE BIT
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IER1_INT1_SHIFT              (0x0000u)
#define _CHIP_IER1_INT1_MK(n)              (((Uint16)n & 0x0001u) << _CHIP_IER1_INT1_SHIFT)
#define _CHIP_IER1_INT1_MASK               (_CHIP_IER1_INT1_MK(1))
#define _CHIP_IER1_INT1_CLR                (~(_CHIP_IER1_INT1_MASK))

#define _CHIP_IER1_CFG(int5, tint1, dmac3, dmac2, int4, dmac0, xint0, int1)\
  _IER1 =  (Uint16)( _CHIP_IER1_INT5_MK(int5)   |\
                     _CHIP_IER1_TINT1_MK(tint1) |\
                     _CHIP_IER1_DMAC3_MK(dmac3) |\
                     _CHIP_IER1_DMAC2_MK(dmac2) |\
                     _CHIP_IER1_INT4_MK(int4)   |\
                     _CHIP_IER1_DMAC0_MK(dmac0) |\
                     _CHIP_IER1_XINT0_MK(xint0) |\
                     _CHIP_IER1_INT1_MK(int1)   \
          )

 
/******************************************************************************\
* _CHIP_IFR0 - INTERRUPT FLAG REGISTER #0
*
* Fields:
*   (RW) _CHIP_IFR0_DMAC5
*   (RW) _CHIP_IFR0_DMAC4
*   (RW) _CHIP_IFR0_XINT2
*   (RW) _CHIP_IFR0_RINT2
*   (RW) _CHIP_IFR0_INT3
*   (RW) _CHIP_IFR0_DSPINT
*   (RW) _CHIP_IFR0_DMAC1
*   (RW) _CHIP_IFR0_XINT1
*   (RW) _CHIP_IFR0_RINT1
*   (RW) _CHIP_IFR0_RINT0
*   (RW) _CHIP_IFR0_TINT0
*   (RW) _CHIP_IFR0_INT2
*   (RW) _CHIP_IFR0_INT0
*
\******************************************************************************/
#define _CHIP_IFR0_ADDR     (0x0001u)
#define _CHIP_IFR0          REG16(_CHIP_IFR0_ADDR)
#define _IFR0                _CHIP_IFR0

#define _CHIP_IFR0_GET\
   _REG_GET(CHIP_ADDR(IFR0))

#define _CHIP_IFR0_SET(Val)\
   _REG_SET(CHIP_ADDR(IFR0), Val)

#define _CHIP_IFR0_FGET(Field)\
 _FIELD_GET(CHIP_ADDR(IFR0),_CHIP_IFR0_##Field)

#define _CHIP_IFR0_FSET(Field,Val)\
 _FIELD_SET(CHIP_ADDR(IFR0),_CHIP_IFR0_##Field,Val)
  

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_DMAC5: DMA CHANNEL 5 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_DMAC5_SHIFT            (0x000Fu)
#define _CHIP_IFR0_DMAC5_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IFR0_DMAC5_SHIFT)
#define _CHIP_IFR0_DMAC5_MASK             (_CHIP_IFR0_DMAC5_MK(1))
#define _CHIP_IFR0_DMAC5_CLR              (~(_CHIP_IFR0_DMAC5_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_DMAC4: DMA CHANNEL 4 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_DMAC4_SHIFT            (0x000Eu)
#define _CHIP_IFR0_DMAC4_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IFR0_DMAC4_SHIFT)
#define _CHIP_IFR0_DMAC4_MASK             (_CHIP_IFR0_DMAC4_MK(1))
#define _CHIP_IFR0_DMAC4_CLR              (~(_CHIP_IFR0_DMAC4_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_XINT2: SERIAL PORT #2 TRANSMIT INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_XINT2_SHIFT            (0x000Du)
#define _CHIP_IFR0_XINT2_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IFR0_XINT2_SHIFT)
#define _CHIP_IFR0_XINT2_MASK             (_CHIP_IFR0_XINT2_MK(1))
#define _CHIP_IFR0_XINT2_CLR              (~(_CHIP_IFR0_XINT2_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_RINT2: SERIAL PORT #2 RECEIVE INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_RINT2_SHIFT            (0x000Cu)
#define _CHIP_IFR0_RINT2_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IFR0_RINT2_SHIFT)
#define _CHIP_IFR0_RINT2_MASK             (_CHIP_IFR0_RINT2_MK(1))
#define _CHIP_IFR0_RINT2_CLR              (~(_CHIP_IFR0_RINT2_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_INT3: EXTERNAL USER INTERRUPT #3 FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_INT3_SHIFT             (0x000Bu)
#define _CHIP_IFR0_INT3_MK(n)             (((Uint16)n & 0x0001u) << _CHIP_IFR0_INT3_SHIFT)
#define _CHIP_IFR0_INT3_MASK              (_CHIP_IFR0_INT3_MK(1))
#define _CHIP_IFR0_INT3_CLR               (~(_CHIP_IFR0_INT3_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_DSPINT: HOST TO DSP INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_DSPINT_SHIFT          (0x000Au)
#define _CHIP_IFR0_DSPINT_MK(n)          (((Uint16)n & 0x0001u) << _CHIP_IFR0_DSPINT_SHIFT)
#define _CHIP_IFR0_DSPINT_MASK           (_CHIP_IFR0_DSPINT_MK(1))
#define _CHIP_IFR0_DSPINT_CLR            (~(_CHIP_IFR0_DSPINT_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_DMAC1: DMA CHANNEL #1 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_DMAC1_SHIFT           (0x0009u)
#define _CHIP_IFR0_DMAC1_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_IFR0_DMAC1_SHIFT)
#define _CHIP_IFR0_DMAC1_MASK            (_CHIP_IFR0_DMAC1_MK(1))
#define _CHIP_IFR0_DMAC1_CLR             (~(_CHIP_IFR0_DMAC1_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_XINT1: SERIAL PORT #1 TRANSMIT INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_XINT1_SHIFT           (0x0007u)
#define _CHIP_IFR0_XINT1_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_IFR0_XINT1_SHIFT)
#define _CHIP_IFR0_XINT1_MASK            (_CHIP_IFR0_XINT1_MK(1))
#define _CHIP_IFR0_XINT1_CLR             (~(_CHIP_IFR0_XINT1_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_RINT1: SERIAL PORT #1 RECEIVE INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_RINT1_SHIFT           (0x0006u)
#define _CHIP_IFR0_RINT1_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_IFR0_RINT1_SHIFT)
#define _CHIP_IFR0_RINT1_MASK            (_CHIP_IFR0_RINT1_MK(1))
#define _CHIP_IFR0_RINT1_CLR             (~(_CHIP_IFR0_RINT1_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_RINT0: SERIAL PORT #0 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_RINT0_SHIFT           (0x0005u)
#define _CHIP_IFR0_RINT0_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_IFR0_RINT0_SHIFT)
#define _CHIP_IFR0_RINT0_MASK            (_CHIP_IFR0_RINT0_MK(1))
#define _CHIP_IFR0_RINT0_CLR             (~(_CHIP_IFR0_RINT0_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_TINT0: TIMER #0 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_TINT0_SHIFT           (0x0004u)
#define _CHIP_IFR0_TINT0_MK(n)           (((Uint16)n & 0x0001u) << _CHIP_IFR0_TINT0_SHIFT)
#define _CHIP_IFR0_TINT0_MASK            (_CHIP_IFR0_TINT0_MK(1))
#define _CHIP_IFR0_TINT0_CLR             (~(_CHIP_IFR0_TINT0_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_INT2: EXTERNAL USER #2 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_INT2_SHIFT            (0x0003u)
#define _CHIP_IFR0_INT2_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IFR0_INT2_SHIFT)
#define _CHIP_IFR0_INT2_MASK             (_CHIP_IFR0_INT2_MK(1))
#define _CHIP_IFR0_INT2_CLR              (~(_CHIP_IFR0_INT2_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR0_INT0: EXTERNAL USER #1 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR0_INT0_SHIFT            (0x0002u)
#define _CHIP_IFR0_INT0_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IFR0_INT0_SHIFT)
#define _CHIP_IFR0_INT0_MASK             (_CHIP_IFR0_INT0_MK(1))
#define _CHIP_IFR0_INT0_CLR              (~(_CHIP_IFR0_INT0_MASK))

#define _CHIP_IFR0_CFG(dmac5, dmac4, xint2, rint2, int3, dspint, dmac1,\
                       xint1, rint1, rint0, tint0, int2, int0)\
  _IFR0 = (Uint16) ( _CHIP_IFR0_DMAC5_MK(dmac5)   |\
                     _CHIP_IFR0_DMAC4_MK(dmac4)   |\
                     _CHIP_IFR0_XINT2_MK(xint2)   |\
                     _CHIP_IFR0_RINT2_MK(rint2)   |\
                     _CHIP_IFR0_INT3_MK(int3)     |\
                     _CHIP_IFR0_DSPINT_MK(dspint) |\
                     _CHIP_IFR0_DMAC1_MK(dmac1)   |\
                     _CHIP_IFR0_XINT1_MK(xint1)   |\
                     _CHIP_IFR0_RINT1_MK(rint1)   |\
                     _CHIP_IFR0_RINT0_MK(rint0)   |\
                     _CHIP_IFR0_TINT0_MK(tint0)   |\
                     _CHIP_IFR0_INT2_MK(int2)     |\
                     _CHIP_IFR0_INT0_MK(int0)     \
         )


/******************************************************************************\
* _CHIP_IFR1 - control status register 2
*
* Fields:
*   (RW) _CHIP_IFR1_INT5
*   (RW) _CHIP_IFR1_TINT1
*   (RW) _CHIP_IFR1_DMAC3
*   (RW) _CHIP_IFR1_DMAC2
*   (RW) _CHIP_IFR1_INT4
*   (RW) _CHIP_IFR1_DMAC0
*   (RW) _CHIP_IFR1_XINT0
*   (RW) _CHIP_IFR1_INT1
*
\******************************************************************************/
#define _CHIP_IFR1_ADDR     (0x0046u)
#define _CHIP_IFR1          REG16(_CHIP_IFR1_ADDR)
#define _IFR1                _CHIP_IFR1

#define _CHIP_IFR1_GET\
   _REG_GET(CHIP_ADDR(IFR1))

#define _CHIP_IFR1_SET(Val)\
   _REG_SET(CHIP_ADDR(IFR1), Val)

#define _CHIP_IFR1_FGET(Field)\
 _FIELD_GET(CHIP_ADDR(IFR1),_CHIP_IFR1_##Field)

#define _CHIP_IFR1_FSET(Field,Val)\
 _FIELD_SET(CHIP_ADDR(IFR1),_CHIP_IFR1_##Field,Val)
  

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR1_INT5: EXTERNAL USER #5 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR1_INT5_SHIFT            (0x0007u)
#define _CHIP_IFR1_INT5_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IFR1_INT5_SHIFT)
#define _CHIP_IFR1_INT5_MASK             (_CHIP_IFR1_INT5_MK(1))
#define _CHIP_IFR1_INT5_CLR              (~(_CHIP_IFR1_INT5_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR1_TINT1: TIMER #1 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR1_TINT1_SHIFT            (0x0006u)
#define _CHIP_IFR1_TINT1_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IFR1_TINT1_SHIFT)
#define _CHIP_IFR1_TINT1_MASK             (_CHIP_IFR1_TINT1_MK(1))
#define _CHIP_IFR1_TINT1_CLR              (~(_CHIP_IFR1_TINT1_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR1_DMAC3: DMA CHANNEL #3 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR1_DMAC3_SHIFT            (0x0005u)
#define _CHIP_IFR1_DMAC3_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IFR1_DMAC3_SHIFT)
#define _CHIP_IFR1_DMAC3_MASK             (_CHIP_IFR1_DMAC3_MK(1))
#define _CHIP_IFR1_DMAC3_CLR              (~(_CHIP_IFR1_DMAC3_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR1_DMAC2: DMA CHANNEL #2 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR1_DMAC2_SHIFT            (0x0004u)
#define _CHIP_IFR1_DMAC2_MK(n)            (((Uint16)n & 0x0001u) << _CHIP_IFR1_DMAC2_SHIFT)
#define _CHIP_IFR1_DMAC2_MASK             (_CHIP_IFR1_DMAC2_MK(1))
#define _CHIP_IFR1_DMAC2_CLR              (~(_CHIP_IFR1_DMAC2_MASK))


/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR1_INT4: EXTERNAL USER #4 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR1_INT4_SHIFT             (0x0003u)
#define _CHIP_IFR1_INT4_MK(n)             (((Uint16)n & 0x0001u) << _CHIP_IFR1_INT4_SHIFT)
#define _CHIP_IFR1_INT4_MASK              (_CHIP_IFR1_INT4_MK(1))
#define _CHIP_IFR1_INT4_CLR               (~(_CHIP_IFR1_INT4_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR1_DMAC0: DMA CHANNEL #0 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR1_DMAC0_SHIFT             (0x0002u)
#define _CHIP_IFR1_DMAC0_MK(n)             (((Uint16)n & 0x0001u) << _CHIP_IFR1_DMAC0_SHIFT)
#define _CHIP_IFR1_DMAC0_MASK              (_CHIP_IFR1_DMAC0_MK(1))
#define _CHIP_IFR1_DMAC0_CLR               (~(_CHIP_IFR1_DMAC0_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR1_XINT0: SERIAL PORT #0 TRANSMIT INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR1_XINT0_SHIFT             (0x0001u)
#define _CHIP_IFR1_XINT0_MK(n)             (((Uint16)n & 0x0001u) << _CHIP_IFR1_XINT0_SHIFT)
#define _CHIP_IFR1_XINT0_MASK              (_CHIP_IFR1_XINT0_MK(1))
#define _CHIP_IFR1_XINT0_CLR               (~(_CHIP_IFR1_XINT0_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IFR1_INT1: EXTERNAL USER #1 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IFR1_INT1_SHIFT              (0x0000u)
#define _CHIP_IFR1_INT1_MK(n)              (((Uint16)n & 0x0001u) << _CHIP_IFR1_INT1_SHIFT)
#define _CHIP_IFR1_INT1_MASK               (_CHIP_IFR1_INT1_MK(1))
#define _CHIP_IFR1_INT1_CLR                (~(_CHIP_IFR1_INT1_MASK))

#define _CHIP_IFR1_CFG(int5, tint1, dmac3, dmac2, int4, dmac0, xint0, int1)\
  _IFR1 = (Uint16)( _CHIP_IFR1_INT5_MK(int5)   |\
                    _CHIP_IFR1_TINT1_MK(tint1) |\
                    _CHIP_IFR1_DMAC3_MK(dmac3) |\
                    _CHIP_IFR1_DMAC2_MK(dmac2) |\
                    _CHIP_IFR1_INT4_MK(int4)   |\
                    _CHIP_IFR1_DMAC0_MK(dmac0) |\
                    _CHIP_IFR1_XINT0_MK(xint0) |\
                    _CHIP_IFR1_INT1_MK(int1)   \
         )

  

/******************************************************************************\
* _CHIP_IVPD - control status register 2
*
* Fields:
*   (RW) _CHIP_IVPD_IVPD
*
\******************************************************************************/
#define _CHIP_IVPD_ADDR     (0x0049u)
#define _CHIP_IVPD          REG16(_CHIP_IVPD_ADDR)
#define _IVPD                _CHIP_IVPD

#define _CHIP_IVPD_GET\
   _REG_GET(CHIP_ADDR(IVPD))

#define _CHIP_IVPD_SET(Val)\
   _REG_SET(CHIP_ADDR(IVPD), Val)

#define _CHIP_IVPD_FGET(Field)\
 _FIELD_GET(CHIP_ADDR(IVPD),_CHIP_IVPD_##Field)

#define _CHIP_IVPD_FSET(Field,Val)\
 _FIELD_SET(CHIP_ADDR(IVPD),_CHIP_IVPD_##Field,Val)


/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IVPD_IVPD: EXTERNAL USER #1 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IVPD_IVPD_SHIFT              (0x0000u)
#define _CHIP_IVPD_IVPD_MK(n)              (((Uint16)n & 0xFFFFu) << _CHIP_IVPD_IVPD_SHIFT)
#define _CHIP_IVPD_IVPD_MASK               (_CHIP_IVPD_IVPD_MK(0xFFFFu))
#define _CHIP_IVPD_IVPD_CLR                (~(_CHIP_IVPD_IVPD_MASK))

#define _CHIP_IVPD_CFG(ivpd)\
 _REG_SET(CHIP_ADDR(IVPD),ivpd)  
  
/******************************************************************************\
* _CHIP_IVPH - control status register 2
*
* Fields:
*   (RW) _CHIP_IVPH_IVPH
*
\******************************************************************************/
#define _CHIP_IVPH_ADDR     (0x004Au)
#define _CHIP_IVPH          REG16(_CHIP_IVPH_ADDR)
#define _IVPH                _CHIP_IVPH

#define _CHIP_IVPH_GET\
   _REG_GET(CHIP_ADDR(IVPH))

#define _CHIP_IVPH_SET(Val)\
   _REG_SET(CHIP_ADDR(IVPH),Val)

#define _CHIP_IVPH_FGET(Field)\
 _FIELD_GET(CHIP_ADDR(IVPH),_CHIP_IVPH_##Field)

#define _CHIP_IVPH_FSET(Field, Val)\
 _FIELD_SET(CHIP_ADDR(IVPH),_CHIP_IVPH_##Field,Val)


/*----------------------------------------------------------------------------*\
* (RW) _CHIP_IVPH_IVPH: EXTERNAL USER #1 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_IVPH_IVPH_SHIFT              (0x0000u)
#define _CHIP_IVPH_IVPH_MK(n)              (((Uint16)n & 0xFFFFu) << _CHIP_IVPH_IVPH_SHIFT)
#define _CHIP_IVPH_IVPH_MASK               (_CHIP_IVPH_IVPH_MK(0xFFFFu))
#define _CHIP_IVPH_IVPH_CLR                (~(_CHIP_IVPH_IVPH_MASK))

#define _CHIP_IVPH_CFG(ivph)\
 _REG_SET(CHIP_ADDR(IVPH), ivph)  

/******************************************************************************\
* _CHIP_PDP - peripheral data page register
*
* Fields:
*   (RW) _CHIP_PDP_PDP
*
\******************************************************************************/
#define _CHIP_PDP_ADDR     (0x002Fu)
#define _CHIP_PDP          REG16(_CHIP_PDP_ADDR)
#define _PDP                _CHIP_PDP

#define _CHIP_PDP_GET\
   _REG_GET(CHIP_ADDR(PDP))

#define _CHIP_PDP_SET(Val)\
   _REG_SET(CHIP_ADDR(PDP), Val)

#define _CHIP_PDP_FGET(Field)\
 _FIELD_GET(CHIP_ADDR(PDP),_CHIP_PDP_##Field)

#define _CHIP_PDP_FSET(Field,Val)\
 _FIELD_SET(CHIP_ADDR(PDP),_CHIP_PDP_##Field,Val)

/*----------------------------------------------------------------------------*\
* (RW) _CHIP_PDP_PDP: EXTERNAL USER #1 INTERRUPT FLAG
\*----------------------------------------------------------------------------*/ 
#define _CHIP_PDP_PDP_SHIFT              (0x0000u)
#define _CHIP_PDP_PDP_MK(n)              (((Uint16)n & 0x00FFu) << _CHIP_PDP_PDP_SHIFT)
#define _CHIP_PDP_PDP_MASK               (_CHIP_PDP_PDP_MK(0xFF))
#define _CHIP_PDP_PDP_CLR                (~(_CHIP_PDP_PDP_MASK))

#define _CHIP_PDP_CFG(pdp)\
 _REG_SET(CHIP_ADDR(PDP),pdp)  

/******************************************************************************\
* _CHIP_REVID - Revison ID Register
*
\******************************************************************************/
#define _CHIP_REVID_ADDR     (0x3804u)

#define _CHIP_REVID_GET\
  _PREG_GET(CHIP_ADDR(REVID))

#if (CHIP_5502)
/******************************************************************************\
* _CHIP_REVIDL - Revison ID Register
*
\******************************************************************************/
#define _CHIP_REVIDL_ADDR     (0x3804u)

#define _CHIP_REVIDL_GET\
  _PREG_GET(CHIP_ADDR(REVIDL))

/******************************************************************************\
* _CHIP_REVIDH - Revison ID Register
*
\******************************************************************************/
#define _CHIP_REVIDH_ADDR     (0x3805u)

#define _CHIP_REVIDH_GET\
  _PREG_GET(CHIP_ADDR(REVIDH))

/******************************************************************************\
* _CHIP_SUBID - Revison ID Register
*
\******************************************************************************/
#define _CHIP_SUBID_ADDR     (0x3806u)

#define _CHIP_SUBID_GET\
  _PREG_GET(CHIP_ADDR(SUBID))

/******************************************************************************\
* _CHIP_CATID - Catalog Device ID Register
*
\******************************************************************************/
#define _CHIP_CATID_ADDR     (0x3807u)

#define _CHIP_CATID_GET\
  _PREG_GET(CHIP_ADDR(CATID))

#endif


/******************************************************************************\
* The DIEID Register is 64-bit. In order to manipulate it we define:
*             DIEIDH: the high 32 bits
*             DIEIDL: the low 32 bits
*
*
*
* _CHIP_DIEIDH - High 32 bits of DieID register
* _CHIP_DIEIDL - Low 32 bits of the DieID register
*
\******************************************************************************/

#define _CHIP_DIEIDH_ADDR     (0x3800u)
#define _CHIP_DIEIDL_ADDR     (0x3802u)


#define _CHIP_DIEIDL_GET\
  _PREG16_GET(CHIP_ADR(DIEIDL))

#define _CHIP_DIEIDH_GET\
  _PREG16_GET(CHIP_ADR(DIEIDH))

#define _CHIP_DIEID_GET\
  _PREG32_GET(CHIP_ADDR(DIEIDH))

#if (CHIP_5510PG2_0) || (CHIP_5509) || (CHIP_5509A) || (CHIP_5502)
  /******************************************************************************\
  * _CHIP_SYSR - System Control Register
  *
  * Fields:
  *   (RW) _CHIP_SYSR_HPE
  *   (RW) _CHIP_SYSR_BH
  *   (RW) _CHIP_SYSR_HBH
  *   (R)  _CHIP_SYSR_BOOTM3
  *   (RW) _CHIP_SYSR_CLKDIV
  *
  \******************************************************************************/
  #define _CHIP_SYSR_ADDR       (0x07FDu)
  #define _CHIP_SYSR            PREG16(_CHIP_SYSR_ADDR)
  #define _SYSR                 _SYSR

  #define _CHIP_SYSR_GET\
     _REG_GET(CHIP_ADDR(SYSR))

  #define _CHIP_SYSR_SET(Val)\
     _REG_SET(CHIP_ADDR(SYSR), Val)

  #define _CHIP_SYSR_FGET(Field)\
   _FIELD_GET(CHIP_ADDR(SYSR),_CHIP_SYSR_##Field)

  #define _CHIP_SYSR_FSET(Field,Val)\
   _FIELD_SET(CHIP_ADDR(SYSR),_CHIP_SYSR_##Field,Val)


  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_SYSR_HPE: Host Port Internal Pull-up Control Enable
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_SYSR_HPE_SHIFT         (0x0009u)
  #define _CHIP_SYSR_HPE_MK(n)         (((Uint16)n & 0x001u) << _CHIP_SYSR_HPE_SHIFT)
  #define _CHIP_SYSR_HPE_MASK          (_CHIP_SYSR_HPE_MK(0x1))
  #define _CHIP_SYSR_HPE_CLR           (~(_CHIP_SYSR_HPE_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_SYSR_BH: Enable/disable EMIF bus holders
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_SYSR_BH_SHIFT          (0x0008u)
  #define _CHIP_SYSR_BH_MK(n)          (((Uint16)n & 0x001u) << _CHIP_SYSR_BH_SHIFT)
  #define _CHIP_SYSR_BH_MASK           (_CHIP_SYSR_BH_MK(0x1))
  #define _CHIP_SYSR_BH_CLR            (~(_CHIP_SYSR_BH_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_SYSR_HBH: Enable/disable Host Port bus holders
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_SYSR_HBH_SHIFT         (0x0007u)
  #define _CHIP_SYSR_HBH_MK(n)         (((Uint16)n & 0x001u) << _CHIP_SYSR_HBH_SHIFT)
  #define _CHIP_SYSR_HBH_MASK          (_CHIP_SYSR_HBH_MK(0x1))
  #define _CHIP_SYSR_HBH_CLR           (~(_CHIP_SYSR_HBH_MASK))

  /*----------------------------------------------------------------------------*\
  * (R) _CHIP_SYSR_BOOTM3: Boot mode select status
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_SYSR_BOOTM3_SHIFT      (0x0006u)
  #define _CHIP_SYSR_BOOTM3_MK(n)      (((Uint16)n & 0x001u) << _CHIP_SYSR_BOOTM3_SHIFT)
  #define _CHIP_SYSR_BOOTM3_MASK       (_CHIP_SYSR_BOOTM3_MK(0x1))
  #define _CHIP_SYSR_BOOTM3_CLR        (~(_CHIP_SYSR_BOOTM3_MASK))

  /*----------------------------------------------------------------------------*\
  * (R) _CHIP_SYSR_CLKDIV: Clockout divide down factor relative to CPU clock
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_SYSR_CLKDIV_SHIFT      (0x0000u)
  #define _CHIP_SYSR_CLKDIV_MK(n)      (((Uint16)n & 0x007u) << _CHIP_SYSR_CLKDIV_SHIFT)
  #define _CHIP_SYSR_CLKDIV_MASK       (_CHIP_SYSR_CLKDIV_MK(0x7))
  #define _CHIP_SYSR_CLKDIV_CLR        (~(_CHIP_SYSR_CLKDIV_MASK))

  #define _CHIP_SYSR_CFG(hpe, bh, hbh, clkdiv)\
    _SYSR = (Uint16)( _CHIP_SYSR_HPE_MK(hpe)      |\
                      _CHIP_SYSR_BH_MK(bh)        |\
                      _CHIP_SYSR_HBH_MK(hbh)      |\
                      _CHIP_SYSR_CLKDIV_MK(clkdiv) \
           )


  /******************************************************************************\
  * _CHIP_SROM - Secure ROM Register
  *
  * Fields:
  *   (RW) _CHIP_SROM
  *
  \******************************************************************************/
  #define _CHIP_SROM_ADDR       (0x7400u)
  #define _CHIP_SROM             PREG16(_CHIP_SROM_ADDR)
  #define _SROM                 _SROM

  #define _CHIP_SROM_GET\
     _PREG_GET(CHIP_ADDR(SROM))

  #define _CHIP_SROM_SET(Val)\
     _PREG_SET(CHIP_ADDR(SROM), Val)

  #define _CHIP_SROM_FGET(Field)\
    _PFIELD_GET(CHIP_ADDR(SROM),_CHIP_SROM_##Field)

  #define _CHIP_SROM_FSET(Field,Val)\
    _PFIELD_SET(CHIP_ADDR(SROM),_CHIP_SROM_##Field,Val)
 

  /******************************************************************************\
  * _CHIP_XBSR - External Bus Selct Register
  *
  * Fields:
  *   (RW) _CHIP_XBSR_CLKOUT     Enable/disable clkout PG2.0 Only
  *   (RW) _CHIP_XBSR_OSCDIS     OSCDIS Enable/disable PG2.0 Only
  *   (RW) _CHIP_XBSR_EMIFX2     EMIF SDRAM divide-by-2 mode PG2.0 Only
  *   (RW) _CHIP_XBSR_UART       Enable/Disable UART mapping to HPI
  *   (RW) _CHIP_XBSR_CKE        EMIF SDRAM clock/refresh pin select
  *   (RW) _CHIP_XBSR_CKEEN      EMIF SDRAM CKE enable bit
  *   (RW) _CHIP_XBSR_SRCOM      EMIF Self-refresh Command
  *   (RW) _CHIP_XBSR_SP2        Serial Port 2 Mode
  *   (RW) _CHIP_XBSR_SP1        Serial Port 1 Mode
  *   (RW) _CHIP_XBSR_PP         Parallel Port Mode
  *
  \******************************************************************************/
  #define _CHIP_XBSR_ADDR       (0x6C00u)
  #define _CHIP_XBSR             PREG16(_CHIP_XBSR_ADDR)
  #define _XBSR                 _CHIP_XBSR

  #define _CHIP_XBSR_GET\
     _PREG_GET(_CHIP_XBSR_ADDR)

  #define _CHIP_XBSR_SET(Val)\
     _PREG_SET(_CHIP_XBSR_ADDR, Val)

  #define _CHIP_XBSR_FGET(Field)\
   _PFIELD_GET(_CHIP_XBSR_ADDR,_CHIP_XBSR_##Field)

  #define _CHIP_XBSR_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_XBSR_ADDR,_CHIP_XBSR_##Field,Val)

  /*----------------------------------------------------------------------------*\
  * (R) _CHIP_XBSR_CLKOUT: CLKOUT Enable/disable PG2.0 Only
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_CLKOUT_SHIFT      (0x000Fu)
  #define _CHIP_XBSR_CLKOUT_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBSR_CLKOUT_SHIFT)
  #define _CHIP_XBSR_CLKOUT_MASK       (_CHIP_XBSR_CLKOUT_MK(0x1))
  #define _CHIP_XBSR_CLKOUT_CLR        (~(_CHIP_XBSR_CLKOUT_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_XBSR_OSCDIS: OSCDIS Enable/disable PG2.0 Only
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_OSCDIS_SHIFT      (0x000Eu)
  #define _CHIP_XBSR_OSCDIS_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBSR_OSCDIS_SHIFT)
  #define _CHIP_XBSR_OSCDIS_MASK       (_CHIP_XBSR_OSCDIS_MK(0x1))
  #define _CHIP_XBSR_OSCDIS_CLR        (~(_CHIP_XBSR_OSCDIS_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_XBSR_EMIFX2: EMIFX2 Enable/disable PG2.0 Only
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_EMIFX2_SHIFT      (0x000Du)
  #define _CHIP_XBSR_EMIFX2_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBSR_EMIFX2_SHIFT)
  #define _CHIP_XBSR_EMIFX2_MASK       (_CHIP_XBSR_EMIFX2_MK(0x1))
  #define _CHIP_XBSR_EMIFX2_CLR        (~(_CHIP_XBSR_EMIFX2_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_XBSR_CKE: EMIFX2 clock pin select
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_CKE_SHIFT      (0x0008u)
  #define _CHIP_XBSR_CKE_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBSR_CKE_SHIFT)
  #define _CHIP_XBSR_CKE_MASK       (_CHIP_XBSR_CKE_MK(0x1))
  #define _CHIP_XBSR_CKE_CLR        (~(_CHIP_XBSR_CKE_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_XBSR_CKE: EMIFX2 SDRAM clock enable
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_CKEEN_SHIFT      (0x0007u)
  #define _CHIP_XBSR_CKEEN_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBSR_CKEEN_SHIFT)
  #define _CHIP_XBSR_CKEEN_MASK       (_CHIP_XBSR_CKEEN_MK(0x1))
  #define _CHIP_XBSR_CKEEN_CLR        (~(_CHIP_XBSR_CKEEN_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_XBSR_CKE: EMIFX2 SDRAM refresh command
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_SRCOM_SHIFT      (0x0006u)
  #define _CHIP_XBSR_SRCOM_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBSR_SRCOM_SHIFT)
  #define _CHIP_XBSR_SRCOM_MASK       (_CHIP_XBSR_SRCOM_MK(0x1))
  #define _CHIP_XBSR_SRCOM_CLR        (~(_CHIP_XBSR_SRCOM_MASK))


  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_XBSR_SP2: Serial Port #2 Mode Select SP/MMC/MS
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_SP2_SHIFT      (0x0004u)
  #define _CHIP_XBSR_SP2_MK(n)      (((Uint16)n & 0x003u) << _CHIP_XBSR_SP2_SHIFT)
  #define _CHIP_XBSR_SP2_MASK       (_CHIP_XBSR_SP2_MK(0x3))
  #define _CHIP_XBSR_SP2_CLR        (~(_CHIP_XBSR_SP2_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_XBSR_UART: Enable/Disable UART ctrl map to HPI GPIO pins (5502)
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_UART_SHIFT      (0x0003u)
  #define _CHIP_XBSR_UART_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBSR_UART_SHIFT)
  #define _CHIP_XBSR_UART_MASK       (_CHIP_XBSR_UART_MK(0x1))
  #define _CHIP_XBSR_UART_CLR        (~(_CHIP_XBSR_UART_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_XBSR_SP1: Serial Port #1 Mode Select SP/MMC/MS
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_SP1_SHIFT      (0x0002u)
  #define _CHIP_XBSR_SP1_MK(n)      (((Uint16)n & 0x003u) << _CHIP_XBSR_SP1_SHIFT)
  #define _CHIP_XBSR_SP1_MASK       (_CHIP_XBSR_SP1_MK(0x3))
  #define _CHIP_XBSR_SP1_CLR        (~(_CHIP_XBSR_SP1_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_XBSR_PP: Parallel Port Mode Select
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_PP_SHIFT      (0x0000u)
  #define _CHIP_XBSR_PP_MK(n)      (((Uint16)n & 0x003u) << _CHIP_XBSR_PP_SHIFT)
  #define _CHIP_XBSR_PP_MASK       (_CHIP_XBSR_PP_MK(0x3))
  #define _CHIP_XBSR_PP_CLR        (~(_CHIP_XBSR_PP_MASK))

  #define _CHIP_XBSR_CFG(clkout, osc, emifx2, sp2mode,sp1mode,ppmode)\
    _CHIP = (Uint16)( _CHIP_XBSR_CLKOUT_MK(clkout)    |\
                          _CHIP_XBSR_OSCDIS_MK(osc)          |\
                          _CHIP_XBSR_EMIFX2_MK(emifx2)    |\
                          _CHIP_XBSR_SP2_MK(sp2mode)  |\
                          _CHIP_XBSR_SP1_MK(sp1mode)  |\
                          _CHIP_XBSR_PP_MK(ppmode)     \
           )

#endif  //(CHIP_5510PG2_0 || CHIP_5509)

#if (CHIP_5502)
  /******************************************************************************\
  * _CHIP_XBSR - External Bus Selct Register
  *
  * Fields:
  *   (RW) _CHIP_XBSR_SP2MODE    Serial Port 2 Mode
  *   (RW) _CHIP_XBSR_PPMODE     Parallel Port Mode
  *
  \******************************************************************************/
  #define _CHIP_XBSR_ADDR       (0x6C00u)
  #define _CHIP_XBSR             PREG16(_CHIP_XBSR_ADDR)
  #define _XBSR                 _CHIP_XBSR

  #define _CHIP_XBSR_GET\
     _PREG_GET(_CHIP_XBSR_ADDR)

  #define _CHIP_XBSR_SET(Val)\
     _PREG_SET(_CHIP_XBSR_ADDR, Val)

  #define _CHIP_XBSR_FGET(Field)\
   _PFIELD_GET(_CHIP_XBSR_ADDR,_CHIP_XBSR_##Field)

  #define _CHIP_XBSR_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_XBSR_ADDR,_CHIP_XBSR_##Field,Val)

  /*----------------------------------------------------------------------------*\
  * (R) _CHIP_XBSR_PPMODE
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_PPMODE_SHIFT      (0x0000u)
  #define _CHIP_XBSR_PPMODE_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBSR_PPMODE_SHIFT)
  #define _CHIP_XBSR_PPMODE_MASK       (_CHIP_XBSR_PPMODE_MK(0x1))
  #define _CHIP_XBSR_PPMODE_CLR        (~(_CHIP_XBSR_PPMODE_MASK))

  /*----------------------------------------------------------------------------*\
  * (R) _CHIP_XBSR_PPMODE
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBSR_SP2MODE_SHIFT      (0x0002u)
  #define _CHIP_XBSR_SP2MODE_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBSR_SP2MODE_SHIFT)
  #define _CHIP_XBSR_SP2MODE_MASK       (_CHIP_XBSR_SP2MODE_MK(0x1))
  #define _CHIP_XBSR_SP2MODE_CLR        (~(_CHIP_XBSR_SP2MODE_MASK))


  /******************************************************************************\
  * _CHIP_XBCR - External Bus Control Register
  *
  * Fields:
  *   (RW) _CHIP_XBCR_PAH        
  *   (RW) _CHIP_XBCR_PDH 
  *   (RW) _CHIP_XBCR_PCH        
  *   (RW) _CHIP_XBCR_HDH        
  *   (RW) _CHIP_XBCR_HCH        
  \******************************************************************************/
  #define _CHIP_XBCR_ADDR       (0x8800u)
  #define _CHIP_XBCR             PREG16(_CHIP_XBCR_ADDR)
  #define _XBCR                 _CHIP_XBCR

  #define _CHIP_XBCR_GET\
     _PREG_GET(_CHIP_XBCR_ADDR)

  #define _CHIP_XBCR_SET(Val)\
     _PREG_SET(_CHIP_XBCR_ADDR, Val)

  #define _CHIP_XBCR_FGET(Field)\
   _PFIELD_GET(_CHIP_XBCR_ADDR,_CHIP_XBCR_##Field)

  #define _CHIP_XBCR_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_XBCR_ADDR,_CHIP_XBCR_##Field,Val)

  /*----------------------------------------------------------------------------*\
  * (R) _CHIP_XBCR_PAH
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBCR_PAH_SHIFT      (0x0000u)
  #define _CHIP_XBCR_PAH_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBCR_PAH_SHIFT)
  #define _CHIP_XBCR_PAH_MASK       (_CHIP_XBCR_PAH_MK(0x1))
  #define _CHIP_XBCR_PAH_CLR        (~(_CHIP_XBCR_PAH_MASK))

  /*----------------------------------------------------------------------------*\
  * (R) _CHIP_XBCR_PDH
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBCR_PDH_SHIFT      (0x0001u)
  #define _CHIP_XBCR_PDH_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBCR_PDH_SHIFT)
  #define _CHIP_XBCR_PDH_MASK       (_CHIP_XBCR_PDH_MK(0x1))
  #define _CHIP_XBCR_PDH_CLR        (~(_CHIP_XBCR_PDH_MASK))

  /*----------------------------------------------------------------------------*\
  * (R) _CHIP_XBCR_PCH
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBCR_PCH_SHIFT      (0x0002u)
  #define _CHIP_XBCR_PCH_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBCR_PCH_SHIFT)
  #define _CHIP_XBCR_PCH_MASK       (_CHIP_XBCR_PCH_MK(0x1))
  #define _CHIP_XBCR_PCH_CLR        (~(_CHIP_XBCR_PCH_MASK))

  /*----------------------------------------------------------------------------*\
  * (R) _CHIP_XBCR_HDH
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBCR_HDH_SHIFT      (0x0003u)
  #define _CHIP_XBCR_HDH_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBCR_HDH_SHIFT)
  #define _CHIP_XBCR_HDH_MASK       (_CHIP_XBCR_HDH_MK(0x1))
  #define _CHIP_XBCR_HDH_CLR        (~(_CHIP_XBCR_HDH_MASK))

  /*----------------------------------------------------------------------------*\
  * (R) _CHIP_XBCR_HCH
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_XBCR_HCH_SHIFT      (0x0004u)
  #define _CHIP_XBCR_HCH_MK(n)      (((Uint16)n & 0x001u) << _CHIP_XBCR_HCH_SHIFT)
  #define _CHIP_XBCR_HCH_MASK       (_CHIP_XBCR_HCH_MK(0x1))
  #define _CHIP_XBCR_HCH_CLR        (~(_CHIP_XBCR_HCH_MASK))


  /******************************************************************************\
  * _CHIP_TSSR - External Bus Control Register
  *
  * Fields:
  *   (RW) _CHIP_TSSR_NMISEL        
  *   (RW) _CHIP_TSSR_IWCON
  *   (RW) _CHIP_TSSR_TIM0MODE      
  *   (RW) _CHIP_TSSR_TIM1MODE        
  *   (RW) _CHIP_TSSR_TIM2MODE        
  \******************************************************************************/
  #define _CHIP_TSSR_ADDR       (0x8000u)
  #define _CHIP_TSSR             PREG16(_CHIP_TSSR_ADDR)
  #define _TSSR                 _CHIP_TSSR

  #define _CHIP_TSSR_GET\
     _PREG_GET(_CHIP_TSSR_ADDR)

  #define _CHIP_TSSR_SET(Val)\
     _PREG_SET(_CHIP_TSSR_ADDR, Val)

  #define _CHIP_TSSR_FGET(Field)\
   _PFIELD_GET(_CHIP_TSSR_ADDR,_CHIP_TSSR_##Field)

  #define _CHIP_TSSR_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_TSSR_ADDR,_CHIP_TSSR_##Field,Val)

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_TSSR_NMISEL
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_TSSR_NMISEL_SHIFT      (0x0000u)
  #define _CHIP_TSSR_NMISEL_MK(n)      (((Uint16)n & 0x001u) << _CHIP_TSSR_NMISEL_SHIFT)
  #define _CHIP_TSSR_NMISEL_MASK       (_CHIP_TSSR_NMISEL_MK(0x1))
  #define _CHIP_TSSR_NMISEL_CLR        (~(_CHIP_TSSR_NMISEL_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_TSSR_IWCON
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_TSSR_IWCON_SHIFT      (0x0001u)
  #define _CHIP_TSSR_IWCON_MK(n)      (((Uint16)n & 0x003u) << _CHIP_TSSR_IWCON_SHIFT)
  #define _CHIP_TSSR_IWCON_MASK       (_CHIP_TSSR_IWCON_MK(0x3))
  #define _CHIP_TSSR_IWCON_CLR        (~(_CHIP_TSSR_IWCON_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_TSSR_TIM0MODE
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_TSSR_TIM0MODE_SHIFT      (0x0003u)
  #define _CHIP_TSSR_TIM0MODE_MK(n)      (((Uint16)n & 0x001u) << _CHIP_TSSR_TIM0MODE_SHIFT)
  #define _CHIP_TSSR_TIM0MODE_MASK       (_CHIP_TSSR_TIM0MODE_MK(0x1))
  #define _CHIP_TSSR_TIM0MODE_CLR        (~(_CHIP_TSSR_TIM0MODE_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_TSSR_TIM1MODE
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_TSSR_TIM1MODE_SHIFT      (0x0004u)
  #define _CHIP_TSSR_TIM1MODE_MK(n)      (((Uint16)n & 0x001u) << _CHIP_TSSR_TIM1MODE_SHIFT)
  #define _CHIP_TSSR_TIM1MODE_MASK       (_CHIP_TSSR_TIM1MODE_MK(0x1))
  #define _CHIP_TSSR_TIM1MODE_CLR        (~(_CHIP_TSSR_TIM1MODE_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_TSSR_TIM2MODE
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_TSSR_TIM2MODE_SHIFT      (0x0005u)
  #define _CHIP_TSSR_TIM2MODE_MK(n)      (((Uint16)n & 0x001u) << _CHIP_TSSR_TIM2MODE_SHIFT)
  #define _CHIP_TSSR_TIM2MODE_MASK       (_CHIP_TSSR_TIM2MODE_MK(0x1))
  #define _CHIP_TSSR_TIM2MODE_CLR        (~(_CHIP_TSSR_TIM2MODE_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_TSSR_IWCON
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_TSSR_IWCON_SHIFT      (0x0001u)
  #define _CHIP_TSSR_IWCON_MK(n)      (((Uint16)n & 0x003u) << _CHIP_TSSR_IWCON_SHIFT)
  #define _CHIP_TSSR_IWCON_MASK       (_CHIP_TSSR_IWCON_MK(0x3))
  #define _CHIP_TSSR_IWCON_CLR        (~(_CHIP_TSSR_IWCON_MASK))


  /******************************************************************************\
  * _CHIP_CLKOSR - CLKOUT Selection Register
  *
  * Fields:
  *   (RW) _CHIP_CLKOSR_CKODIS        
  *   (RW) _CHIP_CLKOSR_CKOSEL
  \******************************************************************************/
  #define _CHIP_CLKOSR_ADDR       (0x8400u)
  #define _CHIP_CLKOSR             PREG16(_CHIP_CLKOSR_ADDR)
  #define _CLKOSR                 _CHIP_CLKOSR

  #define _CHIP_CLKOSR_GET\
     _PREG_GET(_CHIP_CLKOSR_ADDR)

  #define _CHIP_CLKOSR_SET(Val)\
     _PREG_SET(_CHIP_CLKOSR_ADDR, Val)

  #define _CHIP_CLKOSR_FGET(Field)\
   _PFIELD_GET(_CHIP_CLKOSR_ADDR,_CHIP_CLKOSR_##Field)

  #define _CHIP_CLKOSR_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_CLKOSR_ADDR,_CHIP_CLKOSR_##Field,Val)

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_CLKOSR_CKODIS
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_CLKOSR_CKODIS_SHIFT      (0x0000u)
  #define _CHIP_CLKOSR_CKODIS_MK(n)      (((Uint16)n & 0x001u) << _CHIP_CLKOSR_CKODIS_SHIFT)
  #define _CHIP_CLKOSR_CKODIS_MASK       (_CHIP_CLKOSR_CKODIS_MK(0x1))
  #define _CHIP_CLKOSR_CKODIS_CLR        (~(_CHIP_CLKOSR_CKODIS_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_CLKOSR_CKOSEL
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_CLKOSR_CKOSEL_SHIFT      (0x0000u)
  #define _CHIP_CLKOSR_CKOSEL_MK(n)      (((Uint16)n & 0x001u) << _CHIP_CLKOSR_CKOSEL_SHIFT)
  #define _CHIP_CLKOSR_CKOSEL_MASK       (_CHIP_CLKOSR_CKOSEL_MK(0x1))
  #define _CHIP_CLKOSR_CKOSEL_CLR        (~(_CHIP_CLKOSR_CKOSEL_MASK))

  /******************************************************************************\
  * _CHIP_IOMACRO - IO Macro Register
  *
  * Fields:
  *   (RW) _CHIP_IOMACRO_PA        
  *   (RW) _CHIP_IOMACRO_PD        
  *   (RW) _CHIP_IOMACRO_PC        
  *   (RW) _CHIP_IOMACRO_HD        
  *   (RW) _CHIP_IOMACRO_HC       
  *   (RW) _CHIP_IOMACRO_WDT      
  *   (RW) _CHIP_IOMACRO_JTAG
  \******************************************************************************/
  #define _CHIP_IOMACRO_ADDR       (0x8800u)
  #define _CHIP_IOMACRO             PREG16(_CHIP_IOMACRO_ADDR)
  #define _IOMACRO                 _CHIP_IOMACRO

  #define _CHIP_IOMACRO_GET\
     _PREG_GET(_CHIP_IOMACRO_ADDR)

  #define _CHIP_IOMACRO_SET(Val)\
     _PREG_SET(_CHIP_IOMACRO_ADDR, Val)

  #define _CHIP_IOMACRO_FGET(Field)\
   _PFIELD_GET(_CHIP_IOMACRO_ADDR,_CHIP_IOMACRO_##Field)

  #define _CHIP_IOMACRO_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_IOMACRO_ADDR,_CHIP_IOMACRO_##Field,Val)

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_IOMACRO_PA
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_IOMACRO_PA_SHIFT      (0x0000u)
  #define _CHIP_IOMACRO_PA_MK(n)      (((Uint16)n & 0x001u) << _CHIP_IOMACRO_PA_SHIFT)
  #define _CHIP_IOMACRO_PA_MASK       (_CHIP_IOMACRO_PA_MK(0x1))
  #define _CHIP_IOMACRO_PA_CLR        (~(_CHIP_IOMACRO_PA_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_IOMACRO_PD
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_IOMACRO_PD_SHIFT      (0x0001u)
  #define _CHIP_IOMACRO_PD_MK(n)      (((Uint16)n & 0x001u) << _CHIP_IOMACRO_PD_SHIFT)
  #define _CHIP_IOMACRO_PD_MASK       (_CHIP_IOMACRO_PD_MK(0x1))
  #define _CHIP_IOMACRO_PD_CLR        (~(_CHIP_IOMACRO_PD_MASK))

  /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_IOMACRO_PC
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_IOMACRO_PC_SHIFT      (0x0002u)
  #define _CHIP_IOMACRO_PC_MK(n)      (((Uint16)n & 0x001u) << _CHIP_IOMACRO_PC_SHIFT)
  #define _CHIP_IOMACRO_PC_MASK       (_CHIP_IOMACRO_PC_MK(0x1))
  #define _CHIP_IOMACRO_PC_CLR        (~(_CHIP_IOMACRO_PC_MASK))
  
/*----------------------------------------------------------------------------*\
  * (RW) _CHIP_IOMACRO_HD
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_IOMACRO_HD_SHIFT      (0x0003u)
  #define _CHIP_IOMACRO_HD_MK(n)      (((Uint16)n & 0x001u) << _CHIP_IOMACRO_HD_SHIFT)
  #define _CHIP_IOMACRO_HD_MASK       (_CHIP_IOMACRO_HD_MK(0x1))
  #define _CHIP_IOMACRO_HD_CLR        (~(_CHIP_IOMACRO_HD_MASK))
 
 /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_IOMACRO_HC
  \*----------------------------------------------------------------------------*/ 
  #define _CHIP_IOMACRO_HC_SHIFT      (0x0004u)
  #define _CHIP_IOMACRO_HC_MK(n)      (((Uint16)n & 0x001u) << _CHIP_IOMACRO_HC_SHIFT)
  #define _CHIP_IOMACRO_HC_MASK       (_CHIP_IOMACRO_HC_MK(0x1))
  #define _CHIP_IOMACRO_HC_CLR        (~(_CHIP_IOMACRO_HC_MASK))
 
 /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_IOMACRO_WDT
 \*----------------------------------------------------------------------------*/ 
  #define _CHIP_IOMACRO_WDT_SHIFT      (0x0005u)
  #define _CHIP_IOMACRO_WDT_MK(n)      (((Uint16)n & 0x001u) << _CHIP_IOMACRO_WDT_SHIFT)
  #define _CHIP_IOMACRO_WDT_MASK       (_CHIP_IOMACRO_WDT_MK(0x1))
  #define _CHIP_IOMACRO_WDT_CLR        (~(_CHIP_IOMACRO_WDT_MASK))

 /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_IOMACRO_JTAG
 \*----------------------------------------------------------------------------*/ 
  #define _CHIP_IOMACRO_JTAG_SHIFT      (0x0006u)
  #define _CHIP_IOMACRO_JTAG_MK(n)      (((Uint16)n & 0x001u) << _CHIP_IOMACRO_JTAG_SHIFT)
  #define _CHIP_IOMACRO_JTAG_MASK       (_CHIP_IOMACRO_JTAG_MK(0x1))
  #define _CHIP_IOMACRO_JTAG_CLR        (~(_CHIP_IOMACRO_JTAG_MASK))


 /******************************************************************************\
  * _CHIP_PER1 - External Bus Control Register
  *
  * Fields:
  *   (RW) _CHIP_PER1_INT0        
  *   (RW) _CHIP_PER1_INT1
  \******************************************************************************/
  #define _CHIP_PER1_ADDR       (0x0003u)
  #define _CHIP_PER1             PREG16(_CHIP_PER1_ADDR)
  #define _PER1                 _CHIP_PER1

  #define _CHIP_PER1_GET\
     _PREG_GET(_CHIP_PER1_ADDR)

  #define _CHIP_PER1_SET(Val)\
     _PREG_SET(_CHIP_PER1_ADDR, Val)

  #define _CHIP_PER1_FGET(Field)\
   _PFIELD_GET(_CHIP_PER1_ADDR,_CHIP_PER1_##Field)

  #define _CHIP_PER1_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_PER1_ADDR,_CHIP_PER1_##Field,Val)

 
 /******************************************************************************\
  * _CHIP_PER2 - External Bus Control Register
  *
  * Fields:
  *   (RW) _CHIP_PER2_INTL        
  *   (RW) _CHIP_PER2_INTH
  \******************************************************************************/
  #define _CHIP_PER2_ADDR       (0x0004u)
  #define _CHIP_PER2             PREG16(_CHIP_PER2_ADDR)
  #define _PER2                 _CHIP_PER2

  #define _CHIP_PER2_GET\
     _PREG_GET(_CHIP_PER2_ADDR)

  #define _CHIP_PER2_SET(Val)\
     _PREG_SET(_CHIP_PER2_ADDR, Val)

  #define _CHIP_PER2_FGET(Field)\
   _PFIELD_GET(_CHIP_PER2_ADDR,_CHIP_PER2_##Field)

  #define _CHIP_PER2_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_PER2_ADDR,_CHIP_PER2_##Field,Val)
 
/******************************************************************************\
 * _CHIP_PER3 - External Bus Control Register
 *
 * Fields:
 *   (RW) _CHIP_PER3_INT0        
 *   (RW) _CHIP_PER3_INT1
\******************************************************************************/
  #define _CHIP_PER3_ADDR       (0x0005u)
  #define _CHIP_PER3             PREG16(_CHIP_PER3_ADDR)
  #define _PER3                 _CHIP_PER3

  #define _CHIP_PER3_GET\
     _PREG_GET(_CHIP_PER3_ADDR)

  #define _CHIP_PER3_SET(Val)\
     _PREG_SET(_CHIP_PER3_ADDR, Val)

  #define _CHIP_PER3_FGET(Field)\
   _PFIELD_GET(_CHIP_PER3_ADDR,_CHIP_PER_##Field)

  #define _CHIP_PER3_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_PER3_ADDR,_CHIP_PER_##Field,Val)

/******************************************************************************\
 * _CHIP_PER4 - External Bus Control Register
 *
 * Fields:
 *   (RW) _CHIP_PER4_INT0        
 *   (RW) _CHIP_PER4_INT1
\******************************************************************************/
  #define _CHIP_PER4_ADDR       (0x0006u)
  #define _CHIP_PER4             PREG16(_CHIP_PER4_ADDR)
  #define _PER4                 _CHIP_PER4

  #define _CHIP_PER4_GET\
     _PREG_GET(_CHIP_PER4_ADDR)

  #define _CHIP_PER4_SET(Val)\
     _PREG_SET(_CHIP_PER4_ADDR, Val)

  #define _CHIP_PER4_FGET(Field)\
   _PFIELD_GET(_CHIP_PER4_ADDR,_CHIP_PER_##Field)

  #define _CHIP_PER4_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_PER4_ADDR,_CHIP_PER_##Field,Val)

/******************************************************************************\
 * _CHIP_PER5 - External Bus Control Register
 *
 * Fields:
 *   (RW) _CHIP_PER5_INT0        
 *   (RW) _CHIP_PER5_INT1
\******************************************************************************/
  #define _CHIP_PER5_ADDR       (0x0007u)
  #define _CHIP_PER5             PREG16(_CHIP_PER5_ADDR)
  #define _PER5                 _CHIP_PER5

  #define _CHIP_PER5_GET\
     _PREG_GET(_CHIP_PER5_ADDR)

  #define _CHIP_PER5_SET(Val)\
     _PREG_SET(_CHIP_PER5_ADDR, Val)

  #define _CHIP_PER5_FGET(Field)\
   _PFIELD_GET(_CHIP_PER5_ADDR,_CHIP_PER_##Field)

  #define _CHIP_PER5_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_PER5_ADDR,_CHIP_PER_##Field,Val)

/******************************************************************************\
 * _CHIP_PER6 - External Bus Control Register
 *
 * Fields:
 *   (RW) _CHIP_PER6_INT0        
 *   (RW) _CHIP_PER6_INT1
\******************************************************************************/
  #define _CHIP_PER6_ADDR       (0x0008u)
  #define _CHIP_PER6             PREG16(_CHIP_PER6_ADDR)
  #define _PER6                 _CHIP_PER6

  #define _CHIP_PER6_GET\
     _PREG_GET(_CHIP_PER6_ADDR)

  #define _CHIP_PER6_SET(Val)\
     _PREG_SET(_CHIP_PER6_ADDR, Val)

  #define _CHIP_PER6_FGET(Field)\
   _PFIELD_GET(_CHIP_PER6_ADDR,_CHIP_PER_##Field)

  #define _CHIP_PER6_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_PER6_ADDR,_CHIP_PER_##Field,Val)

/******************************************************************************\
 * _CHIP_PER7 - External Bus Control Register
 *
 * Fields:
 *   (RW) _CHIP_PER7_INT0        
 *   (RW) _CHIP_PER7_INT1
\******************************************************************************/
  #define _CHIP_PER7_ADDR       (0x0009u)
  #define _CHIP_PER7             PREG16(_CHIP_PER7_ADDR)
  #define _PER7                 _CHIP_PER7

  #define _CHIP_PER7_GET\
     _PREG_GET(_CHIP_PER7_ADDR)

  #define _CHIP_PER7_SET(Val)\
     _PREG_SET(_CHIP_PER7_ADDR, Val)

  #define _CHIP_PER7_FGET(Field)\
   _PFIELD_GET(_CHIP_PER7_ADDR,_CHIP_PER_##Field)

  #define _CHIP_PER7_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_PER7_ADDR,_CHIP_PER_##Field,Val)

/******************************************************************************\
 * _CHIP_PER8 - External Bus Control Register
 *
 * Fields:
 *   (RW) _CHIP_PER8_INT0        
 *   (RW) _CHIP_PER8_INT1
\******************************************************************************/
  #define _CHIP_PER8_ADDR       (0x000Au)
  #define _CHIP_PER8             PREG16(_CHIP_PER8_ADDR)
  #define _PER8                 _CHIP_PER8

  #define _CHIP_PER8_GET\
     _PREG_GET(_CHIP_PER8_ADDR)

  #define _CHIP_PER8_SET(Val)\
     _PREG_SET(_CHIP_PER8_ADDR, Val)

  #define _CHIP_PER8_FGET(Field)\
   _PFIELD_GET(_CHIP_PER8_ADDR,_CHIP_PER_##Field)

  #define _CHIP_PER8_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_PER8_ADDR,_CHIP_PER_##Field,Val)

/******************************************************************************\
 * _CHIP_PER9 - External Bus Control Register
 *
 * Fields:
 *   (RW) _CHIP_PER9_INT0        
 *   (RW) _CHIP_PER9_INT1
\******************************************************************************/
  #define _CHIP_PER9_ADDR       (0x000Bu)
  #define _CHIP_PER9             PREG16(_CHIP_PER9_ADDR)
  #define _PER9                 _CHIP_PER9

  #define _CHIP_PER9_GET\
     _PREG_GET(_CHIP_PER9_ADDR)

  #define _CHIP_PER9_SET(Val)\
     _PREG_SET(_CHIP_PER9_ADDR, Val)

  #define _CHIP_PER9_FGET(Field)\
   _PFIELD_GET(_CHIP_PER9_ADDR,_CHIP_PER_##Field)

  #define _CHIP_PER9_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_PER9_ADDR,_CHIP_PER_##Field,Val)


/******************************************************************************\
 * _CHIP_PER10 - External Bus Control Register
 *
 * Fields:
 *   (RW) _CHIP_PER10_INT0        
 *   (RW) _CHIP_PER10_INT1
\******************************************************************************/
  #define _CHIP_PER10_ADDR       (0x000Cu)
  #define _CHIP_PER10             PREG16(_CHIP_PER10_ADDR)
  #define _PER10                 _CHIP_PER10

  #define _CHIP_PER10_GET\
     _PREG_GET(_CHIP_PER10_ADDR)

  #define _CHIP_PER10_SET(Val)\
     _PREG_SET(_CHIP_PER10_ADDR, Val)

  #define _CHIP_PER10_FGET(Field)\
   _PFIELD_GET(_CHIP_PER10_ADDR,_CHIP_PER_##Field)

  #define _CHIP_PER10_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_PER10_ADDR,_CHIP_PER_##Field,Val)

/******************************************************************************\
 * _CHIP_PER11 - External Bus Control Register
 *
 * Fields:
 *   (RW) _CHIP_PER11_INT0        
 *   (RW) _CHIP_PER11_INT1
\******************************************************************************/
  #define _CHIP_PER11_ADDR       (0x000Du)
  #define _CHIP_PER11             PREG16(_CHIP_PER11_ADDR)
  #define _PER11                 _CHIP_PER11

  #define _CHIP_PER11_GET\
     _PREG_GET(_CHIP_PER11_ADDR)

  #define _CHIP_PER11_SET(Val)\
     _PREG_SET(_CHIP_PER11_ADDR, Val)

  #define _CHIP_PER11_FGET(Field)\
   _PFIELD_GET(_CHIP_PER11_ADDR,_CHIP_PER_##Field)

  #define _CHIP_PER11_FSET(Field,Val)\
   _PFIELD_SET(_CHIP_PER11_ADDR,_CHIP_PER_##Field,Val)


 /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_PER_INTL
 \*----------------------------------------------------------------------------*/ 
  #define _CHIP_PER_INTL_SHIFT      (0x0006u)
  #define _CHIP_PER_INTL_MK(n)      (((Uint16)n & 0x001fu) << _CHIP_PER_INTL_SHIFT)
  #define _CHIP_PER_INTL_MASK       (_CHIP_PER_INTL_MK(0x1fu))
  #define _CHIP_PER_INTL_CLR        (~(_CHIP_PER_INTL_MASK))

 /*----------------------------------------------------------------------------*\
  * (RW) _CHIP_PER_INTH
 \*----------------------------------------------------------------------------*/ 
  #define _CHIP_PER_INTH_SHIFT      (0x0008u)
  #define _CHIP_PER_INTH_MK(n)      (((Uint16)n & 0x001fu) << _CHIP_PER_INTH_SHIFT)
  #define _CHIP_PER_INTH_MASK       (_CHIP_PER_INTH_MK(0x1fu))
  #define _CHIP_PER_INTH_CLR        (~(_CHIP_PER_INTH_MASK))



#endif /* CHIP_5502 */
#endif /* _CHIPHAL_H_ */
/******************************************************************************\
* End of CHIPhal.h
\******************************************************************************/

csl_csldat.h/   1051539350  0     0     0       5454      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... CSL - chip support library service layer interface
* FILENAME...... csldata.h
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED: 02/04/2000 
*   LAST MODIFIED: 06/19/2000  incorporate cpluplus compatability
*   MODIFIED: 10 April 2003  updated data structure for .csldata size fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (Global/Static Data Table to Support ROMability of CSL modules)
*
*
*
\******************************************************************************/
#ifndef _CSL_CSLDATA_H_
#define _CSL_CSLDATA_H_

#include <csl_cslhal.h>
#include <csl_datasz.h>

/****************************************\
* CSL scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _CSL_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/*============================================================*/
/*============= Defines ======================================*/
/*============================================================*/
#define CSL_SYSDATAINIT\
   { /* CSL Global System Data Initialization       */\
       (0x00000000ul),            /* Reserved Word                      */\
       (0x00000000ul),            /* CSL Data Ptr                       */\
       (0x00000000ul),            /* Ptr to DSPBIOS Dispatch Table      */\
       (char *)(0x0000u),         /* Char Ptr to CSL Version            */\
       (char *)(0x0000u),         /* Char Ptr to CSL Time/Date Stamp    */\
       (0x0000u),                 /* DSPBIOS present flag               */\
       (0x0000u),                 /* DMA Channel Allocation Mask        */\
       (0x0000u),                 /* DMA Global Regs Alocation Mask     */\
       (0x0000u),                 /* DMA Global Regs Used Mask          */\
       (0x0000u),                 /* Dat Alloc Mask                     */\
       (0x0000u),                 /* CSL DAT Module Open flag           */\
       (0x0000u),                 /* CSL DAT Module Submit Mask         */\
       (0x0000u),                 /* DAT Module Submit Request Priority */\
       (0x0000u),                 /* MCBSP Module Port Allocation Mask  */\
       (0x0000u),                 /* MMC Port Allocation Mask           */\
       (0x0000u),                 /* TIMER Allocation Mask              */\
       (0x0000u),                 /* GPT Timer Allocation Mask          */\
       (0x0000u),                 /* PLL Allocation Mask                */\
       (0x0000u),                 /* UART Allocation Mask               */\
       (0x0000u),                 /* Wdt Allocation Mask                */\
       (0x0000u),                 /* Bct Allocation Mask                */\
       (0x0000u),                 /* Gpio Allocation Masks              */\
       (0x0000u),                 \
       (0x0000u),                 \
       (0x0000u),                 \
       (0x0000u),                 /* Error Count                        */\
       (0x00000000ul) }           /* Error Handler                      */

/*****************************************************************************\
* Macro to declare symbols
\*****************************************************************************/


/*============================================================*/
/*============= Structure Definitions ========================*/
/*============================================================*/
typedef struct {
	Uint32 Reserved;
      Uint32 DataPtr;
      Uint32 DispatchTablePtr;
      char * Version;
      char * DateStamp;
      Uint16 OsPresent;
      Uint16 DmaAllocMask;
      Uint16 DmaGblAllocMask;
      Uint16 DmaGblRegMask;
      Uint16 DatAllocMask;
      Uint16 DatOpenFlag;
      Uint16 DatSubmitMask;
      Uint16 DatChaPriority;
      Uint16 McbspPortAllocMask;
      Uint16 MmcAllocMask;
      Uint16 TimerAllocMask;
      Uint16 GptAllocMask;
      Uint16 PllAllocMask;
      Uint16 UartAllocMask;
      Uint16 WdtAllocMask;
      Uint16 BctAllocMask;
      Uint16 GpioAllocMask[4];
      Uint16 ErrCnt;
      Uint32 ErrFunc;
} CSL_SysDataObj;

/******************************************************************************\
* Table of contents for Global/Static data array
\******************************************************************************/
extern CSL_SysDataObj         CSL_SysData;
#define CSL_SYS_DATA          CSL_SysData


#endif /* _CSL_CSLDATA_H_ */
/******************************************************************************\
* End of csl_csldat.h
\******************************************************************************/

csl_cslhal.h/   1049976833  0     0     0       1309      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... CSLHAL - chip support library HAL interface
* FILENAME...... csl_cslhal.h
* DATE CREATED.. Fri 06/11/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       06/11/1999 Created
*   MODIFIED:      11/13/1999 modified for TMS320C54xx
*   LAST MODIFIED: 04/16/2001 modified FILENAME and header comments
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the CSL library)
*
*
*
\******************************************************************************/
#ifndef _CSLHAL_H_
#define _CSLHAL_H_
#include <csl_std.h>
#include <csl_stdhal.h>
#include <csl_chiphal.h>          
#endif /* _CSLHAL_H_ */
/******************************************************************************\
* End of cslhal.h
\******************************************************************************/


csl_dat.h/      1049976834  0     0     0       4101      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... DAT
* FILENAME...... csl_dat.h
* DATE CREATED.. Thu 11/11/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:        11/11/1999 Created
*   MODIFIED:       07/10/2000 modified for C55xx
*   LAST MODIFIED:  04/16/2001 modified header comments
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the DAT module)
*
*
*
\******************************************************************************/
#ifndef _DAT_H_
#define _DAT_H_

#include <_csl.h>
#include <csl_dma.h>

#if (_DAT_SUPPORT)    

/****************************************\
* DAT scope and inline control macros
\****************************************/

#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _DAT_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/****************************************\
* DAT global macro declarations
\****************************************/
#if (_DMA_SUPPORT)
  #define DAT_CHA_ANY   DMA_CHA_ANY
  #define DAT_CHA0      DMA_CHA0
  #define DAT_CHA1      DMA_CHA1
  #define DAT_CHA2      DMA_CHA2
  #define DAT_CHA3      DMA_CHA3
  #define DAT_CHA4      DMA_CHA4
  #define DAT_CHA5      DMA_CHA5
  #define DAT_PRI_LOW   0
  #define DAT_PRI_HIGH  1

  #define DAT_1D2D      0x00000013
  #define DAT_2D1D      0x00000031
  #define DAT_2D2D      0x00000033

#endif

/* error codes */
#define DAT_ERR_MAJOR            (ERR_BASE_DAT)
#define DAT_ERR_ALLOC            (0x00000000)
#define DAT_ERR_INVALID_HANDLE   (0x00000001)
#define DAT_ERR_NOT_OPEN         (0x00000002)
/* open flags */
#define DAT_OPEN_2D    1

/****************************************\
* DAT global typedef declarations
\****************************************/

/*******************************************\
* DMA global macro definition : ROMABILITY
\*******************************************/  
/* Reserved ROM Area by datdata.h */
 
/* Data definition */
typedef struct {
 Uint16 private;
} *DAT_Handle;


/****************************************\
* DAT global function declarations
\****************************************/
CSLAPI DAT_Handle DAT_open(int ChaNum, int Priority, Uint32 Flags);
CSLAPI void DAT_close(DAT_Handle hDat);
CSLAPI Uint16 DAT_copy(DAT_Handle hDat, DMA_AdrPtr Src , DMA_AdrPtr Dst , Uint16 ElemCnt);
CSLAPI Uint16 DAT_copy2D(DAT_Handle hDat, Uint16 Type, DMA_AdrPtr Src, DMA_AdrPtr Dst, Uint16 LineLen, Uint16 LineCnt, Uint16 LinePitch);
CSLAPI Uint16 DAT_fill(DAT_Handle hDat, DMA_AdrPtr Dst , Uint16 ElemCnt, Uint16 *Value);
CSLAPI void DAT_wait(DAT_Handle hDat);
/****************************************\
* DAT inline function declarations
\****************************************/

/****************************************\
* DAT inline function definitions
\****************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */

#endif /* _DAT_SUPPORT */
#endif /* _DAT_H_ */
/******************************************************************************\
* End of csl_dat.h
\******************************************************************************/

csl_datasz.h/   1049976835  0     0     0       1522      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... all modules.
* FILENAME...... csl_datasz.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:        03/30/2000
*   MODIFIED:       04/16/2001 modified FILENAME and other header comments
*   LAST MODIFIED:  06/27/2001 modified for new CSL initialization model
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the PWR module)
*       Reserved ROM Area for API Data 
*
*
\******************************************************************************/
#include <csl_chipdat.h>
#include <csl_icachdat.h>
#include <csl_irqdat.h>  
#include <csl_datdat.h>
#include <csl_dmadat.h>
#include <csl_emifdat.h>
#include <csl_gpiodat.h>
#include <csl_plldat.h>
#include <csl_mcbspdat.h>
#include <csl_pwrdat.h>
#include <csl_timdat.h>
#include <csl_gptdat.h>
#include <csl_bctdat.h>
#include <csl_errdat.h>
#include <csl_mmcdat.h>
#include <csl_wdtimdat.h>
#include <csl_rtcdat.h>
#include <csl_i2cdat.h>
#include <csl_uartdat.h>



csl_datdat.h/   1049976837  0     0     0       1130      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... DAT
* FILENAME...... csl_datdaa.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       03/30/2000
*   MODIFIED:      04/16/2001 modified FILENAME and header comments
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the DAT module)
*       Reserved Area for DAT Data 
*
*
\******************************************************************************/
#ifndef _DAT_DATA_H_
#define _DAT_DATA_H_

#include <csl_std.h>

#define CSL_DATDATAINIT\
{ 0x0000  /* Reserved */ }

typedef struct {
  Uint16 DatReserved;
} CSL_DatDataObj;

#endif
csl_dma.h/      1074583731  0     0     0       35675     `
/*****************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... DMA
* FILENAME...... csl_dma.h
* DATE CREATED.. Fri 06/11/1999
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... SL - Service Layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/11/1999 Created
*   MODIFIED: 03/27/2001 Modified to support 5510PG2.0
*   MODIFIED: 04/16/2001 updated header comments
*   MODIFIED: 05/11/2001 updated for DMA_getConfig()
*   MODIFIED: 06/27/2001 updated for new CSL initialization model
*   MODIFIED: 01/09/2001 fixed problem with 5509 and 5510 PG2.0 support
*   MODIFIED: 01/25/2002 fixed typo FRAMIE ==> FRAMEIE
*   MODIFIED: 04/04/2002 Made misc changes to symbolic values
*   MODIFIED: 05/07/2002 Added DMA_Private typedef for C++ type checking
*   MODIFIED: 06/10/2003 Fixed the problem with DMA_stop and DMA_start
*                          to read DMACSR to clear all pending interrupts
*   MODIFIED: 06/19/2003 Added GTCR register
*   MODIFIED: 07/31/2003 Modified the type of DMA_Config variables,
*                         dmacfi and dmacei to 16 bit signed integers.
*   MODIFIED: 10/06/2003 Added dummy check in DMA_start() and DMA_stop()
*                         to avoid C++ compiler warnings.
*   MODIFIED: 01/08/2004 Added WP field to DMACCR register(5502)                       
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the DMA module)
*
*
*
\******************************************************************************/
#ifndef _DMA_H_
#define _DMA_H_

#include <_csl.h>
#include <csl_dmahal.h>

#if (_DMA_SUPPORT)

/****************************************\
* DMA scope and inline control macros
\****************************************/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _DMA_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/****************************************\
* DMA global macro declarations
\****************************************/
#define DMA_CHA_CNT        (_DMA_CHA_CNT)


/* DMA_Open() flags */
#define DMA_OPEN_RESET     (0x00000001)

/* error codes */
#define DMA_ERR_MAJOR            (ERR_BASE_DMA)
#define DMA_ERR_ALLOC            (0x00000000)
#define DMA_ERR_INVALID_HANDLE   (0x00000001)
#define DMA_ERR_GLOBAL_ALLOC     (0x00000002)

/* channel identifiers for DMA_Open() */
#define DMA_CHA_ANY  (-1)
#define DMA_CHA0    (0)
#define DMA_CHA1    (1)
#define DMA_CHA2    (2)
#define DMA_CHA3    (3)
#define DMA_CHA4    (4)
#define DMA_CHA5    (5)

/* define a debuging assertion macro for validating channel handles */
#ifdef _MCRTE_DEBUG
  #define DMA_ASSERT_HANDLE(hDma,RetExp) \
    if (hDma == INV) { \
      ERR_submit(DMA_ERR_MAJOR, DMA_ERR_INVALID_HANDLE); \
      RetExp; \
    } 
#else
  #define DMA_ASSERT_HANDLE(hDma,RetExp) 
#endif                                

/* For TMS320C55xx devices, the following macros set the DMAGCR register */


#define SET_ALLOCATED(h,val)  CSL_SYS_DATA.DmaAllocMask = (CSL_SYS_DATA.DmaAllocMask & (~(1u<<((DMA_PrivateObj*)(h)->ChaNum)))\
                              | ((val & 1u)<<((DMA_PrivateObj*)(h)->ChaNum))

#define GET_ALLOCATED(h)  CSL_SYS_DATA.DmaAllocMask| (1u<<(((DMA_PrivateObj*)(h)->ChaNum)));
#define GET_EVENTID(h)   (((DMA_PrivateObj*)(h))->EventId)
#define GET_CHANUM(h)    (((DMA_PrivateObj*)(h))->ChaNum) 
 
/* For TMS320C5510 PG2 devices, the following macros set the DMAGSCR register */
#define DMA_setCompmode(value)  ((DMA_FSET(DMAGSCR,COMPMODE,value))

/*-----------------------------------------------------------------------*/
/* The following macros are used to construct peripheral register        */
/* values based on symbolic constants. They will be useful to initialize */
/* the DMA_Config structure in a readable way.                           */
/*-----------------------------------------------------------------------*/

/*============================================================================*\
* DMA DMAGCR	   - Global Control Register Macros
*
* Fields:
*  (RW) FREE
*  (RW) EHPIEXCL
*  (RW) EHPIPRIO
\*============================================================================*/

/* default register value */
#define DMA_DMAGCR_DEFAULT                     (0x0000u)


/*---------------------------------------*\
* DMA_DMAGCR_MK Macros
\*---------------------------------------*/

#define DMA_DMAGCR_RMK(free, excl, prio)((Uint16)(\
    DMA_FMK(DMAGCR,FREE,free) |\
    DMA_FMK(DMAGCR,EHPIEXCL,excl) |\
    DMA_FMK(DMAGCR,EHPIPRIO,prio)\
  )\
)  

#define DMA_DMAGCR_RMKS(free_sym, excl_sym, prio_sym)((Uint16)(\
    DMA_FMKS(DMAGCR,FREE,free_sym) |\
    DMA_FMKS(DMAGCR,EHPIEXCL,ecxl_sym) |\
    DMA_FMKS(DMAGCR,EHPIPRIO,prio_sym)\
  )\
)  

/* field values */

#define DMA_DMAGCR_EHPIPRIO_HI                (0x0001u)
#define DMA_DMAGCR_EHPIPRIO_LOW               (0x0000u)
#define DMA_DMAGCR_EHPIPRIO_DEFAULT           DMA_DMAGCR_EHPIPRIO_LOW

#define DMA_DMAGCR_EHPIEXCL_ON                (0x0001u)
#define DMA_DMAGCR_EHPIEXCL_OFF               (0x0000u)
#define DMA_DMAGCR_EHPIEXCL_DEFAULT           DMA_DMAGCR_EHPIEXCL_OFF

#define DMA_DMAGCR_FREE_ON                    (0x0001u)
#define DMA_DMAGCR_FREE_OFF                   (0x0000u)
#define DMA_DMAGCR_FREE_DEFAULT               DMA_DMAGCR_FREE_OFF             

#if (_DMA_DST_AND_SRC_INDEX_SUPPORT)
  /*---------------------------------------*\
  * DMA_DMAGSCR_MK Macros 
  \*---------------------------------------*/

  #define DMA_DMAGSCR_RMK(mode)((Uint16)\
      DMA_FMK(DMAGSCR,COMPMODE,mode))  

  #define DMA_DMAGSCR_RMKS(mode_sym, excl_sym, prio_sym)((Uint16)\
      DMA_FMKS(DMAGSCR,COMPMODE,mode_sym)) 


  /* field values */

  #define DMA_DMAGSCR_DEFAULT                (0x0000u)
  #define DMA_DMAGSCR_COMPMODE_ON            (0x0000u)
  #define DMA_DMAGSCR_COMPMODE_OFF           (0x0001u)
  #define DMA_DMAGSCR_COMPMODE_DEFAULT       DMA_DMAGSCR_COMPMODE_ON
#endif

/*============================================================================*\
* DMA DMAGTCR	   - Global Timeout Control Register Macros
*
* Fields:
* #if (CHIP_5502)
*  (RW) PTE
*  (RW) ETE
*  (RW) ITE1
*  (RW) ITE0
* #else
*  (RW) DTCE
*  (RW) STCE
\*============================================================================*/

/* default register value */
	
#if (_DMA_DST_AND_SRC_INDEX_SUPPORT)

  #define DMA_DMAGTCR_DEFAULT                  (0x0000u)

/*---------------------------------------*\
* DMA_DMAGTCR_MK Macros
\*---------------------------------------*/
  #if (CHIP_5502)	
    #define DMA_DMAGTCR_RMK(pte, ete, ite1, ite0)((Uint16)(\
        DMA_FMK(DMAGTCR,PTE,pte) |\
        DMA_FMK(DMAGTCR,ETE,ete) |\
        DMA_FMK(DMAGTCR,ITE1,ite1) |\
        DMA_FMK(DMAGTCR,ITE0,ite0)\
      )\
    )

    #define DMA_DMAGTCR_RMKS(pte_sym, ete_sym, ite1_sym, ite0_sym)((Uint16)(\
        DMA_FMKS(DMAGTCR,PTE,pte_sym) |\
        DMA_FMKS(DMAGTCR,ETE,ete_sym) |\
        DMA_FMKS(DMAGTCR,ITE1,ite1_sym) |\
        DMA_FMKS(DMAGTCR,ITE0,ite0_sym)\
      )\
    )  
    
    /* field values */
    
    #define DMA_DMAGTCR_ITE0_HI                   (0x0001u)
    #define DMA_DMAGTCR_ITE0_LOW                  (0x0000u)
    #define DMA_DMAGTCR_ITE0_DEFAULT              DMA_DMAGTCR_ITE0_LOW
    
    #define DMA_DMAGTCR_ITE1_HI                   (0x0001u)
    #define DMA_DMAGTCR_ITE1_LOW                  (0x0000u)
    #define DMA_DMAGTCR_ITE1_DEFAULT              DMA_DMAGTCR_ITE1_LOW
    
    #define DMA_DMAGTCR_ETE_HI                   (0x0001u)
    #define DMA_DMAGTCR_ETE_LOW                  (0x0000u)
    #define DMA_DMAGTCR_ETE_DEFAULT              DMA_DMAGTCR_ETE_LOW
    
    #define DMA_DMAGTCR_PTE_HI                   (0x0001u)
    #define DMA_DMAGTCR_PTE_LOW                  (0x0000u)
    #define DMA_DMAGTCR_PTE_DEFAULT              DMA_DMAGTCR_PTE_LOW
  #else
     #define DMA_DMAGTCR_RMK(dtce, stce)((Uint16)(\
        DMA_FMK(DMAGTCR,DTCE,dtce) |\
        DMA_FMK(DMAGTCR,STCE,stce)\
      )\
    )  
    
    #define DMA_DMAGTCR_RMKS(dtce_sym, stce_sym)((Uint16)(\
        DMA_FMKS(DMAGTCR,DTCE,dtce_sym) |\
        DMA_FMKS(DMAGTCR,STCE,stce_sym)\
      )\
    )  
    
    /* field values */
    
    #define DMA_DMAGTCR_STCE_HI                   (0x0001u)
    #define DMA_DMAGTCR_STCE_LOW                  (0x0000u)
    #define DMA_DMAGTCR_STCE_DEFAULT              DMA_DMAGTCR_STCE_LOW
    
    #define DMA_DMAGTCR_DTCE_HI                   (0x0001u)
    #define DMA_DMAGTCR_DTCE_LOW                  (0x0000u)
    #define DMA_DMAGTCR_DTCE_DEFAULT              DMA_DMAGTCR_DTCE_LOW 
  #endif  

#endif

/*============================================================================*\
* DMA DMACSDPn	   - Channel #n Source Destination Parameters Register Macros
*
* Fields:
*  (RW) DSTBEN
*  (RW) DSTPACK
*  (RW) DST
*  (RW) SRCBEN
*  (RW) SRCPACK
*  (RW) SRC
*  (RW) DATATYPE
\*============================================================================*/

/* Default register value */
#define DMA_DMACSDP_DEFAULT                      (0x0000u)


/*---------------------------------------*\
* DMA_DMACSDP_MK Macros
\*---------------------------------------*/


#define DMA_DMACSDP_RMK(dstben, dstpack, dst, srcben, srcpack, src, datatype)((Uint16)(\
    DMA_FMK(DMACSDP,DSTBEN,dstben)|\
    DMA_FMK(DMACSDP,DSTPACK,dstpack)|\
    DMA_FMK(DMACSDP,DST,dst)|\
    DMA_FMK(DMACSDP,SRCBEN,srcben)|\
    DMA_FMK(DMACSDP,SRCPACK,srcpack)|\
    DMA_FMK(DMACSDP,SRC,src)|\
    DMA_FMK(DMACSDP,DATATYPE,datatype)\
  )\
)

#define DMA_DMACSDP_RMKS(dstben_sym, dstpack_sym, dst_sym, srcben_sym,\
   srcpack_sym, src_sym, datatype_sym)((Uint16)(\
    DMA_FMKS(DMACSDP,DSTBEN,dstben_sym)|\
    DMA_FMKS(DMACSDP,DSTPACK,dstpack_sym)|\
    DMA_FMKS(DMACSDP,DST,dst_sym)|\
    DMA_FMKS(DMACSDP,SRCBEN,srcben_sym)|\
    DMA_FMKS(DMACSDP,SRCPACK,srcpack_sym)|\
    DMA_FMKS(DMACSDP,SRC,src_sym)|\
    DMA_FMKS(DMACSDP,DATATYPE,datatype_sym)\
  )\
)


/* field values */


 #define DMA_DMACSDP_DATATYPE_8BIT                (0x0000u)
 #define DMA_DMACSDP_DATATYPE_16BIT               (0x0001u)
 #define DMA_DMACSDP_DATATYPE_32BIT               (0x0002u)
 #define DMA_DMACSDP_DATATYPE_DEFAULT             DMA_DMACSDP_DATATYPE_8BIT                

#if (CHIP_5502)
 #define DMA_DMACSDP_SRC_DARAMPORT0               (0x0000u)
 #define DMA_DMACSDP_SRC_DARAMPORT1               (0x0001u)
#else  
 #define DMA_DMACSDP_SRC_SARAM                    (0x0000u)
 #define DMA_DMACSDP_SRC_DARAM                    (0x0001u)
#endif
   
 #define DMA_DMACSDP_SRC_EMIF                     (0x0002u)
 #define DMA_DMACSDP_SRC_PERIPH                   (0x0003u)

#if (CHIP_5502)   
 #define DMA_DMACSDP_SRC_DEFAULT                  DMA_DMACSDP_SRC_DARAMPORT0
#else
 #define DMA_DMACSDP_SRC_DEFAULT                  DMA_DMACSDP_SRC_SARAM
#endif   

 #define DMA_DMACSDP_SRCPACK_ON                   (0x0001u)
 #define DMA_DMACSDP_SRCPACK_OFF                  (0x0000u)
 #define DMA_DMACSDP_SRCPACK_DEFAULT              DMA_DMACSDP_SRCPACK_OFF

 #define DMA_DMACSDP_SRCBEN_NOBURST               (0x0000u)
 #define DMA_DMACSDP_SRCBEN_BURST4                (0x0002u)
 #define DMA_DMACSDP_SRCBEN_DEFAULT               DMA_DMACSDP_SRCBEN_NOBURST

#if (CHIP_5502)
 #define DMA_DMACSDP_DST_DARAMPORT0               (0x0000u)
 #define DMA_DMACSDP_DST_DARAMPORT1               (0x0001u)
#else  
 #define DMA_DMACSDP_DST_SARAM                    (0x0000u)
 #define DMA_DMACSDP_DST_DARAM                    (0x0001u)
#endif
   
 #define DMA_DMACSDP_DST_EMIF                     (0x0002u)
 #define DMA_DMACSDP_DST_PERIPH                   (0x0003u)

#if (CHIP_5502)
 #define DMA_DMACSDP_DST_DEFAULT                  DMA_DMACSDP_DST_DARAMPORT0
#else   
 #define DMA_DMACSDP_DST_DEFAULT                  DMA_DMACSDP_DST_SARAM
#endif

 #define DMA_DMACSDP_DSTPACK_ON                   (0x0001u)
 #define DMA_DMACSDP_DSTPACK_OFF                  (0x0000u)
 #define DMA_DMACSDP_DSTPACK_DEFAULT              DMA_DMACSDP_DSTPACK_OFF                  

 #define DMA_DMACSDP_DSTBEN_NOBURST               (0x0000u)
 #define DMA_DMACSDP_DSTBEN_BURST4                (0x0002u)
 #define DMA_DMACSDP_DSTBEN_DEFAULT               DMA_DMACSDP_DSTBEN_NOBURST

/*============================================================================*\
* DMA DMACCRn	   - Channel #n Channel Control Register Macros
*
* Fields:
*  (RW) DSTAMODE
*  (RW) SRCAMODE
*  (RW) ENDPROG
*  (RW) WP
*  (RW) REPEAT
*  (RW) AUTOINIT
*  (RW) EN
*  (RW) PRIO
*  (RW) FS
*  (RW) SYNC
\*============================================================================*/

/* default register value */
#define DMA_DMACCR_DEFAULT                     (0x0000u)


/*---------------------------------------*\
* DMA_DMACCR_MK Macro
\*---------------------------------------*/
#if (CHIP_5502)
   
 #define DMA_DMACCR_RMK(dstamode, srcamode, endprog, wp, repeat, autoinit,\
                     en, prio, fs, sync)((Uint16)(\
    DMA_FMK(DMACCR,DSTAMODE,dstamode)|\
    DMA_FMK(DMACCR,SRCAMODE,srcamode)|\
    DMA_FMK(DMACCR,ENDPROG,endprog)|\
    DMA_FMK(DMACCR,WP,wp)|\
    DMA_FMK(DMACCR,REPEAT,repeat)|\
    DMA_FMK(DMACCR,AUTOINIT,autoinit)|\
    DMA_FMK(DMACCR,EN,en)|\
    DMA_FMK(DMACCR,PRIO,prio)|\
    DMA_FMK(DMACCR,FS,fs)|\
    DMA_FMK(DMACCR,SYNC,sync)\
    )\
  )  

 #define DMA_DMACCR_RMKS(dstamode_sym, srcamode_sym, endprog_sym, wp_sym, \
    repeat_sym, autoinit_sym, en_sym, prio_sym, fs_sym, sync_sym)((Uint16)(\
    DMA_FMKS(DMACCR,DSTAMODE,dstamode_sym)|\
    DMA_FMKS(DMACCR,SRCAMODE,srcamode_sym)|\
    DMA_FMKS(DMACCR,ENDPROG,endprog_sym)|\
    DMA_FMKS(DMACCR,WP,wp_sym)|\
    DMA_FMKS(DMACCR,REPEAT,repeat_sym)|\
    DMA_FMKS(DMACCR,AUTOINIT,autoinit_sym)|\
    DMA_FMKS(DMACCR,EN,en_sym)|\
    DMA_FMKS(DMACCR,PRIO,prio_sym)|\
    DMA_FMKS(DMACCR,FS,fs_sym)|\
    DMA_FMKS(DMACCR,SYNC,sync_sym)\
    )\
  )  

#else
 #define DMA_DMACCR_RMK(dstamode, srcamode, endprog, repeat, autoinit,\
                     en, prio, fs, sync)((Uint16)(\
    DMA_FMK(DMACCR,DSTAMODE,dstamode)|\
    DMA_FMK(DMACCR,SRCAMODE,srcamode)|\
    DMA_FMK(DMACCR,ENDPROG,endprog)|\
    DMA_FMK(DMACCR,REPEAT,repeat)|\
    DMA_FMK(DMACCR,AUTOINIT,autoinit)|\
    DMA_FMK(DMACCR,EN,en)|\
    DMA_FMK(DMACCR,PRIO,prio)|\
    DMA_FMK(DMACCR,FS,fs)|\
    DMA_FMK(DMACCR,SYNC,sync)\
    )\
  )  

 #define DMA_DMACCR_RMKS(dstamode_sym, srcamode_sym, endprog_sym, \
    repeat_sym, autoinit_sym, en_sym, prio_sym, fs_sym, sync_sym)((Uint16)(\
    DMA_FMKS(DMACCR,DSTAMODE,dstamode_sym)|\
    DMA_FMKS(DMACCR,SRCAMODE,srcamode_sym)|\
    DMA_FMKS(DMACCR,ENDPROG,endprog_sym)|\
    DMA_FMKS(DMACCR,REPEAT,repeat_sym)|\
    DMA_FMKS(DMACCR,AUTOINIT,autoinit_sym)|\
    DMA_FMKS(DMACCR,EN,en_sym)|\
    DMA_FMKS(DMACCR,PRIO,prio_sym)|\
    DMA_FMKS(DMACCR,FS,fs_sym)|\
    DMA_FMKS(DMACCR,SYNC,sync_sym)\
    )\
  )  
  
#endif  /* (CHIP_5502)*/  

/* field values */

#define DMA_DMACCR_SYNC_NONE                     (0x0000u)
#define DMA_DMACCR_SYNC_REVT0                    (0x0001u)
#define DMA_DMACCR_SYNC_XEVT0                    (0x0002u)                    
#define DMA_DMACCR_SYNC_REVTA0                   (0x0003u) 
#define DMA_DMACCR_SYNC_XEVTA0                   (0x0004u) 
#define DMA_DMACCR_SYNC_REVT1                    (0x0005u)
#define DMA_DMACCR_SYNC_XEVT1                    (0x0006u)
#define DMA_DMACCR_SYNC_REVTA1                   (0x0007u)
#define DMA_DMACCR_SYNC_XEVTA1                   (0x0008u)
#define DMA_DMACCR_SYNC_REVT2                    (0x0009u)
#define DMA_DMACCR_SYNC_XEVT2                    (0x000Au)
#define DMA_DMACCR_SYNC_REVTA2                   (0x000Bu)
#define DMA_DMACCR_SYNC_XEVTA2                   (0x000Cu)
#define DMA_DMACCR_SYNC_TIM1INT                  (0x000Du)
#define DMA_DMACCR_SYNC_TIM2INT                  (0x000Eu)
#define DMA_DMACCR_SYNC_EXTINT0                  (0x000Fu)
#define DMA_DMACCR_SYNC_EXTINT1                  (0x0010u)
#define DMA_DMACCR_SYNC_EXTINT2                  (0x0011u)
#define DMA_DMACCR_SYNC_EXTINT3                  (0x0012u)
#define DMA_DMACCR_SYNC_EXTINT4                  (0x0013u)
#define DMA_DMACCR_SYNC_EXTINT5                  (0x0014u) 
#define DMA_DMACCR_SYNC_DEFAULT                  DMA_DMACCR_SYNC_NONE
                       
#define DMA_DMACCR_FS_ENABLE                     (0x0001u)
#define DMA_DMACCR_FS_DISABLE                    (0x0000u)
#define DMA_DMACCR_FS_ELEMENT                    (0x0000u)
#define DMA_DMACCR_FS_FRAME                      (0x0001u)
#define DMA_DMACCR_FS_DEFAULT                    DMA_DMACCR_FS_DISABLE

#define DMA_DMACCR_PRIO_HI                       (0x0001u)
#define DMA_DMACCR_PRIO_LOW                      (0x0000u)
#define DMA_DMACCR_PRIO_DEFAULT			 DMA_DMACCR_PRIO_LOW
                      
#define DMA_DMACCR_EN_START                      (0x0001u)
#define DMA_DMACCR_EN_STOP                       (0x0000u)
#define DMA_DMACCR_EN_DEFAULT                    DMA_DMACCR_EN_STOP                  

#define DMA_DMACCR_AUTOINIT_ON                   (0x0001u)
#define DMA_DMACCR_AUTOINIT_OFF                  (0x0000u)
#define DMA_DMACCR_AUTOINIT_DEFAULT              DMA_DMACCR_AUTOINIT_OFF

#define DMA_DMACCR_REPEAT_ON                     (0x0001u)
#define DMA_DMACCR_REPEAT_ALWAYS                 (0x0001u)
#define DMA_DMACCR_REPEAT_ENDPROG1               (0x0000u)
#define DMA_DMACCR_REPEAT_OFF                    (0x0000u)
#define DMA_DMACCR_REPEAT_DEFAULT                DMA_DMACCR_REPEAT_OFF                    

#define DMA_DMACCR_ENDPROG_ON                    (0x0001u)
#define DMA_DMACCR_ENDPROG_OFF                   (0x0000u)
#define DMA_DMACCR_ENDPROG_DEFAULT               DMA_DMACCR_ENDPROG_OFF

#if (CHIP_5502)
  #define DMA_DMACCR_WP_ENABLE                   (0x0001u)
  #define DMA_DMACCR_WP_DISABLE                  (0x0000u)
  #define DMA_DMACCR_WP_DEFAULT                  DMA_DMACCR_WP_DISABLE
#endif
    
    
#define DMA_DMACCR_SRCAMODE_CONST                (0x0000u)
#define DMA_DMACCR_SRCAMODE_POSTINC              (0x0001u)
#define DMA_DMACCR_SRCAMODE_SGLINDX              (0x0002u)
#define DMA_DMACCR_SRCAMODE_DBLINDX              (0x0003u)
#define DMA_DMACCR_SRCAMODE_DEFAULT              DMA_DMACCR_SRCAMODE_CONST

#define DMA_DMACCR_DSTAMODE_CONST                (0x0000u)
#define DMA_DMACCR_DSTAMODE_POSTINC              (0x0001u)
#define DMA_DMACCR_DSTAMODE_SGLINDX              (0x0002u)
#define DMA_DMACCR_DSTAMODE_DBLINDX              (0x0003u)
#define DMA_DMACCR_DSTAMODE_DEFAULT              DMA_DMACCR_DSTAMODE_CONST

#define DMA_DMACCR_SYNC_OF(x)                    ((Uint16)(x))

/*========================================================================*\
* DMA DMACICRn	   - Channel #n Channel Interrupt Control Register Macros
*
* Fields:
*  (RW) BLOCKIE
*  (RW) LASTIE
*  (RW) FRAMEIE
*  (RW) HALFIE
*  (RW) DROPIE
*  (RW) TIMEOUTIE
\*========================================================================*/

/* register value */
#define DMA_DMACICR_DEFAULT                      (0x0003u)

/*---------------------------------------*\
* DMA_DMACICR_MK Macros
\*---------------------------------------*/
  

#define DMA_DMACICR_RMK(blockie, lastie, frameie, halfie, dropie, timeoutie)((Uint16)(\
    DMA_FMK(DMACICR,BLOCKIE, blockie)|\
    DMA_FMK(DMACICR,LASTIE, lastie)|\
    DMA_FMK(DMACICR,FRAMEIE, frameie)|\
    DMA_FMK(DMACICR,HALFIE, halfie)|\
    DMA_FMK(DMACICR,DROPIE, dropie)|\
    DMA_FMK(DMACICR,TIMEOUTIE, timeoutie)\
 )\
)

#define DMA_DMACICR_RMKS(blockie_sym, lastie_sym, frameie_sym, halfie_sym,\
  dropie_sym, timeoutie_sym)((Uint16)(\
    DMA_FMKS(DMACICR,BLOCKIE, blockie_sym)|\
    DMA_FMKS(DMACICR,LASTIE, lastie_sym)|\
    DMA_FMKS(DMACICR,FRAMEIE, frameie_sym)|\
    DMA_FMKS(DMACICR,HALFIE, halfie_sym)|\
    DMA_FMKS(DMACICR,DROPIE, dropie_sym)|\
    DMA_FMKS(DMACICR,TIMEOUTIE, timeoutie_sym)\
 )\
)

/* field values */


 #define DMA_DMACICR_TIMEOUTIE_ON                 (0x0001u)
 #define DMA_DMACICR_TIMEOUTIE_OFF                (0x0000u)
 #define DMA_DMACICR_TIMEOUTIE_DEFAULT            DMA_DMACICR_TIMEOUTIE_ON

 #define DMA_DMACICR_DROPIE_ON                    (0x0001u)
 #define DMA_DMACICR_DROPIE_OFF                   (0x0000u)
 #define DMA_DMACICR_DROPIE_DEFAULT               DMA_DMACICR_DROPIE_ON

 #define DMA_DMACICR_HALFIE_ON               (0x0001u)
 #define DMA_DMACICR_HALFIE_OFF              (0x0000u)
 #define DMA_DMACICR_HALFIE_DEFAULT          DMA_DMACICR_HALFIE_OFF

 #define DMA_DMACICR_FIRSTHALFIE_ON               (0x0001u)
 #define DMA_DMACICR_FIRSTHALFIE_OFF              (0x0000u)
 #define DMA_DMACICR_FIRSTHALFIE_DEFAULT          DMA_DMACICR_HALFIE_OFF

 #define DMA_DMACICR_FRAMEIE_ON                   (0x0001u)
 #define DMA_DMACICR_FRAMEIE_OFF                  (0x0000u)
 #define DMA_DMACICR_FRAMEIE_DEFAULT               DMA_DMACICR_FRAMEIE_OFF

 #define DMA_DMACICR_LASTIE_ON                    (0x0001u)
 #define DMA_DMACICR_LASTIE_OFF                   (0x0000u)
 #define DMA_DMACICR_LASTIE_DEFAULT               DMA_DMACICR_LASTIE_OFF                   

 #define DMA_DMACICR_BLOCKIE_ON                   (0x0001u)
 #define DMA_DMACICR_BLOCKIE_OFF                  (0x0000u)
 #define DMA_DMACICR_BLOCKIE_DEFAULT              DMA_DMACICR_BLOCKIE_OFF



/*========================================================================*\
* DMA DMACSRn	   - Channel #n Channel Status Register Macros
*
* Fields:
*  (R) SYNC
*  (R) BLOCK
*  (R) LAST
*  (R) FRAME
*  (R) HALF
*  (R) DROP
*  (R) TIMEOUT
\*========================================================================*/

/*---------------------------------------*\
* DMA_DMACSR_MK Macros
\*---------------------------------------*/ 
#define DMA_DMACSR_SYNC_TRUE      (0x1u)
#define DMA_DMACSR_SYNC_FALSE     (0x0u)
#define DMA_DMACSR_SYNC_DEFAULT   DMA_DMACSR_SYNC_FALSE

#define DMA_DMACSR_BLOCK_TRUE     (0x1u)
#define DMA_DMACSR_BLOCK_FALSE    (0x0u)
#define DMA_DMACSR_BLOCK_DEFAULT  DMA_DMACSR_BLOCK_FALSE

#define DMA_DMACSR_LAST_TRUE      (0x1u)
#define DMA_DMACSR_LAST_FALSE     (0x0u)
#define DMA_DMACSR_LAST_DEFAULT   DMA_DMACSR_LAST_FALSE

#define DMA_DMACSR_FRAME_TRUE     (0x1u)
#define DMA_DMACSR_FRAME_FALSE    (0x0u)
#define DMA_DMACSR_FRAME_DEFAULT  DMA_DMACSR_FRAME_FALSE

#define DMA_DMACSR_HALF_TRUE     (0x1u)
#define DMA_DMACSR_HALF_FALSE    (0x0u)
#define DMA_DMACSR_HALF_DEFAULT  DMA_DMACSR_HALF_FALSE

#define DMA_DMACSR_DROP_TRUE     (0x1u)
#define DMA_DMACSR_DROP_FALSE    (0x0u)
#define DMA_DMACSR_DROP_DEFAULT  DMA_DMACSR_DROP_FALSE

#define DMA_DMACSR_TIMEOUT_TRUE     (0x1u)
#define DMA_DMACSR_TIMEOUT_FALSE    (0x0u)
#define DMA_DMACSR_TIMEOUT_DEFAULT  DMA_DMACSR_TIMEOUT_FALSE


/* Register only Readable */
#define DMA_DMACSR_RMK(sync,block,last,frame,half,drop,timeout)(\
(Uint16) (DMA_FMK(DMACSR,SYNC,sync)   |\
          DMA_FMK(DMACSR,BLOCK,block) |\
          DMA_FMK(DMACSR,LAST,last)   |\
          DMA_FMK(DMACSR,FRAME,frame) |\
          DMA_FMK(DMACSR,HALF,half)   |\
          DMA_FMK(DMACSR,DROP,drop)   |\
          DMA_FMK(DMACSR,TIMEOUT,timeout) )\
)

#define DMA_DMACSR_RMKS(sync,block,last,frame,half,drop,timeout)(\
(Uint16) (DMA_FMKS(DMACSR,SYNC,sync)   |\
          DMA_FMKS(DMACSR,BLOCK,block) |\
          DMA_FMKS(DMACSR,LAST,last)   |\
          DMA_FMKS(DMACSR,FRAME,frame) |\
          DMA_FMKS(DMACSR,HALF,half)   |\
          DMA_FMKS(DMACSR,DROP,drop)   |\
          DMA_FMKS(DMACSR,TIMEOUT,timeout) )\
)



/*========================================================================*\
* HDMA_DMACSSALn	   - Channel #n Channel Source Start Address (lower 16 bits)
*
* Fields:
*  (RW) SSAL       
\*========================================================================*/

/* default register value */
#define DMA_DMACSSAL_DEFAULT                      (0x0000u)
#define DMA_DMACSSAL_SSAL_OF(x)                   ((Uint16)(x))


/*---------------------------------------*\
* DMA_DMACSSAL_MK Macro
\*---------------------------------------*/ 

#define DMA_DMACSSAL_RMK(ssal) ((Uint16)(\
    DMA_FMK(DMACSSAL,SSAL,ssal)\
  )\
) 

/*============================================================================*\
*  DMA DMACSSAUn	   - Channel #n Channel Source Start Address (lower 16 bits)
*
* Fields:
*  (RW) SSAU       
\*============================================================================*/


/* default register value */
#define DMA_DMACSSAU_DEFAULT                      (0x0000u)
#define DMA_DMACSSAU_SSAU_OF(x)                   ((Uint16)(x))


/*---------------------------------------*\
* DMA_DMACSSAU_MK Macro
\*---------------------------------------*/ 

#define DMA_DMACSSAU_RMK(ssau) ((Uint16)(\
    DMA_FMK(DMACSSAU,SSAU,ssau)\
  )\
) 

/*============================================================================*\
*  DMA DMACDSALn	   - Channel #n Channel Source Start Address (lower 16 bits)
*
* Fields:
*  (RW) DSAL       
\*============================================================================*/

/* default register value */
#define DMA_DMACDSAL_DEFAULT                      (0x0000u)
#define DMA_DMACDSAL_DSAL_OF(x)                   ((Uint16)(x))


/*---------------------------------------*\
* DMA_DMACDSAL_MK Macro
\*---------------------------------------*/ 

#define DMA_DMACDSAL_RMK(dsal) ((Uint16)(\
    DMA_FMK(DMACDSAL,DSAL,dsal)\
  )\
)


/*============================================================================*\
*  DMA DMACDSAUn	   - Channel #n Channel Source Start Address (lower 16 bits)
*
* Fields:
*  (RW) DSAU       
\*============================================================================*/

/* default register value */
#define DMA_DMACDSAU_DEFAULT                      (0x0000u)
#define DMA_DMACDSAU_DSAU_OF(x)                   ((Uint16)(x))

/*---------------------------------------*\
* DMA_DMACDSAU_MK Macro
\*---------------------------------------*/ 

#define DMA_DMACDSAU_RMK(dsau) ((Uint16)(\
    DMA_FMK(DMACDSAU,DSAU,dsau)\
  )\
) 

/*========================================================================*\
*  DMA DMACENn	   - Channel #n Channel Element Number Register
*
* Fields:
*  (RW) ELEMENTNUM       
\*========================================================================*/

/* default register value */
#define DMA_DMACEN_DEFAULT                      (0x0000u)
#define DMA_DMACEN_ELEMENTNUM_OF(x)             ((Uint16)(x))


/*---------------------------------------*\
* DMA_DMACEN_MK Macro
\*---------------------------------------*/ 

#define DMA_DMACEN_RMK(elementnum) ((Uint16)(\
    DMA_FMK(DMACEN,ELEMENTNUM,elementnum)\
  )\
) 

/*========================================================================*\
* HDMA_DMACFNn	   - Channel #n Channel Frame Number Register
*
* Fields:
*  (RW) FRAMENUM      
\*========================================================================*/

/* default register value */
#define DMA_DMACFN_DEFAULT                      (0x0000u)
#define DMA_DMACFN_FRAMENUM_OF(x)               ((Uint16)(x))


/*---------------------------------------*\
* DMA_DMACFN_MK Macro
\*---------------------------------------*/ 

#define DMA_DMACFN_RMK(framenum) ((Uint16)(\
    DMA_FMK(DMACFN,FRAMENUM,framenum)\
  )\
)


/*========================================================================*\
* DMA DMACFIn	   - Channel #n Channel Frame Index Register Macros
*
* Fields:
*  (RW) FRAMENDX      
\*========================================================================*/

/* default register value */
#define DMA_DMACFI_DEFAULT                      (0x0000u)
#define DMA_DMACFI_FRAMENDX_OF(x)               ((Uint16)(x))


/*---------------------------------------*\
* DMA_DMACFI_MK Macro
\*---------------------------------------*/ 

#define DMA_DMACFI_RMK(framendx) ((Uint16)(\
    DMA_FMK(DMACFI,FRAMENDX,framendx)\
  )\
) 


/*========================================================================*\
*  DMA DMACEIn	   - Channel #n Channel Element Index Register Macros
*
* Fields:
*  (RW) ELEMENTNDX      
\*========================================================================*/

/* default register value */
#define DMA_DMACEI_DEFAULT                      (0x0000u)
#define DMA_DMACEI_ELEMENTNDX_OF(x)             ((Uint16)(x))


/*---------------------------------------*\
* DMA_DMACEI_MK Macro
\*---------------------------------------*/


#define DMA_DMACEI_RMK(elementndx) ((Uint16)(\
    DMA_FMK(DMACEI,ELEMENTNDX,elementndx)\
  )\
) 

#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  /*========================================================================*\
   * DMA DMACDFIn	   - Channel #n Destination Frame Index Register Macros
   *
   * Fields:
   *  (RW) FRAMENDX      
  \*========================================================================*/

  /* default register value */
  #define DMA_DMACDFI_DEFAULT                      (0x0000u)
  #define DMA_DMACDFI_FRAMENDX_OF(x)               ((Uint16)(x))


  /*---------------------------------------*\
   * DMA_DMACDFI_MK Macro 
  \*---------------------------------------*/ 

  #define DMA_DMACDFI_RMK(framendx) ((Uint16)(\
      DMA_FMK(DMACDFI,FRAMENDX,framendx)\
    )\
  ) 


  /*========================================================================*\
   *  DMA DMACDEIn	   - Channel #n Destination Element Index Register Macros
   *
   * Fields:
   *  (RW) ELEMENTNDX      
  \*========================================================================*/

  /* default register value */
  #define DMA_DMACDEI_DEFAULT                      (0x0000u)
  #define DMA_DMACDEI_ELEMENTNDX_OF(x)             ((Uint16)(x))


  /*---------------------------------------*\
  * DMA_DMACDEI_MK Macro
  \*---------------------------------------*/ 


  #define DMA_DMACDEI_RMK(elementndx) ((Uint16)(\
      DMA_FMK(DMACDEI,ELEMENTNDX,elementndx)\
    )\
  )

  /*========================================================================*\
  * DMA DMACSFIn	   - Channel #n Source Frame Index Register Macros
  *
  * Fields:
  *  (RW) FRAMENDX      
  \*========================================================================*/

  /* default register value */
  #define DMA_DMACSFI_DEFAULT                      (0x0000u)
  #define DMA_DMACSFI_FRAMENDX_OF(x)               ((Uint16)(x))


  /*---------------------------------------*\
  * DMA_DMACDFI_MK Macro
  \*---------------------------------------*/ 

  #define DMA_DMACSFI_RMK(framendx) ((Uint16)(\
      DMA_FMK(DMACSFI,FRAMENDX,framendx)\
    )\
  )


  /*========================================================================*\
  *  DMA DMACSEIn	   - Channel #n Source Element Index Register Macros
  *
  * Fields:
  *  (RW) ELEMENTNDX      
  \*========================================================================*/

  /* default register value */
  #define DMA_DMACSEI_DEFAULT                      (0x0000u)
  #define DMA_DMACSEI_ELEMENTNDX_OF(x)             ((Uint16)(x))


  /*---------------------------------------*\
  * DMA_DMACSEI_MK Macro
  \*---------------------------------------*/ 

 
  #define DMA_DMACSEI_RMK(elementndx) ((Uint16)(\
      DMA_FMK(DMACSEI,ELEMENTNDX,elementndx)\
    )\
  ) 
#endif

/****************************************\
* DMA global typedef declarations
\****************************************/

typedef void (*DMA_AdrPtr)();

/* channel handle type */
typedef struct {
  Uint32 Private;
} DMA_Private, *DMA_Handle;

/* channel configuration structure */
typedef struct {
  Uint16 dmacsdp;
  Uint16 dmaccr;
  Uint16 dmacicr;
  DMA_AdrPtr dmacssal;
  Uint16 dmacssau;
  DMA_AdrPtr dmacdsal;
  Uint16 dmacdsau;
  Uint16 dmacen;
  Uint16 dmacfn;
#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  Int16 dmacsfi;
  Int16 dmacsei;
  Int16 dmacdfi;
  Int16 dmacdei;
#else
  Int16 dmacfi;
  Int16 dmacei;
#endif
} DMA_Config;


/*******************************************\
* DMA global macro definition : ROMABILITY
\*******************************************/  
/* Reserved ROM Area by dmadata.h */
 
/* Data definition */
 
#define DMA_hCha0  ((DMA_Handle)(&(CSL_DMA_DATA.DmaChan[0])))
#define DMA_hCha1  ((DMA_Handle)(&(CSL_DMA_DATA.DmaChan[1])))
#define DMA_hCha2  ((DMA_Handle)(&(CSL_DMA_DATA.DmaChan[2])))
#define DMA_hCha3  ((DMA_Handle)(&(CSL_DMA_DATA.DmaChan[3])))
#define DMA_hCha4  ((DMA_Handle)(&(CSL_DMA_DATA.DmaChan[4])))
#define DMA_hCha5  ((DMA_Handle)(&(CSL_DMA_DATA.DmaChan[5])))
#define DMA_hCha(n)((DMA_Handle)(&(CSL_DMA_DATA.DmaChan[n])))





#define DMA_getEventId(hDma) (\
     (Uint16)(((DMA_PrivateObj*)hDma)->EventId))


#define DMA_pause(hDma)           DMA_FSETH(hDma,DMACCR,EN,0)


/****************************************\
* DMA global function declarations
\****************************************/
CSLAPI void DMA_init();
CSLAPI void DMA_reset(DMA_Handle hDma);

CSLAPI DMA_Handle DMA_open(int ChaNum, Uint32 Flags);
CSLAPI void DMA_close(DMA_Handle hDma);

CSLAPI void DMA_config(DMA_Handle hDma, DMA_Config *Config);
CSLAPI void DMA_getConfig(DMA_Handle hDma, DMA_Config *Config);


#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  CSLAPI void DMA_configArgs(DMA_Handle hDma, Uint16 dmacsdp, Uint16 dmaccr, Uint16 dmacicr, 
    DMA_AdrPtr dmacssal, Uint16 dmacssau, DMA_AdrPtr dmacdsal, Uint16 dmacdsau, Uint16 dmacen,
    Uint16 dmacfn, Int16 dmacsfi, Int16 dmacsei, Int16 dmacdfi, Int16 dmacdei);
#else
  CSLAPI void DMA_configArgs(DMA_Handle hDma, Uint16 dmacsdp, Uint16 dmaccr,
    Uint16 dmacicr, DMA_AdrPtr dmacssal, Uint16 dmacssau, DMA_AdrPtr dmacdsal, Uint16 dmacdsau,
    Uint16 dmacen, Uint16 dmacfn, Int16 dmacfi, Int16 dmacei);
#endif


/* Prototypes for Static Inline Functions */
static inline void DMA_stop(DMA_Handle hDma);
static inline void DMA_start(DMA_Handle hDma);

/* Definitions for static inline functions */

static inline void DMA_start(DMA_Handle hDma) {
          if(DMA_RGETH(hDma,DMACSR))  {
           	;   /* Dummy check to avoid C++ compiler warning */
	  }
	  DMA_FSETH(hDma,DMACCR,EN,1);
}

static inline void DMA_stop(DMA_Handle hDma) {
          DMA_FSETH(hDma,DMACCR,EN,0);
          if(DMA_RGETH(hDma,DMACSR)){
	       ;    /* Dummy check to avoid C++ compiler warning */
          }
}

#endif /* DMA_SUPPORT */
#endif /* _DMA_H_ */
/******************************************************************************\
* End of dma.h
\******************************************************************************/


csl_dmadat.h/   1056113509  0     0     0       2112      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... DMA
* FILENAME...... csl_dmadat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   MODIFIED:  03/27/2001 Modified to support 5510 PG2.0
*   MODIFIED:  04/16/2001 modified header comments
*   MODIFIED:  01/22/2002 modified for 5510 PG2.0 support and fix
*                         for 5509 support
*   MODIFIED:  06/19/2003 added GTCR
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the DMA module)
*       Reserved Area for DMA Data 
*
*
\******************************************************************************/
#ifndef _DMA_DAT_H_
#define _DMA_DAT_H_

#if (_DMA_DST_AND_SRC_INDEX_SUPPORT)
   #include <csl_dmadatB.h>
#else
   #include <csl_dmadatA.h>
#endif

/* private object, not to be used by application code */
typedef struct {
  Uint16 EventId;
  Uint16 DmaChaNum;
  Uint16 DmaGcrAddr;
#if (_DMA_DST_AND_SRC_INDEX_SUPPORT)
  Uint16 DmaGtcrAddr;
  Uint16 DmaGscrAddr;
#endif
  Uint16 DmaCsdpAddr;
  Uint16 DmaCcrAddr;
  Uint16 DmaCicrAddr;
  Uint16 DmaCsrAddr;
  Uint16 DmaCssalAddr;
  Uint16 DmaCssauAddr;
  Uint16 DmaCdsalAddr;
  Uint16 DmaCdsauAddr;
  Uint16 DmaCenAddr;
  Uint16 DmaCfnAddr;
#if (_DMA_DST_AND_SRC_INDEX_SUPPORT)
  Uint16 DmaCsfiAddr;
  Uint16 DmaCseiAddr;
  Uint16 DmaCdfiAddr;
  Uint16 DmaCdeiAddr;
  Uint16 DmaCsacAddr;
  Uint16 DmaCdacAddr;
#else
  Uint16 DmaCfiAddr;
  Uint16 DmaCeiAddr;
#endif
} DMA_PrivateObj;

typedef struct {
  DMA_PrivateObj DmaChan[6];
} CSL_DmaDataObj;

extern CSL_DmaDataObj CSL_DmaData;

#define CSL_DMA_DATA  CSL_DmaData

#endif
csl_dmadatA.h/  1049976841  0     0     0       4919      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... DMA
* FILENAME...... csl_dmadatA.h
* DATE CREATED.. Wed 06/27/2001 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*  CREATED:    06/27/2001 For new CSL Initialization model
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the DMA module)
*       Reserved Area for DMA Data 
*
*
\******************************************************************************/
#ifndef _DMA_DATA_H_
#define _DMA_DATA_H_

#define CSL_DMADATAINIT\
{  /* DMA Channel 0 Handle Initialization Data */\
    0x0012u,      /*DMA0_EventId*/\
    0x0000u,      /*DMA0_DmaChaNum*/\
    0x0E00u,      /*DMA0_DmaGcrAddr*/\
    0x0C00u,      /*DMA0_DmaCsdpAddr*/\
    0x0C01u,      /*DMA0_DmaCcrAddr*/\
    0x0C02u,      /*DMA0_DmaCicrAddr*/\
    0x0C03u,      /*DMA0_DmaCsrAddr*/\
    0x0C04u,      /*DMA0_DmaCssalAddr*/\
    0x0C05u,      /*DMA0_DmaCssauAddr*/\
    0x0C06u,      /*DMA0_DmaCdsalAddr*/\
    0x0C07u,      /*DMA0_DmaCdsauAddr*/\
    0x0C08u,      /*DMA0_DmaCenAddr*/\
    0x0C09u,      /*DMA0_DmaCfnAddr*/\
    0x0C0Au,      /*DMA0_DmaCfiAddr*/\
    0x0C0Bu,      /*DMA0_DmaCeiAddr*/\
   /* DMA Channel #1 Handle Initialization Data*/\
    0x0009u,      /*DMA1_EventId*/\
    0x0001u,      /*DMA1_DmaChaNum*/\
    0x0E00u,      /*DMA1_DmaGcrAddr*/\
    0x0C20u,      /*DMA1_DmaCsdpAddr*/\
    0x0C21u,      /*DMA1_DmaCcrAddr*/\
    0x0C22u,      /*DMA1_DmaCicrAddr*/\
    0x0C23u,      /*DMA1_DmaCsrAddr*/\
    0x0C24u,      /*DMA1_DmaCssalAddr*/\
    0x0C25u,      /*DMA1_DmaCssauAddr*/\
    0x0C26u,      /*DMA1_DmaCdsalAddr*/\
    0x0C27u,      /*DMA1_DmaCdsauAddr*/\
    0x0C28u,      /*DMA1_DmaCenAddr*/\
    0x0C29u,      /*DMA1_DmaCfnAddr*/\
    0x0C2Au,      /*DMA1_DmaCfiAddr*/\
    0x0C2Bu,      /*DMA1_DmaCeiAddr*/\
   /* DMA Channel #2 Handle Initialization Data*/\
    0x0014u,      /*DMA2_EventId*/\
    0x0002u,      /*DMA2_DmaChaNum*/\
    0x0E00u,      /*DMA2_DmaGcrAddr*/\
    0x0C40u,      /*DMA2_DmaCsdpAddr*/\
    0x0C41u,      /*DMA2_DmaCcrAddr*/\
    0x0C42u,      /*DMA2_DmaCicrAddr*/\
    0x0C43u,      /*DMA2_DmaCsrAddr*/\
    0x0C44u,      /*DMA2_DmaCssalAddr*/\
    0x0C45u,      /*DMA2_DmaCssauAddr*/\
    0x0C46u,      /*DMA2_DmaCdsalAddr*/\
    0x0C47u,      /*DMA2_DmaCdsauAddr*/\
    0x0C48u,      /*DMA2_DmaCenAddr*/\
    0x0C49u,      /*DMA2_DmaCfnAddr*/\
    0x0C4Au,      /*DMA2_DmaCfiAddr*/\
    0x0C4Bu,      /*DMA2_DmaCeiAddr*/\
   /* DMA Channel #3 Handle Initialization Data*/\
    0x0015u,      /*DMA3_EventId*/\
    0x0003u,      /*DMA3_DmaChaNum*/\
    0x0E00u,      /*DMA3_DmaGcrAddr*/\
    0x0C60u,      /*DMA3_DmaCsdpAddr*/\
    0x0C61u,      /*DMA3_DmaCcrAddr*/\
    0x0C62u,      /*DMA3_DmaCicrAddr*/\
    0x0C63u,      /*DMA3_DmaCsrAddr*/\
    0x0C64u,      /*DMA3_DmaCssalAddr*/\
    0x0C65u,      /*DMA3_DmaCssauAddr*/\
    0x0C66u,      /*DMA3_DmaCdsalAddr*/\
    0x0C67u,      /*DMA3_DmaCdsauAddr*/\
    0x0C68u,      /*DMA3_DmaCenAddr*/\
    0x0C69u,      /*DMA3_DmaCfnAddr*/\
    0x0C6Au,      /*DMA3_DmaCfiAddr*/\
    0x0C6Bu,      /*DMA3_DmaCeiAddr*/\
   /* DMA Channel #4 Handle Initialization Data*/\
    0x000Eu,      /*DMA4_EventId*/\
    0x0004u,      /*DMA4_DmaChaNum*/\
    0x0E00u,      /*DMA4_DmaGcrAddr*/\
    0x0C80u,      /*DMA4_DmaCsdpAddr*/\
    0x0C81u,      /*DMA4_DmaCcrAddr*/\
    0x0C82u,      /*DMA4_DmaCicrAddr*/\
    0x0C83u,      /*DMA4_DmaCsrAddr*/\
    0x0C84u,      /*DMA4_DmaCssalAddr*/\
    0x0C85u,      /*DMA4_DmaCssauAddr*/\
    0x0C86u,      /*DMA4_DmaCdsalAddr*/\
    0x0C87u,      /*DMA4_DmaCdsauAddr*/\
    0x0C88u,      /*DMA4_DmaCenAddr*/\
    0x0C89u,      /*DMA4_DmaCfnAddr*/\
    0x0C8Au,      /*DMA4_DmaCfiAddr*/\
    0x0C8Bu,      /*DMA4_DmaCeiAddr*/\
   /* DMA Channel#5 Handle Initialization Data*/\
    0x000Fu,      /*DMA5_EventId*/\
    0x0005u,      /*DMA5_DmaChaNum*/\
    0x0E00u,      /*DMA5_DmaGcrAddr*/\
    0x0CA0u,      /*DMA5_DmaCsdpAddr*/\
    0x0CA1u,      /*DMA5_DmaCcrAddr*/\
    0x0CA2u,      /*DMA5_DmaCicrAddr*/\
    0x0CA3u,      /*DMA5_DmaCsrAddr*/\
    0x0CA4u,      /*DMA5_DmaCssalAddr*/\
    0x0CA5u,      /*DMA5_DmaCssauAddr*/\
    0x0CA6u,      /*DMA5_DmaCdsalAddr*/\
    0x0CA7u,      /*DMA5_DmaCdsauAddr*/\
    0x0CA8u,      /*DMA5_DmaCenAddr*/\
    0x0CA9u,      /*DMA5_DmaCfnAddr*/\
    0x0CAAu,      /*DMA5_DmaCfiAddr*/\
    0x0CABu       /*DMA5_DmaCeiAddr*/\
}
#endif

csl_dmadatB.h/  1056113550  0     0     0       12744     `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... DMA
* FILENAME...... csl_dmadatB.h
* DATE CREATED.. Wed 06/27/2001 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*  CREATED:    06/27/2001 For new CSL Initialization model
*   MODIFIED:  06/19/2003 added GTCR
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the DMA module)
*       Reserved Area for DMA Data 
*
*
\******************************************************************************/
#ifndef _DMA_DATB_H_
#define _DMA_DATB_H_

#if (CHIP_5502)
   #define CSL_DMADATAINIT\
   {  /*DMA Channel 0 Handle Initialization Data*/\
       0x0012u,      /*DMA0_EventId*/\
       0x0000u,      /*DMA0_DmaChaNum*/\
       0x0E00u,      /*DMA0_DmaGcrAddr*/\
       0x0E01u,      /*DMA0_DmaGtcrAddr*/\
       0x0E02u,      /*DMA0_DmaGscrAddr*/\
       0x0C00u,      /*DMA0_DmaCsdpAddr*/\
       0x0C01u,      /*DMA0_DmaCcrAddr*/\
       0x0C02u,      /*DMA0_DmaCicrAddr*/\
       0x0C03u,      /*DMA0_DmaCsrAddr*/\
       0x0C04u,      /*DMA0_DmaCssalAddr*/\
       0x0C05u,      /*DMA0_DmaCssauAddr*/\
       0x0C06u,      /*DMA0_DmaCdsalAddr*/\
       0x0C07u,      /*DMA0_DmaCdsauAddr*/\
       0x0C08u,      /*DMA0_DmaCenAddr*/\
       0x0C09u,      /*DMA0_DmaCfnAddr*/\
       0x0C0Au,      /*DMA0_DmaCsfiAddr*/\
       0x0C0Bu,      /*DMA0_DmaCseiAddr*/\
       0x0C0Fu,      /*DMA0_DmaCdfiAddr*/\
       0x0C0Eu,      /*DMA0_DmaCdeiAddr*/\
       0x0C0Cu,      /*DMA0_DmaCsacAddr*/\
       0x0C0Du,      /*DMA0_DmaCdacAddr*/\
      /* DMA Channel #1 Handle Initialization Data*/\
       0x0009u,      /*DMA1_EventId*/\
       0x0001u,      /*DMA1_DmaChaNum*/\
       0x0E00u,      /*DMA1_DmaGcrAddr*/\
       0x0E01u,      /*DMA1_DmaGtcrAddr*/\
       0x0E02u,      /*DMA1_DmaGscrAddr*/\
       0x0C20u,      /*DMA1_DmaCsdpAddr*/\
       0x0C21u,      /*DMA1_DmaCcrAddr*/\
       0x0C22u,      /*DMA1_DmaCicrAddr*/\
       0x0C23u,      /*DMA1_DmaCsrAddr*/\
       0x0C24u,      /*DMA1_DmaCssalAddr*/\
       0x0C25u,      /*DMA1_DmaCssauAddr*/\
       0x0C26u,      /*DMA1_DmaCdsalAddr*/\
       0x0C27u,      /*DMA1_DmaCdsauAddr*/\
       0x0C28u,      /*DMA1_DmaCenAddr*/\
       0x0C29u,      /*DMA1_DmaCfnAddr*/\
       0x0C2Au,      /*DMA1_DmaCsfiAddr*/\
       0x0C2Bu,      /*DMA1_DmaCseiAddr*/\
       0x0C2Fu,      /*DMA1_DmaCdfiAddr*/\
       0x0C2Eu,      /*DMA1_DmaCdeiAddr*/\
       0x0C2Cu,      /*DMA1_DmaCsacAddr*/\
       0x0C2Du,      /*DMA1_DmaCdacAddr*/\
      /* DMA Channel #2 Handle Initialization Data*/\
       0x0014u,      /*DMA2_EventId*/\
       0x0002u,      /*DMA2_DmaChaNum*/\
       0x0E00u,      /*DMA2_DmaGcrAddr*/\
       0x0E01u,      /*DMA2_DmaGtcrAddr*/\
       0x0E02u,      /*DMA2_DmaGscrAddr*/\
       0x0C40u,      /*DMA2_DmaCsdpAddr*/\
       0x0C41u,      /*DMA2_DmaCcrAddr*/\
       0x0C42u,      /*DMA2_DmaCicrAddr*/\
       0x0C43u,      /*DMA2_DmaCsrAddr*/\
       0x0C44u,      /*DMA2_DmaCssalAddr*/\
       0x0C45u,      /*DMA2_DmaCssauAddr*/\
       0x0C46u,      /*DMA2_DmaCdsalAddr*/\
       0x0C47u,      /*DMA2_DmaCdsauAddr*/\
       0x0C48u,      /*DMA2_DmaCenAddr*/\
       0x0C49u,      /*DMA2_DmaCfnAddr*/\
       0x0C4Au,      /*DMA2_DmaCsfiAddr*/\
       0x0C4Bu,      /*DMA2_DmaCseiAddr*/\
       0x0C4Fu,      /*DMA2_DmaCdfiAddr*/\
       0x0C4Eu,      /*DMA2_DmaCdeiAddr*/\
       0x0C4Cu,      /*DMA2_DmaCsacAddr*/\
       0x0C4Du,      /*DMA2_DmaCdacAddr*/\
      /* DMA Channel #3 Handle Initialization Data*/\
       0x0015u,      /*DMA3_EventId*/\
       0x0003u,      /*DMA3_DmaChaNum*/\
       0x0E00u,      /*DMA3_DmaGcrAddr*/\
       0x0E01u,      /*DMA3_DmaGtcrAddr*/\
       0x0E02u,      /*DMA_DmaGscrAddr*/\
       0x0C60u,      /*DMA3_DmaCsdpAddr*/\
       0x0C61u,      /*DMA3_DmaCcrAddr*/\
       0x0C62u,      /*DMA3_DmaCicrAddr*/\
       0x0C63u,      /*DMA3_DmaCsrAddr*/\
       0x0C64u,      /*DMA3_DmaCssalAddr*/\
       0x0C65u,      /*DMA3_DmaCssauAddr*/\
       0x0C66u,      /*DMA3_DmaCdsalAddr*/\
       0x0C67u,      /*DMA3_DmaCdsauAddr*/\
       0x0C68u,      /*DMA3_DmaCenAddr*/\
       0x0C69u,      /*DMA3_DmaCfnAddr*/\
       0x0C6Au,      /*DMA3_DmaCsfiAddr*/\
       0x0C6Bu,      /*DMA3_DmaCseiAddr*/\
       0x0C6Fu,      /*DMA3_DmaCdfiAddr*/\
       0x0C6Eu,      /*DMA3_DmaCdeiAddr*/\
       0x0C6Cu,      /*DMA3_DmaCsacAddr*/\
       0x0C6Du,      /*DMA3_DmaCdacAddr*/\
      /* DMA Channel #4 Handle Initialization Data*/\
       0x000Eu,      /*DMA4_EventId*/\
       0x0004u,      /*DMA4_DmaChaNum*/\
       0x0E00u,      /*DMA4_DmaGcrAddr*/\
       0x0E01u,      /*DMA4_DmaGtcrAddr*/\
       0x0E02u,      /*DMA4_DmaGscrAddr*/\
       0x0C80u,      /*DMA4_DmaCsdpAddr*/\
       0x0C81u,      /*DMA4_DmaCcrAddr*/\
       0x0C82u,      /*DMA4_DmaCicrAddr*/\
       0x0C83u,      /*DMA4_DmaCsrAddr*/\
       0x0C84u,      /*DMA4_DmaCssalAddr*/\
       0x0C85u,      /*DMA4_DmaCssauAddr*/\
       0x0C86u,      /*DMA4_DmaCdsalAddr*/\
       0x0C87u,      /*DMA4_DmaCdsauAddr*/\
       0x0C88u,      /*DMA4_DmaCenAddr*/\
       0x0C89u,      /*DMA4_DmaCfnAddr*/\
       0x0C8Au,      /*DMA4_DmaCsfiAddr*/\
       0x0C8Bu,      /*DMA4_DmaCseiAddr*/\
       0x0C8Fu,      /*DMA4_DmaCdfiAddr*/\
       0x0C8Eu,      /*DMA4_DmaCdeiAddr*/\
       0x0C8Cu,      /*DMA4_DmaCsacAddr*/\
       0x0C8Du,      /*DMA4_DmaCdacAddr*/\
      /* DMA Channel#5 Handle Initialization Data*/\
       0x000Fu,      /*DMA5_EventId*/\
       0x0005u,      /*DMA5_DmaChaNum*/\
       0x0E00u,      /*DMA5_DmaGcrAddr*/\
       0x0E01u,      /*DMA5_DmaGtcrAddr*/\
       0x0E02u,      /*DMA5_DmaGscrAddr*/\
       0x0CA0u,      /*DMA5_DmaCsdpAddr*/\
       0x0CA1u,      /*DMA5_DmaCcrAddr*/\
       0x0CA2u,      /*DMA5_DmaCicrAddr*/\
       0x0CA3u,      /*DMA5_DmaCsrAddr*/\
       0x0CA4u,      /*DMA5_DmaCssalAddr*/\
       0x0CA5u,      /*DMA5_DmaCssauAddr*/\
       0x0CA6u,      /*DMA5_DmaCdsalAddr*/\
       0x0CA7u,      /*DMA5_DmaCdsauAddr*/\
       0x0CA8u,      /*DMA5_DmaCenAddr*/\
       0x0CA9u,      /*DMA5_DmaCfnAddr*/\
       0x0CAAu,      /*DMA5_DmaCsfiAddr*/\
       0x0CABu,      /*DMA5_DmaCseiAddr*/\
       0x0CAFu,      /*DMA5_DmaCdfiAddr*/\
       0x0CAEu,      /*DMA5_DmaCdeiAddr*/\
       0x0CACu,      /*DMA5_DmaCsacAddr*/\
       0x0CADu       /*DMA5_DmaCdacAddr*/\
   }
#else
   #define CSL_DMADATAINIT\
   {  /*DMA Channel 0 Handle Initialization Data*/\
       0x0012u,      /*DMA0_EventId*/\
       0x0000u,      /*DMA0_DmaChaNum*/\
       0x0E00u,      /*DMA0_DmaGcrAddr*/\
       0x0E03u,      /*DMA0_DmaGtcrAddr*/\
       0x0E02u,      /*DMA0_DmaGscrAddr*/\
       0x0C00u,      /*DMA0_DmaCsdpAddr*/\
       0x0C01u,      /*DMA0_DmaCcrAddr*/\
       0x0C02u,      /*DMA0_DmaCicrAddr*/\
       0x0C03u,      /*DMA0_DmaCsrAddr*/\
       0x0C04u,      /*DMA0_DmaCssalAddr*/\
       0x0C05u,      /*DMA0_DmaCssauAddr*/\
       0x0C06u,      /*DMA0_DmaCdsalAddr*/\
       0x0C07u,      /*DMA0_DmaCdsauAddr*/\
       0x0C08u,      /*DMA0_DmaCenAddr*/\
       0x0C09u,      /*DMA0_DmaCfnAddr*/\
       0x0C0Au,      /*DMA0_DmaCsfiAddr*/\
       0x0C0Bu,      /*DMA0_DmaCseiAddr*/\
       0x0C0Fu,      /*DMA0_DmaCdfiAddr*/\
       0x0C0Eu,      /*DMA0_DmaCdeiAddr*/\
       0x0C0Cu,      /*DMA0_DmaCsacAddr*/\
       0x0C0Du,      /*DMA0_DmaCdacAddr*/\
      /* DMA Channel #1 Handle Initialization Data*/\
       0x0009u,      /*DMA1_EventId*/\
       0x0001u,      /*DMA1_DmaChaNum*/\
       0x0E00u,      /*DMA1_DmaGcrAddr*/\
       0x0E03u,      /*DMA1_DmaGtcrAddr*/\
       0x0E02u,      /*DMA1_DmaGscrAddr*/\
       0x0C20u,      /*DMA1_DmaCsdpAddr*/\
       0x0C21u,      /*DMA1_DmaCcrAddr*/\
       0x0C22u,      /*DMA1_DmaCicrAddr*/\
       0x0C23u,      /*DMA1_DmaCsrAddr*/\
       0x0C24u,      /*DMA1_DmaCssalAddr*/\
       0x0C25u,      /*DMA1_DmaCssauAddr*/\
       0x0C26u,      /*DMA1_DmaCdsalAddr*/\
       0x0C27u,      /*DMA1_DmaCdsauAddr*/\
       0x0C28u,      /*DMA1_DmaCenAddr*/\
       0x0C29u,      /*DMA1_DmaCfnAddr*/\
       0x0C2Au,      /*DMA1_DmaCsfiAddr*/\
       0x0C2Bu,      /*DMA1_DmaCseiAddr*/\
       0x0C2Fu,      /*DMA1_DmaCdfiAddr*/\
       0x0C2Eu,      /*DMA1_DmaCdeiAddr*/\
       0x0C2Cu,      /*DMA1_DmaCsacAddr*/\
       0x0C2Du,      /*DMA1_DmaCdacAddr*/\
      /* DMA Channel #2 Handle Initialization Data*/\
       0x0014u,      /*DMA2_EventId*/\
       0x0002u,      /*DMA2_DmaChaNum*/\
       0x0E00u,      /*DMA2_DmaGcrAddr*/\
       0x0E03u,      /*DMA2_DmaGtcrAddr*/\
       0x0E02u,      /*DMA2_DmaGscrAddr*/\
       0x0C40u,      /*DMA2_DmaCsdpAddr*/\
       0x0C41u,      /*DMA2_DmaCcrAddr*/\
       0x0C42u,      /*DMA2_DmaCicrAddr*/\
       0x0C43u,      /*DMA2_DmaCsrAddr*/\
       0x0C44u,      /*DMA2_DmaCssalAddr*/\
       0x0C45u,      /*DMA2_DmaCssauAddr*/\
       0x0C46u,      /*DMA2_DmaCdsalAddr*/\
       0x0C47u,      /*DMA2_DmaCdsauAddr*/\
       0x0C48u,      /*DMA2_DmaCenAddr*/\
       0x0C49u,      /*DMA2_DmaCfnAddr*/\
       0x0C4Au,      /*DMA2_DmaCsfiAddr*/\
       0x0C4Bu,      /*DMA2_DmaCseiAddr*/\
       0x0C4Fu,      /*DMA2_DmaCdfiAddr*/\
       0x0C4Eu,      /*DMA2_DmaCdeiAddr*/\
       0x0C4Cu,      /*DMA2_DmaCsacAddr*/\
       0x0C4Du,      /*DMA2_DmaCdacAddr*/\
      /* DMA Channel #3 Handle Initialization Data*/\
       0x0015u,      /*DMA3_EventId*/\
       0x0003u,      /*DMA3_DmaChaNum*/\
       0x0E00u,      /*DMA3_DmaGcrAddr*/\
       0x0E03u,      /*DMA3_DmaGtcrAddr*/\
       0x0E02u,      /*DMA_DmaGscrAddr*/\
       0x0C60u,      /*DMA3_DmaCsdpAddr*/\
       0x0C61u,      /*DMA3_DmaCcrAddr*/\
       0x0C62u,      /*DMA3_DmaCicrAddr*/\
       0x0C63u,      /*DMA3_DmaCsrAddr*/\
       0x0C64u,      /*DMA3_DmaCssalAddr*/\
       0x0C65u,      /*DMA3_DmaCssauAddr*/\
       0x0C66u,      /*DMA3_DmaCdsalAddr*/\
       0x0C67u,      /*DMA3_DmaCdsauAddr*/\
       0x0C68u,      /*DMA3_DmaCenAddr*/\
       0x0C69u,      /*DMA3_DmaCfnAddr*/\
       0x0C6Au,      /*DMA3_DmaCsfiAddr*/\
       0x0C6Bu,      /*DMA3_DmaCseiAddr*/\
       0x0C6Fu,      /*DMA3_DmaCdfiAddr*/\
       0x0C6Eu,      /*DMA3_DmaCdeiAddr*/\
       0x0C6Cu,      /*DMA3_DmaCsacAddr*/\
       0x0C6Du,      /*DMA3_DmaCdacAddr*/\
      /* DMA Channel #4 Handle Initialization Data*/\
       0x000Eu,      /*DMA4_EventId*/\
       0x0004u,      /*DMA4_DmaChaNum*/\
       0x0E00u,      /*DMA4_DmaGcrAddr*/\
       0x0E03u,      /*DMA4_DmaGtcrAddr*/\
       0x0E02u,      /*DMA4_DmaGscrAddr*/\
       0x0C80u,      /*DMA4_DmaCsdpAddr*/\
       0x0C81u,      /*DMA4_DmaCcrAddr*/\
       0x0C82u,      /*DMA4_DmaCicrAddr*/\
       0x0C83u,      /*DMA4_DmaCsrAddr*/\
       0x0C84u,      /*DMA4_DmaCssalAddr*/\
       0x0C85u,      /*DMA4_DmaCssauAddr*/\
       0x0C86u,      /*DMA4_DmaCdsalAddr*/\
       0x0C87u,      /*DMA4_DmaCdsauAddr*/\
       0x0C88u,      /*DMA4_DmaCenAddr*/\
       0x0C89u,      /*DMA4_DmaCfnAddr*/\
       0x0C8Au,      /*DMA4_DmaCsfiAddr*/\
       0x0C8Bu,      /*DMA4_DmaCseiAddr*/\
       0x0C8Fu,      /*DMA4_DmaCdfiAddr*/\
       0x0C8Eu,      /*DMA4_DmaCdeiAddr*/\
       0x0C8Cu,      /*DMA4_DmaCsacAddr*/\
       0x0C8Du,      /*DMA4_DmaCdacAddr*/\
      /* DMA Channel#5 Handle Initialization Data*/\
       0x000Fu,      /*DMA5_EventId*/\
       0x0005u,      /*DMA5_DmaChaNum*/\
       0x0E00u,      /*DMA5_DmaGcrAddr*/\
       0x0E03u,      /*DMA5_DmaGtcrAddr*/\
       0x0E02u,      /*DMA5_DmaGscrAddr*/\
       0x0CA0u,      /*DMA5_DmaCsdpAddr*/\
       0x0CA1u,      /*DMA5_DmaCcrAddr*/\
       0x0CA2u,      /*DMA5_DmaCicrAddr*/\
       0x0CA3u,      /*DMA5_DmaCsrAddr*/\
       0x0CA4u,      /*DMA5_DmaCssalAddr*/\
       0x0CA5u,      /*DMA5_DmaCssauAddr*/\
       0x0CA6u,      /*DMA5_DmaCdsalAddr*/\
       0x0CA7u,      /*DMA5_DmaCdsauAddr*/\
       0x0CA8u,      /*DMA5_DmaCenAddr*/\
       0x0CA9u,      /*DMA5_DmaCfnAddr*/\
       0x0CAAu,      /*DMA5_DmaCsfiAddr*/\
       0x0CABu,      /*DMA5_DmaCseiAddr*/\
       0x0CAFu,      /*DMA5_DmaCdfiAddr*/\
       0x0CAEu,      /*DMA5_DmaCdeiAddr*/\
       0x0CACu,      /*DMA5_DmaCsacAddr*/\
       0x0CADu       /*DMA5_DmaCdacAddr*/\
   }
#endif
   
#endif
csl_dmahal.h/   1074583732  0     0     0       100843    `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... DMA
* FILENAME...... csl_dmahal.h
* DATE CREATED.. Tues 05/30/2000
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. stdinc.h, chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:   05/30/2000  created
*   MODIFIED:  03/23/2001  modified to support 5510 PG2.0 DMA
*   MODIFIED:  04/16/2001  modified header comments
*   MODIFIED:  01/24/2002  fixed definition of DMA_FMKS macro (preceding
*                          underscore problem)
*   MODIFIED:  07/18/2002  fixed bad addresses for CDEI and CDFI regs
*   MODIFIED:  08/13/2002  reDid addresses for CDEI/CDFI regs and implemented
*                          some of the 5502 DMA changes for GSCR and GCR
*   MODIFIED:  06/19/2003  adding GTCR register
*   MODIFIED:  07/22/2003  Fixed bad addresses for CDEIx and CDFIx registers
*   MODIFIED:  01/08/2004  Added WP field to DMACCR register(5502)
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the DMA module)
*
* Registers Covered:
*   (RW) _DMA_DMAGCR     -  Global Control Register
*   (RW) _DMA_DMACSDPn   -  Channel #n Source Destination Parameters Register
*   (RW) _DMA_DMACCRn    -  Channel #n Control Register
*   (RW) _DMA_DMACICRn   -  Channel #n Interrupt Control Register
*   (RW) _DMA_DMACSRn    -  Channel #n Status Register
*   (RW) _DMA_DMACSSALn  -  Channel #n Source Start Address ,lower 16 bits
*   (RW) _DMA_DMACSSAUn  -  Channel #n Source Start Address ,upper 8 bits
*   (RW) _DMA_DMACDSALn  -  Channel #n Destination Start Address, lower 16 bits
*   (RW) _DMA_DMACDSAUn  -  Channel #n Destination Start Address, upper 16 bits
*   (RW) _DMA_DMACENn    -  Channel #n Element Number/Count Register
*   (RW) _DMA_DMACFNn    -  Channel #n Frame Number/Count Register
*   (RW) _DMA_DMACFIn    -  Channel #n Frame Index Register
*   (RW) _DMA_DMACEIn    -  Channel #n Element Index Register
* For 5502, 5510 PG2.0 and 5509A
*   (RW) _DMA_DMAGTCR    -  Timeout Control Register (compatability with PG1.0)
*   (RW) _DMA_DMAGSCR    -  Software Compatability Register (compatability with PG1.0)
*   (RW) _DMA_DMACSEI    -  Channel #n Source Element Index Register
*   (RW) _DMA_DMACSFI    -  Channel #n Source Frame Index Register
*   (RW) _DMA_DMACDEI    -  Channel #n Destination Element Index Register
*   (RW) _DMA_DMACDFI    -  Channel #n Destination Frame Index Register
*   (R)  _DMA_DMACSAC    -  Channel #n Source Address Counter Register (Read Only Status)
*   (R)  _DMA_DMACDAC    -  Channel #n Destination Address Counter Register (Status)
\******************************************************************************/
#ifndef _DMAHAL_H_
#define _DMAHAL_H_

#include <csl_std.h>
#include <csl_stdhal.h>
#include <csl_chiphal.h>


/*============================================================================*\
* DMA address, register, and field generic macros
\*============================================================================*/
#define _DMA_PFIELD_GET(RegAddr,Field)            _PFIELD_GET(RegAddr,Field)
#define _DMA_PFIELD_SET(RegAddr,Field,Val)        _PFIELD_SET(RegAddr,Field,Val)
#define _DMA_FSETS(Reg,Field,Sym)                 DMA_FSET(##Reg,##Field,Field##_##Sym)

#define DMA_ADDR(Reg)                  _DMA_##Reg##_ADDR
#define DMA_RGET(Reg)                  _PREG_GET(DMA_ADDR(##Reg))
#define DMA_RSET(Reg,Val)              _PREG_SET(DMA_ADDR(##Reg),Val)
#define DMA_RAOI(Reg,AND,OR,INV)       _PREG_AOI(DMA_ADDR(##Reg),AND,OR,INV)
#define DMA_FGET(Reg,Field)            _DMA_PFIELD_GET(DMA_ADDR(##Reg),_DMA_##Reg##_##Field)
#define DMA_FSET(Reg,Field,Val)        _DMA_PFIELD_SET(DMA_ADDR(##Reg),_DMA_##Reg##_##Field,Val)
#define DMA_FSETS(Reg,Field,Sym)       _DMA_FSETS(##Reg,_DMA_##Reg##_##Field,Sym)
#define DMA_FMK(Reg,Field,Val)         _DMA_##Reg##_##Field##_MK(Val)
#define DMA_FMKS(Reg,Field,Sym)        DMA_FMK(##Reg,##Field,DMA_##Reg##_##Field##_##Sym)
#define DMA_FAOI(Reg,AND,OR,INV)       _PFIELD_AOI(DMA_ADDR(##Reg),_DMA_##Reg##_##Field,AND,OR,INV)

#define DMA_ADDRH(h,Reg)              _DMA_##Reg##_ADDR(((DMA_PrivateObj*)(h))->DmaChaNum)
#define DMA_RGETH(h,Reg)              _PREG_GET(DMA_ADDRH(h,##Reg))
#define DMA_RSETH(h,Reg,Val)          _PREG_SET(DMA_ADDRH(h,##Reg),Val)
#define DMA_RAOIH(h,Reg,AND,OR,INV)   _PREG_AOI(DMA_ADDRH(h,##Reg),AND,OR,INV)
#define DMA_FGETH(h,Reg,Field)        _PFIELD_GET(DMA_ADDRH(h,##Reg),_DMA_##Reg##_##Field)
#define DMA_FSETH(h,Reg,Field,Val)    _PFIELD_SET(DMA_ADDRH(h,##Reg),_DMA_##Reg##_##Field,Val)
#define DMA_FSETSH(h,Reg,Field,Sym)   DMA_FSET(##Reg,##Field,_DMA_##Reg##_##Field##_##Sym)
#define DMA_FAOIH(h,Reg,AND,OR,INV)   _PFIELD_AOI(DMA_ADDRH(h,##Reg),_DMA_##Reg##_##Field,AND,OR,INV)

#define DMA_ADDR_H(h,Reg)              _DMA_##Reg##_ADDR(((DMA_PrivateObj*)(h))->DmaChaNum)
#define DMA_RGET_H(h,Reg)              _PREG_GET(DMA_ADDRH(h,##Reg))
#define DMA_RSET_H(h,Reg,Val)          _PREG_SET(DMA_ADDRH(h,##Reg),Val)
#define DMA_RAOI_H(h,Reg,AND,OR,INV)   _PREG_AOI(DMA_ADDRH(h,##Reg),AND,OR,INV)
#define DMA_FGET_H(h,Reg,Field)        _PFIELD_GET(DMA_ADDRH(h,##Reg),_DMA_##Reg##_##Field)
#define DMA_FSET_H(h,Reg,Field,Val)    _PFIELD_SET(DMA_ADDRH(h,##Reg),_DMA_##Reg##_##Field,Val)
#define DMA_FSETS_H(h,Reg,Field,Sym)   DMA_FSET(##Reg,##Field,_DMA_##Reg##_##Field##_##Sym)
#define DMA_FAOI_H(h,Reg,AND,OR,INV)   _PFIELD_AOI(DMA_ADDRH(h,##Reg),_DMA_##Reg##_##Field,AND,OR,INV)

/*===============================================================================*\
* DMA Channel Field Macros
\*===============================================================================*/
#define _DMA_DMACSDP0_DSTBEN                 _DMA_DMACSDP_DSTBEN
#define _DMA_DMACSDP1_DSTBEN                 _DMA_DMACSDP_DSTBEN
#define _DMA_DMACSDP2_DSTBEN                 _DMA_DMACSDP_DSTBEN
#define _DMA_DMACSDP3_DSTBEN                 _DMA_DMACSDP_DSTBEN
#define _DMA_DMACSDP4_DSTBEN                 _DMA_DMACSDP_DSTBEN
#define _DMA_DMACSDP5_DSTBEN                 _DMA_DMACSDP_DSTBEN

#define _DMA_DMACSDP0_DSTPACK                _DMA_DMACSDP_DSTPACK
#define _DMA_DMACSDP1_DSTPACK                _DMA_DMACSDP_DSTPACK
#define _DMA_DMACSDP2_DSTPACK                _DMA_DMACSDP_DSTPACK
#define _DMA_DMACSDP3_DSTPACK                _DMA_DMACSDP_DSTPACK
#define _DMA_DMACSDP4_DSTPACK                _DMA_DMACSDP_DSTPACK
#define _DMA_DMACSDP5_DSTPACK                _DMA_DMACSDP_DSTPACK

#define _DMA_DMACSDP0_DST              _DMA_DMACSDP_DST
#define _DMA_DMACSDP1_DST              _DMA_DMACSDP_DST
#define _DMA_DMACSDP2_DST              _DMA_DMACSDP_DST
#define _DMA_DMACSDP3_DST              _DMA_DMACSDP_DST
#define _DMA_DMACSDP4_DST              _DMA_DMACSDP_DST
#define _DMA_DMACSDP5_DST              _DMA_DMACSDP_DST

#define _DMA_DMACSDP0_SRCBEN           _DMA_DMACSDP_SRCBEN
#define _DMA_DMACSDP1_SRCBEN           _DMA_DMACSDP_SRCBEN
#define _DMA_DMACSDP2_SRCBEN           _DMA_DMACSDP_SRCBEN
#define _DMA_DMACSDP3_SRCBEN           _DMA_DMACSDP_SRCBEN
#define _DMA_DMACSDP4_SRCBEN           _DMA_DMACSDP_SRCBEN
#define _DMA_DMACSDP5_SRCBEN           _DMA_DMACSDP_SRCBEN

#define _DMA_DMACSDP0_SRCPACK          _DMA_DMACSDP_SRCPACK
#define _DMA_DMACSDP1_SRCPACK          _DMA_DMACSDP_SRCPACK
#define _DMA_DMACSDP2_SRCPACK          _DMA_DMACSDP_SRCPACK
#define _DMA_DMACSDP3_SRCPACK          _DMA_DMACSDP_SRCPACK
#define _DMA_DMACSDP4_SRCPACK          _DMA_DMACSDP_SRCPACK
#define _DMA_DMACSDP5_SRCPACK          _DMA_DMACSDP_SRCPACK

#define _DMA_DMACSDP0_SRC              _DMA_DMACSDP_SRC
#define _DMA_DMACSDP1_SRC              _DMA_DMACSDP_SRC
#define _DMA_DMACSDP2_SRC              _DMA_DMACSDP_SRC
#define _DMA_DMACSDP3_SRC              _DMA_DMACSDP_SRC
#define _DMA_DMACSDP4_SRC              _DMA_DMACSDP_SRC
#define _DMA_DMACSDP5_SRC              _DMA_DMACSDP_SRC

#define _DMA_DMACSDP0_DATATYPE         _DMA_DMACSDP_DATATYPE
#define _DMA_DMACSDP1_DATATYPE         _DMA_DMACSDP_DATATYPE
#define _DMA_DMACSDP2_DATATYPE         _DMA_DMACSDP_DATATYPE
#define _DMA_DMACSDP3_DATATYPE         _DMA_DMACSDP_DATATYPE
#define _DMA_DMACSDP4_DATATYPE         _DMA_DMACSDP_DATATYPE
#define _DMA_DMACSDP5_DATATYPE         _DMA_DMACSDP_DATATYPE

#define _DMA_DMACCR0_DSTAMODE           _DMA_DMACCR_DSTAMODE
#define _DMA_DMACCR1_DSTAMODE           _DMA_DMACCR_DSTAMODE
#define _DMA_DMACCR2_DSTAMODE           _DMA_DMACCR_DSTAMODE
#define _DMA_DMACCR3_DSTAMODE           _DMA_DMACCR_DSTAMODE
#define _DMA_DMACCR4_DSTAMODE           _DMA_DMACCR_DSTAMODE
#define _DMA_DMACCR5_DSTAMODE           _DMA_DMACCR_DSTAMODE

#define _DMA_DMACCR0_SRCAMODE           _DMA_DMACCR_SRCAMODE
#define _DMA_DMACCR1_SRCAMODE           _DMA_DMACCR_SRCAMODE
#define _DMA_DMACCR2_SRCAMODE           _DMA_DMACCR_SRCAMODE
#define _DMA_DMACCR3_SRCAMODE           _DMA_DMACCR_SRCAMODE
#define _DMA_DMACCR4_SRCAMODE           _DMA_DMACCR_SRCAMODE
#define _DMA_DMACCR5_SRCAMODE           _DMA_DMACCR_SRCAMODE

#define _DMA_DMACCR0_ENDPROG            _DMA_DMACCR_ENDPROG
#define _DMA_DMACCR1_ENDPROG            _DMA_DMACCR_ENDPROG
#define _DMA_DMACCR2_ENDPROG            _DMA_DMACCR_ENDPROG
#define _DMA_DMACCR3_ENDPROG            _DMA_DMACCR_ENDPROG
#define _DMA_DMACCR4_ENDPROG            _DMA_DMACCR_ENDPROG
#define _DMA_DMACCR5_ENDPROG            _DMA_DMACCR_ENDPROG

#if (CHIP_5502)

#define _DMA_DMACCR0_WP                 _DMA_DMACCR_WP
#define _DMA_DMACCR1_WP                 _DMA_DMACCR_WP
#define _DMA_DMACCR2_WP                 _DMA_DMACCR_WP
#define _DMA_DMACCR3_WP                 _DMA_DMACCR_WP
#define _DMA_DMACCR4_WP                 _DMA_DMACCR_WP
#define _DMA_DMACCR5_WP                 _DMA_DMACCR_WP

#endif

#define _DMA_DMACCR0_REPEAT             _DMA_DMACCR_REPEAT
#define _DMA_DMACCR1_REPEAT             _DMA_DMACCR_REPEAT
#define _DMA_DMACCR2_REPEAT             _DMA_DMACCR_REPEAT
#define _DMA_DMACCR3_REPEAT             _DMA_DMACCR_REPEAT
#define _DMA_DMACCR4_REPEAT             _DMA_DMACCR_REPEAT
#define _DMA_DMACCR5_REPEAT             _DMA_DMACCR_REPEAT

#define _DMA_DMACCR0_AUTOINIT           _DMA_DMACCR_AUTOINIT
#define _DMA_DMACCR1_AUTOINIT           _DMA_DMACCR_AUTOINIT
#define _DMA_DMACCR2_AUTOINIT           _DMA_DMACCR_AUTOINIT
#define _DMA_DMACCR3_AUTOINIT           _DMA_DMACCR_AUTOINIT
#define _DMA_DMACCR4_AUTOINIT           _DMA_DMACCR_AUTOINIT
#define _DMA_DMACCR5_AUTOINIT           _DMA_DMACCR_AUTOINIT


#define _DMA_DMACCR0_EN                 _DMA_DMACCR_EN
#define _DMA_DMACCR1_EN                 _DMA_DMACCR_EN
#define _DMA_DMACCR2_EN                 _DMA_DMACCR_EN
#define _DMA_DMACCR3_EN                 _DMA_DMACCR_EN
#define _DMA_DMACCR4_EN                 _DMA_DMACCR_EN
#define _DMA_DMACCR5_EN                 _DMA_DMACCR_EN

#define _DMA_DMACCR0_PRIO               _DMA_DMACCR_PRIO
#define _DMA_DMACCR1_PRIO               _DMA_DMACCR_PRIO
#define _DMA_DMACCR2_PRIO               _DMA_DMACCR_PRIO
#define _DMA_DMACCR3_PRIO               _DMA_DMACCR_PRIO
#define _DMA_DMACCR4_PRIO               _DMA_DMACCR_PRIO
#define _DMA_DMACCR5_PRIO               _DMA_DMACCR_PRIO

#define _DMA_DMACCR0_FS                 _DMA_DMACCR_FS
#define _DMA_DMACCR1_FS                 _DMA_DMACCR_FS
#define _DMA_DMACCR2_FS                 _DMA_DMACCR_FS
#define _DMA_DMACCR3_FS                 _DMA_DMACCR_FS
#define _DMA_DMACCR4_FS                 _DMA_DMACCR_FS
#define _DMA_DMACCR5_FS                 _DMA_DMACCR_FS

#define _DMA_DMACCR0_SYNC               _DMA_DMACCR_SYNC
#define _DMA_DMACCR1_SYNC               _DMA_DMACCR_SYNC
#define _DMA_DMACCR2_SYNC               _DMA_DMACCR_SYNC
#define _DMA_DMACCR3_SYNC               _DMA_DMACCR_SYNC
#define _DMA_DMACCR4_SYNC               _DMA_DMACCR_SYNC
#define _DMA_DMACCR5_SYNC               _DMA_DMACCR_SYNC

#define _DMA_DMACICR0_BLOCKIE          _DMA_DMACICR_BLOCKIE
#define _DMA_DMACICR1_BLOCKIE          _DMA_DMACICR_BLOCKIE
#define _DMA_DMACICR2_BLOCKIE          _DMA_DMACICR_BLOCKIE
#define _DMA_DMACICR3_BLOCKIE          _DMA_DMACICR_BLOCKIE
#define _DMA_DMACICR4_BLOCKIE          _DMA_DMACICR_BLOCKIE
#define _DMA_DMACICR5_BLOCKIE          _DMA_DMACICR_BLOCKIE

#define _DMA_DMACICR0_LASTIE           _DMA_DMACICR_LASTIE
#define _DMA_DMACICR1_LASTIE           _DMA_DMACICR_LASTIE
#define _DMA_DMACICR2_LASTIE           _DMA_DMACICR_LASTIE
#define _DMA_DMACICR3_LASTIE           _DMA_DMACICR_LASTIE
#define _DMA_DMACICR4_LASTIE           _DMA_DMACICR_LASTIE
#define _DMA_DMACICR5_LASTIE           _DMA_DMACICR_LASTIE

#define _DMA_DMACICR0_FRAMEIE          _DMA_DMACICR_FRAMEIE
#define _DMA_DMACICR1_FRAMEIE          _DMA_DMACICR_FRAMEIE
#define _DMA_DMACICR2_FRAMEIE          _DMA_DMACICR_FRAMEIE
#define _DMA_DMACICR3_FRAMEIE          _DMA_DMACICR_FRAMEIE
#define _DMA_DMACICR4_FRAMEIE          _DMA_DMACICR_FRAMEIE
#define _DMA_DMACICR5_FRAMEIE          _DMA_DMACICR_FRAMEIE

#define _DMA_DMACICR0_HALFIE      _DMA_DMACICR_HALFIE
#define _DMA_DMACICR1_HALFIE      _DMA_DMACICR_HALFIE
#define _DMA_DMACICR2_HALFIE      _DMA_DMACICR_HALFIE
#define _DMA_DMACICR3_HALFIE      _DMA_DMACICR_HALFIE
#define _DMA_DMACICR4_HALFIE      _DMA_DMACICR_HALFIE
#define _DMA_DMACICR5_HALFIE      _DMA_DMACICR_HALFIE

#define _DMA_DMACICR0_DROPIE           _DMA_DMACICR_DROPIE
#define _DMA_DMACICR1_DROPIE           _DMA_DMACICR_DROPIE
#define _DMA_DMACICR2_DROPIE           _DMA_DMACICR_DROPIE
#define _DMA_DMACICR3_DROPIE           _DMA_DMACICR_DROPIE
#define _DMA_DMACICR4_DROPIE           _DMA_DMACICR_DROPIE
#define _DMA_DMACICR5_DROPIE           _DMA_DMACICR_DROPIE

#define _DMA_DMACICR0_TIMEOUTIE        _DMA_DMACICR_TIMEOUTIE
#define _DMA_DMACICR1_TIMEOUTIE        _DMA_DMACICR_TIMEOUTIE
#define _DMA_DMACICR2_TIMEOUTIE        _DMA_DMACICR_TIMEOUTIE
#define _DMA_DMACICR3_TIMEOUTIE        _DMA_DMACICR_TIMEOUTIE
#define _DMA_DMACICR4_TIMEOUTIE        _DMA_DMACICR_TIMEOUTIE
#define _DMA_DMACICR5_TIMEOUTIE        _DMA_DMACICR_TIMEOUTIE

#define _DMA_DMACSR0_SYNC                  _DMA_DMACSR_SYNC
#define _DMA_DMACSR1_SYNC                  _DMA_DMACSR_SYNC
#define _DMA_DMACSR2_SYNC                  _DMA_DMACSR_SYNC
#define _DMA_DMACSR3_SYNC                  _DMA_DMACSR_SYNC
#define _DMA_DMACSR4_SYNC                  _DMA_DMACSR_SYNC
#define _DMA_DMACSR5_SYNC                  _DMA_DMACSR_SYNC

#define _DMA_DMACSR0_BLOCK                 _DMA_DMACSR_BLOCK
#define _DMA_DMACSR1_BLOCK                 _DMA_DMACSR_BLOCK
#define _DMA_DMACSR2_BLOCK                 _DMA_DMACSR_BLOCK
#define _DMA_DMACSR3_BLOCK                 _DMA_DMACSR_BLOCK
#define _DMA_DMACSR4_BLOCK                 _DMA_DMACSR_BLOCK
#define _DMA_DMACSR5_BLOCK                 _DMA_DMACSR_BLOCK

#define _DMA_DMACSR0_LAST                  _DMA_DMACSR_LAST
#define _DMA_DMACSR1_LAST                  _DMA_DMACSR_LAST
#define _DMA_DMACSR2_LAST                  _DMA_DMACSR_LAST
#define _DMA_DMACSR3_LAST                  _DMA_DMACSR_LAST
#define _DMA_DMACSR4_LAST                  _DMA_DMACSR_LAST
#define _DMA_DMACSR5_LAST                  _DMA_DMACSR_LAST

#define _DMA_DMACSR0_FRAME                 _DMA_DMACSR_FRAME
#define _DMA_DMACSR1_FRAME                 _DMA_DMACSR_FRAME
#define _DMA_DMACSR2_FRAME                 _DMA_DMACSR_FRAME
#define _DMA_DMACSR3_FRAME                 _DMA_DMACSR_FRAME
#define _DMA_DMACSR4_FRAME                 _DMA_DMACSR_FRAME
#define _DMA_DMACSR5_FRAME                 _DMA_DMACSR_FRAME

#define _DMA_DMACSR0_DROP                  _DMA_DMACSR_DROP
#define _DMA_DMACSR1_DROP                  _DMA_DMACSR_DROP
#define _DMA_DMACSR2_DROP                  _DMA_DMACSR_DROP
#define _DMA_DMACSR3_DROP                  _DMA_DMACSR_DROP
#define _DMA_DMACSR4_DROP                  _DMA_DMACSR_DROP
#define _DMA_DMACSR5_DROP                  _DMA_DMACSR_DROP

#define _DMA_DMACSR0_HALF                  _DMA_DMACSR_HALF
#define _DMA_DMACSR1_HALF                  _DMA_DMACSR_HALF
#define _DMA_DMACSR2_HALF                  _DMA_DMACSR_HALF
#define _DMA_DMACSR3_HALF                  _DMA_DMACSR_HALF
#define _DMA_DMACSR4_HALF                  _DMA_DMACSR_HALF
#define _DMA_DMACSR5_HALF                  _DMA_DMACSR_HALF

#define _DMA_DMACSR0_TIMEOUT               _DMA_DMACSR_TIMEOUT
#define _DMA_DMACSR1_TIMEOUT               _DMA_DMACSR_TIMEOUT
#define _DMA_DMACSR2_TIMEOUT               _DMA_DMACSR_TIMEOUT
#define _DMA_DMACSR3_TIMEOUT               _DMA_DMACSR_TIMEOUT
#define _DMA_DMACSR4_TIMEOUT               _DMA_DMACSR_TIMEOUT
#define _DMA_DMACSR5_TIMEOUT               _DMA_DMACSR_TIMEOUT

#define _DMA_DMACSSAL0_SSAL                _DMA_DMACSSAL_SSAL
#define _DMA_DMACSSAL1_SSAL                _DMA_DMACSSAL_SSAL
#define _DMA_DMACSSAL2_SSAL                _DMA_DMACSSAL_SSAL
#define _DMA_DMACSSAL3_SSAL                _DMA_DMACSSAL_SSAL
#define _DMA_DMACSSAL4_SSAL                _DMA_DMACSSAL_SSAL
#define _DMA_DMACSSAL5_SSAL                _DMA_DMACSSAL_SSAL

#define _DMA_DMACSSAU0_SSAU                _DMA_DMACSSAU_SSAU
#define _DMA_DMACSSAU1_SSAU                _DMA_DMACSSAU_SSAU
#define _DMA_DMACSSAU2_SSAU                _DMA_DMACSSAU_SSAU
#define _DMA_DMACSSAU3_SSAU                _DMA_DMACSSAU_SSAU
#define _DMA_DMACSSAU4_SSAU                _DMA_DMACSSAU_SSAU
#define _DMA_DMACSSAU5_SSAU                _DMA_DMACSSAU_SSAU

#define _DMA_DMACDSAL0_DSAL                _DMA_DMACDSAL_DSAL
#define _DMA_DMACDSAL1_DSAL                _DMA_DMACDSAL_DSAL
#define _DMA_DMACDSAL2_DSAL                _DMA_DMACDSAL_DSAL
#define _DMA_DMACDSAL3_DSAL                _DMA_DMACDSAL_DSAL
#define _DMA_DMACDSAL4_DSAL                _DMA_DMACDSAL_DSAL
#define _DMA_DMACDSAL5_DSAL                _DMA_DMACDSAL_DSAL

#define _DMA_DMACDSAU0_DSAU                _DMA_DMACDSAU_DSAU
#define _DMA_DMACDSAU1_DSAU                _DMA_DMACDSAU_DSAU
#define _DMA_DMACDSAU2_DSAU                _DMA_DMACDSAU_DSAU
#define _DMA_DMACDSAU3_DSAU                _DMA_DMACDSAU_DSAU
#define _DMA_DMACDSAU4_DSAU                _DMA_DMACDSAU_DSAU
#define _DMA_DMACDSAU5_DSAU                _DMA_DMACDSAU_DSAU

#define _DMA_DMACEN0_ELEMENTNUM            _DMA_DMACEN_ELEMENTNUM
#define _DMA_DMACEN1_ELEMENTNUM            _DMA_DMACEN_ELEMENTNUM
#define _DMA_DMACEN2_ELEMENTNUM            _DMA_DMACEN_ELEMENTNUM
#define _DMA_DMACEN3_ELEMENTNUM            _DMA_DMACEN_ELEMENTNUM
#define _DMA_DMACEN4_ELEMENTNUM            _DMA_DMACEN_ELEMENTNUM
#define _DMA_DMACEN5_ELEMENTNUM            _DMA_DMACEN_ELEMENTNUM

#define _DMA_DMACFN0_FRAMENUM              _DMA_DMACFN_FRAMENUM
#define _DMA_DMACFN1_FRAMENUM              _DMA_DMACFN_FRAMENUM
#define _DMA_DMACFN2_FRAMENUM              _DMA_DMACFN_FRAMENUM
#define _DMA_DMACFN3_FRAMENUM              _DMA_DMACFN_FRAMENUM
#define _DMA_DMACFN4_FRAMENUM              _DMA_DMACFN_FRAMENUM
#define _DMA_DMACFN5_FRAMENUM              _DMA_DMACFN_FRAMENUM

#define _DMA_DMACFI0_FRAMENDX              _DMA_DMACFI_FRAMENDX
#define _DMA_DMACFI1_FRAMENDX              _DMA_DMACFI_FRAMENDX
#define _DMA_DMACFI2_FRAMENDX              _DMA_DMACFI_FRAMENDX
#define _DMA_DMACFI3_FRAMENDX              _DMA_DMACFI_FRAMENDX
#define _DMA_DMACFI4_FRAMENDX              _DMA_DMACFI_FRAMENDX
#define _DMA_DMACFI5_FRAMENDX              _DMA_DMACFI_FRAMENDX

#define _DMA_DMACEI0_ELEMENTNDX            _DMA_DMACEI_ELEMENTNDX
#define _DMA_DMACEI1_ELEMENTNDX            _DMA_DMACEI_ELEMENTNDX
#define _DMA_DMACEI2_ELEMENTNDX            _DMA_DMACEI_ELEMENTNDX
#define _DMA_DMACEI3_ELEMENTNDX            _DMA_DMACEI_ELEMENTNDX
#define _DMA_DMACEI4_ELEMENTNDX            _DMA_DMACEI_ELEMENTNDX
#define _DMA_DMACEI5_ELEMENTNDX            _DMA_DMACEI_ELEMENTNDX

#define _DMA_DMACSFI0_FRAMENDX              _DMA_DMACSFI_FRAMENDX
#define _DMA_DMACSFI1_FRAMENDX              _DMA_DMACSFI_FRAMENDX
#define _DMA_DMACSFI2_FRAMENDX              _DMA_DMACSFI_FRAMENDX
#define _DMA_DMACSFI3_FRAMENDX              _DMA_DMACSFI_FRAMENDX
#define _DMA_DMACSFI4_FRAMENDX              _DMA_DMACSFI_FRAMENDX
#define _DMA_DMACSFI5_FRAMENDX              _DMA_DMACSFI_FRAMENDX

#define _DMA_DMACSEI0_ELEMENTNDX            _DMA_DMACSEI_ELEMENTNDX
#define _DMA_DMACSEI1_ELEMENTNDX            _DMA_DMACSEI_ELEMENTNDX
#define _DMA_DMACSEI2_ELEMENTNDX            _DMA_DMACSEI_ELEMENTNDX
#define _DMA_DMACSEI3_ELEMENTNDX            _DMA_DMACSEI_ELEMENTNDX
#define _DMA_DMACSEI4_ELEMENTNDX            _DMA_DMACSEI_ELEMENTNDX
#define _DMA_DMACSEI5_ELEMENTNDX            _DMA_DMACSEI_ELEMENTNDX

#define _DMA_DMACDFI0_FRAMENDX              _DMA_DMACDFI_FRAMENDX
#define _DMA_DMACDFI1_FRAMENDX              _DMA_DMACDFI_FRAMENDX
#define _DMA_DMACDFI2_FRAMENDX              _DMA_DMACDFI_FRAMENDX
#define _DMA_DMACDFI3_FRAMENDX              _DMA_DMACDFI_FRAMENDX
#define _DMA_DMACDFI4_FRAMENDX              _DMA_DMACDFI_FRAMENDX
#define _DMA_DMACDFI5_FRAMENDX              _DMA_DMACDFI_FRAMENDX

#define _DMA_DMACDEI0_ELEMENTNDX            _DMA_DMACDEI_ELEMENTNDX
#define _DMA_DMACDEI1_ELEMENTNDX            _DMA_DMACDEI_ELEMENTNDX
#define _DMA_DMACDEI2_ELEMENTNDX            _DMA_DMACDEI_ELEMENTNDX
#define _DMA_DMACDEI3_ELEMENTNDX            _DMA_DMACDEI_ELEMENTNDX
#define _DMA_DMACDEI4_ELEMENTNDX            _DMA_DMACDEI_ELEMENTNDX
#define _DMA_DMACDEI5_ELEMENTNDX            _DMA_DMACDEI_ELEMENTNDX



/*============================================================================*\
* misc declarations
\*============================================================================*/

#define DMA_DEVICE_CNT                 (6) 
#define _DMA_CHA_CNT                   (6)
#define _DMA_BASE_ADDR                 (0x0C00u)

#define _DMA_DMACSDP_OFFSET            (0x0000u)
#define _DMA_DMACCR_OFFSET             (0x0001u)
#define _DMA_DMACICR_OFFSET            (0x0002u)
#define _DMA_DMACSR_OFFSET             (0x0003u)
#define _DMA_DMACSSAL_OFFSET           (0x0004u)
#define _DMA_DMACSSAU_OFFSET           (0x0005u)
#define _DMA_DMACDSAL_OFFSET           (0x0006u)
#define _DMA_DMACDSAU_OFFSET           (0x0007u)
#define _DMA_DMACEN_OFFSET             (0x0008u)
#define _DMA_DMACFN_OFFSET             (0x0009u)
#define _DMA_DMACFI_OFFSET             (0x000Au)
#define _DMA_DMACEI_OFFSET             (0x000Bu)

#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  #define _DMA_DMACSFI_OFFSET          (0x000Au)
  #define _DMA_DMACSEI_OFFSET          (0x000Bu)
  #define _DMA_DMACDFI_OFFSET          (0x000Fu)
  #define _DMA_DMACDEI_OFFSET          (0x000Eu)
  #define _DMA_DMACSAC_OFFSET          (0x000Cu)
  #define _DMA_DMACDAC_OFFSET          (0x000Du)
#endif

#define _DMA_CHAN_SZ                   (0x0020u)

#define _DMA_DMACSDP_ADDR(n)           (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSDP_OFFSET)
#define _DMA_DMACCR_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACCR_OFFSET)
#define _DMA_DMACICR_ADDR(n)           (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACICR_OFFSET)
#define _DMA_DMACSR_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSR_OFFSET)
#define _DMA_DMACSSAL_ADDR(n)          (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSSAL_OFFSET)        
#define _DMA_DMACSSAU_ADDR(n)          (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSSAU_OFFSET)        
#define _DMA_DMACDSAL_ADDR(n)          (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACDSAL_OFFSET)
#define _DMA_DMACDSAU_ADDR(n)          (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACDSAU_OFFSET)
#define _DMA_DMACEN_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACEN_OFFSET)
#define _DMA_DMACFN_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACFN_OFFSET)
#define _DMA_DMACFI_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACFI_OFFSET)
#define _DMA_DMACEI_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACEI_OFFSET)

#define _DMA_DMACSDP(n)                PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSDP_OFFSET)
#define _DMA_DMACCR(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACCR_OFFSET)
#define _DMA_DMACICR(n)                PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACICR_OFFSET)
#define _DMA_DMACSR(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSR_OFFSET)
#define _DMA_DMACSSAL(n)               PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSSAL_OFFSET)        
#define _DMA_DMACSSAU(n)               PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSSAU_OFFSET)        
#define _DMA_DMACDSAL(n)               PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACDSAL_OFFSET)
#define _DMA_DMACDSAU(n)               PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACDSAU_OFFSET)
#define _DMA_DMACEN(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACEN_OFFSET)
#define _DMA_DMACFN(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACFN_OFFSET)
#define _DMA_DMACFI(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACFI_OFFSET)
#define _DMA_DMACEI(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACEI_OFFSET)

#if _DMA_DST_AND_SRC_INDEX_SUPPORT        
#define _DMA_DMACSFI(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSFI_OFFSET)
#define _DMA_DMACSEI(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSEI_OFFSET)
#define _DMA_DMACDFI(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACDFI_OFFSET)
#define _DMA_DMACDEI(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACDEI_OFFSET)
#define _DMA_DMACSAC(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSAC_OFFSET)
#define _DMA_DMACDAC(n)                 PREG16(((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACDAC_OFFSET)
#define _DMA_DMACDFI_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACDFI_OFFSET)
#define _DMA_DMACDEI_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACDEI_OFFSET)
#define _DMA_DMACSFI_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSFI_OFFSET)
#define _DMA_DMACSEI_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSEI_OFFSET)
#define _DMA_DMACSAC_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACSAC_OFFSET)
#define _DMA_DMACDAC_ADDR(n)            (((n) * _DMA_CHAN_SZ) + _DMA_BASE_ADDR + _DMA_DMACDAC_OFFSET)
#endif

/*============================================================================*\
* _DMA_DMAGCR:  Global Control Register
\*============================================================================*/
#define _DMA_DMAGCR_ADDR				(0x0E00u)
#define _DMA_DMAGCR                       	PREG16(_DMA_DMAGCR_ADDR)
#define DMA_DMAGCR                              _DMA_DMAGCR

/*============================================================================*\
* _DMA_DMAGCR_GET and _DMA_DMAGCR_SET
\*============================================================================*/
#define _DMA_DMAGCR_GET(RegAddr)  		_PREG_GET(RegAddr)
#define _DMA_DMAGCR_SET(RegAddr,Val)   	_PREG_SET(RegAddr,Val)

#if (_DMA_DST_AND_SRC_INDEX_SUPPORT)
  /*============================================================================*\
  * _DMA_DMAGTCR:  Global Timeout Counter Register
  \*============================================================================*/
  #if (CHIP_5502)
    #define _DMA_DMAGTCR_ADDR				(0x0E01u)
  #else
    #define _DMA_DMAGTCR_ADDR				(0x0E03u)
  #endif
  #define _DMA_DMAGTCR                       	PREG16(_DMA_DMAGTCR_ADDR)
  #define DMA_DMAGTCR                              _DMA_DMAGTCR

  /*============================================================================*\
  * _DMA_DMAGTCR_GET and _DMA_DMAGTCR_SET
  \*============================================================================*/
  #define _DMA_DMAGTCR_GET(RegAddr)  		_PREG_GET(RegAddr)
  #define _DMA_DMAGTCR_SET(RegAddr,Val)   	_PREG_SET(RegAddr,Val)
#endif

#if ((_DMA_DST_AND_SRC_INDEX_SUPPORT) && ( !CHIP_5502))
  /*============================================================================*\
  * _DMA_DMAGSCR:  Global Software Compatability Register
  \*============================================================================*/
  #define _DMA_DMAGSCR_ADDR				(0x0E02u)
  #define _DMA_DMAGSCR                       	PREG16(_DMA_DMAGSCR_ADDR)
  #define DMA_DMAGSCR                              _DMA_DMAGSCR

  /*============================================================================*\
  * _DMA_DMAGSCR_GET and _DMA_DMAGSCR_SET
  \*============================================================================*/
  #define _DMA_DMAGSCR_GET(RegAddr)  		_PREG_GET(RegAddr)
  #define _DMA_DMAGSCR_SET(RegAddr,Val)   	_PREG_SET(RegAddr,Val)
#endif


/*============================================================================*\
*  DMA Channel #0 Channel Control Registers
\*============================================================================*/
#define _DMA_DMACSDP0_ADDR				(0x0C00u)
#define _DMA_DMACSDP0                       	PREG16(_DMA_DMACSDP0_ADDR)
#define DMA_DMACSDP0                            _DMA_DMACSDP0

#define _DMA_DMACCR0_ADDR				(0x0C01u)
#define _DMA_DMACCR0                      	PREG16(_DMA_DMACCR0_ADDR)
#define DMA_DMACCR0                             _DMA_DMACCR0

#define _DMA_DMACICR0_ADDR				(0x0C02u)
#define _DMA_DMACICR0                      	PREG16(_DMA_DMACICR0_ADDR)
#define DMA_DMACICR0                            _DMA_DMACICR0

#define _DMA_DMACSR0_ADDR				(0x0C03u)
#define _DMA_DMACSR0                      	PREG16(_DMA_DMACSR0_ADDR)
#define DMA_DMACSR0                            _DMA_DMACSR0

#define _DMA_DMACSSAL0_ADDR		   	     (0x0C04u)
#define _DMA_DMACSSAL0                         PREG16(_DMA_DMACSSAL0_ADDR)
#define DMA_DMACSSAL0                          _DMA_DMACSSAL0

#define _DMA_DMACSSAU0_ADDR                    (0x0C05)
#define _DMA_DMACSSAU0                          PREG16(_DMA_DMACSSAU0_ADDR)
#define DMA_DMACSSAU0                           _DMA_DMACSSAU0

#define _DMA_DMACDSAL0_ADDR                    (0x0C06u)
#define _DMA_DMACDSAL0                         PREG16(_DMA_DMACDSAL0_ADDR)
#define DMA_DMACDSAL0                          _DMA_DMACDSAL0

#define _DMA_DMACDSAU0_ADDR                    (0x0C07u)
#define _DMA_DMACDSAU0                         PREG16(_DMA_DMACDSAU0_ADDR)
#define DMA_DMACDSAU0                          _DMA_DMACDSAU0

#define _DMA_DMACEN0_ADDR                     (0x0C08u)
#define _DMA_DMACEN0                          PREG16(_DMA_DMACEN0_ADDR)
#define DMA_DMACEN0                           _DMA_DMACEN0

#define _DMA_DMACFN0_ADDR                     (0x0C09u)
#define _DMA_DMACFN0                           PREG16(_DMA_DMACFN0_ADDR)
#define DMA_DMACFN0                            _DMA_DMACFN0

#define _DMA_DMACFI0_ADDR                     (0x0C0Au)
#define _DMA_DMACFI0                          PREG16(_DMA_DMACFI0_ADDR)
#define DMA_DMACFI0                           _DMA_DMACFI0

#define _DMA_DMACEI0_ADDR                     (0x0C0Bu)
#define _DMA_DMACEI0                          PREG16(_DMA_DMACEI0_ADDR)
#define DMA_DMACEI0                           _DMA_DMACEI0

#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  #define _DMA_DMACSFI0_ADDR                     (0x0C0Au)
  #define _DMA_DMACSFI0                          PREG16(_DMA_DMACSFI0_ADDR)
  #define DMA_DMACSFI0                           _DMA_DMACFI0

  #define _DMA_DMACSEI0_ADDR                     (0x0C0Bu)
  #define _DMA_DMACSEI0                          PREG16(_DMA_DMACSEI0_ADDR)
  #define DMA_DMACSEI0                           _DMA_DMACSEI0

  #define _DMA_DMACDFI0_ADDR                     (0x0C0Fu)
  #define _DMA_DMACDFI0                          PREG16(_DMA_DMACSFI0_ADDR)
  #define DMA_DMACDFI0                           _DMA_DMACFI0

  #define _DMA_DMACDEI0_ADDR                     (0x0C0Eu)
  #define _DMA_DMACDEI0                          PREG16(_DMA_DMACDEI0_ADDR)
  #define DMA_DMACDEI0                           _DMA_DMACDEI0

  #define _DMA_DMACDAC0_ADDR                     (0x0C0Du)
  #define _DMA_DMACDAC0                           PREG16(_DMA_DMACDAC0_ADDR)
  #define DMA_DMACDAC0                            _DMA_DMACDAC0

  #define _DMA_DMACSAC0_ADDR                     (0x0C0Cu)
  #define _DMA_DMACSAC0                           PREG16(_DMA_DMACSAC0_ADDR)
  #define DMA_DMACSAC0                            _DMA_DMACSAC0
#endif

/*============================================================================*\
*  DMA Channel #1 Channel Control Registers
\*============================================================================*/
#define _DMA_DMACSDP1_ADDR				(0x0C20u)
#define _DMA_DMACSDP1                       	PREG16(_DMA_DMACSDP1_ADDR)
#define DMA_DMACSDP1                            _DMA_DMACSDP1

#define _DMA_DMACCR1_ADDR				(0x0C21u)
#define _DMA_DMACCR1                      	PREG16(_DMA_DMACCR1_ADDR)
#define DMA_DMACCR1                             _DMA_DMACCR1

#define _DMA_DMACICR1_ADDR				(0x0C22u)
#define _DMA_DMACICR1                      	PREG16(_DMA_DMACICR1_ADDR)
#define DMA_DMACICR1                            _DMA_DMACICR1

#define _DMA_DMACSR1_ADDR				(0x0C23u)
#define _DMA_DMACSR1                      	PREG16(_DMA_DMACSR1_ADDR)
#define DMA_DMACSR1                             _DMA_DMACSR1

#define _DMA_DMACSSAL1_ADDR			      (0x0C24u)
#define _DMA_DMACSSAL1                          PREG16(_DMA_DMACSSAL1_ADDR)
#define DMA_DMACSSAL1                           _DMA_DMACSSAL1

#define _DMA_DMACSSAU1_ADDR			      (0x0C25)
#define _DMA_DMACSSAU1                     	PREG16(_DMA_DMACSSAU1_ADDR)
#define DMA_DMACSSAU1                           _DMA_DMACSSAU1

#define _DMA_DMACDSAL1_ADDR			      (0x0C26u)
#define _DMA_DMACDSAL1                          PREG16(_DMA_DMACDSAL1_ADDR)
#define DMA_DMACDSAL1                           _DMA_DMACDSAL1

#define _DMA_DMACDSAU1_ADDR			      (0x0C27u)
#define _DMA_DMACDSAU1                     	PREG16(_DMA_DMACDSAU1_ADDR)
#define DMA_DMACDSAU1                           _DMA_DMACDSAU1

#define _DMA_DMACEN1_ADDR			      (0x0C28u)
#define _DMA_DMACEN1                     	      PREG16(_DMA_DMACEN1_ADDR)
#define DMA_DMACEN1                             _DMA_DMACEN1

#define _DMA_DMACFN1_ADDR			      (0x0C29u)
#define _DMA_DMACFN1                     	      PREG16(_DMA_DMACFN1_ADDR)
#define DMA_DMACFN1                             _DMA_DMACFN1

#define _DMA_DMACFI1_ADDR			      (0x0C2Au)
#define _DMA_DMACFI1                     	      PREG16(_DMA_DMACFI1_ADDR)
#define DMA_DMACFI1                             _DMA_DMACFI1

#define _DMA_DMACEI1_ADDR			      (0x0C2Bu)
#define _DMA_DMACEI1                     	      PREG16(_DMA_DMACEI1_ADDR)
#define DMA_DMACEI1                             _DMA_DMACEI1

#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  #define _DMA_DMACSFI1_ADDR                     (0x0C2Au)
  #define _DMA_DMACSFI1                          PREG16(_DMA_DMACSFI1_ADDR)
  #define DMA_DMACSFI1                           _DMA_DMACFI1

  #define _DMA_DMACSEI1_ADDR                     (0x0C2Bu)
  #define _DMA_DMACSEI1                          PREG16(_DMA_DMACSEI1_ADDR)
  #define DMA_DMACSEI1                           _DMA_DMACSEI1

  #define _DMA_DMACDFI1_ADDR                     (0x0C2Fu)
  #define _DMA_DMACDFI1                          PREG16(_DMA_DMACSFI1_ADDR)
  #define DMA_DMACDFI1                           _DMA_DMACFI1

  #define _DMA_DMACDEI1_ADDR                     (0x0C2Eu)
  #define _DMA_DMACDEI1                          PREG16(_DMA_DMACDEI1_ADDR)
  #define DMA_DMACDEI1                           _DMA_DMACDEI1

  #define _DMA_DMACDAC1_ADDR                     (0x0C2Du)
  #define _DMA_DMACDAC1                           PREG16(_DMA_DMACDAC1_ADDR)
  #define DMA_DMACDAC1                           _DMA_DMACDAC1

  #define _DMA_DMACSAC1_ADDR                      (0x0C2Cu)
  #define _DMA_DMACSAC1                           PREG16(_DMA_DMACSAC1_ADDR)
  #define DMA_DMACSAC1                           _DMA_DMACSAC1
#endif

/*============================================================================*\
*  DMA Channel #2 Channel Control Registers
\*============================================================================*/
#define _DMA_DMACSDP2_ADDR				(0x0C40u)
#define _DMA_DMACSDP2                       	PREG16(_DMA_DMACSDP2_ADDR)
#define DMA_DMACSDP2                            _DMA_DMACSDP2

#define _DMA_DMACCR2_ADDR				(0x0C41u)
#define _DMA_DMACCR2                      	PREG16(_DMA_DMACCR2_ADDR)
#define DMA_DMACCR2                             _DMA_DMACCR2

#define _DMA_DMACICR2_ADDR				(0x0C42u)
#define _DMA_DMACICR2                      	PREG16(_DMA_DMACICR2_ADDR)
#define DMA_DMACICR2                            _DMA_DMACICR2

#define _DMA_DMACSR2_ADDR				(0x0C43u)
#define _DMA_DMACSR2                      	PREG16(_DMA_DMACSR2_ADDR)
#define DMA_DMACSR2                             _DMA_DMACSR2

#define _DMA_DMACSSAL2_ADDR			      (0x0C44u)
#define _DMA_DMACSSAL2                          PREG16(_DMA_DMACSSAL2_ADDR)
#define DMA_DMACSSAL2                           _DMA_DMACSSAL2

#define _DMA_DMACSSAU2_ADDR			      (0x0C45)
#define _DMA_DMACSSAU2                     	PREG16(_DMA_DMACSSAU2_ADDR)
#define DMA_DMACSSAU2                           _DMA_DMACSSAU2

#define _DMA_DMACDSAL2_ADDR			      (0x0C46u)
#define _DMA_DMACDSAL2                          PREG16(_DMA_DMACDSAL2_ADDR)
#define DMA_DMACDSAL2                           _DMA_DMACDSAL2

#define _DMA_DMACDSAU2_ADDR			      (0x0C47u)
#define _DMA_DMACDSAU2                     	PREG16(_DMA_DMACDSAU2_ADDR)
#define DMA_DMACDSAU2                           _DMA_DMACDSAU2

#define _DMA_DMACEN2_ADDR			      (0x0C48u)
#define _DMA_DMACEN2                     	      PREG16(_DMA_DMACEN2_ADDR)
#define DMA_DMACEN2                             _DMA_DMACEN2

#define _DMA_DMACFN2_ADDR			      (0x0C49u)
#define _DMA_DMACFN2                     	      PREG16(_DMA_DMACFN2_ADDR)
#define DMA_DMACFN2                             _DMA_DMACFN2

#define _DMA_DMACFI2_ADDR			      (0x0C4Au)
#define _DMA_DMACFI2                     	      PREG16(_DMA_DMACFI2_ADDR)
#define DMA_DMACFI2                             _DMA_DMACFI2

#define _DMA_DMACEI2_ADDR			      (0x0C4Bu)
#define _DMA_DMACEI2                     	      PREG16(_DMA_DMACEI2_ADDR)
#define DMA_DMACEI2                             _DMA_DMACEI2

#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  #define _DMA_DMACSFI2_ADDR                    (0x0C4Au)
  #define _DMA_DMACSFI2                         PREG16(_DMA_DMACSFI2_ADDR)
  #define DMA_DMACSFI2                          _DMA_DMACFI2

  #define _DMA_DMACSEI2_ADDR                    (0x0C4Bu)
  #define _DMA_DMACSEI2                         PREG16(_DMA_DMACSEI2_ADDR)
  #define DMA_DMACSEI2                          _DMA_DMACSEI2

  #define _DMA_DMACDFI2_ADDR                    (0x0C4Fu)
  #define _DMA_DMACDFI2                         PREG16(_DMA_DMACSFI2_ADDR)
  #define DMA_DMACDFI2                          _DMA_DMACFI2

  #define _DMA_DMACDEI2_ADDR                    (0x0C4Eu)
  #define _DMA_DMACDEI2                         PREG16(_DMA_DMACDEI2_ADDR)
  #define DMA_DMACDEI2                          _DMA_DMACDEI2

  #define _DMA_DMACDAC2_ADDR                    (0x0C4Du)
  #define _DMA_DMACDAC2                         PREG16(_DMA_DMACDAC2_ADDR)
  #define DMA_DMACDAC2                          _DMA_DMACDAC2

  #define _DMA_DMACSAC2_ADDR                    (0x0C4Cu)
  #define _DMA_DMACSAC2                         PREG16(_DMA_DMACSAC2_ADDR)
  #define DMA_DMACSAC2                          _DMA_DMACSAC2
#endif


/*============================================================================*\
*  DMA Channel #3 Channel Control Registers
\*============================================================================*/
#define _DMA_DMACSDP3_ADDR				(0x0C60u)
#define _DMA_DMACSDP3                       	PREG16(_DMA_DMACSDP3_ADDR)
#define DMA_DMACSDP3                            _DMA_DMACSDP3

#define _DMA_DMACCR3_ADDR				(0x0C61u)
#define _DMA_DMACCR3                      	PREG16(_DMA_DMACCR3_ADDR)
#define DMA_DMACCR3                             _DMA_DMACCR3

#define _DMA_DMACICR3_ADDR				(0x0C62u)
#define _DMA_DMACICR3                      	PREG16(_DMA_DMACICR2_ADDR)
#define DMA_DMACICR3                            _DMA_DMACICR3

#define _DMA_DMACSR3_ADDR				(0x0C63u)
#define _DMA_DMACSR3                      	PREG16(_DMA_DMACSR3_ADDR)
#define DMA_DMACSR3                             _DMA_DMACSR3

#define _DMA_DMACSSAL3_ADDR			      (0x0C64u)
#define _DMA_DMACSSAL3                          PREG16(_DMA_DMACSSAL3_ADDR)
#define DMA_DMACSSAL3                           _DMA_DMACSSAL3

#define _DMA_DMACSSAU3_ADDR			      (0x0C65)
#define _DMA_DMACSSAU3                     	PREG16(_DMA_DMACSSAU3_ADDR)
#define DMA_DMACSSAU3                           _DMA_DMACSSAU3

#define _DMA_DMACDSAL3_ADDR			      (0x0C66u)
#define _DMA_DMACDSAL3                          PREG16(_DMA_DMACDSAL3_ADDR)
#define DMA_DMACDSAL3                           _DMA_DMACDSAL3

#define _DMA_DMACDSAU3_ADDR			      (0x0C67u)
#define _DMA_DMACDSAU3                     	PREG16(_DMA_DMACDSAU3_ADDR)
#define DMA_DMACDSAU3                           _DMA_DMACDSAU3

#define _DMA_DMACEN3_ADDR			      (0x0C68u)
#define _DMA_DMACEN3                     	      PREG16(_DMA_DMACEN3_ADDR)
#define DMA_DMACEN3                             _DMA_DMACEN3

#define _DMA_DMACFN3_ADDR			      (0x0C69u)
#define _DMA_DMACFN3                     	      PREG16(_DMA_DMACFN3_ADDR)
#define DMA_DMACFN3                             _DMA_DMACFN3

#define _DMA_DMACFI3_ADDR			      (0x0C6Au)
#define _DMA_DMACFI3                     	      PREG16(_DMA_DMACFI3_ADDR)
#define DMA_DMACFI3                             _DMA_DMACFI3

#define _DMA_DMACEI3_ADDR			      (0x0C6Bu)
#define _DMA_DMACEI3                     	      PREG16(_DMA_DMACEI3_ADDR)
#define DMA_DMACEI3                             _DMA_DMACEI3

#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  #define _DMA_DMACSFI3_ADDR                    (0x0C6Au)
  #define _DMA_DMACSFI3                         PREG16(_DMA_DMACSFI3_ADDR)
  #define DMA_DMACSFI3                          _DMA_DMACFI3

  #define _DMA_DMACSEI3_ADDR                    (0x0C6Bu)
  #define _DMA_DMACSEI3                         PREG16(_DMA_DMACSEI3_ADDR)
  #define DMA_DMACSEI3                          _DMA_DMACSEI3

  #define _DMA_DMACDFI3_ADDR                    (0x0C6Fu)
  #define _DMA_DMACDFI3                         PREG16(_DMA_DMACSFI3_ADDR)
  #define DMA_DMACDFI3                          _DMA_DMACFI3

  #define _DMA_DMACDEI3_ADDR                    (0x0C6Eu)
  #define _DMA_DMACDEI3                         PREG16(_DMA_DMACDEI3_ADDR)
  #define DMA_DMACDEI3                          _DMA_DMACDEI3

  #define _DMA_DMACDAC3_ADDR                    (0x0C6Du)
  #define _DMA_DMACDAC3                         PREG16(_DMA_DMACDAC3_ADDR)
  #define DMA_DMACDAC3                          _DMA_DMACDAC3

  #define _DMA_DMACSAC3_ADDR                    (0x0C6Cu)
  #define _DMA_DMACSAC3                         PREG16(_DMA_DMACSAC3_ADDR)
  #define DMA_DMACSAC3                          _DMA_DMACSAC3
#endif

/*============================================================================*\
*  DMA Channel #4 Channel Control Registers
\*============================================================================*/
#define _DMA_DMACSDP4_ADDR				(0x0C80u)
#define _DMA_DMACSDP4                       	PREG16(_DMA_DMACSDP4_ADDR)
#define DMA_DMACSDP4                            _DMA_DMACSDP4

#define _DMA_DMACCR4_ADDR				(0x0C81u)
#define _DMA_DMACCR4                      	PREG16(_DMA_DMACCR4_ADDR)
#define DMA_DMACCR4                             _DMA_DMACCR4

#define _DMA_DMACICR4_ADDR				(0x0C82u)
#define _DMA_DMACICR4                      	PREG16(_DMA_DMACICR2_ADDR)
#define DMA_DMACICR4                            _DMA_DMACICR4

#define _DMA_DMACSR4_ADDR				(0x0C83u)
#define _DMA_DMACSR4                      	PREG16(_DMA_DMACSR4_ADDR)
#define DMA_DMACSR4                             _DMA_DMACSR4

#define _DMA_DMACSSAL4_ADDR			      (0x0C84u)
#define _DMA_DMACSSAL4                          PREG16(_DMA_DMACSSAL4_ADDR)
#define DMA_DMACSSAL4                           _DMA_DMACSSAL4

#define _DMA_DMACSSAU4_ADDR			      (0x0C85u)
#define _DMA_DMACSSAU4                     	PREG16(_DMA_DMACSSAU4_ADDR)
#define DMA_DMACSSAU4                           _DMA_DMACSSAU4

#define _DMA_DMACDSAL4_ADDR			      (0x0C86u)
#define _DMA_DMACDSAL4                          PREG16(_DMA_DMACDSAL4_ADDR)
#define DMA_DMACDSAL4                           _DMA_DMACDSAL4

#define _DMA_DMACDSAU4_ADDR			      (0x0C87u)
#define _DMA_DMACDSAU4                     	PREG16(_DMA_DMACDSAU4_ADDR)
#define DMA_DMACDSAU4                           _DMA_DMACDSAU4

#define _DMA_DMACEN4_ADDR			      (0x0C88u)
#define _DMA_DMACEN4                     	      PREG16(_DMA_DMACEN4_ADDR)
#define DMA_DMACEN4                             _DMA_DMACEN4

#define _DMA_DMACFN4_ADDR			      (0x0C89u)
#define _DMA_DMACFN4                     	      PREG16(_DMA_DMACFN4_ADDR)
#define DMA_DMACFN4                             _DMA_DMACFN4

#define _DMA_DMACFI4_ADDR			      (0x0C8Au)
#define _DMA_DMACFI4                     	      PREG16(_DMA_DMACFI4_ADDR)
#define DMA_DMACFI4                             _DMA_DMACFI4

#define _DMA_DMACEI4_ADDR			      (0x0C8Bu)
#define _DMA_DMACEI4                     	       PREG16(_DMA_DMACEI4_ADDR)
#define DMA_DMACEI4                              _DMA_DMACEI4

#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  #define _DMA_DMACSFI4_ADDR                    (0x0C8Au)
  #define _DMA_DMACSFI4                         PREG16(_DMA_DMACSFI4_ADDR)
  #define DMA_DMACSFI4                          _DMA_DMACFI4

  #define _DMA_DMACSEI4_ADDR                    (0x0C8Bu)
  #define _DMA_DMACSEI4                         PREG16(_DMA_DMACSEI4_ADDR)
  #define DMA_DMACSEI4                          _DMA_DMACSEI4

  #define _DMA_DMACDFI4_ADDR                    (0x0C8Fu)
  #define _DMA_DMACDFI4                         PREG16(_DMA_DMACSFI4_ADDR)
  #define DMA_DMACDFI4                          _DMA_DMACFI4

  #define _DMA_DMACDEI4_ADDR                    (0x0C8Eu)
  #define _DMA_DMACDEI4                         PREG16(_DMA_DMACDEI4_ADDR)
  #define DMA_DMACDEI4                          _DMA_DMACDEI4

  #define _DMA_DMACDAC4_ADDR                    (0x0C8Du)
  #define _DMA_DMACDAC4                         PREG16(_DMA_DMACDAC4_ADDR)
  #define DMA_DMACDAC4                          _DMA_DMACDAC4

  #define _DMA_DMACSAC4_ADDR                    (0x0C8Cu)
  #define _DMA_DMACSAC4                         PREG16(_DMA_DMACSAC4_ADDR)
  #define DMA_DMACSAC4                          _DMA_DMACSAC4
#endif

/*============================================================================*\
*  DMA Channel #5 Channel Control Registers
\*============================================================================*/
#define _DMA_DMACSDP5_ADDR			(0x0CA0u)
#define _DMA_DMACSDP5                     PREG16(_DMA_DMACSDP5_ADDR)
#define DMA_DMACSDP5                      _DMA_DMACSDP5

#define _DMA_DMACCR5_ADDR			(0x0CA1u)
#define _DMA_DMACCR5                      PREG16(_DMA_DMACCR5_ADDR)
#define DMA_DMACCR5                       _DMA_DMACCR5

#define _DMA_DMACICR5_ADDR			(0x0CA2u)
#define _DMA_DMACICR5                     PREG16(_DMA_DMACICR2_ADDR)
#define DMA_DMACICR5                       _DMA_DMACICR5

#define _DMA_DMACSR5_ADDR			(0x0CA3u)
#define _DMA_DMACSR5                       PREG16(_DMA_DMACSR5_ADDR)
#define DMA_DMACSR5                        _DMA_DMACSR5

#define _DMA_DMACSSAL5_ADDR			(0x0CA4u)
#define _DMA_DMACSSAL5                      PREG16(_DMA_DMACSSAL5_ADDR)
#define DMA_DMACSSAL5                       _DMA_DMACSSAL5

#define _DMA_DMACSSAU5_ADDR			(0x0CA5)
#define _DMA_DMACSSAU5                     	PREG16(_DMA_DMACSSAU5_ADDR)
#define DMA_DMACSSAU5                       _DMA_DMACSSAU5

#define _DMA_DMACDSAL5_ADDR			(0x0CA6u)
#define _DMA_DMACDSAL5                      PREG16(_DMA_DMACDSAL5_ADDR)
#define DMA_DMACDSAL5                       _DMA_DMACDSAL5

#define _DMA_DMACDSAU5_ADDR			(0x0CA7u)
#define _DMA_DMACDSAU5                     	PREG16(_DMA_DMACDSAU5_ADDR)
#define DMA_DMACDSAU5                       _DMA_DMACDSAU5

#define _DMA_DMACEN5_ADDR			      (0x0CA8u)
#define _DMA_DMACEN5                     	PREG16(_DMA_DMACEN5_ADDR)
#define DMA_DMACEN5                          _DMA_DMACEN5

#define _DMA_DMACFN5_ADDR			      (0x0CA9u)
#define _DMA_DMACFN5                     	PREG16(_DMA_DMACFN5_ADDR)
#define DMA_DMACFN5                          _DMA_DMACFN5

#define _DMA_DMACFI5_ADDR			      (0x0CAAu)
#define _DMA_DMACFI5                     	PREG16(_DMA_DMACFI5_ADDR)
#define DMA_DMACFI5                          _DMA_DMACFI5

#define _DMA_DMACEI5_ADDR			      (0x0CABu)
#define _DMA_DMACEI5                     	PREG16(_DMA_DMACEI5_ADDR)
#define DMA_DMACEI5                          _DMA_DMACEI5

#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  #define _DMA_DMACSFI5_ADDR                    (0x0CAAu)
  #define _DMA_DMACSFI5                         PREG16(_DMA_DMACSFI5_ADDR)
  #define DMA_DMACSFI5                          _DMA_DMACFI5

  #define _DMA_DMACSEI5_ADDR                    (0x0CABu)
  #define _DMA_DMACSEI5                         PREG16(_DMA_DMACSEI5_ADDR)
  #define DMA_DMACSEI5                          _DMA_DMACSEI5

  #define _DMA_DMACDFI5_ADDR                    (0x0CAFu)
  #define _DMA_DMACDFI5                         PREG16(_DMA_DMACSFI5_ADDR)
  #define DMA_DMACDFI5                          _DMA_DMACFI5

  #define _DMA_DMACDEI5_ADDR                    (0x0CAEu)
  #define _DMA_DMACDEI5                         PREG16(_DMA_DMACDEI5_ADDR)
  #define DMA_DMACDEI5                          _DMA_DMACDEI5

  #define _DMA_DMACDAC5_ADDR                    (0x0CADu)
  #define _DMA_DMACDAC5                         PREG16(_DMA_DMACDAC5_ADDR)
  #define DMA_DMACDAC5                          _DMA_DMACDAC5

  #define _DMA_DMACSAC5_ADDR                    (0x0CACu)
  #define _DMA_DMACSAC5                         PREG16(_DMA_DMACSAC5_ADDR)
  #define DMA_DMACSAC5                          _DMA_DMACSAC5
#endif


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _DMA_DMAGCR	   - Global Control Register
*
* Fields:
*  (RW) _DMA_DMAGCR_FREE
*  (RW) _DMA_DMAGCR_EHPIEXCL
*  (RW) _DMA_DMAGCR_EHPIPRIO
*  IF C550 PG2
*  (RW) _DMA_DMAGCR_AUTOGATING
*  
\*============================================================================*/

#if _DMA_DST_AND_SRC_INDEX_SUPPORT
  /*==========================================================================*\
  * (RW) _DMA_DMAGCR_AUTOGATING
  \*--------------------------------------------------------------------------*/
  #define _DMA_DMAGCR_AUTOGATING_SHIFT	 	(0x0003u)
  #define _DMA_DMAGCR_AUTOGATING_MK(n)            (((Uint16)(n) & 0x0001u) << _DMA_DMAGCR_AUTOGATING_SHIFT)
  #define _DMA_DMAGCR_AUTOGATING_MASK             (_DMA_DMAGCR_AUTOGATING_MK(0x0001u))
  #define _DMA_DMAGCR_AUTOGATING_CLR              (~(_DMA_DMAGCR_AUTOGATING_MASK))
#endif

/*==========================================================================*\
* (RW) _DMA_DMAGCR_FREE
\*--------------------------------------------------------------------------*/
#define _DMA_DMAGCR_FREE_SHIFT	 	(0x0002u)
#define _DMA_DMAGCR_FREE_MK(n)            (((Uint16)(n) & 0x0001u) << _DMA_DMAGCR_FREE_SHIFT)
#define _DMA_DMAGCR_FREE_MASK             (_DMA_DMAGCR_FREE_MK(0x0001u))
#define _DMA_DMAGCR_FREE_CLR              (~(_DMA_DMAGCR_FREE_MASK))

#if (!CHIP_5502)
/*==========================================================================*\
* (RW) _DMA_DMAGCR_EHPIEXCL
\*--------------------------------------------------------------------------*/
#define _DMA_DMAGCR_EHPIEXCL_SHIFT		(0x0001u)
#define _DMA_DMAGCR_EHPIEXCL_MK(n)           (((Uint16)(n) & 0x0001u) << _DMA_DMAGCR_EHPIEXCL_SHIFT)
#define _DMA_DMAGCR_EHPIEXCL_MASK            (_DMA_DMAGCR_EHPIEXCL_MK(0x0001u))
#define _DMA_DMAGCR_EHPIEXCL_CLR             (~(_DMA_DMAGCR_EHPIEXCL_MASK))

/*==========================================================================*\
* (RW) _DMA_DMAGCR_EHPIPRIO
\*--------------------------------------------------------------------------*/
#define _DMA_DMAGCR_EHPIPRIO_SHIFT		(0x0000u)
#define _DMA_DMAGCR_EHPIPRIO_MK(n)           (((Uint16)(n) & 0x0001u) << _DMA_DMAGCR_EHPIPRIO_SHIFT)
#define _DMA_DMAGCR_EHPIPRIO_MASK            (_DMA_DMAGCR_EHPIPRIO_MK(0x0001u))
#define _DMA_DMAGCR_EHPIPRIO_CLR             (~(_DMA_DMAGCR_EHPIPRIO_MASK))

  #if (_DMA_DST_AND_SRC_INDEX_SUPPORT)
    #define _DMA_DMAGCR_CFG(autogate,free, excl, prio)\
       _PREG_SET(_DMA_DMAGCR_ADDR,\
                 (Uint16)(_DMA_DMAGCR_AUTOGATING_MK(autogate)\
                          _DMA_DMAGCR_FREE_MK(free)     |\
                          _DMA_DMAGCR_EHPIEXCL_MK(excl) |\
                          _DMA_DMAGCR_EHPIPRIO_MK(prio)\
                         )\
       ) 
  #else
    #define _DMA_DMAGCR_CFG(free, excl, prio)\
       _PREG_SET(_DMA_DMAGCR_ADDR,\
                 (Uint16)(_DMA_DMAGCR_FREE_MK(free)     |\
                          _DMA_DMAGCR_EHPIEXCL_MK(excl) |\
                          _DMA_DMAGCR_EHPIPRIO_MK(prio)\
                         )\
       )
  #endif
#else
  #define _DMA_DMAGCR_CFG(autogate,free)\
     _PREG_SET(_DMA_DMAGCR_ADDR,\
               (Uint16)(_DMA_DMAGCR_AUTOGATING_MK(autogate)|\
                        _DMA_DMAGCR_FREE_MK(free)\
                       )\
     )
#endif     // (!CHIP_5502)


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _DMA_DMAGSCR	   - Global Software Compatability Register
*
* Fields:
*  (RW) _DMA_DMAGSCR_COMPMODE
*  
\*============================================================================*/

#if ((_DMA_DST_AND_SRC_INDEX_SUPPORT) && (!CHIP_5502))
  /*==========================================================================*\
  * (RW) _DMA_DMAGSCR_SWMODE
  \*--------------------------------------------------------------------------*/
  #define _DMA_DMAGSCR_COMPMODE_SHIFT	 	(0x0003u)
  #define _DMA_DMAGSCR_COMPMODE_MK(n)            (((Uint16)(n) & 0x0001u) << _DMA_DMAGSCR_COMPMODE_SHIFT)
  #define _DMA_DMAGSCR_COMPMODE_MASK             (_DMA_DMAGSCR_COMPMODE_MK(0x0001u))
  #define _DMA_DMAGSCR_COMPMODE_CLR              (~(_DMA_DMAGSCR_COMPMODE_MASK))

  #define _DMA_DMAGSCR_SWMODE_SHIFT	 	      (0x0003u)
  #define _DMA_DMAGSCR_SWMODE_MK(n)             (((Uint16)(n) & 0x0001u) << _DMA_DMAGSCR_SWMODE_SHIFT)
  #define _DMA_DMAGSCR_SWMODE_MASK              (_DMA_DMAGSCR_SWMODE_MK(0x0001u))
  #define _DMA_DMAGSCR_SWMODE_CLR               (~(_DMA_DMAGSCR_SWMODE_MASK))


  #define _DMA_DMAGSCR_CFG(mode)\
     _PREG_SET(_DMA_DMAGCR_ADDR,(Uint16)(_DMA_DMAGSCR_COMPMODE_MK(mode)))

#endif



/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _DMA_DMAGTCR	   - Global Timeout Control Register
*
* Fields:
* IF 5502 
*  (RW) _DMA_DMAGTCR_ITE0
*  (RW) _DMA_DMAGTCR_ITE1
*  (RW) _DMA_DMAGTCR_ETE
*  (RW) _DMA_DMAGTCR_PTE
* ELSE
*  (RW) _DMA_DMAGTCR_STCE
*  (RW) _DMA_DMAGTCR_DTCE
\*============================================================================*/

#if (_DMA_DST_AND_SRC_INDEX_SUPPORT)
  #if (CHIP_5502)

    /*==========================================================================*\
    * (RW) _DMA_DMAGTCR_ITE0
    \*--------------------------------------------------------------------------*/
    #define _DMA_DMAGTCR_ITE0_SHIFT	 	  (0x0000u)
    #define _DMA_DMAGTCR_ITE0_MK(n)               (((Uint16)(n) & 0x0001u) << _DMA_DMAGTCR_ITE0_SHIFT)
    #define _DMA_DMAGTCR_ITE0_MASK                (_DMA_DMAGTCR_ITE0_MK(0x0001u))
    #define _DMA_DMAGTCR_ITE0_CLR                 (~(_DMA_DMAGTCR_ITE0_MASK))
  
    /*==========================================================================*\
    * (RW) _DMA_DMAGTCR_ITE1
    \*--------------------------------------------------------------------------*/
    #define _DMA_DMAGTCR_ITE1_SHIFT	 	  (0x0001u)
    #define _DMA_DMAGTCR_ITE1_MK(n)               (((Uint16)(n) & 0x0001u) << _DMA_DMAGTCR_ITE1_SHIFT)
    #define _DMA_DMAGTCR_ITE1_MASK                (_DMA_DMAGTCR_ITE1_MK(0x0001u))
    #define _DMA_DMAGTCR_ITE1_CLR                 (~(_DMA_DMAGTCR_ITE1_MASK))
  
    /*==========================================================================*\
    * (RW) _DMA_DMAGTCR_ETE
    \*--------------------------------------------------------------------------*/
    #define _DMA_DMAGTCR_ETE_SHIFT	 	  (0x0002u)
    #define _DMA_DMAGTCR_ETE_MK(n)               (((Uint16)(n) & 0x0001u) << _DMA_DMAGTCR_ETE_SHIFT)
    #define _DMA_DMAGTCR_ETE_MASK                (_DMA_DMAGTCR_ETE_MK(0x0001u))
    #define _DMA_DMAGTCR_ETE_CLR                 (~(_DMA_DMAGTCR_ETE_MASK))
  
    /*==========================================================================*\
    * (RW) _DMA_DMAGTCR_PTE
    \*--------------------------------------------------------------------------*/
    #define _DMA_DMAGTCR_PTE_SHIFT	 	  (0x0003u)
    #define _DMA_DMAGTCR_PTE_MK(n)               (((Uint16)(n) & 0x0001u) << _DMA_DMAGTCR_PTE_SHIFT)
    #define _DMA_DMAGTCR_PTE_MASK                (_DMA_DMAGTCR_PTE_MK(0x0001u))
    #define _DMA_DMAGTCR_PTE_CLR                 (~(_DMA_DMAGTCR_PTE_MASK))
  
  	
    #define _DMA_DMAGTCR_CFG(pte,ete,ite1,ite0)\
       _PREG_SET(_DMA_DMAGTCR_ADDR,\
                 (Uint16)(_DMA_DMAGTCR_PTE_MK(pte)|\
			  _DMA_DMAGTCR_ETE_MK(ete)|\
			  _DMA_DMAGTCR_ITE1_MK(ite1)|\
                          _DMA_DMAGTCR_ITE0_MK(ite0)\
                         )\
       )

  #else	

    /*==========================================================================*\
    * (RW) _DMA_DMAGTCR_STCE
    \*--------------------------------------------------------------------------*/
    #define _DMA_DMAGTCR_STCE_SHIFT	 	(0x0000u)
    #define _DMA_DMAGTCR_STCE_MK(n)               (((Uint16)(n) & 0x0001u) << _DMA_DMAGTCR_STCE_SHIFT)
    #define _DMA_DMAGTCR_STCE_MASK                (_DMA_DMAGTCR_STCE_MK(0x0001u))
    #define _DMA_DMAGTCR_STCE_CLR                 (~(_DMA_DMAGTCR_STCE_MASK))
  
    /*==========================================================================*\
    * (RW) _DMA_DMAGTCR_DTCE
    \*--------------------------------------------------------------------------*/
    #define _DMA_DMAGTCR_DTCE_SHIFT	 	(0x0001u)
    #define _DMA_DMAGTCR_DTCE_MK(n)               (((Uint16)(n) & 0x0001u) << _DMA_DMAGTCR_DTCE_SHIFT)
    #define _DMA_DMAGTCR_DTCE_MASK                (_DMA_DMAGTCR_DTCE_MK(0x0001u))
    #define _DMA_DMAGTCR_DTCE_CLR                 (~(_DMA_DMAGTCR_DTCE_MASK))
  
  	
    #define _DMA_DMAGTCR_CFG(dtce,stce)\
       _PREG_SET(_DMA_DMAGTCR_ADDR,\
                 (Uint16)(_DMA_DMAGTCR_DTCE_MK(dtce)|\
                          _DMA_DMAGTCR_STCE_MK(stce)\
                         )\
       )
  
  #endif   

#endif


	
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _DMA_DMACSDPn	   - Channel #n Source Destination Parameters Register
*
* Fields:
*  (RW) _DMA_DMACSDP_DSTBEN
*  (RW) _DMA_DMACSDP_DSTPACK
*  (RW) _DMA_DMACSDP_DST
*  (RW) _DMA_DMACSDP_SRCBEN
*  (RW) _DMA_DMACSDP_SRCPACK
*  (RW) _DMA_DMACSDP_SRC
*  (RW) _DMA_DMACSDP_DATATYPE
\*============================================================================*/




/*==========================================================================*\
* (RW) _DMA_DMACSDP_DSTBEN
\*--------------------------------------------------------------------------*/
#define _DMA_DMACSDP_DSTBEN_SHIFT           (0x000Eu)
#define _DMA_DMACSDP_DSTBEN_MK(n)           (((Uint16)(n) & 0x0003u) << _DMA_DMACSDP_DSTBEN_SHIFT)
#define _DMA_DMACSDP_DSTBEN_MASK            (_DMA_DMACSDP_DSTBEN_MK(0x0003u))
#define _DMA_DMACSDP_DSTBEN_CLR             (~(_DMA_DMACSDP_DSTBEN_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACSDP_DSTPACK
\*--------------------------------------------------------------------------*/
#define _DMA_DMACSDP_DSTPACK_SHIFT          (0x000Du)
#define _DMA_DMACSDP_DSTPACK_MK(n)          (((Uint16)(n) & 0x0001u) << _DMA_DMACSDP_DSTPACK_SHIFT)
#define _DMA_DMACSDP_DSTPACK_MASK           (_DMA_DMACSDP_DSTPACK_MK(0x0001u))
#define _DMA_DMACSDP_DSTPACK_CLR            (~(_DMA_DMACSDP_DSTPACK_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACSDP_DST
\*--------------------------------------------------------------------------*/
#define _DMA_DMACSDP_DST_SHIFT              (0x0009u)
#define _DMA_DMACSDP_DST_MK(n)              (((Uint16)(n) & 0x000Fu) << _DMA_DMACSDP_DST_SHIFT)
#define _DMA_DMACSDP_DST_MASK               (_DMA_DMACSDP_DST_MK(0x000Fu))
#define _DMA_DMACSDP_DST_CLR                (~(_DMA_DMACSDP_DST_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACSDP_SRCBEN
\*--------------------------------------------------------------------------*/
#define _DMA_DMACSDP_SRCBEN_SHIFT           (0x0007u)
#define _DMA_DMACSDP_SRCBEN_MK(n)           (((Uint16)(n) & 0x0003u) << _DMA_DMACSDP_SRCBEN_SHIFT)
#define _DMA_DMACSDP_SRCBEN_MASK            (_DMA_DMACSDP_SRCBEN_MK(0x0003u))
#define _DMA_DMACSDP_SRCBEN_CLR             (~(_DMA_DMACSDP_SRCBEN_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACSDP_SRCPACK
\*--------------------------------------------------------------------------*/
#define _DMA_DMACSDP_SRCPACK_SHIFT          (0x0006u)
#define _DMA_DMACSDP_SRCPACK_MK(n)          (((Uint16)(n) & 0x0001u) << _DMA_DMACSDP_SRCPACK_SHIFT)
#define _DMA_DMACSDP_SRCPACK_MASK           (_DMA_DMACSDP_SRCPACK_MK(0x0001u))
#define _DMA_DMACSDP_SRCPACK_CLR            (~(_DMA_DMACSDP_SRCPACK_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACSDP_SRC
\*--------------------------------------------------------------------------*/
#define _DMA_DMACSDP_SRC_SHIFT              (0x0002u)
#define _DMA_DMACSDP_SRC_MK(n)              (((Uint16)(n) & 0x000Fu) << _DMA_DMACSDP_SRC_SHIFT)
#define _DMA_DMACSDP_SRC_MASK               (_DMA_DMACSDP_SRC_MK(0x000Fu))
#define _DMA_DMACSDP_SRC_CLR                (~(_DMA_DMACSDP_SRC_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACSDP_DATATYPE
\*--------------------------------------------------------------------------*/
#define _DMA_DMACSDP_DATATYPE_SHIFT          (0x0000u)
#define _DMA_DMACSDP_DATATYPE_MK(n)          (((Uint16)(n) & 0x0003u) << _DMA_DMACSDP_DATATYPE_SHIFT)
#define _DMA_DMACSDP_DATATYPE_MASK           (_DMA_DMACSDP_DATATYPE_MK(0x0003u))
#define _DMA_DMACSDP_DATATYPE_CLR            (~(_DMA_DMACSDP_DATATYPE_MASK))


#define _DMA_DMACSDP_CFG(Ch, dstben, dstpack, dst, srcben, srcpack, src, datatype)\
   _PREG_SET(_DMA_DMACDSP_ADDR(Ch),\
             (Uint16) ( _DMA_DMACSDP_DSTBEN_MK(dstben)        |\
                        _DMA_DMACSDP_DSTPACK_MK(dstpack)      |\
                        _DMA_DMACSDP_DST_MK(dst)              |\
                        _DMA_DMACSDP_SRCBEN_MK(srcben)        |\
                        _DMA_DMACSDP_SRCPACK_MK(srcpack)      |\
                        _DMA_DMACSDP_SRC_MK(src)              |\
                        _DMA_DMACSDP_DATATYPE_MK(datatype)    \
                      )\
   )

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _DMA_DMACCRn	   - Channel #n Channel Control Register
*
* Fields:
*  (RW) _DMA_DMACCR_DSTAMODE
*  (RW) _DMA_DMACCR_SRCAMODE
*  (RW) _DMA_DMACCR_ENDPROG
*  (RW) _DMA_DMACCR_WP
*  (RW) _DMA_DMACCR_REPEAT
*  (RW) _DMA_DMACCR_AUTOINIT
*  (RW) _DMA_DMACCR_EN
*  (RW) _DMA_DMACCR_PRIO
*  (RW) _DMA_DMACCR_FS
*  (RW) _DMA_DMACCR_SYNC
\*============================================================================*/

/*==========================================================================*\
* (RW) _DMA_DMACCR_DSTAMODE
\*--------------------------------------------------------------------------*/
#define _DMA_DMACCR_DSTAMODE_SHIFT           (0x000Eu)
#define _DMA_DMACCR_DSTAMODE_MK(n)           (((Uint16)(n) & 0x0003u) << _DMA_DMACCR_DSTAMODE_SHIFT)
#define _DMA_DMACCR_DSTAMODE_MASK            (_DMA_DMACCR_DSTAMODE_MK(0x0003u))
#define _DMA_DMACCR_DSTAMODE_CLR             (~(_DMA_DMACCR_DSTAMODE_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACCR_SRCAMODE
\*--------------------------------------------------------------------------*/
#define _DMA_DMACCR_SRCAMODE_SHIFT           (0x000Cu)
#define _DMA_DMACCR_SRCAMODE_MK(n)           (((Uint16)(n) & 0x0003u) << _DMA_DMACCR_SRCAMODE_SHIFT)
#define _DMA_DMACCR_SRCAMODE_MASK            (_DMA_DMACCR_SRCAMODE_MK(0x0003u))
#define _DMA_DMACCR_SRCAMODE_CLR             (~(_DMA_DMACCR_SRCAMODE_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACCR_ENDPROG
\*--------------------------------------------------------------------------*/
#define _DMA_DMACCR_ENDPROG_SHIFT            (0x000Bu)
#define _DMA_DMACCR_ENDPROG_MK(n)            (((Uint16)(n) & 0x0001u) << _DMA_DMACCR_ENDPROG_SHIFT)
#define _DMA_DMACCR_ENDPROG_MASK             (_DMA_DMACCR_ENDPROG_MK(0x0001u))
#define _DMA_DMACCR_ENDPROG_CLR              (~(_DMA_DMACCR_ENDPROG_MASK))

#if (CHIP_5502)
/*==========================================================================*\
* (RW) _DMA_DMACCR_WP
\*--------------------------------------------------------------------------*/
#define _DMA_DMACCR_WP_SHIFT                 (0x000Au)
#define _DMA_DMACCR_WP_MK(n)                 (((Uint16)(n) & 0x0001u) << _DMA_DMACCR_WP_SHIFT)
#define _DMA_DMACCR_WP_MASK                  (_DMA_DMACCR_WP_MK(0x0001u))
#define _DMA_DMACCR_WP_CLR                   (~(_DMA_DMACCR_WP_MASK))

#endif


   
/*==========================================================================*\
* (RW) _DMA_DMACCR_REPEAT
\*--------------------------------------------------------------------------*/
#define _DMA_DMACCR_REPEAT_SHIFT             (0x0009u)
#define _DMA_DMACCR_REPEAT_MK(n)             (((Uint16)(n) & 0x0001u) << _DMA_DMACCR_REPEAT_SHIFT)
#define _DMA_DMACCR_REPEAT_MASK              (_DMA_DMACCR_REPEAT_MK(0x0001u))
#define _DMA_DMACCR_REPEAT_CLR               (~(_DMA_DMACCR_REPEAT_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACCR_AUTOINIT
\*--------------------------------------------------------------------------*/
#define _DMA_DMACCR_AUTOINIT_SHIFT           (0x0008u)
#define _DMA_DMACCR_AUTOINIT_MK(n)           (((Uint16)(n) & 0x0001u) << _DMA_DMACCR_AUTOINIT_SHIFT)
#define _DMA_DMACCR_AUTOINIT_MASK            (_DMA_DMACCR_AUTOINIT_MK(0x0001u))
#define _DMA_DMACCR_AUTOINIT_CLR             (~(_DMA_DMACCR_AUTOINIT_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACCR_EN
\*--------------------------------------------------------------------------*/
#define _DMA_DMACCR_EN_SHIFT                 (0x0007u)
#define _DMA_DMACCR_EN_MK(n)                 (((Uint16)(n) & 0x0001u) << _DMA_DMACCR_EN_SHIFT)
#define _DMA_DMACCR_EN_MASK                  (_DMA_DMACCR_EN_MK(0x0001u))
#define _DMA_DMACCR_EN_CLR                   (~(_DMA_DMACCR_EN_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACCR_PRIO
\*--------------------------------------------------------------------------*/
#define _DMA_DMACCR_PRIO_SHIFT               (0x0006u)
#define _DMA_DMACCR_PRIO_MK(n)               (((Uint16)(n) & 0x0001u) << _DMA_DMACCR_PRIO_SHIFT)
#define _DMA_DMACCR_PRIO_MASK                (_DMA_DMACCR_PRIO_MK(0x0001u))
#define _DMA_DMACCR_PRIO_CLR                 (~(_DMA_DMACCR_PRIO_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACCR_FS
\*--------------------------------------------------------------------------*/
#define _DMA_DMACCR_FS_SHIFT                 (0x0005u)
#define _DMA_DMACCR_FS_MK(n)                 (((Uint16)(n) & 0x0001u) << _DMA_DMACCR_FS_SHIFT)
#define _DMA_DMACCR_FS_MASK                  (_DMA_DMACCR_FS_MK(0x0001u))
#define _DMA_DMACCR_FS_CLR                   (~(_DMA_DMACCR_FS_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACCR_SYNC
\*--------------------------------------------------------------------------*/
#define _DMA_DMACCR_SYNC_SHIFT               (0x0000u)
#define _DMA_DMACCR_SYNC_MK(n)               (((Uint16)(n) & 0x001Fu) << _DMA_DMACCR_SYNC_SHIFT)
#define _DMA_DMACCR_SYNC_MASK                (_DMA_DMACCR_SYNC_MK(0x001Fu))
#define _DMA_DMACCR_SYNC_CLR                 (~(_DMA_DMACCR_SYNC_MASK))

#if (CHIP_5502)

#define _DMA_DMACCR_CFG(Ch, dstamode, srcamode, endprog, wp, repeat, autoinit,\
                     en, prio, fs, sync)\
   _PREG_SET(_DMA_DMACCR_ADDR(Ch),\
             (Uint16) ( _DMA_DMACCR_DSTAMODE_MK(dstamode)      |\
                        _DMA_DMACCR_SRCAMODE_MK(srcamode)      |\
                        _DMA_DMACCR_ENDPROG_MK(endprog)        |\
                        _DMA_DMACCR_WP_MK(wp)                  |\
                        _DMA_DMACCR_REPEAT_MK(repeat)          |\
                        _DMA_DMACCR_AUTOINIT_MK(autoinit)      |\
                        _DMA_DMACCR_EN_MK(en)                  |\
                        _DMA_DMACCR_PRIO_MK(prio)              |\
                        _DMA_DMACCR_FS_MK(fs)                  |\
                        _DMA_DMACCR_SYNC_MK(sync)              \
                      )\
   )

#else
   
#define _DMA_DMACCR_CFG(Ch, dstamode, srcamode, endprog, repeat, autoinit,\
                     en, prio, fs, sync)\
   _PREG_SET(_DMA_DMACCR_ADDR(Ch),\
             (Uint16) ( _DMA_DMACCR_DSTAMODE_MK(dstamode)      |\
                        _DMA_DMACCR_SRCAMODE_MK(srcamode)      |\
                        _DMA_DMACCR_ENDPROG_MK(endprog)        |\
                        _DMA_DMACCR_REPEAT_MK(repeat)          |\
                        _DMA_DMACCR_AUTOINIT_MK(autoinit)      |\
                        _DMA_DMACCR_EN_MK(en)                  |\
                        _DMA_DMACCR_PRIO_MK(prio)              |\
                        _DMA_DMACCR_FS_MK(fs)                  |\
                        _DMA_DMACCR_SYNC_MK(sync)              \
                      )\
   )
#endif

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACICRn	   - Channel #n Channel Interrupt Control Register
*
* Fields:
*  (RW) _DMA_DMACICR_BLOCKIE
*  (RW) _DMA_DMACICR_LASTIE
*  (RW) _DMA_DMACICR_FRAMEIE
*  (RW) _DMA_DMACICR_HALFIE
*  (RW) _DMA_DMACICR_DROPIE
*  (RW) _DMA_DMACICR_TIMEOUTIE
\*========================================================================*/


/*========================================================================*\
* (RW) _DMA_DMACICR_BLOCKIE
\*------------------------------------------------------------------------*/
#define _DMA_DMACICR_BLOCKIE_SHIFT           (0x0005u)
#define _DMA_DMACICR_BLOCKIE_MK(n)           (((Uint16)(n) & 0x0001u) << _DMA_DMACICR_BLOCKIE_SHIFT)
#define _DMA_DMACICR_BLOCKIE_MASK            (_DMA_DMACICR_BLOCKIE_MK(0x0001u))
#define _DMA_DMACICR_BLOCKIE_CLR             (~(_DMA_DMACICR_BLOCKIE_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACICR_LASTIE
\*--------------------------------------------------------------------------*/
#define _DMA_DMACICR_LASTIE_SHIFT            (0x0004u)
#define _DMA_DMACICR_LASTIE_MK(n)            (((Uint16)(n) & 0x0001u) << _DMA_DMACICR_LASTIE_SHIFT)
#define _DMA_DMACICR_LASTIE_MASK             (_DMA_DMACICR_LASTIE_MK(0x0001u))
#define _DMA_DMACICR_LASTIE_CLR              (~(_DMA_DMACICR_LASTIE_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACICR_FRAMEIE
\*--------------------------------------------------------------------------*/
#define _DMA_DMACICR_FRAMEIE_SHIFT          (0x0003u)
#define _DMA_DMACICR_FRAMEIE_MK(n)          (((Uint16)(n) & 0x0001u) << _DMA_DMACICR_FRAMEIE_SHIFT)
#define _DMA_DMACICR_FRAMEIE_MASK           (_DMA_DMACICR_FRAMEIE_MK(0x0001u))
#define _DMA_DMACICR_FRAMEIE_CLR            (~(_DMA_DMACICR_FRAMEIE_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACICR_HALFIE
\*--------------------------------------------------------------------------*/
#define _DMA_DMACICR_HALFIE_SHIFT      (0x0002u)
#define _DMA_DMACICR_HALFIE_MK(n)      (((Uint16)(n) & 0x0001u) << _DMA_DMACICR_HALFIE_SHIFT)
#define _DMA_DMACICR_HALFIE_MASK       (_DMA_DMACICR_HALFIE_MK(0x0001u))
#define _DMA_DMACICR_HALFIE_CLR        (~(_DMA_DMACICR_HALFIE_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACICR_DROPIE
\*--------------------------------------------------------------------------*/
#define _DMA_DMACICR_DROPIE_SHIFT           (0x0001u)
#define _DMA_DMACICR_DROPIE_MK(n)           (((Uint16)(n) & 0x0001u) << _DMA_DMACICR_DROPIE_SHIFT)
#define _DMA_DMACICR_DROPIE_MASK            (_DMA_DMACICR_DROPIE_MK(0x0001u))
#define _DMA_DMACICR_DROPIE_CLR             (~(_DMA_DMACICR_DROPIE_MASK))

/*==========================================================================*\
* (RW) _DMA_DMACICR_TIMEOUTIE
\*--------------------------------------------------------------------------*/
#define _DMA_DMACICR_TIMEOUTIE_SHIFT        (0x0000u)
#define _DMA_DMACICR_TIMEOUTIE_MK(n)        (((Uint16)(n) & 0x0001u) << _DMA_DMACICR_TIMEOUTIE_SHIFT)
#define _DMA_DMACICR_TIMEOUTIE_MASK         (_DMA_DMACICR_TIMEOUTIE_MK(0x0001u))
#define _DMA_DMACICR_TIMEOUTIE_CLR          (~(_DMA_DMACICR_TIMEOUTIE_MASK))

#define _DMA_DMACICR_CFG(Ch, blockie, lastie, frameie, halfie, dropie, timeoutie)\
   _PREG_SET(_DMA_DMACICR_ADDR(Ch),\
             (Uint16) ( _DMA_DMACICR_BLOCKIE_MK(blockie)          |\
                        _DMA_DMACICR_LASTIE_MK(lastie)            |\
                        _DMA_DMACICR_FRAMEIE_MK(frameie)          |\
                        _DMA_DMACICR_HALFIE_MK(firsthalfie)  |\
                        _DMA_DMACICR_DROPIE_MK(dropie)            |\
                        _DMA_DMACICR_TIMEOUTIE_MK(timeoutie)      \
                      )\
   )

                       
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACSRn	   - Channel #n Channel Status Register
*
* Fields:
*  (R) _DMA_DMACSR_SYNC
*  (R) _DMA_DMACSR_BLOCK
*  (R) _DMA_DMACSR_LAST
*  (R) _DMA_DMACSR_FRAME
*  (R) _DMA_DMACSR_HALF
*  (R) _DMA_DMACSR_DROP
*  (R) _DMA_DMACSR_TIMEOUT
\*========================================================================*/
/*========================================================================*\
* (R) _DMA_DMACSR_SYNC
\*------------------------------------------------------------------------*/
#define _DMA_DMACSR_SYNC_SHIFT            (0x0006u)
#define _DMA_DMACSR_SYNC_MASK             (((Uint16)(1) & 0x0001u) << _DMA_DMACSR_SYNC_SHIFT)
#define _DMA_DMACSR_SYNC_MK(n)            (((Uint16)(n) & 0x0001u) << _DMA_DMACSR_SYNC_SHIFT)
#define _DMA_DMACSR_SYNC_CLR              (~(_DMA_DMACSR_SYNC_MASK))



/*========================================================================*\
* (R) _DMA_DMACSR_BLOCK
\*------------------------------------------------------------------------*/
#define _DMA_DMACSR_BLOCK_SHIFT           (0x0005u)
#define _DMA_DMACSR_BLOCK_MASK            (((Uint16)(1) & 0x0001u) << _DMA_DMACSR_BLOCK_SHIFT)
#define _DMA_DMACSR_BLOCK_MK(n)           (((Uint16)(n) & 0x0001u) << _DMA_DMACSR_BLOCK_SHIFT)
#define _DMA_DMACSR_BLOCK_CLR             (~(_DMA_DMACSR_BLOCK_MASK))

/*========================================================================*\
* (R) _DMA_DMACSR_LAST
\*------------------------------------------------------------------------*/
#define _DMA_DMACSR_LAST_SHIFT            (0x0004u)
#define _DMA_DMACSR_LAST_MASK             (((Uint16)(1) & 0x0001u) << _DMA_DMACSR_LAST_SHIFT)
#define _DMA_DMACSR_LAST_MK(n)            (((Uint16)(n) & 0x0001u) << _DMA_DMACSR_LAST_SHIFT)
#define _DMA_DMACSR_LAST_CLR              (~(_DMA_DMACSR_LAST_MASK))


/*========================================================================*\
* (R) _DMA_DMACSR_FRAME
\*------------------------------------------------------------------------*/
#define _DMA_DMACSR_FRAME_SHIFT           (0x0003u)
#define _DMA_DMACSR_FRAME_MASK            (((Uint16)(1) & 0x0001u) << _DMA_DMACSR_FRAME_SHIFT)
#define _DMA_DMACSR_FRAME_MK(n)           (((Uint16)(n) & 0x0001u) << _DMA_DMACSR_FRAME_SHIFT)
#define _DMA_DMACSR_FRAME_CLR             (~(_DMA_DMACSR_FRAME_MASK))


/*========================================================================*\
* (R) _DMA_DMACSR_HALF
\*------------------------------------------------------------------------*/
#define _DMA_DMACSR_HALF_SHIFT            (0x0002u)
#define _DMA_DMACSR_HALF_MASK             (((Uint16)(1) & 0x0001u) << _DMA_DMACSR_HALF_SHIFT)
#define _DMA_DMACSR_HALF_MK(n)            (((Uint16)(n) & 0x0001u) << _DMA_DMACSR_HALF_SHIFT)
#define _DMA_DMACSR_HALF_CLR              (~(_DMA_DMACSR_HALF_MASK))


/*========================================================================*\
* (R) _DMA_DMACSR_DROP
\*------------------------------------------------------------------------*/
#define _DMA_DMACSR_DROP_SHIFT            (0x0001u)
#define _DMA_DMACSR_DROP_MASK             (((Uint16)(1) & 0x0001u) << _DMA_DMACSR_DROP_SHIFT)
#define _DMA_DMACSR_DROP_MK(n)            (((Uint16)(n) & 0x0001u) << _DMA_DMACSR_DROP_SHIFT)
#define _DMA_DMACSR_DROP_CLR              (~(_DMA_DMACSR_DROP_MASK))


/*========================================================================*\
* (R) _DMA_DMACSR_TIMEOUT
\*------------------------------------------------------------------------*/
#define _DMA_DMACSR_TIMEOUT_SHIFT         (0x0000u)
#define _DMA_DMACSR_TIMEOUT_MASK          (((Uint16)(1) & 0x0001u) << _DMA_DMACSR_TIMEOUT_SHIFT)
#define _DMA_DMACSR_TIMEOUT_MK(n)         (((Uint16)(n) & 0x0001u) << _DMA_DMACSR_TIMEOUT_SHIFT)
#define _DMA_DMACSR_TIMEOUT_CLR           (~(_DMA_DMACSR_TIMEOUT_MASK))
        



/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACSSALn	   - Channel #n Channel Source Start Address (lower 16 bits)
*
* Fields:
*  (RW) _DMA_DMACSSAL_SSAL       
\*========================================================================*/

/*========================================================================*\
* (RW) _DMA_DMACSSAL_SSAL
\*------------------------------------------------------------------------*/
#define _DMA_DMACSSAL_SSAL_SHIFT           (0x0000u)
#define _DMA_DMACSSAL_SSAL_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACSSAL_SSAL_SHIFT)
#define _DMA_DMACSSAL_SSAL_MASK            (_DMA_DMACSSAL_SSAL_MK(0xFFFFu))
#define _DMA_DMACSSAL_SSAL_CLR             (~(_DMA_DMACSSAL_SSAL_MASK))

#define _DMA_DMACSSAL_SSAL_GET(RegAddr) \
   _PFIELD_GET(RegAddr,_DMA_DMACSSAL_SSAL)

#define _DMA_DMACSSAL_SSAL_SET(RegAddr,Val) \
   _PFIELD_SET(RegAddr,_DMA_DMACSSAL_SSAL,Val)

#define _DMA_DMACSSAL_CFG(RegAddr, ssal)   _PREG_SET(RegAddr, _DMA_CSSA_SSAL_MK(ssal))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _DMA_DMACSSAUn	   - Channel #n Channel Source Start Address (lower 16 bits)
*
* Fields:
*  (RW) _DMA_DMACSSAU_SSAU       
\*============================================================================*/

/*==========================================================================*\
* (RW) _DMA_DMACSSAU_SSAU
\*--------------------------------------------------------------------------*/
#define _DMA_DMACSSAU_SSAU_SHIFT           (0x0000u)
#define _DMA_DMACSSAU_SSAU_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACSSAU_SSAU_SHIFT)
#define _DMA_DMACSSAU_SSAU_MASK            (_DMA_DMACSSAU_SSAU_MK(0xFFFFu))
#define _DMA_DMACSSAU_SSAU_CLR             (~(_DMA_DMACSSAU_SSAU_MASK))

#define _DMA_DMACSSAU_CFG(Ch, ssau)   _PREG_SET(_DMA_DMACSSAU_ADDR(Ch), _DMA_DMACSSAU_SSAU_MK(ssau))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _DMA_DMACDSALn	   - Channel #n Channel Source Start Address (lower 16 bits)
*
* Fields:
*  (RW) _DMA_DMACDSAL_DSAL       
\*============================================================================*/

/*==========================================================================*\
* (RW) _DMA_DMACDSAL_DSAL
\*--------------------------------------------------------------------------*/
#define _DMA_DMACDSAL_DSAL_SHIFT           (0x0000u)
#define _DMA_DMACDSAL_DSAL_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACDSAL_DSAL_SHIFT)
#define _DMA_DMACDSAL_DSAL_MASK            (_DMA_DMACDSAL_DSAL_MK(0xFFFFu))
#define _DMA_DMACDSAL_DSAL_CLR             (~(_DMA_DMACDSAL_DSAL_MASK))

#define _DMA_DMACDSAL_CFG(Ch, dsal)   _PREG_SET(_DMA_DMACDSAL_ADDR(Ch), _DMA_DMACDSAL_DSAL_MK(dsal))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _DMA_DMACDSAUn	   - Channel #n Channel Source Start Address (lower 16 bits)
*
* Fields:
*  (RW) _DMA_DMACDSAU_DSAU       
\*============================================================================*/

/*==========================================================================*\
* (RW) _DMA_DMACDSAU_DSAU
\*--------------------------------------------------------------------------*/
#define _DMA_DMACDSAU_DSAU_SHIFT           (0x0000u)
#define _DMA_DMACDSAU_DSAU_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACDSAU_DSAU_SHIFT)
#define _DMA_DMACDSAU_DSAU_MASK            (_DMA_DMACDSAU_DSAU_MK(0xFFFFu))
#define _DMA_DMACDSAU_DSAU_CLR             (~(_DMA_DMACDSAU_DSAU_MASK))

#define _DMA_DMACDSAU_CFG(Ch, dsau)   _PREG_SET(_DMA_DMACDSAU_ADDR(Ch), _DMA_DMACDSAU_DSAU_MK(dsau))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACENn	   - Channel #n Channel Element Number Register
*
* Fields:
*  (RW) _DMA_DMACEN_ELEMENTNUM       
\*========================================================================*/

/*=========================================================================*\
* (RW) _DMA_DMACEN_ELEMENTNUM
\*-------------------------------------------------------------------------*/
#define _DMA_DMACEN_ELEMENTNUM_SHIFT           (0x0000u)
#define _DMA_DMACEN_ELEMENTNUM_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACEN_ELEMENTNUM_SHIFT)
#define _DMA_DMACEN_ELEMENTNUM_MASK            (_DMA_DMACEN_ELEMENTNUM_MK(0xFFFFu))
#define _DMA_DMACEN_ELEMENTNUM_CLR             (~(_DMA_DMACEN_ELEMENTNUM_MASK))

#define _DMA_DMACEN_CFG(Ch, elementnum)  _PREG_SET(_DMA_DMACEN_ADDR(Ch), _DMA_DMACEN_ELEMENTNUM_MK(elementnum))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACFNn	   - Channel #n Channel Frame Number Register
*
* Fields:
*  (RW) _DMA_DMACFN_FRAMENUM      
\*========================================================================*/

/*========================================================================*\
* (RW) _DMA_DMACFN_FRAMENUM
\*------------------------------------------------------------------------*/
#define _DMA_DMACFN_FRAMENUM_SHIFT           (0x0000u)
#define _DMA_DMACFN_FRAMENUM_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACFN_FRAMENUM_SHIFT)
#define _DMA_DMACFN_FRAMENUM_MASK            (_DMA_DMACFN_FRAMENUM_MK(0xFFFFu))
#define _DMA_DMACFN_FRAMENUM_CLR             (~(_DMA_DMACFN_FRAMENUM_MASK))

#define _DMA_DMACFN_CFG(Ch, framenum)   _PREG_SET(_DMA_DMACFN_ADDR(Ch), _DMA_DMACFN_FRAMENUM_MK(framenum))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACFIn	   - Channel #n Channel Frame Index Register
*
* Fields:
*  (RW) _DMA_DMACFI_FRAMENDX      
\*========================================================================*/

/*========================================================================*\
* (RW) _DMA_DMACFI_FRAMENDX
\*------------------------------------------------------------------------*/
#define _DMA_DMACFI_FRAMENDX_SHIFT           (0x0000u)
#define _DMA_DMACFI_FRAMENDX_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACFI_FRAMENDX_SHIFT)
#define _DMA_DMACFI_FRAMENDX_MASK            (_DMA_DMACFI_FRAMENDX_MK(0xFFFFu))
#define _DMA_DMACFI_FRAMENDX_CLR             (~(_DMA_DMACFI_FRAMENDX_MASK))

#define _DMA_DMACFI_CFG(Ch, framendx)   _PREG_SET(_DMA_DMACFI_ADDR(Ch), _DMA_DMACFI_FRAMENDX_MK(framendx))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACEIn	   - Channel #n Channel Element Index Register
*
* Fields:
*  (RW) _DMA_DMACEI_ELEMENTNDX      
\*========================================================================*/

/*========================================================================*\
* (RW) _DMA_DMACEI_ELEMENTNDX
\*------------------------------------------------------------------------*/
#define _DMA_DMACEI_ELEMENTNDX_SHIFT           (0x0000u)
#define _DMA_DMACEI_ELEMENTNDX_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACEI_ELEMENTNDX_SHIFT)
#define _DMA_DMACEI_ELEMENTNDX_MASK            (_DMA_DMACEI_ELEMENTNDX_MK(0xFFFFu))
#define _DMA_DMACEI_ELEMENTNDX_CLR             (~(_DMA_DMACEI_ELEMENTNDX_MASK))

#define _DMA_DMACEI_CFG(Ch, elementndx)   _PREG_SET(_DMA_DMACEI_ADDR(Ch), _DMA_DMACEI_ELEMENTNDX_MK(elementndx))

#if (_DMA_DST_AND_SRC_INDEX_SUPPORT)

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACSFIn	   - Channel #n Channel Src Frame Index Register
*
* Fields:
*  (RW) _DMA_DMACSFI_FRAMENDX      
\*========================================================================*/

/*========================================================================*\
* (RW) _DMA_DMACSFI_FRAMENDX
\*------------------------------------------------------------------------*/
#define _DMA_DMACSFI_FRAMENDX_SHIFT           (0x0000u)
#define _DMA_DMACSFI_FRAMENDX_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACSFI_FRAMENDX_SHIFT)
#define _DMA_DMACSFI_FRAMENDX_MASK            (_DMA_DMACSFI_FRAMENDX_MK(0xFFFFu))
#define _DMA_DMACSFI_FRAMENDX_CLR             (~(_DMA_DMACSFI_FRAMENDX_MASK))

#define _DMA_DMACSFI_CFG(Ch, framendx)   _PREG_SET(_DMA_DMACSFI_ADDR(Ch), _DMA_DMACSFI_FRAMENDX_MK(framendx))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACSACn	   - Channel #n Channel Src Address Count Register
*
* Fields:
*  (RW) _DMA_DMACSAC_DMACSAC     
\*========================================================================*/

/*========================================================================*\
* (RW) _DMA_DMACSAC_DMACSAC
\*------------------------------------------------------------------------*/
#define _DMA_DMACSAC_DMACSAC_SHIFT           (0x0000u)
#define _DMA_DMACSAC_DMACSAC_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACSAC_DMACSAC_SHIFT)
#define _DMA_DMACSAC_DMACSAC_MASK            (_DMA_DMACSAC_DMACSAC_MK(0xFFFFu))
#define _DMA_DMACSAC_DMACSAC_CLR             (~(_DMA_DMACSAC_DMACSAC_MASK))

#define _DMA_DMACSAC_CFG(Ch, dmacsac)   _PREG_SET(_DMA_DMACSAC_ADDR(Ch), _DMA_DMACSAC_DMACSAC_MK(dmacsac))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACDACn	   - Channel #n Channel Dst Address Count Register
*
* Fields:
*  (RW) _DMA_DMACDAC_DMACDAC     
\*========================================================================*/

/*========================================================================*\
* (RW) _DMA_DMACDAC_DMACDAC
\*------------------------------------------------------------------------*/
#define _DMA_DMACDAC_DMACDAC_SHIFT           (0x0000u)
#define _DMA_DMACDAC_DMACDAC_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACDAC_DMACDAC_SHIFT)
#define _DMA_DMACDAC_DMACDAC_MASK            (_DMA_DMACDAC_DMACDAC_MK(0xFFFFu))
#define _DMA_DMACDAC_DMACDAC_CLR             (~(_DMA_DMACDAC_DMACDAC_MASK))

#define _DMA_DMACDAC_CFG(Ch, dmacdac)   _PREG_SET(_DMA_DMACDAC_ADDR(Ch), _DMA_DMACDAC_DMACDAC_MK(dmacdac))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACSEIn	   - Channel #n Channel Src Element Index Register
*
* Fields:
*  (RW) _DMA_DMACSEI_ELEMENTNDX      
\*========================================================================*/

/*========================================================================*\
* (RW) _DMA_DMACSEI_ELEMENTNDX
\*------------------------------------------------------------------------*/
#define _DMA_DMACSEI_ELEMENTNDX_SHIFT           (0x0000u)
#define _DMA_DMACSEI_ELEMENTNDX_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACSEI_ELEMENTNDX_SHIFT)
#define _DMA_DMACSEI_ELEMENTNDX_MASK            (_DMA_DMACSEI_ELEMENTNDX_MK(0xFFFFu))
#define _DMA_DMACSEI_ELEMENTNDX_CLR             (~(_DMA_DMACSEI_ELEMENTNDX_MASK))

#define _DMA_DMACSEI_CFG(Ch, elementndx)   _PREG_SET(_DMA_DMACSEI_ADDR(Ch), _DMA_DMACSEI_ELEMENTNDX_MK(elementndx))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACSFIn	   - Channel #n Channel Dst Frame Index Register
*
* Fields:
*  (RW) _DMA_DMACDFI_FRAMENDX      
\*========================================================================*/

/*========================================================================*\
* (RW) _DMA_DMACDFI_FRAMENDX
\*------------------------------------------------------------------------*/
#define _DMA_DMACDFI_FRAMENDX_SHIFT           (0x0000u)
#define _DMA_DMACDFI_FRAMENDX_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACDFI_FRAMENDX_SHIFT)
#define _DMA_DMACDFI_FRAMENDX_MASK            (_DMA_DMACDFI_FRAMENDX_MK(0xFFFFu))
#define _DMA_DMACDFI_FRAMENDX_CLR             (~(_DMA_DMACDFI_FRAMENDX_MASK))

#define _DMA_DMACDFI_CFG(Ch, framendx)   _PREG_SET(_DMA_DMACDFI_ADDR(Ch), _DMA_DMACDFI_FRAMENDX_MK(framendx))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*========================================================================*\
* _DMA_DMACDEIn	   - Channel #n Channel Dst Element Index Register
*
* Fields:
*  (RW) _DMA_DMACDEI_ELEMENTNDX      
\*========================================================================*/

/*========================================================================*\
* (RW) _DMA_DMACDEI_ELEMENTNDX
\*------------------------------------------------------------------------*/
#define _DMA_DMACDEI_ELEMENTNDX_SHIFT           (0x0000u)
#define _DMA_DMACDEI_ELEMENTNDX_MK(n)           (((Uint16)(n) & 0xFFFFu) << _DMA_DMACDEI_ELEMENTNDX_SHIFT)
#define _DMA_DMACDEI_ELEMENTNDX_MASK            (_DMA_DMACDEI_ELEMENTNDX_MK(0xFFFFu))
#define _DMA_DMACDEI_ELEMENTNDX_CLR             (~(_DMA_DMACDEI_ELEMENTNDX_MASK))

#define _DMA_DMACDEI_CFG(Ch, elementndx)   _PREG_SET(_DMA_DMACDEI_ADDR(Ch), _DMA_DMACDEI_ELEMENTNDX_MK(elementndx))


#endif /* _DMA_SRC_AND_DST_INDEX_SUPPORT */
#endif /* _DMAHAL_H_ */

csl_emif.h/     1051539348  0     0     0       1325      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emif.h
* DATE CREATED.. 06/11/1999 
*------------------------------------------------------------------------------
* HISTORY:
*      MODIFIED:  07/14/2000
*      MODIFIED:  05/11/2001 updated for EMIF_getConfig()
*      MODIFIED:  05/16/2001 renamed EMIF_CONFIG -> EMIF_Config 
*      MODIFIED:  01/27/2002 fixed problem with EMIF_EMIF_EGCR_MEMFREQ_1/2X
*                             _OF(x) type symbolic constants
*      MODIFIED:  02/12/2002 added support for 5502 EMIF
*      MODIFIED: 10 April 2003 added #include of csl_emifdat.h
\******************************************************************************/
#ifndef _EMIF_H_
#define _EMIF_H_

  #include <_csl.h>
  #include <csl_emifdat.h>

  #if (_EMIFB_SUPPORT)
     #include <csl_emifB.h>
  #else
     #include <csl_emifA.h>
  #endif
#endif /* _EMIF_H_ */
/******************************************************************************\
* End of emif.h
\******************************************************************************/

csl_emifA.h/    1049976848  0     0     0       25087     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emif.h
* DATE CREATED.. 06/11/1999 
*------------------------------------------------------------------------------
* HISTORY:
*      MODIFIED:  07/14/2000
*      MODIFIED:  05/11/2001 updated for EMIF_getConfig()
*      MODIFIED:  05/16/2001 renamed EMIF_CONFIG -> EMIF_Config 
*      MODIFIED:  01/27/2002 fixed problem with EMIF_EMIF_EGCR_MEMFREQ_1/2X
*                             _OF(x) type symbolic constants
*      MODIFIED:  10/11/2002 added EMIF_reset macro/function as separate API 
*      MODIFIED:  11/22/2002 added MEMFREQ for 1BY4,1BY8,1BY16 fixed 1/2X
*                            added DEBUG and ST bits to Bus Error regitser (EMIBE)
*                            added symbolic constants EMIF_CKE_GPIO, EMIF_CKE_XF
\******************************************************************************/
#ifndef _EMIFA_H_
#define _EMIFA_H_

#include <csl.h>
#include <csl_emifdat.h>
#include <csl_emifAhal.h>

#if (_EMIF_SUPPORT)
/****************************************\
* EMIF scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _EMIF_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif
                          
#define Emif_Initialized            EMIF_SYM(0) 
/****************************************\
* EMIF global macro declarations
\****************************************/
/*-----------------------------------------------------------------------*/
/* The following macros are used to construct peripheral register        */
/* values based on symbolic constants. They will be useful to initialize */
/* the EMIF_Config structure in a readable way.                          */
/*-----------------------------------------------------------------------*/

/*============================================================================*\
* _EMIF_EGCR	- Global Control Register
*
* Fields:
*  (RW) MEMFREQ	- Memory Clock Frequency field
*  (RW) WPE		- Write Posting Enable field
*  (RW) MEMCEN	- Mem Clock Enable field
*  (R)  ARDY	- Value of ARDY input
*  (R)  HOLD	- Value of /HOLD input
*  (R)  HOLDA	- Value of /HOLDA output
*  (RW) NOHOLD	- External HOLD disable field
\*============================================================================*/

/*==========================================================================*\
*  EMIF_EGCR_DEFAULT Values
\*==========================================================================*/

/* default register value */
#define EMIF_EGCR_DEFAULT              (0x0020)
#define EMIF_EGCR_OF(x)               ((Uint16)(x))

/* field values */
#define EMIF_EGCR_MEMFREQ_1X           (0x0000)
#define EMIF_EGCR_MEMFREQ_1BY2X        (0x0001)
#define EMIF_EGCR_MEMFREQ_1BY4X        (0x0002)
#define EMIF_EGCR_MEMFREQ_1BY8X        (0x0003)
#define EMIF_EGCR_MEMFREQ_1BY16X       (0x0004)
#define EMIF_EGCR_WPE_OFF	         (0x0000)
#define EMIF_EGCR_WPE_ON           	   (0x0001)
#define EMIF_EGCR_MEMCEN_OFF           (0x0000)
#define EMIF_EGCR_MEMCEN_DISABLED      (0x0000)
#define EMIF_EGCR_MEMCEN_ON            (0x0001)
#define EMIF_EGCR_MEMCEN_ENABLED       (0x0001)
#define EMIF_EGCR_ARDY_LO              (0x0000)
#define EMIF_EGCR_ARDY_HI              (0x0001)
#define EMIF_EGCR_HOLD_LO              (0x0000)
#define EMIF_EGCR_HOLD_HI              (0x0001)
#define EMIF_EGCR_HOLDA_LO             (0x0000)
#define EMIF_EGCR_HOLDA_HI             (0x0001)
#define EMIF_EGCR_NOHOLD_HOLD          (0x0000)
#define EMIF_EGCR_NOHOLD_NOHOLD        (0x0001)

/*==========================================================================*\
*  EMIF_EGCR_MK
\*==========================================================================*/

/* make register value based on symbolic constants */

#define EMIF_EGCR_RMK(memfreq,wpe,memcen,nohold) \
 ((Uint16) ( \
 ( EMIF_FMK(EGCR,MEMFREQ,memfreq))|\
 ( EMIF_FMK(EGCR,WPE,wpe))|\
 ( EMIF_FMK(EGCR,MEMCEN,memcen))|\
 ( EMIF_FMK(EGCR,NOHOLD,nohold))\
 )\
)  

#define EMIF_EGCR_RMKS(memfreq_sym,wpe_sym,memcen_sym,nohold_sym) \
 ((Uint16) ( \
 ( EMIF_FMKS(EGCR,MEMFREQ,memfreq_sym))|\
 ( EMIF_FMKS(EGCR,WPE,wpe_sym))|\
 ( EMIF_FMKS(EGCR,MEMCEN,memcen_sym))|\
 ( EMIF_FMKS(EGCR,NOHOLD,nohold_sym))\
 )\
)  

/*============================================================================*\
* EMIF_EMIRST	-  Global Reset Register
*
* Fields:
*  (W) EMIRST	-  Global Reset Register Field
\*============================================================================*/
/* field values */
#define EMIF_EMIRST_EMIRST_0F(x)	       ((Uint16)(x))

/*==========================================================================*\
*  EMIF_EMIRST_RMK
\*==========================================================================*/

/* make register value based on symbolic constants */

#define EMIF_EMIRST_RMK(emirst) \
 ((Uint16) ( EMIF_FMK(EMIRST,EMIRST,emirst))\
)  

#define EMIF_EMIRST_RMKS(emirst_sym) \
 ((Uint16) ( EMIF_FMKS(EMIRST,EMIRST,emirst_sym))\
)  

/*=============================================================================*\
* _EMIF_EMIBE	   - Bus Error Status Register
*
* Fields:
*  (R) TIME
*  (R) CE3
*  (R) CE2
*  (R) CE1
*  (R) CE0
*  (R) DMA
*  (R) FBUS
*  (R) EBUS
*  (R) DBUS
*  (R) CBUS
*  (R) PBUS
\*============================================================================*/

#define EMIF_EMIBE_TIME_TRUE      (0x1u)
#define EMIF_EMIBE_TIME_FALSE     (0x0u)
#define EMIF_EMIBE_TIME_DEFAULT    EMIF_EMIBE_TIME_FALSE

#define EMIF_EMIBE_CE3_TRUE      (0x1u)
#define EMIF_EMIBE_CE3_FALSE     (0x0u)
#define EMIF_EMIBE_CE3_DEFAULT    EMIF_EMIBE_CE3_FALSE

#define EMIF_EMIBE_CE2_TRUE      (0x1u)
#define EMIF_EMIBE_CE2_FALSE     (0x0u)
#define EMIF_EMIBE_CE2_DEFAULT    EMIF_EMIBE_CE2_FALSE

#define EMIF_EMIBE_CE1_TRUE      (0x1u)
#define EMIF_EMIBE_CE1_FALSE     (0x0u)
#define EMIF_EMIBE_CE1_DEFAULT    EMIF_EMIBE_CE1_FALSE

#define EMIF_EMIBE_CE0_TRUE      (0x1u)
#define EMIF_EMIBE_CE0_FALSE     (0x0u)
#define EMIF_EMIBE_CE0_DEFAULT    EMIF_EMIBE_CE0_FALSE

#define EMIF_EMIBE_DMA_TRUE      (0x1u)
#define EMIF_EMIBE_DMA_FALSE     (0x0u)
#define EMIF_EMIBE_DMA_DEFAULT    EMIF_EMIBE_DMA_FALSE

#define EMIF_EMIBE_FBUS_TRUE      (0x1u)
#define EMIF_EMIBE_FBUS_FALSE     (0x0u)
#define EMIF_EMIBE_FBUS_DEFAULT    EMIF_EMIBE_FBUS_FALSE

#define EMIF_EMIBE_EBUS_TRUE      (0x1u)
#define EMIF_EMIBE_EBUS_FALSE     (0x0u)
#define EMIF_EMIBE_EBUS_DEFAULT    EMIF_EMIBE_EBUS_FALSE

#define EMIF_EMIBE_DBUS_TRUE      (0x1u)
#define EMIF_EMIBE_DBUS_FALSE     (0x0u)
#define EMIF_EMIBE_DBUS_DEFAULT    EMIF_EMIBE_DBUS_FALSE

#define EMIF_EMIBE_CBUS_TRUE      (0x1u)
#define EMIF_EMIBE_CBUS_FALSE     (0x0u)
#define EMIF_EMIBE_CBUS_DEFAULT    EMIF_EMIBE_CBUS_FALSE

#define EMIF_EMIBE_PBUS_TRUE      (0x1u)
#define EMIF_EMIBE_PBUS_FALSE     (0x0u)
#define EMIF_EMIBE_PBUS_DEFAULT    EMIF_EMIBE_PBUS_FALSE


#define EMIF_EMIBE_RMK(time,ce3,ce2,ce1,ce0,dma,fbus,ebus,dbus,cbus,pbus)\
 ((Uint16) (\
  EMIF_FMK(EMIBE,TIME,time) |\
  EMIF_FMK(EMIBE,CE3,ce3)   |\
  EMIF_FMK(EMIBE,CE2,ce2)   |\
  EMIF_FMK(EMIBE,CE1,ce1)   |\
  EMIF_FMK(EMIBE,CE0,ce0)   |\
  EMIF_FMK(EMIBE,DMA,dma)   |\
  EMIF_FMK(EMIBE,FBUS,fbus) |\
  EMIF_FMK(EMIBE,EBUS,ebus) |\
  EMIF_FMK(EMIBE,DBUS,dbus) |\
  EMIF_FMK(EMIBE,CBUS,cbus) |\
  EMIF_FMK(EMIBE,PBUS,pbus)\
  )\
)

#define EMIF_EMIBE_RMKS(time,ce3,ce2,ce1,ce0,dma,fbus,ebus,dbus,cbus,pbus)\
 ((Uint16) (\
  EMIF_FMKS(EMIBE,TIME,time) |\
  EMIF_FMKS(EMIBE,CE3,ce3)   |\
  EMIF_FMKS(EMIBE,CE2,ce2)   |\
  EMIF_FMKS(EMIBE,CE1,ce1)   |\
  EMIF_FMKS(EMIBE,CE0,ce0)   |\
  EMIF_FMKS(EMIBE,DMA,dma)   |\
  EMIF_FMKS(EMIBE,FBUS,fbus) |\
  EMIF_FMKS(EMIBE,EBUS,ebus) |\
  EMIF_FMKS(EMIBE,DBUS,dbus) |\
  EMIF_FMKS(EMIBE,CBUS,cbus) |\
  EMIF_FMKS(EMIBE,PBUS,pbus)\
  )\
)

/*===========================================================================*\
* _EMIF_CE01   - Space Control Register 1
* _EMIF_CE11   - Space Control Register 1
* _EMIF_CE21   - Space Control Register 1
* _EMIF_CE31   - Space Control Register 1
*
* Fields:
*  (RW) MTYPE	- MTYPE field
*  (RW) RDSETUP	- Read Setup field
*  (RW) RDSTROBE	- Read Strobe field
*  (RW) RDHOLD	- Read Hold field
\*===========================================================================*/

/*==========================================================================*\
*  EMIF_CEx1_DEFAULT Values
\*==========================================================================*/

/* default register value */
#define EMIF_CEx1_DEFAULT               (0x2FFF)
#define EMIF_CEx1_OF(x)                 ((Uint16)(x))

/* field values */
#define EMIF_CEx1_RDHOLD_OF(x)           ((Uint16)(x))
#define EMIF_CEx1_RDSTROBE_OF(x)         ((Uint16)(x))
#define EMIF_CEx1_RDSETUP_OF(x)          ((Uint16)(x))
#define EMIF_CEx1_MTYPE_ASYNC8           (0x0000)
#define EMIF_CEx1_MTYPE_ASYNC16          (0x0001)
#define EMIF_CEx1_MTYPE_ASYNC32          (0x0002)
#define EMIF_CEx1_MTYPE_SDRAM32          (0x0003)
#define EMIF_CEx1_MTYPE_SBSRAM32         (0x0004)

/*==========================================================================*\
*  EMIF_CEx1_MK
\*==========================================================================*/

#define EMIF_CEx1_RMK(mtype,rdsetup,rdstrobe,rdhold) \
 ((Uint16) ( \
  ( EMIF_FMK(CE01,MTYPE,mtype))|\
  ( EMIF_FMK(CE01,RDSETUP,rdsetup))|\
  ( EMIF_FMK(CE01,RDSTROBE,rdstrobe))|\
  ( EMIF_FMK(CE01,RDHOLD,rdhold))\
  )\
) 

#define EMIF_CEx1_RMKS(mtype_sym,rdsetup_sym,rdstrobe_sym,rdhold_sym) \
 ((Uint16) ( \
  ( EMIF_FMKS(CE01,MTYPE,mtype_sym))|\
  ( EMIF_FMKS(CE01,RDSETUP,rdsetup_sym))|\
  ( EMIF_FMKS(CE01,RDSTROBE,rdstrobe_sym))|\
  ( EMIF_FMKS(CE01,RDHOLD,rdhold_sym))\
  )\
) 


/*===========================================================================*\
* _EMIF_CE02   - Space Control Register 2
* _EMIF_CE12   - Space Control Register 2
* _EMIF_CE22   - Space COntrol Register 2
* _EMIF_CE32   - Space Control Register 2
*
* Fields:
*  (RW) RDEXHLD 	- Extended Hold Read field
*  (RW) WREXHLD	- Extended Hold Write field
*  (RW) WRSETUP	- Write Setup field
*  (RW) WRSTROBE	- Write Strobe field
*  (RW) WRHOLD	- Write Hold field
\*===========================================================================*/

/*==========================================================================*\
*  EMIF_CEx2_DEFAULT Values
\*==========================================================================*/


/* default register value */
#define EMIF_CEx2_DEFAULT               (0x5FFF)
#define EMIF_CEx2_OF(x)                  ((Uint16)(x))

/* field values */
#define EMIF_CEx2_WRHOLD_OF(x)           ((Uint16)(x))
#define EMIF_CEx2_WRSTROBE_OF(x)         ((Uint16)(x))
#define EMIF_CEx2_WRSETUP_OF(x)          ((Uint16)(x))
#define EMIF_CEx2_WREXHLD_OF(x)           ((Uint16)(x))
#define EMIF_CEx2_RDEXHLD_OF(x)          ((Uint16)(x))


/*==========================================================================*\
*  EMIF_CEx2_RMK
\*==========================================================================*/

/* make register value based on symbolic constants */
#define EMIF_CEx2_RMK(rdexhld,wrexhld,wrsetup,wrstrobe,wrhold) \
 ((Uint16) ( \
  ( EMIF_FMK(CE02,RDEXHLD,rdexhld))|\
  ( EMIF_FMK(CE02,WREXHLD,wrexhld))|\
  ( EMIF_FMK(CE02,WRSETUP,wrsetup))|\
  ( EMIF_FMK(CE02,WRSTROBE,wrstrobe))|\
  ( EMIF_FMK(CE02,WRHOLD,wrhold))\
  )\
) 

/*==========================================================================*\
*  EMIF_CEx2_GET
\*==========================================================================*/

/*===========================================================================*\
* _EMIF_CE03   - Space Control Register 3
* _EMIF_CE13   - Space Control Register 3
* _EMIF_CE23   - Space COntrol Register 3
* _EMIF_CE33   - Space Control Register 3
*
* Fields:
*  (RW) TIMOUT 	- Timeout field
\*===========================================================================*/

/*==========================================================================*\
*  EMIF_CEx3_DEFAULT Values
\*==========================================================================*/
/* default register value */
#define EMIF_CEx3_DEFAULT                (0x0000)
#define EMIF_CEx3_OF(x)                  ((Uint16)(x))

/* field values */
#define EMIF_CEx3_TIMOUT_OF(x)           ((Uint16)(x))

/*==========================================================================*\
*  EMIF_CEx3_MK
\*==========================================================================*/
/* make register value based on symbolic constants */

#define EMIF_CEx3_RMK(timout)            ((Uint16) (EMIF_FMK(CE03,TIMOUT,timout))) 

/*==========================================================================*\
*  EMIF_CEx3_SET
\*==========================================================================*/

#define EMIF_CE03_SET(val) (_PREG_SET(_EMIF_CE03_ADDR,val))
#define EMIF_CE13_SET(val) (_PREG_SET(_EMIF_CE13_ADDR,val))
#define EMIF_CE23_SET(val) (_PREG_SET(_EMIF_CE23_ADDR,val))
#define EMIF_CE33_SET(val) (_PREG_SET(_EMIF_CE33_ADDR,val))


/*==========================================================================*\
*  EMIF_CEx3_GET
\*==========================================================================*/

#define EMIF_CE03_GET 	((Uint16) _PREG_GET(_EMIF_CE03_ADDR))
#define EMIF_CE13_GET 	((Uint16) _PREG_GET(_EMIF_CE13_ADDR))
#define EMIF_CE23_GET 	((Uint16) _PREG_GET(_EMIF_CE23_ADDR))
#define EMIF_CE33_GET 	((Uint16) _PREG_GET(_EMIF_CE33_ADDR))

/*==========================================================================*\
*  EMIF_CEx3_FSET
\*==========================================================================*/

#define EMIF_CE03_FSET(FIELD,val) (_PFIELD_SET(_EMIF_CE03_ADDR,_EMIF_CEx3_##FIELD,val))
#define EMIF_CE13_FSET(FIELD,val) (_PFIELD_SET(_EMIF_CE13_ADDR,_EMIF_CEx3_##FIELD,val))
#define EMIF_CE23_FSET(FIELD,val) (_PFIELD_SET(_EMIF_CE23_ADDR,_EMIF_CEx3_##FIELD,val))
#define EMIF_CE33_FSET(FIELD,val) (_PFIELD_SET(_EMIF_CE33_ADDR,_EMIF_CEx3_##FIELD,val))

/*==========================================================================*\
*  EMIF_CEx3_FGET
\*==========================================================================*/

#define EMIF_CE03_FGET(FIELD) 	   ((Uint16) _PFIELD_GET(_EMIF_CE03_ADDR,_EMIF_CEx3_##FIELD))
#define EMIF_CE13_FGET(FIELD) 	   ((Uint16) _PFIELD_GET(_EMIF_CE13_ADDR,_EMIF_CEx3_##FIELD))
#define EMIF_CE23_FGET(FIELD) 	   ((Uint16) _PFIELD_GET(_EMIF_CE23_ADDR,_EMIF_CEx3_##FIELD))
#define EMIF_CE33_FGET(FIELD) 	   ((Uint16) _PFIELD_GET(_EMIF_CE33_ADDR,_EMIF_CEx3_##FIELD))

/*===========================================================================*\
* _EMIF_SDC1   - SDRAM Control Register 1
*
* Fields:
*  (RW) TRC
*  (RW) SDSIZE
*  (RW) SDWID
*  (RW) RFEN
*  (RW) TRCD
*  (RW) TRP
\*===========================================================================*/

/*==========================================================================*\
*  EMIF_SDC1_DEFAULT Values
\*==========================================================================*/
/* default register value */
#define EMIF_SDC1_DEFAULT             (0x0F94)


#define EMIF_SDC1_OF(x)                 ((Uint16)(x))

/* field values */
#define EMIF_SDC1_TRP_OF(x)             ((Uint16)(x))
#define EMIF_SDC1_TRCD_OF(x)            ((Uint16)(x))
#define EMIF_SDC1_RFEN_DISABLE          (0x0000)
#define EMIF_SDC1_RFEN_ENABLE           (0x0001)
#define EMIF_SDC1_SDWID_OFF             (0x0000)
#define EMIF_SDC1_SDWID_ON              (0x0001)
#define EMIF_SDC1_SDSIZE_16M            (0x0000)
#define EMIF_SDC1_SDSIZE_64M            (0x0001)
#define EMIF_SDC1_TRC_OF(x)             ((Uint16)(x))

/*==========================================================================*\
*  EMIF_SDC1_MK
\*==========================================================================*/
/* make register value based on symbolic constants */
#define EMIF_SDC1_MK(trc,sdsize,sdwid,rfen,trcd,trp) \
 ((Uint16) ( \
  ( _EMIF_SDC1_TRC_MK(trc))|\
  ( _EMIF_SDC1_SDSIZE_MK(sdsize))|\
  ( _EMIF_SDC1_SDWID_MK(sdwid))|\
  ( _EMIF_SDC1_RFEN_MK(rfen))|\
  ( _EMIF_SDC1_TRCD_MK(trcd))|\
  ( _EMIF_SDC1_TRP_MK(trp))\
  )\
)
/*==========================================================================*\
*  EMIF_SDC1_SET
\*==========================================================================*/

#define EMIF_SDC1_SET(val) (_PREG_SET(_EMIF_SDC1_ADDR,val))

/*==========================================================================*\
*  EMIF_SDC1_GET
\*==========================================================================*/

#define EMIF_SDC1_GET 	((Uint16) _PREG_GET(_EMIF_SDC1_ADDR))

/*==========================================================================*\
*  EMIF_SDC1_FSET
\*==========================================================================*/

#define EMIF_SDC1_FSET(FIELD,val) (_PFIELD_SET(_EMIF_SDC1_ADDR,_EMIF_SDC1_##FIELD,val))

/*==========================================================================*\
*  EMIF_SDC1_FGET
\*==========================================================================*/

#define EMIF_SDC1_FGET(FIELD) 	   ((Uint16) _PFIELD_GET(_EMIF_SDC1_ADDR,_EMIF_SDC1_##FIELD))

#define EMIF_SDC1_RMK(trc,sdsize,sdwid,rfen,trcd,trp)( \
(Uint16) (	EMIF_FMK(SDC1,TRC,trc) 		|\
		EMIF_FMK(SDC1,SDSIZE,sdsize) 	|\
		EMIF_FMK(SDC1,SDWID,sdwid) 	|\
		EMIF_FMK(SDC1,RFEN,rfen) 	|\
		EMIF_FMK(SDC1,TRCD,trcd) 	|\
		EMIF_FMK(SDC1,TRP,trp)		)\
)


/*===========================================================================*\
* _EMIF_SDPER   - SDRAM Period Register
*
* Fields:
*  (RW) PERIOD
\*===========================================================================*/

/*==========================================================================*\
*  EMIF_SDPER_DEFAULT Values
\*==========================================================================*/
/* default register value */
#define EMIF_SDPER_DEFAULT             (0x0080)
#define EMIF_SDPER_OF(x)  ((Uint16)(x))

/* field values */
#define EMIF_SDPER_PERIOD_OF(x)          ((Uint16)(x))

/*==========================================================================*\
*  EMIF_SDCNT_RMK
\*==========================================================================*/
/* make register value based on symbolic constants */

#define EMIF_SDCNT_COUNTER_OF(x)          ((Uint16)(x))

#define EMIF_SDCNT_RMK(sdcnt)             ((Uint16)(EMIF_FMK(SDCNT,COUNTER,sdcnt)))

/*==========================================================================*\
*  EMIF_SDPER_RMK
\*==========================================================================*/
/* make register value based on symbolic constants */

#define EMIF_SDPER_RMK(period) \
 ((Uint16) ( \
  ( EMIF_FMK(SDPER,PERIOD,period))\
  )\
)

#define EMIF_SDPER_RMKS(period_s) \
 ((Uint16) ( \
  ( EMIF_FMKS(SDPER,PERIOD,period_s))\
  )\
)


/*===========================================================================*\
* EMIF_INIT   - SDRAM Initialization Register
*
* Fields:
*  (RW) INIT
\*===========================================================================*/

/*==========================================================================*\
*  EMIF_INIT_DEFAULT Values
\*==========================================================================*/
/* default register value */
#define EMIF_INIT_DEFAULT             (0x0000u)
#define EMIF_SDINIT_DEFAULT           (0x0000u)
#define EMIF_INIT_OF(x)               ((Uint16)(x))
#define EMIF_SDINIT_OF(x)             ((Uint16)(x))

/* field values */
#define EMIF_SDINIT_INIT_OF(x)          ((Uint16)(x))
#define EMIF_SDINIT_INIT_OF(x)          ((Uint16)(x))


/*==========================================================================*\
*  EMIF_INIT_RMK
\*==========================================================================*/
/* make register value based on symbolic constants */

/* make register value based on symbolic constants */
#define EMIF_INIT_RMK(val) \
 ((Uint16) ( \
  ( EMIF_FMK(INIT,INIT,val))\
  )\
)

#define EMIF_INIT_RMKS(val_s) \
 ((Uint16) ( \
  ( EMIF_FMKS(INIT,INIT,val_s))\
  )\
)

/* make register value based on symbolic constants */
#define EMIF_SDINIT_RMK(val) \
 ((Uint16) ( \
  ( EMIF_FMK(SDINIT,INIT,val))\
  )\
)

#define EMIF_SDINIT_RMKS(val_s) \
 ((Uint16) ( \
  ( EMIF_FMKS(SDINIT,INIT,val_s))\
  )\
)

/*===========================================================================*\
* _EMIF_SDC2   - SDRAM Control Register 2
*
* Fields:
*  (RW) SDACC
*  (RW) TMRD
*  (RW) TRAS
*  (RW) TACTV2ACTV
\*==========================================================================*/

/*==========================================================================*\
*  EMIF_SDC2_DEFAULT Values
\*==========================================================================*/
/* default register value */
#define EMIF_SDC2_DEFAULT             (0x03FF)


#define EMIF_SDC2_OF(x)                 ((Uint16)(x))

/* field values */
#define EMIF_SDC2_SDACC_16BITBUS        (0u)
#define EMIF_SDC2_SDACC_32BITBUS        (1u)
#define EMIF_SDC2_TACTV2ACTV_OF(x)      ((Uint16)(x))
#define EMIF_SDC2_TRAS_OF(x)             ((Uint16)(x))
#define EMIF_SDC2_TMRD_OF(x)            ((Uint16)(x))

/*==========================================================================*\
*  EMIF_SDC2_RMK
\*==========================================================================*/
/* make register value based on symbolic constants */
#define EMIF_SDC2_RMK(sdacc,tmrd,tras,tactv2actv) \
 ((Uint16) ( \
  (EMIF_FMK(SDC2,SDACC,sdacc))|\
  (EMIF_FMK(SDC2,TMRD,tmrd))|\
  (EMIF_FMK(SDC2,TRAS,tras))|\
  (EMIF_FMK(SDC2,TACTV2ACTV,tactv2actv))\
  )\
) 

#define EMIF_SDC2_RMKS(sdacc_s,tmrd_s,tras_s,tactv2actv_s) \
 ((Uint16) ( \
  (EMIF_FMKS(SDC2,SDACC,sdacc_s))|\
  (EMIF_FMKS(SDC2,TMRD,tmrd_s))|\
  (EMIF_FMKS(SDC2,TRAS,tras_s))|\
  (EMIF_FMKS(SDC2,TACTV2ACTV,tactv2actv_s))\
  )\
) 


/****************************************\
* Define constants for EMIF clock
\****************************************/
#define EMIF_CKE_GPIO4            (0x0001u)
#define EMIF_CKE_XF               (0x0000u)
#define EMIF_CKEEN_ENABLED        (0x0001u)
#define EMIF_SRCOM_ENABLE         (0x0001u)
#define EMIF_SREF_DELAY_DEFAULT   (0x0028u)  
#define EMIF_SRCOM_DISABLED       (0x0000u)

/****************************************\
* EMIF global typedef declarations
\****************************************/

/* device configuration structure */
typedef struct {
  Uint16 egcr;
  Uint16 emirst;
  Uint16 ce01;
  Uint16 ce02;
  Uint16 ce03;
  Uint16 ce11;
  Uint16 ce12;
  Uint16 ce13;
  Uint16 ce21;
  Uint16 ce22;
  Uint16 ce23;
  Uint16 ce31;
  Uint16 ce32;
  Uint16 ce33;
  Uint16 sdc1;
  Uint16 sdper;
  Uint16 init;
  Uint16 sdc2;
} EMIF_Config;

/****************************************\
* EMIF global variable declarations
\****************************************/

/****************************************\
* EMIF global function declarations
\****************************************/

CSLAPI void EMIF_config(EMIF_Config *Config);
CSLAPI void EMIF_getConfig(EMIF_Config *Config);
CSLAPI void EMIF_configArgs(Uint16 egcr, Uint16 emirst, Uint16 ce01,
  Uint16 ce02, Uint16 ce03, Uint16 ce11, Uint16 ce12, Uint16 ce13,
  Uint16 ce21, Uint16 ce22, Uint16 ce23, Uint16 ce31, Uint16 ce32,
  Uint16 ce33, Uint16 sdc1, Uint16 sdper, Uint16 init, 
  Uint16 sdc2);

CSLAPI void EMIF_enterselfRefresh(Uint16 ckePin, Uint16 tRasDelay);
CSLAPI void EMIF_exitselfRefresh(Uint16 tXsrDelay);

/****************************************\
* EMIF inline function declarations
\****************************************/
static inline void EMIF_reset(void);

/****************************************\
* EMIF inline function definitions
\****************************************/
static inline void EMIF_reset(void) {
  EMIF_RSET(EMIRST,0xFFFF);
}

#endif /* EMIF_SUPPORT */
#endif /* _EMIFA_H_ */
/******************************************************************************\
* End of emif.h
\******************************************************************************/

csl_emifAhal.h/ 1049976849  0     0     0       67354     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... EMI
* FILENAME...... csl_emifhal.h
* DATE CREATED.. Wed 05/24/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. stdinc.h, chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  05/24/2000 created
*   MODIFIED: 04/16/2001 modifed FILENAME and other header comments
*   MODIFIED: 01/24/2002 fixed bug in EMIF_FSETS macro definition 
*   MODIFIED: 11/23/2002 added status bits to EMIF BUS Error Register (5509A) 
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the TIMER module)
*
* Registers Covered:
*   (RW) _EMIF_EGCR  -  Global Control Register
*   (W)  _EMIF_EMIRST  -  Global Reset Register
*   (R)  _EMIF_EMIBE  -  Bus Error Status Register
*   (RW) _EMIF_CE01 -  CE0 Space Control Register 1
*   (RW) _EMIF_CE02 -  CE0 Space Control Register 2
*   (RW) _EMIF_CE03 -  CE0 Space Control Register 3
*   (RW) _EMIF_CE11 -  CE1 Space Control Register 1
*   (RW) _EMIF_CE12 -  CE1 Space Control Register 2
*   (RW) _EMIF_CE13 -  CE1 Space Control Register 3
*   (RW) _EMIF_CE21 -  CE2 Space Control Register 1
*   (RW) _EMIF_CE22 -  CE2 Space Control Register 2
*   (RW) _EMIF_CE23 -  CE2 Space Control Register 3
*   (RW) _EMIF_CE31 -  CE3 Space Control Register 1
*   (RW) _EMIF_CE32 -  CE3 Space Control Register 2
*   (RW) _EMIF_CE33 -  CE3 Space Control Register 2
*   (RW) _EMIF_SDC1 - SDRAM Control Register 1
*   (R)  _EMIF_SDPER	- SDRAM Period Register
*   (R)  _EMIF_SDCNT - SDRAM Counter Register
*   (R)  _EMIF_INIT  - SDRAM Initialization Register
*   (RW) _EMIF_SDC2 - SDRAM Control Register 2
\******************************************************************************/
#ifndef _EMIFAHAL_H_
#define _EMIFAHAL_H_

#include <csl_std.h>
#include <csl_chiphal.h>

#if (_EMIFA_SUPPORT)

/*============================================================================*\
* misc declarations
\*============================================================================*/

#define _EMIF_DEVICE_CNT			(2)


/*============================================================================*\
* EMIF generic register and field  access macros
\*============================================================================*/

#define EMIF_ADDR(Reg)                _EMIF_##Reg##_ADDR
#define EMIF_RGET(Reg)                _PREG_GET(EMIF_ADDR(##Reg))
#define EMIF_RSET(Reg,Val)            _PREG_SET(EMIF_ADDR(##Reg),Val)
#define EMIF_RAOI(Reg,AND,OR,INV)     _PREG_AOI(EMIF_ADDR(##Reg),AND,OR,INV)
#define EMIF_FGET(Reg,Field)          _PFIELD_GET(EMIF_ADDR(##Reg), _EMIF_##Reg##_##Field)
#define EMIF_FSET(Reg,Field,Val)      _PFIELD_SET(EMIF_ADDR(##Reg), _EMIF_##Reg##_##Field,Val)
#define EMIF_FSETS(Reg,Field,Sym)     EMIF_FSET(##Reg,##Field,EMIF_##Reg##_##Field##_##Sym)
#define EMIF_FMK(Reg,Field,Val)       _EMIF_##Reg##_##Field##_MK(Val)
#define EMIF_FMKS(Reg,Field,Sym)      EMIF_FMK(##Reg,##Field,EMIF_##Reg##_##Field##_##Sym)
#define EMIF_FAOI(Reg,Field,AND,OR,INV)\
  _PFIELD_AOI(EMIF_ADDR(##Reg),_EMIF_##Reg##_##Field,AND,OR,INV)

/*============================================================================*\
* _EMIF_EGCR:  Global Control Register
\*============================================================================*/
#define _EMIF_EGCR_ADDR				(0x0800u)
#define _EMIF_EGCR                       	PREG16(_EMIF_EGCR_ADDR)
#define _EGCR                           	_EMIF_EGCR

/*============================================================================*\
* _EMIF_EGCR_GET and _EMIF_EGCR_SET
\*============================================================================*/
#define _EMIF_EGCR_GET(RegAddr)		_PREG_GET(RegAddr)
#define _EMIF_EGCR_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/*============================================================================*\
* _EMIF_EMIRST:  Global Reset Register
\*============================================================================*/
#define _EMIF_EMIRST_ADDR			(0x0801u)
#define _EMIF_EMIRST                     	PREG16(_EMIF_EMIRST_ADDR)
#define _EMIRST                          	_EMIF_EMIRST

/*============================================================================*\
* _EMIF_EMIRST_GET 
\*============================================================================*/

#define _EMIF_EMIRST_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/*============================================================================*\
* _EMIF_EMIBE:  Bus Error Status Register
\*============================================================================*/
#define _EMIF_EMIBE_ADDR				(0x0802u)
#define _EMIF_EMIBE                       	PREG16(_EMIF_EMIBE_ADDR)
#define _EMIBE                              	_EMIF_EMIBE

/*============================================================================*\
* _EMIF_EMIBE_GET 
\*============================================================================*/
#define _EMIF_EMIBE_GET(RegAddr)		_PREG_GET(RegAddr)

/*============================================================================*\
* _EMIF_CE01:  CE0 Space Control Register 1
\*============================================================================*/
#define _EMIF_CE01_ADDR				(0x0803u)
#define _EMIF_CE01                       	PREG16(_EMIF_CE01_ADDR)
#define _CE01                              _EMIF_CE01

/*============================================================================*\
* _EMIF_CE02:  CE0 Space Control Register 2
\*============================================================================*/
#define _EMIF_CE02_ADDR				(0x0804u)
#define _EMIF_CE02                       	PREG16(_EMIF_CE02_ADDR)
#define _CE02                              _EMIF_CE02

/*============================================================================*\
* _EMIF_CE03:  CE0 Space Control Register 3
\*============================================================================*/
#define _EMIF_CE03_ADDR				(0x0805u)
#define _EMIF_CE03                       	PREG16(_EMIF_CE03_ADDR)
#define _CE03                              _EMIF_CE03

/*============================================================================*\
* _EMIF_CE11:  CE1 Space Control Register 1
\*============================================================================*/
#define _EMIF_CE11_ADDR				(0x0806u)
#define _EMIF_CE11                       	PREG16(_EMIF_CE11_ADDR)
#define _CE11                              _EMIF_CE11

/*============================================================================*\
* _EMIF_CE12:  CE1 Space Control Register 2
\*============================================================================*/
#define _EMIF_CE12_ADDR				(0x0807u)
#define _EMIF_CE12                       	PREG16(_EMIF_CE12_ADDR)
#define _CE12                              _EMIF_CE12

/*============================================================================*\
* _EMIF_CE13:  CE1 Space Control Register 3
\*============================================================================*/
#define _EMIF_CE13_ADDR				(0x0808u)
#define _EMIF_CE13                       	PREG16(_EMIF_CE13_ADDR)
#define _CE13                              _EMIF_CE13

/*============================================================================*\
* _EMIF_CE21:  CE2 Space Control Register 1
\*============================================================================*/
#define _EMIF_CE21_ADDR				(0x0809u)
#define _EMIF_CE21                       	PREG16(_EMIF_CE21_ADDR)
#define _CE21                              _EMIF_CE21

/*============================================================================*\
* _EMIF_CE22:  CE2 Space Control Register 2
\*============================================================================*/
#define _EMIF_CE22_ADDR				(0x080Au)
#define _EMIF_CE22                       	PREG16(_EMIF_CE22_ADDR)
#define _CE22                              _EMIF_CE22

/*============================================================================*\
* _EMIF_CE23:  CE2 Space Control Register 3
\*============================================================================*/
#define _EMIF_CE23_ADDR				(0x080Bu)
#define _EMIF_CE23                       	PREG16(_EMIF_CE23_ADDR)
#define _CE23                              _EMIF_CE23

/*============================================================================*\
* _EMIF_CE31:  CE3 Space Control Register 1
\*============================================================================*/
#define _EMIF_CE31_ADDR				(0x080Cu)
#define _EMIF_CE31                       	PREG16(_EMIF_CE31_ADDR)
#define _CE31                              _EMIF_CE31

/*============================================================================*\
* _EMIF_CE32:  CE3 Space Control Register 2
\*============================================================================*/
#define _EMIF_CE32_ADDR				(0x080Du)
#define _EMIF_CE32                       	PREG16(_EMIF_CE32_ADDR)
#define _CE32                              _EMIF_CE32

/*============================================================================*\
* _EMIF_CE33:  CE3 Space Control Register 3
\*============================================================================*/
#define _EMIF_CE33_ADDR				(0x080Eu)
#define _EMIF_CE33                       	PREG16(_EMIF_CE33_ADDR)
#define _CE33                              _EMIF_CE33

/*============================================================================*\
* _EMIF_SDC1:  SDRAM Control Register 1
\*============================================================================*/
#define _EMIF_SDC1_ADDR			(0x080Fu)
#define _EMIF_SDC1                    PREG16(_EMIF_SDC1_ADDR)
#define _SDC1	                        _EMIF_SDC1

/*============================================================================*\
* _EMIF_SDC1_GET and _EMIF_SDC1_SET
\*============================================================================*/
#define _EMIF_SDC1_GET(RegAddr)		_PREG_GET(RegAddr)
#define _EMIF_SDC1_SET(RegAddr,Val)	_PREG_SET(RegAddr,Val)


/*============================================================================*\
* _EMIF_SDPER:  SDRAM Period Register
\*============================================================================*/
#define _EMIF_SDPER_ADDR			(0x0810u)
#define _EMIF_SDPER                    	PREG16(_EMIF_SDPER_ADDR)
#define _SDPER	                        _EMIF_SDPER

/*============================================================================*\
* _EMIF_SDCNT:  SDRAM Counter Register
\*============================================================================*/
#define _EMIF_SDCNT_ADDR			(0x0811u)
#define _EMIF_SDCNT                    PREG16(_EMIF_SDCNT_ADDR)
#define _SDCNT	                        _EMIF_SDCNT


/*============================================================================*\
* _EMIF_INIT:  SDRAM Initialization Register
\*============================================================================*/
#define _EMIF_INIT_ADDR			     (0x0812u)
#define _EMIF_INIT                    	PREG16(_EMIF_INIT_ADDR)
#define _INIT	                        _EMIF_INIT

#define _EMIF_SDINIT_ADDR			(0x0812u)
#define _EMIF_SDINIT                    	PREG16(_EMIF_SDINIT_ADDR)
#define _SDINIT	                        _EMIF_SDINIT

/*============================================================================*\
* _EMIF_SDC2:  SDRAM Control Register 2
\*============================================================================*/
#define _EMIF_SDC2_ADDR			  (0x0813u)
#define _EMIF_SDC2                    PREG16(_EMIF_SDC2_ADDR)
#define _SDC2	                    _EMIF_SDC2

/*============================================================================*\
* _EMIF_IPMR:  Internal Power Management Register
\*============================================================================*/
#define _EMIF_IPMR_ADDR			  (0x0814u)
#define _EMIF_IPMR                    PREG16(_EMIF_IPMR_ADDR)
#define _IPMR	                    _EMIF_IPMR

/* \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */
/* \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */
/* \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */
/* \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */
/* \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */
/* ============================================================================ *\
* _EMIF_EGCR	   - Global Control Register
*
* Fields:
*  (RW) _EMIF_EGCR_MEMFREQ	- Memory Clock Frequency field
*  (RW) _EMIF_EGCR_WPE		- Write Posting Enable field
*  (RW) _EMIF_EGCR_MEMCEN	- Mem Clock Enable field
*  (R)  _EMIF_EGCR_ARDY		- Value of ARDY input
*  (R)  _EMIF_EGCR_HOLD		- Value of /HOLD input
*  (R)  _EMIF_EGCR_HOLDA		- Value of /HOLDA output
*  (RW)  _EMIF_EGCR_NOHOLD	- External HOLD disable field
\*============================================================================*/

/*==========================================================================*\
* (RW) _EMIF_EGCR_MEMFREQ
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_MEMFREQ_SHIFT		(0x0009u)
#define _EMIF_EGCR_MEMFREQ_MK(n)           (((Uint16)(n) & 0x0003u) << _EMIF_EGCR_MEMFREQ_SHIFT)
#define _EMIF_EGCR_MEMFREQ_MASK            (_EMIF_EGCR_MEMFREQ_MK(0x0003u))
#define _EMIF_EGCR_MEMFREQ_CLR             (~(_EMIF_EGCR_MEMFREQ_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_EGCR_WPE
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_WPE_SHIFT			(0x0007u)
#define _EMIF_EGCR_WPE_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EGCR_WPE_SHIFT)
#define _EMIF_EGCR_WPE_MASK            	(_EMIF_EGCR_WPE_MK(0x0001u))
#define _EMIF_EGCR_WPE_CLR             	(~(_EMIF_EGCR_WPE_MK(0x0001u)))

/*==========================================================================*\
* (RW) _EMIF_EGCR_MEMCEN
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_MEMCEN_SHIFT		(0x0005u)
#define _EMIF_EGCR_MEMCEN_MK(n)           (((Uint16)(n) & 0x0001u) << _EMIF_EGCR_MEMCEN_SHIFT)
#define _EMIF_EGCR_MEMCEN_MASK            (_EMIF_EGCR_MEMCEN_MK(0x0001u))
#define _EMIF_EGCR_MEMCEN_CLR             (~(_EMIF_EGCR_MEMCEN_MK(0x0001u)))

/*==========================================================================*\
* (R) _EMIF_EGCR_ARDY
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_ARDY_SHIFT			(0x0003u)
#define _EMIF_EGCR_ARDY_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EGCR_ARDY_SHIFT)
#define _EMIF_EGCR_ARDY_MASK            	(_EMIF_EGCR_ARDY_MK(0x0001u))
#define _EMIF_EGCR_ARDY_CLR               (~(_EMIF_EGCR_ARDY_MASK))

/*==========================================================================*\
* (R) _EMIF_EGCR_HOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_HOLD_SHIFT			(0x0002u)
#define _EMIF_EGCR_HOLD_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EGCR_HOLD_SHIFT)
#define _EMIF_EGCR_HOLD_MASK            	(_EMIF_EGCR_HOLD_MK(0x0001u))
#define _EMIF_EGCR_HOLD_CLR               (~(_EMIF_EGCR_HOLD_MASK))

/*==========================================================================*\
* (R) _EMIF_EGCR_HOLDA
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_HOLDA_SHIFT		(0x0001u)
#define _EMIF_EGCR_HOLDA_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EGCR_HOLDA_SHIFT)
#define _EMIF_EGCR_HOLDA_MASK            	(_EMIF_EGCR_HOLDA_MK(0x0001u))
#define _EMIF_EGCR_HOLDA_CLR              (~(_EMIF_EGCR_HOLDA_MASK))

/*==========================================================================*\
* (RW) _EMIF_EGCR_NOHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_NOHOLD_SHIFT		(0x0000u)
#define _EMIF_EGCR_NOHOLD_MK(n)           (((Uint16)(n) & 0x0001u) << _EMIF_EGCR_NOHOLD_SHIFT)
#define _EMIF_EGCR_NOHOLD_MASK            (_EMIF_EGCR_NOHOLD_MK(0x0001u))
#define _EMIF_EGCR_NOHOLD_CLR             (~(_EMIF_EGCR_NOHOLD_MK(0x0001u)))

/*==========================================================================*\
* _EMIF_EGCR	- Global Control Register Config
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_CFG(memfreq,wpe,memcen,nohold) \
	_PREG_SET(_EMIF_EGCR_ADDR,\
    		(Uint16) (_EMIF_EGCR_MEMFREQ_MK(memfreq)|\
				_EMIF_EGCR_WPE_MK(wpe)|\
				_EMIF_EGCR_MEMCEN_MK(memcen)|\
				_EMIF_EGCR_NOHOLD_MK(nohold)\
             ))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _EMIF_EMIRST		- Global Reset Register
*
* Fields:
*  (W) _EMIF_EMIRST_EMIRST
\*============================================================================*/
#define _EMIF_EMIRST_EMIRST_SHIFT			(0x0000u)
#define _EMIF_EMIRST_EMIRST_MK(n)           	(((Uint16)(n) & 0xFFFFu) << _EMIF_EMIRST_EMIRST_SHIFT)
#define _EMIF_EMIRST_EMIRST_MASK            	(_EMIF_EMIRST_EMIRST_MK(0xFFFFu))
#define _EMIF_EMIRST_EMIRST_CLR             	(~(_EMIF_EMIRST_EMIRST_MK(0xFFFFu)))

/*==========================================================================*\
* _EMIF_EMIRST		- Global Reset Register Config
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIRST_CFG(EMIRST) \
	_PREG_SET(_EMIF_EMIRST_ADDR,\
    		(Uint16) (	_EMIF_EMIRST_EMIRST_MK(EMIRST)\
	))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*=============================================================================*\
* _EMIF_EMIBE	   - Bus Error Status Register
*
* Fields:
*  (R) _EMIF_EMIBE_TIME
*  (R) _EMIF_EMIBE_CE3
*  (R) _EMIF_EMIBE_CE2
*  (R) _EMIF_EMIBE_CE1
*  (R) _EMIF_EMIBE_CE0
*  (R) _EMIF_EMIBE_DMA
*  (R) _EMIF_EMIBE_FBUS
*  (R) _EMIF_EMIBE_EBUS
*  (R) _EMIF_EMIBE_DBUS
*  (R) _EMIF_EMIBE_CBUS
*  (R) _EMIF_EMIBE_PBUS
\*============================================================================*/

/*==========================================================================*\
* (R) _EMIF_EMIBE_TIME
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_TIME_SHIFT		(0x000Cu)
#define _EMIF_EMIBE_TIME_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_TIME_SHIFT)
#define _EMIF_EMIBE_TIME_MASK            	(_EMIF_EMIBE_TIME_MK(0x0001u))
#define _EMIF_EMIBE_TIME_CLR              (~(_EMIF_EMIBE_TIME_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_CE3
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_CE3_SHIFT			(0x000Au)
#define _EMIF_EMIBE_CE3_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_CE3_SHIFT)
#define _EMIF_EMIBE_CE3_MASK            	(_EMIF_EMIBE_CE3_MK(0x0001u))
#define _EMIF_EMIBE_CE3_CLR               (~(_EMIF_EMIBE_CE3_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_CE2
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_CE2_SHIFT			(0x0009u)
#define _EMIF_EMIBE_CE2_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_CE2_SHIFT)
#define _EMIF_EMIBE_CE2_MASK            	(_EMIF_EMIBE_CE2_MK(0x0001u))
#define _EMIF_EMIBE_CE2_CLR               (~(_EMIF_EMIBE_CE2_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_CE1
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_CE1_SHIFT			(0x0008u)
#define _EMIF_EMIBE_CE1_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_CE1_SHIFT)
#define _EMIF_EMIBE_CE1_MASK            	(_EMIF_EMIBE_CE1_MK(0x0001u))
#define _EMIF_EMIBE_CE1_CLR               (~(_EMIF_EMIBE_CE1_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_CE0
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_CE0_SHIFT			(0x0007u)
#define _EMIF_EMIBE_CE0_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_CE0_SHIFT)
#define _EMIF_EMIBE_CE0_MASK            	(_EMIF_EMIBE_CE0_MK(0x0001u))
#define _EMIF_EMIBE_CE0_CLR               (~(_EMIF_EMIBE_CE0_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_DMA
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_DMA_SHIFT			(0x0006u)
#define _EMIF_EMIBE_DMA_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_DMA_SHIFT)
#define _EMIF_EMIBE_DMA_MASK            	(_EMIF_EMIBE_DMA_MK(0x0001u))
#define _EMIF_EMIBE_DMA_CLR               (~(_EMIF_EMIBE_DMA_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_FBUS
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_FBUS_SHIFT		(0x0005u)
#define _EMIF_EMIBE_FBUS_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_FBUS_SHIFT)
#define _EMIF_EMIBE_FBUS_MASK            	(_EMIF_EMIBE_FBUS_MK(0x0001u))
#define _EMIF_EMIBE_FBUS_CLR              (~(_EMIF_EMIBE_FBUS_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_EBUS
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_EBUS_SHIFT		(0x0004u)
#define _EMIF_EMIBE_EBUS_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_EBUS_SHIFT)
#define _EMIF_EMIBE_EBUS_MASK            	(_EMIF_EMIBE_EBUS_MK(0x0001u))
#define _EMIF_EMIBE_EBUS_CLR              (~(_EMIF_EMIBE_EBUS_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_DBUS
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_DBUS_SHIFT		(0x0003u)
#define _EMIF_EMIBE_DBUS_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_DBUS_SHIFT)
#define _EMIF_EMIBE_DBUS_MASK            	(_EMIF_EMIBE_DBUS_MK(0x0001u))
#define _EMIF_EMIBE_DBUS_CLR              (~(_EMIF_EMIBE_DBUS_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_CBUS
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_CBUS_SHIFT		(0x0002u)
#define _EMIF_EMIBE_CBUS_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_CBUS_SHIFT)
#define _EMIF_EMIBE_CBUS_MASK            	(_EMIF_EMIBE_CBUS_MK(0x0001u))
#define _EMIF_EMIBE_CBUS_CLR              (~(_EMIF_EMIBE_CBUS_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_PBUS
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_PBUS_SHIFT		(0x0000u)
#define _EMIF_EMIBE_PBUS_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_PBUS_SHIFT)
#define _EMIF_EMIBE_PBUS_MASK            	(_EMIF_EMIBE_PBUS_MK(0x0001u))
#define _EMIF_EMIBE_PBUS_CLR              (~(_EMIF_EMIBE_PBUS_MASK))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE01   - Space Control Register 1
* _EMIF_CE11   - Space Control Register 1
* _EMIF_CE21   - Space Control Register 1
* _EMIF_CE31   - Space Control Register 1
*
* Fields:
*  (RW) _EMIF_CEx1_MTYPE	- MTYPE field
*  (RW) _EMIF_CEx1_RDSETUP	- Read Setup field
*  (RW) _EMIF_CEx1_RDSTROBE	- Read Strobe field
*  (RW) _EMIF_CEx1_RDHOLD	- Read Hold field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE01_MTYPE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE01_MTYPE_SHIFT		(0x000Cu)
#define _EMIF_CE01_MTYPE_MK(n)           	(((Uint16)(n) & 0x0007u) << _EMIF_CE01_MTYPE_SHIFT)
#define _EMIF_CE01_MTYPE_MASK            	(_EMIF_CE01_MTYPE_MK(0x0007u))
#define _EMIF_CE01_MTYPE_CLR             	(~(_EMIF_CE01_MTYPE_MK(0x0007u)))

/*==========================================================================*\
* (RW) _EMIF_CE01_RDSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE01_RDSETUP_SHIFT		(0x0008u)
#define _EMIF_CE01_RDSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE01_RDSETUP_SHIFT)
#define _EMIF_CE01_RDSETUP_MASK           (_EMIF_CE01_RDSETUP_MK(0x000Fu))
#define _EMIF_CE01_RDSETUP_CLR            (~(_EMIF_CE01_RDSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE01_RDSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE01_RDSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE01_RDSTROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE01_RDSTROBE_SHIFT)
#define _EMIF_CE01_RDSTROBE_MASK          (_EMIF_CE01_RDSTROBE_MK(0x003Fu))
#define _EMIF_CE01_RDSTROBE_CLR           (~(_EMIF_CE01_RDSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE01_RDHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE01_RDHOLD_SHIFT		(0x0000u)
#define _EMIF_CE01_RDHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE01_RDHOLD_SHIFT)
#define _EMIF_CE01_RDHOLD_MASK          	(_EMIF_CE01_RDHOLD_MK(0x0003u))
#define _EMIF_CE01_RDHOLD_CLR           	(~(_EMIF_CE01_RDHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE01	- CE(0/1/2/3) Space Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE01_CFG(Sp,mtype,rdsetup,rdstrobe,rdhold) \
	_PREG_SET(_EMIF_CE01_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE01_MTYPE_MK(mtype) 		|	\
				_EMIF_CE01_RDSETUP_MK(rdsetup)	|	\
				_EMIF_CE01_RDSTROBE_MK(rdstrobe) 	|	\
				_EMIF_CE01_RDHOLD_MK(rdhold) 			\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE11_MTYPE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE11_MTYPE_SHIFT		(0x000Cu)
#define _EMIF_CE11_MTYPE_MK(n)           	(((Uint16)(n) & 0x0007u) << _EMIF_CE11_MTYPE_SHIFT)
#define _EMIF_CE11_MTYPE_MASK            	(_EMIF_CE11_MTYPE_MK(0x0007u))
#define _EMIF_CE11_MTYPE_CLR             	(~(_EMIF_CE11_MTYPE_MK(0x0007u)))

/*==========================================================================*\
* (RW) _EMIF_CE11_RDSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE11_RDSETUP_SHIFT		(0x0008u)
#define _EMIF_CE11_RDSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE11_RDSETUP_SHIFT)
#define _EMIF_CE11_RDSETUP_MASK           (_EMIF_CE11_RDSETUP_MK(0x000Fu))
#define _EMIF_CE11_RDSETUP_CLR            (~(_EMIF_CE11_RDSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE11_RDSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE11_RDSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE11_RDSTROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE11_RDSTROBE_SHIFT)
#define _EMIF_CE11_RDSTROBE_MASK          (_EMIF_CE11_RDSTROBE_MK(0x003Fu))
#define _EMIF_CE11_RDSTROBE_CLR           (~(_EMIF_CE11_RDSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE11_RDHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE11_RDHOLD_SHIFT		(0x0000u)
#define _EMIF_CE11_RDHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE11_RDHOLD_SHIFT)
#define _EMIF_CE11_RDHOLD_MASK          	(_EMIF_CE11_RDHOLD_MK(0x0003u))
#define _EMIF_CE11_RDHOLD_CLR           	(~(_EMIF_CE11_RDHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE11	- CE(0/1/2/3) Space Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE11_CFG(Sp,mtype,rdsetup,rdstrobe,rdhold) \
	_PREG_SET(_EMIF_CE11_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE11_MTYPE_MK(mtype) 		|	\
				_EMIF_CE11_RDSETUP_MK(rdsetup)	|	\
				_EMIF_CE11_RDSTROBE_MK(rdstrobe) 	|	\
				_EMIF_CE11_RDHOLD_MK(rdhold) 			\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE21_MTYPE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE21_MTYPE_SHIFT		(0x000Cu)
#define _EMIF_CE21_MTYPE_MK(n)           	(((Uint16)(n) & 0x0007u) << _EMIF_CE21_MTYPE_SHIFT)
#define _EMIF_CE21_MTYPE_MASK            	(_EMIF_CE21_MTYPE_MK(0x0007u))
#define _EMIF_CE21_MTYPE_CLR             	(~(_EMIF_CE21_MTYPE_MK(0x0007u)))

/*==========================================================================*\
* (RW) _EMIF_CE21_RDSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE21_RDSETUP_SHIFT		(0x0008u)
#define _EMIF_CE21_RDSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE21_RDSETUP_SHIFT)
#define _EMIF_CE21_RDSETUP_MASK           (_EMIF_CE21_RDSETUP_MK(0x000Fu))
#define _EMIF_CE21_RDSETUP_CLR            (~(_EMIF_CE21_RDSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE21_RDSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE21_RDSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE21_RDSTROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE21_RDSTROBE_SHIFT)
#define _EMIF_CE21_RDSTROBE_MASK          (_EMIF_CE21_RDSTROBE_MK(0x003Fu))
#define _EMIF_CE21_RDSTROBE_CLR           (~(_EMIF_CE21_RDSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE21_RDHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE21_RDHOLD_SHIFT		(0x0000u)
#define _EMIF_CE21_RDHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE21_RDHOLD_SHIFT)
#define _EMIF_CE21_RDHOLD_MASK          	(_EMIF_CE21_RDHOLD_MK(0x0003u))
#define _EMIF_CE21_RDHOLD_CLR           	(~(_EMIF_CE21_RDHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE21	- CE(0/1/2/3) Space Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE21_CFG(Sp,mtype,rdsetup,rdstrobe,rdhold) \
	_PREG_SET(_EMIF_CE21_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE21_MTYPE_MK(mtype) 		|	\
				_EMIF_CE21_RDSETUP_MK(rdsetup)	|	\
				_EMIF_CE21_RDSTROBE_MK(rdstrobe) 	|	\
				_EMIF_CE21_RDHOLD_MK(rdhold) 			\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE31_MTYPE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE31_MTYPE_SHIFT		(0x000Cu)
#define _EMIF_CE31_MTYPE_MK(n)           	(((Uint16)(n) & 0x0007u) << _EMIF_CE31_MTYPE_SHIFT)
#define _EMIF_CE31_MTYPE_MASK            	(_EMIF_CE31_MTYPE_MK(0x0007u))
#define _EMIF_CE31_MTYPE_CLR             	(~(_EMIF_CE31_MTYPE_MK(0x0007u)))

/*==========================================================================*\
* (RW) _EMIF_CE31_RDSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE31_RDSETUP_SHIFT		(0x0008u)
#define _EMIF_CE31_RDSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE31_RDSETUP_SHIFT)
#define _EMIF_CE31_RDSETUP_MASK           (_EMIF_CE31_RDSETUP_MK(0x000Fu))
#define _EMIF_CE31_RDSETUP_CLR            (~(_EMIF_CE31_RDSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE31_RDSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE31_RDSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE31_RDSTROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE31_RDSTROBE_SHIFT)
#define _EMIF_CE31_RDSTROBE_MASK          (_EMIF_CE31_RDSTROBE_MK(0x003Fu))
#define _EMIF_CE31_RDSTROBE_CLR           (~(_EMIF_CE31_RDSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE31_RDHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE31_RDHOLD_SHIFT		(0x0000u)
#define _EMIF_CE31_RDHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE31_RDHOLD_SHIFT)
#define _EMIF_CE31_RDHOLD_MASK          	(_EMIF_CE31_RDHOLD_MK(0x0003u))
#define _EMIF_CE31_RDHOLD_CLR           	(~(_EMIF_CE31_RDHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE31	- CE(0/1/2/3) Space Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE31_CFG(Sp,mtype,rdsetup,rdstrobe,rdhold) \
	_PREG_SET(_EMIF_CE31_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE31_MTYPE_MK(mtype) 		|	\
				_EMIF_CE31_RDSETUP_MK(rdsetup)	|	\
				_EMIF_CE31_RDSTROBE_MK(rdstrobe) 	|	\
				_EMIF_CE31_RDHOLD_MK(rdhold) 			\
             ))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE02   - Space Control Register 2
* _EMIF_CE12   - Space Control Register 2
* _EMIF_CE22   - Space COntrol Register 2
* _EMIF_CE32   - Space Control Register 2
*
* Fields:
*  (RW) _EMIF_CEx2_RDEXHLD 	- Extended Hold Read field
*  (RW) _EMIF_CEx2_WREXHLD	- Extended Hold Write field
*  (RW) _EMIF_CEx2_WRSETUP	- Write Setup field
*  (RW) _EMIF_CEx2_WRSTROBE	- Write Strobe field
*  (RW) _EMIF_CEx2_WRHOLD	- Write Hold field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE02_RDEXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_RDEXHLD_SHIFT		(0x000Eu)
#define _EMIF_CE02_RDEXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE02_RDEXHLD_SHIFT)
#define _EMIF_CE02_RDEXHLD_MASK          	(_EMIF_CE02_RDEXHLD_MK(0x0003u))
#define _EMIF_CE02_RDEXHLD_CLR           	(~(_EMIF_CE02_RDEXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE02_WREXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_WREXHLD_SHIFT		(0x000Cu)
#define _EMIF_CE02_WREXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE02_WREXHLD_SHIFT)
#define _EMIF_CE02_WREXHLD_MASK          	(_EMIF_CE02_WREXHLD_MK(0x0003u))
#define _EMIF_CE02_WREXHLD_CLR           	(~(_EMIF_CE02_WREXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE02_WRSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_WRSETUP_SHIFT		(0x0008u)
#define _EMIF_CE02_WRSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE02_WRSETUP_SHIFT)
#define _EMIF_CE02_WRSETUP_MASK          	(_EMIF_CE02_WRSETUP_MK(0x000Fu))
#define _EMIF_CE02_WRSETUP_CLR           	(~(_EMIF_CE02_WRSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE02_WRSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_WRSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE02_WRSTROBE_MK(n)		(((Uint16)(n) & 0x003Fu) << _EMIF_CE02_WRSTROBE_SHIFT)
#define _EMIF_CE02_WRSTROBE_MASK          (_EMIF_CE02_WRSTROBE_MK(0x003Fu))
#define _EMIF_CE02_WRSTROBE_CLR           (~(_EMIF_CE02_WRSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE02_WRHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_WRHOLD_SHIFT		(0x0000u)
#define _EMIF_CE02_WRHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE02_WRHOLD_SHIFT)
#define _EMIF_CE02_WRHOLD_MASK          	(_EMIF_CE02_WRHOLD_MK(0x0003u))
#define _EMIF_CE02_WRHOLD_CLR           	(~(_EMIF_CE02_WRHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE02		- CE(0/1/2/3) Space Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_CFG(Sp,rdexhld,wrexhld,wrsetup,wrstrobe,wrhold) \
	_PREG_SET(_EMIF_CE02_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE02_RDEXHLD_MK(rdexhld) 	|	\
				_EMIF_CE02_WREXHLD_MK(wrexhld)		|	\
				_EMIF_CE02_WRSETUP_MK(wrsetup) 	|	\
				_EMIF_CE02_WRSTROBE_MK(wrstrobe) 	|	\
				_EMIF_CE02_WRHOLD_MK(wrhold) 			\
             ))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE02   - Space Control Register 2
* _EMIF_CE12   - Space Control Register 2
* _EMIF_CE22   - Space COntrol Register 2
* _EMIF_CE32   - Space Control Register 2
*
* Fields:
*  (RW) _EMIF_CEx2_RDEXHLD 	- Extended Hold Read field
*  (RW) _EMIF_CEx2_WREXHLD	- Extended Hold Write field
*  (RW) _EMIF_CEx2_WRSETUP	- Write Setup field
*  (RW) _EMIF_CEx2_WRSTROBE	- Write Strobe field
*  (RW) _EMIF_CEx2_WRHOLD	- Write Hold field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE12_RDEXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_RDEXHLD_SHIFT		(0x000Eu)
#define _EMIF_CE12_RDEXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE12_RDEXHLD_SHIFT)
#define _EMIF_CE12_RDEXHLD_MASK          	(_EMIF_CE12_RDEXHLD_MK(0x0003u))
#define _EMIF_CE12_RDEXHLD_CLR           	(~(_EMIF_CE12_RDEXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE12_WREXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_WREXHLD_SHIFT		(0x000Cu)
#define _EMIF_CE12_WREXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE12_WREXHLD_SHIFT)
#define _EMIF_CE12_WREXHLD_MASK          	(_EMIF_CE12_WREXHLD_MK(0x0003u))
#define _EMIF_CE12_WREXHLD_CLR           	(~(_EMIF_CE12_WREXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE12_WRSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_WRSETUP_SHIFT		(0x0008u)
#define _EMIF_CE12_WRSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE12_WRSETUP_SHIFT)
#define _EMIF_CE12_WRSETUP_MASK          	(_EMIF_CE12_WRSETUP_MK(0x000Fu))
#define _EMIF_CE12_WRSETUP_CLR           	(~(_EMIF_CE12_WRSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE12_WRSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_WRSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE12_WRSTROBE_MK(n)		(((Uint16)(n) & 0x003Fu) << _EMIF_CE12_WRSTROBE_SHIFT)
#define _EMIF_CE12_WRSTROBE_MASK          (_EMIF_CE12_WRSTROBE_MK(0x003Fu))
#define _EMIF_CE12_WRSTROBE_CLR           (~(_EMIF_CE12_WRSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE12_WRHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_WRHOLD_SHIFT		(0x0000u)
#define _EMIF_CE12_WRHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE12_WRHOLD_SHIFT)
#define _EMIF_CE12_WRHOLD_MASK          	(_EMIF_CE12_WRHOLD_MK(0x0003u))
#define _EMIF_CE12_WRHOLD_CLR           	(~(_EMIF_CE12_WRHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE12		- CE(0/1/2/3) Space Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_CFG(Sp,rdexhld,wrexhld,wrsetup,wrstrobe,wrhold) \
	_PREG_SET(_EMIF_CE12_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE12_RDEXHLD_MK(rdexhld) 	|	\
				_EMIF_CE12_WREXHLD_MK(wrexhld)		|	\
				_EMIF_CE12_WRSETUP_MK(wrsetup) 	|	\
				_EMIF_CE12_WRSTROBE_MK(wrstrobe) 	|	\
				_EMIF_CE12_WRHOLD_MK(wrhold) 			\
             ))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE02   - Space Control Register 2
* _EMIF_CE12   - Space Control Register 2
* _EMIF_CE22   - Space COntrol Register 2
* _EMIF_CE32   - Space Control Register 2
*
* Fields:
*  (RW) _EMIF_CEx2_RDEXHLD 	- Extended Hold Read field
*  (RW) _EMIF_CEx2_WREXHLD	- Extended Hold Write field
*  (RW) _EMIF_CEx2_WRSETUP	- Write Setup field
*  (RW) _EMIF_CEx2_WRSTROBE	- Write Strobe field
*  (RW) _EMIF_CEx2_WRHOLD	- Write Hold field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE22_RDEXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_RDEXHLD_SHIFT		(0x000Eu)
#define _EMIF_CE22_RDEXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE22_RDEXHLD_SHIFT)
#define _EMIF_CE22_RDEXHLD_MASK          	(_EMIF_CE22_RDEXHLD_MK(0x0003u))
#define _EMIF_CE22_RDEXHLD_CLR           	(~(_EMIF_CE22_RDEXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE22_WREXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_WREXHLD_SHIFT		(0x000Cu)
#define _EMIF_CE22_WREXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE22_WREXHLD_SHIFT)
#define _EMIF_CE22_WREXHLD_MASK          	(_EMIF_CE22_WREXHLD_MK(0x0003u))
#define _EMIF_CE22_WREXHLD_CLR           	(~(_EMIF_CE22_WREXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE22_WRSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_WRSETUP_SHIFT		(0x0008u)
#define _EMIF_CE22_WRSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE22_WRSETUP_SHIFT)
#define _EMIF_CE22_WRSETUP_MASK          	(_EMIF_CE22_WRSETUP_MK(0x000Fu))
#define _EMIF_CE22_WRSETUP_CLR           	(~(_EMIF_CE22_WRSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE22_WRSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_WRSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE22_WRSTROBE_MK(n)		(((Uint16)(n) & 0x003Fu) << _EMIF_CE22_WRSTROBE_SHIFT)
#define _EMIF_CE22_WRSTROBE_MASK          (_EMIF_CE22_WRSTROBE_MK(0x003Fu))
#define _EMIF_CE22_WRSTROBE_CLR           (~(_EMIF_CE22_WRSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE22_WRHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_WRHOLD_SHIFT		(0x0000u)
#define _EMIF_CE22_WRHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE22_WRHOLD_SHIFT)
#define _EMIF_CE22_WRHOLD_MASK          	(_EMIF_CE22_WRHOLD_MK(0x0003u))
#define _EMIF_CE22_WRHOLD_CLR           	(~(_EMIF_CE22_WRHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE22		- CE(0/1/2/3) Space Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_CFG(Sp,rdexhld,wrexhld,wrsetup,wrstrobe,wrhold) \
	_PREG_SET(_EMIF_CE22_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE22_RDEXHLD_MK(rdexhld) 	|	\
				_EMIF_CE22_WREXHLD_MK(wrexhld)		|	\
				_EMIF_CE22_WRSETUP_MK(wrsetup) 	|	\
				_EMIF_CE22_WRSTROBE_MK(wrstrobe) 	|	\
				_EMIF_CE22_WRHOLD_MK(wrhold) 			\
             ))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE02   - Space Control Register 2
* _EMIF_CE12   - Space Control Register 2
* _EMIF_CE22   - Space COntrol Register 2
* _EMIF_CE32   - Space Control Register 2
*
* Fields:
*  (RW) _EMIF_CEx2_RDEXHLD 	- Extended Hold Read field
*  (RW) _EMIF_CEx2_WREXHLD	- Extended Hold Write field
*  (RW) _EMIF_CEx2_WRSETUP	- Write Setup field
*  (RW) _EMIF_CEx2_WRSTROBE	- Write Strobe field
*  (RW) _EMIF_CEx2_WRHOLD	- Write Hold field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE32_RDEXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_RDEXHLD_SHIFT		(0x000Eu)
#define _EMIF_CE32_RDEXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE32_RDEXHLD_SHIFT)
#define _EMIF_CE32_RDEXHLD_MASK          	(_EMIF_CE32_RDEXHLD_MK(0x0003u))
#define _EMIF_CE32_RDEXHLD_CLR           	(~(_EMIF_CE32_RDEXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE32_WREXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_WREXHLD_SHIFT		(0x000Cu)
#define _EMIF_CE32_WREXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE32_WREXHLD_SHIFT)
#define _EMIF_CE32_WREXHLD_MASK          	(_EMIF_CE32_WREXHLD_MK(0x0003u))
#define _EMIF_CE32_WREXHLD_CLR           	(~(_EMIF_CE32_WREXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE32_WRSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_WRSETUP_SHIFT		(0x0008u)
#define _EMIF_CE32_WRSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE32_WRSETUP_SHIFT)
#define _EMIF_CE32_WRSETUP_MASK          	(_EMIF_CE32_WRSETUP_MK(0x000Fu))
#define _EMIF_CE32_WRSETUP_CLR           	(~(_EMIF_CE32_WRSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE32_WRSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_WRSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE32_WRSTROBE_MK(n)		(((Uint16)(n) & 0x003Fu) << _EMIF_CE32_WRSTROBE_SHIFT)
#define _EMIF_CE32_WRSTROBE_MASK          (_EMIF_CE32_WRSTROBE_MK(0x003Fu))
#define _EMIF_CE32_WRSTROBE_CLR           (~(_EMIF_CE32_WRSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE32_WRHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_WRHOLD_SHIFT		(0x0000u)
#define _EMIF_CE32_WRHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE32_WRHOLD_SHIFT)
#define _EMIF_CE32_WRHOLD_MASK          	(_EMIF_CE32_WRHOLD_MK(0x0003u))
#define _EMIF_CE32_WRHOLD_CLR           	(~(_EMIF_CE32_WRHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE32		- CE(0/1/2/3) Space Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_CFG(Sp,rdexhld,wrexhld,wrsetup,wrstrobe,wrhold) \
	_PREG_SET(_EMIF_CE32_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE32_RDEXHLD_MK(rdexhld) 	|	\
				_EMIF_CE32_WREXHLD_MK(wrexhld)		|	\
				_EMIF_CE32_WRSETUP_MK(wrsetup) 	|	\
				_EMIF_CE32_WRSTROBE_MK(wrstrobe) 	|	\
				_EMIF_CE32_WRHOLD_MK(wrhold) 			\
             ))



/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE03   - Space Control Register 3
* _EMIF_CE13   - Space Control Register 3
* _EMIF_CE23   - Space COntrol Register 3
* _EMIF_CE33   - Space Control Register 3
*
* Fields:
*  (RW) _EMIF_CEx3_TIMOUT 	- Timeout field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE03_TIMOUT
\*--------------------------------------------------------------------------*/
#define _EMIF_CE03_TIMOUT_SHIFT		(0x0000u)
#define _EMIF_CE03_TIMOUT_MK(n)		(((Uint16)(n) & 0x00FFu) << _EMIF_CE03_TIMOUT_SHIFT)
#define _EMIF_CE03_TIMOUT_MASK          	(_EMIF_CE03_TIMOUT_MK(0x00FFu))
#define _EMIF_CE03_TIMOUT_CLR           	(~(_EMIF_CE03_TIMOUT_MK(0x00FFu)))

/*==========================================================================*\
* _EMIF_CE03		- CE(0/1/2/3) Space Control Register 3 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE03_CFG(Sp,timeout) \
	_PREG_SET(_EMIF_CE03_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE03_TIMOUT_MK(timeout)\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE13_TIMOUT
\*--------------------------------------------------------------------------*/
#define _EMIF_CE13_TIMOUT_SHIFT		(0x0000u)
#define _EMIF_CE13_TIMOUT_MK(n)		(((Uint16)(n) & 0x00FFu) << _EMIF_CE13_TIMOUT_SHIFT)
#define _EMIF_CE13_TIMOUT_MASK          	(_EMIF_CE13_TIMOUT_MK(0x00FFu))
#define _EMIF_CE13_TIMOUT_CLR           	(~(_EMIF_CE13_TIMOUT_MK(0x00FFu)))

/*==========================================================================*\
* _EMIF_CE13		- CE(0/1/2/3) Space Control Register 3 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE13_CFG(Sp,timeout) \
	_PREG_SET(_EMIF_CE13_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE13_TIMOUT_MK(timeout)\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE23_TIMOUT
\*--------------------------------------------------------------------------*/
#define _EMIF_CE23_TIMOUT_SHIFT		(0x0000u)
#define _EMIF_CE23_TIMOUT_MK(n)		(((Uint16)(n) & 0x00FFu) << _EMIF_CE23_TIMOUT_SHIFT)
#define _EMIF_CE23_TIMOUT_MASK          	(_EMIF_CE23_TIMOUT_MK(0x00FFu))
#define _EMIF_CE23_TIMOUT_CLR           	(~(_EMIF_CE23_TIMOUT_MK(0x00FFu)))

/*==========================================================================*\
* _EMIF_CE33		- CE(0/1/2/3) Space Control Register 3 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE23_CFG(Sp,timeout) \
	_PREG_SET(_EMIF_CE23_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE33_TIMOUT_MK(timeout)\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE33_TIMOUT
\*--------------------------------------------------------------------------*/
#define _EMIF_CE33_TIMOUT_SHIFT		(0x0000u)
#define _EMIF_CE33_TIMOUT_MK(n)		(((Uint16)(n) & 0x00FFu) << _EMIF_CE33_TIMOUT_SHIFT)
#define _EMIF_CE33_TIMOUT_MASK          	(_EMIF_CE33_TIMOUT_MK(0x00FFu))
#define _EMIF_CE33_TIMOUT_CLR           	(~(_EMIF_CE33_TIMOUT_MK(0x00FFu)))

/*==========================================================================*\
* _EMIF_CE33		- CE(0/1/2/3) Space Control Register 3 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE33_CFG(Sp,timeout) \
	_PREG_SET(_EMIF_CE33_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE33_TIMOUT_MK(timeout)\
             ))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_SDC1   - SDRAM Control Register 1
*
* Fields:
*  (RW) _EMIF_SDC1_TRC
*  (RW) _EMIF_SDC1_SDSIZE
*  (RW) _EMIF_SDC1_SDWID
*  (RW) _EMIF_SDC1_RFEN
*  (RW) _EMIF_SDC1_TRCD
*  (RW) _EMIF_SDC1_TRP
\*===========================================================================*/

/*===========================================================================*\
* (RW) _EMIF_SDC1_TRC
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_TRC_SHIFT		      (0x000Bu)
#define _EMIF_SDC1_TRC_MK(n)		      (((Uint16)(n) & 0x001Fu) << _EMIF_SDC1_TRC_SHIFT)
#define _EMIF_SDC1_TRC_MASK          	(_EMIF_SDC1_TRC_MK(0x001Fu))
#define _EMIF_SDC1_TRC_CLR           	(~(_EMIF_SDC1_TRC_MK(0x001Fu)))

/*==========================================================================*\
* (RW) _EMIF_SDC1_SDSIZE
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_SDSIZE_SHIFT		(0x000Au)
#define _EMIF_SDC1_SDSIZE_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDC1_SDSIZE_SHIFT)
#define _EMIF_SDC1_SDSIZE_MASK            (_EMIF_SDC1_SDSIZE_MK(0x0001u))
#define _EMIF_SDC1_SDSIZE_CLR             (~(_EMIF_SDC1_SDSIZE_MK(0x0001u)))

/*==========================================================================*\
* (RW) _EMIF_SDC1_SDWID
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_SDWID_SHIFT		(0x0009u)
#define _EMIF_SDC1_SDWID_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDC1_SDWID_SHIFT)
#define _EMIF_SDC1_SDWID_MASK        	(_EMIF_SDC1_SDWID_MK(0x0001u))
#define _EMIF_SDC1_SDWID_CLR         	(~(_EMIF_SDC1_SDWID_MK(0x0001u)))

/*==========================================================================*\
* (RW) _EMIF_SDC1_RFEN
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_RFEN_SHIFT		      (0x0008u)
#define _EMIF_SDC1_RFEN_MK(n)		      (((Uint16)(n) & 0x0001u) << _EMIF_SDC1_RFEN_SHIFT)
#define _EMIF_SDC1_RFEN_MASK        	(_EMIF_SDC1_RFEN_MK(0x0001u))
#define _EMIF_SDC1_RFEN_CLR         	(~(_EMIF_SDC1_RFEN_MK(0x0001u)))

/*==========================================================================*\
* (RW) _EMIF_SDC1_TRCD
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_TRCD_SHIFT		      (0x0004u)
#define _EMIF_SDC1_TRCD_MK(n)		      (((Uint16)(n) & 0x000Fu) << _EMIF_SDC1_TRCD_SHIFT)
#define _EMIF_SDC1_TRCD_MASK        	(_EMIF_SDC1_TRCD_MK(0x000Fu))
#define _EMIF_SDC1_TRCD_CLR         	(~(_EMIF_SDC1_TRCD_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_SDC1_TRP
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_TRP_SHIFT		      (0x0000u)
#define _EMIF_SDC1_TRP_MK(n)		      (((Uint16)(n) & 0x000Fu) << _EMIF_SDC1_TRP_SHIFT)
#define _EMIF_SDC1_TRP_MASK        	      (_EMIF_SDC1_TRP_MK(0x000Fu))
#define _EMIF_SDC1_TRP_CLR         	      (~(_EMIF_SDC1_TRP_MK(0x000Fu)))

/*==========================================================================*\
* _EMIF_SDC1		- SDRAM Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_CFG(trc,sdsize,sdwid,rfen,trcd,trp) \
	_PREG_SET(_EMIF_SDC1_ADDR,\
    		(Uint16) (	_EMIF_SDC1_TRC_MK(trc) 		|	\
				_EMIF_SDC1_SDSIZE_MK(sdsize) 	|	\
				_EMIF_SDC1_SDWID_MK(sdwid) 	|	\
				_EMIF_SDC1_RFEN_MK(rfen) 		|	\
				_EMIF_SDC1_TRCD_MK(trcd) 		|	\
				_EMIF_SDC1_TRP_MK(trp)			\
             ))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_SDPER   - SDRAM Period Register
*
* Fields:
*  (RW) _EMIF_SDPER_PERIOD
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_SDPER_PERIOD
\*--------------------------------------------------------------------------*/
#define _EMIF_SDPER_PERIOD_SHIFT		(0x0000u)
#define _EMIF_SDPER_PERIOD_MK(n)		(((Uint16)(n) & 0x0FFFu) << _EMIF_SDPER_PERIOD_SHIFT)
#define _EMIF_SDPER_PERIOD_MASK        	(_EMIF_SDPER_PERIOD_MK(0x0FFFu))
#define _EMIF_SDPER_PERIOD_CLR         	(~(_EMIF_SDPER_PERIOD_MK(0x0FFFu)))

/*==========================================================================*\
* _EMIF_SDPER		- SDRAM Period Register Config
\*--------------------------------------------------------------------------*/
#define _EMIF_SDPER_CFG(period) \
	_PREG_SET(_EMIF_SDPER_ADDR,\
    		(Uint16) (	_EMIF_SDPER_PERIOD_MK(period)		\
             ))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _EMIF_SDCNT   - SDRAM Counter Register
*
* Fields:
*  (R)  _EMIF_SDCNT_COUNTER
\*===========================================================================*/

/*===========================================================================*\
* (R) _EMIF_SDCNT_COUNTER
\*---------------------------------------------------------------------------*/
#define _EMIF_SDCNT_COUNTER_SHIFT		(0x0000u)
#define _EMIF_SDCNT_COUNTER_MK(n)		(((Uint16)(n) & 0x0FFFu) << _EMIF_SDCNT_COUNTER_SHIFT)
#define _EMIF_SDCNT_COUNTER_MASK        	(_EMIF_SDCNT_COUNTER_MK(0x0FFFu))
#define _EMIF_SDCNT_COUNTER_CLR           (~(_EMIF_SDCNT_COUNTER_MASK))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_INIT   - SDRAM INITialization Register
*
* Fields:
*  (RW)  _EMIF_INIT_INIT
\*===========================================================================*/

/*==========================================================================*\
*  (RW)  _EMIF_INIT_INIT
\*--------------------------------------------------------------------------*/
#define _EMIF_INIT_INIT_SHIFT		(0x0000u)
#define _EMIF_INIT_INIT_MK(n)		(((Uint16)(n) & 0xFFFFu) << _EMIF_INIT_INIT_SHIFT)
#define _EMIF_INIT_INIT_MASK        (_EMIF_INIT_INIT_MK(0xFFFFu))
#define _EMIF_INIT_INIT_CLR         (~(_EMIF_INIT_INIT_MK(0xFFFFu)))

/*==========================================================================*\
* _EMIF_INIT		- SDRAM INITialization Register
\*--------------------------------------------------------------------------*/
#define _EMIF_INIT_CFG(val) \
	_PREG_SET(_EMIF_INIT_ADDR,\
    		(Uint16) (	_EMIF_INIT_INIT_MK(val)		\
             ))

/*==========================================================================*\
*  (RW)  _EMIF_SDINIT_INIT
\*--------------------------------------------------------------------------*/
#define _EMIF_SDINIT_INIT_SHIFT		(0x0000u)
#define _EMIF_SDINIT_INIT_MK(n)		(((Uint16)(n) & 0xFFFFu) << _EMIF_SDINIT_INIT_SHIFT)
#define _EMIF_SDINIT_INIT_MASK        (_EMIF_SDINIT_INIT_MK(0xFFFFu))
#define _EMIF_SDINIT_INIT_CLR         (~(_EMIF_SDINIT_INIT_MK(0xFFFFu)))

/*==========================================================================*\
* _EMIF_SDINIT		- SDRAM INITialization Register
\*--------------------------------------------------------------------------*/
#define _EMIF_SDINIT_CFG(val) \
	_PREG_SET(_EMIF_SDINIT_ADDR,\
    		(Uint16) (	_EMIF_SDINIT_INIT_MK(val)		\
             ))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_SDC2   - SDRAM Control Register 2
*
* Fields:
*  (RW) _EMIF_SDC2_SDACC
*  (RW) _EMIF_SDC2_TMRD
*  (RW) _EMIF_SDC2_TRAS
*  (RW) _EMIF_SDC2_TACTV2ACTV
\*==========================================================================*/
/*==========================================================================*\
* (RW) _EMIF_SDC2_SDACC
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC2_SDACC_SHIFT		(0x000Au)
#define _EMIF_SDC2_SDACC_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDC2_SDACC_SHIFT)
#define _EMIF_SDC2_SDACC_MASK        	(_EMIF_SDC2_SDACC_MK(0x0003u))
#define _EMIF_SDC2_SDACC_CLR         	(~(_EMIF_SDC2_SDACC_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_SDC2_TMRD
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC2_TMRD_SHIFT		(0x0008u)
#define _EMIF_SDC2_TMRD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_SDC2_TMRD_SHIFT)
#define _EMIF_SDC2_TMRD_MASK        	(_EMIF_SDC2_TMRD_MK(0x0003u))
#define _EMIF_SDC2_TMRD_CLR         	(~(_EMIF_SDC2_TMRD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_SDC2_TRAS
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC2_TRAS_SHIFT		(0x0004u)
#define _EMIF_SDC2_TRAS_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_SDC2_TRAS_SHIFT)
#define _EMIF_SDC2_TRAS_MASK        	(_EMIF_SDC2_TRAS_MK(0x000Fu))
#define _EMIF_SDC2_TRAS_CLR         	(~(_EMIF_SDC2_TRAS_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_SDC2_TACTV2ACTV
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC2_TACTV2ACTV_SHIFT	(0x0000u)
#define _EMIF_SDC2_TACTV2ACTV_MK(n)	(((Uint16)(n) & 0x000Fu) << _EMIF_SDC2_TACTV2ACTV_SHIFT)
#define _EMIF_SDC2_TACTV2ACTV_MASK   	(_EMIF_SDC2_TACTV2ACTV_MK(0x000Fu))
#define _EMIF_SDC2_TACTV2ACTV_CLR    	(~(_EMIF_SDC2_TACTV2ACTV_MK(0x000Fu)))

/*==========================================================================*\
* _EMIF_SDC2		- SDRAM Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC2_CFG(sdacc, tmrd,tras,tactv2actv) \
	_PREG_SET(_EMIF_SDC2_ADDR,\
    		(Uint16) (  _EMIF_SDC2_SDACC_MK(sdacc)          |	\
                  	_EMIF_SDC2_TMRD_MK(tmrd) 		|	\
				_EMIF_SDC2_TRAS_MK(tras) 		|	\
				_EMIF_SDC2_TACTV2ACTV_MK(tactv2actv) 	\
             ))


#elif (!(_EMIF_MOD))
	#error EMIF Hal Module Not Supported on Specified Target
#endif
#endif
csl_emifB.h/    1049976850  0     0     0       39277     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... EMIF
* FILENAME...... csl_emif.h
* DATE CREATED.. Mon Feb 11 15:35:20 2002
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Mon Feb 11 15:35:20 2002 (Automatic generation)
*	 Last Modified:	27 Mar 2003
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the EMIF module 
*
\*************************************************************************/

#ifndef _CSL_EMIFB_H_
#define _CSL_EMIFB_H_

#include <csl_emifBhal.h>
#include <csl_std.h>
#include <_csl.h>
#include <csl_chiphal.h>

#if (_EMIFB_SUPPORT) 

/*----------------------------------------------------------------*\
*	 EMIF scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _EMIF_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/****************************************\
* EMIF global macro declarations
\****************************************/

/* error codes */
#define EMIF_ERR_MAJOR		   (ERR_BASE_EMIF) 
#define EMIF_ERR_ALLOC		   (0x00000000) 
#define EMIF_ERR_INVALID_HANDLE  (0x00000001) 

/* ============================================================== */
 /* Make CE0CTL1 register values based on symbolic constants  */

/*  CE0CTL1 field values  */

	#define EMIF_CE0CTL1_TA_OF(x)			((Uint16)(x))
	#define EMIF_CE0CTL1_TA_DEFAULT		EMIF_CE0CTL1_TA_OF(3)

	#define EMIF_CE0CTL1_READ_STROBE_OF(x)		((Uint16)(x))
	#define EMIF_CE0CTL1_READ_STROBE_DEFAULT		EMIF_CE0CTL1_READ_STROBE_OF(0x3fu)

	#define EMIF_CE0CTL1_MTYPE_8BIT_ASYNC			(000000u)
	#define EMIF_CE0CTL1_MTYPE_16BIT_ASYNC			(0x0001u)
	#define EMIF_CE0CTL1_MTYPE_32BIT_ASYNC			(0x0002u)
	#define EMIF_CE0CTL1_MTYPE_32BIT_SDRAM			(0x0003u)
	#define EMIF_CE0CTL1_MTYPE_32BIT_SBSRAM			(0x0004u)
	#define EMIF_CE0CTL1_MTYPE_8BIT_SDRAM			(0x0008u)
	#define EMIF_CE0CTL1_MTYPE_16BIT_SDRAM			(0x0009u)
	#define EMIF_CE0CTL1_MTYPE_8BIT_SBSRAM			(000010u)
	#define EMIF_CE0CTL1_MTYPE_16BIT_SBSRAM			(000011u)
	#define EMIF_CE0CTL1_MTYPE_DEFAULT		EMIF_CE0CTL1_MTYPE_8BIT_ASYNC

	#define EMIF_CE0CTL1_WRITE_HOLD_MSB_HIGH			(0x0001u)
	#define EMIF_CE0CTL1_WRITE_HOLD_MSB_LOW			(000000u)
	#define EMIF_CE0CTL1_WRITE_HOLD_MSB_DEFAULT		EMIF_CE0CTL1_WRITE_HOLD_MSB_LOW

	#define EMIF_CE0CTL1_WRITE_HOLD_HIGH			(0x0001u)
	#define EMIF_CE0CTL1_WRITE_HOLD_LOW				(000000u)
	#define EMIF_CE0CTL1_WRITE_HOLD_DEFAULT			EMIF_CE0CTL1_WRITE_HOLD_LOW

	#define EMIF_CE0CTL1_READ_HOLD_OF(x)		((Uint16)(x))
	#define EMIF_CE0CTL1_READ_HOLD_DEFAULT		EMIF_CE0CTL1_READ_HOLD_OF(3)


#define EMIF_CE0CTL1_RMK(ta,read_strobe,mtype,write_hold,read_hold)\
 ((Uint16) ( \
  ( EMIF_FMK(CE0CTL1,TA,ta))|\
  ( EMIF_FMK(CE0CTL1,READ_STROBE,read_strobe))|\
  ( EMIF_FMK(CE0CTL1,MTYPE,mtype))|\
  ( EMIF_FMK(CE0CTL1,WRITE_HOLD,write_hold))|\
  ( EMIF_FMK(CE0CTL1,READ_HOLD,read_hold))\
)\
 )

#define EMIF_CE0CTL1_RMKS(ta_sym,read_strobe_sym,mtype_sym,write_hold_sym,read_hold_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE0CTL1,TA,ta_sym))|\
  ( EMIF_FMKS(CE0CTL1,READ_STROBE,read_strobe_sym))|\
  ( EMIF_FMKS(CE0CTL1,MTYPE,mtype_sym))|\
  ( EMIF_FMKS(CE0CTL1,WRITE_HOLD,write_hold_sym))|\
  ( EMIF_FMKS(CE0CTL1,READ_HOLD,read_hold_sym))\
)\
 )

/*  Default CE0CTL1 register value  */

#define EMIF_CE0CTL1_DEFAULT               (0xFF03u)

/* ============================================================== */
 /* Make CE0CTL2 register values based on symbolic constants  */

/*  CE0CTL2 field values  */

	#define EMIF_CE0CTL2_WRITE_SETUP_OF(x)			((Uint16)(x))
      #define EMIF_CE0CTL2_WRITE_SETUP_DEFAULT			EMIF_CE0CTL2_WRITE_SETUP_OF(15)

	#define EMIF_CE0CTL2_WRITE_STROBE_OF(x)			((Uint16)(x))
	#define EMIF_CE0CTL2_WRITE_STROBE_DEFAULT			EMIF_CE0CTL2_WRITE_STROBE_OF(0x3fu)
	#define EMIF_CE0CTL2_WRITE_HOLD_OF(x)			((Uint16)(x))
	#define EMIF_CE0CTL2_WRITE_HOLD_DEFAULT			EMIF_CE0CTL2_WRITE_HOLD_OF(3)
	#define EMIF_CE0CTL2_READ_SETUP_OF(x)			((Uint16)(x))
      #define EMIF_CE0CTL2_READ_SETUP_DEFAULT			EMIF_CE0CTL2_READ_SETUP_OF(15)

#define EMIF_CE0CTL2_RMK(write_setup,write_strobe,write_hold,read_setup)\
 ((Uint16) ( \
  ( EMIF_FMK(CE0CTL2,WRITE_SETUP,write_setup))|\
  ( EMIF_FMK(CE0CTL2,WRITE_STROBE,write_strobe))|\
  ( EMIF_FMK(CE0CTL2,WRITE_HOLD,write_hold))|\
  ( EMIF_FMK(CE0CTL2,READ_SETUP,read_setup))\
)\
 )

#define EMIF_CE0CTL2_RMKS(write_setup_sym,write_strobe_sym,write_hold_sym,read_setup_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE0CTL2,WRITE_SETUP,write_setup_sym))|\
  ( EMIF_FMKS(CE0CTL2,WRITE_STROBE,write_strobe_sym))|\
  ( EMIF_FMKS(CE0CTL2,WRITE_HOLD,write_hold_sym))|\
  ( EMIF_FMKS(CE0CTL2,READ_SETUP,read_setup_sym))\
)\
 )

/*  Default CE0CTL2 register value  */

#define EMIF_CE0CTL2_DEFAULT          (0xFFFFu)

/* ============================================================== */
 /* Make CE0SEC1 register values based on symbolic constants  */

/*  CE0SEC1 field values  */

	#define EMIF_CE0SEC1_SNCCLK_SYNC_ECLKOUT1			(000000u)
	#define EMIF_CE0SEC1_SNCCLK_SYNC_ECLKOUT2			(0x0001u)
	#define EMIF_CE0SEC1_SNCCLK_DEFAULT		EMIF_CE0SEC1_SNCCLK_SYNC_ECLKOUT1

	#define EMIF_CE0SEC1_REN_ADS			(000000u)
	#define EMIF_CE0SEC1_REN_REN			(0x0001u)
	#define EMIF_CE0SEC1_REN_DEFAULT		EMIF_CE0SEC1_REN_ADS

	#define EMIF_CE0SEC1_RENEN_ADS			(000000u)
	#define EMIF_CE0SEC1_RENEN_REN			(0x0001u)
	#define EMIF_CE0SEC1_RENEN_DEFAULT		EMIF_CE0SEC1_RENEN_ADS

      #define EMIF_CE0SEC1_CEEXT_CE_TIED_TO_SOE			(0x0001u)
	#define EMIF_CE0SEC1_CEEXT_CE_TIED_TO_SNCCRL			(000000u)
	#define EMIF_CE0SEC1_CEEXT_DEFAULT		EMIF_CE0SEC1_CEEXT_CE_TIED_TO_SNCCRL

	#define EMIF_CE0SEC1_SYNCWL_0CYCLES			(000000u)
	#define EMIF_CE0SEC1_SYNCWL_1CYCLES			(0x0001u)
	#define EMIF_CE0SEC1_SYNCWL_2CYCLES			(0x0002u)
	#define EMIF_CE0SEC1_SYNCWL_3CYCLES			(0x0003u)
	#define EMIF_CE0SEC1_SYNCWL_DEFAULT		EMIF_CE0SEC1_SYNCWL_2CYCLES

	#define EMIF_CE0SEC1_SYNCRL_0CYCLES			(000000u)
	#define EMIF_CE0SEC1_SYNCRL_1CYCLE			(0x0001u)
	#define EMIF_CE0SEC1_SYNCRL_2CYCLES			(0x0002u)
	#define EMIF_CE0SEC1_SYNCRL_3CYCLES			(0x0003u)
	#define EMIF_CE0SEC1_SYNCRL_DEFAULT		EMIF_CE0SEC1_SYNCRL_2CYCLES

#define EMIF_CE0SEC1_RMK(sncclk,renen,ceext,syncwl,syncrl)\
 ((Uint16) ( \
  ( EMIF_FMK(CE0SEC1,SNCCLK,sncclk))|\
  ( EMIF_FMK(CE0SEC1,RENEN,renen))|\
  ( EMIF_FMK(CE0SEC1,CEEXT,ceext))|\
  ( EMIF_FMK(CE0SEC1,SYNCWL,syncwl))|\
  ( EMIF_FMK(CE0SEC1,SYNCRL,syncrl))\
)\
 )

#define EMIF_CE0SEC1_RMKS(sncclk_sym,renen_sym,ceext_sym,syncwl_sym,syncrl_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE0SEC1,SNCCLK,sncclk_sym))|\
  ( EMIF_FMKS(CE0SEC1,RENEN,renen_sym))|\
  ( EMIF_FMKS(CE0SEC1,CEEXT,ceext_sym))|\
  ( EMIF_FMKS(CE0SEC1,SYNCWL,syncwl_sym))|\
  ( EMIF_FMKS(CE0SEC1,SYNCRL,syncrl_sym))\
)\
 )

/*  Default CE0SEC1 register value  */

#define EMIF_CE0SEC1_DEFAULT          (0x0002u)

/* ============================================================== */
/* Make CE1CTL1 register values based on symbolic constants       */

/*  CE1CTL1 field values  */

	#define EMIF_CE1CTL1_TA_OF(x)			((Uint16)(x))
	#define EMIF_CE1CTL1_TA_DEFAULT		EMIF_CE1CTL1_TA_OF(3)

	#define EMIF_CE1CTL1_READ_STROBE_OF(x)		((Uint16)(x))
	#define EMIF_CE1CTL1_READ_STROBE_DEFAULT		EMIF_CE1CTL1_READ_STROBE_OF(0x3fu)

	#define EMIF_CE1CTL1_MTYPE_8BIT_ASYNC			(000000u)
	#define EMIF_CE1CTL1_MTYPE_16BIT_ASYNC			(0x0001u)
	#define EMIF_CE1CTL1_MTYPE_32BIT_ASYNC			(0x0002u)
	#define EMIF_CE1CTL1_MTYPE_32BIT_SDRAM			(0x0003u)
	#define EMIF_CE1CTL1_MTYPE_32BIT_SBSRAM			(0x0004u)
	#define EMIF_CE1CTL1_MTYPE_8BIT_SDRAM			(0x0008u)
	#define EMIF_CE1CTL1_MTYPE_16BIT_SDRAM			(0x0009u)
	#define EMIF_CE1CTL1_MTYPE_8BIT_SBSRAM			(000010u)
	#define EMIF_CE1CTL1_MTYPE_16BIT_SBSRAM			(000011u)
	#define EMIF_CE1CTL1_MTYPE_DEFAULT		EMIF_CE1CTL1_MTYPE_8BIT_ASYNC

	#define EMIF_CE1CTL1_WRITE_HOLD_MSB_HIGH			(0x0001u)
	#define EMIF_CE1CTL1_WRITE_HOLD_MSB_LOW			(000000u)
	#define EMIF_CE1CTL1_WRITE_HOLD_MSB_DEFAULT		EMIF_CE1CTL1_WRITE_HOLD_MSB_LOW

	#define EMIF_CE1CTL1_WRITE_HOLD_HIGH			(0x0001u)
	#define EMIF_CE1CTL1_WRITE_HOLD_LOW				(000000u)
	#define EMIF_CE1CTL1_WRITE_HOLD_DEFAULT			EMIF_CE1CTL1_WRITE_HOLD_LOW

	#define EMIF_CE1CTL1_READ_HOLD_OF(x)		((Uint16)(x))
	#define EMIF_CE1CTL1_READ_HOLD_DEFAULT		EMIF_CE1CTL1_READ_HOLD_OF(3)


#define EMIF_CE1CTL1_RMK(ta,read_strobe,mtype,write_hold,read_hold)\
 ((Uint16) ( \
  ( EMIF_FMK(CE1CTL1,TA,ta))|\
  ( EMIF_FMK(CE1CTL1,READ_STROBE,read_strobe))|\
  ( EMIF_FMK(CE1CTL1,MTYPE,mtype))|\
  ( EMIF_FMK(CE1CTL1,WRITE_HOLD,write_hold))|\
  ( EMIF_FMK(CE1CTL1,READ_HOLD,read_hold))\
)\
 )

#define EMIF_CE1CTL1_RMKS(ta_sym,read_strobe_sym,mtype_sym,write_hold_sym,read_hold_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE1CTL1,TA,ta_sym))|\
  ( EMIF_FMKS(CE1CTL1,READ_STROBE,read_strobe_sym))|\
  ( EMIF_FMKS(CE1CTL1,MTYPE,mtype_sym))|\
  ( EMIF_FMKS(CE1CTL1,WRITE_HOLD,write_hold_sym))|\
  ( EMIF_FMKS(CE1CTL1,READ_HOLD,read_hold_sym))\
)\
 )

/*  Default CE1CTL1 register value  */

#define EMIF_CE1CTL1_DEFAULT         (0xFF03u)

/* ============================================================== */
 /* Make CE1CTL2 register values based on symbolic constants  */

/*  CE1CTL2 field values  */

	#define EMIF_CE1CTL2_WRITE_SETUP_OF(x)			((Uint16)(x))
	#define EMIF_CE1CTL2_WRITE_SETUP_DEFAULT			EMIF_CE1CTL2_WRITE_SETUP_OF(15)

	#define EMIF_CE1CTL2_WRITE_STROBE_OF(x)			((Uint16)(x))
	#define EMIF_CE1CTL2_WRITE_STROBE_DEFAULT			EMIF_CE1CTL2_WRITE_STROBE_OF(0x3fu)

	#define EMIF_CE1CTL2_WRITE_HOLD_OF(x)			((Uint16)(x))
	#define EMIF_CE1CTL2_WRITE_HOLD_DEFAULT			EMIF_CE1CTL2_WRITE_HOLD_OF(3)

	#define EMIF_CE1CTL2_READ_SETUP_OF(x)			((Uint16)(x))
	#define EMIF_CE1CTL2_READ_SETUP_DEFAULT			EMIF_CE1CTL2_READ_SETUP_OF(15)

#define EMIF_CE1CTL2_RMK(write_setup,write_strobe,write_hold,read_setup)\
 ((Uint16) ( \
  ( EMIF_FMK(CE1CTL2,WRITE_SETUP,write_setup))|\
  ( EMIF_FMK(CE1CTL2,WRITE_STROBE,write_strobe))|\
  ( EMIF_FMK(CE1CTL2,WRITE_HOLD,write_hold))|\
  ( EMIF_FMK(CE1CTL2,READ_SETUP,read_setup))\
)\
 )

#define EMIF_CE1CTL2_RMKS(write_setup_sym,write_strobe_sym,write_hold_sym,read_setup_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE1CTL2,WRITE_SETUP,write_setup_sym))|\
  ( EMIF_FMKS(CE1CTL2,WRITE_STROBE,write_strobe_sym))|\
  ( EMIF_FMKS(CE1CTL2,WRITE_HOLD,write_hold_sym))|\
  ( EMIF_FMKS(CE1CTL2,READ_SETUP,read_setup_sym))\
)\
 )

/*  Default CE1CTL2 register value  */

#define EMIF_CE1CTL2_DEFAULT           (0xFFFFu)

/* ============================================================== */
 /* Make CE1SEC1 register values based on symbolic constants  */

/*  CE1SEC1 field values  */

	#define EMIF_CE1SEC1_SNCCLK_SYNC_ECLKOUT1			(000000u)
	#define EMIF_CE1SEC1_SNCCLK_SYNC_ECLKOUT2			(0x0001u)
	#define EMIF_CE1SEC1_SNCCLK_DEFAULT		EMIF_CE1SEC1_SNCCLK_SYNC_ECLKOUT1

	#define EMIF_CE1SEC1_REN_ADS			(000000u)
	#define EMIF_CE1SEC1_REN_REN			(0x0001u)
	#define EMIF_CE1SEC1_REN_DEFAULT		EMIF_CE1SEC1_REN_ADS

	#define EMIF_CE1SEC1_RENEN_ADS			(000000u)
	#define EMIF_CE1SEC1_RENEN_REN			(0x0001u)
	#define EMIF_CE1SEC1_RENEN_DEFAULT		EMIF_CE1SEC1_RENEN_ADS

	#define EMIF_CE1SEC1_CEEXT_CE_TIED_TO_SOE			(0x0001u)
	#define EMIF_CE1SEC1_CEEXT_CE_TIED_TO_SNCCRL			(000000u)
	#define EMIF_CE1SEC1_CEEXT_DEFAULT		EMIF_CE1SEC1_CEEXT_CE_TIED_TO_SNCCRL

	#define EMIF_CE1SEC1_SYNCWL_0CYCLES			(000000u)
	#define EMIF_CE1SEC1_SYNCWL_1CYCLES			(0x0001u)
	#define EMIF_CE1SEC1_SYNCWL_2CYCLES			(0x0002u)
	#define EMIF_CE1SEC1_SYNCWL_3CYCLES			(0x0003u)
	#define EMIF_CE1SEC1_SYNCWL_DEFAULT		EMIF_CE1SEC1_SYNCWL_2CYCLES

	#define EMIF_CE1SEC1_SYNCRL_0CYCLES			(000000u)
	#define EMIF_CE1SEC1_SYNCRL_1CYCLE			(0x0001u)
	#define EMIF_CE1SEC1_SYNCRL_2CYCLES			(0x0002u)
	#define EMIF_CE1SEC1_SYNCRL_3CYCLES			(0x0003u)
	#define EMIF_CE1SEC1_SYNCRL_DEFAULT		EMIF_CE1SEC1_SYNCRL_2CYCLES

#define EMIF_CE1SEC1_RMK(sncclk,renen,ceext,syncwl,syncrl)\
 ((Uint16) ( \
  ( EMIF_FMK(CE1SEC1,SNCCLK,sncclk))|\
  ( EMIF_FMK(CE1SEC1,RENEN,renen))|\
  ( EMIF_FMK(CE1SEC1,CEEXT,ceext))|\
  ( EMIF_FMK(CE1SEC1,SYNCWL,syncwl))|\
  ( EMIF_FMK(CE1SEC1,SYNCRL,syncrl))\
)\
 )

#define EMIF_CE1SEC1_RMKS(sncclk_sym,renen_sym,ceext_sym,syncwl_sym,syncrl_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE1SEC1,SNCCLK,sncclk_sym))|\
  ( EMIF_FMKS(CE1SEC1,RENEN,renen_sym))|\
  ( EMIF_FMKS(CE1SEC1,CEEXT,ceext_sym))|\
  ( EMIF_FMKS(CE1SEC1,SYNCWL,syncwl_sym))|\
  ( EMIF_FMKS(CE1SEC1,SYNCRL,syncrl_sym))\
)\
 )



/*  Default CE1SEC1 register value  */

#define EMIF_CE1SEC1_DEFAULT             (0x0002u)

/* ============================================================== */
 /* Make CE2CTL1 register values based on symbolic constants  */

/*  CE2CTL1 field values  */

	#define EMIF_CE2CTL1_TA_OF(x)			((Uint16)(x))
	#define EMIF_CE2CTL1_TA_DEFAULT		EMIF_CE2CTL1_TA_OF(3)

	#define EMIF_CE2CTL1_READ_STROBE_OF(x)		((Uint16)(x))
	#define EMIF_CE2CTL1_READ_STROBE_DEFAULT		EMIF_CE2CTL1_READ_STROBE_OF(0x3fu)

	#define EMIF_CE2CTL1_MTYPE_8BIT_ASYNC			(000000u)
	#define EMIF_CE2CTL1_MTYPE_16BIT_ASYNC			(0x0001u)
	#define EMIF_CE2CTL1_MTYPE_32BIT_ASYNC			(0x0002u)
	#define EMIF_CE2CTL1_MTYPE_32BIT_SDRAM			(0x0003u)
	#define EMIF_CE2CTL1_MTYPE_32BIT_SBSRAM			(0x0004u)
	#define EMIF_CE2CTL1_MTYPE_8BIT_SDRAM			(0x0008u)
	#define EMIF_CE2CTL1_MTYPE_16BIT_SDRAM			(0x0009u)
	#define EMIF_CE2CTL1_MTYPE_8BIT_SBSRAM			(000010u)
	#define EMIF_CE2CTL1_MTYPE_16BIT_SBSRAM			(000011u)
	#define EMIF_CE2CTL1_MTYPE_DEFAULT		EMIF_CE2CTL1_MTYPE_8BIT_ASYNC

	#define EMIF_CE2CTL1_WRITE_HOLD_MSB_HIGH			(0x0001u)
	#define EMIF_CE2CTL1_WRITE_HOLD_MSB_LOW			(000000u)
	#define EMIF_CE2CTL1_WRITE_HOLD_MSB_DEFAULT		EMIF_CE2CTL1_WRITE_HOLD_MSB_LOW

	#define EMIF_CE2CTL1_WRITE_HOLD_HIGH			(0x0001u)
	#define EMIF_CE2CTL1_WRITE_HOLD_LOW				(000000u)
	#define EMIF_CE2CTL1_WRITE_HOLD_DEFAULT			EMIF_CE2CTL1_WRITE_HOLD_LOW

	#define EMIF_CE2CTL1_READ_HOLD_OF(x)		((Uint16)(x))
	#define EMIF_CE2CTL1_READ_HOLD_DEFAULT		EMIF_CE2CTL1_READ_HOLD_OF(3)


#define EMIF_CE2CTL1_RMK(ta,read_strobe,mtype,write_hold,read_hold)\
 ((Uint16) ( \
  ( EMIF_FMK(CE2CTL1,TA,ta))|\
  ( EMIF_FMK(CE2CTL1,READ_STROBE,read_strobe))|\
  ( EMIF_FMK(CE2CTL1,MTYPE,mtype))|\
  ( EMIF_FMK(CE2CTL1,WRITE_HOLD,write_hold))|\
  ( EMIF_FMK(CE2CTL1,READ_HOLD,read_hold))\
)\
 )

#define EMIF_CE2CTL1_RMKS(ta_sym,read_strobe_sym,mtype_sym,write_hold_sym,read_hold_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE2CTL1,TA,ta_sym))|\
  ( EMIF_FMKS(CE2CTL1,READ_STROBE,read_strobe_sym))|\
  ( EMIF_FMKS(CE2CTL1,MTYPE,mtype_sym))|\
  ( EMIF_FMKS(CE2CTL1,WRITE_HOLD,write_hold_sym))|\
  ( EMIF_FMKS(CE2CTL1,READ_HOLD,read_hold_sym))\
)\
 )

/*  Default CE2CTL1 register value  */

#define EMIF_CE2CTL1_DEFAULT          (0xFF03u)

/* ============================================================== */
 /* Make CE2CTL2 register values based on symbolic constants  */

/*  CE2CTL2 field values  */

	#define EMIF_CE2CTL2_WRITE_SETUP_OF(x)			((Uint16)(x))
	#define EMIF_CE2CTL2_WRITE_SETUP_DEFAULT			EMIF_CE2CTL2_WRITE_SETUP_OF(15)

	#define EMIF_CE2CTL2_WRITE_STROBE_OF(x)			((Uint16)(x))
	#define EMIF_CE2CTL2_WRITE_STROBE_DEFAULT			EMIF_CE2CTL2_WRITE_STROBE_OF(0x3fu)

	#define EMIF_CE2CTL2_WRITE_HOLD_OF(x)			((Uint16)(x))
	#define EMIF_CE2CTL2_WRITE_HOLD_DEFAULT			EMIF_CE2CTL2_WRITE_HOLD_OF(3)

	#define EMIF_CE2CTL2_READ_SETUP_OF(x)			((Uint16)(x))
	#define EMIF_CE2CTL2_READ_SETUP_DEFAULT			EMIF_CE2CTL2_READ_SETUP_OF(15)

#define EMIF_CE2CTL2_RMK(write_setup,write_strobe,write_hold,read_setup)\
 ((Uint16) ( \
  ( EMIF_FMK(CE2CTL2,WRITE_SETUP,write_setup))|\
  ( EMIF_FMK(CE2CTL2,WRITE_STROBE,write_strobe))|\
  ( EMIF_FMK(CE2CTL2,WRITE_HOLD,write_hold))|\
  ( EMIF_FMK(CE2CTL2,READ_SETUP,read_setup))\
)\
 )

#define EMIF_CE2CTL2_RMKS(write_setup_sym,write_strobe_sym,write_hold_sym,read_setup_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE2CTL2,WRITE_SETUP,write_setup_sym))|\
  ( EMIF_FMKS(CE2CTL2,WRITE_STROBE,write_strobe_sym))|\
  ( EMIF_FMKS(CE2CTL2,WRITE_HOLD,write_hold_sym))|\
  ( EMIF_FMKS(CE2CTL2,READ_SETUP,read_setup_sym))\
)\
 )

/*  Default CE2CTL2 register value  */

#define EMIF_CE2CTL2_DEFAULT           (0xFFFFu)

/* ============================================================== */
 /* Make CE2SEC1 register values based on symbolic constants  */

/*  CE2SEC1 field values  */

	#define EMIF_CE2SEC1_SNCCLK_SYNC_ECLKOUT1			(000000u)
	#define EMIF_CE2SEC1_SNCCLK_SYNC_ECLKOUT2			(0x0001u)
	#define EMIF_CE2SEC1_SNCCLK_DEFAULT		EMIF_CE2SEC1_SNCCLK_SYNC_ECLKOUT1

	#define EMIF_CE2SEC1_REN_ADS			(000000u)
	#define EMIF_CE2SEC1_REN_REN			(0x0001u)
	#define EMIF_CE2SEC1_REN_DEFAULT		EMIF_CE2SEC1_REN_ADS

	#define EMIF_CE2SEC1_RENEN_ADS			(000000u)
	#define EMIF_CE2SEC1_RENEN_REN			(0x0001u)
	#define EMIF_CE2SEC1_RENEN_DEFAULT		EMIF_CE2SEC1_RENEN_ADS

	#define EMIF_CE2SEC1_CEEXT_CE_TIED_TO_SOE			(0x0001u)
	#define EMIF_CE2SEC1_CEEXT_CE_TIED_TO_SNCCRL			(000000u)
	#define EMIF_CE2SEC1_CEEXT_DEFAULT		EMIF_CE2SEC1_CEEXT_CE_TIED_TO_SNCCRL

	#define EMIF_CE2SEC1_SYNCWL_0CYCLES			(000000u)
	#define EMIF_CE2SEC1_SYNCWL_1CYCLES			(0x0001u)
	#define EMIF_CE2SEC1_SYNCWL_2CYCLES			(0x0002u)
	#define EMIF_CE2SEC1_SYNCWL_3CYCLES			(0x0003u)
	#define EMIF_CE2SEC1_SYNCWL_DEFAULT		EMIF_CE2SEC1_SYNCWL_2CYCLES

	#define EMIF_CE2SEC1_SYNCRL_0CYCLES			(000000u)
	#define EMIF_CE2SEC1_SYNCRL_1CYCLE			(0x0001u)
	#define EMIF_CE2SEC1_SYNCRL_2CYCLES			(0x0002u)
	#define EMIF_CE2SEC1_SYNCRL_3CYCLES			(0x0003u)
	#define EMIF_CE2SEC1_SYNCRL_DEFAULT		EMIF_CE2SEC1_SYNCRL_2CYCLES


#define EMIF_CE2SEC1_RMK(sncclk,renen,ceext,syncwl,syncrl)\
 ((Uint16) ( \
  ( EMIF_FMK(CE2SEC1,SNCCLK,sncclk))|\
  ( EMIF_FMK(CE2SEC1,RENEN,renen))|\
  ( EMIF_FMK(CE2SEC1,CEEXT,ceext))|\
  ( EMIF_FMK(CE2SEC1,SYNCWL,syncwl))|\
  ( EMIF_FMK(CE2SEC1,SYNCRL,syncrl))\
)\
 )

#define EMIF_CE2SEC1_RMKS(sncclk_sym,renen_sym,ceext_sym,syncwl_sym,syncrl_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE2SEC1,SNCCLK,sncclk_sym))|\
  ( EMIF_FMKS(CE2SEC1,RENEN,renen_sym))|\
  ( EMIF_FMKS(CE2SEC1,CEEXT,ceext_sym))|\
  ( EMIF_FMKS(CE2SEC1,SYNCWL,syncwl_sym))|\
  ( EMIF_FMKS(CE2SEC1,SYNCRL,syncrl_sym))\
)\
 )



/*  Default CE2SEC1 register value  */

#define EMIF_CE2SEC1_DEFAULT         (0x0002u)

/* ============================================================== */
 /* Make CE3CTL1 register values based on symbolic constants  */

/*  CE3CTL1 field values  */

	#define EMIF_CE3CTL1_TA_OF(x)			((Uint16)(x))
	#define EMIF_CE3CTL1_TA_DEFAULT		EMIF_CE3CTL1_TA_OF(3)

	#define EMIF_CE3CTL1_READ_STROBE_OF(x)		((Uint16)(x))
	#define EMIF_CE3CTL1_READ_STROBE_DEFAULT		EMIF_CE3CTL1_READ_STROBE_OF(0x3fu)

	#define EMIF_CE3CTL1_MTYPE_8BIT_ASYNC			(000000u)
	#define EMIF_CE3CTL1_MTYPE_16BIT_ASYNC			(0x0001u)
	#define EMIF_CE3CTL1_MTYPE_32BIT_ASYNC			(0x0002u)
	#define EMIF_CE3CTL1_MTYPE_32BIT_SDRAM			(0x0003u)
	#define EMIF_CE3CTL1_MTYPE_32BIT_SBSRAM			(0x0004u)
	#define EMIF_CE3CTL1_MTYPE_8BIT_SDRAM			(0x0008u)
	#define EMIF_CE3CTL1_MTYPE_16BIT_SDRAM			(0x0009u)
	#define EMIF_CE3CTL1_MTYPE_8BIT_SBSRAM			(000010u)
	#define EMIF_CE3CTL1_MTYPE_16BIT_SBSRAM			(000011u)
	#define EMIF_CE3CTL1_MTYPE_DEFAULT		EMIF_CE3CTL1_MTYPE_8BIT_ASYNC

	#define EMIF_CE3CTL1_WRITE_HOLD_MSB_HIGH			(0x0001u)
	#define EMIF_CE3CTL1_WRITE_HOLD_MSB_LOW			(000000u)
	#define EMIF_CE3CTL1_WRITE_HOLD_MSB_DEFAULT		EMIF_CE3CTL1_WRITE_HOLD_MSB_LOW

	#define EMIF_CE3CTL1_WRITE_HOLD_HIGH			(0x0001u)
	#define EMIF_CE3CTL1_WRITE_HOLD_LOW				(000000u)
	#define EMIF_CE3CTL1_WRITE_HOLD_DEFAULT			EMIF_CE3CTL1_WRITE_HOLD_LOW

	#define EMIF_CE3CTL1_READ_HOLD_OF(x)		((Uint16)(x))
	#define EMIF_CE3CTL1_READ_HOLD_DEFAULT		EMIF_CE3CTL1_READ_HOLD_OF(3)


#define EMIF_CE3CTL1_RMK(ta,read_strobe,mtype,write_hold,read_hold)\
 ((Uint16) ( \
  ( EMIF_FMK(CE3CTL1,TA,ta))|\
  ( EMIF_FMK(CE3CTL1,READ_STROBE,read_strobe))|\
  ( EMIF_FMK(CE3CTL1,MTYPE,mtype))|\
  ( EMIF_FMK(CE3CTL1,WRITE_HOLD,write_hold))|\
  ( EMIF_FMK(CE3CTL1,READ_HOLD,read_hold))\
)\
 )

#define EMIF_CE3CTL1_RMKS(ta_sym,read_strobe_sym,mtype_sym,write_hold_sym,read_hold_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE3CTL1,TA,ta_sym))|\
  ( EMIF_FMKS(CE3CTL1,READ_STROBE,read_strobe_sym))|\
  ( EMIF_FMKS(CE3CTL1,MTYPE,mtype_sym))|\
  ( EMIF_FMKS(CE3CTL1,WRITE_HOLD,write_hold_sym))|\
  ( EMIF_FMKS(CE3CTL1,READ_HOLD,read_hold_sym))\
)\
 )

/*  Default CE3CTL1 register value  */

#define EMIF_CE3CTL1_DEFAULT          (0xFF03u)

/* ============================================================== */
 /* Make CE3CTL2 register values based on symbolic constants  */

/*  CE3CTL2 field values  */

	#define EMIF_CE3CTL2_WRITE_SETUP_OF(x)			((Uint16)(x))
	#define EMIF_CE3CTL2_WRITE_SETUP_DEFAULT			EMIF_CE3CTL2_WRITE_SETUP_OF(15)

	#define EMIF_CE3CTL2_WRITE_STROBE_OF(x)			((Uint16)(x))
	#define EMIF_CE3CTL2_WRITE_STROBE_DEFAULT			EMIF_CE3CTL2_WRITE_STROBE_OF(0x3fu)

	#define EMIF_CE3CTL2_WRITE_HOLD_OF(x)			((Uint16)(x))
	#define EMIF_CE3CTL2_WRITE_HOLD_DEFAULT			EMIF_CE3CTL2_WRITE_HOLD_OF(3)

	#define EMIF_CE3CTL2_READ_SETUP_OF(x)			((Uint16)(x))
	#define EMIF_CE3CTL2_READ_SETUP_DEFAULT			EMIF_CE3CTL2_READ_SETUP_OF(15)



#define EMIF_CE3CTL2_RMK(write_setup,write_strobe,write_hold,read_setup)\
 ((Uint16) ( \
  ( EMIF_FMK(CE3CTL2,WRITE_SETUP,write_setup))|\
  ( EMIF_FMK(CE3CTL2,WRITE_STROBE,write_strobe))|\
  ( EMIF_FMK(CE3CTL2,WRITE_HOLD,write_hold))|\
  ( EMIF_FMK(CE3CTL2,READ_SETUP,read_setup))\
)\
 )

#define EMIF_CE3CTL2_RMKS(write_setup_sym,write_strobe_sym,write_hold_sym,read_setup_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE3CTL2,WRITE_SETUP,write_setup_sym))|\
  ( EMIF_FMKS(CE3CTL2,WRITE_STROBE,write_strobe_sym))|\
  ( EMIF_FMKS(CE3CTL2,WRITE_HOLD,write_hold_sym))|\
  ( EMIF_FMKS(CE3CTL2,READ_SETUP,read_setup_sym))\
)\
 )

/*  Default CE3CTL2 register value  */

#define EMIF_CE3CTL2_DEFAULT              (0xFFFFu)

/* ============================================================== */
 /* Make CE3SEC1 register values based on symbolic constants  */

/*  CE3SEC1 field values  */

	#define EMIF_CE3SEC1_SNCCLK_SYNC_ECLKOUT1			(000000u)
	#define EMIF_CE3SEC1_SNCCLK_SYNC_ECLKOUT2			(0x0001u)
	#define EMIF_CE3SEC1_SNCCLK_DEFAULT		EMIF_CE3SEC1_SNCCLK_SYNC_ECLKOUT1

	#define EMIF_CE3SEC1_REN_ADS			(000000u)
	#define EMIF_CE3SEC1_REN_REN			(0x0001u)
	#define EMIF_CE3SEC1_REN_DEFAULT		EMIF_CE3SEC1_REN_ADS

	#define EMIF_CE3SEC1_RENEN_ADS			(000000u)
	#define EMIF_CE3SEC1_RENEN_REN			(0x0001u)
	#define EMIF_CE3SEC1_RENEN_DEFAULT			EMIF_CE3SEC1_RENEN_ADS

	#define EMIF_CE3SEC1_CEEXT_CE_TIED_TO_SOE			(0x0001u)
	#define EMIF_CE3SEC1_CEEXT_CE_TIED_TO_SNCCRL			(000000u)
	#define EMIF_CE3SEC1_CEEXT_DEFAULT		EMIF_CE3SEC1_CEEXT_CE_TIED_TO_SNCCRL

	#define EMIF_CE3SEC1_SYNCWL_0CYCLES			(000000u)
	#define EMIF_CE3SEC1_SYNCWL_1CYCLES			(0x0001u)
	#define EMIF_CE3SEC1_SYNCWL_2CYCLES			(0x0002u)
	#define EMIF_CE3SEC1_SYNCWL_3CYCLES			(0x0003u)
	#define EMIF_CE3SEC1_SYNCWL_DEFAULT		EMIF_CE3SEC1_SYNCWL_2CYCLES

	#define EMIF_CE3SEC1_SYNCRL_0CYCLES			(000000u)
	#define EMIF_CE3SEC1_SYNCRL_1CYCLE			(0x0001u)
	#define EMIF_CE3SEC1_SYNCRL_2CYCLES			(0x0002u)
	#define EMIF_CE3SEC1_SYNCRL_3CYCLES			(0x0003u)
	#define EMIF_CE3SEC1_SYNCRL_DEFAULT		EMIF_CE3SEC1_SYNCRL_2CYCLES

#define EMIF_CE3SEC1_RMK(sncclk,renen,ceext,syncwl,syncrl)\
 ((Uint16) ( \
  ( EMIF_FMK(CE3SEC1,SNCCLK,sncclk))|\
  ( EMIF_FMK(CE3SEC1,RENEN,renen))|\
  ( EMIF_FMK(CE3SEC1,CEEXT,ceext))|\
  ( EMIF_FMK(CE3SEC1,SYNCWL,syncwl))|\
  ( EMIF_FMK(CE3SEC1,SYNCRL,syncrl))\
)\
 )

#define EMIF_CE3SEC1_RMKS(sncclk_sym,renen_sym,ceext_sym,syncwl_sym,syncrl_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(CE3SEC1,SNCCLK,sncclk_sym))|\
  ( EMIF_FMKS(CE3SEC1,RENEN,renen_sym))|\
  ( EMIF_FMKS(CE3SEC1,CEEXT,ceext_sym))|\
  ( EMIF_FMKS(CE3SEC1,SYNCWL,syncwl_sym))|\
  ( EMIF_FMKS(CE3SEC1,SYNCRL,syncrl_sym))\
)\
 )


/*  Default CE3SEC1 register value  */

#define EMIF_CE3SEC1_DEFAULT              (0x0002u)

/* ============================================================== */
 /* Make GBLCTL1 register values based on symbolic constants  */

/*  GBLCTL1 field values  */

	#define EMIF_GBLCTL1_ARDY_DEV_NOT_READY			(000000u)
	#define EMIF_GBLCTL1_ARDY_DEV_READY			(0x0001u)
	#define EMIF_GBLCTL1_HOLD_EXT_REQUEST			(000000u)
	#define EMIF_GBLCTL1_HOLD_NO_REQUEST			(0x0001u)
	#define EMIF_GBLCTL1_HOLDA_EXT_DEV_OWNS_EMIF			(000000u)
	#define EMIF_GBLCTL1_HOLDA_EMIF_FREE			(0x0001u)
	#define EMIF_GBLCTL1_NOHOLD_HOLD_ENABLED			(000000u)
	#define EMIF_GBLCTL1_NOHOLD_HOLD_DISABLED			(0x0001u)
	#define EMIF_GBLCTL1_NOHOLD_DEFAULT		EMIF_GBLCTL1_NOHOLD_HOLD_DISABLED

	#define EMIF_GBLCTL1_EK1HZ_HIGHZ			(0x0001u)
	#define EMIF_GBLCTL1_EK1HZ_EK1EN			(000000u)
	#define EMIF_GBLCTL1_EK1HZ_DEFAULT		EMIF_GBLCTL1_EK1HZ_EK1EN

	#define EMIF_GBLCTL1_EK1EN_ENABLED			(000001u)
	#define EMIF_GBLCTL1_EK1EN_DISABLED			(000000u)

#define EMIF_GBLCTL1_RMK(nohold,ek1hz,ek1en)\
 ((Uint16) ( \
  ( EMIF_FMK(GBLCTL1,NOHOLD,nohold))|\
  ( EMIF_FMK(GBLCTL1,EK1HZ,ek1hz))|\
  ( EMIF_FMK(GBLCTL1,EK1EN,ek1en))\
)\
 )

#define EMIF_GBLCTL1_RMKS(nohold_sym,ek1hz_sym,ek1en_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(GBLCTL1,NOHOLD,nohold_sym))|\
  ( EMIF_FMKS(GBLCTL1,EK1HZ,ek1hz_sym))|\
  ( EMIF_FMKS(GBLCTL1,EK1EN,ek1en_sym))\
)\
 )

/*  Default GBLCTL1 register value  */

#define EMIF_GBLCTL1_DEFAULT                 (0x0060u)

/* ============================================================== */
 /* Make GBLCTL2 register values based on symbolic constants  */

/*  GBLCTL2 field values  */

	#define EMIF_GBLCTL2_EK2RATE_1XCLK			(000000u)
	#define EMIF_GBLCTL2_EK2RATE_2XCLK			(0x0001u)
	#define EMIF_GBLCTL2_EK2RATE_4XCLK			(0x0002u)
	#define EMIF_GBLCTL2_EK2RATE_DEFAULT		EMIF_GBLCTL2_EK2RATE_1XCLK

	#define EMIF_GBLCTL2_EK2HZ_HIGHZ			(0x0001u)
	#define EMIF_GBLCTL2_EK2HZ_EK2EN			(000000u)
	#define EMIF_GBLCTL2_EK2HZ_DEFAULT		EMIF_GBLCTL2_EK2HZ_EK2EN

	#define EMIF_GBLCTL2_EK2EN_ENABLED			(0x0001u)
	#define EMIF_GBLCTL2_EK2EN_DISABLED			(000000u)
	#define EMIF_GBLCTL2_EK2EN_DEFAULT		EMIF_GBLCTL2_EK2EN_ENABLED


#define EMIF_GBLCTL2_RMK(ek2rate,ek2hz,ek2en)\
 ((Uint16) ( \
  ( EMIF_FMK(GBLCTL2,EK2RATE,ek2rate))|\
  ( EMIF_FMK(GBLCTL2,EK2HZ,ek2hz))|\
  ( EMIF_FMK(GBLCTL2,EK2EN,ek2en))\
)\
 )

#define EMIF_GBLCTL2_RMKS(ek2rate_sym,ek2hz_sym,ek2en_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(GBLCTL2,EK2RATE,ek2rate_sym))|\
  ( EMIF_FMKS(GBLCTL2,EK2HZ,ek2hz_sym))|\
  ( EMIF_FMKS(GBLCTL2,EK2EN,ek2en_sym))\
)\
 )

/*  Default GBLCTL2 register value  */

#define EMIF_GBLCTL2_DEFAULT         (0x0009u)

/* ============================================================== */
 /* Make SDCTL1 register values based on symbolic constants  */

/*  SDCTL1 field values  */

	#define EMIF_SDCTL1_TRC_OF(x)			((Uint16)(x))
	#define EMIF_SDCTL1_SLFRFR_ENABLED			(0x0001u)
	#define EMIF_SDCTL1_SLFRFR_DISABLED			(000000u)
	#define EMIF_SDCTL1_SLFRFR_GP_OUTPUT			(000000u)
	#define EMIF_SDCTL1_SLFRFR_DEFAULT		EMIF_SDCTL1_SLFRFR_DISABLED


#define EMIF_SDCTL1_RMK(trc,slfrfr)\
 ((Uint16) ( \
  ( EMIF_FMK(SDCTL1,TRC,trc))|\
  ( EMIF_FMK(SDCTL1,SLFRFR,slfrfr))\
)\
 )

#define EMIF_SDCTL1_RMKS(trc_sym,slfrfr_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(SDCTL1,TRC,trc_sym))|\
  ( EMIF_FMKS(SDCTL1,SLFRFR,slfrfr_sym))\
)\
 )

/*  Default SDCTL1 register value  */

#define EMIF_SDCTL1_DEFAULT          (0xF000u)

/* ============================================================== */
 /* Make SDCTL2 register values based on symbolic constants  */

/*  SDCTL2 field values  */

	#define EMIF_SDCTL2_SDWTH_2BANKS			(000000u)
	#define EMIF_SDCTL2_SDWTH_4BANKS			(0x0010u)
	#define EMIF_SDCTL2_SDWTH_11ROW_ADDR_PINS			(000000u)
	#define EMIF_SDCTL2_SDWTH_12ROW_ADDR_PINS			(0x0004u)
	#define EMIF_SDCTL2_SDWTH_13ROW_ADDR_PINS			(0x0008u)
	#define EMIF_SDCTL2_SDWTH_9COL_ADDR_PINS			(000000u)
	#define EMIF_SDCTL2_SDWTH_8COL_ADDR_PINS			(0x0001u)
	#define EMIF_SDCTL2_SDWTH_10COL_ADDR_PINS			(0x0002u)
	#define EMIF_SDCTL2_SDWTH_DEFAULT		EMIF_SDCTL2_SDWTH_2BANKS

	#define EMIF_SDCTL2_RFEN_ENABLED			(0x0001u)
	#define EMIF_SDCTL2_RFEN_DISABLED			(000000u)
	#define EMIF_SDCTL2_RFEN_DEFAULT		EMIF_SDCTL2_RFEN_ENABLED

	#define EMIF_SDCTL2_INIT_INIT_SDRAM			(0x0001u)
	#define EMIF_SDCTL2_INIT_INIT_DONE			(000000u)
	#define EMIF_SDCTL2_TRCD_OF(x)			((Uint16)(x))
	#define EMIF_SDCTL2_TRP_OF(x)			((Uint16)(x))

#define EMIF_SDCTL2_RMK(sdwth,rfen,init,trcd,trp)\
 ((Uint16) ( \
  ( EMIF_FMK(SDCTL2,SDWTH,sdwth))|\
  ( EMIF_FMK(SDCTL2,RFEN,rfen))|\
  ( EMIF_FMK(SDCTL2,INIT,init))|\
  ( EMIF_FMK(SDCTL2,TRCD,trcd))|\
  ( EMIF_FMK(SDCTL2,TRP,trp))\
)\
 )

#define EMIF_SDCTL2_RMKS(sdwth_sym,rfen_sym,init_sym,trcd_sym,trp_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(SDCTL2,SDWTH,sdwth_sym))|\
  ( EMIF_FMKS(SDCTL2,RFEN,rfen_sym))|\
  ( EMIF_FMKS(SDCTL2,INIT,init_sym))|\
  ( EMIF_FMKS(SDCTL2,TRCD,trcd_sym))|\
  ( EMIF_FMKS(SDCTL2,TRP,trp_sym))\
)\
 )

/*  Default SDCTL2 register value  */

#define EMIF_SDCTL2_DEFAULT           (0x0348u)

/* ============================================================== */
 /* Make SDEXT1 register values based on symbolic constants  */

/*  SDEXT1 field values  */

	#define EMIF_SDEXT1_R2WDQM_1CYCLE			(0x0001u)
	#define EMIF_SDEXT1_R2WDQM_2CYCLES			(0x0002u)
	#define EMIF_SDEXT1_R2WDQM_3CYCLES			(0x0003u)
	#define EMIF_SDEXT1_R2WDQM_DEFAULT		EMIF_SDEXT1_R2WDQM_2CYCLES

	#define EMIF_SDEXT1_RD2WR_3CYCLES			(0x0003u)
	#define EMIF_SDEXT1_RD2WR_4CYCLES			(0x0004u)
	#define EMIF_SDEXT1_RD2WR_5CYCLES			(0x0005u)
	#define EMIF_SDEXT1_RD2WR_DEFAULT		EMIF_SDEXT1_RD2WR_5CYCLES

	#define EMIF_SDEXT1_RD2DEAC_1CYCLE			(0x0001u)
	#define EMIF_SDEXT1_RD2DEAC_2CYCLES			(0x0002u)
	#define EMIF_SDEXT1_RD2DEAC_3CYCLES			(0x0003u)
	#define EMIF_SDEXT1_RD2DEAC_DEFAULT		EMIF_SDEXT1_RD2DEAC_3CYCLES

	#define EMIF_SDEXT1_RD2RD_1CYCLE			(000000u)
	#define EMIF_SDEXT1_RD2RD_2CYCLES			(0x0001u)
	#define EMIF_SDEXT1_RD2RD_DEFAULT		EMIF_SDEXT1_RD2RD_2CYCLES

	#define EMIF_SDEXT1_THZP_OF(x)			((Uint16)(x))
	#define EMIF_SDEXT1_TWR_OF(x)			((Uint16)(x))
	#define EMIF_SDEXT1_TRRD_2CYCLES			(000000u)
	#define EMIF_SDEXT1_TRRD_3CYCLES			(0x0001u)
	#define EMIF_SDEXT1_TRRD_DEFAULT		EMIF_SDEXT1_TRRD_3CYCLES

	#define EMIF_SDEXT1_TRAS_OF(x)			((Uint16)(x))
	#define EMIF_SDEXT1_TCL_2CYCLES			(000000u)
	#define EMIF_SDEXT1_TCL_3CYCLES			(0x0001u)
	#define EMIF_SDEXT1_TCL_DEFAULT		EMIF_SDEXT1_TCL_3CYCLES


#define EMIF_SDEXT1_RMK(r2wdqm,rd2wr,rd2deac,rd2rd,thzp,twr,trrd,tras,tcl)\
 ((Uint16) ( \
  ( EMIF_FMK(SDEXT1,R2WDQM,r2wdqm))|\
  ( EMIF_FMK(SDEXT1,RD2WR,rd2wr))|\
  ( EMIF_FMK(SDEXT1,RD2DEAC,rd2deac))|\
  ( EMIF_FMK(SDEXT1,RD2RD,rd2rd))|\
  ( EMIF_FMK(SDEXT1,THZP,thzp))|\
  ( EMIF_FMK(SDEXT1,TWR,twr))|\
  ( EMIF_FMK(SDEXT1,TRRD,trrd))|\
  ( EMIF_FMK(SDEXT1,TRAS,tras))|\
  ( EMIF_FMK(SDEXT1,TCL,tcl))\
)\
 )

#define EMIF_SDEXT1_RMKS(r2wdqm_sym,rd2wr_sym,rd2deac_sym,rd2rd_sym,thzp_sym,twr_sym,trrd_sym,tras_sym,tcl_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(SDEXT1,R2WDQM,r2wdqm_sym))|\
  ( EMIF_FMKS(SDEXT1,RD2WR,rd2wr_sym))|\
  ( EMIF_FMKS(SDEXT1,RD2DEAC,rd2deac_sym))|\
  ( EMIF_FMKS(SDEXT1,RD2RD,rd2rd_sym))|\
  ( EMIF_FMKS(SDEXT1,THZP,thzp_sym))|\
  ( EMIF_FMKS(SDEXT1,TWR,twr_sym))|\
  ( EMIF_FMKS(SDEXT1,TRRD,trrd_sym))|\
  ( EMIF_FMKS(SDEXT1,TRAS,tras_sym))|\
  ( EMIF_FMKS(SDEXT1,TCL,tcl_sym))\
)\
 )

/*  Default SDEXT1 register value  */

#define EMIF_SDEXT1_DEFAULT           (0x5F3Fu)

/* ============================================================== */
 /* Make SDEXT2 register values based on symbolic constants  */

/*  SDEXT2 field values  */

	#define EMIF_SDEXT2_WR2RD_0CYCLES			(000000u)
	#define EMIF_SDEXT2_WR2RD_1CYCLE			(0x0001u)
	#define EMIF_SDEXT2_WR2RD_DEFAULT		EMIF_SDEXT2_WR2RD_1CYCLE

	#define EMIF_SDEXT2_WR2DEAC_1CYCLE			(0x0001u)
	#define EMIF_SDEXT2_WR2DEAC_DEFAULT		EMIF_SDEXT2_WR2DEAC_1CYCLE

	#define EMIF_SDEXT2_WR2WR_1CYCLE			(0x0001u)
	#define EMIF_SDEXT2_WR2WR_DEFAULT		EMIF_SDEXT2_WR2WR_1CYCLE

	#define EMIF_SDEXT2_R2WDQM_1CYCLE			(0x0001u)
	#define EMIF_SDEXT2_R2WDQM_2CYCLES			(0x0002u)
	#define EMIF_SDEXT2_R2WDQM_3CYCLES			(0x0003u)
	#define EMIF_SDEXT2_R2WDQM_DEFAULT		EMIF_SDEXT2_R2WDQM_2CYCLES


#define EMIF_SDEXT2_RMK(wr2rd,wr2deac,wr2wr,r2wdqm)\
 ((Uint16) ( \
  ( EMIF_FMK(SDEXT2,WR2RD,wr2rd))|\
  ( EMIF_FMK(SDEXT2,WR2DEAC,wr2deac))|\
  ( EMIF_FMK(SDEXT2,WR2WR,wr2wr))|\
  ( EMIF_FMK(SDEXT2,R2WDQM,r2wdqm))\
)\
 )

#define EMIF_SDEXT2_RMKS(wr2rd_sym,wr2deac_sym,wr2wr_sym,r2wdqm_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(SDEXT2,WR2RD,wr2rd_sym))|\
  ( EMIF_FMKS(SDEXT2,WR2DEAC,wr2deac_sym))|\
  ( EMIF_FMKS(SDEXT2,WR2WR,wr2wr_sym))|\
  ( EMIF_FMKS(SDEXT2,R2WDQM,r2wdqm_sym))\
)\
 )

/*  Default SDEXT2 register value  */

#define EMIF_SDEXT2_DEFAULT          (0x0017u)

/* ============================================================== */
 /* Make SDTIM1 register values based on symbolic constants  */

/*  SDTIM1 field values  */

	#define EMIF_SDTIM1_PERIOD_OF(x)			((Uint16)(x))

#define EMIF_SDTIM1_RMK(period)\
 ((Uint16) ( \
  ( EMIF_FMK(SDTIM1,PERIOD,period))\
)\
 )

#define EMIF_SDTIM1_RMKS(period_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(SDTIM1,PERIOD,period_sym))\
)\
 )

/*  Default SDTIM1 register value  */

#define EMIF_SDTIM1_DEFAULT         (0x05DCu)

/*  SDRFR1 field values  */

	#define EMIF_SDRFR1_PERIOD_OF(x)			((Uint16)(x))

#define EMIF_SDRFR1_RMK(period)\
 ((Uint16) ( \
  ( EMIF_FMK(SDRFR1,PERIOD,period))\
)\
 )

#define EMIF_SDRFR1_RMKS(period_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(SDRFR1,PERIOD,period_sym))\
)\
 )

/*  Default SDRFR1 register value  */

#define EMIF_SDRFR1_DEFAULT          (0x05DCu)


/* ============================================================== */
 /* Make SDTIM2 register values based on symbolic constants  */

/*  SDTIM2 field values  */

	#define EMIF_SDTIM2_EXTRA_REFRESHES_1REFRESH			(000000u)
	#define EMIF_SDTIM2_EXTRA_REFRESHES_2REFRESHES			(0x0001u)
	#define EMIF_SDTIM2_EXTRA_REFRESHES_3REFRESHES			(0x0002u)
	#define EMIF_SDTIM2_EXTRA_REFRESHES_4REFRESHES			(0x0003u)
	#define EMIF_SDTIM2_EXTRA_REFRESHES_DEFAULT		EMIF_SDTIM2_EXTRA_REFRESHES_1REFRESH

	#define EMIF_SDTIM2_COUNTER_OF(x)			             ((Uint16)(x))

#define EMIF_SDTIM2_RMK(extra_refreshes,counter)\
 ((Uint16) ( \
  ( EMIF_FMK(SDTIM2,EXTRA_REFRESHES,extra_refreshes))|\
  ( EMIF_FMK(SDTIM2,COUNTER,counter))\
)\
 )

#define EMIF_SDTIM2_RMKS(extra_refreshes_sym,counter_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(SDTIM2,EXTRA_REFRESHES,extra_refreshes_sym))|\
  ( EMIF_FMKS(SDTIM2,COUNTER,counter_sym))\
)\
 )

/*  Default SDTIM2 register value  */

#define EMIF_SDTIM2_DEFAULT           (0x05DCu)

/* ============================================================== */
 /* Make SDRFR2 register values based on symbolic constants  */

/*  SDRFR2 field values  */

	#define EMIF_SDRFR2_EXTRA_REFRESHES_1REFRESH			(000000u)
	#define EMIF_SDRFR2_EXTRA_REFRESHES_2REFRESHES			(0x0001u)
	#define EMIF_SDRFR2_EXTRA_REFRESHES_3REFRESHES			(0x0002u)
	#define EMIF_SDRFR2_EXTRA_REFRESHES_4REFRESHES			(0x0003u)
	#define EMIF_SDRFR2_EXTRA_REFRESHES_DEFAULT		EMIF_SDRFR2_EXTRA_REFRESHES_1REFRESH

	#define EMIF_SDRFR2_COUNTER_OF(x)			             ((Uint16)(x))

#define EMIF_SDRFR2_RMK(extra_refreshes,counter)\
 ((Uint16) ( \
  ( EMIF_FMK(SDRFR2,EXTRA_REFRESHES,extra_refreshes))|\
  ( EMIF_FMK(SDRFR2,COUNTER,counter))\
)\
 )

#define EMIF_SDRFR2_RMKS(extra_refreshes_sym,counter_sym)\
 ((Uint16) ( \
  ( EMIF_FMKS(SDRFR2,EXTRA_REFRESHES,extra_refreshes_sym))|\
  ( EMIF_FMKS(SDRFR2,COUNTER,counter_sym))\
)\
 )

/*  Default SDRFR2 register value  */
#define EMIF_SDRFR2_DEFAULT           (0x05DCu)

/* ============================================================== */
 /* Make CESCR register values based on symbolic constants       */

#define EMIF_CESCR_RMK(ces)\
  ((Uint16)EMIF_FMK(CESCR,CES,ces))

#define EMIF_CESCR_RMKS(ces)\
  ((Uint16)EMIF_FMKS(CESCR,CES,ces))

#define EMIF_CESCR_DEFAULT						(0x0000u)

/*************************************************\
 EMIF global typedef declarations 
\*************************************************/

typedef struct {
	Uint16 gblctl1;
	Uint16 gblctl2;
	Uint16 ce1ctl1;
	Uint16 ce1ctl2;
	Uint16 ce0ctl1;
	Uint16 ce0ctl2;
	Uint16 ce2ctl1;
	Uint16 ce2ctl2;
	Uint16 ce3ctl1;
	Uint16 ce3ctl2;
	Uint16 sdctl1;
	Uint16 sdctl2;
	Uint16 sdrfr1;
	Uint16 sdrfr2;
	Uint16 sdext1;
	Uint16 sdext2;
	Uint16 ce1sec1;
	Uint16 ce0sec1;
	Uint16 ce2sec1;
	Uint16 ce3sec1;
      Uint16 cescr;
} EMIF_Config;


/*************************************************\
* EMIF global variable declarations
\*************************************************/


/*************************************************\
* EMIF global function declarations
\*************************************************/



CSLAPI void EMIF_config(EMIF_Config *myConfig);
CSLAPI void EMIF_configArgs(Uint16 gblctl1,Uint16 gblctl2,Uint16 ce1ctl1,Uint16 ce1ctl2,Uint16 ce0ctl1,
                            Uint16 ce0ctl2,Uint16 ce2ctl1,Uint16 ce2ctl2,Uint16 ce3ctl1,Uint16 ce3ctl2,
                            Uint16 sdctl1,Uint16 sdctl2,Uint16 sdrfr1,Uint16 sdrfr2,Uint16 sdext1,Uint16 sdext2,
                            Uint16 ce1sec1,Uint16 ce0sec1,Uint16 ce2sec1,Uint16 ce3sec1, Uint16 cescr);
CSLAPI void EMIF_getConfig(EMIF_Config *myConfig);

/*************************************************\
* EMIF inline function declarations
\*************************************************/


#ifdef USEDEFS


/*----------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /*USEDEFS */

#elif (!(_EMIF_MOD))
	#error EMIF Hal Module Not Supported on Specified Target
#endif  /* _EMIF_SUPPORT  */

#endif  /* _CSL_EMIFHAL_H  */

/******************************************************************************\
*     
*      End of csl_emif.h 
*
\******************************************************************************/

csl_emifBhal.h/ 1049976852  0     0     0       83343     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... EMIF
* FILENAME...... csl_emifhal.h
* DATE CREATED.. Mon Feb 11 15:35:20 2002
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Mon Feb 11 15:35:20 2002 (Automatic generation)
*	 Modified:	26 Mar 2003   Added definitions to bring in line with
*                               User Documentation SPRU621A
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL HAL interface file for the EMIF module 
*
* Registers covered:
*
* 		 Note: Add registers description here
*	 GBLCTL1		- EMIF Global Control Register 1
*	 GBLCTL2		- EMIF Global Control Register 2
*	 CE1CTL1		- CE1 Space Control Register 1
*	 CE1CTL2		- CE1 Space Control Register 2
*	 CE0CTL1		- CE0 Space Control Register 1
*	 CE0CTL2		- CE0 Space Control Register 2
*	 CE2CTL1		- CE2 Space Control Register 1
*	 CE2CTL2		- CE2 Space Control Register 2
*	 CE3CTL1		- CE3 Space Control Register 1
*	 CE3CTL2		- CE3 Space Control Register 2
*	 SDCTL1		- SDRAM Control Register 1
*	 SDCTL2		- SDRAM Control Register 2
*	 SDTIM1/SDRFR1	- SDRAM Refresh Control Register 1 Alternate naming Added 26 Mar 2003
*	 SDTIM2/SDRFR2	- SDRAM Refresh Control Register 2 Alternate naming Added 26 Mar 2003
*	 SDEXT1		- SDRAM Extension Register 1
*	 SDEXT2		- SDRAM Extension Register 2
*	 CE1SEC1		- CE1 Space Secondary Control Register 1
*	 CE0SEC1		- CE0 Space Secondary Control Register 1
*	 CE2SEC1		- CE2 Space Secondary Control Register 1
*	 CE3SEC1		- CE3 Space Secondary Control Register 1
*      CESCR            - CE Space Size Control Register (affects all CE spaces)
*                         Added 26 Mar 2003
*
\*************************************************************************/

#ifndef _CSL_EMIFBHAL_H_
#define _CSL_EMIFBHAL_H_

#include <csl_chiphal.h>

#if (_EMIFB_SUPPORT) 

/*----------------------------------------------------------------*\
*	 EMIF scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _EMIF_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/*----------------------------------------------------------------*\
*		 Address Macros			
\*----------------------------------------------------------------*/

/*--------------------- Register: GBLCTL1 -----------------------*/
#define _EMIF_GBLCTL1_ADDR		(0x0800u)
#define _EMIF_GBLCTL1			PREG16(_EMIF_GBLCTL1_ADDR)
#define _GBLCTL1			_EMIF_GBLCTL1


/*--------------------- Register: GBLCTL2 -----------------------*/
#define _EMIF_GBLCTL2_ADDR		(0x0801u)
#define _EMIF_GBLCTL2			PREG16(_EMIF_GBLCTL2_ADDR)
#define _GBLCTL2			_EMIF_GBLCTL2


/*--------------------- Register: CE1CTL1 -----------------------*/
#define _EMIF_CE1CTL1_ADDR		(0x0802u)
#define _EMIF_CE1CTL1			PREG16(_EMIF_CE1CTL1_ADDR)
#define _CE1CTL1			_EMIF_CE1CTL1


/*--------------------- Register: CE1CTL2 -----------------------*/
#define _EMIF_CE1CTL2_ADDR		(0x0803u)
#define _EMIF_CE1CTL2			PREG16(_EMIF_CE1CTL2_ADDR)
#define _CE1CTL2			_EMIF_CE1CTL2


/*--------------------- Register: CE0CTL1 -----------------------*/
#define _EMIF_CE0CTL1_ADDR		(0x0804u)
#define _EMIF_CE0CTL1			PREG16(_EMIF_CE0CTL1_ADDR)
#define _CE0CTL1			_EMIF_CE0CTL1


/*--------------------- Register: CE0CTL2 -----------------------*/
#define _EMIF_CE0CTL2_ADDR		(0x0805u)
#define _EMIF_CE0CTL2			PREG16(_EMIF_CE0CTL2_ADDR)
#define _CE0CTL2			_EMIF_CE0CTL2


/*--------------------- Register: CE2CTL1 -----------------------*/
#define _EMIF_CE2CTL1_ADDR		(0x0808u)
#define _EMIF_CE2CTL1			PREG16(_EMIF_CE2CTL1_ADDR)
#define _CE2CTL1			_EMIF_CE2CTL1


/*--------------------- Register: CE2CTL2 -----------------------*/
#define _EMIF_CE2CTL2_ADDR		(0x0809u)
#define _EMIF_CE2CTL2			PREG16(_EMIF_CE2CTL2_ADDR)
#define _CE2CTL2			_EMIF_CE2CTL2


/*--------------------- Register: CE3CTL1 -----------------------*/
#define _EMIF_CE3CTL1_ADDR		(0x080Au)
#define _EMIF_CE3CTL1			PREG16(_EMIF_CE3CTL1_ADDR)
#define _CE3CTL1			_EMIF_CE3CTL1


/*--------------------- Register: CE3CTL2 -----------------------*/
#define _EMIF_CE3CTL2_ADDR		(0x080Bu)
#define _EMIF_CE3CTL2			PREG16(_EMIF_CE3CTL2_ADDR)
#define _CE3CTL2			_EMIF_CE3CTL2


/*--------------------- Register: SDCTL1 -----------------------*/
#define _EMIF_SDCTL1_ADDR		(0x080Cu)
#define _EMIF_SDCTL1			PREG16(_EMIF_SDCTL1_ADDR)
#define _SDCTL1			_EMIF_SDCTL1


/*--------------------- Register: SDCTL2 -----------------------*/
#define _EMIF_SDCTL2_ADDR		(0x080Du)
#define _EMIF_SDCTL2			PREG16(_EMIF_SDCTL2_ADDR)
#define _SDCTL2			_EMIF_SDCTL2


/*--------------------- Register: SDTIM1 -----------------------*/
#define _EMIF_SDTIM1_ADDR		(0x080Eu)
#define _EMIF_SDTIM1			PREG16(_EMIF_SDTIM1_ADDR)
#define _SDTIM1			_EMIF_SDTIM1


/*--------------------- Register: SDTIM2 -----------------------*/
#define _EMIF_SDTIM2_ADDR		(0x080Fu)
#define _EMIF_SDTIM2			PREG16(_EMIF_SDTIM2_ADDR)
#define _SDTIM2			_EMIF_SDTIM2

/*--------------------- Register: SDRFR1 -----------------------*/
#define _EMIF_SDRFR1_ADDR		(0x080Eu)
#define _EMIF_SDRFR1			PREG16(_EMIF_SDRFR1_ADDR)
#define _SDRFR1			      _EMIF_SDRFR1


/*--------------------- Register: SDRFR2 -----------------------*/
#define _EMIF_SDRFR2_ADDR		(0x080Fu)
#define _EMIF_SDRFR2			PREG16(_EMIF_SDRFR2_ADDR)
#define _SDRFR2			      _EMIF_SDRFR2

/*--------------------- Register: SDEXT1 -----------------------*/
#define _EMIF_SDEXT1_ADDR		(0x0810u)
#define _EMIF_SDEXT1			PREG16(_EMIF_SDEXT1_ADDR)
#define _SDEXT1			_EMIF_SDEXT1


/*--------------------- Register: SDEXT2 -----------------------*/
#define _EMIF_SDEXT2_ADDR		(0x0811u)
#define _EMIF_SDEXT2			PREG16(_EMIF_SDEXT2_ADDR)
#define _SDEXT2			_EMIF_SDEXT2


/*--------------------- Register: CE1SEC1 -----------------------*/
#define _EMIF_CE1SEC1_ADDR		(0x0822u)
#define _EMIF_CE1SEC1			PREG16(_EMIF_CE1SEC1_ADDR)
#define _CE1SEC1			_EMIF_CE1SEC1


/*--------------------- Register: CE0SEC1 -----------------------*/
#define _EMIF_CE0SEC1_ADDR		(0x0824u)
#define _EMIF_CE0SEC1			PREG16(_EMIF_CE0SEC1_ADDR)
#define _CE0SEC1			_EMIF_CE0SEC1


/*--------------------- Register: CE2SEC1 -----------------------*/
#define _EMIF_CE2SEC1_ADDR		(0x0828u)
#define _EMIF_CE2SEC1			PREG16(_EMIF_CE2SEC1_ADDR)
#define _CE2SEC1			_EMIF_CE2SEC1


/*--------------------- Register: CE3SEC1 -----------------------*/
#define _EMIF_CE3SEC1_ADDR		(0x082Au)
#define _EMIF_CE3SEC1			PREG16(_EMIF_CE3SEC1_ADDR)
#define _CE3SEC1			_EMIF_CE3SEC1


/*--------------------- Register: CESCR -----------------------*/
#define _EMIF_CESCR_ADDR		(0x0840u)
#define _EMIF_CESCR			PREG16(_EMIF_CESCR_ADDR)
#define _CESCR				_EMIF_CESCR



/*----------------------------------------------------------------*\
*		 Register Macros		
\*----------------------------------------------------------------*/

#define EMIF_ADDR(Reg)		  _EMIF_##Reg##_ADDR
#define EMIF_RGET(Reg)		  _EMIF_##Reg##_GET
#define EMIF_RSET(Reg,Val)		  _EMIF_##Reg##_SET(Val)
#define EMIF_FGET(Reg,Field)		  _EMIF_##Reg##_FGET(Field)
#define EMIF_FSET(Reg,Field,Val)		  _EMIF_##Reg##_FSET(Field, Val)
#define EMIF_FMK(Reg,Field,Val)		  _EMIF_##Reg##_##Field##_MK(Val)
#define EMIF_RAOI(Reg,AND,OR,INV)		  _EMIF_##Reg##_AOI(AND,OR,INV)
#define EMIF_FAOI(Reg,Field,AND,OR,INV)	  _EMIF_##Reg##_FAOI(Field,AND,OR,INV)
#define EMIF_FMKS(Reg,Field,Sym)\
	  _EMIF_##Reg##_##Field##_MK(EMIF_##Reg##_##Field##_##Sym)
#define EMIF_FSETS(Reg,Field,Sym)\
	  _EMIF_FSET(Reg,Field,EMIF_##Reg##_##Field##_##Sym)

/*----------------------------------------------------------------*\
*		 Non-handle Registers Macros		
\*----------------------------------------------------------------*/


/*--------------------- Register: GBLCTL1 -----------------------*/
#define _EMIF_GBLCTL1_GET		  _PREG_GET(_EMIF_GBLCTL1_ADDR) 
#define _EMIF_GBLCTL1_SET(Val)		  _PREG_SET(_EMIF_GBLCTL1_ADDR,Val)
#define _EMIF_GBLCTL1_FGET(Field)	  _PFIELD_GET(_EMIF_GBLCTL1_ADDR, _EMIF_GBLCTL1_##Field)
#define _EMIF_GBLCTL1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_GBLCTL1_ADDR, _EMIF_GBLCTL1_##Field, Val)
#define _EMIF_GBLCTL1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_GBLCTL1_ADDR,AND,OR,INV)
#define _EMIF_GBLCTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_GBLCTL1_ADDR, _EMIF_GBLCTL1_##Field,AND,OR,INV)


/*--------------------- Register: GBLCTL2 -----------------------*/
#define _EMIF_GBLCTL2_GET		  _PREG_GET(_EMIF_GBLCTL2_ADDR) 
#define _EMIF_GBLCTL2_SET(Val)		  _PREG_SET(_EMIF_GBLCTL2_ADDR,Val)
#define _EMIF_GBLCTL2_FGET(Field)	  _PFIELD_GET(_EMIF_GBLCTL2_ADDR, _EMIF_GBLCTL2_##Field)
#define _EMIF_GBLCTL2_FSET(Field,Val)	  _PFIELD_SET(_EMIF_GBLCTL2_ADDR, _EMIF_GBLCTL2_##Field, Val)
#define _EMIF_GBLCTL2_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_GBLCTL2_ADDR,AND,OR,INV)
#define _EMIF_GBLCTL2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_GBLCTL2_ADDR, _EMIF_GBLCTL2_##Field,AND,OR,INV)


/*--------------------- Register: CE1CTL1 -----------------------*/
#define _EMIF_CE1CTL1_GET		  _PREG_GET(_EMIF_CE1CTL1_ADDR) 
#define _EMIF_CE1CTL1_SET(Val)		  _PREG_SET(_EMIF_CE1CTL1_ADDR,Val)
#define _EMIF_CE1CTL1_FGET(Field)	  _PFIELD_GET(_EMIF_CE1CTL1_ADDR, _EMIF_CE1CTL1_##Field)
#define _EMIF_CE1CTL1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE1CTL1_ADDR, _EMIF_CE1CTL1_##Field, Val)
#define _EMIF_CE1CTL1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE1CTL1_ADDR,AND,OR,INV)
#define _EMIF_CE1CTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE1CTL1_ADDR, _EMIF_CE1CTL1_##Field,AND,OR,INV)


/*--------------------- Register: CE1CTL2 -----------------------*/
#define _EMIF_CE1CTL2_GET		  _PREG_GET(_EMIF_CE1CTL2_ADDR) 
#define _EMIF_CE1CTL2_SET(Val)		  _PREG_SET(_EMIF_CE1CTL2_ADDR,Val)
#define _EMIF_CE1CTL2_FGET(Field)	  _PFIELD_GET(_EMIF_CE1CTL2_ADDR, _EMIF_CE1CTL2_##Field)
#define _EMIF_CE1CTL2_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE1CTL2_ADDR, _EMIF_CE1CTL2_##Field, Val)
#define _EMIF_CE1CTL2_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE1CTL2_ADDR,AND,OR,INV)
#define _EMIF_CE1CTL2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE1CTL2_ADDR, _EMIF_CE1CTL2_##Field,AND,OR,INV)


/*--------------------- Register: CE0CTL1 -----------------------*/
#define _EMIF_CE0CTL1_GET		  _PREG_GET(_EMIF_CE0CTL1_ADDR) 
#define _EMIF_CE0CTL1_SET(Val)		  _PREG_SET(_EMIF_CE0CTL1_ADDR,Val)
#define _EMIF_CE0CTL1_FGET(Field)	  _PFIELD_GET(_EMIF_CE0CTL1_ADDR, _EMIF_CE0CTL1_##Field)
#define _EMIF_CE0CTL1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE0CTL1_ADDR, _EMIF_CE0CTL1_##Field, Val)
#define _EMIF_CE0CTL1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE0CTL1_ADDR,AND,OR,INV)
#define _EMIF_CE0CTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE0CTL1_ADDR, _EMIF_CE0CTL1_##Field,AND,OR,INV)


/*--------------------- Register: CE0CTL2 -----------------------*/
#define _EMIF_CE0CTL2_GET		  _PREG_GET(_EMIF_CE0CTL2_ADDR) 
#define _EMIF_CE0CTL2_SET(Val)		  _PREG_SET(_EMIF_CE0CTL2_ADDR,Val)
#define _EMIF_CE0CTL2_FGET(Field)	  _PFIELD_GET(_EMIF_CE0CTL2_ADDR, _EMIF_CE0CTL2_##Field)
#define _EMIF_CE0CTL2_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE0CTL2_ADDR, _EMIF_CE0CTL2_##Field, Val)
#define _EMIF_CE0CTL2_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE0CTL2_ADDR,AND,OR,INV)
#define _EMIF_CE0CTL2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE0CTL2_ADDR, _EMIF_CE0CTL2_##Field,AND,OR,INV)


/*--------------------- Register: CE2CTL1 -----------------------*/
#define _EMIF_CE2CTL1_GET		  _PREG_GET(_EMIF_CE2CTL1_ADDR) 
#define _EMIF_CE2CTL1_SET(Val)		  _PREG_SET(_EMIF_CE2CTL1_ADDR,Val)
#define _EMIF_CE2CTL1_FGET(Field)	  _PFIELD_GET(_EMIF_CE2CTL1_ADDR, _EMIF_CE2CTL1_##Field)
#define _EMIF_CE2CTL1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE2CTL1_ADDR, _EMIF_CE2CTL1_##Field, Val)
#define _EMIF_CE2CTL1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE2CTL1_ADDR,AND,OR,INV)
#define _EMIF_CE2CTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE2CTL1_ADDR, _EMIF_CE2CTL1_##Field,AND,OR,INV)


/*--------------------- Register: CE2CTL2 -----------------------*/
#define _EMIF_CE2CTL2_GET		  _PREG_GET(_EMIF_CE2CTL2_ADDR) 
#define _EMIF_CE2CTL2_SET(Val)		  _PREG_SET(_EMIF_CE2CTL2_ADDR,Val)
#define _EMIF_CE2CTL2_FGET(Field)	  _PFIELD_GET(_EMIF_CE2CTL2_ADDR, _EMIF_CE2CTL2_##Field)
#define _EMIF_CE2CTL2_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE2CTL2_ADDR, _EMIF_CE2CTL2_##Field, Val)
#define _EMIF_CE2CTL2_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE2CTL2_ADDR,AND,OR,INV)
#define _EMIF_CE2CTL2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE2CTL2_ADDR, _EMIF_CE2CTL2_##Field,AND,OR,INV)


/*--------------------- Register: CE3CTL1 -----------------------*/
#define _EMIF_CE3CTL1_GET		  _PREG_GET(_EMIF_CE3CTL1_ADDR) 
#define _EMIF_CE3CTL1_SET(Val)		  _PREG_SET(_EMIF_CE3CTL1_ADDR,Val)
#define _EMIF_CE3CTL1_FGET(Field)	  _PFIELD_GET(_EMIF_CE3CTL1_ADDR, _EMIF_CE3CTL1_##Field)
#define _EMIF_CE3CTL1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE3CTL1_ADDR, _EMIF_CE3CTL1_##Field, Val)
#define _EMIF_CE3CTL1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE3CTL1_ADDR,AND,OR,INV)
#define _EMIF_CE3CTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE3CTL1_ADDR, _EMIF_CE3CTL1_##Field,AND,OR,INV)


/*--------------------- Register: CE3CTL2 -----------------------*/
#define _EMIF_CE3CTL2_GET		  _PREG_GET(_EMIF_CE3CTL2_ADDR) 
#define _EMIF_CE3CTL2_SET(Val)		  _PREG_SET(_EMIF_CE3CTL2_ADDR,Val)
#define _EMIF_CE3CTL2_FGET(Field)	  _PFIELD_GET(_EMIF_CE3CTL2_ADDR, _EMIF_CE3CTL2_##Field)
#define _EMIF_CE3CTL2_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE3CTL2_ADDR, _EMIF_CE3CTL2_##Field, Val)
#define _EMIF_CE3CTL2_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE3CTL2_ADDR,AND,OR,INV)
#define _EMIF_CE3CTL2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE3CTL2_ADDR, _EMIF_CE3CTL2_##Field,AND,OR,INV)

/*--------------------- Register: CESCR -----------------------*/
#define _EMIF_CESCR_GET		  _PREG_GET(_EMIF_CESCR_ADDR) 
#define _EMIF_CESCR_SET(Val)		  _PREG_SET(_EMIF_CESCR_ADDR,Val)
#define _EMIF_CESCR_FGET(Field)	  _PFIELD_GET(_EMIF_CESCR_ADDR, _EMIF_CESCR_##Field)
#define _EMIF_CESCR_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CESCR_ADDR, _EMIF_CESCR_##Field, Val)
#define _EMIF_CESCR_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CESCR_ADDR,AND,OR,INV)
#define _EMIF_CESCR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CESCR_ADDR, _EMIF_CESCR_##Field,AND,OR,INV)



/*--------------------- Register: SDCTL1 -----------------------*/
#define _EMIF_SDCTL1_GET		  _PREG_GET(_EMIF_SDCTL1_ADDR) 
#define _EMIF_SDCTL1_SET(Val)		  _PREG_SET(_EMIF_SDCTL1_ADDR,Val)
#define _EMIF_SDCTL1_FGET(Field)	  _PFIELD_GET(_EMIF_SDCTL1_ADDR, _EMIF_SDCTL1_##Field)
#define _EMIF_SDCTL1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_SDCTL1_ADDR, _EMIF_SDCTL1_##Field, Val)
#define _EMIF_SDCTL1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_SDCTL1_ADDR,AND,OR,INV)
#define _EMIF_SDCTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_SDCTL1_ADDR, _EMIF_SDCTL1_##Field,AND,OR,INV)


/*--------------------- Register: SDCTL2 -----------------------*/
#define _EMIF_SDCTL2_GET		  _PREG_GET(_EMIF_SDCTL2_ADDR) 
#define _EMIF_SDCTL2_SET(Val)		  _PREG_SET(_EMIF_SDCTL2_ADDR,Val)
#define _EMIF_SDCTL2_FGET(Field)	  _PFIELD_GET(_EMIF_SDCTL2_ADDR, _EMIF_SDCTL2_##Field)
#define _EMIF_SDCTL2_FSET(Field,Val)	  _PFIELD_SET(_EMIF_SDCTL2_ADDR, _EMIF_SDCTL2_##Field, Val)
#define _EMIF_SDCTL2_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_SDCTL2_ADDR,AND,OR,INV)
#define _EMIF_SDCTL2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_SDCTL2_ADDR, _EMIF_SDCTL2_##Field,AND,OR,INV)


/*--------------------- Register: SDTIM1 -----------------------*/
#define _EMIF_SDTIM1_GET		  _PREG_GET(_EMIF_SDTIM1_ADDR) 
#define _EMIF_SDTIM1_SET(Val)		  _PREG_SET(_EMIF_SDTIM1_ADDR,Val)
#define _EMIF_SDTIM1_FGET(Field)	  _PFIELD_GET(_EMIF_SDTIM1_ADDR, _EMIF_SDTIM1_##Field)
#define _EMIF_SDTIM1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_SDTIM1_ADDR, _EMIF_SDTIM1_##Field, Val)
#define _EMIF_SDTIM1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_SDTIM1_ADDR,AND,OR,INV)
#define _EMIF_SDTIM1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_SDTIM1_ADDR, _EMIF_SDTIM1_##Field,AND,OR,INV)


/*--------------------- Register: SDTIM2 -----------------------*/
#define _EMIF_SDTIM2_GET		  _PREG_GET(_EMIF_SDTIM2_ADDR) 
#define _EMIF_SDTIM2_SET(Val)		  _PREG_SET(_EMIF_SDTIM2_ADDR,Val)
#define _EMIF_SDTIM2_FGET(Field)	  _PFIELD_GET(_EMIF_SDTIM2_ADDR, _EMIF_SDTIM2_##Field)
#define _EMIF_SDTIM2_FSET(Field,Val)	  _PFIELD_SET(_EMIF_SDTIM2_ADDR, _EMIF_SDTIM2_##Field, Val)
#define _EMIF_SDTIM2_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_SDTIM2_ADDR,AND,OR,INV)
#define _EMIF_SDTIM2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_SDTIM2_ADDR, _EMIF_SDTIM2_##Field,AND,OR,INV)

/*--------------------- Register: SDRFR1 -----------------------*/
#define _EMIF_SDRFR1_GET		  _PREG_GET(_EMIF_SDRFR1_ADDR) 
#define _EMIF_SDRFR1_SET(Val)		  _PREG_SET(_EMIF_SDRFR1_ADDR,Val)
#define _EMIF_SDRFR1_FGET(Field)	  _PFIELD_GET(_EMIF_SDRFR1_ADDR, _EMIF_SDRFR1_##Field)
#define _EMIF_SDRFR1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_SDRFR1_ADDR, _EMIF_SDRFR1_##Field, Val)
#define _EMIF_SDRFR1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_SDRFR1_ADDR,AND,OR,INV)
#define _EMIF_SDRFR1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_SDRFR1_ADDR, _EMIF_SDRFR1_##Field,AND,OR,INV)


/*--------------------- Register: SDRFR2 -----------------------*/
#define _EMIF_SDRFR2_GET		  _PREG_GET(_EMIF_SDRFR2_ADDR) 
#define _EMIF_SDRFR2_SET(Val)		  _PREG_SET(_EMIF_SDRFR2_ADDR,Val)
#define _EMIF_SDRFR2_FGET(Field)	  _PFIELD_GET(_EMIF_SDRFR2_ADDR, _EMIF_SDRFR2_##Field)
#define _EMIF_SDRFR2_FSET(Field,Val)	  _PFIELD_SET(_EMIF_SDRFR2_ADDR, _EMIF_SDRFR2_##Field, Val)
#define _EMIF_SDRFR2_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_SDRFR2_ADDR,AND,OR,INV)
#define _EMIF_SDRFR2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_SDRFR2_ADDR, _EMIF_SDRFR2_##Field,AND,OR,INV)

/*--------------------- Register: SDEXT1 -----------------------*/
#define _EMIF_SDEXT1_GET		  _PREG_GET(_EMIF_SDEXT1_ADDR) 
#define _EMIF_SDEXT1_SET(Val)		  _PREG_SET(_EMIF_SDEXT1_ADDR,Val)
#define _EMIF_SDEXT1_FGET(Field)	  _PFIELD_GET(_EMIF_SDEXT1_ADDR, _EMIF_SDEXT1_##Field)
#define _EMIF_SDEXT1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_SDEXT1_ADDR, _EMIF_SDEXT1_##Field, Val)
#define _EMIF_SDEXT1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_SDEXT1_ADDR,AND,OR,INV)
#define _EMIF_SDEXT1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_SDEXT1_ADDR, _EMIF_SDEXT1_##Field,AND,OR,INV)


/*--------------------- Register: SDEXT2 -----------------------*/
#define _EMIF_SDEXT2_GET		  _PREG_GET(_EMIF_SDEXT2_ADDR) 
#define _EMIF_SDEXT2_SET(Val)		  _PREG_SET(_EMIF_SDEXT2_ADDR,Val)
#define _EMIF_SDEXT2_FGET(Field)	  _PFIELD_GET(_EMIF_SDEXT2_ADDR, _EMIF_SDEXT2_##Field)
#define _EMIF_SDEXT2_FSET(Field,Val)	  _PFIELD_SET(_EMIF_SDEXT2_ADDR, _EMIF_SDEXT2_##Field, Val)
#define _EMIF_SDEXT2_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_SDEXT2_ADDR,AND,OR,INV)
#define _EMIF_SDEXT2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_SDEXT2_ADDR, _EMIF_SDEXT2_##Field,AND,OR,INV)


/*--------------------- Register: CE1SEC1 -----------------------*/
#define _EMIF_CE1SEC1_GET		  _PREG_GET(_EMIF_CE1SEC1_ADDR) 
#define _EMIF_CE1SEC1_SET(Val)		  _PREG_SET(_EMIF_CE1SEC1_ADDR,Val)
#define _EMIF_CE1SEC1_FGET(Field)	  _PFIELD_GET(_EMIF_CE1SEC1_ADDR, _EMIF_CE1SEC1_##Field)
#define _EMIF_CE1SEC1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE1SEC1_ADDR, _EMIF_CE1SEC1_##Field, Val)
#define _EMIF_CE1SEC1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE1SEC1_ADDR,AND,OR,INV)
#define _EMIF_CE1SEC1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE1SEC1_ADDR, _EMIF_CE1SEC1_##Field,AND,OR,INV)


/*--------------------- Register: CE0SEC1 -----------------------*/
#define _EMIF_CE0SEC1_GET		  _PREG_GET(_EMIF_CE0SEC1_ADDR) 
#define _EMIF_CE0SEC1_SET(Val)		  _PREG_SET(_EMIF_CE0SEC1_ADDR,Val)
#define _EMIF_CE0SEC1_FGET(Field)	  _PFIELD_GET(_EMIF_CE0SEC1_ADDR, _EMIF_CE0SEC1_##Field)
#define _EMIF_CE0SEC1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE0SEC1_ADDR, _EMIF_CE0SEC1_##Field, Val)
#define _EMIF_CE0SEC1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE0SEC1_ADDR,AND,OR,INV)
#define _EMIF_CE0SEC1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE0SEC1_ADDR, _EMIF_CE0SEC1_##Field,AND,OR,INV)


/*--------------------- Register: CE2SEC1 -----------------------*/
#define _EMIF_CE2SEC1_GET		  _PREG_GET(_EMIF_CE2SEC1_ADDR) 
#define _EMIF_CE2SEC1_SET(Val)		  _PREG_SET(_EMIF_CE2SEC1_ADDR,Val)
#define _EMIF_CE2SEC1_FGET(Field)	  _PFIELD_GET(_EMIF_CE2SEC1_ADDR, _EMIF_CE2SEC1_##Field)
#define _EMIF_CE2SEC1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE2SEC1_ADDR, _EMIF_CE2SEC1_##Field, Val)
#define _EMIF_CE2SEC1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE2SEC1_ADDR,AND,OR,INV)
#define _EMIF_CE2SEC1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE2SEC1_ADDR, _EMIF_CE2SEC1_##Field,AND,OR,INV)


/*--------------------- Register: CE3SEC1 -----------------------*/
#define _EMIF_CE3SEC1_GET		  _PREG_GET(_EMIF_CE3SEC1_ADDR) 
#define _EMIF_CE3SEC1_SET(Val)		  _PREG_SET(_EMIF_CE3SEC1_ADDR,Val)
#define _EMIF_CE3SEC1_FGET(Field)	  _PFIELD_GET(_EMIF_CE3SEC1_ADDR, _EMIF_CE3SEC1_##Field)
#define _EMIF_CE3SEC1_FSET(Field,Val)	  _PFIELD_SET(_EMIF_CE3SEC1_ADDR, _EMIF_CE3SEC1_##Field, Val)
#define _EMIF_CE3SEC1_AOI(AND,OR,INV)	  _PREG_AOI(_EMIF_CE3SEC1_ADDR,AND,OR,INV)
#define _EMIF_CE3SEC1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_EMIF_CE3SEC1_ADDR, _EMIF_CE3SEC1_##Field,AND,OR,INV)



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE3CTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE3CTL1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE3CTL1_READ_HOLD	
*	(RW)   _EMIF_CE3CTL1_WRITE_HOLD_MSB	/ _EMIF_CE3CTL1_WRITE_HOLD Added 26 Mar 2003
*	(RW)   _EMIF_CE3CTL1_MTYPE	
*	(RW)   _EMIF_CE3CTL1_READ_STROBE	
*	(RW)   _EMIF_CE3CTL1_TA	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3CTL1_READ_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3CTL1_READ_HOLD_SHIFT		(000000u)
#define _EMIF_CE3CTL1_READ_HOLD_MK(n)		(((Uint16)(n) & 0x0007u) << _EMIF_CE3CTL1_READ_HOLD_SHIFT)
#define _EMIF_CE3CTL1_READ_HOLD_MASK		(_EMIF_CE3CTL1_READ_HOLD_MK(0x0007u))
#define _EMIF_CE3CTL1_READ_HOLD_CLR		      (~(_EMIF_CE3CTL1_READ_HOLD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3CTL1_WRITE_HOLD_MSB:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3CTL1_WRITE_HOLD_MSB_SHIFT      (0x0003u)
#define _EMIF_CE3CTL1_WRITE_HOLD_MSB_MK(n)	(((Uint16)(n) & 0x0001u) << _EMIF_CE3CTL1_WRITE_HOLD_MSB_SHIFT)
#define _EMIF_CE3CTL1_WRITE_HOLD_MSB_MASK		(_EMIF_CE3CTL1_WRITE_HOLD_MSB_MK(0x0001u))
#define _EMIF_CE3CTL1_WRITE_HOLD_MSB_CLR		(~(_EMIF_CE3CTL1_WRITE_HOLD_MSB_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3CTL1_WRITE_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3CTL1_WRITE_HOLD_SHIFT		(0x0003u)
#define _EMIF_CE3CTL1_WRITE_HOLD_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE3CTL1_WRITE_HOLD_SHIFT)
#define _EMIF_CE3CTL1_WRITE_HOLD_MASK		(_EMIF_CE3CTL1_WRITE_HOLD_MK(0x0001u))
#define _EMIF_CE3CTL1_WRITE_HOLD_CLR		(~(_EMIF_CE3CTL1_WRITE_HOLD_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3CTL1_MTYPE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3CTL1_MTYPE_SHIFT		(0x0004u)
#define _EMIF_CE3CTL1_MTYPE_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE3CTL1_MTYPE_SHIFT)
#define _EMIF_CE3CTL1_MTYPE_MASK		(_EMIF_CE3CTL1_MTYPE_MK(0x000fu))
#define _EMIF_CE3CTL1_MTYPE_CLR		(~(_EMIF_CE3CTL1_MTYPE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3CTL1_READ_STROBE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3CTL1_READ_STROBE_SHIFT		(0x0008u)
#define _EMIF_CE3CTL1_READ_STROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE3CTL1_READ_STROBE_SHIFT)
#define _EMIF_CE3CTL1_READ_STROBE_MASK		(_EMIF_CE3CTL1_READ_STROBE_MK(0x003fu))
#define _EMIF_CE3CTL1_READ_STROBE_CLR		(~(_EMIF_CE3CTL1_READ_STROBE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3CTL1_TA:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3CTL1_TA_SHIFT		(0x000eu)
#define _EMIF_CE3CTL1_TA_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE3CTL1_TA_SHIFT)
#define _EMIF_CE3CTL1_TA_MASK		(_EMIF_CE3CTL1_TA_MK(0x0003u))
#define _EMIF_CE3CTL1_TA_CLR		(~(_EMIF_CE3CTL1_TA_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE3SEC1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE3SEC1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE3SEC1_SYNCRL	
*	(RW)   _EMIF_CE3SEC1_SYNCWL	
*	(RW)   _EMIF_CE3SEC1_CEEXT	
*	(RW)   _EMIF_CE3SEC1_REN    / _EMIF_CE3SEC1_RENEN	Added 26 Mar 2003
*	(RW)   _EMIF_CE3SEC1_SNCCLK	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3SEC1_SYNCRL:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3SEC1_SYNCRL_SHIFT		(000000u)
#define _EMIF_CE3SEC1_SYNCRL_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE3SEC1_SYNCRL_SHIFT)
#define _EMIF_CE3SEC1_SYNCRL_MASK		(_EMIF_CE3SEC1_SYNCRL_MK(0x0003u))
#define _EMIF_CE3SEC1_SYNCRL_CLR		(~(_EMIF_CE3SEC1_SYNCRL_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3SEC1_SYNCWL:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3SEC1_SYNCWL_SHIFT		(0x0002u)
#define _EMIF_CE3SEC1_SYNCWL_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE3SEC1_SYNCWL_SHIFT)
#define _EMIF_CE3SEC1_SYNCWL_MASK		(_EMIF_CE3SEC1_SYNCWL_MK(0x0003u))
#define _EMIF_CE3SEC1_SYNCWL_CLR		(~(_EMIF_CE3SEC1_SYNCWL_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3SEC1_CEEXT:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3SEC1_CEEXT_SHIFT		(0x0004u)
#define _EMIF_CE3SEC1_CEEXT_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE3SEC1_CEEXT_SHIFT)
#define _EMIF_CE3SEC1_CEEXT_MASK		(_EMIF_CE3SEC1_CEEXT_MK(0x0001u))
#define _EMIF_CE3SEC1_CEEXT_CLR		(~(_EMIF_CE3SEC1_CEEXT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3SEC1_REN:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3SEC1_REN_SHIFT		(0x0005u)
#define _EMIF_CE3SEC1_REN_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE3SEC1_REN_SHIFT)
#define _EMIF_CE3SEC1_REN_MASK		(_EMIF_CE3SEC1_REN_MK(0x0001u))
#define _EMIF_CE3SEC1_REN_CLR		(~(_EMIF_CE3SEC1_REN_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3SEC1_RENEN:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3SEC1_RENEN_SHIFT		(0x0005u)
#define _EMIF_CE3SEC1_RENEN_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE3SEC1_RENEN_SHIFT)
#define _EMIF_CE3SEC1_RENEN_MASK		(_EMIF_CE3SEC1_RENEN_MK(0x0001u))
#define _EMIF_CE3SEC1_RENEN_CLR		(~(_EMIF_CE3SEC1_RENEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3SEC1_SNCCLK:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3SEC1_SNCCLK_SHIFT		(0x0006u)
#define _EMIF_CE3SEC1_SNCCLK_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE3SEC1_SNCCLK_SHIFT)
#define _EMIF_CE3SEC1_SNCCLK_MASK		(_EMIF_CE3SEC1_SNCCLK_MK(0x0001u))
#define _EMIF_CE3SEC1_SNCCLK_CLR		(~(_EMIF_CE3SEC1_SNCCLK_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE3CTL2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE3CTL2	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE3CTL2_READ_SETUP	
*	(RW)   _EMIF_CE3CTL2_WRITE_HOLD	
*	(RW)   _EMIF_CE3CTL2_WRITE_STROBE	
*	(RW)   _EMIF_CE3CTL2_WRITE_SETUP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3CTL2_READ_SETUP:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3CTL2_READ_SETUP_SHIFT		(000000u)
#define _EMIF_CE3CTL2_READ_SETUP_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE3CTL2_READ_SETUP_SHIFT)
#define _EMIF_CE3CTL2_READ_SETUP_MASK		(_EMIF_CE3CTL2_READ_SETUP_MK(0x000fu))
#define _EMIF_CE3CTL2_READ_SETUP_CLR		(~(_EMIF_CE3CTL2_READ_SETUP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3CTL2_WRITE_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3CTL2_WRITE_HOLD_SHIFT		(0x0004u)
#define _EMIF_CE3CTL2_WRITE_HOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE3CTL2_WRITE_HOLD_SHIFT)
#define _EMIF_CE3CTL2_WRITE_HOLD_MASK		(_EMIF_CE3CTL2_WRITE_HOLD_MK(0x0003u))
#define _EMIF_CE3CTL2_WRITE_HOLD_CLR		(~(_EMIF_CE3CTL2_WRITE_HOLD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3CTL2_WRITE_STROBE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3CTL2_WRITE_STROBE_SHIFT		(0x0006u)
#define _EMIF_CE3CTL2_WRITE_STROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE3CTL2_WRITE_STROBE_SHIFT)
#define _EMIF_CE3CTL2_WRITE_STROBE_MASK		(_EMIF_CE3CTL2_WRITE_STROBE_MK(0x003fu))
#define _EMIF_CE3CTL2_WRITE_STROBE_CLR		(~(_EMIF_CE3CTL2_WRITE_STROBE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE3CTL2_WRITE_SETUP:	
\*----------------------------------------------------------------*/

#define _EMIF_CE3CTL2_WRITE_SETUP_SHIFT		(0x000cu)
#define _EMIF_CE3CTL2_WRITE_SETUP_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE3CTL2_WRITE_SETUP_SHIFT)
#define _EMIF_CE3CTL2_WRITE_SETUP_MASK		(_EMIF_CE3CTL2_WRITE_SETUP_MK(0x000fu))
#define _EMIF_CE3CTL2_WRITE_SETUP_CLR		(~(_EMIF_CE3CTL2_WRITE_SETUP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE0CTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE0CTL1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE0CTL1_READ_HOLD	
*	(RW)   _EMIF_CE0CTL1_WRITE_HOLD_MSB	/_EMIF_CE0CTL1_WRITE_HOLD
*	(RW)   _EMIF_CE0CTL1_MTYPE	
*	(RW)   _EMIF_CE0CTL1_READ_STROBE	
*	(RW)   _EMIF_CE0CTL1_TA	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0CTL1_READ_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0CTL1_READ_HOLD_SHIFT		(000000u)
#define _EMIF_CE0CTL1_READ_HOLD_MK(n)		(((Uint16)(n) & 0x0007u) << _EMIF_CE0CTL1_READ_HOLD_SHIFT)
#define _EMIF_CE0CTL1_READ_HOLD_MASK		(_EMIF_CE0CTL1_READ_HOLD_MK(0x0007u))
#define _EMIF_CE0CTL1_READ_HOLD_CLR		(~(_EMIF_CE0CTL1_READ_HOLD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0CTL1_WRITE_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0CTL1_WRITE_HOLD_SHIFT		(0x0003u)
#define _EMIF_CE0CTL1_WRITE_HOLD_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE0CTL1_WRITE_HOLD_SHIFT)
#define _EMIF_CE0CTL1_WRITE_HOLD_MASK		(_EMIF_CE0CTL1_WRITE_HOLD_MK(0x0001u))
#define _EMIF_CE0CTL1_WRITE_HOLD_CLR		(~(_EMIF_CE0CTL1_WRITE_HOLD_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0CTL1_WRITE_HOLD_MSB:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0CTL1_WRITE_HOLD_MSB_SHIFT		(0x0003u)
#define _EMIF_CE0CTL1_WRITE_HOLD_MSB_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE0CTL1_WRITE_HOLD_MSB_SHIFT)
#define _EMIF_CE0CTL1_WRITE_HOLD_MSB_MASK		(_EMIF_CE0CTL1_WRITE_HOLD_MSB_MK(0x0001u))
#define _EMIF_CE0CTL1_WRITE_HOLD_MSB_CLR		(~(_EMIF_CE0CTL1_WRITE_HOLD_MSB_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0CTL1_MTYPE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0CTL1_MTYPE_SHIFT		(0x0004u)
#define _EMIF_CE0CTL1_MTYPE_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE0CTL1_MTYPE_SHIFT)
#define _EMIF_CE0CTL1_MTYPE_MASK		(_EMIF_CE0CTL1_MTYPE_MK(0x000fu))
#define _EMIF_CE0CTL1_MTYPE_CLR		(~(_EMIF_CE0CTL1_MTYPE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0CTL1_READ_STROBE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0CTL1_READ_STROBE_SHIFT		(0x0008u)
#define _EMIF_CE0CTL1_READ_STROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE0CTL1_READ_STROBE_SHIFT)
#define _EMIF_CE0CTL1_READ_STROBE_MASK		(_EMIF_CE0CTL1_READ_STROBE_MK(0x003fu))
#define _EMIF_CE0CTL1_READ_STROBE_CLR		(~(_EMIF_CE0CTL1_READ_STROBE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0CTL1_TA:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0CTL1_TA_SHIFT		(0x000eu)
#define _EMIF_CE0CTL1_TA_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE0CTL1_TA_SHIFT)
#define _EMIF_CE0CTL1_TA_MASK		(_EMIF_CE0CTL1_TA_MK(0x0003u))
#define _EMIF_CE0CTL1_TA_CLR		(~(_EMIF_CE0CTL1_TA_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE0SEC1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE0SEC1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE0SEC1_SYNCRL	
*	(RW)   _EMIF_CE0SEC1_SYNCWL	
*	(RW)   _EMIF_CE0SEC1_CEEXT	
*	(RW)   _EMIF_CE0SEC1_REN	/ _EMIF_CE0SEC1_RENEN Added 26 Mar 2003
*	(RW)   _EMIF_CE0SEC1_SNCCLK	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0SEC1_SYNCRL:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0SEC1_SYNCRL_SHIFT		(000000u)
#define _EMIF_CE0SEC1_SYNCRL_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE0SEC1_SYNCRL_SHIFT)
#define _EMIF_CE0SEC1_SYNCRL_MASK		(_EMIF_CE0SEC1_SYNCRL_MK(0x0003u))
#define _EMIF_CE0SEC1_SYNCRL_CLR		(~(_EMIF_CE0SEC1_SYNCRL_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0SEC1_SYNCWL:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0SEC1_SYNCWL_SHIFT		(0x0002u)
#define _EMIF_CE0SEC1_SYNCWL_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE0SEC1_SYNCWL_SHIFT)
#define _EMIF_CE0SEC1_SYNCWL_MASK		(_EMIF_CE0SEC1_SYNCWL_MK(0x0003u))
#define _EMIF_CE0SEC1_SYNCWL_CLR		(~(_EMIF_CE0SEC1_SYNCWL_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0SEC1_CEEXT:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0SEC1_CEEXT_SHIFT		(0x0004u)
#define _EMIF_CE0SEC1_CEEXT_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE0SEC1_CEEXT_SHIFT)
#define _EMIF_CE0SEC1_CEEXT_MASK		(_EMIF_CE0SEC1_CEEXT_MK(0x0001u))
#define _EMIF_CE0SEC1_CEEXT_CLR		(~(_EMIF_CE0SEC1_CEEXT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0SEC1_REN:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0SEC1_REN_SHIFT		(0x0005u)
#define _EMIF_CE0SEC1_REN_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE0SEC1_REN_SHIFT)
#define _EMIF_CE0SEC1_REN_MASK		(_EMIF_CE0SEC1_REN_MK(0x0001u))
#define _EMIF_CE0SEC1_REN_CLR		(~(_EMIF_CE0SEC1_REN_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0SEC1_RENEN:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0SEC1_RENEN_SHIFT		(0x0005u)
#define _EMIF_CE0SEC1_RENEN_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE0SEC1_RENEN_SHIFT)
#define _EMIF_CE0SEC1_RENEN_MASK		(_EMIF_CE0SEC1_RENEN_MK(0x0001u))
#define _EMIF_CE0SEC1_RENEN_CLR		(~(_EMIF_CE0SEC1_RENEN_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0SEC1_SNCCLK:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0SEC1_SNCCLK_SHIFT		(0x0006u)
#define _EMIF_CE0SEC1_SNCCLK_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE0SEC1_SNCCLK_SHIFT)
#define _EMIF_CE0SEC1_SNCCLK_MASK		(_EMIF_CE0SEC1_SNCCLK_MK(0x0001u))
#define _EMIF_CE0SEC1_SNCCLK_CLR		(~(_EMIF_CE0SEC1_SNCCLK_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE0CTL2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE0CTL2	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE0CTL2_READ_SETUP	
*	(RW)   _EMIF_CE0CTL2_WRITE_HOLD	
*	(RW)   _EMIF_CE0CTL2_WRITE_STROBE	
*	(RW)   _EMIF_CE0CTL2_WRITE_SETUP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0CTL2_READ_SETUP:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0CTL2_READ_SETUP_SHIFT		(000000u)
#define _EMIF_CE0CTL2_READ_SETUP_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE0CTL2_READ_SETUP_SHIFT)
#define _EMIF_CE0CTL2_READ_SETUP_MASK		(_EMIF_CE0CTL2_READ_SETUP_MK(0x000fu))
#define _EMIF_CE0CTL2_READ_SETUP_CLR		(~(_EMIF_CE0CTL2_READ_SETUP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0CTL2_WRITE_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0CTL2_WRITE_HOLD_SHIFT		(0x0004u)
#define _EMIF_CE0CTL2_WRITE_HOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE0CTL2_WRITE_HOLD_SHIFT)
#define _EMIF_CE0CTL2_WRITE_HOLD_MASK		(_EMIF_CE0CTL2_WRITE_HOLD_MK(0x0003u))
#define _EMIF_CE0CTL2_WRITE_HOLD_CLR		(~(_EMIF_CE0CTL2_WRITE_HOLD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0CTL2_WRITE_STROBE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0CTL2_WRITE_STROBE_SHIFT		(0x0006u)
#define _EMIF_CE0CTL2_WRITE_STROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE0CTL2_WRITE_STROBE_SHIFT)
#define _EMIF_CE0CTL2_WRITE_STROBE_MASK		(_EMIF_CE0CTL2_WRITE_STROBE_MK(0x003fu))
#define _EMIF_CE0CTL2_WRITE_STROBE_CLR		(~(_EMIF_CE0CTL2_WRITE_STROBE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE0CTL2_WRITE_SETUP:	
\*----------------------------------------------------------------*/

#define _EMIF_CE0CTL2_WRITE_SETUP_SHIFT		(0x000cu)
#define _EMIF_CE0CTL2_WRITE_SETUP_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE0CTL2_WRITE_SETUP_SHIFT)
#define _EMIF_CE0CTL2_WRITE_SETUP_MASK		(_EMIF_CE0CTL2_WRITE_SETUP_MK(0x000fu))
#define _EMIF_CE0CTL2_WRITE_SETUP_CLR		(~(_EMIF_CE0CTL2_WRITE_SETUP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the SDCTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_SDCTL1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_SDCTL1_SLFRFR	
*	(RW)   _EMIF_SDCTL1_TRC	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDCTL1_SLFRFR:	
\*----------------------------------------------------------------*/

#define _EMIF_SDCTL1_SLFRFR_SHIFT		(000000u)
#define _EMIF_SDCTL1_SLFRFR_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDCTL1_SLFRFR_SHIFT)
#define _EMIF_SDCTL1_SLFRFR_MASK		(_EMIF_SDCTL1_SLFRFR_MK(0x0001u))
#define _EMIF_SDCTL1_SLFRFR_CLR		(~(_EMIF_SDCTL1_SLFRFR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDCTL1_TRC:	
\*----------------------------------------------------------------*/

#define _EMIF_SDCTL1_TRC_SHIFT		(0x000cu)
#define _EMIF_SDCTL1_TRC_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_SDCTL1_TRC_SHIFT)
#define _EMIF_SDCTL1_TRC_MASK		(_EMIF_SDCTL1_TRC_MK(0x000fu))
#define _EMIF_SDCTL1_TRC_CLR		(~(_EMIF_SDCTL1_TRC_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the SDCTL2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_SDCTL2	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_SDCTL2_TRP	
*	(RW)   _EMIF_SDCTL2_TRCD	
*	(RW)   _EMIF_SDCTL2_INIT	
*	(RW)   _EMIF_SDCTL2_RFEN	
*	(RW)   _EMIF_SDCTL2_SDWTH	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDCTL2_TRP:	
\*----------------------------------------------------------------*/

#define _EMIF_SDCTL2_TRP_SHIFT		(000000u)
#define _EMIF_SDCTL2_TRP_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_SDCTL2_TRP_SHIFT)
#define _EMIF_SDCTL2_TRP_MASK		(_EMIF_SDCTL2_TRP_MK(0x000fu))
#define _EMIF_SDCTL2_TRP_CLR		(~(_EMIF_SDCTL2_TRP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDCTL2_TRCD:	
\*----------------------------------------------------------------*/

#define _EMIF_SDCTL2_TRCD_SHIFT		(0x0004u)
#define _EMIF_SDCTL2_TRCD_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_SDCTL2_TRCD_SHIFT)
#define _EMIF_SDCTL2_TRCD_MASK		(_EMIF_SDCTL2_TRCD_MK(0x000fu))
#define _EMIF_SDCTL2_TRCD_CLR		(~(_EMIF_SDCTL2_TRCD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDCTL2_INIT:	
\*----------------------------------------------------------------*/

#define _EMIF_SDCTL2_INIT_SHIFT		(0x0008u)
#define _EMIF_SDCTL2_INIT_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDCTL2_INIT_SHIFT)
#define _EMIF_SDCTL2_INIT_MASK		(_EMIF_SDCTL2_INIT_MK(0x0001u))
#define _EMIF_SDCTL2_INIT_CLR		(~(_EMIF_SDCTL2_INIT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDCTL2_RFEN:	
\*----------------------------------------------------------------*/

#define _EMIF_SDCTL2_RFEN_SHIFT		(0x0009u)
#define _EMIF_SDCTL2_RFEN_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDCTL2_RFEN_SHIFT)
#define _EMIF_SDCTL2_RFEN_MASK		(_EMIF_SDCTL2_RFEN_MK(0x0001u))
#define _EMIF_SDCTL2_RFEN_CLR		(~(_EMIF_SDCTL2_RFEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDCTL2_SDWTH:	
\*----------------------------------------------------------------*/

#define _EMIF_SDCTL2_SDWTH_SHIFT		(0x000au)
#define _EMIF_SDCTL2_SDWTH_MK(n)		(((Uint16)(n) & 0x001fu) << _EMIF_SDCTL2_SDWTH_SHIFT)
#define _EMIF_SDCTL2_SDWTH_MASK		(_EMIF_SDCTL2_SDWTH_MK(0x001fu))
#define _EMIF_SDCTL2_SDWTH_CLR		(~(_EMIF_SDCTL2_SDWTH_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE1CTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE1CTL1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE1CTL1_READ_HOLD	
*	(RW)   _EMIF_CE1CTL1_WRITE_HOLD_MSB	/ _EMIF_CE1CTL1_WRITE_HOLD
*	(RW)   _EMIF_CE1CTL1_MTYPE	
*	(RW)   _EMIF_CE1CTL1_READ_STROBE	
*	(RW)   _EMIF_CE1CTL1_TA	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1CTL1_READ_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1CTL1_READ_HOLD_SHIFT		(000000u)
#define _EMIF_CE1CTL1_READ_HOLD_MK(n)		(((Uint16)(n) & 0x0007u) << _EMIF_CE1CTL1_READ_HOLD_SHIFT)
#define _EMIF_CE1CTL1_READ_HOLD_MASK		(_EMIF_CE1CTL1_READ_HOLD_MK(0x0007u))
#define _EMIF_CE1CTL1_READ_HOLD_CLR		(~(_EMIF_CE1CTL1_READ_HOLD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1CTL1_WRITE_HOLD_MSB:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1CTL1_WRITE_HOLD_MSB_SHIFT		(0x0003u)
#define _EMIF_CE1CTL1_WRITE_HOLD_MSB_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE1CTL1_WRITE_HOLD_MSB_SHIFT)
#define _EMIF_CE1CTL1_WRITE_HOLD_MSB_MASK		(_EMIF_CE1CTL1_WRITE_HOLD_MSB_MK(0x0001u))
#define _EMIF_CE1CTL1_WRITE_HOLD_MSB_CLR		(~(_EMIF_CE1CTL1_WRITE_HOLD_MSB_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1CTL1_WRITE_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1CTL1_WRITE_HOLD_SHIFT		(0x0003u)
#define _EMIF_CE1CTL1_WRITE_HOLD_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE1CTL1_WRITE_HOLD_SHIFT)
#define _EMIF_CE1CTL1_WRITE_HOLD_MASK		(_EMIF_CE1CTL1_WRITE_HOLD_MK(0x0001u))
#define _EMIF_CE1CTL1_WRITE_HOLD_CLR		(~(_EMIF_CE1CTL1_WRITE_HOLD_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1CTL1_MTYPE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1CTL1_MTYPE_SHIFT		(0x0004u)
#define _EMIF_CE1CTL1_MTYPE_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE1CTL1_MTYPE_SHIFT)
#define _EMIF_CE1CTL1_MTYPE_MASK		(_EMIF_CE1CTL1_MTYPE_MK(0x000fu))
#define _EMIF_CE1CTL1_MTYPE_CLR		(~(_EMIF_CE1CTL1_MTYPE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1CTL1_READ_STROBE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1CTL1_READ_STROBE_SHIFT		(0x0008u)
#define _EMIF_CE1CTL1_READ_STROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE1CTL1_READ_STROBE_SHIFT)
#define _EMIF_CE1CTL1_READ_STROBE_MASK		(_EMIF_CE1CTL1_READ_STROBE_MK(0x003fu))
#define _EMIF_CE1CTL1_READ_STROBE_CLR		(~(_EMIF_CE1CTL1_READ_STROBE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1CTL1_TA:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1CTL1_TA_SHIFT		(0x000eu)
#define _EMIF_CE1CTL1_TA_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE1CTL1_TA_SHIFT)
#define _EMIF_CE1CTL1_TA_MASK		(_EMIF_CE1CTL1_TA_MK(0x0003u))
#define _EMIF_CE1CTL1_TA_CLR		(~(_EMIF_CE1CTL1_TA_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE1SEC1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE1SEC1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE1SEC1_SYNCRL	
*	(RW)   _EMIF_CE1SEC1_SYNCWL	
*	(RW)   _EMIF_CE1SEC1_CEEXT	
*	(RW)   _EMIF_CE1SEC1_REN   / _EMIF_CE1SEC1_RENEN   Added 26 Mar 2003	
*	(RW)   _EMIF_CE1SEC1_SNCCLK
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1SEC1_SYNCRL:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1SEC1_SYNCRL_SHIFT		(000000u)
#define _EMIF_CE1SEC1_SYNCRL_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE1SEC1_SYNCRL_SHIFT)
#define _EMIF_CE1SEC1_SYNCRL_MASK		(_EMIF_CE1SEC1_SYNCRL_MK(0x0003u))
#define _EMIF_CE1SEC1_SYNCRL_CLR		(~(_EMIF_CE1SEC1_SYNCRL_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1SEC1_SYNCWL:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1SEC1_SYNCWL_SHIFT		(0x0002u)
#define _EMIF_CE1SEC1_SYNCWL_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE1SEC1_SYNCWL_SHIFT)
#define _EMIF_CE1SEC1_SYNCWL_MASK		(_EMIF_CE1SEC1_SYNCWL_MK(0x0003u))
#define _EMIF_CE1SEC1_SYNCWL_CLR		(~(_EMIF_CE1SEC1_SYNCWL_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1SEC1_CEEXT:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1SEC1_CEEXT_SHIFT		(0x0004u)
#define _EMIF_CE1SEC1_CEEXT_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE1SEC1_CEEXT_SHIFT)
#define _EMIF_CE1SEC1_CEEXT_MASK		(_EMIF_CE1SEC1_CEEXT_MK(0x0001u))
#define _EMIF_CE1SEC1_CEEXT_CLR		(~(_EMIF_CE1SEC1_CEEXT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1SEC1_REN:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1SEC1_REN_SHIFT		(0x0005u)
#define _EMIF_CE1SEC1_REN_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE1SEC1_REN_SHIFT)
#define _EMIF_CE1SEC1_REN_MASK		(_EMIF_CE1SEC1_REN_MK(0x0001u))
#define _EMIF_CE1SEC1_REN_CLR		(~(_EMIF_CE1SEC1_REN_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1SEC1_RENEN:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1SEC1_RENEN_SHIFT		(0x0005u)
#define _EMIF_CE1SEC1_RENEN_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE1SEC1_RENEN_SHIFT)
#define _EMIF_CE1SEC1_RENEN_MASK		(_EMIF_CE1SEC1_RENEN_MK(0x0001u))
#define _EMIF_CE1SEC1_RENEN_CLR		(~(_EMIF_CE1SEC1_RENEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1SEC1_SNCCLK:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1SEC1_SNCCLK_SHIFT		(0x0006u)
#define _EMIF_CE1SEC1_SNCCLK_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE1SEC1_SNCCLK_SHIFT)
#define _EMIF_CE1SEC1_SNCCLK_MASK		(_EMIF_CE1SEC1_SNCCLK_MK(0x0001u))
#define _EMIF_CE1SEC1_SNCCLK_CLR		(~(_EMIF_CE1SEC1_SNCCLK_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the SDEXT1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_SDEXT1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_SDEXT1_TCL	
*	(RW)   _EMIF_SDEXT1_TRAS	
*	(RW)   _EMIF_SDEXT1_TRRD	
*	(RW)   _EMIF_SDEXT1_TWR	
*	(RW)   _EMIF_SDEXT1_THZP	
*	(RW)   _EMIF_SDEXT1_RD2RD	
*	(RW)   _EMIF_SDEXT1_RD2DEAC	
*	(RW)   _EMIF_SDEXT1_RD2WR	
*	(RW)   _EMIF_SDEXT1_R2WDQM	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT1_TCL:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT1_TCL_SHIFT		(000000u)
#define _EMIF_SDEXT1_TCL_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDEXT1_TCL_SHIFT)
#define _EMIF_SDEXT1_TCL_MASK		(_EMIF_SDEXT1_TCL_MK(0x0001u))
#define _EMIF_SDEXT1_TCL_CLR		(~(_EMIF_SDEXT1_TCL_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT1_TRAS:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT1_TRAS_SHIFT		(0x0001u)
#define _EMIF_SDEXT1_TRAS_MK(n)		(((Uint16)(n) & 0x0007u) << _EMIF_SDEXT1_TRAS_SHIFT)
#define _EMIF_SDEXT1_TRAS_MASK		(_EMIF_SDEXT1_TRAS_MK(0x0007u))
#define _EMIF_SDEXT1_TRAS_CLR		(~(_EMIF_SDEXT1_TRAS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT1_TRRD:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT1_TRRD_SHIFT		(0x0004u)
#define _EMIF_SDEXT1_TRRD_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDEXT1_TRRD_SHIFT)
#define _EMIF_SDEXT1_TRRD_MASK		(_EMIF_SDEXT1_TRRD_MK(0x0001u))
#define _EMIF_SDEXT1_TRRD_CLR		(~(_EMIF_SDEXT1_TRRD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT1_TWR:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT1_TWR_SHIFT		(0x0005u)
#define _EMIF_SDEXT1_TWR_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_SDEXT1_TWR_SHIFT)
#define _EMIF_SDEXT1_TWR_MASK		(_EMIF_SDEXT1_TWR_MK(0x0003u))
#define _EMIF_SDEXT1_TWR_CLR		(~(_EMIF_SDEXT1_TWR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT1_THZP:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT1_THZP_SHIFT		(0x0007u)
#define _EMIF_SDEXT1_THZP_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_SDEXT1_THZP_SHIFT)
#define _EMIF_SDEXT1_THZP_MASK		(_EMIF_SDEXT1_THZP_MK(0x0003u))
#define _EMIF_SDEXT1_THZP_CLR		(~(_EMIF_SDEXT1_THZP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT1_RD2RD:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT1_RD2RD_SHIFT		(0x0009u)
#define _EMIF_SDEXT1_RD2RD_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDEXT1_RD2RD_SHIFT)
#define _EMIF_SDEXT1_RD2RD_MASK		(_EMIF_SDEXT1_RD2RD_MK(0x0001u))
#define _EMIF_SDEXT1_RD2RD_CLR		(~(_EMIF_SDEXT1_RD2RD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT1_RD2DEAC:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT1_RD2DEAC_SHIFT		(0x000au)
#define _EMIF_SDEXT1_RD2DEAC_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_SDEXT1_RD2DEAC_SHIFT)
#define _EMIF_SDEXT1_RD2DEAC_MASK		(_EMIF_SDEXT1_RD2DEAC_MK(0x0003u))
#define _EMIF_SDEXT1_RD2DEAC_CLR		(~(_EMIF_SDEXT1_RD2DEAC_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT1_RD2WR:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT1_RD2WR_SHIFT		(0x000cu)
#define _EMIF_SDEXT1_RD2WR_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_SDEXT1_RD2WR_SHIFT)
#define _EMIF_SDEXT1_RD2WR_MASK		(_EMIF_SDEXT1_RD2WR_MK(0x0003u))
#define _EMIF_SDEXT1_RD2WR_CLR		(~(_EMIF_SDEXT1_RD2WR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT1_R2WDQM:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT1_R2WDQM_SHIFT		(0x000fu)
#define _EMIF_SDEXT1_R2WDQM_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDEXT1_R2WDQM_SHIFT)
#define _EMIF_SDEXT1_R2WDQM_MASK		(_EMIF_SDEXT1_R2WDQM_MK(0x0001u))
#define _EMIF_SDEXT1_R2WDQM_CLR		(~(_EMIF_SDEXT1_R2WDQM_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE1CTL2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE1CTL2	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE1CTL2_READ_SETUP	
*	(RW)   _EMIF_CE1CTL2_WRITE_HOLD	
*	(RW)   _EMIF_CE1CTL2_WRITE_STROBE	
*	(RW)   _EMIF_CE1CTL2_WRITE_SETUP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1CTL2_READ_SETUP:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1CTL2_READ_SETUP_SHIFT		(000000u)
#define _EMIF_CE1CTL2_READ_SETUP_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE1CTL2_READ_SETUP_SHIFT)
#define _EMIF_CE1CTL2_READ_SETUP_MASK		(_EMIF_CE1CTL2_READ_SETUP_MK(0x000fu))
#define _EMIF_CE1CTL2_READ_SETUP_CLR		(~(_EMIF_CE1CTL2_READ_SETUP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1CTL2_WRITE_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1CTL2_WRITE_HOLD_SHIFT		(0x0004u)
#define _EMIF_CE1CTL2_WRITE_HOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE1CTL2_WRITE_HOLD_SHIFT)
#define _EMIF_CE1CTL2_WRITE_HOLD_MASK		(_EMIF_CE1CTL2_WRITE_HOLD_MK(0x0003u))
#define _EMIF_CE1CTL2_WRITE_HOLD_CLR		(~(_EMIF_CE1CTL2_WRITE_HOLD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1CTL2_WRITE_STROBE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1CTL2_WRITE_STROBE_SHIFT		(0x0006u)
#define _EMIF_CE1CTL2_WRITE_STROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE1CTL2_WRITE_STROBE_SHIFT)
#define _EMIF_CE1CTL2_WRITE_STROBE_MASK		(_EMIF_CE1CTL2_WRITE_STROBE_MK(0x003fu))
#define _EMIF_CE1CTL2_WRITE_STROBE_CLR		(~(_EMIF_CE1CTL2_WRITE_STROBE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE1CTL2_WRITE_SETUP:	
\*----------------------------------------------------------------*/

#define _EMIF_CE1CTL2_WRITE_SETUP_SHIFT		(0x000cu)
#define _EMIF_CE1CTL2_WRITE_SETUP_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE1CTL2_WRITE_SETUP_SHIFT)
#define _EMIF_CE1CTL2_WRITE_SETUP_MASK		(_EMIF_CE1CTL2_WRITE_SETUP_MK(0x000fu))
#define _EMIF_CE1CTL2_WRITE_SETUP_CLR		(~(_EMIF_CE1CTL2_WRITE_SETUP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the SDEXT2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_SDEXT2	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_SDEXT2_R2WDQM	
*	(RW)   _EMIF_SDEXT2_WR2WR	
*	(RW)   _EMIF_SDEXT2_WR2DEAC	
*	(RW)   _EMIF_SDEXT2_WR2RD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT2_R2WDQM:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT2_R2WDQM_SHIFT		(000000u)
#define _EMIF_SDEXT2_R2WDQM_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDEXT2_R2WDQM_SHIFT)
#define _EMIF_SDEXT2_R2WDQM_MASK		(_EMIF_SDEXT2_R2WDQM_MK(0x0001u))
#define _EMIF_SDEXT2_R2WDQM_CLR		(~(_EMIF_SDEXT2_R2WDQM_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT2_WR2WR:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT2_WR2WR_SHIFT		(0x0001u)
#define _EMIF_SDEXT2_WR2WR_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_SDEXT2_WR2WR_SHIFT)
#define _EMIF_SDEXT2_WR2WR_MASK		(_EMIF_SDEXT2_WR2WR_MK(0x0003u))
#define _EMIF_SDEXT2_WR2WR_CLR		(~(_EMIF_SDEXT2_WR2WR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT2_WR2DEAC:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT2_WR2DEAC_SHIFT		(0x0002u)
#define _EMIF_SDEXT2_WR2DEAC_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_SDEXT2_WR2DEAC_SHIFT)
#define _EMIF_SDEXT2_WR2DEAC_MASK		(_EMIF_SDEXT2_WR2DEAC_MK(0x0003u))
#define _EMIF_SDEXT2_WR2DEAC_CLR		(~(_EMIF_SDEXT2_WR2DEAC_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDEXT2_WR2RD:	
\*----------------------------------------------------------------*/

#define _EMIF_SDEXT2_WR2RD_SHIFT		(0x0004u)
#define _EMIF_SDEXT2_WR2RD_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDEXT2_WR2RD_SHIFT)
#define _EMIF_SDEXT2_WR2RD_MASK		(_EMIF_SDEXT2_WR2RD_MK(0x0001u))
#define _EMIF_SDEXT2_WR2RD_CLR		(~(_EMIF_SDEXT2_WR2RD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the SDTIM1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_SDTIM1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_SDTIM1_PERIOD	
*	(R)   _EMIF_SDTIM1_COUNTER	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDTIM1_PERIOD:	
\*----------------------------------------------------------------*/

#define _EMIF_SDTIM1_PERIOD_SHIFT		(000000u)
#define _EMIF_SDTIM1_PERIOD_MK(n)		(((Uint16)(n) & 0x0fffu) << _EMIF_SDTIM1_PERIOD_SHIFT)
#define _EMIF_SDTIM1_PERIOD_MASK		(_EMIF_SDTIM1_PERIOD_MK(0x0fffu))
#define _EMIF_SDTIM1_PERIOD_CLR		(~(_EMIF_SDTIM1_PERIOD_MASK))



/*----------------------------------------------------------------*\
*   (R)  _EMIF_SDTIM1_COUNTER:	
\*----------------------------------------------------------------*/

#define _EMIF_SDTIM1_COUNTER_SHIFT		(0x000cu)
#define _EMIF_SDTIM1_COUNTER_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_SDTIM1_COUNTER_SHIFT)
#define _EMIF_SDTIM1_COUNTER_MASK		(_EMIF_SDTIM1_COUNTER_MK(0x000fu))
#define _EMIF_SDTIM1_COUNTER_CLR		(~(_EMIF_SDTIM1_COUNTER_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the SDRFR1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_SDRFR1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_SDRFR1_PERIOD	
*	(R)   _EMIF_SDRFR1_COUNTER	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDRFR1_PERIOD:	
\*----------------------------------------------------------------*/

#define _EMIF_SDRFR1_PERIOD_SHIFT		(000000u)
#define _EMIF_SDRFR1_PERIOD_MK(n)		(((Uint16)(n) & 0x0fffu) << _EMIF_SDRFR1_PERIOD_SHIFT)
#define _EMIF_SDRFR1_PERIOD_MASK		(_EMIF_SDRFR1_PERIOD_MK(0x0fffu))
#define _EMIF_SDRFR1_PERIOD_CLR		(~(_EMIF_SDRFR1_PERIOD_MASK))



/*----------------------------------------------------------------*\
*   (R)  _EMIF_SDRFR1_COUNTER:	
\*----------------------------------------------------------------*/

#define _EMIF_SDRFR1_COUNTER_SHIFT		(0x000cu)
#define _EMIF_SDRFR1_COUNTER_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_SDRFR1_COUNTER_SHIFT)
#define _EMIF_SDRFR1_COUNTER_MASK		(_EMIF_SDRFR1_COUNTER_MK(0x000fu))
#define _EMIF_SDRFR1_COUNTER_CLR		(~(_EMIF_SDRFR1_COUNTER_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GBLCTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_GBLCTL1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_GBLCTL1_EK1EN	
*	(RW)   _EMIF_GBLCTL1_EK1HZ	
*	(RW)   _EMIF_GBLCTL1_NOHOLD	
*	(R)   _EMIF_GBLCTL1_HOLDA	
*	(R)   _EMIF_GBLCTL1_HOLD	
*	(R)   _EMIF_GBLCTL1_ARDY	
*
\******************************************************************************/





/*----------------------------------------------------------------*\
*   (RW)  _EMIF_GBLCTL1_EK1EN:	
\*----------------------------------------------------------------*/

#define _EMIF_GBLCTL1_EK1EN_SHIFT		(0x0005u)
#define _EMIF_GBLCTL1_EK1EN_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_GBLCTL1_EK1EN_SHIFT)
#define _EMIF_GBLCTL1_EK1EN_MASK		(_EMIF_GBLCTL1_EK1EN_MK(0x0001u))
#define _EMIF_GBLCTL1_EK1EN_CLR		(~(_EMIF_GBLCTL1_EK1EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_GBLCTL1_EK1HZ:	
\*----------------------------------------------------------------*/

#define _EMIF_GBLCTL1_EK1HZ_SHIFT		(0x0006u)
#define _EMIF_GBLCTL1_EK1HZ_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_GBLCTL1_EK1HZ_SHIFT)
#define _EMIF_GBLCTL1_EK1HZ_MASK		(_EMIF_GBLCTL1_EK1HZ_MK(0x0001u))
#define _EMIF_GBLCTL1_EK1HZ_CLR		(~(_EMIF_GBLCTL1_EK1HZ_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_GBLCTL1_NOHOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_GBLCTL1_NOHOLD_SHIFT		(0x0007u)
#define _EMIF_GBLCTL1_NOHOLD_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_GBLCTL1_NOHOLD_SHIFT)
#define _EMIF_GBLCTL1_NOHOLD_MASK		(_EMIF_GBLCTL1_NOHOLD_MK(0x0001u))
#define _EMIF_GBLCTL1_NOHOLD_CLR		(~(_EMIF_GBLCTL1_NOHOLD_MASK))



/*----------------------------------------------------------------*\
*   (R)  _EMIF_GBLCTL1_HOLDA:	
\*----------------------------------------------------------------*/

#define _EMIF_GBLCTL1_HOLDA_SHIFT		(0x0008u)
#define _EMIF_GBLCTL1_HOLDA_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_GBLCTL1_HOLDA_SHIFT)
#define _EMIF_GBLCTL1_HOLDA_MASK		(_EMIF_GBLCTL1_HOLDA_MK(0x0001u))
#define _EMIF_GBLCTL1_HOLDA_CLR		(~(_EMIF_GBLCTL1_HOLDA_MASK))



/*----------------------------------------------------------------*\
*   (R)  _EMIF_GBLCTL1_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_GBLCTL1_HOLD_SHIFT		(0x0009u)
#define _EMIF_GBLCTL1_HOLD_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_GBLCTL1_HOLD_SHIFT)
#define _EMIF_GBLCTL1_HOLD_MASK		(_EMIF_GBLCTL1_HOLD_MK(0x0001u))
#define _EMIF_GBLCTL1_HOLD_CLR		(~(_EMIF_GBLCTL1_HOLD_MASK))



/*----------------------------------------------------------------*\
*   (R)  _EMIF_GBLCTL1_ARDY:	
\*----------------------------------------------------------------*/

#define _EMIF_GBLCTL1_ARDY_SHIFT		(0x000au)
#define _EMIF_GBLCTL1_ARDY_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_GBLCTL1_ARDY_SHIFT)
#define _EMIF_GBLCTL1_ARDY_MASK		(_EMIF_GBLCTL1_ARDY_MK(0x0001u))
#define _EMIF_GBLCTL1_ARDY_CLR		(~(_EMIF_GBLCTL1_ARDY_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the SDTIM2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_SDTIM2	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_SDTIM2_COUNTER	
*	(RW)   _EMIF_SDTIM2_EXTRA_REFRESHES	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDTIM2_COUNTER:	
\*----------------------------------------------------------------*/

#define _EMIF_SDTIM2_COUNTER_SHIFT		(000000u)
#define _EMIF_SDTIM2_COUNTER_MK(n)		(((Uint16)(n) & 0x00ffu) << _EMIF_SDTIM2_COUNTER_SHIFT)
#define _EMIF_SDTIM2_COUNTER_MASK		(_EMIF_SDTIM2_COUNTER_MK(0x00ffu))
#define _EMIF_SDTIM2_COUNTER_CLR		(~(_EMIF_SDTIM2_COUNTER_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDTIM2_EXTRA_REFRESHES:	
\*----------------------------------------------------------------*/

#define _EMIF_SDTIM2_EXTRA_REFRESHES_SHIFT		(0x0008u)
#define _EMIF_SDTIM2_EXTRA_REFRESHES_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_SDTIM2_EXTRA_REFRESHES_SHIFT)
#define _EMIF_SDTIM2_EXTRA_REFRESHES_MASK		(_EMIF_SDTIM2_EXTRA_REFRESHES_MK(0x0003u))
#define _EMIF_SDTIM2_EXTRA_REFRESHES_CLR		(~(_EMIF_SDTIM2_EXTRA_REFRESHES_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the SDRFR2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_SDRFR2	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_SDRFR2_COUNTER	
*	(RW)   _EMIF_SDRFR2_EXTRA_REFRESHES	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDRFR2_COUNTER:	
\*----------------------------------------------------------------*/

#define _EMIF_SDRFR2_COUNTER_SHIFT		(000000u)
#define _EMIF_SDRFR2_COUNTER_MK(n)		(((Uint16)(n) & 0x00ffu) << _EMIF_SDRFR2_COUNTER_SHIFT)
#define _EMIF_SDRFR2_COUNTER_MASK		(_EMIF_SDRFR2_COUNTER_MK(0x00ffu))
#define _EMIF_SDRFR2_COUNTER_CLR		(~(_EMIF_SDRFR2_COUNTER_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_SDRFR2_EXTRA_REFRESHES:	
\*----------------------------------------------------------------*/

#define _EMIF_SDRFR2_EXTRA_REFRESHES_SHIFT		(0x0008u)
#define _EMIF_SDRFR2_EXTRA_REFRESHES_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_SDRFR2_EXTRA_REFRESHES_SHIFT)
#define _EMIF_SDRFR2_EXTRA_REFRESHES_MASK		(_EMIF_SDRFR2_EXTRA_REFRESHES_MK(0x0003u))
#define _EMIF_SDRFR2_EXTRA_REFRESHES_CLR		(~(_EMIF_SDRFR2_EXTRA_REFRESHES_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GBLCTL2 register			
\*----------------------------------------------------------------*/


/******************************************************************************\
* 
* _EMIF_GBLCTL2	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_GBLCTL2_EK2EN	
*	(RW)   _EMIF_GBLCTL2_EK2HZ	
*	(RW)   _EMIF_GBLCTL2_EK2RATE	
*
\******************************************************************************/



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_GBLCTL2_EK2EN:	
\*----------------------------------------------------------------*/

#define _EMIF_GBLCTL2_EK2EN_SHIFT		(000000u)
#define _EMIF_GBLCTL2_EK2EN_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_GBLCTL2_EK2EN_SHIFT)
#define _EMIF_GBLCTL2_EK2EN_MASK		(_EMIF_GBLCTL2_EK2EN_MK(0x0001u))
#define _EMIF_GBLCTL2_EK2EN_CLR		(~(_EMIF_GBLCTL2_EK2EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_GBLCTL2_EK2HZ:	
\*----------------------------------------------------------------*/

#define _EMIF_GBLCTL2_EK2HZ_SHIFT		(0x0001u)
#define _EMIF_GBLCTL2_EK2HZ_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_GBLCTL2_EK2HZ_SHIFT)
#define _EMIF_GBLCTL2_EK2HZ_MASK		(_EMIF_GBLCTL2_EK2HZ_MK(0x0001u))
#define _EMIF_GBLCTL2_EK2HZ_CLR		(~(_EMIF_GBLCTL2_EK2HZ_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_GBLCTL2_EK2RATE:	
\*----------------------------------------------------------------*/

#define _EMIF_GBLCTL2_EK2RATE_SHIFT		(0x0002u)
#define _EMIF_GBLCTL2_EK2RATE_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_GBLCTL2_EK2RATE_SHIFT)
#define _EMIF_GBLCTL2_EK2RATE_MASK		(_EMIF_GBLCTL2_EK2RATE_MK(0x0003u))
#define _EMIF_GBLCTL2_EK2RATE_CLR		(~(_EMIF_GBLCTL2_EK2RATE_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE2CTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE2CTL1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE2CTL1_READ_HOLD	
*	(RW)   _EMIF_CE2CTL1_WRITE_HOLD_MSB	/ _EMIF_CE2CTL1_WRITE_HOLD
*	(RW)   _EMIF_CE2CTL1_MTYPE	
*	(RW)   _EMIF_CE2CTL1_READ_STROBE	
*	(RW)   _EMIF_CE2CTL1_TA	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2CTL1_READ_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2CTL1_READ_HOLD_SHIFT		(000000u)
#define _EMIF_CE2CTL1_READ_HOLD_MK(n)		(((Uint16)(n) & 0x0007u) << _EMIF_CE2CTL1_READ_HOLD_SHIFT)
#define _EMIF_CE2CTL1_READ_HOLD_MASK		(_EMIF_CE2CTL1_READ_HOLD_MK(0x0007u))
#define _EMIF_CE2CTL1_READ_HOLD_CLR		(~(_EMIF_CE2CTL1_READ_HOLD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2CTL1_WRITE_HOLD_MSB:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2CTL1_WRITE_HOLD_MSB_SHIFT		(0x0003u)
#define _EMIF_CE2CTL1_WRITE_HOLD_MSB_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE2CTL1_WRITE_HOLD_MSB_SHIFT)
#define _EMIF_CE2CTL1_WRITE_HOLD_MSB_MASK		(_EMIF_CE2CTL1_WRITE_HOLD_MSB_MK(0x0001u))
#define _EMIF_CE2CTL1_WRITE_HOLD_MSB_CLR		(~(_EMIF_CE2CTL1_WRITE_HOLD_MSB_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2CTL1_WRITE_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2CTL1_WRITE_HOLD_SHIFT		(0x0003u)
#define _EMIF_CE2CTL1_WRITE_HOLD_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE2CTL1_WRITE_HOLD_SHIFT)
#define _EMIF_CE2CTL1_WRITE_HOLD_MASK		(_EMIF_CE2CTL1_WRITE_HOLD_MK(0x0001u))
#define _EMIF_CE2CTL1_WRITE_HOLD_CLR		(~(_EMIF_CE2CTL1_WRITE_HOLD_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2CTL1_MTYPE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2CTL1_MTYPE_SHIFT		(0x0004u)
#define _EMIF_CE2CTL1_MTYPE_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE2CTL1_MTYPE_SHIFT)
#define _EMIF_CE2CTL1_MTYPE_MASK		(_EMIF_CE2CTL1_MTYPE_MK(0x000fu))
#define _EMIF_CE2CTL1_MTYPE_CLR		(~(_EMIF_CE2CTL1_MTYPE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2CTL1_READ_STROBE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2CTL1_READ_STROBE_SHIFT		(0x0008u)
#define _EMIF_CE2CTL1_READ_STROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE2CTL1_READ_STROBE_SHIFT)
#define _EMIF_CE2CTL1_READ_STROBE_MASK		(_EMIF_CE2CTL1_READ_STROBE_MK(0x003fu))
#define _EMIF_CE2CTL1_READ_STROBE_CLR		(~(_EMIF_CE2CTL1_READ_STROBE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2CTL1_TA:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2CTL1_TA_SHIFT		(0x000eu)
#define _EMIF_CE2CTL1_TA_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE2CTL1_TA_SHIFT)
#define _EMIF_CE2CTL1_TA_MASK		(_EMIF_CE2CTL1_TA_MK(0x0003u))
#define _EMIF_CE2CTL1_TA_CLR		(~(_EMIF_CE2CTL1_TA_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE2SEC1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE2SEC1	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE2SEC1_SYNCRL	
*	(RW)   _EMIF_CE2SEC1_SYNCWL	
*	(RW)   _EMIF_CE2SEC1_CEEXT	
*	(RW)   _EMIF_CE2SEC1_REN	/ _EMIF_CE2SEC1_RENEN  Added 26 Mar 2003
*	(RW)   _EMIF_CE2SEC1_SNCCLK	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2SEC1_SYNCRL:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2SEC1_SYNCRL_SHIFT		(000000u)
#define _EMIF_CE2SEC1_SYNCRL_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE2SEC1_SYNCRL_SHIFT)
#define _EMIF_CE2SEC1_SYNCRL_MASK		(_EMIF_CE2SEC1_SYNCRL_MK(0x0003u))
#define _EMIF_CE2SEC1_SYNCRL_CLR		(~(_EMIF_CE2SEC1_SYNCRL_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2SEC1_SYNCWL:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2SEC1_SYNCWL_SHIFT		(0x0002u)
#define _EMIF_CE2SEC1_SYNCWL_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE2SEC1_SYNCWL_SHIFT)
#define _EMIF_CE2SEC1_SYNCWL_MASK		(_EMIF_CE2SEC1_SYNCWL_MK(0x0003u))
#define _EMIF_CE2SEC1_SYNCWL_CLR		(~(_EMIF_CE2SEC1_SYNCWL_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2SEC1_CEEXT:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2SEC1_CEEXT_SHIFT		(0x0004u)
#define _EMIF_CE2SEC1_CEEXT_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE2SEC1_CEEXT_SHIFT)
#define _EMIF_CE2SEC1_CEEXT_MASK		(_EMIF_CE2SEC1_CEEXT_MK(0x0001u))
#define _EMIF_CE2SEC1_CEEXT_CLR		(~(_EMIF_CE2SEC1_CEEXT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2SEC1_REN:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2SEC1_REN_SHIFT		(0x0005u)
#define _EMIF_CE2SEC1_REN_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE2SEC1_REN_SHIFT)
#define _EMIF_CE2SEC1_REN_MASK		(_EMIF_CE2SEC1_REN_MK(0x0001u))
#define _EMIF_CE2SEC1_REN_CLR		(~(_EMIF_CE2SEC1_REN_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2SEC1_RENEN:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2SEC1_RENEN_SHIFT		(0x0005u)
#define _EMIF_CE2SEC1_RENEN_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE2SEC1_RENEN_SHIFT)
#define _EMIF_CE2SEC1_RENEN_MASK		(_EMIF_CE2SEC1_RENEN_MK(0x0001u))
#define _EMIF_CE2SEC1_RENEN_CLR		(~(_EMIF_CE2SEC1_RENEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2SEC1_SNCCLK:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2SEC1_SNCCLK_SHIFT		(0x0006u)
#define _EMIF_CE2SEC1_SNCCLK_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_CE2SEC1_SNCCLK_SHIFT)
#define _EMIF_CE2SEC1_SNCCLK_MASK		(_EMIF_CE2SEC1_SNCCLK_MK(0x0001u))
#define _EMIF_CE2SEC1_SNCCLK_CLR		(~(_EMIF_CE2SEC1_SNCCLK_MASK))

/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CE2CTL2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CE2CTL2	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CE2CTL2_READ_SETUP	
*	(RW)   _EMIF_CE2CTL2_WRITE_HOLD	
*	(RW)   _EMIF_CE2CTL2_WRITE_STROBE	
*	(RW)   _EMIF_CE2CTL2_WRITE_SETUP	
*
\******************************************************************************/


/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2CTL2_READ_SETUP:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2CTL2_READ_SETUP_SHIFT		(000000u)
#define _EMIF_CE2CTL2_READ_SETUP_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE2CTL2_READ_SETUP_SHIFT)
#define _EMIF_CE2CTL2_READ_SETUP_MASK		(_EMIF_CE2CTL2_READ_SETUP_MK(0x000fu))
#define _EMIF_CE2CTL2_READ_SETUP_CLR		(~(_EMIF_CE2CTL2_READ_SETUP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2CTL2_WRITE_HOLD:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2CTL2_WRITE_HOLD_SHIFT		(0x0004u)
#define _EMIF_CE2CTL2_WRITE_HOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE2CTL2_WRITE_HOLD_SHIFT)
#define _EMIF_CE2CTL2_WRITE_HOLD_MASK		(_EMIF_CE2CTL2_WRITE_HOLD_MK(0x0003u))
#define _EMIF_CE2CTL2_WRITE_HOLD_CLR		(~(_EMIF_CE2CTL2_WRITE_HOLD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2CTL2_WRITE_STROBE:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2CTL2_WRITE_STROBE_SHIFT		(0x0006u)
#define _EMIF_CE2CTL2_WRITE_STROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE2CTL2_WRITE_STROBE_SHIFT)
#define _EMIF_CE2CTL2_WRITE_STROBE_MASK		(_EMIF_CE2CTL2_WRITE_STROBE_MK(0x003fu))
#define _EMIF_CE2CTL2_WRITE_STROBE_CLR		(~(_EMIF_CE2CTL2_WRITE_STROBE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CE2CTL2_WRITE_SETUP:	
\*----------------------------------------------------------------*/

#define _EMIF_CE2CTL2_WRITE_SETUP_SHIFT		(0x000cu)
#define _EMIF_CE2CTL2_WRITE_SETUP_MK(n)		(((Uint16)(n) & 0x000fu) << _EMIF_CE2CTL2_WRITE_SETUP_SHIFT)
#define _EMIF_CE2CTL2_WRITE_SETUP_MASK		(_EMIF_CE2CTL2_WRITE_SETUP_MK(0x000fu))
#define _EMIF_CE2CTL2_WRITE_SETUP_CLR		(~(_EMIF_CE2CTL2_WRITE_SETUP_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the CESCR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _EMIF_CESCR	 - Note: Add description here
*
* Fields:
*	(RW)   _EMIF_CESCR_CES	
*
\******************************************************************************/

/*----------------------------------------------------------------*\
*   (RW)  _EMIF_CESCR_CES:	
\*----------------------------------------------------------------*/

#define _EMIF_CESCR_CES_SHIFT				(000000u)
#define _EMIF_CESCR_CES_MK(n)				(((Uint16)(n) & 0x0002u) << _EMIF_CESCR_CES_SHIFT)
#define _EMIF_CESCR_CES_MASK				(_EMIF_CESCR_CES_MK(0x0003u))
#define _EMIF_CESCR_CES_CLR				(~(_EMIF_CESCR_CES_MASK))


#elif (!(_EMIF_MOD))
	#error EMIF Hal Module Not Supported on Specified Target
#endif  /* _EMIF_SUPPORT  */

#endif  /* _CSL_EMIFHAL_H  */

/******************************************************************************\
*     
*      End of csl_emifhal.h 
*
\******************************************************************************/

csl_emifdat.h/  1051539347  0     0     0       2214      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... EMIF
* FILENAME...... csl_emifdat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL  - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       03/30/2000
*   MODIFIED: 04/16/2001 modified header comments
*   MODIFIED: 03/27/2003 Updated register names as per SPRU621A
*   MODIFIED: 10 April 2003 added reference for CLS_EmifData for .csldata
*                           size fix
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the EMIF module)
*       Reserved Area for EMIF Data 
*
*
\******************************************************************************/
#ifndef _EMIF_DATA_H_
#define _EMIF_DATA_H_

  #include <csl_std.h>

  #if (_EMIFB_SUPPORT)
     typedef struct {
	Uint16 gblctl1;
	Uint16 gblctl2;
	Uint16 ce1ctl1;
	Uint16 ce1ctl2;
	Uint16 ce0ctl1;
	Uint16 ce0ctl2;
      Uint16 reserved0;
      Uint16 reserved1;
	Uint16 ce2ctl1;
	Uint16 ce2ctl2;
	Uint16 ce3ctl1;
	Uint16 ce3ctl2;
	Uint16 sdctl1;
	Uint16 sdctl2;
	Uint16 sdrfr1;
	Uint16 sdrfr2;
	Uint16 sdext1;
	Uint16 sdext2;
      Uint16 reserved3[16];
	Uint16 ce1sec1;
      Uint16 reserved4;
	Uint16 ce0sec1;
      Uint16 reserved6[3];
	Uint16 ce2sec1;
      Uint16 reserved5;
	Uint16 ce3sec1;
      Uint16 reserved7[22];
      Uint16 cescr;
      } EMIF_RegObj, *EMIF_RegPtr;
    
      typedef struct {
        EMIF_RegPtr regs;
      } CSL_EmifDataObj;     


     #define CSL_EMIFDATAINIT\
     { (EMIF_RegPtr)0x0800u }

  #else

     typedef struct {
       Uint16 EmifReserved;
     } CSL_EmifDataObj;

     #define CSL_EMIFDATAINIT\
     { 0x0000u }

  #endif

extern CSL_EmifDataObj CSL_EmifData;

#define CSL_EMIF_DATA CSL_EmifData

#endif
csl_emifhal.h/  1049976855  0     0     0       66883     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... EMI
* FILENAME...... csl_emifhal.h
* DATE CREATED.. Wed 05/24/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. stdinc.h, chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  05/24/2000 created
*   MODIFIED: 04/16/2001 modifed FILENAME and other header comments
*   MODIFIED: 01/24/2002 fixed bug in EMIF_FSETS macro definition  
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the TIMER module)
*
* Registers Covered:
*   (RW) _EMIF_EGCR  -  Global Control Register
*   (W)  _EMIF_EMIRST  -  Global Reset Register
*   (R)  _EMIF_EMIBE  -  Bus Error Status Register
*   (RW) _EMIF_CE01 -  CE0 Space Control Register 1
*   (RW) _EMIF_CE02 -  CE0 Space Control Register 2
*   (RW) _EMIF_CE03 -  CE0 Space Control Register 3
*   (RW) _EMIF_CE11 -  CE1 Space Control Register 1
*   (RW) _EMIF_CE12 -  CE1 Space Control Register 2
*   (RW) _EMIF_CE13 -  CE1 Space Control Register 3
*   (RW) _EMIF_CE21 -  CE2 Space Control Register 1
*   (RW) _EMIF_CE22 -  CE2 Space Control Register 2
*   (RW) _EMIF_CE23 -  CE2 Space Control Register 3
*   (RW) _EMIF_CE31 -  CE3 Space Control Register 1
*   (RW) _EMIF_CE32 -  CE3 Space Control Register 2
*   (RW) _EMIF_CE33 -  CE3 Space Control Register 2
*   (RW) _EMIF_SDC1 - SDRAM Control Register 1
*   (R)  _EMIF_SDPER	- SDRAM Period Register
*   (R)  _EMIF_SDCNT - SDRAM Counter Register
*   (R)  _EMIF_INIT  - SDRAM Initialization Register
*   (RW) _EMIF_SDC2 - SDRAM Control Register 2
\******************************************************************************/
#ifndef _EMIFHAL_H_
#define _EMIFHAL_H_

#include <csl_std.h>
#include <csl_chiphal.h>

#if (_EMIF_SUPPORT)

/*============================================================================*\
* misc declarations
\*============================================================================*/

#define _EMIF_DEVICE_CNT			(2)


/*============================================================================*\
* EMIF generic register and field  access macros
\*============================================================================*/

#define EMIF_ADDR(Reg)                _EMIF_##Reg##_ADDR
#define EMIF_RGET(Reg)                _PREG_GET(EMIF_ADDR(##Reg))
#define EMIF_RSET(Reg,Val)            _PREG_SET(EMIF_ADDR(##Reg),Val)
#define EMIF_RAOI(Reg,AND,OR,INV)     _PREG_AOI(EMIF_ADDR(##Reg),AND,OR,INV)
#define EMIF_FGET(Reg,Field)          _PFIELD_GET(EMIF_ADDR(##Reg), _EMIF_##Reg##_##Field)
#define EMIF_FSET(Reg,Field,Val)      _PFIELD_SET(EMIF_ADDR(##Reg), _EMIF_##Reg##_##Field,Val)
#define EMIF_FSETS(Reg,Field,Sym)     EMIF_FSET(##Reg,##Field,EMIF_##Reg##_##Field##_##Sym)
#define EMIF_FMK(Reg,Field,Val)       _EMIF_##Reg##_##Field##_MK(Val)
#define EMIF_FMKS(Reg,Field,Sym)      EMIF_FMK(##Reg,##Field,EMIF_##Reg##_##Field##_##Sym)
#define EMIF_FAOI(Reg,Field,AND,OR,INV)\
  _PFIELD_AOI(EMIF_ADDR(##Reg),_EMIF_##Reg##_##Field,AND,OR,INV)

/*============================================================================*\
* _EMIF_EGCR:  Global Control Register
\*============================================================================*/
#define _EMIF_EGCR_ADDR				(0x0800u)
#define _EMIF_EGCR                       	PREG16(_EMIF_EGCR_ADDR)
#define _EGCR                           	_EMIF_EGCR

/*============================================================================*\
* _EMIF_EGCR_GET and _EMIF_EGCR_SET
\*============================================================================*/
#define _EMIF_EGCR_GET(RegAddr)		_PREG_GET(RegAddr)
#define _EMIF_EGCR_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/*============================================================================*\
* _EMIF_EMIRST:  Global Reset Register
\*============================================================================*/
#define _EMIF_EMIRST_ADDR			(0x0801u)
#define _EMIF_EMIRST                     	PREG16(_EMIF_EMIRST_ADDR)
#define _EMIRST                          	_EMIF_EMIRST

/*============================================================================*\
* _EMIF_EMIRST_GET 
\*============================================================================*/

#define _EMIF_EMIRST_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/*============================================================================*\
* _EMIF_EMIBE:  Bus Error Status Register
\*============================================================================*/
#define _EMIF_EMIBE_ADDR				(0x0802u)
#define _EMIF_EMIBE                       	PREG16(_EMIF_EMIBE_ADDR)
#define _EMIBE                              	_EMIF_EMIBE

/*============================================================================*\
* _EMIF_EMIBE_GET 
\*============================================================================*/
#define _EMIF_EMIBE_GET(RegAddr)		_PREG_GET(RegAddr)

/*============================================================================*\
* _EMIF_CE01:  CE0 Space Control Register 1
\*============================================================================*/
#define _EMIF_CE01_ADDR				(0x0803u)
#define _EMIF_CE01                       	PREG16(_EMIF_CE01_ADDR)
#define _CE01                              _EMIF_CE01

/*============================================================================*\
* _EMIF_CE02:  CE0 Space Control Register 2
\*============================================================================*/
#define _EMIF_CE02_ADDR				(0x0804u)
#define _EMIF_CE02                       	PREG16(_EMIF_CE02_ADDR)
#define _CE02                              _EMIF_CE02

/*============================================================================*\
* _EMIF_CE03:  CE0 Space Control Register 3
\*============================================================================*/
#define _EMIF_CE03_ADDR				(0x0805u)
#define _EMIF_CE03                       	PREG16(_EMIF_CE03_ADDR)
#define _CE03                              _EMIF_CE03

/*============================================================================*\
* _EMIF_CE11:  CE1 Space Control Register 1
\*============================================================================*/
#define _EMIF_CE11_ADDR				(0x0806u)
#define _EMIF_CE11                       	PREG16(_EMIF_CE11_ADDR)
#define _CE11                              _EMIF_CE11

/*============================================================================*\
* _EMIF_CE12:  CE1 Space Control Register 2
\*============================================================================*/
#define _EMIF_CE12_ADDR				(0x0807u)
#define _EMIF_CE12                       	PREG16(_EMIF_CE12_ADDR)
#define _CE12                              _EMIF_CE12

/*============================================================================*\
* _EMIF_CE13:  CE1 Space Control Register 3
\*============================================================================*/
#define _EMIF_CE13_ADDR				(0x0808u)
#define _EMIF_CE13                       	PREG16(_EMIF_CE13_ADDR)
#define _CE13                              _EMIF_CE13

/*============================================================================*\
* _EMIF_CE21:  CE2 Space Control Register 1
\*============================================================================*/
#define _EMIF_CE21_ADDR				(0x0809u)
#define _EMIF_CE21                       	PREG16(_EMIF_CE21_ADDR)
#define _CE21                              _EMIF_CE21

/*============================================================================*\
* _EMIF_CE22:  CE2 Space Control Register 2
\*============================================================================*/
#define _EMIF_CE22_ADDR				(0x080Au)
#define _EMIF_CE22                       	PREG16(_EMIF_CE22_ADDR)
#define _CE22                              _EMIF_CE22

/*============================================================================*\
* _EMIF_CE23:  CE2 Space Control Register 3
\*============================================================================*/
#define _EMIF_CE23_ADDR				(0x080Bu)
#define _EMIF_CE23                       	PREG16(_EMIF_CE23_ADDR)
#define _CE23                              _EMIF_CE23

/*============================================================================*\
* _EMIF_CE31:  CE3 Space Control Register 1
\*============================================================================*/
#define _EMIF_CE31_ADDR				(0x080Cu)
#define _EMIF_CE31                       	PREG16(_EMIF_CE31_ADDR)
#define _CE31                              _EMIF_CE31

/*============================================================================*\
* _EMIF_CE32:  CE3 Space Control Register 2
\*============================================================================*/
#define _EMIF_CE32_ADDR				(0x080Du)
#define _EMIF_CE32                       	PREG16(_EMIF_CE32_ADDR)
#define _CE32                              _EMIF_CE32

/*============================================================================*\
* _EMIF_CE33:  CE3 Space Control Register 3
\*============================================================================*/
#define _EMIF_CE33_ADDR				(0x080Eu)
#define _EMIF_CE33                       	PREG16(_EMIF_CE33_ADDR)
#define _CE33                              _EMIF_CE33

/*============================================================================*\
* _EMIF_SDC1:  SDRAM Control Register 1
\*============================================================================*/
#define _EMIF_SDC1_ADDR			(0x080Fu)
#define _EMIF_SDC1                    PREG16(_EMIF_SDC1_ADDR)
#define _SDC1	                        _EMIF_SDC1

/*============================================================================*\
* _EMIF_SDC1_GET and _EMIF_SDC1_SET
\*============================================================================*/
#define _EMIF_SDC1_GET(RegAddr)		_PREG_GET(RegAddr)
#define _EMIF_SDC1_SET(RegAddr,Val)	_PREG_SET(RegAddr,Val)


/*============================================================================*\
* _EMIF_SDPER:  SDRAM Period Register
\*============================================================================*/
#define _EMIF_SDPER_ADDR			(0x0810u)
#define _EMIF_SDPER                    	PREG16(_EMIF_SDPER_ADDR)
#define _SDPER	                        _EMIF_SDPER

/*============================================================================*\
* _EMIF_SDCNT:  SDRAM Counter Register
\*============================================================================*/
#define _EMIF_SDCNT_ADDR			(0x0811u)
#define _EMIF_SDCNT                    PREG16(_EMIF_SDCNT_ADDR)
#define _SDCNT	                        _EMIF_SDCNT


/*============================================================================*\
* _EMIF_INIT:  SDRAM Initialization Register
\*============================================================================*/
#define _EMIF_INIT_ADDR			     (0x0812u)
#define _EMIF_INIT                    	PREG16(_EMIF_INIT_ADDR)
#define _INIT	                        _EMIF_INIT

#define _EMIF_SDINIT_ADDR			(0x0812u)
#define _EMIF_SDINIT                    	PREG16(_EMIF_SDINIT_ADDR)
#define _SDINIT	                        _EMIF_SDINIT

/*============================================================================*\
* _EMIF_SDC2:  SDRAM Control Register 2
\*============================================================================*/
#define _EMIF_SDC2_ADDR			  (0x0813u)
#define _EMIF_SDC2                    PREG16(_EMIF_SDC2_ADDR)
#define _SDC2	                    _EMIF_SDC2


/* \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */
/* \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */
/* \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */
/* \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */
/* \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */
/* ============================================================================ *\
* _EMIF_EGCR	   - Global Control Register
*
* Fields:
*  (RW) _EMIF_EGCR_MEMFREQ	- Memory Clock Frequency field
*  (RW) _EMIF_EGCR_WPE		- Write Posting Enable field
*  (RW) _EMIF_EGCR_MEMCEN	- Mem Clock Enable field
*  (R)  _EMIF_EGCR_ARDY		- Value of ARDY input
*  (R)  _EMIF_EGCR_HOLD		- Value of /HOLD input
*  (R)  _EMIF_EGCR_HOLDA		- Value of /HOLDA output
*  (RW)  _EMIF_EGCR_NOHOLD	- External HOLD disable field
\*============================================================================*/

/*==========================================================================*\
* (RW) _EMIF_EGCR_MEMFREQ
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_MEMFREQ_SHIFT		(0x0009u)
#define _EMIF_EGCR_MEMFREQ_MK(n)           (((Uint16)(n) & 0x0003u) << _EMIF_EGCR_MEMFREQ_SHIFT)
#define _EMIF_EGCR_MEMFREQ_MASK            (_EMIF_EGCR_MEMFREQ_MK(0x0003u))
#define _EMIF_EGCR_MEMFREQ_CLR             (~(_EMIF_EGCR_MEMFREQ_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_EGCR_WPE
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_WPE_SHIFT			(0x0007u)
#define _EMIF_EGCR_WPE_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EGCR_WPE_SHIFT)
#define _EMIF_EGCR_WPE_MASK            	(_EMIF_EGCR_WPE_MK(0x0001u))
#define _EMIF_EGCR_WPE_CLR             	(~(_EMIF_EGCR_WPE_MK(0x0001u)))

/*==========================================================================*\
* (RW) _EMIF_EGCR_MEMCEN
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_MEMCEN_SHIFT		(0x0005u)
#define _EMIF_EGCR_MEMCEN_MK(n)           (((Uint16)(n) & 0x0001u) << _EMIF_EGCR_MEMCEN_SHIFT)
#define _EMIF_EGCR_MEMCEN_MASK            (_EMIF_EGCR_MEMCEN_MK(0x0001u))
#define _EMIF_EGCR_MEMCEN_CLR             (~(_EMIF_EGCR_MEMCEN_MK(0x0001u)))

/*==========================================================================*\
* (R) _EMIF_EGCR_ARDY
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_ARDY_SHIFT			(0x0003u)
#define _EMIF_EGCR_ARDY_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EGCR_ARDY_SHIFT)
#define _EMIF_EGCR_ARDY_MASK            	(_EMIF_EGCR_ARDY_MK(0x0001u))
#define _EMIF_EGCR_ARDY_CLR               (~(_EMIF_EGCR_ARDY_MASK))

/*==========================================================================*\
* (R) _EMIF_EGCR_HOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_HOLD_SHIFT			(0x0002u)
#define _EMIF_EGCR_HOLD_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EGCR_HOLD_SHIFT)
#define _EMIF_EGCR_HOLD_MASK            	(_EMIF_EGCR_HOLD_MK(0x0001u))
#define _EMIF_EGCR_HOLD_CLR               (~(_EMIF_EGCR_HOLD_MASK))

/*==========================================================================*\
* (R) _EMIF_EGCR_HOLDA
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_HOLDA_SHIFT		(0x0001u)
#define _EMIF_EGCR_HOLDA_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EGCR_HOLDA_SHIFT)
#define _EMIF_EGCR_HOLDA_MASK            	(_EMIF_EGCR_HOLDA_MK(0x0001u))
#define _EMIF_EGCR_HOLDA_CLR              (~(_EMIF_EGCR_HOLDA_MASK))

/*==========================================================================*\
* (RW) _EMIF_EGCR_NOHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_NOHOLD_SHIFT		(0x0000u)
#define _EMIF_EGCR_NOHOLD_MK(n)           (((Uint16)(n) & 0x0001u) << _EMIF_EGCR_NOHOLD_SHIFT)
#define _EMIF_EGCR_NOHOLD_MASK            (_EMIF_EGCR_NOHOLD_MK(0x0001u))
#define _EMIF_EGCR_NOHOLD_CLR             (~(_EMIF_EGCR_NOHOLD_MK(0x0001u)))

/*==========================================================================*\
* _EMIF_EGCR	- Global Control Register Config
\*--------------------------------------------------------------------------*/
#define _EMIF_EGCR_CFG(memfreq,wpe,memcen,nohold) \
	_PREG_SET(_EMIF_EGCR_ADDR,\
    		(Uint16) (_EMIF_EGCR_MEMFREQ_MK(memfreq)|\
				_EMIF_EGCR_WPE_MK(wpe)|\
				_EMIF_EGCR_MEMCEN_MK(memcen)|\
				_EMIF_EGCR_NOHOLD_MK(nohold)\
             ))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _EMIF_EMIRST		- Global Reset Register
*
* Fields:
*  (W) _EMIF_EMIRST_EMIRST
\*============================================================================*/
#define _EMIF_EMIRST_EMIRST_SHIFT			(0x0000u)
#define _EMIF_EMIRST_EMIRST_MK(n)           	(((Uint16)(n) & 0xFFFFu) << _EMIF_EMIRST_EMIRST_SHIFT)
#define _EMIF_EMIRST_EMIRST_MASK            	(_EMIF_EMIRST_EMIRST_MK(0xFFFFu))
#define _EMIF_EMIRST_EMIRST_CLR             	(~(_EMIF_EMIRST_EMIRST_MK(0xFFFFu)))

/*==========================================================================*\
* _EMIF_EMIRST		- Global Reset Register Config
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIRST_CFG(EMIRST) \
	_PREG_SET(_EMIF_EMIRST_ADDR,\
    		(Uint16) (	_EMIF_EMIRST_EMIRST_MK(EMIRST)\
	))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*=============================================================================*\
* _EMIF_EMIBE	   - Bus Error Status Register
*
* Fields:
*  (R) _EMIF_EMIBE_TIME
*  (R) _EMIF_EMIBE_CE3
*  (R) _EMIF_EMIBE_CE2
*  (R) _EMIF_EMIBE_CE1
*  (R) _EMIF_EMIBE_CE0
*  (R) _EMIF_EMIBE_DMA
*  (R) _EMIF_EMIBE_FBUS
*  (R) _EMIF_EMIBE_EBUS
*  (R) _EMIF_EMIBE_DBUS
*  (R) _EMIF_EMIBE_CBUS
*  (R) _EMIF_EMIBE_PBUS
\*============================================================================*/

/*==========================================================================*\
* (R) _EMIF_EMIBE_TIME
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_TIME_SHIFT		(0x000Cu)
#define _EMIF_EMIBE_TIME_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_TIME_SHIFT)
#define _EMIF_EMIBE_TIME_MASK            	(_EMIF_EMIBE_TIME_MK(0x0001u))
#define _EMIF_EMIBE_TIME_CLR              (~(_EMIF_EMIBE_TIME_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_CE3
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_CE3_SHIFT			(0x000Au)
#define _EMIF_EMIBE_CE3_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_CE3_SHIFT)
#define _EMIF_EMIBE_CE3_MASK            	(_EMIF_EMIBE_CE3_MK(0x0001u))
#define _EMIF_EMIBE_CE3_CLR               (~(_EMIF_EMIBE_CE3_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_CE2
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_CE2_SHIFT			(0x0009u)
#define _EMIF_EMIBE_CE2_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_CE2_SHIFT)
#define _EMIF_EMIBE_CE2_MASK            	(_EMIF_EMIBE_CE2_MK(0x0001u))
#define _EMIF_EMIBE_CE2_CLR               (~(_EMIF_EMIBE_CE2_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_CE1
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_CE1_SHIFT			(0x0008u)
#define _EMIF_EMIBE_CE1_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_CE1_SHIFT)
#define _EMIF_EMIBE_CE1_MASK            	(_EMIF_EMIBE_CE1_MK(0x0001u))
#define _EMIF_EMIBE_CE1_CLR               (~(_EMIF_EMIBE_CE1_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_CE0
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_CE0_SHIFT			(0x0007u)
#define _EMIF_EMIBE_CE0_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_CE0_SHIFT)
#define _EMIF_EMIBE_CE0_MASK            	(_EMIF_EMIBE_CE0_MK(0x0001u))
#define _EMIF_EMIBE_CE0_CLR               (~(_EMIF_EMIBE_CE0_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_DMA
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_DMA_SHIFT			(0x0006u)
#define _EMIF_EMIBE_DMA_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_DMA_SHIFT)
#define _EMIF_EMIBE_DMA_MASK            	(_EMIF_EMIBE_DMA_MK(0x0001u))
#define _EMIF_EMIBE_DMA_CLR               (~(_EMIF_EMIBE_DMA_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_FBUS
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_FBUS_SHIFT		(0x0005u)
#define _EMIF_EMIBE_FBUS_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_FBUS_SHIFT)
#define _EMIF_EMIBE_FBUS_MASK            	(_EMIF_EMIBE_FBUS_MK(0x0001u))
#define _EMIF_EMIBE_FBUS_CLR              (~(_EMIF_EMIBE_FBUS_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_EBUS
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_EBUS_SHIFT		(0x0004u)
#define _EMIF_EMIBE_EBUS_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_EBUS_SHIFT)
#define _EMIF_EMIBE_EBUS_MASK            	(_EMIF_EMIBE_EBUS_MK(0x0001u))
#define _EMIF_EMIBE_EBUS_CLR              (~(_EMIF_EMIBE_EBUS_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_DBUS
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_DBUS_SHIFT		(0x0003u)
#define _EMIF_EMIBE_DBUS_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_DBUS_SHIFT)
#define _EMIF_EMIBE_DBUS_MASK            	(_EMIF_EMIBE_DBUS_MK(0x0001u))
#define _EMIF_EMIBE_DBUS_CLR              (~(_EMIF_EMIBE_DBUS_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_CBUS
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_CBUS_SHIFT		(0x0002u)
#define _EMIF_EMIBE_CBUS_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_CBUS_SHIFT)
#define _EMIF_EMIBE_CBUS_MASK            	(_EMIF_EMIBE_CBUS_MK(0x0001u))
#define _EMIF_EMIBE_CBUS_CLR              (~(_EMIF_EMIBE_CBUS_MASK))

/*==========================================================================*\
* (R) _EMIF_EMIBE_PBUS
\*--------------------------------------------------------------------------*/
#define _EMIF_EMIBE_PBUS_SHIFT		(0x0000u)
#define _EMIF_EMIBE_PBUS_MK(n)           	(((Uint16)(n) & 0x0001u) << _EMIF_EMIBE_PBUS_SHIFT)
#define _EMIF_EMIBE_PBUS_MASK            	(_EMIF_EMIBE_PBUS_MK(0x0001u))
#define _EMIF_EMIBE_PBUS_CLR              (~(_EMIF_EMIBE_PBUS_MASK))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE01   - Space Control Register 1
* _EMIF_CE11   - Space Control Register 1
* _EMIF_CE21   - Space Control Register 1
* _EMIF_CE31   - Space Control Register 1
*
* Fields:
*  (RW) _EMIF_CEx1_MTYPE	- MTYPE field
*  (RW) _EMIF_CEx1_RDSETUP	- Read Setup field
*  (RW) _EMIF_CEx1_RDSTROBE	- Read Strobe field
*  (RW) _EMIF_CEx1_RDHOLD	- Read Hold field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE01_MTYPE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE01_MTYPE_SHIFT		(0x000Cu)
#define _EMIF_CE01_MTYPE_MK(n)           	(((Uint16)(n) & 0x0007u) << _EMIF_CE01_MTYPE_SHIFT)
#define _EMIF_CE01_MTYPE_MASK            	(_EMIF_CE01_MTYPE_MK(0x0007u))
#define _EMIF_CE01_MTYPE_CLR             	(~(_EMIF_CE01_MTYPE_MK(0x0007u)))

/*==========================================================================*\
* (RW) _EMIF_CE01_RDSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE01_RDSETUP_SHIFT		(0x0008u)
#define _EMIF_CE01_RDSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE01_RDSETUP_SHIFT)
#define _EMIF_CE01_RDSETUP_MASK           (_EMIF_CE01_RDSETUP_MK(0x000Fu))
#define _EMIF_CE01_RDSETUP_CLR            (~(_EMIF_CE01_RDSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE01_RDSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE01_RDSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE01_RDSTROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE01_RDSTROBE_SHIFT)
#define _EMIF_CE01_RDSTROBE_MASK          (_EMIF_CE01_RDSTROBE_MK(0x003Fu))
#define _EMIF_CE01_RDSTROBE_CLR           (~(_EMIF_CE01_RDSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE01_RDHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE01_RDHOLD_SHIFT		(0x0000u)
#define _EMIF_CE01_RDHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE01_RDHOLD_SHIFT)
#define _EMIF_CE01_RDHOLD_MASK          	(_EMIF_CE01_RDHOLD_MK(0x0003u))
#define _EMIF_CE01_RDHOLD_CLR           	(~(_EMIF_CE01_RDHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE01	- CE(0/1/2/3) Space Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE01_CFG(Sp,mtype,rdsetup,rdstrobe,rdhold) \
	_PREG_SET(_EMIF_CE01_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE01_MTYPE_MK(mtype) 		|	\
				_EMIF_CE01_RDSETUP_MK(rdsetup)	|	\
				_EMIF_CE01_RDSTROBE_MK(rdstrobe) 	|	\
				_EMIF_CE01_RDHOLD_MK(rdhold) 			\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE11_MTYPE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE11_MTYPE_SHIFT		(0x000Cu)
#define _EMIF_CE11_MTYPE_MK(n)           	(((Uint16)(n) & 0x0007u) << _EMIF_CE11_MTYPE_SHIFT)
#define _EMIF_CE11_MTYPE_MASK            	(_EMIF_CE11_MTYPE_MK(0x0007u))
#define _EMIF_CE11_MTYPE_CLR             	(~(_EMIF_CE11_MTYPE_MK(0x0007u)))

/*==========================================================================*\
* (RW) _EMIF_CE11_RDSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE11_RDSETUP_SHIFT		(0x0008u)
#define _EMIF_CE11_RDSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE11_RDSETUP_SHIFT)
#define _EMIF_CE11_RDSETUP_MASK           (_EMIF_CE11_RDSETUP_MK(0x000Fu))
#define _EMIF_CE11_RDSETUP_CLR            (~(_EMIF_CE11_RDSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE11_RDSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE11_RDSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE11_RDSTROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE11_RDSTROBE_SHIFT)
#define _EMIF_CE11_RDSTROBE_MASK          (_EMIF_CE11_RDSTROBE_MK(0x003Fu))
#define _EMIF_CE11_RDSTROBE_CLR           (~(_EMIF_CE11_RDSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE11_RDHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE11_RDHOLD_SHIFT		(0x0000u)
#define _EMIF_CE11_RDHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE11_RDHOLD_SHIFT)
#define _EMIF_CE11_RDHOLD_MASK          	(_EMIF_CE11_RDHOLD_MK(0x0003u))
#define _EMIF_CE11_RDHOLD_CLR           	(~(_EMIF_CE11_RDHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE11	- CE(0/1/2/3) Space Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE11_CFG(Sp,mtype,rdsetup,rdstrobe,rdhold) \
	_PREG_SET(_EMIF_CE11_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE11_MTYPE_MK(mtype) 		|	\
				_EMIF_CE11_RDSETUP_MK(rdsetup)	|	\
				_EMIF_CE11_RDSTROBE_MK(rdstrobe) 	|	\
				_EMIF_CE11_RDHOLD_MK(rdhold) 			\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE21_MTYPE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE21_MTYPE_SHIFT		(0x000Cu)
#define _EMIF_CE21_MTYPE_MK(n)           	(((Uint16)(n) & 0x0007u) << _EMIF_CE21_MTYPE_SHIFT)
#define _EMIF_CE21_MTYPE_MASK            	(_EMIF_CE21_MTYPE_MK(0x0007u))
#define _EMIF_CE21_MTYPE_CLR             	(~(_EMIF_CE21_MTYPE_MK(0x0007u)))

/*==========================================================================*\
* (RW) _EMIF_CE21_RDSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE21_RDSETUP_SHIFT		(0x0008u)
#define _EMIF_CE21_RDSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE21_RDSETUP_SHIFT)
#define _EMIF_CE21_RDSETUP_MASK           (_EMIF_CE21_RDSETUP_MK(0x000Fu))
#define _EMIF_CE21_RDSETUP_CLR            (~(_EMIF_CE21_RDSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE21_RDSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE21_RDSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE21_RDSTROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE21_RDSTROBE_SHIFT)
#define _EMIF_CE21_RDSTROBE_MASK          (_EMIF_CE21_RDSTROBE_MK(0x003Fu))
#define _EMIF_CE21_RDSTROBE_CLR           (~(_EMIF_CE21_RDSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE21_RDHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE21_RDHOLD_SHIFT		(0x0000u)
#define _EMIF_CE21_RDHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE21_RDHOLD_SHIFT)
#define _EMIF_CE21_RDHOLD_MASK          	(_EMIF_CE21_RDHOLD_MK(0x0003u))
#define _EMIF_CE21_RDHOLD_CLR           	(~(_EMIF_CE21_RDHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE21	- CE(0/1/2/3) Space Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE21_CFG(Sp,mtype,rdsetup,rdstrobe,rdhold) \
	_PREG_SET(_EMIF_CE21_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE21_MTYPE_MK(mtype) 		|	\
				_EMIF_CE21_RDSETUP_MK(rdsetup)	|	\
				_EMIF_CE21_RDSTROBE_MK(rdstrobe) 	|	\
				_EMIF_CE21_RDHOLD_MK(rdhold) 			\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE31_MTYPE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE31_MTYPE_SHIFT		(0x000Cu)
#define _EMIF_CE31_MTYPE_MK(n)           	(((Uint16)(n) & 0x0007u) << _EMIF_CE31_MTYPE_SHIFT)
#define _EMIF_CE31_MTYPE_MASK            	(_EMIF_CE31_MTYPE_MK(0x0007u))
#define _EMIF_CE31_MTYPE_CLR             	(~(_EMIF_CE31_MTYPE_MK(0x0007u)))

/*==========================================================================*\
* (RW) _EMIF_CE31_RDSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE31_RDSETUP_SHIFT		(0x0008u)
#define _EMIF_CE31_RDSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE31_RDSETUP_SHIFT)
#define _EMIF_CE31_RDSETUP_MASK           (_EMIF_CE31_RDSETUP_MK(0x000Fu))
#define _EMIF_CE31_RDSETUP_CLR            (~(_EMIF_CE31_RDSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE31_RDSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE31_RDSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE31_RDSTROBE_MK(n)		(((Uint16)(n) & 0x003fu) << _EMIF_CE31_RDSTROBE_SHIFT)
#define _EMIF_CE31_RDSTROBE_MASK          (_EMIF_CE31_RDSTROBE_MK(0x003Fu))
#define _EMIF_CE31_RDSTROBE_CLR           (~(_EMIF_CE31_RDSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE31_RDHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE31_RDHOLD_SHIFT		(0x0000u)
#define _EMIF_CE31_RDHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE31_RDHOLD_SHIFT)
#define _EMIF_CE31_RDHOLD_MASK          	(_EMIF_CE31_RDHOLD_MK(0x0003u))
#define _EMIF_CE31_RDHOLD_CLR           	(~(_EMIF_CE31_RDHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE31	- CE(0/1/2/3) Space Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE31_CFG(Sp,mtype,rdsetup,rdstrobe,rdhold) \
	_PREG_SET(_EMIF_CE31_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE31_MTYPE_MK(mtype) 		|	\
				_EMIF_CE31_RDSETUP_MK(rdsetup)	|	\
				_EMIF_CE31_RDSTROBE_MK(rdstrobe) 	|	\
				_EMIF_CE31_RDHOLD_MK(rdhold) 			\
             ))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE02   - Space Control Register 2
* _EMIF_CE12   - Space Control Register 2
* _EMIF_CE22   - Space COntrol Register 2
* _EMIF_CE32   - Space Control Register 2
*
* Fields:
*  (RW) _EMIF_CEx2_RDEXHLD 	- Extended Hold Read field
*  (RW) _EMIF_CEx2_WREXHLD	- Extended Hold Write field
*  (RW) _EMIF_CEx2_WRSETUP	- Write Setup field
*  (RW) _EMIF_CEx2_WRSTROBE	- Write Strobe field
*  (RW) _EMIF_CEx2_WRHOLD	- Write Hold field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE02_RDEXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_RDEXHLD_SHIFT		(0x000Eu)
#define _EMIF_CE02_RDEXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE02_RDEXHLD_SHIFT)
#define _EMIF_CE02_RDEXHLD_MASK          	(_EMIF_CE02_RDEXHLD_MK(0x0003u))
#define _EMIF_CE02_RDEXHLD_CLR           	(~(_EMIF_CE02_RDEXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE02_WREXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_WREXHLD_SHIFT		(0x000Cu)
#define _EMIF_CE02_WREXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE02_WREXHLD_SHIFT)
#define _EMIF_CE02_WREXHLD_MASK          	(_EMIF_CE02_WREXHLD_MK(0x0003u))
#define _EMIF_CE02_WREXHLD_CLR           	(~(_EMIF_CE02_WREXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE02_WRSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_WRSETUP_SHIFT		(0x0008u)
#define _EMIF_CE02_WRSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE02_WRSETUP_SHIFT)
#define _EMIF_CE02_WRSETUP_MASK          	(_EMIF_CE02_WRSETUP_MK(0x000Fu))
#define _EMIF_CE02_WRSETUP_CLR           	(~(_EMIF_CE02_WRSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE02_WRSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_WRSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE02_WRSTROBE_MK(n)		(((Uint16)(n) & 0x003Fu) << _EMIF_CE02_WRSTROBE_SHIFT)
#define _EMIF_CE02_WRSTROBE_MASK          (_EMIF_CE02_WRSTROBE_MK(0x003Fu))
#define _EMIF_CE02_WRSTROBE_CLR           (~(_EMIF_CE02_WRSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE02_WRHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_WRHOLD_SHIFT		(0x0000u)
#define _EMIF_CE02_WRHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE02_WRHOLD_SHIFT)
#define _EMIF_CE02_WRHOLD_MASK          	(_EMIF_CE02_WRHOLD_MK(0x0003u))
#define _EMIF_CE02_WRHOLD_CLR           	(~(_EMIF_CE02_WRHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE02		- CE(0/1/2/3) Space Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE02_CFG(Sp,rdexhld,wrexhld,wrsetup,wrstrobe,wrhold) \
	_PREG_SET(_EMIF_CE02_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE02_RDEXHLD_MK(rdexhld) 	|	\
				_EMIF_CE02_WREXHLD_MK(wrexhld)		|	\
				_EMIF_CE02_WRSETUP_MK(wrsetup) 	|	\
				_EMIF_CE02_WRSTROBE_MK(wrstrobe) 	|	\
				_EMIF_CE02_WRHOLD_MK(wrhold) 			\
             ))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE02   - Space Control Register 2
* _EMIF_CE12   - Space Control Register 2
* _EMIF_CE22   - Space COntrol Register 2
* _EMIF_CE32   - Space Control Register 2
*
* Fields:
*  (RW) _EMIF_CEx2_RDEXHLD 	- Extended Hold Read field
*  (RW) _EMIF_CEx2_WREXHLD	- Extended Hold Write field
*  (RW) _EMIF_CEx2_WRSETUP	- Write Setup field
*  (RW) _EMIF_CEx2_WRSTROBE	- Write Strobe field
*  (RW) _EMIF_CEx2_WRHOLD	- Write Hold field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE12_RDEXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_RDEXHLD_SHIFT		(0x000Eu)
#define _EMIF_CE12_RDEXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE12_RDEXHLD_SHIFT)
#define _EMIF_CE12_RDEXHLD_MASK          	(_EMIF_CE12_RDEXHLD_MK(0x0003u))
#define _EMIF_CE12_RDEXHLD_CLR           	(~(_EMIF_CE12_RDEXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE12_WREXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_WREXHLD_SHIFT		(0x000Cu)
#define _EMIF_CE12_WREXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE12_WREXHLD_SHIFT)
#define _EMIF_CE12_WREXHLD_MASK          	(_EMIF_CE12_WREXHLD_MK(0x0003u))
#define _EMIF_CE12_WREXHLD_CLR           	(~(_EMIF_CE12_WREXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE12_WRSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_WRSETUP_SHIFT		(0x0008u)
#define _EMIF_CE12_WRSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE12_WRSETUP_SHIFT)
#define _EMIF_CE12_WRSETUP_MASK          	(_EMIF_CE12_WRSETUP_MK(0x000Fu))
#define _EMIF_CE12_WRSETUP_CLR           	(~(_EMIF_CE12_WRSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE12_WRSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_WRSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE12_WRSTROBE_MK(n)		(((Uint16)(n) & 0x003Fu) << _EMIF_CE12_WRSTROBE_SHIFT)
#define _EMIF_CE12_WRSTROBE_MASK          (_EMIF_CE12_WRSTROBE_MK(0x003Fu))
#define _EMIF_CE12_WRSTROBE_CLR           (~(_EMIF_CE12_WRSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE12_WRHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_WRHOLD_SHIFT		(0x0000u)
#define _EMIF_CE12_WRHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE12_WRHOLD_SHIFT)
#define _EMIF_CE12_WRHOLD_MASK          	(_EMIF_CE12_WRHOLD_MK(0x0003u))
#define _EMIF_CE12_WRHOLD_CLR           	(~(_EMIF_CE12_WRHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE12		- CE(0/1/2/3) Space Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE12_CFG(Sp,rdexhld,wrexhld,wrsetup,wrstrobe,wrhold) \
	_PREG_SET(_EMIF_CE12_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE12_RDEXHLD_MK(rdexhld) 	|	\
				_EMIF_CE12_WREXHLD_MK(wrexhld)		|	\
				_EMIF_CE12_WRSETUP_MK(wrsetup) 	|	\
				_EMIF_CE12_WRSTROBE_MK(wrstrobe) 	|	\
				_EMIF_CE12_WRHOLD_MK(wrhold) 			\
             ))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE02   - Space Control Register 2
* _EMIF_CE12   - Space Control Register 2
* _EMIF_CE22   - Space COntrol Register 2
* _EMIF_CE32   - Space Control Register 2
*
* Fields:
*  (RW) _EMIF_CEx2_RDEXHLD 	- Extended Hold Read field
*  (RW) _EMIF_CEx2_WREXHLD	- Extended Hold Write field
*  (RW) _EMIF_CEx2_WRSETUP	- Write Setup field
*  (RW) _EMIF_CEx2_WRSTROBE	- Write Strobe field
*  (RW) _EMIF_CEx2_WRHOLD	- Write Hold field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE22_RDEXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_RDEXHLD_SHIFT		(0x000Eu)
#define _EMIF_CE22_RDEXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE22_RDEXHLD_SHIFT)
#define _EMIF_CE22_RDEXHLD_MASK          	(_EMIF_CE22_RDEXHLD_MK(0x0003u))
#define _EMIF_CE22_RDEXHLD_CLR           	(~(_EMIF_CE22_RDEXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE22_WREXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_WREXHLD_SHIFT		(0x000Cu)
#define _EMIF_CE22_WREXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE22_WREXHLD_SHIFT)
#define _EMIF_CE22_WREXHLD_MASK          	(_EMIF_CE22_WREXHLD_MK(0x0003u))
#define _EMIF_CE22_WREXHLD_CLR           	(~(_EMIF_CE22_WREXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE22_WRSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_WRSETUP_SHIFT		(0x0008u)
#define _EMIF_CE22_WRSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE22_WRSETUP_SHIFT)
#define _EMIF_CE22_WRSETUP_MASK          	(_EMIF_CE22_WRSETUP_MK(0x000Fu))
#define _EMIF_CE22_WRSETUP_CLR           	(~(_EMIF_CE22_WRSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE22_WRSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_WRSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE22_WRSTROBE_MK(n)		(((Uint16)(n) & 0x003Fu) << _EMIF_CE22_WRSTROBE_SHIFT)
#define _EMIF_CE22_WRSTROBE_MASK          (_EMIF_CE22_WRSTROBE_MK(0x003Fu))
#define _EMIF_CE22_WRSTROBE_CLR           (~(_EMIF_CE22_WRSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE22_WRHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_WRHOLD_SHIFT		(0x0000u)
#define _EMIF_CE22_WRHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE22_WRHOLD_SHIFT)
#define _EMIF_CE22_WRHOLD_MASK          	(_EMIF_CE22_WRHOLD_MK(0x0003u))
#define _EMIF_CE22_WRHOLD_CLR           	(~(_EMIF_CE22_WRHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE22		- CE(0/1/2/3) Space Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE22_CFG(Sp,rdexhld,wrexhld,wrsetup,wrstrobe,wrhold) \
	_PREG_SET(_EMIF_CE22_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE22_RDEXHLD_MK(rdexhld) 	|	\
				_EMIF_CE22_WREXHLD_MK(wrexhld)		|	\
				_EMIF_CE22_WRSETUP_MK(wrsetup) 	|	\
				_EMIF_CE22_WRSTROBE_MK(wrstrobe) 	|	\
				_EMIF_CE22_WRHOLD_MK(wrhold) 			\
             ))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE02   - Space Control Register 2
* _EMIF_CE12   - Space Control Register 2
* _EMIF_CE22   - Space COntrol Register 2
* _EMIF_CE32   - Space Control Register 2
*
* Fields:
*  (RW) _EMIF_CEx2_RDEXHLD 	- Extended Hold Read field
*  (RW) _EMIF_CEx2_WREXHLD	- Extended Hold Write field
*  (RW) _EMIF_CEx2_WRSETUP	- Write Setup field
*  (RW) _EMIF_CEx2_WRSTROBE	- Write Strobe field
*  (RW) _EMIF_CEx2_WRHOLD	- Write Hold field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE32_RDEXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_RDEXHLD_SHIFT		(0x000Eu)
#define _EMIF_CE32_RDEXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE32_RDEXHLD_SHIFT)
#define _EMIF_CE32_RDEXHLD_MASK          	(_EMIF_CE32_RDEXHLD_MK(0x0003u))
#define _EMIF_CE32_RDEXHLD_CLR           	(~(_EMIF_CE32_RDEXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE32_WREXHLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_WREXHLD_SHIFT		(0x000Cu)
#define _EMIF_CE32_WREXHLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE32_WREXHLD_SHIFT)
#define _EMIF_CE32_WREXHLD_MASK          	(_EMIF_CE32_WREXHLD_MK(0x0003u))
#define _EMIF_CE32_WREXHLD_CLR           	(~(_EMIF_CE32_WREXHLD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_CE32_WRSETUP
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_WRSETUP_SHIFT		(0x0008u)
#define _EMIF_CE32_WRSETUP_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_CE32_WRSETUP_SHIFT)
#define _EMIF_CE32_WRSETUP_MASK          	(_EMIF_CE32_WRSETUP_MK(0x000Fu))
#define _EMIF_CE32_WRSETUP_CLR           	(~(_EMIF_CE32_WRSETUP_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE32_WRSTROBE
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_WRSTROBE_SHIFT		(0x0002u)
#define _EMIF_CE32_WRSTROBE_MK(n)		(((Uint16)(n) & 0x003Fu) << _EMIF_CE32_WRSTROBE_SHIFT)
#define _EMIF_CE32_WRSTROBE_MASK          (_EMIF_CE32_WRSTROBE_MK(0x003Fu))
#define _EMIF_CE32_WRSTROBE_CLR           (~(_EMIF_CE32_WRSTROBE_MK(0x003Fu)))

/*==========================================================================*\
* (RW) _EMIF_CE32_WRHOLD
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_WRHOLD_SHIFT		(0x0000u)
#define _EMIF_CE32_WRHOLD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_CE32_WRHOLD_SHIFT)
#define _EMIF_CE32_WRHOLD_MASK          	(_EMIF_CE32_WRHOLD_MK(0x0003u))
#define _EMIF_CE32_WRHOLD_CLR           	(~(_EMIF_CE32_WRHOLD_MK(0x0003u)))

/*==========================================================================*\
* _EMIF_CE32		- CE(0/1/2/3) Space Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE32_CFG(Sp,rdexhld,wrexhld,wrsetup,wrstrobe,wrhold) \
	_PREG_SET(_EMIF_CE32_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE32_RDEXHLD_MK(rdexhld) 	|	\
				_EMIF_CE32_WREXHLD_MK(wrexhld)		|	\
				_EMIF_CE32_WRSETUP_MK(wrsetup) 	|	\
				_EMIF_CE32_WRSTROBE_MK(wrstrobe) 	|	\
				_EMIF_CE32_WRHOLD_MK(wrhold) 			\
             ))



/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_CE03   - Space Control Register 3
* _EMIF_CE13   - Space Control Register 3
* _EMIF_CE23   - Space COntrol Register 3
* _EMIF_CE33   - Space Control Register 3
*
* Fields:
*  (RW) _EMIF_CEx3_TIMOUT 	- Timeout field
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_CE03_TIMOUT
\*--------------------------------------------------------------------------*/
#define _EMIF_CE03_TIMOUT_SHIFT		(0x0000u)
#define _EMIF_CE03_TIMOUT_MK(n)		(((Uint16)(n) & 0x00FFu) << _EMIF_CE03_TIMOUT_SHIFT)
#define _EMIF_CE03_TIMOUT_MASK          	(_EMIF_CE03_TIMOUT_MK(0x00FFu))
#define _EMIF_CE03_TIMOUT_CLR           	(~(_EMIF_CE03_TIMOUT_MK(0x00FFu)))

/*==========================================================================*\
* _EMIF_CE03		- CE(0/1/2/3) Space Control Register 3 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE03_CFG(Sp,timeout) \
	_PREG_SET(_EMIF_CE03_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE03_TIMOUT_MK(timeout)\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE13_TIMOUT
\*--------------------------------------------------------------------------*/
#define _EMIF_CE13_TIMOUT_SHIFT		(0x0000u)
#define _EMIF_CE13_TIMOUT_MK(n)		(((Uint16)(n) & 0x00FFu) << _EMIF_CE13_TIMOUT_SHIFT)
#define _EMIF_CE13_TIMOUT_MASK          	(_EMIF_CE13_TIMOUT_MK(0x00FFu))
#define _EMIF_CE13_TIMOUT_CLR           	(~(_EMIF_CE13_TIMOUT_MK(0x00FFu)))

/*==========================================================================*\
* _EMIF_CE13		- CE(0/1/2/3) Space Control Register 3 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE13_CFG(Sp,timeout) \
	_PREG_SET(_EMIF_CE13_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE13_TIMOUT_MK(timeout)\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE23_TIMOUT
\*--------------------------------------------------------------------------*/
#define _EMIF_CE23_TIMOUT_SHIFT		(0x0000u)
#define _EMIF_CE23_TIMOUT_MK(n)		(((Uint16)(n) & 0x00FFu) << _EMIF_CE23_TIMOUT_SHIFT)
#define _EMIF_CE23_TIMOUT_MASK          	(_EMIF_CE23_TIMOUT_MK(0x00FFu))
#define _EMIF_CE23_TIMOUT_CLR           	(~(_EMIF_CE23_TIMOUT_MK(0x00FFu)))

/*==========================================================================*\
* _EMIF_CE33		- CE(0/1/2/3) Space Control Register 3 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE23_CFG(Sp,timeout) \
	_PREG_SET(_EMIF_CE23_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE33_TIMOUT_MK(timeout)\
             ))

/*==========================================================================*\
* (RW) _EMIF_CE33_TIMOUT
\*--------------------------------------------------------------------------*/
#define _EMIF_CE33_TIMOUT_SHIFT		(0x0000u)
#define _EMIF_CE33_TIMOUT_MK(n)		(((Uint16)(n) & 0x00FFu) << _EMIF_CE33_TIMOUT_SHIFT)
#define _EMIF_CE33_TIMOUT_MASK          	(_EMIF_CE33_TIMOUT_MK(0x00FFu))
#define _EMIF_CE33_TIMOUT_CLR           	(~(_EMIF_CE33_TIMOUT_MK(0x00FFu)))

/*==========================================================================*\
* _EMIF_CE33		- CE(0/1/2/3) Space Control Register 3 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_CE33_CFG(Sp,timeout) \
	_PREG_SET(_EMIF_CE33_ADDR(Sp),\
    		(Uint16) (	_EMIF_CE33_TIMOUT_MK(timeout)\
             ))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_SDC1   - SDRAM Control Register 1
*
* Fields:
*  (RW) _EMIF_SDC1_TRC
*  (RW) _EMIF_SDC1_SDSIZE
*  (RW) _EMIF_SDC1_SDWID
*  (RW) _EMIF_SDC1_RFEN
*  (RW) _EMIF_SDC1_TRCD
*  (RW) _EMIF_SDC1_TRP
\*===========================================================================*/

/*===========================================================================*\
* (RW) _EMIF_SDC1_TRC
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_TRC_SHIFT		      (0x000Bu)
#define _EMIF_SDC1_TRC_MK(n)		      (((Uint16)(n) & 0x001Fu) << _EMIF_SDC1_TRC_SHIFT)
#define _EMIF_SDC1_TRC_MASK          	(_EMIF_SDC1_TRC_MK(0x001Fu))
#define _EMIF_SDC1_TRC_CLR           	(~(_EMIF_SDC1_TRC_MK(0x001Fu)))

/*==========================================================================*\
* (RW) _EMIF_SDC1_SDSIZE
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_SDSIZE_SHIFT		(0x000Au)
#define _EMIF_SDC1_SDSIZE_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDC1_SDSIZE_SHIFT)
#define _EMIF_SDC1_SDSIZE_MASK            (_EMIF_SDC1_SDSIZE_MK(0x0001u))
#define _EMIF_SDC1_SDSIZE_CLR             (~(_EMIF_SDC1_SDSIZE_MK(0x0001u)))

/*==========================================================================*\
* (RW) _EMIF_SDC1_SDWID
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_SDWID_SHIFT		(0x0009u)
#define _EMIF_SDC1_SDWID_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDC1_SDWID_SHIFT)
#define _EMIF_SDC1_SDWID_MASK        	(_EMIF_SDC1_SDWID_MK(0x0001u))
#define _EMIF_SDC1_SDWID_CLR         	(~(_EMIF_SDC1_SDWID_MK(0x0001u)))

/*==========================================================================*\
* (RW) _EMIF_SDC1_RFEN
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_RFEN_SHIFT		      (0x0008u)
#define _EMIF_SDC1_RFEN_MK(n)		      (((Uint16)(n) & 0x0001u) << _EMIF_SDC1_RFEN_SHIFT)
#define _EMIF_SDC1_RFEN_MASK        	(_EMIF_SDC1_RFEN_MK(0x0001u))
#define _EMIF_SDC1_RFEN_CLR         	(~(_EMIF_SDC1_RFEN_MK(0x0001u)))

/*==========================================================================*\
* (RW) _EMIF_SDC1_TRCD
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_TRCD_SHIFT		      (0x0004u)
#define _EMIF_SDC1_TRCD_MK(n)		      (((Uint16)(n) & 0x000Fu) << _EMIF_SDC1_TRCD_SHIFT)
#define _EMIF_SDC1_TRCD_MASK        	(_EMIF_SDC1_TRCD_MK(0x000Fu))
#define _EMIF_SDC1_TRCD_CLR         	(~(_EMIF_SDC1_TRCD_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_SDC1_TRP
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_TRP_SHIFT		      (0x0000u)
#define _EMIF_SDC1_TRP_MK(n)		      (((Uint16)(n) & 0x000Fu) << _EMIF_SDC1_TRP_SHIFT)
#define _EMIF_SDC1_TRP_MASK        	      (_EMIF_SDC1_TRP_MK(0x000Fu))
#define _EMIF_SDC1_TRP_CLR         	      (~(_EMIF_SDC1_TRP_MK(0x000Fu)))

/*==========================================================================*\
* _EMIF_SDC1		- SDRAM Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC1_CFG(trc,sdsize,sdwid,rfen,trcd,trp) \
	_PREG_SET(_EMIF_SDC1_ADDR,\
    		(Uint16) (	_EMIF_SDC1_TRC_MK(trc) 		|	\
				_EMIF_SDC1_SDSIZE_MK(sdsize) 	|	\
				_EMIF_SDC1_SDWID_MK(sdwid) 	|	\
				_EMIF_SDC1_RFEN_MK(rfen) 		|	\
				_EMIF_SDC1_TRCD_MK(trcd) 		|	\
				_EMIF_SDC1_TRP_MK(trp)			\
             ))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_SDPER   - SDRAM Period Register
*
* Fields:
*  (RW) _EMIF_SDPER_PERIOD
\*===========================================================================*/

/*==========================================================================*\
* (RW) _EMIF_SDPER_PERIOD
\*--------------------------------------------------------------------------*/
#define _EMIF_SDPER_PERIOD_SHIFT		(0x0000u)
#define _EMIF_SDPER_PERIOD_MK(n)		(((Uint16)(n) & 0x0FFFu) << _EMIF_SDPER_PERIOD_SHIFT)
#define _EMIF_SDPER_PERIOD_MASK        	(_EMIF_SDPER_PERIOD_MK(0x0FFFu))
#define _EMIF_SDPER_PERIOD_CLR         	(~(_EMIF_SDPER_PERIOD_MK(0x0FFFu)))

/*==========================================================================*\
* _EMIF_SDPER		- SDRAM Period Register Config
\*--------------------------------------------------------------------------*/
#define _EMIF_SDPER_CFG(period) \
	_PREG_SET(_EMIF_SDPER_ADDR,\
    		(Uint16) (	_EMIF_SDPER_PERIOD_MK(period)		\
             ))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*============================================================================*\
* _EMIF_SDCNT   - SDRAM Counter Register
*
* Fields:
*  (R)  _EMIF_SDCNT_COUNTER
\*===========================================================================*/

/*===========================================================================*\
* (R) _EMIF_SDCNT_COUNTER
\*---------------------------------------------------------------------------*/
#define _EMIF_SDCNT_COUNTER_SHIFT		(0x0000u)
#define _EMIF_SDCNT_COUNTER_MK(n)		(((Uint16)(n) & 0x0FFFu) << _EMIF_SDCNT_COUNTER_SHIFT)
#define _EMIF_SDCNT_COUNTER_MASK        	(_EMIF_SDCNT_COUNTER_MK(0x0FFFu))
#define _EMIF_SDCNT_COUNTER_CLR           (~(_EMIF_SDCNT_COUNTER_MASK))

/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_INIT   - SDRAM INITialization Register
*
* Fields:
*  (RW)  _EMIF_INIT_INIT
\*===========================================================================*/

/*==========================================================================*\
*  (RW)  _EMIF_INIT_INIT
\*--------------------------------------------------------------------------*/
#define _EMIF_INIT_INIT_SHIFT		(0x0000u)
#define _EMIF_INIT_INIT_MK(n)		(((Uint16)(n) & 0xFFFFu) << _EMIF_INIT_INIT_SHIFT)
#define _EMIF_INIT_INIT_MASK        (_EMIF_INIT_INIT_MK(0xFFFFu))
#define _EMIF_INIT_INIT_CLR         (~(_EMIF_INIT_INIT_MK(0xFFFFu)))

/*==========================================================================*\
* _EMIF_INIT		- SDRAM INITialization Register
\*--------------------------------------------------------------------------*/
#define _EMIF_INIT_CFG(val) \
	_PREG_SET(_EMIF_INIT_ADDR,\
    		(Uint16) (	_EMIF_INIT_INIT_MK(val)		\
             ))

/*==========================================================================*\
*  (RW)  _EMIF_SDINIT_INIT
\*--------------------------------------------------------------------------*/
#define _EMIF_SDINIT_INIT_SHIFT		(0x0000u)
#define _EMIF_SDINIT_INIT_MK(n)		(((Uint16)(n) & 0xFFFFu) << _EMIF_SDINIT_INIT_SHIFT)
#define _EMIF_SDINIT_INIT_MASK        (_EMIF_SDINIT_INIT_MK(0xFFFFu))
#define _EMIF_SDINIT_INIT_CLR         (~(_EMIF_SDINIT_INIT_MK(0xFFFFu)))

/*==========================================================================*\
* _EMIF_SDINIT		- SDRAM INITialization Register
\*--------------------------------------------------------------------------*/
#define _EMIF_SDINIT_CFG(val) \
	_PREG_SET(_EMIF_SDINIT_ADDR,\
    		(Uint16) (	_EMIF_SDINIT_INIT_MK(val)		\
             ))


/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
/*===========================================================================*\
* _EMIF_SDC2   - SDRAM Control Register 2
*
* Fields:
*  (RW) _EMIF_SDC2_TMRD
*  (RW) _EMIF_SDC2_TRAS
*  (RW) _EMIF_SDC2_TACTV2ACTV
\*==========================================================================*/
/*==========================================================================*\
* (RW) _EMIF_SDC2_SDACC
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC2_SDACC_SHIFT		(0x000Au)
#define _EMIF_SDC2_SDACC_MK(n)		(((Uint16)(n) & 0x0001u) << _EMIF_SDC2_SDACC_SHIFT)
#define _EMIF_SDC2_SDACC_MASK        	(_EMIF_SDC2_SDACC_MK(0x0003u))
#define _EMIF_SDC2_SDACC_CLR         	(~(_EMIF_SDC2_SDACC_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_SDC2_TMRD
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC2_TMRD_SHIFT		(0x0008u)
#define _EMIF_SDC2_TMRD_MK(n)		(((Uint16)(n) & 0x0003u) << _EMIF_SDC2_TMRD_SHIFT)
#define _EMIF_SDC2_TMRD_MASK        	(_EMIF_SDC2_TMRD_MK(0x0003u))
#define _EMIF_SDC2_TMRD_CLR         	(~(_EMIF_SDC2_TMRD_MK(0x0003u)))

/*==========================================================================*\
* (RW) _EMIF_SDC2_TRAS
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC2_TRAS_SHIFT		(0x0004u)
#define _EMIF_SDC2_TRAS_MK(n)		(((Uint16)(n) & 0x000Fu) << _EMIF_SDC2_TRAS_SHIFT)
#define _EMIF_SDC2_TRAS_MASK        	(_EMIF_SDC2_TRAS_MK(0x000Fu))
#define _EMIF_SDC2_TRAS_CLR         	(~(_EMIF_SDC2_TRAS_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _EMIF_SDC2_TACTV2ACTV
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC2_TACTV2ACTV_SHIFT	(0x0000u)
#define _EMIF_SDC2_TACTV2ACTV_MK(n)	(((Uint16)(n) & 0x000Fu) << _EMIF_SDC2_TACTV2ACTV_SHIFT)
#define _EMIF_SDC2_TACTV2ACTV_MASK   	(_EMIF_SDC2_TACTV2ACTV_MK(0x000Fu))
#define _EMIF_SDC2_TACTV2ACTV_CLR    	(~(_EMIF_SDC2_TACTV2ACTV_MK(0x000Fu)))

/*==========================================================================*\
* _EMIF_SDC2		- SDRAM Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _EMIF_SDC2_CFG(sdacc, tmrd,tras,tactv2actv) \
	_PREG_SET(_EMIF_SDC2_ADDR,\
    		(Uint16) (  _EMIF_SDC2_SDACC_MK(sdacc)          |	\
                  	_EMIF_SDC2_TMRD_MK(tmrd) 		|	\
				_EMIF_SDC2_TRAS_MK(tras) 		|	\
				_EMIF_SDC2_TACTV2ACTV_MK(tactv2actv) 	\
             ))


#elif (!(_EMIF_MOD))
	#error EMIF Hal Module Not Supported on Specified Target
#endif
#endif

csl_err.h/      1051539346  0     0     0       3315      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... ERR
* FILENAME...... csl_err.h
* DATE CREATED.. Tue 06/22/1999 
* PROJECT....... CSL - CHip Support Library
* COMPONENT..... SL - Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:        06/22/1999 Created
*   MODIFIED:       02/22/2000 C54x Romability .
*   MODIFIED:       07/13/2000 modified for C55x
*   LAST MODIFIED:  04/16/2001 modified FILENAME and header comments
*   MODIFIED: 10 April 2003 added #include for csl_errdat.h
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the ERR module)
*
*
*
\******************************************************************************/
#ifndef _ERR_H_
#define _ERR_H_

#include <_csl.h>

#include <csl_errdat.h>

#if (_ERR_SUPPORT)
/****************************************\
* ERR scope and inline control macros
\****************************************/
#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _INLINE
  #define IDECL static inline
  #define USEDEFS
  #define IDEF  static inline
#else
  #define IDECL extern
#endif

/****************************************\
* ERR global macro declarations
\****************************************/   

#define ERR_BASE_DAT     0x00000001
#define ERR_BASE_DMA     0x00000002
#define ERR_BASE_EDMA    0x00000003
#define ERR_BASE_MCBSP   0x00000004
#define ERR_BASE_TIMER   0x00000005 
#define ERR_BASE_PWR     0x00000006
#define ERR_BASE_GPIO    0x00000007
#define ERR_BASE_PLL     0x00000008
#define ERR_BASE_CACHE   0x00000009

#define ERR_BASE_USER  0x80000000

/****************************************\
* ERR global typedef declarations
\****************************************/
typedef void(*ERR_Handler)(Uint32 Major, Uint32 Minor);

/*******************************************\
* ERR global macro definition : ROMABILITY
\*******************************************/ 
/* Reserved ROM Area for Err Data */

/* ErrFunc is "far type" : 32bit Address */

/****************************************\
* ERR global variable declarations
\****************************************/

/****************************************\
* ERR global function declarations
\****************************************/
extern void   ERR_defaultHandler(Uint32 Major, Uint32 Minor);
extern void   ERR_installHandler(ERR_Handler Handler);
extern void   ERR_submit(Uint32 Major, Uint32 Minor);
extern Uint16 ERR_getCount();

/****************************************\
* ERR inline function declarations
\****************************************/


/****************************************\
* ERR inline function definitions
\****************************************/

#endif /* ERR_SUPPORT */
#endif /* _ERR_H_ */
/******************************************************************************\
* End of err.h
\******************************************************************************/


csl_errdat.h/   1051539345  0     0     0       1310      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... ERR
* FILENAME...... csl_errdat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  03/30/2000
*   MODIFIED: 04/16/2001 updated FILENAME and other header comments
*   MODIFIED: 10 April 2003 added reference for CSL_ErrData for .csldata size
*                           fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the PWR module)
*       Reserved ROM Area for EBUS Data 
*
*
\******************************************************************************/
#ifndef _ERR_DATA_H_
  #define _ERR_DATA_H_ 

  #include <csl_std.h>

  #define CSL_ERRDATAINIT  { 0x0000u }

  typedef struct {
   Uint16 ErrReserved;
  } CSL_ErrDataObj;

extern CSL_ErrDataObj CSL_ErrData;

#define CSL_ERR_DATA  CSL_ErrData

#endif
 
csl_giodat.h/   1049976859  0     0     0       921       `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GIO
* FILENAME...... giodata.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CHip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GIO module)
*       Reserved Area for GIO Data 
*
*
\******************************************************************************/
#ifndef _GIO_DATA_H_
#define _GIO_DATA_H_
#define GIO_DATA_SZ                1
#endif

csl_gpio.h/     1049976861  0     0     0       1469      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpio.h
* DATE CREATED.. Fri 06/09/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. 
* VERSION....... 1.00
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:         06/09/2000 created for C5510
*   LAST MODIFIED:   04/16/2001 updated module name and other header comments
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GPIO module)
*
*
*
\******************************************************************************/
#ifndef _CSL_GPIO_H_
  #define _CSL_GPIO_H_

  #include <csl.h>
  #include <csl_chiphal.h>

   
   #if (CHIP_5509_FAMILY)
      #include <csl_gpio5509.h>
   #elif (CHIP_5502_FAMILY)
      #include <csl_gpio5502.h>
   #else    /* Default (CHIP_5510_FAMILY) */
      #include <csl_gpio5510.h>
   #endif

#endif   /* _CSL_GPIO_H_ */
/******************************************************************************\
* End of gpio.h
\******************************************************************************/

csl_gpio5502.h/ 1065617100  0     0     0       30991     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpio.h
* DATE CREATED.. Fri 06/09/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. 
* VERSION....... 1.00
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:    06/09/2000 created for C5510
*   MODIFIED:   04/16/2001 updated module name and other header comments
*   MODIFIED:   01/22/2002 fixed pinDir and pinWrit so they dont affect
*                          just PIN0
*   MODIFIED:   04/04/2002 added GPIO_PIN definitions
*   MODIFIED:   04/23/2002 added PGPIO support for 5502
*   MODIFIED:   10/06/2003 Fixed GPIO_open(),GPIO_close()and GPIO_pinDisable() bugs.
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GPIO module)
*
*
*
\******************************************************************************/
#ifndef _GPIO5502_H_
#define _GPIO5502_H_

#include <_csl.h>

#if (_GPIO_SUPPORT)

#include <csl_gpio5502hal.h>
#include <csl_gpio5502dat.h>

/****************************************\
* GIO scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _GPIO_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/****************************************\
* GIO static macro declarations          
\****************************************/
 
#define GPIO_DEV0    (0)
#define _GPIO_NON_PARALLEL           0
#define _GPIO_PARALLEL_0             1
#define _GPIO_PARALLEL_1             2
#define _GPIO_PARALLEL_2             3

/*=====================================================*\
* Define Symbolic Constants for PIN Names
\*=====================================================*/


#define GPIO_PIN0            (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0001u)
#define GPIO_PIN1            (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0002u)
#define GPIO_PIN2            (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0004u)
#define GPIO_PIN3            (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0008u)
#define GPIO_PIN4            (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0010u)
#define GPIO_PIN5            (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0020u)
#define GPIO_PIN6            (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0040u)
#define GPIO_PIN7            (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0080u)

#define GPIO_GPIO_PIN0        (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0001u)
#define GPIO_GPIO_PIN1        (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0002u)
#define GPIO_GPIO_PIN2        (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0004u)
#define GPIO_GPIO_PIN3        (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0008u)
#define GPIO_GPIO_PIN4        (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0010u)
#define GPIO_GPIO_PIN5        (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0020u)
#define GPIO_GPIO_PIN6        (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0040u)
#define GPIO_GPIO_PIN7        (((Uint32)(_GPIO_NON_PARALLEL) << 16) | 0x0080u)

#define GPIO_PGPIO_PIN0       (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0001u) 
#define GPIO_PGPIO_PIN1       (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0002u) 
#define GPIO_PGPIO_PIN2       (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0004u) 
#define GPIO_PGPIO_PIN3       (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0008u) 
#define GPIO_PGPIO_PIN4       (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0010u) 
#define GPIO_PGPIO_PIN5       (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0020u) 
#define GPIO_PGPIO_PIN6       (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0040u) 
#define GPIO_PGPIO_PIN7       (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0080u) 
#define GPIO_PGPIO_PIN8       (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0100u) 
#define GPIO_PGPIO_PIN9       (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0200u) 
#define GPIO_PGPIO_PIN10      (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0400u) 
#define GPIO_PGPIO_PIN11      (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x0800u) 
#define GPIO_PGPIO_PIN12      (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x1000u) 
#define GPIO_PGPIO_PIN13      (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x2000u) 
#define GPIO_PGPIO_PIN14      (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x4000u) 
#define GPIO_PGPIO_PIN15      (((Uint32)(_GPIO_PARALLEL_0) << 16) | 0x8000u) 

#define GPIO_PGPIO_PIN16      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0001u) 
#define GPIO_PGPIO_PIN17      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0002u) 
#define GPIO_PGPIO_PIN18      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0004u) 
#define GPIO_PGPIO_PIN19      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0008u) 
#define GPIO_PGPIO_PIN20      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0010u) 
#define GPIO_PGPIO_PIN21      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0020u) 
#define GPIO_PGPIO_PIN22      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0040u) 
#define GPIO_PGPIO_PIN23      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0080u) 
#define GPIO_PGPIO_PIN24      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0100u) 
#define GPIO_PGPIO_PIN25      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0200u) 
#define GPIO_PGPIO_PIN26      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0400u) 
#define GPIO_PGPIO_PIN27      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x0800u) 
#define GPIO_PGPIO_PIN28      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x1000u) 
#define GPIO_PGPIO_PIN29      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x2000u) 
#define GPIO_PGPIO_PIN30      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x4000u) 
#define GPIO_PGPIO_PIN31      (((Uint32)(_GPIO_PARALLEL_1) << 16) | 0x8000u) 

#define GPIO_PGPIO_PIN32      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0001u) 
#define GPIO_PGPIO_PIN33      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0002u) 
#define GPIO_PGPIO_PIN34      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0004u) 
#define GPIO_PGPIO_PIN35      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0008u) 
#define GPIO_PGPIO_PIN36      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0010u) 
#define GPIO_PGPIO_PIN37      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0020u) 
#define GPIO_PGPIO_PIN38      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0040u) 
#define GPIO_PGPIO_PIN39      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0080u) 
#define GPIO_PGPIO_PIN40      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0100u) 
#define GPIO_PGPIO_PIN41      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0200u) 
#define GPIO_PGPIO_PIN42      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0400u) 
#define GPIO_PGPIO_PIN43      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x0800u) 
#define GPIO_PGPIO_PIN44      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x1000u) 
#define GPIO_PGPIO_PIN45      (((Uint32)(_GPIO_PARALLEL_2) << 16) | 0x2000u) 

/*=====================================================*\
* GPIO PIN Enable Masks           
\*=====================================================*/

#define GPIO_PIN0_ENABLE             (0x0001u)
#define GPIO_PIN1_ENABLE             (0x0002u)
#define GPIO_PIN2_ENABLE             (0x0004u)
#define GPIO_PIN3_ENABLE             (0x0008u)
#define GPIO_PIN4_ENABLE             (0x0010u)
#define GPIO_PIN5_ENABLE             (0x0020u)
#define GPIO_PIN6_ENABLE             (0x0040u)
#define GPIO_PIN7_ENABLE             (0x0080u)

#define GPIO_GPIO_PIN0_ENABLE        (0x0001u)
#define GPIO_GPIO_PIN1_ENABLE        (0x0002u)
#define GPIO_GPIO_PIN2_ENABLE        (0x0004u)
#define GPIO_GPIO_PIN3_ENABLE        (0x0008u)
#define GPIO_GPIO_PIN4_ENABLE        (0x0010u)
#define GPIO_GPIO_PIN5_ENABLE        (0x0020u)
#define GPIO_GPIO_PIN6_ENABLE        (0x0040u)
#define GPIO_GPIO_PIN7_ENABLE        (0x0080u)

#define GPIO_PGPIO_PIN0_ENABLE       (0x0001u) 
#define GPIO_PGPIO_PIN1_ENABLE       (0x0002u) 
#define GPIO_PGPIO_PIN2_ENABLE       (0x0004u) 
#define GPIO_PGPIO_PIN3_ENABLE       (0x0008u) 
#define GPIO_PGPIO_PIN4_ENABLE       (0x0010u) 
#define GPIO_PGPIO_PIN5_ENABLE       (0x0020u) 
#define GPIO_PGPIO_PIN6_ENABLE       (0x0040u) 
#define GPIO_PGPIO_PIN7_ENABLE       (0x0080u) 
#define GPIO_PGPIO_PIN8_ENABLE       (0x0100u) 
#define GPIO_PGPIO_PIN9_ENABLE       (0x0200u) 
#define GPIO_PGPIO_PIN10_ENABLE      (0x0400u) 
#define GPIO_PGPIO_PIN11_ENABLE      (0x0800u) 
#define GPIO_PGPIO_PIN12_ENABLE      (0x1000u) 
#define GPIO_PGPIO_PIN13_ENABLE      (0x2000u) 
#define GPIO_PGPIO_PIN14_ENABLE      (0x4000u) 
#define GPIO_PGPIO_PIN15_ENABLE      (0x8000u) 

#define GPIO_PGPIO_PIN16_ENABLE      (0x0001u) 
#define GPIO_PGPIO_PIN17_ENABLE      (0x0002u) 
#define GPIO_PGPIO_PIN18_ENABLE      (0x0004u) 
#define GPIO_PGPIO_PIN19_ENABLE      (0x0008u) 
#define GPIO_PGPIO_PIN20_ENABLE      (0x0010u) 
#define GPIO_PGPIO_PIN21_ENABLE      (0x0020u) 
#define GPIO_PGPIO_PIN22_ENABLE      (0x0040u) 
#define GPIO_PGPIO_PIN23_ENABLE      (0x0080u) 
#define GPIO_PGPIO_PIN24_ENABLE      (0x0100u) 
#define GPIO_PGPIO_PIN25_ENABLE      (0x0200u) 
#define GPIO_PGPIO_PIN26_ENABLE      (0x0400u) 
#define GPIO_PGPIO_PIN27_ENABLE      (0x0800u) 
#define GPIO_PGPIO_PIN28_ENABLE      (0x1000u) 
#define GPIO_PGPIO_PIN29_ENABLE      (0x2000u) 
#define GPIO_PGPIO_PIN30_ENABLE      (0x4000u) 
#define GPIO_PGPIO_PIN31_ENABLE      (0x8000u) 

#define GPIO_PGPIO_PIN32_ENABLE      (0x0001u) 
#define GPIO_PGPIO_PIN33_ENABLE      (0x0002u) 
#define GPIO_PGPIO_PIN34_ENABLE      (0x0004u) 
#define GPIO_PGPIO_PIN35_ENABLE      (0x0008u) 
#define GPIO_PGPIO_PIN36_ENABLE      (0x0010u) 
#define GPIO_PGPIO_PIN37_ENABLE      (0x0020u) 
#define GPIO_PGPIO_PIN38_ENABLE      (0x0040u) 
#define GPIO_PGPIO_PIN39_ENABLE      (0x0080u) 
#define GPIO_PGPIO_PIN40_ENABLE      (0x0100u) 
#define GPIO_PGPIO_PIN41_ENABLE      (0x0200u) 
#define GPIO_PGPIO_PIN42_ENABLE      (0x0400u) 
#define GPIO_PGPIO_PIN43_ENABLE      (0x0800u) 
#define GPIO_PGPIO_PIN44_ENABLE      (0x1000u) 
#define GPIO_PGPIO_PIN45_ENABLE      (0x2000u) 

/*=====================================================*\
* GPIO PIN Direction Masks           
\*=====================================================*/

#define GPIO_PIN0_OUTPUT             (0x0001u)
#define GPIO_PIN1_OUTPUT             (0x0002u)
#define GPIO_PIN2_OUTPUT             (0x0004u)
#define GPIO_PIN3_OUTPUT             (0x0008u)
#define GPIO_PIN4_OUTPUT             (0x0010u)
#define GPIO_PIN5_OUTPUT             (0x0020u)
#define GPIO_PIN6_OUTPUT             (0x0040u)
#define GPIO_PIN7_OUTPUT             (0x0080u)

#define GPIO_GPIO_PIN0_OUTPUT        (0x0001u)
#define GPIO_GPIO_PIN1_OUTPUT        (0x0002u)
#define GPIO_GPIO_PIN2_OUTPUT        (0x0004u)
#define GPIO_GPIO_PIN3_OUTPUT        (0x0008u)
#define GPIO_GPIO_PIN4_OUTPUT        (0x0010u)
#define GPIO_GPIO_PIN5_OUTPUT        (0x0020u)
#define GPIO_GPIO_PIN6_OUTPUT        (0x0040u)
#define GPIO_GPIO_PIN7_OUTPUT        (0x0080u)

#define GPIO_PGPIO_PIN0_OUTPUT       (0x0001u) 
#define GPIO_PGPIO_PIN1_OUTPUT       (0x0002u) 
#define GPIO_PGPIO_PIN2_OUTPUT       (0x0004u) 
#define GPIO_PGPIO_PIN3_OUTPUT       (0x0008u) 
#define GPIO_PGPIO_PIN4_OUTPUT       (0x0010u) 
#define GPIO_PGPIO_PIN5_OUTPUT       (0x0020u) 
#define GPIO_PGPIO_PIN6_OUTPUT       (0x0040u) 
#define GPIO_PGPIO_PIN7_OUTPUT       (0x0080u) 
#define GPIO_PGPIO_PIN8_OUTPUT       (0x0100u) 
#define GPIO_PGPIO_PIN9_OUTPUT       (0x0200u) 
#define GPIO_PGPIO_PIN10_OUTPUT      (0x0400u) 
#define GPIO_PGPIO_PIN11_OUTPUT      (0x0800u) 
#define GPIO_PGPIO_PIN12_OUTPUT      (0x1000u) 
#define GPIO_PGPIO_PIN13_OUTPUT      (0x2000u) 
#define GPIO_PGPIO_PIN14_OUTPUT      (0x4000u) 
#define GPIO_PGPIO_PIN15_OUTPUT      (0x8000u) 

#define GPIO_PGPIO_PIN16_OUTPUT      (0x0001u) 
#define GPIO_PGPIO_PIN17_OUTPUT      (0x0002u) 
#define GPIO_PGPIO_PIN18_OUTPUT      (0x0004u) 
#define GPIO_PGPIO_PIN19_OUTPUT      (0x0008u) 
#define GPIO_PGPIO_PIN20_OUTPUT      (0x0010u) 
#define GPIO_PGPIO_PIN21_OUTPUT      (0x0020u) 
#define GPIO_PGPIO_PIN22_OUTPUT      (0x0040u) 
#define GPIO_PGPIO_PIN23_OUTPUT      (0x0080u) 
#define GPIO_PGPIO_PIN24_OUTPUT      (0x0100u) 
#define GPIO_PGPIO_PIN25_OUTPUT      (0x0200u) 
#define GPIO_PGPIO_PIN26_OUTPUT      (0x0400u) 
#define GPIO_PGPIO_PIN27_OUTPUT      (0x0800u) 
#define GPIO_PGPIO_PIN28_OUTPUT      (0x1000u) 
#define GPIO_PGPIO_PIN29_OUTPUT      (0x2000u) 
#define GPIO_PGPIO_PIN30_OUTPUT      (0x4000u) 
#define GPIO_PGPIO_PIN31_OUTPUT      (0x8000u) 

#define GPIO_PGPIO_PIN32_OUTPUT      (0x0001u) 
#define GPIO_PGPIO_PIN33_OUTPUT      (0x0002u) 
#define GPIO_PGPIO_PIN34_OUTPUT      (0x0004u) 
#define GPIO_PGPIO_PIN35_OUTPUT      (0x0008u) 
#define GPIO_PGPIO_PIN36_OUTPUT      (0x0010u) 
#define GPIO_PGPIO_PIN37_OUTPUT      (0x0020u) 
#define GPIO_PGPIO_PIN38_OUTPUT      (0x0040u) 
#define GPIO_PGPIO_PIN39_OUTPUT      (0x0080u) 
#define GPIO_PGPIO_PIN40_OUTPUT      (0x0100u) 
#define GPIO_PGPIO_PIN41_OUTPUT      (0x0200u) 
#define GPIO_PGPIO_PIN42_OUTPUT      (0x0400u) 
#define GPIO_PGPIO_PIN43_OUTPUT      (0x0800u) 
#define GPIO_PGPIO_PIN44_OUTPUT      (0x1000u) 
#define GPIO_PGPIO_PIN45_OUTPUT      (0x2000u) 

#define GPIO_PIN0_INPUT             (0x0001u)
#define GPIO_PIN1_INPUT             (0x0002u)
#define GPIO_PIN2_INPUT             (0x0004u)
#define GPIO_PIN3_INPUT             (0x0008u)
#define GPIO_PIN4_INPUT             (0x0010u)
#define GPIO_PIN5_INPUT             (0x0020u)
#define GPIO_PIN6_INPUT             (0x0040u)
#define GPIO_PIN7_INPUT             (0x0080u)

#define GPIO_GPIO_PIN0_INPUT        (0x0000u)
#define GPIO_GPIO_PIN1_INPUT        (0x0000u)
#define GPIO_GPIO_PIN2_INPUT        (0x0000u)
#define GPIO_GPIO_PIN3_INPUT        (0x0000u)
#define GPIO_GPIO_PIN4_INPUT        (0x0000u)
#define GPIO_GPIO_PIN5_INPUT        (0x0000u)
#define GPIO_GPIO_PIN6_INPUT        (0x0000u)
#define GPIO_GPIO_PIN7_INPUT        (0x0000u)

#define GPIO_PGPIO_PIN0_INPUT       (0x0000u) 
#define GPIO_PGPIO_PIN1_INPUT       (0x0000u) 
#define GPIO_PGPIO_PIN2_INPUT       (0x0000u) 
#define GPIO_PGPIO_PIN3_INPUT       (0x0000u) 
#define GPIO_PGPIO_PIN4_INPUT       (0x0000u) 
#define GPIO_PGPIO_PIN5_INPUT       (0x0000u) 
#define GPIO_PGPIO_PIN6_INPUT       (0x0000u) 
#define GPIO_PGPIO_PIN7_INPUT       (0x0000u) 
#define GPIO_PGPIO_PIN8_INPUT       (0x0000u) 
#define GPIO_PGPIO_PIN9_INPUT       (0x0000u) 
#define GPIO_PGPIO_PIN10_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN11_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN12_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN13_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN14_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN15_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN16_INPUT      (0x0000u) 

#define GPIO_PGPIO_PIN17_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN18_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN19_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN20_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN21_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN22_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN23_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN24_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN25_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN26_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN27_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN28_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN29_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN30_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN31_INPUT      (0x0000u) 

#define GPIO_PGPIO_PIN32_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN33_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN34_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN35_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN36_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN37_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN38_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN39_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN40_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN41_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN42_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN43_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN44_INPUT      (0x0000u) 
#define GPIO_PGPIO_PIN45_INPUT      (0x0000u) 


#define GPIO_INPUT           (0x0000u)
#define GPIO_OUTPUT          (0x0001u)

/* Configure GIO (General Purpose I/O) Pins */
#define GPIO_IODIR_IODIR0_EN         (0x0001u)
#define GPIO_IODIR_IODIR1_EN         (0x0002u)
#define GPIO_IODIR_IODIR2_EN         (0x0004u)
#define GPIO_IODIR_IODIR3_EN         (0x0008u)
#define GPIO_IODIR_IODIR4_EN         (0x0010u)
#define GPIO_IODIR_IODIR5_EN         (0x0020u)
#define GPIO_IODIR_IODIR6_EN         (0x0040u)
#define GPIO_IODIR_IODIR7_EN         (0x0080u)

#define GPIO_IODIR_IODIR0            (0x0001u)
#define GPIO_IODIR_IODIR1            (0x0002u)
#define GPIO_IODIR_IODIR2            (0x0004u)
#define GPIO_IODIR_IODIR3            (0x0008u)
#define GPIO_IODIR_IODIR4            (0x0010u)
#define GPIO_IODIR_IODIR5            (0x0020u)
#define GPIO_IODIR_IODIR6            (0x0040u)
#define GPIO_IODIR_IODIR7            (0x0080u)

#define GPIO_IODIR_IO0DIR            (0x0001u)
#define GPIO_IODIR_IO1DIR            (0x0002u)
#define GPIO_IODIR_IO2DIR            (0x0004u)
#define GPIO_IODIR_IO3DIR            (0x0008u)
#define GPIO_IODIR_IO4DIR            (0x0010u)
#define GPIO_IODIR_IO5DIR            (0x0020u)
#define GPIO_IODIR_IO6DIR            (0x0040u)
#define GPIO_IODIR_IO7DIR            (0x0080u)

#define GPIO_IODATA_IOD0_O	       (0x0001u)
#define GPIO_IODATA_IOD1_O           (0x0002u)
#define GPIO_IODATA_IOD2_O           (0x0004u)
#define GPIO_IODATA_IOD3_O           (0x0008u)
#define GPIO_IODATA_IOD4_O           (0x0010u)
#define GPIO_IODATA_IOD5_O           (0x0020u)
#define GPIO_IODATA_IOD6_O           (0x0040u)
#define GPIO_IODATA_IOD7_O           (0x0080u)

#define GPIO_IODATA_IO0DIR_OUTPUT	 (0x0001u)
#define GPIO_IODATA_IO1DIR_OUTPUT    (0x0002u)
#define GPIO_IODATA_IO2DIR_OUTPUT    (0x0004u)
#define GPIO_IODATA_IO3DIR_OUTPUT    (0x0008u)
#define GPIO_IODATA_IO4DIR_OUTPUT    (0x0010u)
#define GPIO_IODATA_IO5DIR_OUTPUT    (0x0020u)
#define GPIO_IODATA_IO6DIR_OUTPUT    (0x0040u)
#define GPIO_IODATA_IO7DIR_OUTPUT    (0x0080u)


#define GPIO_IODATA_IOD0_I           (0x0000u)
#define GPIO_IODATA_IOD1_I           (0x0000u)
#define GPIO_IODATA_IOD2_I           (0x0000u)
#define GPIO_IODATA_IOD3_I           (0x0000u)
#define GPIO_IODATA_IOD4_I           (0x0000u)
#define GPIO_IODATA_IOD5_I           (0x0000u)
#define GPIO_IODATA_IOD6_I           (0x0000u)
#define GPIO_IODATA_IOD7_I           (0x0000u)

#define GPIO_IODATA_IO0DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO1DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO2DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO3DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO4DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO5DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO6DIR_INPUT      (0x0000u)
#define GPIO_IODATA_IO7DIR_INPUT      (0x0000u)

/****************************************\
* GIO static typedef declarations
\****************************************/
/*******************************************\
* GIO: global macro definition : ROMABILITY
\*******************************************/  
/* Reserved ROM Area by giodata.h */     

/*===========================================================================*\
*  GPIO IODIR Macros
*
* Fields:
*  (RW) IO7DIR
*  (RW) IO6DIR
*  (RW) IO5DIR
*  (RW) IO4DIR
*  (RW) IO3DIR
*  (RW) IO2DIR
*  (RW) IO1DIR
*  (RW) IO0DIR
\*==========================================================================*/



/*---------------------------------------*\
* GPIO_IODIR_MK Macro
\*---------------------------------------*/

#define GPIO_IODIR_RMK(io7, io6, io5, io4, io3,\
                        io2, io1, io0 )\
  (Uint16) ( GPIO_FMK(IODIR,IO7DIR,io7)    |\
             GPIO_FMK(IODIR,IO6DIR,io6)    |\
             GPIO_FMK(IODIR,IO5DIR,io5)    |\
             GPIO_FMK(IODIR,IO4DIR,io4)    |\
             GPIO_FMK(IODIR,IO3DIR,io3)    |\
             GPIO_FMK(IODIR,IO2DIR,io2)    |\
             GPIO_FMK(IODIR,IO1DIR,io1)    |\
             GPIO_FMK(IODIR,IO0DIR,io0)    \
)

/*===========================================================================*\
* GPIO IODATA
*
* Fields:
*  (RW) IO7D
*  (RW) IO6D
*  (RW) IO5D
*  (RW) IO4D
*  (RW) IO3D
*  (RW) IO2D
*  (RW) IO1D
*  (RW) IO0D
\*==========================================================================*/

/*---------------------------------------*\
* GPIO_IODATA_MK Macro
\*---------------------------------------*/

#define GPIO_IODATA_RMK(io0,io1,io2,io3,io4,io5,io6,io7)(\
(Uint16) (	GPIO_FMK(IODATA,IO0DAT,io0) |	\
		GPIO_FMK(IODATA,IO1DAT,io1) |	\
		GPIO_FMK(IODATA,IO2DAT,io2) |	\
		GPIO_FMK(IODATA,IO3DAT,io3) |	\
		GPIO_FMK(IODATA,IO4DAT,io4) |	\
		GPIO_FMK(IODATA,IO5DAT,io5) |	\
		GPIO_FMK(IODATA,IO6DAT,io6) |	\
		GPIO_FMK(IODATA,IO7DAT,io7) 	\
	   ))

/***************************************\
* GPIO COnfiguration Structure
\***************************************/
typedef struct {
      Uint16 iodir;
#if (CHIP_5509)
      Uint16 pgpioen0;
      Uint16 pgpiodir0;
      Uint16 pgpioen1;
      Uint16 pgpiodir1;
#endif
#if (CHIP_5502)
      Uint16 pgpioen0;
      Uint16 pgpiodir0;
      Uint16 pgpioen1;
      Uint16 pgpiodir1;
      Uint16 pgpioen2;
      Uint16 pgpiodir2;
#endif
} GPIO_ConfigAll;

typedef struct {
#if (_GPIO_PARALLEL_SUPPORT)
     Uint16 ioen;
#endif
     Uint16 iodir;
} GPIO_Config;
     

typedef struct {
    Uint16 private;
}GPIO_Obj, *GPIO_Handle;

/****************************************\
* GIO function declarations        
\****************************************/
IDECL  GPIO_Handle GPIO_open(Uint32 allocmask, Uint32 flags);
IDECL  void GPIO_close(GPIO_Handle hGpio);
IDECL  void GPIO_config(GPIO_Handle hGpio, GPIO_Config *pinCfg);

#if (_GPIO_PARALLEL_SUPPORT)
IDECL void GPIO_configArgs(GPIO_Handle hGpio, Uint32 enabMask, Uint16 direction);
#else
IDECL void GPIO_configArgs(GPIO_Handle hGpio, Uint16 direction);
#endif

IDECL  void GPIO_configAll(GPIO_ConfigAll *gCfg);
#if (CHIP_5502)
IDECL  void GPIO_configAllArgs(GPIO_Handle hGpio, Uint16 iodir, Uint16 pgpioen0, Uint16 pgpiodir0,
       Uint16 pgpioen1, Uint16 pgpiodir1, Uint16 pgpioen2, Uint16 pgpiodir2);
#elif (CHIP_5509)
IDECL   void GPIO_configAllArgs(GPIO_Handle hGpio, Uint16 iodir, Uint16 pgpioen0, Uint16 pgpiodir0,
         Uint16 pgpioen1, Uint16 pgpiodir1);
#else
IDECL   void GPIO_configAllArgs(GPIO_Handle hGpio, Uint16 iodir);
#endif

IDECL  void GPIO_pinEnable(GPIO_Handle hGpio, Uint32 pinMask);
IDECL  void GPIO_pinDisable(GPIO_Handle hGpio, Uint32 pinMask);
IDECL  void GPIO_pinDirection(GPIO_Handle hGpio, Uint32 pinMask, Uint16 direction);
IDECL  int  GPIO_pinRead(GPIO_Handle hGpio, Uint32 pinId);
IDECL  void GPIO_pinWrite(GPIO_Handle hGpio, Uint32 pinId, Uint16 val);
IDECL  int  GPIO_pinReadAll(GPIO_Handle hGpio, Uint32 pinMask);
IDECL  void GPIO_pinWriteAll(GPIO_Handle hGpio, Uint32 pinMask, Uint16 pinVals);
IDECL  void  GPIO_pinReset(GPIO_Handle hGpio, Uint32 pinMask);


/****************************************\
* GPIO Inline Functions
\****************************************/

#ifdef USEDEFS
/*------------------------------------------------------*/
IDEF void GPIO_close(GPIO_Handle hGpio) {
   GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
   Uint16 regIndx = ptr->regIndx;

   (CSL_SYS_DATA).GpioAllocMask[regIndx] = 0;
   ptr->pinsAllocated = 0x0000;
}
  
/*------------------------------------------------------*/
IDEF void GPIO_config(GPIO_Handle hGpio, GPIO_Config *cfg) {
   GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
  
   if (ptr->regIndx == _GPIO_NON_PARALLEL) {
      *((ioport Uint16 *)(ptr->dirReg)) = cfg->iodir;
      return;
   }
   *((ioport Uint16 *)(ptr->enableReg)) = cfg->ioen & (ptr->pinsAllocated);
   *((ioport Uint16 *)(ptr->dirReg)) = cfg->iodir;
}
/*------------------------------------------------------*/
#if (_GPIO_PARALLEL_SUPPORT)
IDEF void GPIO_configArgs(GPIO_Handle hGpio, Uint32 enabMask, Uint16 direction) {
#else
IDEF void GPIO_configArgs(GPIO_Handle hGpio, Uint16 direction) {
#endif
    GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;

    if (ptr->regIndx == _GPIO_NON_PARALLEL) {
      *(ioport Uint16 *)(ptr->dirReg) = direction;
      return;
    }

    *(ioport Uint16 *)(ptr->enableReg) = enabMask & (ptr->pinsAllocated);
}
/*------------------------------------------------------*/
IDEF void GPIO_configAll(GPIO_ConfigAll *gCfg) {

     GPIO_RSET(IODIR,gCfg->iodir);
#if (_GPIO_PARALLEL_SUPPORT)
      GPIO_RSET(PGPIOEN0,gCfg->pgpioen0);
      GPIO_RSET(PGPIODIR0,gCfg->pgpiodir0);
      GPIO_RSET(PGPIOEN1,gCfg->pgpioen1);
      GPIO_RSET(PGPIODIR1,gCfg->pgpiodir1);
#if (CHIP_5502)
      GPIO_RSET(PGPIOEN2,gCfg->pgpioen2);
      GPIO_RSET(PGPIODIR2,gCfg->pgpiodir2);
#endif
#endif
}
/*------------------------------------------------------*/
#if (CHIP_5502)
IDEF  void GPIO_configAllArgs(GPIO_Handle hGpio, Uint16 iodir, Uint16 pgpioen0, Uint16 pgpiodir0,
       Uint16 pgpioen1, Uint16 pgpiodir1, Uint16 pgpioen2, Uint16 pgpiodir2) {
#elif (CHIP_5509)
IDEF  void GPIO_configAllArgs(GPIO_Handle hGpio, Uint16 iodir, Uint16 pgpioen0, Uint16 pgpiodir0,
        Uint16 pgpioen1, Uint16 pgpiodir1) {
#else
IDEF  void GPIO_configAllArgs(GPIO_Handle hGpio, Uint16 iodir) {
#endif

     GPIO_RSET(IODIR,iodir);
#if (_GPIO_PARALLEL_SUPPORT)
      GPIO_RSET(PGPIOEN0,pgpioen0);
      GPIO_RSET(PGPIODIR0,pgpiodir0);
      GPIO_RSET(PGPIOEN1,pgpioen1);
      GPIO_RSET(PGPIODIR1,pgpiodir1);
#if (CHIP_5502)
      GPIO_RSET(PGPIOEN2,pgpioen2);
      GPIO_RSET(PGPIODIR2,pgpiodir2);
#endif
#endif
}
/*----------------------------------------------------------------------------*/
IDEF GPIO_Handle GPIO_open(Uint32 allocMask, Uint32 flags){
  Uint16 regIndx = (Uint16)((allocMask >> 16) & 0xFFFFu);
  Uint16 pinMask = (Uint16)(allocMask & 0xFFFFu); 
  Uint16 old_intm;
  GPIO_PrivateObj *ptr = INV;

  old_intm = IRQ_globalDisable();

  if (!((CSL_SYS_DATA).GpioAllocMask[regIndx] )) {
      (CSL_SYS_DATA).GpioAllocMask[regIndx] = pinMask; /*allocated;*/
      ptr = (GPIO_PrivateObj *)(&((CSL_GPIO_DATA).pinObj[regIndx]));
      ptr->regIndx = regIndx;
      ptr->pinsAllocated = pinMask;
  }
  IRQ_globalRestore(old_intm);
  
  return (GPIO_Handle)(ptr);
}

/*------------------------------------------------------*/
IDEF void GPIO_pinEnable(GPIO_Handle hGpio, Uint32 pinId){
  GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
  Uint16 allocMask;
  Uint16 pin = (Uint16)(pinId & 0xFFFFu);

   allocMask = ptr->pinsAllocated;
   if (ptr->regIndx == _GPIO_NON_PARALLEL) {
     return;
   }
   *((ioport Uint16 *)(ptr->enableReg)) = *((ioport Uint16 *)(ptr->enableReg)) 
                                          | (allocMask & pin);

}
/*------------------------------------------------------*/
IDEF void GPIO_pinDisable(GPIO_Handle hGpio, Uint32 pinId){
  GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
  Uint16 allocMask;
  Uint16 pin = (Uint16)(pinId & 0xFFFFu);

   if (ptr->regIndx == _GPIO_NON_PARALLEL) {
     return;
   }
   allocMask = ptr->pinsAllocated;
   *((ioport Uint16 *)(ptr->enableReg)) = (*((ioport Uint16 *)(ptr->enableReg))) 
                                          & (~(allocMask & pin));

}
/*------------------------------------------------------*/
IDEF void GPIO_pinDirection(GPIO_Handle hGpio, Uint32 pinMask, Uint16 direction){
   GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
   Uint16 pins = (Uint16)(pinMask & 0xFFFFu);
   Uint16 allocMask = ptr->pinsAllocated;
   *((ioport Uint16 *)(ptr->dirReg)) = ((*((ioport Uint16 *)(ptr->dirReg))) 
                                       & (~(allocMask & pins))) | ((direction) ? pins:0x0000u);
}
/*------------------------------------------------------*/
IDEF int GPIO_pinRead(GPIO_Handle hGpio, Uint32 pinId){
  GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;  
  Uint16 pins = (Uint16)(pinId & 0xFFFFu);
  Uint16 val;
  
  val =  ((*((ioport Uint16 *)(ptr->datReg))) & (ptr->pinsAllocated & pins));
  return (val ? 1:0);
}
/*------------------------------------------------------*/
IDEF int GPIO_pinReadAll(GPIO_Handle hGpio, Uint32 pinMask){
  GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;  
  Uint16 pins = (Uint16)(pinMask & 0xFFFFu);
  Uint16 val;
  
  val =  ((*((ioport Uint16 *)(ptr->datReg))) & (ptr->pinsAllocated & pins));
  return (val);
}
/*------------------------------------------------------*/
IDEF void GPIO_pinWrite(GPIO_Handle hGpio, Uint32 pinMask, Uint16 val){
  GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;  
  Uint16 pins = (Uint16)(pinMask & 0xFFFFu);
  Uint16 allocMask = ptr->pinsAllocated;
   *((ioport Uint16 *)(ptr->datReg)) = ((*((ioport Uint16 *)(ptr->datReg))) 
                                       & (~(allocMask & pins))) | ((val) ? pins:0x0000u);
}
/*------------------------------------------------------*/
IDEF void GPIO_pinWriteAll(GPIO_Handle hGpio, Uint32 pinMask, Uint16 val){
  GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;  
  Uint16 pins = (Uint16)(pinMask & 0xFFFFu);
  Uint16 allocMask = ptr->pinsAllocated;
   *((ioport Uint16 *)(ptr->datReg)) = ((*((ioport Uint16 *)(ptr->datReg))) 
                                       & (~(allocMask & pins))) | val;
}
/*------------------------------------------------------*/
IDEF void GPIO_pinReset(GPIO_Handle hGpio, Uint32 pinMask) {
  GPIO_PrivateObj *ptr = (GPIO_PrivateObj *)hGpio;
  Uint16 allocMask = ptr->pinsAllocated;

#if (_GPIO_PARALLEL_SUPPORT)
  *((ioport Uint16 *)(ptr->enableReg)) = *(ioport Uint16 *)(ptr->enableReg)
                                       & (~(allocMask & pinMask));
#endif
  *((ioport Uint16 *)(ptr->dirReg)) = (*((ioport Uint16 *)(ptr->dirReg)) &
                                    (~(allocMask & pinMask)));
}

#endif  // USEDEFS

#else
  #ifndef _GPIO_MOD_ 			/* GPIO_SUPPORT */
    #error GPIO Module Not Supported on Specified Target TEST!!!  
  #endif
#endif 					/* GPIO_SUPPORT */

#endif 					/* _GPIO_H_ */
/******************************************************************************\
* End of csl_gpio.h
\******************************************************************************/


csl_gpio5502dat/1057212103  20    0     0       1893      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpiodata.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GIO module)
*       Reserved Area for GIO Data 
*
*
\******************************************************************************/
#ifndef _GPIO5502_DAT_H_
  #define _GPIO5502_DAT_H_


#define _GPIO_PIN_GRPS         (4)
 
  typedef struct {
     Uint16 regIndx;
     Uint16 pinsAllocated;
     Uint16 *enableReg;
     Uint16 *dirReg;
     Uint16 *datReg;
  } GPIO_PrivateObj;

  #define CSL_GPIODATAINIT  {\
      0x0000u,            \
      0x0000u,            \
      (Uint16 *)0x0000u,  \
      (Uint16 *)0x3400u,  \
      (Uint16 *)0x3401u,  \
      0x0000u,            \
      0x0000u,            \
      (Uint16 *)0x4400u,  \
      (Uint16 *)0x4401u,  \
      (Uint16 *)0x4402u,  \
      0x0000u,            \
      0x0000u,            \
      (Uint16 *)0x4403u,  \
      (Uint16 *)0x4404u,  \
      (Uint16 *)0x4405u,  \
      0x0000u,            \
      0x0000u,            \
      (Uint16 *)0x4406u,  \
      (Uint16 *)0x4407u,  \
      (Uint16 *)0x4408u   \
  }

  typedef struct {
     GPIO_PrivateObj pinObj[_GPIO_PIN_GRPS];
  } CSL_GpioDataObj;

extern CSL_GpioDataObj   CSL_GpioData;

#define CSL_GPIO_DATA    CSL_GpioData

#endif

csl_gpio5502hal/1051539343  39    0     0       117992    `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpiohal.h
* DATE CREATED.. Mon 06/05/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. csl_stdinc.h, csl_chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       06/05/2000 (AP) created
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments  
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the GPIO module)
*
* Registers Covered:
*   (RW) _GPIO_IODIR
*   (RW) _GPIO_IODATA
\******************************************************************************/

#ifndef _GPIOHAL_H_
#define _GPIOHAL_H_

#include <csl_chiphal.h>

#if (_GPIO_SUPPORT)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _GPIO_IODIR
\*============================================================================*/
#define _GPIO_IODIR_ADDR				(0x3400u)
#define _GPIO_IODIR                       	PREG16(_GPIO_IODIR_ADDR)
#define _IODIR                              	_GPIO_IODIR

/*============================================================================*\
* (RW) _GPIO_IODATA
\*============================================================================*/
#define _GPIO_IODATA_ADDR				(0x3401u)
#define _GPIO_IODATA                       	PREG16(_GPIO_IODATA_ADDR)
#define _IODATA                              	_GPIO_IODATA

/*============================================================================*\
* Generic GPIO register/field get and set macros
\*============================================================================*/

#define GPIO_ADDR(Reg)                    _GPIO_##Reg##_ADDR
#define GPIO_RGET(Reg)                    _PREG_GET(GPIO_ADDR(##Reg))
#define GPIO_RSET(Reg,Val)                _PREG_SET(GPIO_ADDR(##Reg),Val)
#define GPIO_RAOI(Reg,AND,OR,INV)         _PREG_AOI(GPIO_ADDR(##Reg),AND,OR,INV)
#define GPIO_FGET(Reg,Field)              _PFIELD_GET(GPIO_ADDR(##Reg),_GPIO_##Reg##_##Field)
#define GPIO_FSET(Reg,Field,Val)\
   _PFIELD_SET(GPIO_ADDR(##Reg), _GPIO_##Reg##_##Field, Val)
#define GPIO_FSETS(Reg,Field,Sym)\
   GPIO_FSET(##Reg,##Field,GPIO_##Reg##_##Field##_##Sym)
#define GPIO_FAOI(Reg,Field,AND,OR,INV)  _PFIELD_AOI(GPIO_ADDR(##Reg),_GPIO_##Reg##_##Field,AND,OR,INV)
#define GPIO_FMK(Reg,Field,Val)          _GPIO_##Reg##_##Field##_MK(Val)
#define GPIO_FMKS(Reg,Field,Sym)         GPIO_FMK(##Reg,##Field,GPIO_##Reg##_##Field##_##Sym)

/*===========================================================================*\
* _GPIO_IODIR
*
* Fields:
*  (RW) _GPIO_IODIR_IO7DIR
*  (RW) _GPIO_IODIR_IO6DIR
*  (RW) _GPIO_IODIR_IO5DIR
*  (RW) _GPIO_IODIR_IO4DIR
*  (RW) _GPIO_IODIR_IO3DIR
*  (RW) _GPIO_IODIR_IO2DIR
*  (RW) _GPIO_IODIR_IO1DIR
*  (RW) _GPIO_IODIR_IO0DIR
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO7DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO7DIR_SHIFT		(0x0007u)
#define _GPIO_IODIR_IO7DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO7DIR_SHIFT)
#define _GPIO_IODIR_IO7DIR_MASK       	(_GPIO_IODIR_IO7DIR_MK(0x0001u))
#define _GPIO_IODIR_IO7DIR_CLR        	(~(_GPIO_IODIR_IO7DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO6DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO6DIR_SHIFT		(0x0006u)
#define _GPIO_IODIR_IO6DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO6DIR_SHIFT)
#define _GPIO_IODIR_IO6DIR_MASK       	(_GPIO_IODIR_IO6DIR_MK(0x0001u))
#define _GPIO_IODIR_IO6DIR_CLR        	(~(_GPIO_IODIR_IO6DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO5DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO5DIR_SHIFT		(0x0005u)
#define _GPIO_IODIR_IO5DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO5DIR_SHIFT)
#define _GPIO_IODIR_IO5DIR_MASK       	(_GPIO_IODIR_IO5DIR_MK(0x0001u))
#define _GPIO_IODIR_IO5DIR_CLR        	(~(_GPIO_IODIR_IO5DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO4DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO4DIR_SHIFT		(0x0004u)
#define _GPIO_IODIR_IO4DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO4DIR_SHIFT)
#define _GPIO_IODIR_IO4DIR_MASK       	(_GPIO_IODIR_IO4DIR_MK(0x0001u))
#define _GPIO_IODIR_IO4DIR_CLR        	(~(_GPIO_IODIR_IO4DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO3DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO3DIR_SHIFT		(0x0003u)
#define _GPIO_IODIR_IO3DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO3DIR_SHIFT)
#define _GPIO_IODIR_IO3DIR_MASK       	(_GPIO_IODIR_IO3DIR_MK(0x0001u))
#define _GPIO_IODIR_IO3DIR_CLR        	(~(_GPIO_IODIR_IO3DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO2DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO2DIR_SHIFT		(0x0002u)
#define _GPIO_IODIR_IO2DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO2DIR_SHIFT)
#define _GPIO_IODIR_IO2DIR_MASK       	(_GPIO_IODIR_IO2DIR_MK(0x0001u))
#define _GPIO_IODIR_IO2DIR_CLR        	(~(_GPIO_IODIR_IO2DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO1DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO1DIR_SHIFT		(0x0001u)
#define _GPIO_IODIR_IO1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO1DIR_SHIFT)
#define _GPIO_IODIR_IO1DIR_MASK       	(_GPIO_IODIR_IO1DIR_MK(0x0001u))
#define _GPIO_IODIR_IO1DIR_CLR        	(~(_GPIO_IODIR_IO1DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO0DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO0DIR_SHIFT		(0x0000u)
#define _GPIO_IODIR_IO0DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO0DIR_SHIFT)
#define _GPIO_IODIR_IO0DIR_MASK       	(_GPIO_IODIR_IO0DIR_MK(0x0001u))
#define _GPIO_IODIR_IO0DIR_CLR        	(~(_GPIO_IODIR_IO0DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODIR_ADDR,						\
    		(Uint16) (	_GPIO_IODIR_IO0DIR_MK(io0) 		|	\
				_GPIO_IODIR_IO1DIR_MK(io1) 		|	\
				_GPIO_IODIR_IO2DIR_MK(io2) 		|	\
				_GPIO_IODIR_IO3DIR_MK(io3) 		|	\
				_GPIO_IODIR_IO4DIR_MK(io4) 		|	\
				_GPIO_IODIR_IO5DIR_MK(io5) 		|	\
				_GPIO_IODIR_IO6DIR_MK(io6) 		|	\
				_GPIO_IODIR_IO7DIR_MK(io7) 			\
	             ))

/*===========================================================================*\
* _GPIO_IODATA
*
* Fields:
*  (RW) _GPIO_IODATA_IO7D
*  (RW) _GPIO_IODATA_IO6D
*  (RW) _GPIO_IODATA_IO5D
*  (RW) _GPIO_IODATA_IO4D
*  (RW) _GPIO_IODATA_IO3D
*  (RW) _GPIO_IODATA_IO2D
*  (RW) _GPIO_IODATA_IO1D
*  (RW) _GPIO_IODATA_IO0D
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO7D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO7D_SHIFT		(0x0007u)
#define _GPIO_IODATA_IO7D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO7D_SHIFT)
#define _GPIO_IODATA_IO7D_MASK       	(_GPIO_IODATA_IO7D_MK(0x0001u))
#define _GPIO_IODATA_IO7D_CLR        	(~(_GPIO_IODATA_IO7D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO6D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO6D_SHIFT		(0x0006u)
#define _GPIO_IODATA_IO6D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO6D_SHIFT)
#define _GPIO_IODATA_IO6D_MASK       	(_GPIO_IODATA_IO6D_MK(0x0001u))
#define _GPIO_IODATA_IO6D_CLR        	(~(_GPIO_IODATA_IO6D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO5D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO5D_SHIFT		(0x0005u)
#define _GPIO_IODATA_IO5D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO5D_SHIFT)
#define _GPIO_IODATA_IO5D_MASK       	(_GPIO_IODATA_IO5D_MK(0x0001u))
#define _GPIO_IODATA_IO5D_CLR        	(~(_GPIO_IODATA_IO5D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO4D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO4D_SHIFT		(0x0004u)
#define _GPIO_IODATA_IO4D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO4D_SHIFT)
#define _GPIO_IODATA_IO4D_MASK       	(_GPIO_IODATA_IO4D_MK(0x0001u))
#define _GPIO_IODATA_IO4D_CLR        	(~(_GPIO_IODATA_IO4D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO3D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO3D_SHIFT		(0x0003u)
#define _GPIO_IODATA_IO3D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO3D_SHIFT)
#define _GPIO_IODATA_IO3D_MASK       	(_GPIO_IODATA_IO3D_MK(0x0001u))
#define _GPIO_IODATA_IO3D_CLR        	(~(_GPIO_IODATA_IO3D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO2D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO2D_SHIFT		(0x0002u)
#define _GPIO_IODATA_IO2D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO2D_SHIFT)
#define _GPIO_IODATA_IO2D_MASK       	(_GPIO_IODATA_IO2D_MK(0x0001u))
#define _GPIO_IODATA_IO2D_CLR        	(~(_GPIO_IODATA_IO2D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO1D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO1D_SHIFT		(0x0001u)
#define _GPIO_IODATA_IO1D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO1D_SHIFT)
#define _GPIO_IODATA_IO1D_MASK       	(_GPIO_IODATA_IO1D_MK(0x0001u))
#define _GPIO_IODATA_IO1D_CLR        	(~(_GPIO_IODATA_IO1D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO0D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO0D_SHIFT		(0x0000u)
#define _GPIO_IODATA_IO0D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO0D_SHIFT)
#define _GPIO_IODATA_IO0D_MASK       	(_GPIO_IODATA_IO0D_MK(0x0001u))
#define _GPIO_IODATA_IO0D_CLR        	(~(_GPIO_IODATA_IO0D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA 	- Config
\*--------------------------------------------------------------------------*/

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO7DAT
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO7DAT_SHIFT		(0x0007u)
#define _GPIO_IODATA_IO7DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO7DAT_SHIFT)
#define _GPIO_IODATA_IO7DAT_MASK       	(_GPIO_IODATA_IO7DAT_MK(0x0001u))
#define _GPIO_IODATA_IO7DAT_CLR        	(~(_GPIO_IODATA_IO7DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO6DAT
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO6DAT_SHIFT		(0x0006u)
#define _GPIO_IODATA_IO6DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO6DAT_SHIFT)
#define _GPIO_IODATA_IO6DAT_MASK       	(_GPIO_IODATA_IO6DAT_MK(0x0001u))
#define _GPIO_IODATA_IO6DAT_CLR        	(~(_GPIO_IODATA_IO6DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO5DAT
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO5DAT_SHIFT		(0x0005u)
#define _GPIO_IODATA_IO5DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO5DAT_SHIFT)
#define _GPIO_IODATA_IO5DAT_MASK       	(_GPIO_IODATA_IO5DAT_MK(0x0001u))
#define _GPIO_IODATA_IO5DAT_CLR        	(~(_GPIO_IODATA_IO5DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO4DAT
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO4DAT_SHIFT		(0x0004u)
#define _GPIO_IODATA_IO4DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO4DAT_SHIFT)
#define _GPIO_IODATA_IO4DAT_MASK       	(_GPIO_IODATA_IO4DAT_MK(0x0001u))
#define _GPIO_IODATA_IO4DAT_CLR        	(~(_GPIO_IODATA_IO4DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO3D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO3DAT_SHIFT		(0x0003u)
#define _GPIO_IODATA_IO3DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO3DAT_SHIFT)
#define _GPIO_IODATA_IO3DAT_MASK       	(_GPIO_IODATA_IO3DAT_MK(0x0001u))
#define _GPIO_IODATA_IO3DAT_CLR        	(~(_GPIO_IODATA_IO3DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO2D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO2DAT_SHIFT		(0x0002u)
#define _GPIO_IODATA_IO2DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO2DAT_SHIFT)
#define _GPIO_IODATA_IO2DAT_MASK       	(_GPIO_IODATA_IO2DAT_MK(0x0001u))
#define _GPIO_IODATA_IO2DAT_CLR        	(~(_GPIO_IODATA_IO2DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO1D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO1DAT_SHIFT		(0x0001u)
#define _GPIO_IODATA_IO1DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO1DAT_SHIFT)
#define _GPIO_IODATA_IO1DAT_MASK       	(_GPIO_IODATA_IO1DAT_MK(0x0001u))
#define _GPIO_IODATA_IO1DAT_CLR        	(~(_GPIO_IODATA_IO1DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO0D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO0DAT_SHIFT		(0x0000u)
#define _GPIO_IODATA_IO0DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO0DAT_SHIFT)
#define _GPIO_IODATA_IO0DAT_MASK       	(_GPIO_IODATA_IO0DAT_MK(0x0001u))
#define _GPIO_IODATA_IO0DAT_CLR        	(~(_GPIO_IODATA_IO0DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODATA_ADDR,						\
    		(Uint16) (	_GPIO_IODATA_IO0DAT_MK(io0) 		|	\
				_GPIO_IODATA_IO1DAT_MK(io1) 		|	\
				_GPIO_IODATA_IO2DAT_MK(io2) 		|	\
				_GPIO_IODATA_IO3DAT_MK(io3) 		|	\
				_GPIO_IODATA_IO4DAT_MK(io4) 		|	\
				_GPIO_IODATA_IO5DAT_MK(io5) 		|	\
				_GPIO_IODATA_IO6DAT_MK(io6) 		|	\
				_GPIO_IODATA_IO7DAT_MK(io7) 			\
	             ))


#if (_GPIO_PARALLEL_SUPPORT)


/*============================================================================*\
* (RW) _GPIO_GPIOEN
\*============================================================================*/
#define _GPIO_GPIOEN_ADDR				(0x4403u)
#define _GPIO_GPIOEN                       	PREG16(_GPIO_GPIOEN_ADDR)
#define _GPIOEN                              	_GPIO_GPIOEN

/*============================================================================*\
* (RW) _GPIO_GPIODIR
\*============================================================================*/
#define _GPIO_GPIODIR_ADDR				(0x4404u)
#define _GPIO_GPIODIR                       	PREG16(_GPIO_GPIODIR_ADDR)
#define _GPIODIR                              	_GPIO_GPIODIR

/*============================================================================*\
* (RW) _GPIO_GPIODATA
\*============================================================================*/
#define _GPIO_GPIODATA_ADDR				(0x4405u)
#define _GPIO_GPIODATA                       	PREG16(_GPIO_GPIODATA_ADDR)
#define _GPIODATA                            	_GPIO_GPIODATA


/*============================================================================*\
* Generic GPIO register/field get and set macros
\*============================================================================*/

/*===========================================================================*\
* _GPIO_GPIODIR
*
* Fields:
*  (RW) _GPIO_GPIODIR_IO13DIR
*  (RW) _GPIO_GPIODIR_IO12DIR
*  (RW) _GPIO_GPIODIR_IO11DIR
*  (RW) _GPIO_GPIODIR_IO10DIR
*  (RW) _GPIO_GPIODIR_IO9DIR
*  (RW) _GPIO_GPIODIR_IO8DIR
\*==========================================================================*/


/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO13DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO13DIR_SHIFT		(0x0005u)
#define _GPIO_GPIODIR_IO13DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO13DIR_SHIFT)
#define _GPIO_GPIODIR_IO13DIR_MASK       	(_GPIO_GPIODIR_IO13DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO13DIR_CLR        	(~(_GPIO_GPIODIR_IO13DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO12DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO12DIR_SHIFT		(0x0004u)
#define _GPIO_GPIODIR_IO12DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO12DIR_SHIFT)
#define _GPIO_GPIODIR_IO12DIR_MASK       	(_GPIO_GPIODIR_IO12DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO12DIR_CLR        	(~(_GPIO_GPIODIR_IO12DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO11DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO11DIR_SHIFT		(0x0003u)
#define _GPIO_GPIODIR_IO11DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO11DIR_SHIFT)
#define _GPIO_GPIODIR_IO11DIR_MASK       	(_GPIO_GPIODIR_IO11DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO11DIR_CLR        	(~(_GPIO_GPIODIR_IO11DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO10DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO10DIR_SHIFT		(0x0002u)
#define _GPIO_GPIODIR_IO10DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO10DIR_SHIFT)
#define _GPIO_GPIODIR_IO10DIR_MASK       	(_GPIO_GPIODIR_IO10DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO10DIR_CLR        	(~(_GPIO_GPIODIR_IO10DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO9DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO9DIR_SHIFT		(0x0001u)
#define _GPIO_GPIODIR_IO9DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO9DIR_SHIFT)
#define _GPIO_GPIODIR_IO9DIR_MASK       	(_GPIO_GPIODIR_IO9DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO9DIR_CLR        	(~(_GPIO_GPIODIR_IO9DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR_IO8DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_IO8DIR_SHIFT		(0x0000u)
#define _GPIO_GPIODIR_IO8DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODIR_IO8DIR_SHIFT)
#define _GPIO_GPIODIR_IO8DIR_MASK       	(_GPIO_GPIODIR_IO8DIR_MK(0x0001u))
#define _GPIO_GPIODIR_IO8DIR_CLR        	(~(_GPIO_GPIODIR_IO8DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODIR 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODIR_CFG(io8,io9,io10,io11,io12,io13)  \
	HPREG_SET(_GPIO_GPIODIR_ADDR,						\
    		(Uint16) (	_GPIO_GPIODIR_IO0DIR_MK(io8) 		|	\
				_GPIO_GPIODIR_IO1DIR_MK(io9) 		|	\
				_GPIO_GPIODIR_IO2DIR_MK(io10) 		|	\
				_GPIO_GPIODIR_IO3DIR_MK(io11) 		|	\
				_GPIO_GPIODIR_IO4DIR_MK(io12) 		|	\
				_GPIO_GPIODIR_IO5DIR_MK(io13) 		|	\
				_GPIO_GPIODIR_IO6DIR_MK(io14) 		|	\
				_GPIO_GPIODIR_IO7DIR_MK(io15) 			\
	             ))

/*===========================================================================*\
* _GPIO_GPIODATA
*
* Fields:
*  (RW) _GPIO_GPIODATA_IO13D
*  (RW) _GPIO_GPIODATA_IO12D
*  (RW) _GPIO_GPIODATA_IO11D
*  (RW) _GPIO_GPIODATA_IO10D
*  (RW) _GPIO_GPIODATA_IO9D
*  (RW) _GPIO_GPIODATA_IO8D
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO13D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO13D_SHIFT		(0x0005u)
#define _GPIO_GPIODATA_IO13D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO13D_SHIFT)
#define _GPIO_GPIODATA_IO13D_MASK       	(_GPIO_GPIODATA_IO13D_MK(0x0001u))
#define _GPIO_GPIODATA_IO13D_CLR        	(~(_GPIO_GPIODATA_IO13D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO12D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO12D_SHIFT		(0x0004u)
#define _GPIO_GPIODATA_IO12D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO12D_SHIFT)
#define _GPIO_GPIODATA_IO12D_MASK       	(_GPIO_GPIODATA_IO12D_MK(0x0001u))
#define _GPIO_GPIODATA_IO12D_CLR        	(~(_GPIO_GPIODATA_IO12D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO11D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO11D_SHIFT		(0x0003u)
#define _GPIO_GPIODATA_IO11D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO11D_SHIFT)
#define _GPIO_GPIODATA_IO11D_MASK       	(_GPIO_GPIODATA_IO11D_MK(0x0001u))
#define _GPIO_GPIODATA_IO11D_CLR        	(~(_GPIO_GPIODATA_IO11D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO10D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO10D_SHIFT		(0x0002u)
#define _GPIO_GPIODATA_IO10D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO10D_SHIFT)
#define _GPIO_GPIODATA_IO10D_MASK       	(_GPIO_GPIODATA_IO10D_MK(0x0001u))
#define _GPIO_GPIODATA_IO10D_CLR        	(~(_GPIO_GPIODATA_IO10D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO9D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO9D_SHIFT		(0x0001u)
#define _GPIO_GPIODATA_IO9D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO9D_SHIFT)
#define _GPIO_GPIODATA_IO9D_MASK       	(_GPIO_GPIODATA_IO9D_MK(0x0001u))
#define _GPIO_GPIODATA_IO9D_CLR        	(~(_GPIO_GPIODATA_IO9D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO8D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO8D_SHIFT		(0x0000u)
#define _GPIO_GPIODATA_IO8D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO8D_SHIFT)
#define _GPIO_GPIODATA_IO8D_MASK       	(_GPIO_GPIODATA_IO8D_MK(0x0001u))
#define _GPIO_GPIODATA_IO8D_CLR        	(~(_GPIO_GPIODATA_IO8D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_CFG(io8,io9,io10,io11,io12,io13)  \
	HPREG_SET(_GPIO_GPIODATA_ADDR,						\
    		(Uint16) (	_GPIO_GPIODATA_IO8D_MK(io8) 		|	\
				_GPIO_GPIODATA_IO9D_MK(io9) 		|	\
				_GPIO_GPIODATA_IO10D_MK(io10) 		|	\
				_GPIO_GPIODATA_IO11D_MK(io11) 		|	\
				_GPIO_GPIODATA_IO12D_MK(io12) 		|	\
				_GPIO_GPIODATA_IO13D_MK(io13) 			\
	             ))

/*===============================================================*\
* Use new IODATA bit field nomenclature
\*===============================================================*/

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO13DAT
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO13DAT_SHIFT		(0x0005u)
#define _GPIO_GPIODATA_IO13DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO13DAT_SHIFT)
#define _GPIO_GPIODATA_IO13DAT_MASK       	(_GPIO_GPIODATA_IO13DAT_MK(0x0001u))
#define _GPIO_GPIODATA_IO13DAT_CLR        	(~(_GPIO_GPIODATA_IO13DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO12D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO12DAT_SHIFT		(0x0004u)
#define _GPIO_GPIODATA_IO12DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO12DAT_SHIFT)
#define _GPIO_GPIODATA_IO12DAT_MASK       	(_GPIO_GPIODATA_IO12DAT_MK(0x0001u))
#define _GPIO_GPIODATA_IO12DAT_CLR        	(~(_GPIO_GPIODATA_IO12DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO11D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO11DAT_SHIFT		(0x0003u)
#define _GPIO_GPIODATA_IO11DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO11DAT_SHIFT)
#define _GPIO_GPIODATA_IO11DAT_MASK       	(_GPIO_GPIODATA_IO11DAT_MK(0x0001u))
#define _GPIO_GPIODATA_IO11DAT_CLR        	(~(_GPIO_GPIODATA_IO11DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO10D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO10DAT_SHIFT		(0x0002u)
#define _GPIO_GPIODATA_IO10DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO10DAT_SHIFT)
#define _GPIO_GPIODATA_IO10DAT_MASK       	(_GPIO_GPIODATA_IO10DAT_MK(0x0001u))
#define _GPIO_GPIODATA_IO10DAT_CLR        	(~(_GPIO_GPIODATA_IO10DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO9D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO9DAT_SHIFT		(0x0001u)
#define _GPIO_GPIODATA_IO9DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO9DAT_SHIFT)
#define _GPIO_GPIODATA_IO9DAT_MASK       	(_GPIO_GPIODATA_IO9DAT_MK(0x0001u))
#define _GPIO_GPIODATA_IO9DAT_CLR        	(~(_GPIO_GPIODATA_IO9DAT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIODATA_IO8D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIODATA_IO8DAT_SHIFT		(0x0000u)
#define _GPIO_GPIODATA_IO8DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIODATA_IO8DAT_SHIFT)
#define _GPIO_GPIODATA_IO8DAT_MASK       	(_GPIO_GPIODATA_IO8DAT_MK(0x0001u))
#define _GPIO_GPIODATA_IO8DAT_CLR        	(~(_GPIO_GPIODATA_IO8DAT_MK(0x0001u)))

/*===========================================================================*\
* _GPIO_GPIOEN
*
* Fields:
*  (RW) _GPIO_GPIOEN_IO13
*  (RW) _GPIO_GPIOEN_IO12
*  (RW) _GPIO_GPIOEN_IO11
*  (RW) _GPIO_GPIOEN_IO10
*  (RW) _GPIO_GPIOEN_IO9
*  (RW) _GPIO_GPIOEN_IO8
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO13
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO13_SHIFT		(0x0005u)
#define _GPIO_GPIOEN_IO13_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO13_SHIFT)
#define _GPIO_GPIOEN_IO13_MASK       	(_GPIO_GPIOEN_IO13_MK(0x0001u))
#define _GPIO_GPIOEN_IO13_CLR        	(~(_GPIO_GPIOEN_IO13_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO12
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO12_SHIFT		(0x0004u)
#define _GPIO_GPIOEN_IO12_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO12_SHIFT)
#define _GPIO_GPIOEN_IO12_MASK       	(_GPIO_GPIOEN_IO12_MK(0x0001u))
#define _GPIO_GPIOEN_IO12_CLR        	(~(_GPIO_GPIOEN_IO12_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO11
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO11_SHIFT		(0x0003u)
#define _GPIO_GPIOEN_IO11_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO11_SHIFT)
#define _GPIO_GPIOEN_IO11_MASK       	(_GPIO_GPIOEN_IO11_MK(0x0001u))
#define _GPIO_GPIOEN_IO11_CLR        	(~(_GPIO_GPIOEN_IO11_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO10
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO10_SHIFT		(0x0002u)
#define _GPIO_GPIOEN_IO10_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO10_SHIFT)
#define _GPIO_GPIOEN_IO10_MASK       	(_GPIO_GPIOEN_IO10_MK(0x0001u))
#define _GPIO_GPIOEN_IO10_CLR        	(~(_GPIO_GPIOEN_IO10_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO9
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO9_SHIFT		(0x0001u)
#define _GPIO_GPIOEN_IO9_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO9_SHIFT)
#define _GPIO_GPIOEN_IO9_MASK       	(_GPIO_GPIOEN_IO9_MK(0x0001u))
#define _GPIO_GPIOEN_IO9_CLR        	(~(_GPIO_GPIOEN_IO9_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO8D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO8_SHIFT		(0x0000u)
#define _GPIO_GPIOEN_IO8_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO8_SHIFT)
#define _GPIO_GPIOEN_IO8_MASK       	(_GPIO_GPIOEN_IO8_MK(0x0001u))
#define _GPIO_GPIOEN_IO8_CLR        	(~(_GPIO_GPIOEN_IO8_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN 	- Config
\*--------------------------------------------------------------------------*/

/*===========================================================================*\
* _GPIO_GPIOEN
*
* Fields:
*  (RW) _GPIO_GPIOEN_IO13
*  (RW) _GPIO_GPIOEN_IO12
*  (RW) _GPIO_GPIOEN_IO11
*  (RW) _GPIO_GPIOEN_IO10
*  (RW) _GPIO_GPIOEN_IO9
*  (RW) _GPIO_GPIOEN_IO8
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO13EN
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO13EN_SHIFT		(0x0005u)
#define _GPIO_GPIOEN_IO13EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO13EN_SHIFT)
#define _GPIO_GPIOEN_IO13EN_MASK       	(_GPIO_GPIOEN_IO13EN_MK(0x0001u))
#define _GPIO_GPIOEN_IO13EN_CLR        	(~(_GPIO_GPIOEN_IO13EN_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO12
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO12EN_SHIFT		(0x0004u)
#define _GPIO_GPIOEN_IO12EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO12EN_SHIFT)
#define _GPIO_GPIOEN_IO12EN_MASK       	(_GPIO_GPIOEN_IO12EN_MK(0x0001u))
#define _GPIO_GPIOEN_IO12EN_CLR        	(~(_GPIO_GPIOEN_IO12EN_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO11
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO11EN_SHIFT		(0x0003u)
#define _GPIO_GPIOEN_IO11EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO11EN_SHIFT)
#define _GPIO_GPIOEN_IO11EN_MASK       	(_GPIO_GPIOEN_IO11EN_MK(0x0001u))
#define _GPIO_GPIOEN_IO11EN_CLR        	(~(_GPIO_GPIOEN_IO11EN_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO10
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO10EN_SHIFT		(0x0002u)
#define _GPIO_GPIOEN_IO10EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO10EN_SHIFT)
#define _GPIO_GPIOEN_IO10EN_MASK       	(_GPIO_GPIOEN_IO10EN_MK(0x0001u))
#define _GPIO_GPIOEN_IO10EN_CLR        	(~(_GPIO_GPIOEN_IO10EN_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO9
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO9EN_SHIFT		(0x0001u)
#define _GPIO_GPIOEN_IO9EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO9EN_SHIFT)
#define _GPIO_GPIOEN_IO9EN_MASK       	(_GPIO_GPIOEN_IO9EN_MK(0x0001u))
#define _GPIO_GPIOEN_IO9EN_CLR        	(~(_GPIO_GPIOEN_IO9EN_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN_IO8D
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_IO8EN_SHIFT		(0x0000u)
#define _GPIO_GPIOEN_IO8EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_GPIOEN_IO8EN_SHIFT)
#define _GPIO_GPIOEN_IO8EN_MASK       	(_GPIO_GPIOEN_IO8EN_MK(0x0001u))
#define _GPIO_GPIOEN_IO8EN_CLR        	(~(_GPIO_GPIOEN_IO8EN_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_GPIOEN 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_GPIOEN_CFG(io8,io9,io10,io11,io12,io13)  \
	HPREG_SET(_GPIO_GPIOEN_ADDR,						\
    		(Uint16) (	_GPIO_GPIOEN_IO8EN_MK(io8) 		|	\
				_GPIO_GPIOEN_IO9EN_MK(io9) 		|	\
				_GPIO_GPIOEN_IO10EN_MK(io10) 		|	\
				_GPIO_GPIOEN_IO11EN_MK(io11) 		|	\
				_GPIO_GPIOEN_IO12EN_MK(io12) 		|	\
				_GPIO_GPIOEN_IO13EN_MK(io13) 			\
	             ))



/*----------------------------------------------------------------*\
*		 Address Macros			
\*----------------------------------------------------------------*/

/*--------------------- Register: PGPIOEN0 -----------------------*/
#define _GPIO_PGPIOEN0_ADDR		(0x4400u)
#define _GPIO_PGPIOEN0			PREG16(_GPIO_PGPIOEN0_ADDR)
#define PGPIOEN0			_GPIO_PGPIOEN0


/*--------------------- Register: PGPIODIR0 -----------------------*/
#define _GPIO_PGPIODIR0_ADDR		(0x4401u)
#define _GPIO_PGPIODIR0			PREG16(_GPIO_PGPIODIR0_ADDR)
#define PGPIODIR0			_GPIO_PGPIODIR0


/*--------------------- Register: PGPIODAT0 -----------------------*/
#define _GPIO_PGPIODAT0_ADDR		(0x4402u)
#define _GPIO_PGPIODAT0			PREG16(_GPIO_PGPIODAT0_ADDR)
#define PGPIODAT0			_GPIO_PGPIODAT0


/*--------------------- Register: PGPIOEN1 -----------------------*/
#define _GPIO_PGPIOEN1_ADDR		(0x4403u)
#define _GPIO_PGPIOEN1			PREG16(_GPIO_PGPIOEN1_ADDR)
#define PGPIOEN1			_GPIO_PGPIOEN1


/*--------------------- Register: PGPIODIR1 -----------------------*/
#define _GPIO_PGPIODIR1_ADDR		(0x4404u)
#define _GPIO_PGPIODIR1			PREG16(_GPIO_PGPIODIR1_ADDR)
#define PGPIODIR1			_GPIO_PGPIODIR1


/*--------------------- Register: PGPIODAT1 -----------------------*/
#define _GPIO_PGPIODAT1_ADDR		(0x4405u)
#define _GPIO_PGPIODAT1			PREG16(_GPIO_PGPIODAT1_ADDR)
#define PGPIODAT1			_GPIO_PGPIODAT1


/*--------------------- Register: PGPIOEN2 -----------------------*/
#define _GPIO_PGPIOEN2_ADDR		(0x4406u)
#define _GPIO_PGPIOEN2			PREG16(_GPIO_PGPIOEN2_ADDR)
#define PGPIOEN2			_GPIO_PGPIOEN2


/*--------------------- Register: PGPIODIR2 -----------------------*/
#define _GPIO_PGPIODIR2_ADDR		(0x4407u)
#define _GPIO_PGPIODIR2			PREG16(_GPIO_PGPIODIR2_ADDR)
#define PGPIODIR2			_GPIO_PGPIODIR2


/*--------------------- Register: PGPIODAT2 -----------------------*/
#define _GPIO_PGPIODAT2_ADDR		(0x4408u)
#define _GPIO_PGPIODAT2			PREG16(_GPIO_PGPIODAT2_ADDR)
#define PGPIODAT2			_GPIO_PGPIODAT2



/*----------------------------------------------------------------*\
*		 Register Macros		
\*----------------------------------------------------------------*/

/*--------------------- Register: PGPIOEN0 -----------------------*/
#define _GPIO_PGPIOEN0_GET		  _PREG_GET(_GPIO_PGPIOEN0_ADDR) 
#define _GPIO_PGPIOEN0_SET(Val)		  _PREG_SET(_GPIO_PGPIOEN0_ADDR,Val)
#define _GPIO_PGPIOEN0_FGET(Field)	  _PFIELD_GET(_GPIO_PGPIOEN0_ADDR, _GPIO_PGPIOEN0_##Field)
#define _GPIO_PGPIOEN0_FSET(Field,Val)	  _PFIELD_SET(_GPIO_PGPIOEN0_ADDR, _GPIO_PGPIOEN0_##Field, Val)
#define _GPIO_PGPIOEN0_AOI(AND,OR,INV)	  _PREG_AOI(_GPIO_PGPIOEN0_ADDR,AND,OR,INV)
#define _GPIO_PGPIOEN0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPIO_PGPIOEN0_ADDR, _GPIO_PGPIOEN0_##Field,AND,OR,INV)


/*--------------------- Register: PGPIODIR0 -----------------------*/
#define _GPIO_PGPIODIR0_GET		  _PREG_GET(_GPIO_PGPIODIR0_ADDR) 
#define _GPIO_PGPIODIR0_SET(Val)		  _PREG_SET(_GPIO_PGPIODIR0_ADDR,Val)
#define _GPIO_PGPIODIR0_FGET(Field)	  _PFIELD_GET(_GPIO_PGPIODIR0_ADDR, _GPIO_PGPIODIR0_##Field)
#define _GPIO_PGPIODIR0_FSET(Field,Val)	  _PFIELD_SET(_GPIO_PGPIODIR0_ADDR, _GPIO_PGPIODIR0_##Field, Val)
#define _GPIO_PGPIODIR0_AOI(AND,OR,INV)	  _PREG_AOI(_GPIO_PGPIODIR0_ADDR,AND,OR,INV)
#define _GPIO_PGPIODIR0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPIO_PGPIODIR0_ADDR, _GPIO_PGPIODIR0_##Field,AND,OR,INV)


/*--------------------- Register: PGPIODAT0 -----------------------*/
#define _GPIO_PGPIODAT0_GET		  _PREG_GET(_GPIO_PGPIODAT0_ADDR) 
#define _GPIO_PGPIODAT0_SET(Val)		  _PREG_SET(_GPIO_PGPIODAT0_ADDR,Val)
#define _GPIO_PGPIODAT0_FGET(Field)	  _PFIELD_GET(_GPIO_PGPIODAT0_ADDR, _GPIO_PGPIODAT0_##Field)
#define _GPIO_PGPIODAT0_FSET(Field,Val)	  _PFIELD_SET(_GPIO_PGPIODAT0_ADDR, _GPIO_PGPIODAT0_##Field, Val)
#define _GPIO_PGPIODAT0_AOI(AND,OR,INV)	  _PREG_AOI(_GPIO_PGPIODAT0_ADDR,AND,OR,INV)
#define _GPIO_PGPIODAT0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPIO_PGPIODAT0_ADDR, _GPIO_PGPIODAT0_##Field,AND,OR,INV)


/*--------------------- Register: PGPIOEN1 -----------------------*/
#define _GPIO_PGPIOEN1_GET		  _PREG_GET(_GPIO_PGPIOEN1_ADDR) 
#define _GPIO_PGPIOEN1_SET(Val)		  _PREG_SET(_GPIO_PGPIOEN1_ADDR,Val)
#define _GPIO_PGPIOEN1_FGET(Field)	  _PFIELD_GET(_GPIO_PGPIOEN1_ADDR, _GPIO_PGPIOEN1_##Field)
#define _GPIO_PGPIOEN1_FSET(Field,Val)	  _PFIELD_SET(_GPIO_PGPIOEN1_ADDR, _GPIO_PGPIOEN1_##Field, Val)
#define _GPIO_PGPIOEN1_AOI(AND,OR,INV)	  _PREG_AOI(_GPIO_PGPIOEN1_ADDR,AND,OR,INV)
#define _GPIO_PGPIOEN1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPIO_PGPIOEN1_ADDR, _GPIO_PGPIOEN1_##Field,AND,OR,INV)


/*--------------------- Register: PGPIODIR1 -----------------------*/
#define _GPIO_PGPIODIR1_GET		  _PREG_GET(_GPIO_PGPIODIR1_ADDR) 
#define _GPIO_PGPIODIR1_SET(Val)		  _PREG_SET(_GPIO_PGPIODIR1_ADDR,Val)
#define _GPIO_PGPIODIR1_FGET(Field)	  _PFIELD_GET(_GPIO_PGPIODIR1_ADDR, _GPIO_PGPIODIR1_##Field)
#define _GPIO_PGPIODIR1_FSET(Field,Val)	  _PFIELD_SET(_GPIO_PGPIODIR1_ADDR, _GPIO_PGPIODIR1_##Field, Val)
#define _GPIO_PGPIODIR1_AOI(AND,OR,INV)	  _PREG_AOI(_GPIO_PGPIODIR1_ADDR,AND,OR,INV)
#define _GPIO_PGPIODIR1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPIO_PGPIODIR1_ADDR, _GPIO_PGPIODIR1_##Field,AND,OR,INV)


/*--------------------- Register: PGPIODAT1 -----------------------*/
#define _GPIO_PGPIODAT1_GET		  _PREG_GET(_GPIO_PGPIODAT1_ADDR) 
#define _GPIO_PGPIODAT1_SET(Val)		  _PREG_SET(_GPIO_PGPIODAT1_ADDR,Val)
#define _GPIO_PGPIODAT1_FGET(Field)	  _PFIELD_GET(_GPIO_PGPIODAT1_ADDR, _GPIO_PGPIODAT1_##Field)
#define _GPIO_PGPIODAT1_FSET(Field,Val)	  _PFIELD_SET(_GPIO_PGPIODAT1_ADDR, _GPIO_PGPIODAT1_##Field, Val)
#define _GPIO_PGPIODAT1_AOI(AND,OR,INV)	  _PREG_AOI(_GPIO_PGPIODAT1_ADDR,AND,OR,INV)
#define _GPIO_PGPIODAT1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPIO_PGPIODAT1_ADDR, _GPIO_PGPIODAT1_##Field,AND,OR,INV)


/*--------------------- Register: PGPIOEN2 -----------------------*/
#define _GPIO_PGPIOEN2_GET		  _PREG_GET(_GPIO_PGPIOEN2_ADDR) 
#define _GPIO_PGPIOEN2_SET(Val)		  _PREG_SET(_GPIO_PGPIOEN2_ADDR,Val)
#define _GPIO_PGPIOEN2_FGET(Field)	  _PFIELD_GET(_GPIO_PGPIOEN2_ADDR, _GPIO_PGPIOEN2_##Field)
#define _GPIO_PGPIOEN2_FSET(Field,Val)	  _PFIELD_SET(_GPIO_PGPIOEN1_ADDR, _GPIO_PGPIOEN2_##Field, Val)
#define _GPIO_PGPIOEN2_AOI(AND,OR,INV)	  _PREG_AOI(_GPIO_PGPIOEN2_ADDR,AND,OR,INV)
#define _GPIO_PGPIOEN2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPIO_PGPIOEN2_ADDR, _GPIO_PGPIOEN2_##Field,AND,OR,INV)


/*--------------------- Register: PGPIODIR2 -----------------------*/
#define _GPIO_PGPIODIR2_GET		  _PREG_GET(_GPIO_PGPIODIR2_ADDR) 
#define _GPIO_PGPIODIR2_SET(Val)		  _PREG_SET(_GPIO_PGPIODIR2_ADDR,Val)
#define _GPIO_PGPIODIR2_FGET(Field)	  _PFIELD_GET(_GPIO_PGPIODIR2_ADDR, _GPIO_PGPIODIR2_##Field)
#define _GPIO_PGPIODIR2_FSET(Field,Val)	  _PFIELD_SET(_GPIO_PGPIODIR2_ADDR, _GPIO_PGPIODIR2_##Field, Val)
#define _GPIO_PGPIODIR2_AOI(AND,OR,INV)	  _PREG_AOI(_GPIO_PGPIODIR2_ADDR,AND,OR,INV)
#define _GPIO_PGPIODIR2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPIO_PGPIODIR2_ADDR, _GPIO_PGPIODIR2_##Field,AND,OR,INV)


/*--------------------- Register: PGPIODAT2 -----------------------*/
#define _GPIO_PGPIODAT2_GET		  _PREG_GET(_GPIO_PGPIODAT2_ADDR) 
#define _GPIO_PGPIODAT2_SET(Val)		  _PREG_SET(_GPIO_PGPIODAT2_ADDR,Val)
#define _GPIO_PGPIODAT2_FGET(Field)	  _PFIELD_GET(_GPIO_PGPIODAT2_ADDR, _GPIO_PGPIODAT2_##Field)
#define _GPIO_PGPIODAT2_FSET(Field,Val)	  _PFIELD_SET(_GPIO_PGPIODAT2_ADDR, _GPIO_PGPIODAT2_##Field, Val)
#define _GPIO_PGPIODAT2_AOI(AND,OR,INV)	  _PREG_AOI(_GPIO_PGPIODAT2_ADDR,AND,OR,INV)
#define _GPIO_PGPIODAT2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPIO_PGPIODAT2_ADDR, _GPIO_PGPIODAT2_##Field,AND,OR,INV)



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PGPIOEN1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPIO_PGPIOEN2	 - Note: Add description here
*
* Fields:
*	(RW)   _GPIO_PGPIOEN2_IO32EN	
*	(RW)   _GPIO_PGPIOEN2_IO33EN	
*	(RW)   _GPIO_PGPIOEN2_IO34EN	
*	(RW)   _GPIO_PGPIOEN2_IO35EN	
*	(RW)   _GPIO_PGPIOEN2_IO36EN	
*	(RW)   _GPIO_PGPIOEN2_IO37EN	
*	(RW)   _GPIO_PGPIOEN2_IO38EN	
*	(RW)   _GPIO_PGPIOEN2_IO39EN	
*	(RW)   _GPIO_PGPIOEN2_IO40EN	
*	(RW)   _GPIO_PGPIOEN2_IO41EN	
*	(RW)   _GPIO_PGPIOEN2_IO42EN	
*	(RW)   _GPIO_PGPIOEN2_IO43EN	
*	(RW)   _GPIO_PGPIOEN2_IO44EN	
*	(RW)   _GPIO_PGPIOEN2_IO45EN	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO32EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO32EN_SHIFT		(000000u)
#define _GPIO_PGPIOEN2_IO32EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO32EN_SHIFT)
#define _GPIO_PGPIOEN2_IO32EN_MASK		(_GPIO_PGPIOEN2_IO32EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO32EN_CLR		(~(_GPIO_PGPIOEN2_IO32EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO33EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO33EN_SHIFT		(0x0001u)
#define _GPIO_PGPIOEN2_IO33EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO33EN_SHIFT)
#define _GPIO_PGPIOEN2_IO33EN_MASK		(_GPIO_PGPIOEN2_IO33EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO33EN_CLR		(~(_GPIO_PGPIOEN2_IO33EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO34EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO34EN_SHIFT		(0x0002u)
#define _GPIO_PGPIOEN2_IO34EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO34EN_SHIFT)
#define _GPIO_PGPIOEN2_IO34EN_MASK		(_GPIO_PGPIOEN2_IO34EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO34EN_CLR		(~(_GPIO_PGPIOEN2_IO34EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO35EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO35EN_SHIFT		(0x0003u)
#define _GPIO_PGPIOEN2_IO35EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO35EN_SHIFT)
#define _GPIO_PGPIOEN2_IO35EN_MASK		(_GPIO_PGPIOEN2_IO35EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO35EN_CLR		(~(_GPIO_PGPIOEN2_IO35EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO36EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO36EN_SHIFT		(0x0004u)
#define _GPIO_PGPIOEN2_IO36EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO36EN_SHIFT)
#define _GPIO_PGPIOEN2_IO36EN_MASK		(_GPIO_PGPIOEN2_IO36EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO36EN_CLR		(~(_GPIO_PGPIOEN2_IO36EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO37EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO37EN_SHIFT		(0x0005u)
#define _GPIO_PGPIOEN2_IO37EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO37EN_SHIFT)
#define _GPIO_PGPIOEN2_IO37EN_MASK		(_GPIO_PGPIOEN2_IO37EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO37EN_CLR		(~(_GPIO_PGPIOEN2_IO37EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO38EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO38EN_SHIFT		(0x0006u)
#define _GPIO_PGPIOEN2_IO38EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO38EN_SHIFT)
#define _GPIO_PGPIOEN2_IO38EN_MASK		(_GPIO_PGPIOEN2_IO38EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO38EN_CLR		(~(_GPIO_PGPIOEN2_IO38EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO39EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO39EN_SHIFT		(0x0007u)
#define _GPIO_PGPIOEN2_IO39EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO39EN_SHIFT)
#define _GPIO_PGPIOEN2_IO39EN_MASK		(_GPIO_PGPIOEN2_IO39EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO39EN_CLR		(~(_GPIO_PGPIOEN2_IO39EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO40EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO40EN_SHIFT		(0x0008u)
#define _GPIO_PGPIOEN2_IO40EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO40EN_SHIFT)
#define _GPIO_PGPIOEN2_IO40EN_MASK		(_GPIO_PGPIOEN2_IO40EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO40EN_CLR		(~(_GPIO_PGPIOEN2_IO40EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO41EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO41EN_SHIFT		(0x0009u)
#define _GPIO_PGPIOEN2_IO41EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO41EN_SHIFT)
#define _GPIO_PGPIOEN2_IO41EN_MASK		(_GPIO_PGPIOEN2_IO41EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO41EN_CLR		(~(_GPIO_PGPIOEN2_IO41EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO42EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO42EN_SHIFT		(0x000au)
#define _GPIO_PGPIOEN2_IO42EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO42EN_SHIFT)
#define _GPIO_PGPIOEN2_IO42EN_MASK		(_GPIO_PGPIOEN2_IO42EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO42EN_CLR		(~(_GPIO_PGPIOEN2_IO42EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO43EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO43EN_SHIFT		(0x000bu)
#define _GPIO_PGPIOEN2_IO43EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO43EN_SHIFT)
#define _GPIO_PGPIOEN2_IO43EN_MASK		(_GPIO_PGPIOEN2_IO43EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO43EN_CLR		(~(_GPIO_PGPIOEN2_IO43EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO44EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO44EN_SHIFT		(0x000cu)
#define _GPIO_PGPIOEN2_IO44EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO44EN_SHIFT)
#define _GPIO_PGPIOEN2_IO44EN_MASK		(_GPIO_PGPIOEN2_IO44EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO44EN_CLR		(~(_GPIO_PGPIOEN2_IO44EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN2_IO45EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN2_IO45EN_SHIFT		(0x000du)
#define _GPIO_PGPIOEN2_IO45EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN2_IO45EN_SHIFT)
#define _GPIO_PGPIOEN2_IO45EN_MASK		(_GPIO_PGPIOEN2_IO45EN_MK(0x0001u))
#define _GPIO_PGPIOEN2_IO45EN_CLR		(~(_GPIO_PGPIOEN2_IO45EN_MASK))


/******************************************************************************\
* 
* _GPIO_PGPIOEN1	 - Note: Add description here
*
* Fields:
*	(RW)   _GPIO_PGPIOEN1_IO16EN	
*	(RW)   _GPIO_PGPIOEN1_IO17EN	
*	(RW)   _GPIO_PGPIOEN1_IO18EN	
*	(RW)   _GPIO_PGPIOEN1_IO19EN	
*	(RW)   _GPIO_PGPIOEN1_IO20EN	
*	(RW)   _GPIO_PGPIOEN1_IO21EN	
*	(RW)   _GPIO_PGPIOEN1_IO22EN	
*	(RW)   _GPIO_PGPIOEN1_IO23EN	
*	(RW)   _GPIO_PGPIOEN1_IO24EN	
*	(RW)   _GPIO_PGPIOEN1_IO25EN	
*	(RW)   _GPIO_PGPIOEN1_IO26EN	
*	(RW)   _GPIO_PGPIOEN1_IO27EN	
*	(RW)   _GPIO_PGPIOEN1_IO28EN	
*	(RW)   _GPIO_PGPIOEN1_IO29EN	
*     (RW)   _GPIO_PGPIOEN1_IO30EN
*     (RW)   _GPIO_PGPIOEN1_IO31EN
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO16EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO16EN_SHIFT		(000000u)
#define _GPIO_PGPIOEN1_IO16EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO16EN_SHIFT)
#define _GPIO_PGPIOEN1_IO16EN_MASK		(_GPIO_PGPIOEN1_IO16EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO16EN_CLR		(~(_GPIO_PGPIOEN1_IO16EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO17EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO17EN_SHIFT		(0x0001u)
#define _GPIO_PGPIOEN1_IO17EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO17EN_SHIFT)
#define _GPIO_PGPIOEN1_IO17EN_MASK		(_GPIO_PGPIOEN1_IO17EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO17EN_CLR		(~(_GPIO_PGPIOEN1_IO17EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO18EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO18EN_SHIFT		(0x0002u)
#define _GPIO_PGPIOEN1_IO18EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO18EN_SHIFT)
#define _GPIO_PGPIOEN1_IO18EN_MASK		(_GPIO_PGPIOEN1_IO18EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO18EN_CLR		(~(_GPIO_PGPIOEN1_IO18EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO19EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO19EN_SHIFT		(0x0003u)
#define _GPIO_PGPIOEN1_IO19EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO19EN_SHIFT)
#define _GPIO_PGPIOEN1_IO19EN_MASK		(_GPIO_PGPIOEN1_IO19EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO19EN_CLR		(~(_GPIO_PGPIOEN1_IO19EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO20EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO20EN_SHIFT		(0x0004u)
#define _GPIO_PGPIOEN1_IO20EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO20EN_SHIFT)
#define _GPIO_PGPIOEN1_IO20EN_MASK		(_GPIO_PGPIOEN1_IO20EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO20EN_CLR		(~(_GPIO_PGPIOEN1_IO20EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO21EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO21EN_SHIFT		(0x0005u)
#define _GPIO_PGPIOEN1_IO21EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO21EN_SHIFT)
#define _GPIO_PGPIOEN1_IO21EN_MASK		(_GPIO_PGPIOEN1_IO21EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO21EN_CLR		(~(_GPIO_PGPIOEN1_IO21EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO22EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO22EN_SHIFT		(0x0006u)
#define _GPIO_PGPIOEN1_IO22EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO22EN_SHIFT)
#define _GPIO_PGPIOEN1_IO22EN_MASK		(_GPIO_PGPIOEN1_IO22EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO22EN_CLR		(~(_GPIO_PGPIOEN1_IO22EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO23EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO23EN_SHIFT		(0x0007u)
#define _GPIO_PGPIOEN1_IO23EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO23EN_SHIFT)
#define _GPIO_PGPIOEN1_IO23EN_MASK		(_GPIO_PGPIOEN1_IO23EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO23EN_CLR		(~(_GPIO_PGPIOEN1_IO23EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO24EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO24EN_SHIFT		(0x0008u)
#define _GPIO_PGPIOEN1_IO24EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO24EN_SHIFT)
#define _GPIO_PGPIOEN1_IO24EN_MASK		(_GPIO_PGPIOEN1_IO24EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO24EN_CLR		(~(_GPIO_PGPIOEN1_IO24EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO25EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO25EN_SHIFT		(0x0009u)
#define _GPIO_PGPIOEN1_IO25EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO25EN_SHIFT)
#define _GPIO_PGPIOEN1_IO25EN_MASK		(_GPIO_PGPIOEN1_IO25EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO25EN_CLR		(~(_GPIO_PGPIOEN1_IO25EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO26EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO26EN_SHIFT		(0x000au)
#define _GPIO_PGPIOEN1_IO26EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO26EN_SHIFT)
#define _GPIO_PGPIOEN1_IO26EN_MASK		(_GPIO_PGPIOEN1_IO26EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO26EN_CLR		(~(_GPIO_PGPIOEN1_IO26EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO27EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO27EN_SHIFT		(0x000bu)
#define _GPIO_PGPIOEN1_IO27EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO27EN_SHIFT)
#define _GPIO_PGPIOEN1_IO27EN_MASK		(_GPIO_PGPIOEN1_IO27EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO27EN_CLR		(~(_GPIO_PGPIOEN1_IO27EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO28EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO28EN_SHIFT		(0x000cu)
#define _GPIO_PGPIOEN1_IO28EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO28EN_SHIFT)
#define _GPIO_PGPIOEN1_IO28EN_MASK		(_GPIO_PGPIOEN1_IO28EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO28EN_CLR		(~(_GPIO_PGPIOEN1_IO28EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO29EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO29EN_SHIFT		(0x000du)
#define _GPIO_PGPIOEN1_IO29EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO29EN_SHIFT)
#define _GPIO_PGPIOEN1_IO29EN_MASK		(_GPIO_PGPIOEN1_IO29EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO29EN_CLR		(~(_GPIO_PGPIOEN1_IO29EN_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO30EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO30EN_SHIFT		(0x000eu)
#define _GPIO_PGPIOEN1_IO30EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO30EN_SHIFT)
#define _GPIO_PGPIOEN1_IO30EN_MASK		(_GPIO_PGPIOEN1_IO30EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO30EN_CLR		(~(_GPIO_PGPIOEN1_IO30EN_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN1_IO31EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN1_IO31EN_SHIFT		(0x000fu)
#define _GPIO_PGPIOEN1_IO31EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN1_IO31EN_SHIFT)
#define _GPIO_PGPIOEN1_IO31EN_MASK		(_GPIO_PGPIOEN1_IO31EN_MK(0x0001u))
#define _GPIO_PGPIOEN1_IO31EN_CLR		(~(_GPIO_PGPIOEN1_IO31EN_MASK))

/******************************************************************************\
* 
* _GPIO_PGPIOEN0	 - Note: Add description here
*
* Fields:
*	(RW)   _GPIO_PGPIOEN0_IO16EN	
*	(RW)   _GPIO_PGPIOEN0_IO1EN	
*	(RW)   _GPIO_PGPIOEN0_IO2EN	
*	(RW)   _GPIO_PGPIOEN0_IO3EN	
*	(RW)   _GPIO_PGPIOEN0_IO4EN	
*	(RW)   _GPIO_PGPIOEN0_IO5EN	
*	(RW)   _GPIO_PGPIOEN0_IO6EN	
*	(RW)   _GPIO_PGPIOEN0_IO7EN	
*	(RW)   _GPIO_PGPIOEN0_IO8EN	
*	(RW)   _GPIO_PGPIOEN0_IO9EN	
*	(RW)   _GPIO_PGPIOEN0_IO10EN	
*	(RW)   _GPIO_PGPIOEN0_IO11EN	
*	(RW)   _GPIO_PGPIOEN0_IO12EN	
*	(RW)   _GPIO_PGPIOEN0_IO13EN	
*     (RW)   _GPIO_PGPIOEN0_IO14EN
*     (RW)   _GPIO_PGPIOEN0_IO15EN
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO0EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO0EN_SHIFT		(000000u)
#define _GPIO_PGPIOEN0_IO0EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO0EN_SHIFT)
#define _GPIO_PGPIOEN0_IO0EN_MASK		(_GPIO_PGPIOEN0_IO0EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO0EN_CLR		(~(_GPIO_PGPIOEN0_IO0EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO1EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO1EN_SHIFT		(0x0001u)
#define _GPIO_PGPIOEN0_IO1EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO1EN_SHIFT)
#define _GPIO_PGPIOEN0_IO1EN_MASK		(_GPIO_PGPIOEN0_IO1EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO1EN_CLR		(~(_GPIO_PGPIOEN0_IO1EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO2EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO2EN_SHIFT		(0x0002u)
#define _GPIO_PGPIOEN0_IO2EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO2EN_SHIFT)
#define _GPIO_PGPIOEN0_IO2EN_MASK		(_GPIO_PGPIOEN0_IO2EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO2EN_CLR		(~(_GPIO_PGPIOEN0_IO2EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO3EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO3EN_SHIFT		(0x0003u)
#define _GPIO_PGPIOEN0_IO3EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO3EN_SHIFT)
#define _GPIO_PGPIOEN0_IO3EN_MASK		(_GPIO_PGPIOEN0_IO3EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO3EN_CLR		(~(_GPIO_PGPIOEN0_IO3EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO4EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO4EN_SHIFT		(0x0004u)
#define _GPIO_PGPIOEN0_IO4EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO4EN_SHIFT)
#define _GPIO_PGPIOEN0_IO4EN_MASK		(_GPIO_PGPIOEN0_IO4EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO4EN_CLR		(~(_GPIO_PGPIOEN0_IO4EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO5EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO5EN_SHIFT		(0x0005u)
#define _GPIO_PGPIOEN0_IO5EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO5EN_SHIFT)
#define _GPIO_PGPIOEN0_IO5EN_MASK		(_GPIO_PGPIOEN0_IO5EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO5EN_CLR		(~(_GPIO_PGPIOEN0_IO5EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO6EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO6EN_SHIFT		(0x0006u)
#define _GPIO_PGPIOEN0_IO6EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO6EN_SHIFT)
#define _GPIO_PGPIOEN0_IO6EN_MASK		(_GPIO_PGPIOEN0_IO6EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO6EN_CLR		(~(_GPIO_PGPIOEN0_IO6EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO7EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO7EN_SHIFT		(0x0007u)
#define _GPIO_PGPIOEN0_IO7EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO7EN_SHIFT)
#define _GPIO_PGPIOEN0_IO7EN_MASK		(_GPIO_PGPIOEN0_IO7EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO7EN_CLR		(~(_GPIO_PGPIOEN0_IO7EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO8EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO8EN_SHIFT		(0x0008u)
#define _GPIO_PGPIOEN0_IO8EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO8EN_SHIFT)
#define _GPIO_PGPIOEN0_IO8EN_MASK		(_GPIO_PGPIOEN0_IO8EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO8EN_CLR		(~(_GPIO_PGPIOEN0_IO8EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO9EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO9EN_SHIFT		(0x0009u)
#define _GPIO_PGPIOEN0_IO9EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO9EN_SHIFT)
#define _GPIO_PGPIOEN0_IO9EN_MASK		(_GPIO_PGPIOEN0_IO9EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO9EN_CLR		(~(_GPIO_PGPIOEN0_IO9EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO10EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO10EN_SHIFT		(0x000au)
#define _GPIO_PGPIOEN0_IO10EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO10EN_SHIFT)
#define _GPIO_PGPIOEN0_IO10EN_MASK		(_GPIO_PGPIOEN0_IO10EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO10EN_CLR		(~(_GPIO_PGPIOEN0_IO10EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO11EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO11EN_SHIFT		(0x000bu)
#define _GPIO_PGPIOEN0_IO11EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO11EN_SHIFT)
#define _GPIO_PGPIOEN0_IO11EN_MASK		(_GPIO_PGPIOEN0_IO11EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO11EN_CLR		(~(_GPIO_PGPIOEN0_IO11EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO12EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO12EN_SHIFT		(0x000cu)
#define _GPIO_PGPIOEN0_IO12EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO12EN_SHIFT)
#define _GPIO_PGPIOEN0_IO12EN_MASK		(_GPIO_PGPIOEN0_IO12EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO12EN_CLR		(~(_GPIO_PGPIOEN0_IO12EN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO13EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO13EN_SHIFT		(0x000du)
#define _GPIO_PGPIOEN0_IO13EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO13EN_SHIFT)
#define _GPIO_PGPIOEN0_IO13EN_MASK		(_GPIO_PGPIOEN0_IO13EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO13EN_CLR		(~(_GPIO_PGPIOEN0_IO13EN_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO14EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO14EN_SHIFT		(0x000eu)
#define _GPIO_PGPIOEN0_IO14EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO14EN_SHIFT)
#define _GPIO_PGPIOEN0_IO14EN_MASK		(_GPIO_PGPIOEN0_IO14EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO14EN_CLR		(~(_GPIO_PGPIOEN0_IO14EN_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIOEN0_IO15EN:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIOEN0_IO15EN_SHIFT		(0x000fu)
#define _GPIO_PGPIOEN0_IO15EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIOEN0_IO15EN_SHIFT)
#define _GPIO_PGPIOEN0_IO15EN_MASK		(_GPIO_PGPIOEN0_IO15EN_MK(0x0001u))
#define _GPIO_PGPIOEN0_IO15EN_CLR		(~(_GPIO_PGPIOEN0_IO15EN_MASK))





/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PGPIODAT0 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPIO_PGPIODAT0	 - Note: Add description here
*
* Fields:
*	(RW)   _GPIO_PGPIODAT0_IO0DAT	
*	(RW)   _GPIO_PGPIODAT0_IO1DAT	
*	(RW)   _GPIO_PGPIODAT0_IO2DAT	
*	(RW)   _GPIO_PGPIODAT0_IO3DAT	
*	(RW)   _GPIO_PGPIODAT0_IO4DAT	
*	(RW)   _GPIO_PGPIODAT0_IO5DAT	
*	(RW)   _GPIO_PGPIODAT0_IO6DAT	
*	(RW)   _GPIO_PGPIODAT0_IO7DAT	
*	(RW)   _GPIO_PGPIODAT0_IO8DAT	
*	(RW)   _GPIO_PGPIODAT0_IO9DAT	
*	(RW)   _GPIO_PGPIODAT0_IO10DAT	
*	(RW)   _GPIO_PGPIODAT0_IO11DAT	
*	(RW)   _GPIO_PGPIODAT0_IO12DAT	
*	(RW)   _GPIO_PGPIODAT0_IO13DAT	
*	(RW)   _GPIO_PGPIODAT0_IO14DAT	
*	(RW)   _GPIO_PGPIODAT0_IO15DAT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO0DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO0DAT_SHIFT		(000000u)
#define _GPIO_PGPIODAT0_IO0DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO0DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO0DAT_MASK		(_GPIO_PGPIODAT0_IO0DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO0DAT_CLR		(~(_GPIO_PGPIODAT0_IO0DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO1DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO1DAT_SHIFT		(0x0001u)
#define _GPIO_PGPIODAT0_IO1DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO1DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO1DAT_MASK		(_GPIO_PGPIODAT0_IO1DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO1DAT_CLR		(~(_GPIO_PGPIODAT0_IO1DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO2DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO2DAT_SHIFT		(0x0002u)
#define _GPIO_PGPIODAT0_IO2DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO2DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO2DAT_MASK		(_GPIO_PGPIODAT0_IO2DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO2DAT_CLR		(~(_GPIO_PGPIODAT0_IO2DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO3DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO3DAT_SHIFT		(0x0003u)
#define _GPIO_PGPIODAT0_IO3DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO3DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO3DAT_MASK		(_GPIO_PGPIODAT0_IO3DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO3DAT_CLR		(~(_GPIO_PGPIODAT0_IO3DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO4DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO4DAT_SHIFT		(0x0004u)
#define _GPIO_PGPIODAT0_IO4DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO4DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO4DAT_MASK		(_GPIO_PGPIODAT0_IO4DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO4DAT_CLR		(~(_GPIO_PGPIODAT0_IO4DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO5DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO5DAT_SHIFT		(0x0005u)
#define _GPIO_PGPIODAT0_IO5DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO5DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO5DAT_MASK		(_GPIO_PGPIODAT0_IO5DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO5DAT_CLR		(~(_GPIO_PGPIODAT0_IO5DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO6DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO6DAT_SHIFT		(0x0006u)
#define _GPIO_PGPIODAT0_IO6DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO6DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO6DAT_MASK		(_GPIO_PGPIODAT0_IO6DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO6DAT_CLR		(~(_GPIO_PGPIODAT0_IO6DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO7DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO7DAT_SHIFT		(0x0007u)
#define _GPIO_PGPIODAT0_IO7DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO7DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO7DAT_MASK		(_GPIO_PGPIODAT0_IO7DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO7DAT_CLR		(~(_GPIO_PGPIODAT0_IO7DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO8DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO8DAT_SHIFT		(0x0008u)
#define _GPIO_PGPIODAT0_IO8DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO8DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO8DAT_MASK		(_GPIO_PGPIODAT0_IO8DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO8DAT_CLR		(~(_GPIO_PGPIODAT0_IO8DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO9DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO9DAT_SHIFT		(0x0009u)
#define _GPIO_PGPIODAT0_IO9DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO9DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO9DAT_MASK		(_GPIO_PGPIODAT0_IO9DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO9DAT_CLR		(~(_GPIO_PGPIODAT0_IO9DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO10DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO10DAT_SHIFT		(0x000au)
#define _GPIO_PGPIODAT0_IO10DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO10DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO10DAT_MASK		(_GPIO_PGPIODAT0_IO10DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO10DAT_CLR		(~(_GPIO_PGPIODAT0_IO10DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO11DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO11DAT_SHIFT		(0x000bu)
#define _GPIO_PGPIODAT0_IO11DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO11DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO11DAT_MASK		(_GPIO_PGPIODAT0_IO11DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO11DAT_CLR		(~(_GPIO_PGPIODAT0_IO11DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO12DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO12DAT_SHIFT		(0x000cu)
#define _GPIO_PGPIODAT0_IO12DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO12DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO12DAT_MASK		(_GPIO_PGPIODAT0_IO12DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO12DAT_CLR		(~(_GPIO_PGPIODAT0_IO12DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO13DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO13DAT_SHIFT		(0x000du)
#define _GPIO_PGPIODAT0_IO13DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO13DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO13DAT_MASK		(_GPIO_PGPIODAT0_IO13DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO13DAT_CLR		(~(_GPIO_PGPIODAT0_IO13DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO14DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO14DAT_SHIFT		(0x000eu)
#define _GPIO_PGPIODAT0_IO14DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO14DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO14DAT_MASK		(_GPIO_PGPIODAT0_IO14DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO14DAT_CLR		(~(_GPIO_PGPIODAT0_IO14DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT0_IO15DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT0_IO15DAT_SHIFT		(0x000fu)
#define _GPIO_PGPIODAT0_IO15DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT0_IO15DAT_SHIFT)
#define _GPIO_PGPIODAT0_IO15DAT_MASK		(_GPIO_PGPIODAT0_IO15DAT_MK(0x0001u))
#define _GPIO_PGPIODAT0_IO15DAT_CLR		(~(_GPIO_PGPIODAT0_IO15DAT_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PGPIODAT1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPIO_PGPIODAT1	 - Note: Add description here
*
* Fields:
*	(RW)   _GPIO_PGPIODAT1_IO16DAT	
*	(RW)   _GPIO_PGPIODAT1_IO1DAT	
*	(RW)   _GPIO_PGPIODAT1_IO18DAT	
*	(RW)   _GPIO_PGPIODAT1_IO19DAT	
*	(RW)   _GPIO_PGPIODAT1_IO20DAT	
*	(RW)   _GPIO_PGPIODAT1_IO5DAT	
*	(RW)   _GPIO_PGPIODAT1_IO22DAT	
*	(RW)   _GPIO_PGPIODAT1_IO23DAT	
*	(RW)   _GPIO_PGPIODAT1_IO24DAT	
*	(RW)   _GPIO_PGPIODAT1_IO25DAT	
*	(RW)   _GPIO_PGPIODAT1_IO26DAT	
*	(RW)   _GPIO_PGPIODAT1_IO27DAT	
*	(RW)   _GPIO_PGPIODAT1_IO28DAT	
*	(RW)   _GPIO_PGPIODAT1_IO29DAT	
*	(RW)   _GPIO_PGPIODAT1_IO30DAT	
*	(RW)   _GPIO_PGPIODAT1_IO31DAT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO16DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO16DAT_SHIFT		(000000u)
#define _GPIO_PGPIODAT1_IO16DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO16DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO16DAT_MASK		(_GPIO_PGPIODAT1_IO16DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO16DAT_CLR		(~(_GPIO_PGPIODAT1_IO16DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO17DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO17DAT_SHIFT		(0x0001u)
#define _GPIO_PGPIODAT1_IO17DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO17DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO17DAT_MASK		(_GPIO_PGPIODAT1_IO17DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO17DAT_CLR		(~(_GPIO_PGPIODAT1_IO17DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO18DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO18DAT_SHIFT		(0x0002u)
#define _GPIO_PGPIODAT1_IO18DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO18DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO18DAT_MASK		(_GPIO_PGPIODAT1_IO18DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO18DAT_CLR		(~(_GPIO_PGPIODAT1_IO18DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO19DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO19DAT_SHIFT		(0x0003u)
#define _GPIO_PGPIODAT1_IO19DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO19DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO19DAT_MASK		(_GPIO_PGPIODAT1_IO19DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO19DAT_CLR		(~(_GPIO_PGPIODAT1_IO19DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO20DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO20DAT_SHIFT		(0x0004u)
#define _GPIO_PGPIODAT1_IO20DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO20DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO20DAT_MASK		(_GPIO_PGPIODAT1_IO20DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO20DAT_CLR		(~(_GPIO_PGPIODAT1_IO20DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO21DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO21DAT_SHIFT		(0x0005u)
#define _GPIO_PGPIODAT1_IO21DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO21DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO21DAT_MASK		(_GPIO_PGPIODAT1_IO21DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO21DAT_CLR		(~(_GPIO_PGPIODAT1_IO21DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO22DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO22DAT_SHIFT		(0x0006u)
#define _GPIO_PGPIODAT1_IO22DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO22DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO22DAT_MASK		(_GPIO_PGPIODAT1_IO22DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO22DAT_CLR		(~(_GPIO_PGPIODAT1_IO22DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO23DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO23DAT_SHIFT		(0x0007u)
#define _GPIO_PGPIODAT1_IO23DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO23DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO23DAT_MASK		(_GPIO_PGPIODAT1_IO23DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO23DAT_CLR		(~(_GPIO_PGPIODAT1_IO23DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO24DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO24DAT_SHIFT		(0x0008u)
#define _GPIO_PGPIODAT1_IO24DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO24DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO24DAT_MASK		(_GPIO_PGPIODAT1_IO24DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO24DAT_CLR		(~(_GPIO_PGPIODAT1_IO24DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO25DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO25DAT_SHIFT		(0x0009u)
#define _GPIO_PGPIODAT1_IO25DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO25DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO25DAT_MASK		(_GPIO_PGPIODAT1_IO25DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO25DAT_CLR		(~(_GPIO_PGPIODAT1_IO25DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO26DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO26DAT_SHIFT		(0x000au)
#define _GPIO_PGPIODAT1_IO26DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO26DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO26DAT_MASK		(_GPIO_PGPIODAT1_IO26DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO26DAT_CLR		(~(_GPIO_PGPIODAT1_IO26DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO27DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO27DAT_SHIFT		(0x000bu)
#define _GPIO_PGPIODAT1_IO27DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO27DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO27DAT_MASK		(_GPIO_PGPIODAT1_IO27DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO27DAT_CLR		(~(_GPIO_PGPIODAT1_IO27DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO28DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO28DAT_SHIFT		(0x000cu)
#define _GPIO_PGPIODAT1_IO28DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO28DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO28DAT_MASK		(_GPIO_PGPIODAT1_IO28DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO28DAT_CLR		(~(_GPIO_PGPIODAT1_IO28DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO29DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO29DAT_SHIFT		(0x000du)
#define _GPIO_PGPIODAT1_IO29DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO29DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO29DAT_MASK		(_GPIO_PGPIODAT1_IO29DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO29DAT_CLR		(~(_GPIO_PGPIODAT1_IO29DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO30DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO30DAT_SHIFT		(0x000eu)
#define _GPIO_PGPIODAT1_IO30DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO30DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO30DAT_MASK		(_GPIO_PGPIODAT1_IO30DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO30DAT_CLR		(~(_GPIO_PGPIODAT1_IO30DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT1_IO31DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT1_IO31DAT_SHIFT		(0x000fu)
#define _GPIO_PGPIODAT1_IO31DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT1_IO31DAT_SHIFT)
#define _GPIO_PGPIODAT1_IO31DAT_MASK		(_GPIO_PGPIODAT1_IO31DAT_MK(0x0001u))
#define _GPIO_PGPIODAT1_IO31DAT_CLR		(~(_GPIO_PGPIODAT1_IO31DAT_MASK))




/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PGPIODAT1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPIO_PGPIODAT1	 - Note: Add description here
*
* Fields:
*	(RW)   _GPIO_PGPIODAT2_IO32DAT	
*	(RW)   _GPIO_PGPIODAT2_IO33DAT	
*	(RW)   _GPIO_PGPIODAT2_IO34DAT	
*	(RW)   _GPIO_PGPIODAT2_IO35DAT	
*	(RW)   _GPIO_PGPIODAT2_IO36DAT	
*	(RW)   _GPIO_PGPIODAT2_IO37DAT	
*	(RW)   _GPIO_PGPIODAT2_IO38DAT	
*	(RW)   _GPIO_PGPIODAT2_IO39DAT	
*	(RW)   _GPIO_PGPIODAT2_IO40DAT	
*	(RW)   _GPIO_PGPIODAT2_IO41DAT	
*	(RW)   _GPIO_PGPIODAT2_IO42DAT	
*	(RW)   _GPIO_PGPIODAT2_IO43DAT	
*	(RW)   _GPIO_PGPIODAT2_IO44DAT	
*	(RW)   _GPIO_PGPIODAT2_IO45DAT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO32DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO32DAT_SHIFT		(000000u)
#define _GPIO_PGPIODAT2_IO32DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO32DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO32DAT_MASK		(_GPIO_PGPIODAT2_IO32DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO32DAT_CLR		(~(_GPIO_PGPIODAT2_IO32DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO33DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO33DAT_SHIFT		(0x0001u)
#define _GPIO_PGPIODAT2_IO33DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO33DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO33DAT_MASK		(_GPIO_PGPIODAT2_IO33DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO33DAT_CLR		(~(_GPIO_PGPIODAT2_IO33DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO34DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO34DAT_SHIFT		(0x0002u)
#define _GPIO_PGPIODAT2_IO34DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO34DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO34DAT_MASK		(_GPIO_PGPIODAT2_IO34DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO34DAT_CLR		(~(_GPIO_PGPIODAT2_IO34DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO35DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO35DAT_SHIFT		(0x0003u)
#define _GPIO_PGPIODAT2_IO35DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO35DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO35DAT_MASK		(_GPIO_PGPIODAT2_IO35DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO35DAT_CLR		(~(_GPIO_PGPIODAT2_IO35DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO36DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO36DAT_SHIFT		(0x0004u)
#define _GPIO_PGPIODAT2_IO36DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO36DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO36DAT_MASK		(_GPIO_PGPIODAT2_IO36DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO36DAT_CLR		(~(_GPIO_PGPIODAT2_IO36DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO37DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO37DAT_SHIFT		(0x0005u)
#define _GPIO_PGPIODAT2_IO37DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO37DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO37DAT_MASK		(_GPIO_PGPIODAT2_IO37DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO37DAT_CLR		(~(_GPIO_PGPIODAT2_IO37DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO38DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO38DAT_SHIFT		(0x0006u)
#define _GPIO_PGPIODAT2_IO38DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO38DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO38DAT_MASK		(_GPIO_PGPIODAT2_IO38DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO38DAT_CLR		(~(_GPIO_PGPIODAT2_IO38DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO39DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO39DAT_SHIFT		(0x0007u)
#define _GPIO_PGPIODAT2_IO39DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO39DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO39DAT_MASK		(_GPIO_PGPIODAT2_IO39DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO39DAT_CLR		(~(_GPIO_PGPIODAT2_IO39DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO40DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO40DAT_SHIFT		(0x0008u)
#define _GPIO_PGPIODAT2_IO40DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO40DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO40DAT_MASK		(_GPIO_PGPIODAT2_IO40DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO40DAT_CLR		(~(_GPIO_PGPIODAT2_IO40DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO41DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO41DAT_SHIFT		(0x0009u)
#define _GPIO_PGPIODAT2_IO41DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO41DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO41DAT_MASK		(_GPIO_PGPIODAT2_IO41DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO41DAT_CLR		(~(_GPIO_PGPIODAT2_IO41DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO42DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO42DAT_SHIFT		(0x000au)
#define _GPIO_PGPIODAT2_IO42DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO42DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO42DAT_MASK		(_GPIO_PGPIODAT2_IO42DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO42DAT_CLR		(~(_GPIO_PGPIODAT2_IO42DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO43DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO43DAT_SHIFT		(0x000bu)
#define _GPIO_PGPIODAT2_IO43DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO43DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO43DAT_MASK		(_GPIO_PGPIODAT2_IO43DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO43DAT_CLR		(~(_GPIO_PGPIODAT2_IO43DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO44DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO44DAT_SHIFT		(0x000cu)
#define _GPIO_PGPIODAT2_IO44DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO44DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO44DAT_MASK		(_GPIO_PGPIODAT2_IO44DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO44DAT_CLR		(~(_GPIO_PGPIODAT2_IO44DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODAT2_IO45DAT:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODAT2_IO45DAT_SHIFT		(0x000du)
#define _GPIO_PGPIODAT2_IO45DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODAT2_IO45DAT_SHIFT)
#define _GPIO_PGPIODAT2_IO45DAT_MASK		(_GPIO_PGPIODAT2_IO45DAT_MK(0x0001u))
#define _GPIO_PGPIODAT2_IO45DAT_CLR		(~(_GPIO_PGPIODAT2_IO45DAT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PGPIODIR0 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPIO_PGPIODIR0	 - Note: Add description here
*
* Fields:
*	(RW)   _GPIO_PGPIODIR1_IO16DIR	
*	(RW)   _GPIO_PGPIODIR1_IO17DIR	
*	(RW)   _GPIO_PGPIODIR1_IO18DIR	
*	(RW)   _GPIO_PGPIODIR1_IO19DIR	
*	(RW)   _GPIO_PGPIODIR1_IO20DIR	
*	(RW)   _GPIO_PGPIODIR1_IO21DIR	
*	(RW)   _GPIO_PGPIODIR1_IO22DIR	
*	(RW)   _GPIO_PGPIODIR1_IO23DIR	
*	(RW)   _GPIO_PGPIODIR1_IO24DIR	
*	(RW)   _GPIO_PGPIODIR1_IO25DIR	
*	(RW)   _GPIO_PGPIODIR1_IO26DIR	
*	(RW)   _GPIO_PGPIODIR1_IO27DIR	
*	(RW)   _GPIO_PGPIODIR1_IO28DIR	
*	(RW)   _GPIO_PGPIODIR1_IO29DIR	
*	(RW)   _GPIO_PGPIODIR1_IO30DIR	
*	(RW)   _GPIO_PGPIODIR1_IO31DIR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO16DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO16DIR_SHIFT		(000000u)
#define _GPIO_PGPIODIR1_IO16DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO16DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO16DIR_MASK		(_GPIO_PGPIODIR1_IO16DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO16DIR_CLR		(~(_GPIO_PGPIODIR1_IO16DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO17DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO17DIR_SHIFT		(0x0001u)
#define _GPIO_PGPIODIR1_IO17DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO17DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO17DIR_MASK		(_GPIO_PGPIODIR1_IO17DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO17DIR_CLR		(~(_GPIO_PGPIODIR1_IO17DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO18DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO18DIR_SHIFT		(0x0002u)
#define _GPIO_PGPIODIR1_IO18DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO18DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO18DIR_MASK		(_GPIO_PGPIODIR1_IO18DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO18DIR_CLR		(~(_GPIO_PGPIODIR1_IO18DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO19DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO19DIR_SHIFT		(0x0003u)
#define _GPIO_PGPIODIR1_IO19DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO19DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO19DIR_MASK		(_GPIO_PGPIODIR1_IO19DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO19DIR_CLR		(~(_GPIO_PGPIODIR1_IO19DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO20DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO20DIR_SHIFT		(0x0004u)
#define _GPIO_PGPIODIR1_IO20DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO20DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO20DIR_MASK		(_GPIO_PGPIODIR1_IO20DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO20DIR_CLR		(~(_GPIO_PGPIODIR1_IO20DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO21DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO21DIR_SHIFT		(0x0005u)
#define _GPIO_PGPIODIR1_IO21DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO21DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO21DIR_MASK		(_GPIO_PGPIODIR1_IO21DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO21DIR_CLR		(~(_GPIO_PGPIODIR1_IO21DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO22DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO22DIR_SHIFT		(0x0006u)
#define _GPIO_PGPIODIR1_IO22DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO22DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO22DIR_MASK		(_GPIO_PGPIODIR1_IO22DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO22DIR_CLR		(~(_GPIO_PGPIODIR1_IO22DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO23DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO23DIR_SHIFT		(0x0007u)
#define _GPIO_PGPIODIR1_IO23DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO23DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO23DIR_MASK		(_GPIO_PGPIODIR1_IO23DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO23DIR_CLR		(~(_GPIO_PGPIODIR1_IO23DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO24DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO24DIR_SHIFT		(0x0008u)
#define _GPIO_PGPIODIR1_IO24DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO24DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO24DIR_MASK		(_GPIO_PGPIODIR1_IO24DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO24DIR_CLR		(~(_GPIO_PGPIODIR1_IO24DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO25DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO25DIR_SHIFT		(0x0009u)
#define _GPIO_PGPIODIR1_IO25DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO25DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO25DIR_MASK		(_GPIO_PGPIODIR1_IO25DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO25DIR_CLR		(~(_GPIO_PGPIODIR1_IO25DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO26DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO26DIR_SHIFT		(0x000au)
#define _GPIO_PGPIODIR1_IO26DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO26DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO26DIR_MASK		(_GPIO_PGPIODIR1_IO26DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO26DIR_CLR		(~(_GPIO_PGPIODIR1_IO26DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO27DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO27DIR_SHIFT		(0x000bu)
#define _GPIO_PGPIODIR1_IO27DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO27DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO27DIR_MASK		(_GPIO_PGPIODIR1_IO27DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO27DIR_CLR		(~(_GPIO_PGPIODIR1_IO27DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO28DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO28DIR_SHIFT		(0x000cu)
#define _GPIO_PGPIODIR1_IO28DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO28DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO28DIR_MASK		(_GPIO_PGPIODIR1_IO28DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO28DIR_CLR		(~(_GPIO_PGPIODIR1_IO28DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO29DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO29DIR_SHIFT		(0x000du)
#define _GPIO_PGPIODIR1_IO29DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO29DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO29DIR_MASK		(_GPIO_PGPIODIR1_IO29DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO29DIR_CLR		(~(_GPIO_PGPIODIR1_IO29DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO30DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO30DIR_SHIFT		(0x000eu)
#define _GPIO_PGPIODIR1_IO30DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO30DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO30DIR_MASK		(_GPIO_PGPIODIR1_IO30DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO30DIR_CLR		(~(_GPIO_PGPIODIR1_IO30DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR1_IO31DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR1_IO31DIR_SHIFT		(0x000fu)
#define _GPIO_PGPIODIR1_IO31DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR1_IO31DIR_SHIFT)
#define _GPIO_PGPIODIR1_IO31DIR_MASK		(_GPIO_PGPIODIR1_IO31DIR_MK(0x0001u))
#define _GPIO_PGPIODIR1_IO31DIR_CLR		(~(_GPIO_PGPIODIR1_IO31DIR_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PGPIODIR1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPIO_PGPIODIR0	 - Note: Add description here
*
* Fields:
*	(RW)   _GPIO_PGPIODIR0_IO0DIR	
*	(RW)   _GPIO_PGPIODIR0_IO1DIR	
*	(RW)   _GPIO_PGPIODIR0_IO2DIR	
*	(RW)   _GPIO_PGPIODIR0_IO3DIR	
*	(RW)   _GPIO_PGPIODIR0_IO4DIR	
*	(RW)   _GPIO_PGPIODIR0_IO5DIR	
*	(RW)   _GPIO_PGPIODIR0_IO6DIR	
*	(RW)   _GPIO_PGPIODIR0_IO7DIR	
*	(RW)   _GPIO_PGPIODIR0_IO8DIR	
*	(RW)   _GPIO_PGPIODIR0_IO9DIR	
*	(RW)   _GPIO_PGPIODIR0_IO10DIR	
*	(RW)   _GPIO_PGPIODIR0_IO11DIR	
*	(RW)   _GPIO_PGPIODIR0_IO12DIR	
*	(RW)   _GPIO_PGPIODIR0_IO13DIR	
*	(RW)   _GPIO_PGPIODIR0_IO14DIR	
*	(RW)   _GPIO_PGPIODIR0_IO15DIR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO0DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO0DIR_SHIFT		(000000u)
#define _GPIO_PGPIODIR0_IO0DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO0DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO0DIR_MASK		(_GPIO_PGPIODIR0_IO0DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO0DIR_CLR		(~(_GPIO_PGPIODIR0_IO0DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO1DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO1DIR_SHIFT		(0x0001u)
#define _GPIO_PGPIODIR0_IO1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO1DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO1DIR_MASK		(_GPIO_PGPIODIR0_IO1DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO1DIR_CLR		(~(_GPIO_PGPIODIR0_IO1DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO2DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO2DIR_SHIFT		(0x0002u)
#define _GPIO_PGPIODIR0_IO2DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO2DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO2DIR_MASK		(_GPIO_PGPIODIR0_IO2DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO2DIR_CLR		(~(_GPIO_PGPIODIR0_IO2DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO3DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO3DIR_SHIFT		(0x0003u)
#define _GPIO_PGPIODIR0_IO3DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO3DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO3DIR_MASK		(_GPIO_PGPIODIR0_IO3DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO3DIR_CLR		(~(_GPIO_PGPIODIR0_IO3DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO4DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO4DIR_SHIFT		(0x0004u)
#define _GPIO_PGPIODIR0_IO4DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO4DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO4DIR_MASK		(_GPIO_PGPIODIR0_IO4DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO4DIR_CLR		(~(_GPIO_PGPIODIR0_IO4DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO5DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO5DIR_SHIFT		(0x0005u)
#define _GPIO_PGPIODIR0_IO5DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO5DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO5DIR_MASK		(_GPIO_PGPIODIR0_IO5DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO5DIR_CLR		(~(_GPIO_PGPIODIR0_IO5DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO6DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO6DIR_SHIFT		(0x0006u)
#define _GPIO_PGPIODIR0_IO6DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO6DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO6DIR_MASK		(_GPIO_PGPIODIR0_IO6DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO6DIR_CLR		(~(_GPIO_PGPIODIR0_IO6DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO7DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO7DIR_SHIFT		(0x0007u)
#define _GPIO_PGPIODIR0_IO7DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO7DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO7DIR_MASK		(_GPIO_PGPIODIR0_IO7DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO7DIR_CLR		(~(_GPIO_PGPIODIR0_IO7DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO8DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO8DIR_SHIFT		(0x0008u)
#define _GPIO_PGPIODIR0_IO8DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO8DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO8DIR_MASK		(_GPIO_PGPIODIR0_IO8DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO8DIR_CLR		(~(_GPIO_PGPIODIR0_IO8DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO9DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO9DIR_SHIFT		(0x0009u)
#define _GPIO_PGPIODIR0_IO9DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO9DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO9DIR_MASK		(_GPIO_PGPIODIR0_IO9DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO9DIR_CLR		(~(_GPIO_PGPIODIR0_IO9DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO10DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO10DIR_SHIFT		(0x000au)
#define _GPIO_PGPIODIR0_IO10DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO10DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO10DIR_MASK		(_GPIO_PGPIODIR0_IO10DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO10DIR_CLR		(~(_GPIO_PGPIODIR0_IO10DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO11DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO11DIR_SHIFT		(0x000bu)
#define _GPIO_PGPIODIR0_IO11DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO11DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO11DIR_MASK		(_GPIO_PGPIODIR0_IO11DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO11DIR_CLR		(~(_GPIO_PGPIODIR0_IO11DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO12DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO12DIR_SHIFT		(0x000cu)
#define _GPIO_PGPIODIR0_IO12DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO12DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO12DIR_MASK		(_GPIO_PGPIODIR0_IO12DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO12DIR_CLR		(~(_GPIO_PGPIODIR0_IO12DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO13DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO13DIR_SHIFT		(0x000du)
#define _GPIO_PGPIODIR0_IO13DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO13DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO13DIR_MASK		(_GPIO_PGPIODIR0_IO13DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO13DIR_CLR		(~(_GPIO_PGPIODIR0_IO13DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO14DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO14DIR_SHIFT		(0x000eu)
#define _GPIO_PGPIODIR0_IO14DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO14DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO14DIR_MASK		(_GPIO_PGPIODIR0_IO14DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO14DIR_CLR		(~(_GPIO_PGPIODIR0_IO14DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR0_IO15DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR0_IO15DIR_SHIFT		(0x000fu)
#define _GPIO_PGPIODIR0_IO15DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR0_IO15DIR_SHIFT)
#define _GPIO_PGPIODIR0_IO15DIR_MASK		(_GPIO_PGPIODIR0_IO15DIR_MK(0x0001u))
#define _GPIO_PGPIODIR0_IO15DIR_CLR		(~(_GPIO_PGPIODIR0_IO15DIR_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PGPIODIR2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPIO_PGPIODIR2	 - Note: Add description here
*
* Fields:
*	(RW)   _GPIO_PGPIODIR2_IO32DIR	
*	(RW)   _GPIO_PGPIODIR2_IO33DIR	
*	(RW)   _GPIO_PGPIODIR2_IO34DIR	
*	(RW)   _GPIO_PGPIODIR2_IO35DIR	
*	(RW)   _GPIO_PGPIODIR2_IO36DIR	
*	(RW)   _GPIO_PGPIODIR2_IO37DIR	
*	(RW)   _GPIO_PGPIODIR2_IO38DIR	
*	(RW)   _GPIO_PGPIODIR2_IO39DIR	
*	(RW)   _GPIO_PGPIODIR2_IO40DIR	
*	(RW)   _GPIO_PGPIODIR2_IO41DIR	
*	(RW)   _GPIO_PGPIODIR2_IO42DIR	
*	(RW)   _GPIO_PGPIODIR2_IO43DIR	
*	(RW)   _GPIO_PGPIODIR2_IO44DIR	
*	(RW)   _GPIO_PGPIODIR2_IO45DIR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO32DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO32DIR_SHIFT		(000000u)
#define _GPIO_PGPIODIR2_IO32DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO32DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO32DIR_MASK		(_GPIO_PGPIODIR2_IO32DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO32DIR_CLR		(~(_GPIO_PGPIODIR2_IO32DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO33DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO33DIR_SHIFT		(0x0001u)
#define _GPIO_PGPIODIR2_IO33DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO33DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO33DIR_MASK		(_GPIO_PGPIODIR2_IO33DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO33DIR_CLR		(~(_GPIO_PGPIODIR2_IO33DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO34DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO34DIR_SHIFT		(0x0002u)
#define _GPIO_PGPIODIR2_IO34DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO34DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO34DIR_MASK		(_GPIO_PGPIODIR2_IO34DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO34DIR_CLR		(~(_GPIO_PGPIODIR2_IO34DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO35DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO35DIR_SHIFT		(0x0003u)
#define _GPIO_PGPIODIR2_IO35DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO35DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO35DIR_MASK		(_GPIO_PGPIODIR2_IO35DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO35DIR_CLR		(~(_GPIO_PGPIODIR2_IO35DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO36DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO36DIR_SHIFT		(0x0004u)
#define _GPIO_PGPIODIR2_IO36DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO36DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO36DIR_MASK		(_GPIO_PGPIODIR2_IO36DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO36DIR_CLR		(~(_GPIO_PGPIODIR2_IO36DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO37DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO37DIR_SHIFT		(0x0005u)
#define _GPIO_PGPIODIR2_IO37DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO37DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO37DIR_MASK		(_GPIO_PGPIODIR2_IO37DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO37DIR_CLR		(~(_GPIO_PGPIODIR2_IO37DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO38DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO38DIR_SHIFT		(0x0006u)
#define _GPIO_PGPIODIR2_IO38DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO38DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO38DIR_MASK		(_GPIO_PGPIODIR2_IO38DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO38DIR_CLR		(~(_GPIO_PGPIODIR2_IO38DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO39DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO39DIR_SHIFT		(0x0007u)
#define _GPIO_PGPIODIR2_IO39DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO39DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO39DIR_MASK		(_GPIO_PGPIODIR2_IO39DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO39DIR_CLR		(~(_GPIO_PGPIODIR2_IO39DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO40DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO40DIR_SHIFT		(0x0008u)
#define _GPIO_PGPIODIR2_IO40DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO40DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO40DIR_MASK		(_GPIO_PGPIODIR2_IO40DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO40DIR_CLR		(~(_GPIO_PGPIODIR2_IO40DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO41DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO41DIR_SHIFT		(0x0009u)
#define _GPIO_PGPIODIR2_IO41DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO41DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO41DIR_MASK		(_GPIO_PGPIODIR2_IO41DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO41DIR_CLR		(~(_GPIO_PGPIODIR2_IO41DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO42DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO42DIR_SHIFT		(0x000au)
#define _GPIO_PGPIODIR2_IO42DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO42DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO42DIR_MASK		(_GPIO_PGPIODIR2_IO42DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO42DIR_CLR		(~(_GPIO_PGPIODIR2_IO42DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO43DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO43DIR_SHIFT		(0x000bu)
#define _GPIO_PGPIODIR2_IO43DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO43DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO43DIR_MASK		(_GPIO_PGPIODIR2_IO43DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO43DIR_CLR		(~(_GPIO_PGPIODIR2_IO43DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO44DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO44DIR_SHIFT		(0x000cu)
#define _GPIO_PGPIODIR2_IO44DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO44DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO44DIR_MASK		(_GPIO_PGPIODIR2_IO44DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO44DIR_CLR		(~(_GPIO_PGPIODIR2_IO44DIR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPIO_PGPIODIR2_IO45DIR:	
\*----------------------------------------------------------------*/

#define _GPIO_PGPIODIR2_IO45DIR_SHIFT		(0x000du)
#define _GPIO_PGPIODIR2_IO45DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_PGPIODIR2_IO45DIR_SHIFT)
#define _GPIO_PGPIODIR2_IO45DIR_MASK		(_GPIO_PGPIODIR2_IO45DIR_MK(0x0001u))
#define _GPIO_PGPIODIR2_IO45DIR_CLR		(~(_GPIO_PGPIODIR2_IO45DIR_MASK))




#endif
#else
   #ifndef _GPIO_MOD
	#error GPIO Hal Module Not Supported on Specified Target
   #endif
#endif
#endif
csl_gpio5509.h/ 1049976867  0     0     0       1443      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpio.h
* DATE CREATED.. Fri 06/09/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. 
* VERSION....... 1.00
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:         06/09/2000 created for C5510
*   LAST MODIFIED:   04/16/2001 updated module name and other header comments
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GPIO module)
*
*
*
\******************************************************************************/
#ifndef _CSL_GPIO5509_H_
  #define _CSL_GPIO5509_H_

  #include <csl.h>
  #include <csl_chiphal.h>

   #if (_GPIO_SUPPORT)

     #if (_GPIO_PGPIO_SUPPORT)
        #include <_csl_pgpio.h>
     #else
       #include <_csl_gpio.h>
     #endif

  #endif 					/* _GPIO_SUPPORT_ */
#endif   /* _CSL_GPIO_H_ */
/******************************************************************************\
* End of gpio.h
\******************************************************************************/

csl_gpio5509a.h/1049976868  0     0     0       1445      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpio.h
* DATE CREATED.. Fri 06/09/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. 
* VERSION....... 1.00
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:         06/09/2000 created for C5510
*   LAST MODIFIED:   04/16/2001 updated module name and other header comments
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GPIO module)
*
*
*
\******************************************************************************/
#ifndef _CSL_GPIO5509A_H_
  #define _CSL_GPIO5509A_H_

  #include <csl.h>
  #include <csl_chiphal.h>

   #if (_GPIO_SUPPORT)

     #if (_GPIO_PGPIO_SUPPORT)
        #include <_csl_pgpio.h>
     #else
       #include <_csl_gpio.h>
     #endif

  #endif 					/* _GPIO_SUPPORT_ */
#endif   /* _CSL_GPIO_H_ */
/******************************************************************************\
* End of gpio.h
\******************************************************************************/

csl_gpio5509ada/1049976870  58    0     0       1037      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpiodata.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GIO module)
*       Reserved Area for GIO Data 
*
*
\******************************************************************************/
#ifndef _GPIO5509A_DAT_H_
  #define _GPIO5509A_DAT_H_

  #include <csl_chiphal.h>

  #if (_GPIO_PGPIO_SUPPORT)
    #include <_csl_pgpiodat.h>
 #else
   #include <_csl_gpiodat.h>
 #endif
#endif

csl_gpio5509aha/1049976871  78    0     0       12703     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpiohal.h
* DATE CREATED.. Mon 06/05/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. csl_stdinc.h, csl_chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       06/05/2000 (AP) created
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments  
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the GPIO module)
*
* Registers Covered:
*   (RW) _GPIO_IODIR
*   (RW) _GPIO_IODATA
\******************************************************************************/

#ifndef _GPIO5509AHAL_H_
#define _GPIO5509AHAL_H_

#include <csl_chiphal.h>

#if (_GPIO_SUPPORT)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _GPIO_IODIR
\*============================================================================*/
#define _GPIO_IODIR_ADDR				(0x3400u)
#define _GPIO_IODIR                       	PREG16(_GPIO_IODIR_ADDR)
#define _IODIR                              	_GPIO_IODIR

/*============================================================================*\
* (RW) _GPIO_IODATA
\*============================================================================*/
#define _GPIO_IODATA_ADDR				(0x3401u)
#define _GPIO_IODATA                       	PREG16(_GPIO_IODATA_ADDR)
#define _IODATA                              	_GPIO_IODATA

/*============================================================================*\
* Generic GPIO register/field get and set macros
\*============================================================================*/

#define GPIO_ADDR(Reg)                    _GPIO_##Reg##_ADDR
#define GPIO_RGET(Reg)                    _PREG_GET(GPIO_ADDR(##Reg))
#define GPIO_RSET(Reg,Val)                _PREG_SET(GPIO_ADDR(##Reg),Val)
#define GPIO_RAOI(Reg,AND,OR,INV)         _PREG_AOI(GPIO_ADDR(##Reg),AND,OR,INV)
#define GPIO_FGET(Reg,Field)              _PFIELD_GET(GPIO_ADDR(##Reg),_GPIO_##Reg##_##Field)
#define GPIO_FSET(Reg,Field,Val)\
   _PFIELD_SET(GPIO_ADDR(##Reg), _GPIO_##Reg##_##Field, Val)
#define GPIO_FSETS(Reg,Field,Sym)\
   GPIO_FSET(##Reg,##Field,GPIO_##Reg##_##Field##_##Sym)
#define GPIO_FAOI(Reg,Field,AND,OR,INV)  _PFIELD_AOI(GPIO_ADDR(##Reg),_GPIO_##Reg##_##Field,AND,OR,INV)
#define GPIO_FMK(Reg,Field,Val)          _GPIO_##Reg##_##Field##_MK(Val)
#define GPIO_FMKS(Reg,Field,Sym)         GPIO_FMK(##Reg,##Field,GPIO_##Reg##_##Field##_##Sym)



/*===========================================================================*\
* _GPIO_IODIR
*
* Fields:
*  (RW) _GPIO_IODIR_IO7DIR
*  (RW) _GPIO_IODIR_IO6DIR
*  (RW) _GPIO_IODIR_IO5DIR
*  (RW) _GPIO_IODIR_IO4DIR
*  (RW) _GPIO_IODIR_IO3DIR
*  (RW) _GPIO_IODIR_IO2DIR
*  (RW) _GPIO_IODIR_IO1DIR
*  (RW) _GPIO_IODIR_IO0DIR
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO7DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO7DIR_SHIFT		(0x0007u)
#define _GPIO_IODIR_IO7DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO7DIR_SHIFT)
#define _GPIO_IODIR_IO7DIR_MASK       	(_GPIO_IODIR_IO7DIR_MK(0x0001u))
#define _GPIO_IODIR_IO7DIR_CLR        	(~(_GPIO_IODIR_IO7DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO6DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO6DIR_SHIFT		(0x0006u)
#define _GPIO_IODIR_IO6DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO6DIR_SHIFT)
#define _GPIO_IODIR_IO6DIR_MASK       	(_GPIO_IODIR_IO6DIR_MK(0x0001u))
#define _GPIO_IODIR_IO6DIR_CLR        	(~(_GPIO_IODIR_IO6DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO5DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO5DIR_SHIFT		(0x0005u)
#define _GPIO_IODIR_IO5DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO5DIR_SHIFT)
#define _GPIO_IODIR_IO5DIR_MASK       	(_GPIO_IODIR_IO5DIR_MK(0x0001u))
#define _GPIO_IODIR_IO5DIR_CLR        	(~(_GPIO_IODIR_IO5DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO4DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO4DIR_SHIFT		(0x0004u)
#define _GPIO_IODIR_IO4DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO4DIR_SHIFT)
#define _GPIO_IODIR_IO4DIR_MASK       	(_GPIO_IODIR_IO4DIR_MK(0x0001u))
#define _GPIO_IODIR_IO4DIR_CLR        	(~(_GPIO_IODIR_IO4DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO3DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO3DIR_SHIFT		(0x0003u)
#define _GPIO_IODIR_IO3DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO3DIR_SHIFT)
#define _GPIO_IODIR_IO3DIR_MASK       	(_GPIO_IODIR_IO3DIR_MK(0x0001u))
#define _GPIO_IODIR_IO3DIR_CLR        	(~(_GPIO_IODIR_IO3DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO2DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO2DIR_SHIFT		(0x0002u)
#define _GPIO_IODIR_IO2DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO2DIR_SHIFT)
#define _GPIO_IODIR_IO2DIR_MASK       	(_GPIO_IODIR_IO2DIR_MK(0x0001u))
#define _GPIO_IODIR_IO2DIR_CLR        	(~(_GPIO_IODIR_IO2DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO1DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO1DIR_SHIFT		(0x0001u)
#define _GPIO_IODIR_IO1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO1DIR_SHIFT)
#define _GPIO_IODIR_IO1DIR_MASK       	(_GPIO_IODIR_IO1DIR_MK(0x0001u))
#define _GPIO_IODIR_IO1DIR_CLR        	(~(_GPIO_IODIR_IO1DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO0DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO0DIR_SHIFT		(0x0000u)
#define _GPIO_IODIR_IO0DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO0DIR_SHIFT)
#define _GPIO_IODIR_IO0DIR_MASK       	(_GPIO_IODIR_IO0DIR_MK(0x0001u))
#define _GPIO_IODIR_IO0DIR_CLR        	(~(_GPIO_IODIR_IO0DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODIR_ADDR,						\
    		(Uint16) (	_GPIO_IODIR_IO0DIR_MK(io0) 		|	\
				_GPIO_IODIR_IO1DIR_MK(io1) 		|	\
				_GPIO_IODIR_IO2DIR_MK(io2) 		|	\
				_GPIO_IODIR_IO3DIR_MK(io3) 		|	\
				_GPIO_IODIR_IO4DIR_MK(io4) 		|	\
				_GPIO_IODIR_IO5DIR_MK(io5) 		|	\
				_GPIO_IODIR_IO6DIR_MK(io6) 		|	\
				_GPIO_IODIR_IO7DIR_MK(io7) 			\
	             ))

/*===========================================================================*\
* _GPIO_IODATA
*
* Fields:
*  (RW) _GPIO_IODATA_IO7D
*  (RW) _GPIO_IODATA_IO6D
*  (RW) _GPIO_IODATA_IO5D
*  (RW) _GPIO_IODATA_IO4D
*  (RW) _GPIO_IODATA_IO3D
*  (RW) _GPIO_IODATA_IO2D
*  (RW) _GPIO_IODATA_IO1D
*  (RW) _GPIO_IODATA_IO0D
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO7D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO7D_SHIFT		(0x0007u)
#define _GPIO_IODATA_IO7D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO7D_SHIFT)
#define _GPIO_IODATA_IO7D_MASK       	(_GPIO_IODATA_IO7D_MK(0x0001u))
#define _GPIO_IODATA_IO7D_CLR        	(~(_GPIO_IODATA_IO7D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO6D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO6D_SHIFT		(0x0006u)
#define _GPIO_IODATA_IO6D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO6D_SHIFT)
#define _GPIO_IODATA_IO6D_MASK       	(_GPIO_IODATA_IO6D_MK(0x0001u))
#define _GPIO_IODATA_IO6D_CLR        	(~(_GPIO_IODATA_IO6D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO5D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO5D_SHIFT		(0x0005u)
#define _GPIO_IODATA_IO5D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO5D_SHIFT)
#define _GPIO_IODATA_IO5D_MASK       	(_GPIO_IODATA_IO5D_MK(0x0001u))
#define _GPIO_IODATA_IO5D_CLR        	(~(_GPIO_IODATA_IO5D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO4D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO4D_SHIFT		(0x0004u)
#define _GPIO_IODATA_IO4D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO4D_SHIFT)
#define _GPIO_IODATA_IO4D_MASK       	(_GPIO_IODATA_IO4D_MK(0x0001u))
#define _GPIO_IODATA_IO4D_CLR        	(~(_GPIO_IODATA_IO4D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO3D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO3D_SHIFT		(0x0003u)
#define _GPIO_IODATA_IO3D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO3D_SHIFT)
#define _GPIO_IODATA_IO3D_MASK       	(_GPIO_IODATA_IO3D_MK(0x0001u))
#define _GPIO_IODATA_IO3D_CLR        	(~(_GPIO_IODATA_IO3D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO2D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO2D_SHIFT		(0x0002u)
#define _GPIO_IODATA_IO2D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO2D_SHIFT)
#define _GPIO_IODATA_IO2D_MASK       	(_GPIO_IODATA_IO2D_MK(0x0001u))
#define _GPIO_IODATA_IO2D_CLR        	(~(_GPIO_IODATA_IO2D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO1D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO1D_SHIFT		(0x0001u)
#define _GPIO_IODATA_IO1D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO1D_SHIFT)
#define _GPIO_IODATA_IO1D_MASK       	(_GPIO_IODATA_IO1D_MK(0x0001u))
#define _GPIO_IODATA_IO1D_CLR        	(~(_GPIO_IODATA_IO1D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO0D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO0D_SHIFT		(0x0000u)
#define _GPIO_IODATA_IO0D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO0D_SHIFT)
#define _GPIO_IODATA_IO0D_MASK       	(_GPIO_IODATA_IO0D_MK(0x0001u))
#define _GPIO_IODATA_IO0D_CLR        	(~(_GPIO_IODATA_IO0D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODATA_ADDR,						\
    		(Uint16) (	_GPIO_IODATA_IO0D_MK(io0) 		|	\
				_GPIO_IODATA_IO1D_MK(io1) 		|	\
				_GPIO_IODATA_IO2D_MK(io2) 		|	\
				_GPIO_IODATA_IO3D_MK(io3) 		|	\
				_GPIO_IODATA_IO4D_MK(io4) 		|	\
				_GPIO_IODATA_IO5D_MK(io5) 		|	\
				_GPIO_IODATA_IO6D_MK(io6) 		|	\
				_GPIO_IODATA_IO7D_MK(io7) 			\
	             ))

#else
   #ifndef _GPIO_MOD
	#error GPIO Hal Module Not Supported on Specified Target
   #endif
#endif
#endif

csl_gpio5509dat/1049976872  98    0     0       1035      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpiodata.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GIO module)
*       Reserved Area for GIO Data 
*
*
\******************************************************************************/
#ifndef _GPIO5509_DAT_H_
  #define _GPIO5509_DAT_H_

  #include <csl_chiphal.h>

  #if (_GPIO_PGPIO_SUPPORT)
    #include <_csl_pgpiodat.h>
 #else
   #include <_csl_gpiodat.h>
 #endif
#endif

csl_gpio5509hal/1049976874  117   0     0       12701     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpiohal.h
* DATE CREATED.. Mon 06/05/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. csl_stdinc.h, csl_chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       06/05/2000 (AP) created
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments  
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the GPIO module)
*
* Registers Covered:
*   (RW) _GPIO_IODIR
*   (RW) _GPIO_IODATA
\******************************************************************************/

#ifndef _GPIO5509HAL_H_
#define _GPIO5509HAL_H_

#include <csl_chiphal.h>

#if (_GPIO_SUPPORT)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _GPIO_IODIR
\*============================================================================*/
#define _GPIO_IODIR_ADDR				(0x3400u)
#define _GPIO_IODIR                       	PREG16(_GPIO_IODIR_ADDR)
#define _IODIR                              	_GPIO_IODIR

/*============================================================================*\
* (RW) _GPIO_IODATA
\*============================================================================*/
#define _GPIO_IODATA_ADDR				(0x3401u)
#define _GPIO_IODATA                       	PREG16(_GPIO_IODATA_ADDR)
#define _IODATA                              	_GPIO_IODATA

/*============================================================================*\
* Generic GPIO register/field get and set macros
\*============================================================================*/

#define GPIO_ADDR(Reg)                    _GPIO_##Reg##_ADDR
#define GPIO_RGET(Reg)                    _PREG_GET(GPIO_ADDR(##Reg))
#define GPIO_RSET(Reg,Val)                _PREG_SET(GPIO_ADDR(##Reg),Val)
#define GPIO_RAOI(Reg,AND,OR,INV)         _PREG_AOI(GPIO_ADDR(##Reg),AND,OR,INV)
#define GPIO_FGET(Reg,Field)              _PFIELD_GET(GPIO_ADDR(##Reg),_GPIO_##Reg##_##Field)
#define GPIO_FSET(Reg,Field,Val)\
   _PFIELD_SET(GPIO_ADDR(##Reg), _GPIO_##Reg##_##Field, Val)
#define GPIO_FSETS(Reg,Field,Sym)\
   GPIO_FSET(##Reg,##Field,GPIO_##Reg##_##Field##_##Sym)
#define GPIO_FAOI(Reg,Field,AND,OR,INV)  _PFIELD_AOI(GPIO_ADDR(##Reg),_GPIO_##Reg##_##Field,AND,OR,INV)
#define GPIO_FMK(Reg,Field,Val)          _GPIO_##Reg##_##Field##_MK(Val)
#define GPIO_FMKS(Reg,Field,Sym)         GPIO_FMK(##Reg,##Field,GPIO_##Reg##_##Field##_##Sym)



/*===========================================================================*\
* _GPIO_IODIR
*
* Fields:
*  (RW) _GPIO_IODIR_IO7DIR
*  (RW) _GPIO_IODIR_IO6DIR
*  (RW) _GPIO_IODIR_IO5DIR
*  (RW) _GPIO_IODIR_IO4DIR
*  (RW) _GPIO_IODIR_IO3DIR
*  (RW) _GPIO_IODIR_IO2DIR
*  (RW) _GPIO_IODIR_IO1DIR
*  (RW) _GPIO_IODIR_IO0DIR
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO7DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO7DIR_SHIFT		(0x0007u)
#define _GPIO_IODIR_IO7DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO7DIR_SHIFT)
#define _GPIO_IODIR_IO7DIR_MASK       	(_GPIO_IODIR_IO7DIR_MK(0x0001u))
#define _GPIO_IODIR_IO7DIR_CLR        	(~(_GPIO_IODIR_IO7DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO6DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO6DIR_SHIFT		(0x0006u)
#define _GPIO_IODIR_IO6DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO6DIR_SHIFT)
#define _GPIO_IODIR_IO6DIR_MASK       	(_GPIO_IODIR_IO6DIR_MK(0x0001u))
#define _GPIO_IODIR_IO6DIR_CLR        	(~(_GPIO_IODIR_IO6DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO5DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO5DIR_SHIFT		(0x0005u)
#define _GPIO_IODIR_IO5DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO5DIR_SHIFT)
#define _GPIO_IODIR_IO5DIR_MASK       	(_GPIO_IODIR_IO5DIR_MK(0x0001u))
#define _GPIO_IODIR_IO5DIR_CLR        	(~(_GPIO_IODIR_IO5DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO4DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO4DIR_SHIFT		(0x0004u)
#define _GPIO_IODIR_IO4DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO4DIR_SHIFT)
#define _GPIO_IODIR_IO4DIR_MASK       	(_GPIO_IODIR_IO4DIR_MK(0x0001u))
#define _GPIO_IODIR_IO4DIR_CLR        	(~(_GPIO_IODIR_IO4DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO3DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO3DIR_SHIFT		(0x0003u)
#define _GPIO_IODIR_IO3DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO3DIR_SHIFT)
#define _GPIO_IODIR_IO3DIR_MASK       	(_GPIO_IODIR_IO3DIR_MK(0x0001u))
#define _GPIO_IODIR_IO3DIR_CLR        	(~(_GPIO_IODIR_IO3DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO2DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO2DIR_SHIFT		(0x0002u)
#define _GPIO_IODIR_IO2DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO2DIR_SHIFT)
#define _GPIO_IODIR_IO2DIR_MASK       	(_GPIO_IODIR_IO2DIR_MK(0x0001u))
#define _GPIO_IODIR_IO2DIR_CLR        	(~(_GPIO_IODIR_IO2DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO1DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO1DIR_SHIFT		(0x0001u)
#define _GPIO_IODIR_IO1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO1DIR_SHIFT)
#define _GPIO_IODIR_IO1DIR_MASK       	(_GPIO_IODIR_IO1DIR_MK(0x0001u))
#define _GPIO_IODIR_IO1DIR_CLR        	(~(_GPIO_IODIR_IO1DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO0DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO0DIR_SHIFT		(0x0000u)
#define _GPIO_IODIR_IO0DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO0DIR_SHIFT)
#define _GPIO_IODIR_IO0DIR_MASK       	(_GPIO_IODIR_IO0DIR_MK(0x0001u))
#define _GPIO_IODIR_IO0DIR_CLR        	(~(_GPIO_IODIR_IO0DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODIR_ADDR,						\
    		(Uint16) (	_GPIO_IODIR_IO0DIR_MK(io0) 		|	\
				_GPIO_IODIR_IO1DIR_MK(io1) 		|	\
				_GPIO_IODIR_IO2DIR_MK(io2) 		|	\
				_GPIO_IODIR_IO3DIR_MK(io3) 		|	\
				_GPIO_IODIR_IO4DIR_MK(io4) 		|	\
				_GPIO_IODIR_IO5DIR_MK(io5) 		|	\
				_GPIO_IODIR_IO6DIR_MK(io6) 		|	\
				_GPIO_IODIR_IO7DIR_MK(io7) 			\
	             ))

/*===========================================================================*\
* _GPIO_IODATA
*
* Fields:
*  (RW) _GPIO_IODATA_IO7D
*  (RW) _GPIO_IODATA_IO6D
*  (RW) _GPIO_IODATA_IO5D
*  (RW) _GPIO_IODATA_IO4D
*  (RW) _GPIO_IODATA_IO3D
*  (RW) _GPIO_IODATA_IO2D
*  (RW) _GPIO_IODATA_IO1D
*  (RW) _GPIO_IODATA_IO0D
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO7D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO7D_SHIFT		(0x0007u)
#define _GPIO_IODATA_IO7D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO7D_SHIFT)
#define _GPIO_IODATA_IO7D_MASK       	(_GPIO_IODATA_IO7D_MK(0x0001u))
#define _GPIO_IODATA_IO7D_CLR        	(~(_GPIO_IODATA_IO7D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO6D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO6D_SHIFT		(0x0006u)
#define _GPIO_IODATA_IO6D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO6D_SHIFT)
#define _GPIO_IODATA_IO6D_MASK       	(_GPIO_IODATA_IO6D_MK(0x0001u))
#define _GPIO_IODATA_IO6D_CLR        	(~(_GPIO_IODATA_IO6D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO5D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO5D_SHIFT		(0x0005u)
#define _GPIO_IODATA_IO5D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO5D_SHIFT)
#define _GPIO_IODATA_IO5D_MASK       	(_GPIO_IODATA_IO5D_MK(0x0001u))
#define _GPIO_IODATA_IO5D_CLR        	(~(_GPIO_IODATA_IO5D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO4D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO4D_SHIFT		(0x0004u)
#define _GPIO_IODATA_IO4D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO4D_SHIFT)
#define _GPIO_IODATA_IO4D_MASK       	(_GPIO_IODATA_IO4D_MK(0x0001u))
#define _GPIO_IODATA_IO4D_CLR        	(~(_GPIO_IODATA_IO4D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO3D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO3D_SHIFT		(0x0003u)
#define _GPIO_IODATA_IO3D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO3D_SHIFT)
#define _GPIO_IODATA_IO3D_MASK       	(_GPIO_IODATA_IO3D_MK(0x0001u))
#define _GPIO_IODATA_IO3D_CLR        	(~(_GPIO_IODATA_IO3D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO2D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO2D_SHIFT		(0x0002u)
#define _GPIO_IODATA_IO2D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO2D_SHIFT)
#define _GPIO_IODATA_IO2D_MASK       	(_GPIO_IODATA_IO2D_MK(0x0001u))
#define _GPIO_IODATA_IO2D_CLR        	(~(_GPIO_IODATA_IO2D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO1D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO1D_SHIFT		(0x0001u)
#define _GPIO_IODATA_IO1D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO1D_SHIFT)
#define _GPIO_IODATA_IO1D_MASK       	(_GPIO_IODATA_IO1D_MK(0x0001u))
#define _GPIO_IODATA_IO1D_CLR        	(~(_GPIO_IODATA_IO1D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO0D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO0D_SHIFT		(0x0000u)
#define _GPIO_IODATA_IO0D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO0D_SHIFT)
#define _GPIO_IODATA_IO0D_MASK       	(_GPIO_IODATA_IO0D_MK(0x0001u))
#define _GPIO_IODATA_IO0D_CLR        	(~(_GPIO_IODATA_IO0D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODATA_ADDR,						\
    		(Uint16) (	_GPIO_IODATA_IO0D_MK(io0) 		|	\
				_GPIO_IODATA_IO1D_MK(io1) 		|	\
				_GPIO_IODATA_IO2D_MK(io2) 		|	\
				_GPIO_IODATA_IO3D_MK(io3) 		|	\
				_GPIO_IODATA_IO4D_MK(io4) 		|	\
				_GPIO_IODATA_IO5D_MK(io5) 		|	\
				_GPIO_IODATA_IO6D_MK(io6) 		|	\
				_GPIO_IODATA_IO7D_MK(io7) 			\
	             ))

#else
   #ifndef _GPIO_MOD
	#error GPIO Hal Module Not Supported on Specified Target
   #endif
#endif
#endif

csl_gpio5510.h/ 1049976875  0     0     0       1443      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpio.h
* DATE CREATED.. Fri 06/09/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS.. 
* VERSION....... 1.00
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:         06/09/2000 created for C5510
*   LAST MODIFIED:   04/16/2001 updated module name and other header comments
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GPIO module)
*
*
*
\******************************************************************************/
#ifndef _CSL_GPIO5510_H_
  #define _CSL_GPIO5510_H_

  #include <csl.h>
  #include <csl_chiphal.h>

   #if (_GPIO_SUPPORT)

     #if (_GPIO_PGPIO_SUPPORT)
        #include <_csl_pgpio.h>
     #else
       #include <_csl_gpio.h>
     #endif

  #endif 					/* _GPIO_SUPPORT_ */
#endif   /* _CSL_GPIO_H_ */
/******************************************************************************\
* End of gpio.h
\******************************************************************************/

csl_gpio5510dat/1049976877  136   0     0       1035      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpiodata.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GIO module)
*       Reserved Area for GIO Data 
*
*
\******************************************************************************/
#ifndef _GPIO5510_DAT_H_
  #define _GPIO5510_DAT_H_

  #include <csl_chiphal.h>

  #if (_GPIO_PGPIO_SUPPORT)
    #include <_csl_pgpiodat.h>
 #else
   #include <_csl_gpiodat.h>
 #endif
#endif

csl_gpio5510hal/1049976878  155   0     0       12701     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpiohal.h
* DATE CREATED.. Mon 06/05/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. csl_stdinc.h, csl_chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       06/05/2000 (AP) created
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments  
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the GPIO module)
*
* Registers Covered:
*   (RW) _GPIO_IODIR
*   (RW) _GPIO_IODATA
\******************************************************************************/

#ifndef _GPIO5510HAL_H_
#define _GPIO5510HAL_H_

#include <csl_chiphal.h>

#if (_GPIO_SUPPORT)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _GPIO_IODIR
\*============================================================================*/
#define _GPIO_IODIR_ADDR				(0x3400u)
#define _GPIO_IODIR                       	PREG16(_GPIO_IODIR_ADDR)
#define _IODIR                              	_GPIO_IODIR

/*============================================================================*\
* (RW) _GPIO_IODATA
\*============================================================================*/
#define _GPIO_IODATA_ADDR				(0x3401u)
#define _GPIO_IODATA                       	PREG16(_GPIO_IODATA_ADDR)
#define _IODATA                              	_GPIO_IODATA

/*============================================================================*\
* Generic GPIO register/field get and set macros
\*============================================================================*/

#define GPIO_ADDR(Reg)                    _GPIO_##Reg##_ADDR
#define GPIO_RGET(Reg)                    _PREG_GET(GPIO_ADDR(##Reg))
#define GPIO_RSET(Reg,Val)                _PREG_SET(GPIO_ADDR(##Reg),Val)
#define GPIO_RAOI(Reg,AND,OR,INV)         _PREG_AOI(GPIO_ADDR(##Reg),AND,OR,INV)
#define GPIO_FGET(Reg,Field)              _PFIELD_GET(GPIO_ADDR(##Reg),_GPIO_##Reg##_##Field)
#define GPIO_FSET(Reg,Field,Val)\
   _PFIELD_SET(GPIO_ADDR(##Reg), _GPIO_##Reg##_##Field, Val)
#define GPIO_FSETS(Reg,Field,Sym)\
   GPIO_FSET(##Reg,##Field,GPIO_##Reg##_##Field##_##Sym)
#define GPIO_FAOI(Reg,Field,AND,OR,INV)  _PFIELD_AOI(GPIO_ADDR(##Reg),_GPIO_##Reg##_##Field,AND,OR,INV)
#define GPIO_FMK(Reg,Field,Val)          _GPIO_##Reg##_##Field##_MK(Val)
#define GPIO_FMKS(Reg,Field,Sym)         GPIO_FMK(##Reg,##Field,GPIO_##Reg##_##Field##_##Sym)



/*===========================================================================*\
* _GPIO_IODIR
*
* Fields:
*  (RW) _GPIO_IODIR_IO7DIR
*  (RW) _GPIO_IODIR_IO6DIR
*  (RW) _GPIO_IODIR_IO5DIR
*  (RW) _GPIO_IODIR_IO4DIR
*  (RW) _GPIO_IODIR_IO3DIR
*  (RW) _GPIO_IODIR_IO2DIR
*  (RW) _GPIO_IODIR_IO1DIR
*  (RW) _GPIO_IODIR_IO0DIR
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO7DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO7DIR_SHIFT		(0x0007u)
#define _GPIO_IODIR_IO7DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO7DIR_SHIFT)
#define _GPIO_IODIR_IO7DIR_MASK       	(_GPIO_IODIR_IO7DIR_MK(0x0001u))
#define _GPIO_IODIR_IO7DIR_CLR        	(~(_GPIO_IODIR_IO7DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO6DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO6DIR_SHIFT		(0x0006u)
#define _GPIO_IODIR_IO6DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO6DIR_SHIFT)
#define _GPIO_IODIR_IO6DIR_MASK       	(_GPIO_IODIR_IO6DIR_MK(0x0001u))
#define _GPIO_IODIR_IO6DIR_CLR        	(~(_GPIO_IODIR_IO6DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO5DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO5DIR_SHIFT		(0x0005u)
#define _GPIO_IODIR_IO5DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO5DIR_SHIFT)
#define _GPIO_IODIR_IO5DIR_MASK       	(_GPIO_IODIR_IO5DIR_MK(0x0001u))
#define _GPIO_IODIR_IO5DIR_CLR        	(~(_GPIO_IODIR_IO5DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO4DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO4DIR_SHIFT		(0x0004u)
#define _GPIO_IODIR_IO4DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO4DIR_SHIFT)
#define _GPIO_IODIR_IO4DIR_MASK       	(_GPIO_IODIR_IO4DIR_MK(0x0001u))
#define _GPIO_IODIR_IO4DIR_CLR        	(~(_GPIO_IODIR_IO4DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO3DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO3DIR_SHIFT		(0x0003u)
#define _GPIO_IODIR_IO3DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO3DIR_SHIFT)
#define _GPIO_IODIR_IO3DIR_MASK       	(_GPIO_IODIR_IO3DIR_MK(0x0001u))
#define _GPIO_IODIR_IO3DIR_CLR        	(~(_GPIO_IODIR_IO3DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO2DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO2DIR_SHIFT		(0x0002u)
#define _GPIO_IODIR_IO2DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO2DIR_SHIFT)
#define _GPIO_IODIR_IO2DIR_MASK       	(_GPIO_IODIR_IO2DIR_MK(0x0001u))
#define _GPIO_IODIR_IO2DIR_CLR        	(~(_GPIO_IODIR_IO2DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO1DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO1DIR_SHIFT		(0x0001u)
#define _GPIO_IODIR_IO1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO1DIR_SHIFT)
#define _GPIO_IODIR_IO1DIR_MASK       	(_GPIO_IODIR_IO1DIR_MK(0x0001u))
#define _GPIO_IODIR_IO1DIR_CLR        	(~(_GPIO_IODIR_IO1DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO0DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO0DIR_SHIFT		(0x0000u)
#define _GPIO_IODIR_IO0DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO0DIR_SHIFT)
#define _GPIO_IODIR_IO0DIR_MASK       	(_GPIO_IODIR_IO0DIR_MK(0x0001u))
#define _GPIO_IODIR_IO0DIR_CLR        	(~(_GPIO_IODIR_IO0DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODIR_ADDR,						\
    		(Uint16) (	_GPIO_IODIR_IO0DIR_MK(io0) 		|	\
				_GPIO_IODIR_IO1DIR_MK(io1) 		|	\
				_GPIO_IODIR_IO2DIR_MK(io2) 		|	\
				_GPIO_IODIR_IO3DIR_MK(io3) 		|	\
				_GPIO_IODIR_IO4DIR_MK(io4) 		|	\
				_GPIO_IODIR_IO5DIR_MK(io5) 		|	\
				_GPIO_IODIR_IO6DIR_MK(io6) 		|	\
				_GPIO_IODIR_IO7DIR_MK(io7) 			\
	             ))

/*===========================================================================*\
* _GPIO_IODATA
*
* Fields:
*  (RW) _GPIO_IODATA_IO7D
*  (RW) _GPIO_IODATA_IO6D
*  (RW) _GPIO_IODATA_IO5D
*  (RW) _GPIO_IODATA_IO4D
*  (RW) _GPIO_IODATA_IO3D
*  (RW) _GPIO_IODATA_IO2D
*  (RW) _GPIO_IODATA_IO1D
*  (RW) _GPIO_IODATA_IO0D
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO7D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO7D_SHIFT		(0x0007u)
#define _GPIO_IODATA_IO7D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO7D_SHIFT)
#define _GPIO_IODATA_IO7D_MASK       	(_GPIO_IODATA_IO7D_MK(0x0001u))
#define _GPIO_IODATA_IO7D_CLR        	(~(_GPIO_IODATA_IO7D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO6D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO6D_SHIFT		(0x0006u)
#define _GPIO_IODATA_IO6D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO6D_SHIFT)
#define _GPIO_IODATA_IO6D_MASK       	(_GPIO_IODATA_IO6D_MK(0x0001u))
#define _GPIO_IODATA_IO6D_CLR        	(~(_GPIO_IODATA_IO6D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO5D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO5D_SHIFT		(0x0005u)
#define _GPIO_IODATA_IO5D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO5D_SHIFT)
#define _GPIO_IODATA_IO5D_MASK       	(_GPIO_IODATA_IO5D_MK(0x0001u))
#define _GPIO_IODATA_IO5D_CLR        	(~(_GPIO_IODATA_IO5D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO4D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO4D_SHIFT		(0x0004u)
#define _GPIO_IODATA_IO4D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO4D_SHIFT)
#define _GPIO_IODATA_IO4D_MASK       	(_GPIO_IODATA_IO4D_MK(0x0001u))
#define _GPIO_IODATA_IO4D_CLR        	(~(_GPIO_IODATA_IO4D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO3D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO3D_SHIFT		(0x0003u)
#define _GPIO_IODATA_IO3D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO3D_SHIFT)
#define _GPIO_IODATA_IO3D_MASK       	(_GPIO_IODATA_IO3D_MK(0x0001u))
#define _GPIO_IODATA_IO3D_CLR        	(~(_GPIO_IODATA_IO3D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO2D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO2D_SHIFT		(0x0002u)
#define _GPIO_IODATA_IO2D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO2D_SHIFT)
#define _GPIO_IODATA_IO2D_MASK       	(_GPIO_IODATA_IO2D_MK(0x0001u))
#define _GPIO_IODATA_IO2D_CLR        	(~(_GPIO_IODATA_IO2D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO1D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO1D_SHIFT		(0x0001u)
#define _GPIO_IODATA_IO1D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO1D_SHIFT)
#define _GPIO_IODATA_IO1D_MASK       	(_GPIO_IODATA_IO1D_MK(0x0001u))
#define _GPIO_IODATA_IO1D_CLR        	(~(_GPIO_IODATA_IO1D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO0D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO0D_SHIFT		(0x0000u)
#define _GPIO_IODATA_IO0D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO0D_SHIFT)
#define _GPIO_IODATA_IO0D_MASK       	(_GPIO_IODATA_IO0D_MK(0x0001u))
#define _GPIO_IODATA_IO0D_CLR        	(~(_GPIO_IODATA_IO0D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODATA_ADDR,						\
    		(Uint16) (	_GPIO_IODATA_IO0D_MK(io0) 		|	\
				_GPIO_IODATA_IO1D_MK(io1) 		|	\
				_GPIO_IODATA_IO2D_MK(io2) 		|	\
				_GPIO_IODATA_IO3D_MK(io3) 		|	\
				_GPIO_IODATA_IO4D_MK(io4) 		|	\
				_GPIO_IODATA_IO5D_MK(io5) 		|	\
				_GPIO_IODATA_IO6D_MK(io6) 		|	\
				_GPIO_IODATA_IO7D_MK(io7) 			\
	             ))

#else
   #ifndef _GPIO_MOD
	#error GPIO Hal Module Not Supported on Specified Target
   #endif
#endif
#endif

csl_gpiodat.h/  1049976879  0     0     0       1132      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... gpiodata.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the GIO module)
*       Reserved Area for GIO Data 
*
*
\******************************************************************************/
#ifndef _GPIO_DAT_H_
  #define _GPIO_DAT_H_

  #include <csl_chiphal.h>

  #if (CHIP_5509_FAMILY)
    #include <csl_gpio5509dat.h>
  #elif (CHIP_5502_FAMILY)
    #include <csl_gpio5502dat.h>
  #else    /* Default (CHIP_5510_FAMILY) */
    #include <csl_gpio5510dat.h>
  #endif

#endif
csl_gpiohal.h/  1049976881  0     0     0       12693     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... GPIO
* FILENAME...... csl_gpiohal.h
* DATE CREATED.. Mon 06/05/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. csl_stdinc.h, csl_chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       06/05/2000 (AP) created
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments  
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the GPIO module)
*
* Registers Covered:
*   (RW) _GPIO_IODIR
*   (RW) _GPIO_IODATA
\******************************************************************************/

#ifndef _GPIOHAL_H_
#define _GPIOHAL_H_

#include <csl_chiphal.h>

#if (_GPIO_SUPPORT)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _GPIO_IODIR
\*============================================================================*/
#define _GPIO_IODIR_ADDR				(0x3400u)
#define _GPIO_IODIR                       	PREG16(_GPIO_IODIR_ADDR)
#define _IODIR                              	_GPIO_IODIR

/*============================================================================*\
* (RW) _GPIO_IODATA
\*============================================================================*/
#define _GPIO_IODATA_ADDR				(0x3401u)
#define _GPIO_IODATA                       	PREG16(_GPIO_IODATA_ADDR)
#define _IODATA                              	_GPIO_IODATA

/*============================================================================*\
* Generic GPIO register/field get and set macros
\*============================================================================*/

#define GPIO_ADDR(Reg)                    _GPIO_##Reg##_ADDR
#define GPIO_RGET(Reg)                    _PREG_GET(GPIO_ADDR(##Reg))
#define GPIO_RSET(Reg,Val)                _PREG_SET(GPIO_ADDR(##Reg),Val)
#define GPIO_RAOI(Reg,AND,OR,INV)         _PREG_AOI(GPIO_ADDR(##Reg),AND,OR,INV)
#define GPIO_FGET(Reg,Field)              _PFIELD_GET(GPIO_ADDR(##Reg),_GPIO_##Reg##_##Field)
#define GPIO_FSET(Reg,Field,Val)\
   _PFIELD_SET(GPIO_ADDR(##Reg), _GPIO_##Reg##_##Field, Val)
#define GPIO_FSETS(Reg,Field,Sym)\
   GPIO_FSET(##Reg,##Field,GPIO_##Reg##_##Field##_##Sym)
#define GPIO_FAOI(Reg,Field,AND,OR,INV)  _PFIELD_AOI(GPIO_ADDR(##Reg),_GPIO_##Reg##_##Field,AND,OR,INV)
#define GPIO_FMK(Reg,Field,Val)          _GPIO_##Reg##_##Field##_MK(Val)
#define GPIO_FMKS(Reg,Field,Sym)         GPIO_FMK(##Reg,##Field,GPIO_##Reg##_##Field##_##Sym)



/*===========================================================================*\
* _GPIO_IODIR
*
* Fields:
*  (RW) _GPIO_IODIR_IO7DIR
*  (RW) _GPIO_IODIR_IO6DIR
*  (RW) _GPIO_IODIR_IO5DIR
*  (RW) _GPIO_IODIR_IO4DIR
*  (RW) _GPIO_IODIR_IO3DIR
*  (RW) _GPIO_IODIR_IO2DIR
*  (RW) _GPIO_IODIR_IO1DIR
*  (RW) _GPIO_IODIR_IO0DIR
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO7DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO7DIR_SHIFT		(0x0007u)
#define _GPIO_IODIR_IO7DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO7DIR_SHIFT)
#define _GPIO_IODIR_IO7DIR_MASK       	(_GPIO_IODIR_IO7DIR_MK(0x0001u))
#define _GPIO_IODIR_IO7DIR_CLR        	(~(_GPIO_IODIR_IO7DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO6DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO6DIR_SHIFT		(0x0006u)
#define _GPIO_IODIR_IO6DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO6DIR_SHIFT)
#define _GPIO_IODIR_IO6DIR_MASK       	(_GPIO_IODIR_IO6DIR_MK(0x0001u))
#define _GPIO_IODIR_IO6DIR_CLR        	(~(_GPIO_IODIR_IO6DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO5DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO5DIR_SHIFT		(0x0005u)
#define _GPIO_IODIR_IO5DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO5DIR_SHIFT)
#define _GPIO_IODIR_IO5DIR_MASK       	(_GPIO_IODIR_IO5DIR_MK(0x0001u))
#define _GPIO_IODIR_IO5DIR_CLR        	(~(_GPIO_IODIR_IO5DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO4DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO4DIR_SHIFT		(0x0004u)
#define _GPIO_IODIR_IO4DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO4DIR_SHIFT)
#define _GPIO_IODIR_IO4DIR_MASK       	(_GPIO_IODIR_IO4DIR_MK(0x0001u))
#define _GPIO_IODIR_IO4DIR_CLR        	(~(_GPIO_IODIR_IO4DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO3DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO3DIR_SHIFT		(0x0003u)
#define _GPIO_IODIR_IO3DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO3DIR_SHIFT)
#define _GPIO_IODIR_IO3DIR_MASK       	(_GPIO_IODIR_IO3DIR_MK(0x0001u))
#define _GPIO_IODIR_IO3DIR_CLR        	(~(_GPIO_IODIR_IO3DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO2DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO2DIR_SHIFT		(0x0002u)
#define _GPIO_IODIR_IO2DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO2DIR_SHIFT)
#define _GPIO_IODIR_IO2DIR_MASK       	(_GPIO_IODIR_IO2DIR_MK(0x0001u))
#define _GPIO_IODIR_IO2DIR_CLR        	(~(_GPIO_IODIR_IO2DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO1DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO1DIR_SHIFT		(0x0001u)
#define _GPIO_IODIR_IO1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO1DIR_SHIFT)
#define _GPIO_IODIR_IO1DIR_MASK       	(_GPIO_IODIR_IO1DIR_MK(0x0001u))
#define _GPIO_IODIR_IO1DIR_CLR        	(~(_GPIO_IODIR_IO1DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR_IO0DIR
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_IO0DIR_SHIFT		(0x0000u)
#define _GPIO_IODIR_IO0DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODIR_IO0DIR_SHIFT)
#define _GPIO_IODIR_IO0DIR_MASK       	(_GPIO_IODIR_IO0DIR_MK(0x0001u))
#define _GPIO_IODIR_IO0DIR_CLR        	(~(_GPIO_IODIR_IO0DIR_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODIR 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODIR_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODIR_ADDR,						\
    		(Uint16) (	_GPIO_IODIR_IO0DIR_MK(io0) 		|	\
				_GPIO_IODIR_IO1DIR_MK(io1) 		|	\
				_GPIO_IODIR_IO2DIR_MK(io2) 		|	\
				_GPIO_IODIR_IO3DIR_MK(io3) 		|	\
				_GPIO_IODIR_IO4DIR_MK(io4) 		|	\
				_GPIO_IODIR_IO5DIR_MK(io5) 		|	\
				_GPIO_IODIR_IO6DIR_MK(io6) 		|	\
				_GPIO_IODIR_IO7DIR_MK(io7) 			\
	             ))

/*===========================================================================*\
* _GPIO_IODATA
*
* Fields:
*  (RW) _GPIO_IODATA_IO7D
*  (RW) _GPIO_IODATA_IO6D
*  (RW) _GPIO_IODATA_IO5D
*  (RW) _GPIO_IODATA_IO4D
*  (RW) _GPIO_IODATA_IO3D
*  (RW) _GPIO_IODATA_IO2D
*  (RW) _GPIO_IODATA_IO1D
*  (RW) _GPIO_IODATA_IO0D
\*==========================================================================*/

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO7D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO7D_SHIFT		(0x0007u)
#define _GPIO_IODATA_IO7D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO7D_SHIFT)
#define _GPIO_IODATA_IO7D_MASK       	(_GPIO_IODATA_IO7D_MK(0x0001u))
#define _GPIO_IODATA_IO7D_CLR        	(~(_GPIO_IODATA_IO7D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO6D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO6D_SHIFT		(0x0006u)
#define _GPIO_IODATA_IO6D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO6D_SHIFT)
#define _GPIO_IODATA_IO6D_MASK       	(_GPIO_IODATA_IO6D_MK(0x0001u))
#define _GPIO_IODATA_IO6D_CLR        	(~(_GPIO_IODATA_IO6D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO5D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO5D_SHIFT		(0x0005u)
#define _GPIO_IODATA_IO5D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO5D_SHIFT)
#define _GPIO_IODATA_IO5D_MASK       	(_GPIO_IODATA_IO5D_MK(0x0001u))
#define _GPIO_IODATA_IO5D_CLR        	(~(_GPIO_IODATA_IO5D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO4D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO4D_SHIFT		(0x0004u)
#define _GPIO_IODATA_IO4D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO4D_SHIFT)
#define _GPIO_IODATA_IO4D_MASK       	(_GPIO_IODATA_IO4D_MK(0x0001u))
#define _GPIO_IODATA_IO4D_CLR        	(~(_GPIO_IODATA_IO4D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO3D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO3D_SHIFT		(0x0003u)
#define _GPIO_IODATA_IO3D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO3D_SHIFT)
#define _GPIO_IODATA_IO3D_MASK       	(_GPIO_IODATA_IO3D_MK(0x0001u))
#define _GPIO_IODATA_IO3D_CLR        	(~(_GPIO_IODATA_IO3D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO2D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO2D_SHIFT		(0x0002u)
#define _GPIO_IODATA_IO2D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO2D_SHIFT)
#define _GPIO_IODATA_IO2D_MASK       	(_GPIO_IODATA_IO2D_MK(0x0001u))
#define _GPIO_IODATA_IO2D_CLR        	(~(_GPIO_IODATA_IO2D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO1D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO1D_SHIFT		(0x0001u)
#define _GPIO_IODATA_IO1D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO1D_SHIFT)
#define _GPIO_IODATA_IO1D_MASK       	(_GPIO_IODATA_IO1D_MK(0x0001u))
#define _GPIO_IODATA_IO1D_CLR        	(~(_GPIO_IODATA_IO1D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA_IO0D
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_IO0D_SHIFT		(0x0000u)
#define _GPIO_IODATA_IO0D_MK(n)		(((Uint16)(n) & 0x0001u) << _GPIO_IODATA_IO0D_SHIFT)
#define _GPIO_IODATA_IO0D_MASK       	(_GPIO_IODATA_IO0D_MK(0x0001u))
#define _GPIO_IODATA_IO0D_CLR        	(~(_GPIO_IODATA_IO0D_MK(0x0001u)))

/*==========================================================================*\
* (RW) _GPIO_IODATA 	- Config
\*--------------------------------------------------------------------------*/
#define _GPIO_IODATA_CFG(io0,io1,io2,io3,io4,io5,io6,io7)  \
	HPREG_SET(_GPIO_IODATA_ADDR,						\
    		(Uint16) (	_GPIO_IODATA_IO0D_MK(io0) 		|	\
				_GPIO_IODATA_IO1D_MK(io1) 		|	\
				_GPIO_IODATA_IO2D_MK(io2) 		|	\
				_GPIO_IODATA_IO3D_MK(io3) 		|	\
				_GPIO_IODATA_IO4D_MK(io4) 		|	\
				_GPIO_IODATA_IO5D_MK(io5) 		|	\
				_GPIO_IODATA_IO6D_MK(io6) 		|	\
				_GPIO_IODATA_IO7D_MK(io7) 			\
	             ))

#else
   #ifndef _GPIO_MOD
	#error GPIO Hal Module Not Supported on Specified Target
   #endif
#endif
#endif

csl_gpt.h/      1067582948  0     0     0       41448     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated. 
*                           All Rights Reserved  
*------------------------------------------------------------------------------ 
* MODULE NAME... GPT 
* FILENAME...... csl_gpt.h 
* DATE CREATED.. Sat Feb  9 16:13:17 2002 
* PROJECT....... Chip Support Library 
* COMPONENT..... Service Layer 
* PREREQUISITS..  
*------------------------------------------------------------------------------ 
* 
* HISTORY: 
*	 Created:	Sat Feb  9 16:13:17 2002 (Automatic generation) 
*	 Modified:	10/30/2003 Fixed few typos in macros, added TDDR34 
*                          in GPTGCTL1_RMK, added IDEF and IDECL for _stop12()
*                          and _stop34() API and fixed bug in _stop()
*               03/12/2003 Modified register names and fields as per SPRU618A.   
* 
*------------------------------------------------------------------------------ 
* DESCRIPTION: CSL Service Layer interface for the GPT module  
* 
\*************************************************************************/ 
 
#ifndef _CSL_GPT_H_ 
#define _CSL_GPT_H_ 
 
#include <csl_gpthal.h> 
#include <csl_std.h> 
#include <_csl.h> 
#include <csl_chiphal.h> 
 
#if (_GPT_SUPPORT)  
 
/*----------------------------------------------------------------*\
*	 GPT scope and inline control macros 			 
\*----------------------------------------------------------------*/ 
 
#ifdef __cplusplus 
#define CSLAPI extern "C" 
#else 
#define CSLAPI extern  
#endif 
 
#undef  USEDEFS 
#undef  IDECL 
#undef  IDEF 
 
#ifdef  _GPT_MOD_ 
  #define IDECL CSLAPI 
  #define IDEF 
#else 
  #ifdef  _INLINE 
    #define IDECL static inline 
    #define USEDEFS 
    #define IDEF  static inline 
  #else 
    #define IDECL CSLAPI 
 #endif 
#endif 
 
/****************************************\
* GPT global macro declarations 
\****************************************/ 
 
/* error codes */ 
#define GPT_ERR_MAJOR		   (ERR_BASE_GPT)  
#define GPT_ERR_ALLOC		   (0x00000000)  
#define GPT_ERR_INVALID_HANDLE  (0x00000001)  
 
#define GPT_DEVICE_CNT		2 
 
/* GPT_Open() flags */ 
#define GPT_OPEN_RESET	  (0x0001) 
 
/* device identifiers for GPT_Open() */ 
#define GPT_DEVANY  (-1) 
#define GPT_DEV0    (0) 
#define GPT_DEV1    (1) 
 
/* define a debuging assertion macro for validating device handles */ 
#ifdef _MCRTE_DEBUG 
  #define GPT_ASSERT_HANDLE(hGPT,RetExp) \
    if (hGPT == INV) { \
       ERR_submit(GPT_ERR_MAJOR, GPT_ERR_INVALID_HANDLE); \
       RetExp; \
    }  
#else 
  #define GPT_ASSERT_HANDLE(hGPT,RetExp)  
#endif 
 
/*******************************************\
* GPT global macro definition : ROMABILITY  
\*******************************************/  
/* Reserved ROM Area for GPTData.h */ 
/* Data definition */   
#define GPT_Initialized            GPT_SYM(0) 
#define GPT_DeviceTable            GPT_SYM(1) 
 
/* Predefined Device Handlers */ 
 
#define GPT_hDev0 ((GPT_Handle)&(CSL_GPT_DATA.Gpt[0])) 
 
#define GPT_hDev1 ((GPT_Handle)&(CSL_GPT_DATA.Gpt[1])) 
 
#define GPT_hDev(dev) ((GPT_Handle)&(CSL_GPT_DATA.Gpt[dev])) 
 
/* ============================================================== */ 
/*  Generic Access Macros                                         */ 
/* ============================================================== */ 
 
#define GPT_getEventId(hGpt)   (((GPT_PrivateObj *)hGpt)->EventId) 
 
/* ============================================================== */ 
 /* Make GPTCLK register values based on symbolic constants  */ 
 
/*  GPTCLK field values  */ 
 	
	#define GPT_GPTCLK_CLKDIV_DIV0	       (0x0000u) 
	#define GPT_GPTCLK_CLKDIV_DIV1	       (0x0001u) 
	#define GPT_GPTCLK_CLKDIV_DIV2	       (0x0002u) 
	#define GPT_GPTCLK_CLKDIV_DIV4	       (0x0004u) 
	#define GPT_GPTCLK_CLKDIV_DIV8	       (0x0008u)
	#define GPT_GPTCLK_CLKDIV_DEFAULT      GPT_GPTCLK_CLKDIV_DIV0
	
	#define GPT_GPTCLK0_CLKDIV_DIV0	       (0x0000u) 
	#define GPT_GPTCLK0_CLKDIV_DIV1	       (0x0001u) 
	#define GPT_GPTCLK0_CLKDIV_DIV2	       (0x0002u) 
	#define GPT_GPTCLK0_CLKDIV_DIV4	       (0x0004u) 
	#define GPT_GPTCLK0_CLKDIV_DIV8	       (0x0008u) 
	#define GPT_GPTCLK0_CLKDIV_DEFAULT     GPT_GPTCLK0_CLKDIV_DIV0
 
        #define GPT_GPTCLK1_CLKDIV_DIV0	       (0x0000u) 
	#define GPT_GPTCLK1_CLKDIV_DIV1	       (0x0001u) 
	#define GPT_GPTCLK1_CLKDIV_DIV2	       (0x0002u) 
	#define GPT_GPTCLK1_CLKDIV_DIV4	       (0x0004u) 
	#define GPT_GPTCLK1_CLKDIV_DIV8	       (0x0008u) 
	#define GPT_GPTCLK1_CLKDIV_DEFAULT     GPT_GPTCLK1_CLKDIV_DIV0

 
 
/*  Default GPTCLK register value  */ 
 
/* ============================================================== */ 
 /* Make GPTCNT1 register values based on symbolic constants  */ 
 
/*  GPTCNT1 field values  */ 
 
	#define GPT_GPTCNT1_CNT1_OF(x)		((Uint16)(x)) 
      #define GPT_GPTCNT1_CNT1_DEFAULT     	GPT_GPTCNT1_CNT1_OF(0) 
 
	#define GPT_GPTCNT10_CNT1_OF(x)		((Uint16)(x)) 
      #define GPT_GPTCNT10_CNT1_DEFAULT     	GPT_GPTCNT1_CNT1_OF(0) 
 
	#define GPT_GPTCNT11_CNT1_OF(x)		((Uint16)(x)) 
      #define GPT_GPTCNT11_CNT1_DEFAULT     	GPT_GPTCNT1_CNT1_OF(0) 
 
 /*
#define GPT_GPTCNT1_RMK(cnt1) \
 ((Uint16) ( \
  ( GPT_FMK(GPTCNT1,CNT1,##cnt1##)) \
) \
 ) 
 */

#define GPT_GPTCNT1_RMK(cnt1) \
 ((Uint16) ( \
  ( GPT_FMK(GPTCNT1,CNT1,##cnt1##)) \
) \
 )
  
#define GPT_GPTCNT1_RMKS(cnt1_sym) \
 ((Uint16) ( \
  ( GPT_FMKS(GPTCNT1,CNT1,cnt1_sym)) \
) \
 ) 
 
/*  Default GPTCNT1 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTCNT2 register values based on symbolic constants  */ 
 
/*  GPTCNT2 field values  */ 
 
	#define GPT_GPTCNT2_CNT2_OF(x)		((Uint16)(x)) 
	#define GPT_GPTCNT2_CNT2_DEFAULT		GPT_GPTCNT2_CNT2_OF(0) 
 
	#define GPT_GPTCNT20_CNT2_OF(x)		((Uint16)(x)) 
	#define GPT_GPTCNT20_CNT2_DEFAULT		GPT_GPTCNT2_CNT2_OF(0) 
 
	#define GPT_GPTCNT21_CNT2_OF(x)		((Uint16)(x)) 
	#define GPT_GPTCNT21_CNT2_DEFAULT		GPT_GPTCNT2_CNT2_OF(0) 
 
 
#define GPT_GPTCNT2_RMK(cnt2)\
 ((Uint16) ( \
  ( GPT_FMK(GPTCNT2,CNT2,cnt2))\
)\
 ) 
 
#define GPT_GPTCNT2_RMKS(cnt2_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTCNT2,CNT2,cnt2_sym))\
)\
 ) 
 
/*  Default GPTCNT2 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTCNT3 register values based on symbolic constants  */ 
 
/*  GPTCNT3 field values  */ 
 
	#define GPT_GPTCNT3_CNT3_OF(x)		((Uint16)(x)) 
	#define GPT_GPTCNT3_CNT3_DEFAULT		GPT_GPTCNT3_CNT3_OF(0) 
 
	#define GPT_GPTCNT30_CNT3_OF(x)		((Uint16)(x)) 
	#define GPT_GPTCNT30_CNT3_DEFAULT		GPT_GPTCNT3_CNT3_OF(0) 
 
	#define GPT_GPTCNT31_CNT3_OF(x)		((Uint16)(x)) 
	#define GPT_GPTCNT31_CNT3_DEFAULT		GPT_GPTCNT3_CNT3_OF(0) 
 
 
#define GPT_GPTCNT3_RMK(cnt3)\
 ((Uint16) ( \
  ( GPT_FMK(GPTCNT3,CNT3,cnt3))\
)\
 ) 
 
#define GPT_GPTCNT3_RMKS(cnt3_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTCNT3,CNT3,cnt3_sym))\
)\
 ) 
 
/*  Default GPTCNT3 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTCNT4 register values based on symbolic constants  */ 
 
/*  GPTCNT4 field values  */ 
 
	#define GPT_GPTCNT4_CNT4_OF(x)		((Uint16)(x)) 
	#define GPT_GPTCNT4_CNT4_DEFAULT		GPT_GPTCNT4_CNT4_OF(0) 
 
	#define GPT_GPTCNT40_CNT4_OF(x)		((Uint16)(x)) 
	#define GPT_GPTCNT40_CNT4_DEFAULT		GPT_GPTCNT4_CNT4_OF(0) 
 
	#define GPT_GPTCNT41_CNT4_OF(x)		((Uint16)(x)) 
	#define GPT_GPTCNT41_CNT4_DEFAULT		GPT_GPTCNT4_CNT4_OF(0) 
 
 
#define GPT_GPTCNT4_RMK(cnt4)\
 ((Uint16) ( \
  ( GPT_FMK(GPTCNT4,CNT4,cnt4))\
)\
 ) 
 
#define GPT_GPTCNT4_RMKS(cnt4_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTCNT4,CNT4,cnt4_sym))\
)\
 ) 
 
/*  Default GPTCNT4 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTCTL1 register values based on symbolic constants  */ 
 
/*  GPTCTL1 field values  */ 
 
	#define GPT_GPTCTL1_TIEN_NOT_GATED			(000000u) 
	#define GPT_GPTCTL1_TIEN_GATED_BY_TINP			(0x0001u) 
	#define GPT_GPTCTL1_TIEN_DEFAULT		GPT_GPTCTL1_TIEN_NOT_GATED 
 
	#define GPT_GPTCTL10_TIEN_NOT_GATED			(000000u) 
	#define GPT_GPTCTL10_TIEN_GATED_BY_TINP			(0x0001u) 
	#define GPT_GPTCTL10_TIEN_DEFAULT		GPT_GPTCTL1_TIEN_NOT_GATED 
 
	#define GPT_GPTCTL11_TIEN_NOT_GATED			(000000u) 
	#define GPT_GPTCTL11_TIEN_GATED_BY_TINP			(0x0001u) 
	#define GPT_GPTCTL11_TIEN_DEFAULT		GPT_GPTCTL1_TIEN_NOT_GATED 
 
	#define GPT_GPTCTL1_CLKSRC_VBUS				(000000u) 
	#define GPT_GPTCTL1_CLKSRC_INPUT_PIN			(0x0001u) 
	#define GPT_GPTCTL1_CLKSRC_DEFAULT		GPT_GPTCTL1_CLKSRC_VBUS 
 
	#define GPT_GPTCTL10_CLKSRC_VBUS			(000000u) 
	#define GPT_GPTCTL10_CLKSRC_INPUT_PIN			(0x0001u) 
	#define GPT_GPTCTL10_CLKSRC_DEFAULT		GPT_GPTCTL1_CLKSRC_VBUS 
 
	#define GPT_GPTCTL11_CLKSRC_VBUS			(000000u) 
	#define GPT_GPTCTL11_CLKSRC_INPUT_PIN			(0x0001u) 
	#define GPT_GPTCTL11_CLKSRC_DEFAULT		GPT_GPTCTL1_CLKSRC_VBUS 
 
	#define GPT_GPTCTL1_ENAMODE_DISABLED			(000000u) 
	#define GPT_GPTCTL1_ENAMODE_ONCE			(0x0001u) 
	#define GPT_GPTCTL1_ENAMODE_CONTINUOUS			(0x0002u) 
	#define GPT_GPTCTL1_ENAMODE_DEFAULT		GPT_GPTCTL1_ENAMODE_DISABLED 
 
	#define GPT_GPTCTL10_ENAMODE_DISABLED			(000000u) 
	#define GPT_GPTCTL10_ENAMODE_ONCE			(0x0001u) 
	#define GPT_GPTCTL10_ENAMODE_CONTINUOUS			(0x0002u) 
	#define GPT_GPTCTL10_ENAMODE_DEFAULT		GPT_GPTCTL1_ENAMODE_DISABLED 
 
	#define GPT_GPTCTL11_ENAMODE_DISABLED			(000000u) 
	#define GPT_GPTCTL11_ENAMODE_ONCE			(0x0001u) 
	#define GPT_GPTCTL11_ENAMODE_CONTINUOUS			(0x0002u) 
	#define GPT_GPTCTL11_ENAMODE_DEFAULT		GPT_GPTCTL1_ENAMODE_DISABLED 
 
	#define GPT_GPTCTL1_PWID_INACTIVE_1CYCLE		(000000u) 
	#define GPT_GPTCTL1_PWID_INACTIVE_2CYCLES		(0x0001u) 
	#define GPT_GPTCTL1_PWID_INACTIVE_3CYCLES		(0x0002u) 
	#define GPT_GPTCTL1_PWID_INACTIVE_4CYCLES		(0x0003u) 
	#define GPT_GPTCTL1_PWID_DEFAULT		GPT_GPTCTL1_PWID_INACTIVE_1CYCLE
 
	#define GPT_GPTCTL10_PWID_INACTIVE_1CYCLE		(000000u) 
	#define GPT_GPTCTL10_PWID_INACTIVE_2CYCLES		(0x0001u) 
	#define GPT_GPTCTL10_PWID_INACTIVE_3CYCLES		(0x0002u) 
	#define GPT_GPTCTL10_PWID_INACTIVE_4CYCLES		(0x0003u) 
	#define GPT_GPTCTL10_PWID_DEFAULT		GPT_GPTCTL1_PWID_INACTIVE_1CYCLE
 
	#define GPT_GPTCTL11_PWID_INACTIVE_1CYCLE		(000000u) 
	#define GPT_GPTCTL11_PWID_INACTIVE_2CYCLES		(0x0001u) 
	#define GPT_GPTCTL11_PWID_INACTIVE_3CYCLES		(0x0002u) 
	#define GPT_GPTCTL11_PWID_INACTIVE_4CYCLES		(0x0003u) 
	#define GPT_GPTCTL11_PWID_DEFAULT		GPT_GPTCTL1_PWID_INACTIVE_1CYCLE
 
	#define GPT_GPTCTL1_CP_CLOCK_MODE			(0x0001u) 
	#define GPT_GPTCTL1_CP_PULSE_MODE			(000000u) 
	#define GPT_GPTCTL1_CP_DEFAULT			GPT_GPTCTL1_CP_PULSE_MODE 
 
	#define GPT_GPTCTL10_CP_CLOCK_MODE			(0x0001u) 
	#define GPT_GPTCTL10_CP_PULSE_MODE			(000000u) 
	#define GPT_GPTCTL10_CP_DEFAULT			GPT_GPTCTL1_CP_PULSE_MODE 
 
	#define GPT_GPTCTL11_CP_CLOCK_MODE			(0x0001u) 
	#define GPT_GPTCTL11_CP_PULSE_MODE			(000000u) 
	#define GPT_GPTCTL11_CP_DEFAULT			GPT_GPTCTL1_CP_PULSE_MODE 
 
	#define GPT_GPTCTL1_INVIN_INVERT_OUTPUT			(0x0001u) 
	#define GPT_GPTCTL1_INVIN_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL1_INVIN_DEFAULT		GPT_GPTCTL1_INVIN_DONT_INVERT_OUTPUT 
 
	#define GPT_GPTCTL10_INVIN_INVERT_OUTPUT		(0x0001u) 
	#define GPT_GPTCTL10_INVIN_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL10_INVIN_DEFAULT		GPT_GPTCTL1_INVIN_DONT_INVERT_OUTPUT 
 
	#define GPT_GPTCTL11_INVIN_INVERT_OUTPUT		(0x0001u) 
	#define GPT_GPTCTL11_INVIN_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL11_INVIN_DEFAULT		GPT_GPTCTL1_INVIN_DONT_INVERT_OUTPUT 
 
 
	#define GPT_GPTCTL1_INVOUT_INVERT_OUTPUT		(0x0001u) 
	#define GPT_GPTCTL1_INVOUT_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL1_INVOUT_DEFAULT		GPT_GPTCTL1_INVOUT_DONT_INVERT_OUTPUT 
 
	#define GPT_GPTCTL10_INVOUT_INVERT_OUTPUT		(0x0001u) 
	#define GPT_GPTCTL10_INVOUT_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL10_INVOUT_DEFAULT		GPT_GPTCTL1_INVOUT_DONT_INVERT_OUTPUT 
 
	#define GPT_GPTCTL11_INVOUT_INVERT_OUTPUT		(0x0001u) 
	#define GPT_GPTCTL11_INVOUT_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL11_INVOUT_DEFAULT		GPT_GPTCTL1_INVOUT_DONT_INVERT_OUTPUT 
 
	#define GPT_GPTCTL1_TSTAT_HIGH				(0x0001u) 
	#define GPT_GPTCTL1_TSTAT_LOW				(000000u) 
 
	#define GPT_GPTCTL10_TSTAT_HIGH				(0x0001u) 
	#define GPT_GPTCTL10_TSTAT_LOW				(000000u) 
 
	#define GPT_GPTCTL11_TSTAT_HIGH				(0x0001u) 
	#define GPT_GPTCTL11_TSTAT_LOW				(000000u) 
 
#define GPT_GPTCTL1_RMK(tien,clksrc,enamode,pwid,cp,invin,invout)\
 ((Uint16) ( \
  ( GPT_FMK(GPTCTL1,TIEN,tien))|\
  ( GPT_FMK(GPTCTL1,CLKSRC,clksrc))|\
  ( GPT_FMK(GPTCTL1,ENAMODE,enamode))|\
  ( GPT_FMK(GPTCTL1,PWID,pwid))|\
  ( GPT_FMK(GPTCTL1,CP,cp))|\
  ( GPT_FMK(GPTCTL1,INVIN,invin))|\
  ( GPT_FMK(GPTCTL1,INVOUT,invout))\
)\
 ) 
 
#define GPT_GPTCTL1_RMKS(tien_sym,clksrc_sym,enamode_sym,pwid_sym,cp_sym,invin_sym,invout_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTCTL1,TIEN,tien_sym))|\
  ( GPT_FMKS(GPTCTL1,CLKSRC,clksrc_sym))|\
  ( GPT_FMKS(GPTCTL1,ENAMODE,enamode_sym))|\
  ( GPT_FMKS(GPTCTL1,PWID,pwid_sym))|\
  ( GPT_FMKS(GPTCTL1,CP,cp_sym))|\
  ( GPT_FMKS(GPTCTL1,INVIN,invin_sym))|\
  ( GPT_FMKS(GPTCTL1,INVOUT,invout_sym))\
)\
 ) 
 
/*  Default GPTCTL1 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTCTL2 register values based on symbolic constants  */ 
 
/*  GPTCTL2 field values  */ 
 
	#define GPT_GPTCTL2_TIEN_NOT_GATED			(000000u) 
	#define GPT_GPTCTL2_TIEN_GATED_BY_TINP			(0x0001u) 
	#define GPT_GPTCTL2_TIEN_DEFAULT		GPT_GPTCTL2_TIEN_NOT_GATED 
 
	#define GPT_GPTCTL20_TIEN_NOT_GATED			(000000u) 
	#define GPT_GPTCTL20_TIEN_GATED_BY_TINP			(0x0001u) 
	#define GPT_GPTCTL20_TIEN_DEFAULT		GPT_GPTCTL2_TIEN_NOT_GATED 
 
	#define GPT_GPTCTL21_TIEN_NOT_GATED			(000000u) 
	#define GPT_GPTCTL21_TIEN_GATED_BY_TINP			(0x0001u) 
	#define GPT_GPTCTL21_TIEN_DEFAULT		GPT_GPTCTL2_TIEN_NOT_GATED 
 
	#define GPT_GPTCTL2_CLKSRC_VBUS				(000000u) 
	#define GPT_GPTCTL2_CLKSRC_INPUT_PIN			(0x0001u) 
	#define GPT_GPTCTL2_CLKSRC_DEFAULT		GPT_GPTCTL2_CLKSRC_VBUS 
 
	#define GPT_GPTCTL20_CLKSRC_VBUS			(000000u) 
	#define GPT_GPTCTL20_CLKSRC_INPUT_PIN			(0x0001u) 
	#define GPT_GPTCTL20_CLKSRC_DEFAULT		GPT_GPTCTL2_CLKSRC_VBUS 
 
	#define GPT_GPTCTL21_CLKSRC_VBUS			(000000u) 
	#define GPT_GPTCTL21_CLKSRC_INPUT_PIN			(0x0001u) 
	#define GPT_GPTCTL21_CLKSRC_DEFAULT		GPT_GPTCTL2_CLKSRC_VBUS 
 
	#define GPT_GPTCTL2_ENAMODE_DISABLED			(000000u) 
	#define GPT_GPTCTL2_ENAMODE_ONCE			(0x0001u) 
	#define GPT_GPTCTL2_ENAMODE_CONTINUOUS			(0x0002u) 
	#define GPT_GPTCTL2_ENAMODE_DEFAULT		GPT_GPTCTL2_ENAMODE_DISABLED 
 
	#define GPT_GPTCTL20_ENAMODE_DISABLED			(000000u) 
	#define GPT_GPTCTL20_ENAMODE_ONCE			(0x0001u) 
	#define GPT_GPTCTL20_ENAMODE_CONTINUOUS			(0x0002u) 
	#define GPT_GPTCTL20_ENAMODE_DEFAULT		GPT_GPTCTL2_ENAMODE_DISABLED 
 
	#define GPT_GPTCTL21_ENAMODE_DISABLED			(000000u) 
	#define GPT_GPTCTL21_ENAMODE_ONCE			(0x0001u) 
	#define GPT_GPTCTL21_ENAMODE_CONTINUOUS			(0x0002u) 
	#define GPT_GPTCTL21_ENAMODE_DEFAULT		GPT_GPTCTL2_ENAMODE_DISABLED 
 
	#define GPT_GPTCTL2_PWID_INACTIVE_1CYCLE		(000000u) 
	#define GPT_GPTCTL2_PWID_INACTIVE_2CYCLES		(0x0001u) 
	#define GPT_GPTCTL2_PWID_INACTIVE_3CYCLES		(0x0002u) 
	#define GPT_GPTCTL2_PWID_INACTIVE_4CYCLES		(0x0003u) 
	#define GPT_GPTCTL2_PWID_DEFAULT		GPT_GPTCTL2_PWID_INACTIVE_1CYCLE 
 
	#define GPT_GPTCTL20_PWID_INACTIVE_1CYCLE		(000000u) 
	#define GPT_GPTCTL20_PWID_INACTIVE_2CYCLES		(0x0001u) 
	#define GPT_GPTCTL20_PWID_INACTIVE_3CYCLES		(0x0002u) 
	#define GPT_GPTCTL20_PWID_INACTIVE_4CYCLES		(0x0003u) 
	#define GPT_GPTCTL20_PWID_DEFAULT		GPT_GPTCTL2_PWID_INACTIVE_1CYCLE 
 
	#define GPT_GPTCTL21_PWID_INACTIVE_1CYCLE		(000000u) 
	#define GPT_GPTCTL21_PWID_INACTIVE_2CYCLES		(0x0001u) 
	#define GPT_GPTCTL21_PWID_INACTIVE_3CYCLES		(0x0002u) 
	#define GPT_GPTCTL21_PWID_INACTIVE_4CYCLES		(0x0003u) 
	#define GPT_GPTCTL21_PWID_DEFAULT		GPT_GPTCTL2_PWID_INACTIVE_1CYCLE 
 
	#define GPT_GPTCTL2_CP_CLOCK_MODE			(0x0001u) 
	#define GPT_GPTCTL2_CP_PULSE_MODE			(000000u) 
	#define GPT_GPTCTL2_CP_DEFAULT			GPT_GPTCTL2_CP_PULSE_MODE 
 
	#define GPT_GPTCTL20_CP_CLOCK_MODE			(0x0001u) 
	#define GPT_GPTCTL20_CP_PULSE_MODE			(000000u) 
	#define GPT_GPTCTL20_CP_DEFAULT			GPT_GPTCTL2_CP_PULSE_MODE 
 
	#define GPT_GPTCTL21_CP_CLOCK_MODE			(0x0001u) 
	#define GPT_GPTCTL21_CP_PULSE_MODE			(000000u) 
	#define GPT_GPTCTL21_CP_DEFAULT			GPT_GPTCTL2_CP_PULSE_MODE 
 
 
	#define GPT_GPTCTL2_INVIN_INVERT_OUTPUT			(0x0001u) 
	#define GPT_GPTCTL2_INVIN_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL2_INVIN_DEFAULT		GPT_GPTCTL2_INVIN_DONT_INVERT_OUTPUT 
 
	#define GPT_GPTCTL20_INVIN_INVERT_OUTPUT		(0x0001u) 
	#define GPT_GPTCTL20_INVIN_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL20_INVIN_DEFAULT		GPT_GPTCTL2_INVIN_DONT_INVERT_OUTPUT 
 
	#define GPT_GPTCTL21_INVIN_INVERT_OUTPUT		(0x0001u) 
	#define GPT_GPTCTL21_INVIN_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL21_INVIN_DEFAULT		GPT_GPTCTL2_INVIN_DONT_INVERT_OUTPUT 
 
	#define GPT_GPTCTL2_INVOUT_INVERT_OUTPUT		(0x0001u) 
	#define GPT_GPTCTL2_INVOUT_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL2_INVOUT_DEFAULT		GPT_GPTCTL2_INVOUT_DONT_INVERT_OUTPUT 
 
	#define GPT_GPTCTL20_INVOUT_INVERT_OUTPUT		(0x0001u) 
	#define GPT_GPTCTL20_INVOUT_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL20_INVOUT_DEFAULT		GPT_GPTCTL2_INVOUT_DONT_INVERT_OUTPUT 
 
	#define GPT_GPTCTL21_INVOUT_INVERT_OUTPUT		(0x0001u) 
	#define GPT_GPTCTL21_INVOUT_DONT_INVERT_OUTPUT		(000000u) 
	#define GPT_GPTCTL21_INVOUT_DEFAULT		GPT_GPTCTL2_INVOUT_DONT_INVERT_OUTPUT 
 
	#define GPT_GPTCTL2_TSTAT_HIGH				(0x0001u) 
	#define GPT_GPTCTL2_TSTAT_LOW				(000000u) 
 
	#define GPT_GPTCTL20_TSTAT_HIGH				(0x0001u) 
	#define GPT_GPTCTL20_TSTAT_LOW				(000000u) 
 
	#define GPT_GPTCTL21_TSTAT_HIGH				(0x0001u) 
	#define GPT_GPTCTL21_TSTAT_LOW				(000000u) 
 
#define GPT_GPTCTL2_RMK(tien,clksrc,enamode,pwid,cp,invin,invout)\
 ((Uint16) ( \
  ( GPT_FMK(GPTCTL2,TIEN,tien))|\
  ( GPT_FMK(GPTCTL2,CLKSRC,clksrc))|\
  ( GPT_FMK(GPTCTL2,ENAMODE,enamode))|\
  ( GPT_FMK(GPTCTL2,PWID,pwid))|\
  ( GPT_FMK(GPTCTL2,CP,cp))|\
  ( GPT_FMK(GPTCTL2,INVIN,invin))|\
  ( GPT_FMK(GPTCTL2,INVOUT,invout))\
)\
 ) 
 
#define GPT_GPTCTL2_RMKS(tien_sym,clksrc_sym,enamode_sym,pwid_sym,cp_sym,invin_sym,invout_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTCTL2,TIEN,tien_sym))|\
  ( GPT_FMKS(GPTCTL2,CLKSRC,clksrc_sym))|\
  ( GPT_FMKS(GPTCTL2,ENAMODE,enamode_sym))|\
  ( GPT_FMKS(GPTCTL2,PWID,pwid_sym))|\
  ( GPT_FMKS(GPTCTL2,CP,cp_sym))|\
  ( GPT_FMKS(GPTCTL2,INVIN,invin_sym))|\
  ( GPT_FMKS(GPTCTL2,INVOUT,invout_sym))\
)\
 ) 
 
/*  Default GPTCTL2 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTEMU register values based on symbolic constants  */ 
 
/*  GPTEMU field values  */ 
 
	#define GPT_GPTEMU_FREE_ON  			(000000u) 
	#define GPT_GPTEMU_FREE_OFF			(000001u) 
        #define GPT_GPTEMU_FREE_DEFAULT           GPT_GPTEMU_FREE_ON 
          
	#define GPT_GPTEMU0_FREE_ON			(000000u) 
	#define GPT_GPTEMU0_FREE_OFF			(000001u) 
        #define GPT_GPTEMU0_FREE_DEFAULT          GPT_GPTEMU0_FREE_ON
          
	#define GPT_GPTEMU1_FREE_ON			(000000u) 
	#define GPT_GPTEMU1_FREE_OFF			(000001u) 
        #define GPT_GPTEMU1_FREE_DEFAULT          GPT_GPTEMU1_FREE_ON 
        
        #define GPT_GPTEMU_SOFT_ON  			(000000u) 
	#define GPT_GPTEMU_SOFT_OFF			(000001u) 
        #define GPT_GPTEMU_SOFT_DEFAULT           GPT_GPTEMU_SOFT_ON 
         
	#define GPT_GPTEMU0_SOFT_ON			(000000u) 
	#define GPT_GPTEMU0_SOFT_OFF			(000001u) 
        #define GPT_GPTEMU0_SOFT_DEFAULT          GPT_GPTEMU0_SOFT_ON 
 
	#define GPT_GPTEMU1_SOFT_ON			(000000u) 
	#define GPT_GPTEMU1_SOFT_OFF			(000001u) 
	#define GPT_GPTEMU1_SOFT_DEFAULT          GPT_GPTEMU1_SOFT_ON 
 
   
/*  Default GPTEMU register value  */ 
 
/* ============================================================== */ 
 /* Make GPTGPEN register values based on symbolic constants  */ 
 
/*  GPTGPEN field values  */ 
 
	#define GPT_GPTGPEN_TOUT1EN_TIMER_OUTPUT		(000000u) 
	#define GPT_GPTGPEN_TOUT1EN_GPIO_PIN			(0x0001u) 
	#define GPT_GPTGPEN_TOUT1EN_DEFAULT		    GPT_GPTGPEN_TOUT1EN_TIMER_OUTPUT 
 
	#define GPT_GPTGPEN0_TOUT1EN_TIMER_OUTPUT		(000000u) 
	#define GPT_GPTGPEN0_TOUT1EN_GPIO_PIN			(0x0001u) 
	#define GPT_GPTGPEN0_TOUT1EN_DEFAULT		GPT_GPTGPEN_TOUT1EN_TIMER_OUTPUT 
 
	#define GPT_GPTGPEN1_TOUT1EN_TIMER_OUTPUT		(000000u) 
	#define GPT_GPTGPEN1_TOUT1EN_GPIO_PIN			(0x0001u) 
	#define GPT_GPTGPEN1_TOUT1EN_DEFAULT		GPT_GPTGPEN_TOUT1EN_TIMER_OUTPUT 
 
	#define GPT_GPTGPEN_TIN1EN_TIMER_INPUT			(000000u) 
	#define GPT_GPTGPEN_TIN1EN_GPIO_PIN			    (0x0001u) 
	#define GPT_GPTGPEN_TIN1EN_DEFAULT		    GPT_GPTGPEN_TIN1EN_TIMER_INPUT 
 
	#define GPT_GPTGPEN0_TIN1EN_TIMER_INPUT		    (000000u) 
	#define GPT_GPTGPEN0_TIN1EN_GPIO_PIN			(0x0001u) 
	#define GPT_GPTGPEN0_TIN1EN_DEFAULT		    GPT_GPTGPEN_TIN1EN_TIMER_INPUT 
 
	#define GPT_GPTGPEN1_TIN1EN_TIMER_INPUT		    (000000u) 
	#define GPT_GPTGPEN1_TIN1EN_GPIO_PIN		    (0x0001u) 
	#define GPT_GPTGPEN1_TIN1EN_DEFAULT		    GPT_GPTGPEN_TIN1EN_TIMER_INPUT 
 
 
#define GPT_GPTGPEN_RMK(tout1en,tin1en)\
 ((Uint16) ( \
  ( GPT_FMK(GPTGPEN,TOUT1EN,tout1en))|\
  ( GPT_FMK(GPTGPEN,TIN1EN,tin1en))\
)\
 ) 
 
#define GPT_GPTGPEN_RMKS(tout1en_sym,tin1en_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTGPEN,TOUT1EN,tout1en_sym))|\
  ( GPT_FMKS(GPTGPEN,TIN1EN,tin1en_sym))\
)\
 ) 
 
/*  Default GPTGPEN register value  */ 
 
/* ============================================================== */ 
 /* Make GPTGCTL1 register values based on symbolic constants  */ 
 
/*  GPTGCTL1 field values  */ 
 
	#define GPT_GPTGCTL1_TDDR34_OF(x)		((Uint16)(x)) 
	#define GPT_GPTGCTL1_TDDR34_DEFAULT		GPT_GPTGCTL1_TDDR34_OF(0) 
 
	#define GPT_GPTGCTL10_TDDR34_OF(x)		((Uint16)(x)) 
	#define GPT_GPTGCTL10_TDDR34_DEFAULT		GPT_GPTGCTL1_TDDR34_OF(0) 
 
	#define GPT_GPTGCTL11_TDDR34_OF(x)		((Uint16)(x)) 
	#define GPT_GPTGCTL11_TDDR34_DEFAULT		GPT_GPTGCTL1_TDDR34_OF(0) 
 
	#define GPT_GPTGCTL1_PSC34_OF(x)		((Uint16)(x)) 
	#define GPT_GPTGCTL1_PSC34_DEFAULT		GPT_GPTGCTL1_PSC34_OF(0) 
 
	#define GPT_GPTGCTL10_PSC34_OF(x)		((Uint16)(x)) 
	#define GPT_GPTGCTL10_PSC34_DEFAULT		GPT_GPTGCTL1_PSC34_OF(0) 
 
	#define GPT_GPTGCTL11_PSC34_OF(x)		((Uint16)(x)) 
	#define GPT_GPTGCTL11_PSC34_DEFAULT		GPT_GPTGCTL1_PSC34_OF(0) 
 
	#define GPT_GPTGCTL1_TIMMODE_64BIT_GPTIM			(000000u) 
	#define GPT_GPTGCTL1_TIMMODE_32BIT_DUAL				(0x0001u) 
	#define GPT_GPTGCTL1_TIMMODE_32BIT_CHAINED			(0x0003u) 
	#define GPT_GPTGCTL1_TIMMODE_DEFAULT			GPT_GPTGCTL1_TIMMODE_64BIT_GPTIM 
 
	#define GPT_GPTGCTL10_TIMMODE_64BIT_GPTIM			(000000u) 
	#define GPT_GPTGCTL10_TIMMODE_32BIT_DUAL			(0x0001u) 
	#define GPT_GPTGCTL10_TIMMODE_32BIT_CHAINED			(0x0003u) 
	#define GPT_GPTGCTL10_TIMMODE_DEFAULT			GPT_GPTGCTL1_TIMMODE_64BIT_GPTIM 
 
	#define GPT_GPTGCTL11_TIMMODE_64BIT_GPTIM			(000000u) 
	#define GPT_GPTGCTL11_TIMMODE_32BIT_DUAL			(0x0001u) 
	#define GPT_GPTGCTL11_TIMMODE_32BIT_CHAINED			(0x0003u) 
	#define GPT_GPTGCTL11_TIMMODE_DEFAULT			GPT_GPTGCTL1_TIMMODE_64BIT_GPTIM 
 
	#define GPT_GPTGCTL1_TIM34RS_IN_RESET				(000000u) 
	#define GPT_GPTGCTL1_TIM34RS_NOT_IN_RESET			(0x0001u) 
	#define GPT_GPTGCTL1_TIM34RS_DEFAULT			GPT_GPTGCTL1_TIM34RS_IN_RESET 
 
	#define GPT_GPTGCTL10_TIM34RS_IN_RESET				(000000u) 
	#define GPT_GPTGCTL10_TIM34RS_NOT_IN_RESET			(0x0001u) 
	#define GPT_GPTGCTL10_TIM34RS_DEFAULT			GPT_GPTGCTL1_TIM34RS_IN_RESET 
 
	#define GPT_GPTGCTL11_TIM34RS_IN_RESET				(000000u) 
	#define GPT_GPTGCTL11_TIM34RS_NOT_IN_RESET			(0x0001u) 
	#define GPT_GPTGCTL11_TIM34RS_DEFAULT			GPT_GPTGCTL1_TIM34RS_IN_RESET 
 
	#define GPT_GPTGCTL1_TIM12RS_IN_RESET				(000000u) 
	#define GPT_GPTGCTL1_TIM12RS_NOT_IN_RESET			(0x0001u) 
	#define GPT_GPTGCTL1_TIM12RS_DEFAULT			GPT_GPTGCTL1_TIM12RS_IN_RESET 
 
	#define GPT_GPTGCTL10_TIM12RS_IN_RESET				(000000u) 
	#define GPT_GPTGCTL10_TIM12RS_NOT_IN_RESET			(0x0001u) 
	#define GPT_GPTGCTL10_TIM12RS_DEFAULT			GPT_GPTGCTL1_TIM12RS_IN_RESET 
 
	#define GPT_GPTGCTL11_TIM12RS_IN_RESET				(000000u) 
	#define GPT_GPTGCTL11_TIM12RS_NOT_IN_RESET			(0x0001u) 
	#define GPT_GPTGCTL11_TIM12RS_DEFAULT			GPT_GPTGCTL1_TIM12RS_IN_RESET 
 
#define GPT_GPTGCTL1_RMK(tddr34,psc34,timmode,tim34rs,tim12rs)\
 ((Uint16) ( \
  ( GPT_FMK(GPTGCTL1,TDDR34,tddr34))|\
  ( GPT_FMK(GPTGCTL1,PSC34,psc34))|\
  ( GPT_FMK(GPTGCTL1,TIMMODE,timmode))|\
  ( GPT_FMK(GPTGCTL1,TIM34RS,tim34rs))|\
  ( GPT_FMK(GPTGCTL1,TIM12RS,tim12rs))\
)\
 ) 
 
#define GPT_GPTGCTL1_RMKS(tddr34_sym,psc34_sym,timmode_sym,tim34rs_sym,tim12rs_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTGCTL1,TDDR34,tddr34_sym))|\
  ( GPT_FMKS(GPTGCTL1,PSC34,psc34_sym))|\
  ( GPT_FMKS(GPTGCTL1,TIMMODE,timmode_sym))|\
  ( GPT_FMKS(GPTGCTL1,TIM34RS,tim34rs_sym))|\
  ( GPT_FMKS(GPTGCTL1,TIM12RS,tim12rs_sym))\
)\
 ) 
 
/*  Default GPTGCTL1 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTGPDAT register values based on symbolic constants  */ 
 
/*  GPTGPDAT field values  */ 
 

	#define GPT_GPTGPDAT_TOUT1DAT_HIGH			(0x0001u) 
	#define GPT_GPTGPDAT_TOUT1DAT_LOW			(000000u) 
	#define GPT_GPTGPDAT_TOUT1DAT_DEFAULT		GPT_GPTGPDAT_TOUT1DAT_LOW 
 
	#define GPT_GPTGPDAT0_TOUT1DAT_HIGH			(0x0001u) 
	#define GPT_GPTGPDAT0_TOUT1DAT_LOW			(000000u) 
	#define GPT_GPTGPDAT0_TOUT1DAT_DEFAULT		GPT_GPTGPDAT_TOUT1DAT_LOW 
 
	#define GPT_GPTGPDAT1_TOUT1DAT_HIGH			(0x0001u) 
	#define GPT_GPTGPDAT1_TOUT1DAT_LOW			(000000u) 
	#define GPT_GPTGPDAT1_TOUT1DAT_DEFAULT		GPT_GPTGPDAT_TOUT1DAT_LOW 
 
	#define GPT_GPTGPDAT_TIN1DAT_HIGH			(0x0001u) 
	#define GPT_GPTGPDAT_TIN1DAT_LOW			(000000u) 
	#define GPT_GPTGPDAT_TIN1DAT_DEFAULT		GPT_GPTGPDAT_TIN1DAT_LOW 
 
	#define GPT_GPTGPDAT0_TIN1DAT_HIGH			(0x0001u) 
	#define GPT_GPTGPDAT0_TIN1DAT_LOW			(000000u) 
	#define GPT_GPTGPDAT0_TIN1DAT_DEFAULT		GPT_GPTGPDAT_TIN1DAT_LOW 
 
	#define GPT_GPTGPDAT1_TIN1DAT_HIGH			(0x0001u) 
	#define GPT_GPTGPDAT1_TIN1DAT_LOW			(000000u) 
	#define GPT_GPTGPDAT1_TIN1DAT_DEFAULT		GPT_GPTGPDAT_TIN1DAT_LOW 
 
 
 
#define GPT_GPTGPDAT_RMK(tout1dat,tin1dat)\
 ((Uint16) ( \
  ( GPT_FMK(GPTGPDAT,TOUT1DAT,tout1dat))|\
  ( GPT_FMK(GPTGPDAT,TIN1DAT,tin1dat))\
)\
 ) 
 
#define GPT_GPTGPDAT_RMKS(tout1dat_sym,tin1dat_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTGPDAT,TOUT1DAT,tout1dat_sym))|\
  ( GPT_FMKS(GPTGPDAT,TIN1DAT,tin1dat_sym))\
)\
 ) 
 
/*  Default GPTGPDAT register value  */ 
 
/* ============================================================== */ 
 /* Make GPTGPDIR register values based on symbolic constants  */ 
 
/*  GPTGPDIR field values  */ 
 
	
	#define GPT_GPTGPDIR_TOUT1DIR_GPIO_INPUT			(000000u) 
	#define GPT_GPTGPDIR_TOUT1DIR_GPIO_OUTPUT			(0x0001u) 
	#define GPT_GPTGPDIR_TOUT1DIR_DEFAULT			GPT_GPTGPDIR_TOUT1DIR_GPIO_INPUT 
 
	#define GPT_GPTGPDIR0_TOUT1DIR_GPIO_INPUT			(000000u) 
	#define GPT_GPTGPDIR0_TOUT1DIR_GPIO_OUTPUT			(0x0001u) 
	#define GPT_GPTGPDIR0_TOUT1DIR_DEFAULT			GPT_GPTGPDIR_TOUT1DIR_GPIO_INPUT 
 
	#define GPT_GPTGPDIR1_TOUT1DIR_GPIO_INPUT			(000000u) 
	#define GPT_GPTGPDIR1_TOUT1DIR_GPIO_OUTPUT			(0x0001u) 
	#define GPT_GPTGPDIR1_TOUT1DIR_DEFAULT			GPT_GPTGPDIR_TOUT1DIR_GPIO_INPUT 
 
	#define GPT_GPTGPDIR_TIN1DIR_GPIO_INPUT				(000000u) 
	#define GPT_GPTGPDIR_TIN1DIR_GPIO_OUTPUT			(0x0001u) 
	#define GPT_GPTGPDIR_TIN1DIR_DEFAULT			GPT_GPTGPDIR_TIN1DIR_GPIO_INPUT 
 
	#define GPT_GPTGPDIR0_TIN1DIR_GPIO_INPUT			(000000u) 
	#define GPT_GPTGPDIR0_TIN1DIR_GPIO_OUTPUT			(0x0001u) 
	#define GPT_GPTGPDIR0_TIN1DIR_DEFAULT			GPT_GPTGPDIR_TIN1DIR_GPIO_INPUT 
 
	#define GPT_GPTGPDIR1_TIN1DIR_GPIO_INPUT			(000000u) 
	#define GPT_GPTGPDIR1_TIN1DIR_GPIO_OUTPUT			(0x0001u) 
	#define GPT_GPTGPDIR1_TIN1DIR_DEFAULT			GPT_GPTGPDIR_TIN1DIR_GPIO_INPUT 
 
#define GPT_GPTGPDIR_RMK(tout1dir,tin1dir)\
 ((Uint16) ( \
  ( GPT_FMK(GPTGPDIR,TOUT1DIR,tout1dir))|\
  ( GPT_FMK(GPTGPDIR,TIN1DIR,tin1dir))\
)\
 ) 
 
#define GPT_GPTGPDIR_RMKS(tout1dir_sym,tin1dir_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTGPDIR,TOUT1DIR,tout1dir_sym))|\
  ( GPT_FMKS(GPTGPDIR,TIN1DIR,tin1dir_sym))\
)\
 ) 
 
/*  Default GPTGPDIR register value  */ 
 
/* ============================================================== */ 
 /* Make GPTGPINT register values based on symbolic constants  */ 
 
/*  GPTGPINT field values  */ 
 
	
    #define GPT_GPTGPINT_TIN1INV_DISABLE			(0x0000u)  
	#define GPT_GPTGPINT_TIN1INV_ENABLE			(000001u) 
	#define GPT_GPTGPINT_TIN1INV_DEFAULT		GPT_GPTGPINT_TIN1INV_DISABLE
	
	
    #define GPT_GPTGPINT0_TIN1INV_DISABLE			(0x0000u)  
	#define GPT_GPTGPINT0_TIN1INV_ENABLE			(000001u) 
	#define GPT_GPTGPINT0_TIN1INV_DEFAULT		GPT_GPTGPINT_TIN10INV_DISABLE
	
	
    #define GPT_GPTGPINT1_TIN1INV_DISABLE			(0x0000u)  
	#define GPT_GPTGPINT1_TIN1INV_ENABLE			(000001u) 
	#define GPT_GPTGPINT1_TIN1INV_DEFAULT		GPT_GPTGPINT_TIN11INV_DISABLE
 
	#define GPT_GPTGPINT_TIN1INT_DISABLE			(0x0000u)  
	#define GPT_GPTGPINT_TIN1INT_ENABLE			(000001u) 
	#define GPT_GPTGPINT_TIN1INT_DEFAULT		GPT_GPTGPINT_TIN1INT_DISABLE
	
	
    #define GPT_GPTGPINT0_TIN1INT_DISABLE			(0x0000u)  
	#define GPT_GPTGPINT0_TIN1INT_ENABLE			(000001u) 
	#define GPT_GPTGPINT0_TIN1INT_DEFAULT		GPT_GPTGPINT_TIN10INT_DISABLE
	
	
    #define GPT_GPTGPINT1_TIN1INT_DISABLE			(0x0000u)  
	#define GPT_GPTGPINT1_TIN1INT_ENABLE			(000001u) 
	#define GPT_GPTGPINT1_TIN1INT_DEFAULT		GPT_GPTGPINT_TIN11INT_DISABLE
 
 
#define GPT_GPTGPINT_RMK(tin1inv,tin1int)\
 ((Uint16) ( \
  ( GPT_FMK(GPTGPINT,TIN1INV,tin1inv))|\
  ( GPT_FMK(GPTGPINT,TIN1INT,tin1int))\
)\
 ) 
 
#define GPT_GPTGPINT_RMKS(tin1inv_sym,tin1int_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTGPINT,TIN1INV,tin1inv_sym))|\
  ( GPT_FMKS(GPTGPINT,TIN1INT,tin1int_sym))\
)\
 ) 
 
/*  Default GPTGPINT register value  */ 
 
/* ============================================================== */ 
 /* Make GPTPID1 register values based on symbolic constants  */ 
 
/*  GPTPID1 field values  */ 
 
	#define GPT_GPTPID1_CLASS_CLASS			(000000u) 
	#define GPT_GPTPID1_CLASS_DEFAULT		GPT_GPTPID1_CLASS_CLASS 
 
	#define GPT_GPTPID10_CLASS_CLASS			(000000u) 
	#define GPT_GPTPID10_CLASS_DEFAULT		GPT_GPTPID1_CLASS_CLASS 
 
	#define GPT_GPTPID11_CLASS_CLASS			(000000u) 
	#define GPT_GPTPID11_CLASS_DEFAULT		GPT_GPTPID1_CLASS_CLASS 
 
	#define GPT_GPTPID1_REVISION_REVISION			(000000u) 
	#define GPT_GPTPID1_REVISION_DEFAULT		GPT_GPTPID1_REVISION_REVISION 
 
	#define GPT_GPTPID10_REVISION_REVISION			(000000u) 
	#define GPT_GPTPID10_REVISION_DEFAULT		GPT_GPTPID1_REVISION_REVISION 
 
	#define GPT_GPTPID11_REVISION_REVISION			(000000u) 
	#define GPT_GPTPID11_REVISION_DEFAULT		GPT_GPTPID1_REVISION_REVISION 
 
 
 
/*  Default GPTPID1 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTPID2 register values based on symbolic constants  */ 
 
/*  GPTPID2 field values  */ 
 
	#define GPT_GPTPID2_TYPE_TYPE			(000000u) 
	#define GPT_GPTPID2_TYPE_DEFAULT		GPT_GPTPID2_TYPE_GPT_GPTPID2_TYPE_TYPE 
 
	#define GPT_GPTPID20_TYPE_TYPE			(000000u) 
	#define GPT_GPTPID20_TYPE_DEFAULT		GPT_GPTPID2_TYPE_GPT_GPTPID2_TYPE_TYPE 
 
	#define GPT_GPTPID21_TYPE_TYPE			(000000u) 
	#define GPT_GPTPID21_TYPE_DEFAULT		GPT_GPTPID2_TYPE_GPT_GPTPID2_TYPE_TYPE 
 
 
/*  Default GPTPID2 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTPRD1 register values based on symbolic constants  */ 
 
/*  GPTPRD1 field values  */ 
 
	#define GPT_GPTPRD1_PRD1_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD1_PRD1_DEFAULT		GPT_GPTPRD1_PRD1_OF(0) 
 
	#define GPT_GPTPRD10_PRD1_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD10_PRD1_DEFAULT		GPT_GPTPRD1_PRD1_OF(0) 
 
	#define GPT_GPTPRD11_PRD1_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD11_PRD1_DEFAULT		GPT_GPTPRD1_PRD1_OF(0) 
 
 
#define GPT_GPTPRD1_RMK(prd1)\
 ((Uint16) ( \
  ( GPT_FMK(GPTPRD1,PRD1,prd1))\
)\
 ) 
 
#define GPT_GPTPRD1_RMKS(prd1_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTPRD1,PRD1,prd1_sym))\
)\
 ) 
 
/*  Default GPTPRD1 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTPRD2 register values based on symbolic constants  */ 
 
/*  GPTPRD2 field values  */ 
 
	#define GPT_GPTPRD2_PRD2_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD2_PRD2_DEFAULT		GPT_GPTPRD2_PRD2_0x0000u 
 
	#define GPT_GPTPRD20_PRD2_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD20_PRD2_DEFAULT		GPT_GPTPRD2_PRD2_0x0000u 
 
	#define GPT_GPTPRD21_PRD2_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD21_PRD2_DEFAULT		GPT_GPTPRD2_PRD2_0x0000u 
 
 
#define GPT_GPTPRD2_RMK(prd2)\
 ((Uint16) ( \
  ( GPT_FMK(GPTPRD2,PRD2,prd2))\
)\
 ) 
 
#define GPT_GPTPRD2_RMKS(prd2_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTPRD2,PRD2,prd2_sym))\
)\
 ) 
 
/*  Default GPTPRD2 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTPRD3 register values based on symbolic constants  */ 
 
/*  GPTPRD3 field values  */ 
 
	#define GPT_GPTPRD3_PRD3_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD3_PRD3_DEFAULT		GPT_GPTPRD3_PRD3_OF(0) 
 
	#define GPT_GPTPRD30_PRD3_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD30_PRD3_DEFAULT		GPT_GPTPRD3_PRD3_OF(0) 
 
	#define GPT_GPTPRD31_PRD3_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD31_PRD3_DEFAULT		GPT_GPTPRD3_PRD3_OF(0) 
 
 
#define GPT_GPTPRD3_RMK(prd3)\
 ((Uint16) ( \
  ( GPT_FMK(GPTPRD3,PRD3,prd3))\
)\
 ) 
 
#define GPT_GPTPRD3_RMKS(prd3_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTPRD3,PRD3,prd3_sym))\
)\
 ) 
 
/*  Default GPTPRD3 register value  */ 
 
/* ============================================================== */ 
 /* Make GPTPRD4 register values based on symbolic constants  */ 
 
/*  GPTPRD4 field values  */ 
 
	#define GPT_GPTPRD4_PRD4_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD4_PRD4_DEFAULT		GPT_GPTPRD4_PRD4_0x0000u 
 
	#define GPT_GPTPRD40_PRD4_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD40_PRD4_DEFAULT		GPT_GPTPRD4_PRD4_0x0000u 
 
	#define GPT_GPTPRD41_PRD4_OF(x)		((Uint16)(x)) 
	#define GPT_GPTPRD41_PRD4_DEFAULT		GPT_GPTPRD4_PRD4_0x0000u 
 
 
#define GPT_GPTPRD4_RMK(prd4)\
 ((Uint16) ( \
  ( GPT_FMK(GPTPRD4,PRD4,prd4))\
)\
 ) 
 
#define GPT_GPTPRD4_RMKS(prd4_sym)\
 ((Uint16) ( \
  ( GPT_FMKS(GPTPRD4,PRD4,prd4_sym))\
)\
 ) 
 
/*  Default GPTPRD4 register value  */ 
/*************************************************\
 GPT global typedef declarations  
\*************************************************/ 
 
typedef struct { 
	Uint16 gptemu; 
	Uint16 gptgpint; 
	Uint16 gptgpen; 
	Uint16 gptgpdir; 
	Uint16 gptgpdat; 
	Uint16 gptprd1; 
	Uint16 gptprd2; 
	Uint16 gptprd3; 
	Uint16 gptprd4; 
	Uint16 gptctl1; 
	Uint16 gptctl2; 
	Uint16 gptgctl1; 
} GPT_Config; 
 
typedef struct { 
   Uint16 *privateObj; 
} GPT_Private; 
 
 
/*************************************************\
* GPT global variable declarations 
\*************************************************/ 
 
 
/*************************************************\
* GPT global function declarations 
\*************************************************/ 
 
CSLAPI GPT_Handle GPT_open(int devNum, Uint32 Flags); 

CSLAPI void GPT_close(GPT_Handle hGPT); 

CSLAPI void GPT_config(GPT_Handle hGPT, GPT_Config *myConfig); 

CSLAPI void GPT_configArgs(GPT_Handle hGpt, Uint16 gptemu,  
            Uint16 gptprd1,  Uint16 gptprd2, Uint16 gptprd3,  Uint16 gptprd4, 
            Uint16 gptgpint, Uint16 gptgpen, Uint16 gptgpdir, Uint16 gptgpdat, 
            Uint16 gptctl1,  Uint16 gptctl2, Uint16 gptgctl1); 

CSLAPI void GPT_initDual32(GPT_Handle hGpt, Uint16 dt1ctl, Uint16 dt2ctl,  
           Uint32 dt1prd, Uint32 dt2prd, Uint16 dt2prsc); 

CSLAPI void GPT_init64(GPT_Handle hGpt, Uint16 gptgctl, Uint16 dt12ctl, 
           Uint32 prdHigh, Uint32 prdLow); 

CSLAPI void GPT_initChained32(GPT_Handle hGpt, Uint16 gctl, Uint16 ctl1, 
           Uint32 prdHigh, Uint32 prdLow); 
 
 
/*************************************************\
* GPT inline function declarations 
\*************************************************/ 
 
 
#ifdef USEDEFS 
 
IDECL void GPT_getPID(GPT_Handle hGpt, Uint16 *_type, Uint16 *_class, 
                        Uint16 *revision); 
                        
IDECL void GPT_getCnt(GPT_Handle hGpt, Uint32 *tim34, Uint32 *tim12); 

IDECL void GPT_start12(GPT_Handle hGpt); 

IDECL void GPT_start34(GPT_Handle hGpt); 

IDECL void GPT_stop(GPT_Handle hGpt); 

IDECL void GPT_reset(GPT_Handle hGpt); 

IDECL void GPT_start(GPT_Handle hGpt); 
 
IDECL void GPT_stop12(GPT_Handle hGpt);

IDECL void GPT_stop34(GPT_Handle hGpt);
 
/*----------------------------------------------------------------------------*/ 
IDEF void GPT_getPID(GPT_Handle hGpt, Uint16 *_type, Uint16 *_class, 
                     Uint16 *revision) { 
     ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs; 
     Uint16 tmp; 
     tmp = (regPtr->gptpid1); 
     *_class = tmp & 0xFFu; 
     *_type = (tmp > 8) & 0xFFu; 
     *revision = (regPtr->gptpid2) & 0xFFu; 
} 
 
/*----------------------------------------------------------------------------*/ 
IDEF void GPT_getCnt (GPT_Handle hGpt, Uint32 *tim34, Uint32 *tim12) { 
   ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs; 
   Uint16 tim1,tim2,tim3,tim4; 
    
   // Access TIM1 first to cause copy of tim2/3/4 to 
   // shadow registers to preserve snapshot 
 
   tim1 = (regPtr->gptcnt1);   
   tim2 = (regPtr->gptcnt2); 
   tim3 = (regPtr->gptcnt3); 
   tim4 = (regPtr->gptcnt4); 
 
   *tim12 = ((Uint32)tim2 << 16u) | tim1; 
   *tim34 = ((Uint32)tim4 << 16u) | tim3; 
} 
/*----------------------------------------------------------------------------*/ 
 IDEF void GPT_start12(GPT_Handle hGpt) { 
   ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs; 
    
   (regPtr->gptgctl1) |= 0x1u; 
} 
/*----------------------------------------------------------------------------*/ 
 IDEF void GPT_start34(GPT_Handle hGpt) { 
   ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs; 
    
   (regPtr->gptgctl1) |= 0x2u; 
} 
/*----------------------------------------------------------------------------*/ 
IDEF void GPT_stop(GPT_Handle hGpt) { 
  int oldgie; 
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs; 
 
  oldgie = IRQ_globalDisable();  
     
  /* stop timer 12 and 34*/   
  (regPtr->gptgctl1) &= 0xFFFCu; 
 
  IRQ_globalRestore(oldgie); 
 
} 
/*----------------------------------------------------------------------------*/ 
IDEF void GPT_stop12(GPT_Handle hGpt) {
  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;

  oldgie = IRQ_globalDisable(); 
    
  /* stop timer 12 only*/  
  (regPtr->gptgctl1) &= 0xFFFEu;

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/ 
IDEF void GPT_stop34(GPT_Handle hGpt) {
 
  int oldgie;
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;

  oldgie = IRQ_globalDisable(); 
    
  /* stop timer 34 only*/  
  (regPtr->gptgctl1) &= 0xFFFDu;

  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/ 
IDEF void GPT_reset(GPT_Handle hGpt) { 
  int oldgie; 
  Uint16 EventId; 
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs; 
 
  oldgie = IRQ_globalDisable();   
     
  if (hGpt == INV) {     
  
      GPT_reset(GPT_hDev0); 
      GPT_reset(GPT_hDev1);   
        
  }  
  else { 
      EventId  = GPT_getEventId(hGpt); 
      /* stop timer */   
      (regPtr->gptgctl1) = 0x0000u;  
      /* Reset Period Value=0xFFFF */ 
      (regPtr->gptprd1) = 0x0000u; 
      (regPtr->gptprd2) = 0x0000u; 
      (regPtr->gptprd3) = 0x0000u; 
      (regPtr->gptprd4) = 0x0000u; 
      IRQ_disable(EventId); 
      IRQ_clear(EventId); 
  } 
  IRQ_globalRestore(oldgie); 
 
} 
/*----------------------------------------------------------------------------*/ 
IDEF void GPT_start(GPT_Handle hGpt) { 
  int oldgie; 
  ioport GPT_RegObj *regPtr = ((GPT_PrivateObj *)hGpt)->regs;  
 
  oldgie = IRQ_globalDisable();  
     
      /* Take Tim12 and Tim34 out of reset */ 
 
  (regPtr->gptgctl1) |= 0x3u; 
 
  IRQ_globalRestore(oldgie); 
 
} 
/*----------------------------------------------------------------------------*/ 
 
#endif /*USEDEFS */ 
 
#else 
    #ifndef _GPT_MOD_ 
	   #error GPT Hal Module Not Supported on Specified Target 
    #endif 
#endif  /* _GPT_SUPPORT  */ 
 
#endif  /* _CSL_GPTHAL_H  */ 
 
/******************************************************************************\
*      
*      End of csl_gpt.h  
* 
\******************************************************************************/ 
csl_gptdat.h/   1051539342  0     0     0       2595      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... TIMER
* FILENAME...... csl_gptdat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       03/30/2000
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments 
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the TIMER module)
*       Reserved Area for TIMER Data 
*
*
\******************************************************************************/
#ifndef _GPT_DATA_H_
#define _GPT_DATA_H_

#include <csl_std.h>

#define __GPT_DEVICE_CNT           2

/* private object, not to be used by application code */
typedef struct {
	volatile Uint16 gptpid1;
	volatile Uint16 gptpid2;
	volatile Uint16 gptemu;
	volatile Uint16 gptclk;
	volatile Uint16 gptgpint;
	volatile Uint16 gptgpen;
	volatile Uint16 gptgpdir;
	volatile Uint16 gptgpdat;
	volatile Uint16 gptcnt1;
	volatile Uint16 gptcnt2;
	volatile Uint16 gptcnt3;
	volatile Uint16 gptcnt4;
	volatile Uint16 gptprd1;
	volatile Uint16 gptprd2;
	volatile Uint16 gptprd3;
	volatile Uint16 gptprd4;
	volatile Uint16 gptctl1;
	volatile Uint16 gptctl2;
	volatile Uint16 gptgctl1;
} GPT_RegObj, *GPT_RegPtr;


typedef struct {
  Uint16  devNum;
  Uint16  EventId;
  GPT_RegPtr  regs;
} GPT_PrivateObj, *GPT_Handle;
 

// The following addresses are incorrect for GPT
// timer registers... these were altered to allow
// use of simulator for testing purposes.
// These definitions need t obe returned to their
// correct values of 0x1000 and 0x2400 respectively
// when simulator is no longer used as the test bed.

#define CSL_GPTDATAINIT\
{/*Timer #0 Handle Initialization Data*/\
  0x0000u,  /*TIMER0_Timer*/\
  0x0004u,  /*TIMER0_EventId*/\
 (GPT_RegPtr)0x1000u,   /* TIMER0_PID1Addr */\
/*Timer #1 Handle Initialization Data*/\
  0x0001u,  /*TIMER1_Timer*/\
  0x0016u,  /*TIMER1_EventId*/\
 (GPT_RegPtr)0x2400u,   /* TIMER1_PID1Addr */\
}

typedef struct {
  GPT_PrivateObj Gpt[__GPT_DEVICE_CNT];
} CSL_GptDataObj;

extern CSL_GptDataObj CSL_GptData;

#define CSL_GPT_DATA  CSL_GptData

#endif

csl_gpthal.h/   1049976885  0     0     0       80929     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... GPT 
* FILENAME...... csl_gpthal.h
* DATE CREATED.. Sat Feb  9 16:13:17 2002
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS..  
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Sat Feb  9 16:13:17 2002 (Automatic generation)
*	 Last Modified:	        03/11/2003 Modified register names and fields
*                               as per SPRU618A.   
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL HAL interface file for the GPT module 
*
* Registers covered:
*                  GPTPID1		- 
*	           GPTPID2		- 
*	           GPTEMU		- Emulation management register
*	           GPTCLK		- Timer clock speed register
*	           GPTCNT1		- Timer count register 1
*	           GPTCNT2		- Timer count register 2
*	           GPTCNT3		- Timer count register 3
*	           GPTCNT4		- Timer count register 4
*	           GPTPRD1		- Timer period register 1
*	           GPTPRD2		- Timer period register 2
*	           GPTPRD3		- Timer period register 3
*	           GPTPRD4		- Timer period register 4
*	           GPTGPINT		- GPIO interrupt control register
*	           GPTGPEN		- GPIO enable register
*	           GPTGPDIR		- GPIO direction register
*	           GPTGPDAT		- GPIO data register
*	           GPTCTL1		- Timer control register 1
*	           GPTCTL2		- Timer control register 2
*	           GPTGCTL1		- Global timer control register
*
\*************************************************************************/
  
#ifndef _CSL_GPTHAL_H_
#define _CSL_GPTHAL_H_

#include <csl_chiphal.h>

#if (_GPT_SUPPORT) 

/*----------------------------------------------------------------*\
*	 GPT scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _GPT_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/*----------------------------------------------------------------*\
*		 Address Macros			
\*----------------------------------------------------------------*/

// #define _GPT_BASE_ADDRn(n)		(_TIMERB_BASE_ADDR + (n * 0x1400u))

#define _GPT_BASE_ADDR		        (0x1000u)
//#define _GPT_BASE_ADDR			(0x0800u)

#define _GPT_BASE_ADDRn(n)		(_GPT_BASE_ADDR + (n * 0x1400u))

/*--------------------- Register: GPTPID1 -----------------------*/
#define _GPT_GPTPID10_ADDR		(_GPT_GPTPID1_ADDR(0))
#define _GPT_GPTPID10			PREG16(_GPT_GPTPID10_ADDR)
#define GPTPID10				_GPT_GPTPID10

#define _GPT_GPTPID11_ADDR		(_GPT_GPTPID1_ADDR(1))
#define _GPT_GPTPID11			PREG16(_GPT_GPTPID11_ADDR)
#define GPTPID11				_GPT_GPTPID11

#define _GPT_GPTPID1_BASE			 (0)
#define _GPT_GPTPID1_ADDR(n)		 ((_GPT_GPTPID1_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTPID1(n)			 PREG16(_GPT_GPTPID1_ADDR(n))
#define _GPT_GPTPID1_ADDR_H(devNum)	 _GPT_GPTPID1_ADDR(devNum)
#define _GPT_GPTPID1_ADDRH(devNum)	 _GPT_GPTPID1_ADDR(devNum)

/*--------------------- Register: GPTPID2 -----------------------*/
#define _GPT_GPTPID20_ADDR		(_GPT_GPTPID2_ADDR(0))
#define _GPT_GPTPID20			PREG16(_GPT_GPTPID20_ADDR)
#define GPTPID20				_GPT_GPTPID20

#define _GPT_GPTPID21_ADDR		(_GPT_GPTPID2_ADDR(1))
#define _GPT_GPTPID21			PREG16(_GPT_GPTPID21_ADDR)
#define GPTPID21				_GPT_GPTPID21

#define _GPT_GPTPID2_BASE			 (0x1u)
#define _GPT_GPTPID2_ADDR(n)		 ((_GPT_GPTPID2_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTPID2(n)			 PREG16(_GPT_GPTPID2_ADDR(n))
#define _GPT_GPTPID2_ADDR_H(devNum)	 _GPT_GPTPID2_ADDR(devNum)
#define _GPT_GPTPID2_ADDRH(devNum)	 _GPT_GPTPID2_ADDR(devNum)

/*--------------------- Register: GPTEMU -----------------------*/
#define _GPT_GPTEMU0_ADDR		(_GPT_GPTEMU_ADDR(0))
#define _GPT_GPTEMU0			PREG16(_GPT_GPTEMU0_ADDR)
#define GPTEMU0				_GPT_GPTEMU0

#define _GPT_GPTEMU1_ADDR		(_GPT_GPTEMU_ADDR(1))
#define _GPT_GPTEMU1			PREG16(_GPT_GPTEMU1_ADDR)
#define GPTEMU1				_GPT_GPTEMU1

#define _GPT_GPTEMU_BASE			 (0x2u)
#define _GPT_GPTEMU_ADDR(n)		 ((_GPT_GPTEMU_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTEMU(n)			 PREG16(_GPT_GPTEMU_ADDR(n))
#define _GPT_GPTEMU_ADDR_H(devNum)	 _GPT_GPTEMU_ADDR(devNum)
#define _GPT_GPTEMU_ADDRH(devNum)	 _GPT_GPTEMU_ADDR(devNum)

/*--------------------- Register: GPTCLK -----------------------*/
#define _GPT_GPTCLK0_ADDR		(_GPT_GPTCLK_ADDR(0))
#define _GPT_GPTCLK0			PREG16(_GPT_GPTCLK0_ADDR)
#define GPTCLK0				_GPT_GPTCLK0

#define _GPT_GPTCLK1_ADDR		(_GPT_GPTCLK_ADDR(1))
#define _GPT_GPTCLK1			PREG16(_GPT_GPTCLK1_ADDR)
#define GPTCLK1				_GPT_GPTCLK1

#define _GPT_GPTCLK_BASE			 (0x3u)
#define _GPT_GPTCLK_ADDR(n)		 ((_GPT_GPTCLK_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTCLK(n)			 PREG16(_GPT_GPTCLK_ADDR(n))
#define _GPT_GPTCLK_ADDR_H(devNum)	 _GPT_GPTCLK_ADDR(devNum)
#define _GPT_GPTCLK_ADDRH(devNum)	 _GPT_GPTCLK_ADDR(devNum)

/*--------------------- Register: GPTCNT1 -----------------------*/
#define _GPT_GPTCNT10_ADDR		(_GPT_GPTCNT1_ADDR(0))
#define _GPT_GPTCNT10			PREG16(_GPT_GPTCNT10_ADDR)
#define GPTCNT10				_GPT_GPTCNT10

#define _GPT_GPTCNT11_ADDR		(_GPT_GPTCNT1_ADDR(1))
#define _GPT_GPTCNT11			PREG16(_GPT_GPTCNT11_ADDR)
#define GPTCNT11				_GPT_GPTCNT11

#define _GPT_GPTCNT1_BASE			 (0x8u)
#define _GPT_GPTCNT1_ADDR(n)		 ((_GPT_GPTCNT1_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTCNT1(n)			 PREG16(_GPT_GPTCNT1_ADDR(n))
#define _GPT_GPTCNT1_ADDR_H(devNum)	 _GPT_GPTCNT1_ADDR(devNum)
#define _GPT_GPTCNT1_ADDRH(devNum)	 _GPT_GPTCNT1_ADDR(devNum)

/*--------------------- Register: GPTCNT2 -----------------------*/
#define _GPT_GPTCNT20_ADDR		(_GPT_GPTCNT2_ADDR(0))
#define _GPT_GPTCNT20			PREG16(_GPT_GPTCNT20_ADDR)
#define GPTCNT20				_GPT_GPTCNT20

#define _GPT_GPTCNT21_ADDR		(_GPT_GPTCNT2_ADDR(1))
#define _GPT_GPTCNT21			PREG16(_GPT_GPTCNT21_ADDR)
#define GPTCNT21				_GPT_GPTCNT21

#define _GPT_GPTCNT2_BASE			 (0x9u)
#define _GPT_GPTCNT2_ADDR(n)		 ((_GPT_GPTCNT2_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTCNT2(n)			 PREG16(_GPT_GPTCNT2_ADDR(n))
#define _GPT_GPTCNT2_ADDR_H(devNum)	 _GPT_GPTCNT2_ADDR(devNum)
#define _GPT_GPTCNT2_ADDRH(devNum)	 _GPT_GPTCNT2_ADDR(devNum)

/*--------------------- Register: GPTCNT3 -----------------------*/
#define _GPT_GPTCNT30_ADDR		(_GPT_GPTCNT3_ADDR(0))
#define _GPT_GPTCNT30			PREG16(_GPT_GPTCNT30_ADDR)
#define GPTCNT30				_GPT_GPTCNT30

#define _GPT_GPTCNT31_ADDR		(_GPT_GPTCNT3_ADDR(1))
#define _GPT_GPTCNT31			PREG16(_GPT_GPTCNT31_ADDR)
#define GPTCNT31				_GPT_GPTCNT31

#define _GPT_GPTCNT3_BASE			 (0xAu)
#define _GPT_GPTCNT3_ADDR(n)		 ((_GPT_GPTCNT3_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTCNT3(n)			 PREG16(_GPT_GPTCNT3_ADDR(n))
#define _GPT_GPTCNT3_ADDR_H(devNum)	 _GPT_GPTCNT3_ADDR(devNum)
#define _GPT_GPTCNT3_ADDRH(devNum)	 _GPT_GPTCNT3_ADDR(devNum)

/*--------------------- Register: GPTCNT4 -----------------------*/
#define _GPT_GPTCNT40_ADDR		(_GPT_GPTCNT4_ADDR(0))
#define _GPT_GPTCNT40			PREG16(_GPT_GPTCNT40_ADDR)
#define GPTCNT40				_GPT_GPTCNT40

#define _GPT_GPTCNT41_ADDR		(_GPT_GPTCNT4_ADDR(1))
#define _GPT_GPTCNT41			PREG16(_GPT_GPTCNT41_ADDR)
#define GPTCNT41				_GPT_GPTCNT41

#define _GPT_GPTCNT4_BASE			 (0xBu)
#define _GPT_GPTCNT4_ADDR(n)		 ((_GPT_GPTCNT4_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTCNT4(n)			 PREG16(_GPT_GPTCNT4_ADDR(n))
#define _GPT_GPTCNT4_ADDR_H(devNum)	 _GPT_GPTCNT4_ADDR(devNum)
#define _GPT_GPTCNT4_ADDRH(devNum)	 _GPT_GPTCNT4_ADDR(devNum)

/*--------------------- Register: GPTPRD1 -----------------------*/
#define _GPT_GPTPRD10_ADDR		(_GPT_GPTPRD1_ADDR(0))
#define _GPT_GPTPRD10			PREG16(_GPT_GPTPRD10_ADDR)
#define GPTPRD10				_GPT_GPTPRD10

#define _GPT_GPTPRD11_ADDR		(_GPT_GPTPRD1_ADDR(1))
#define _GPT_GPTPRD11			PREG16(_GPT_GPTPRD11_ADDR)
#define GPTPRD11				_GPT_GPTPRD11

#define _GPT_GPTPRD1_BASE			 (0xCu)
#define _GPT_GPTPRD1_ADDR(n)		 ((_GPT_GPTPRD1_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTPRD1(n)			 PREG16(_GPT_GPTPRD1_ADDR(n))
#define _GPT_GPTPRD1_ADDR_H(devNum)	 _GPT_GPTPRD1_ADDR(devNum)
#define _GPT_GPTPRD1_ADDRH(devNum)	 _GPT_GPTPRD1_ADDR(devNum)

/*--------------------- Register: GPTPRD2 -----------------------*/
#define _GPT_GPTPRD20_ADDR		(_GPT_GPTPRD2_ADDR(0))
#define _GPT_GPTPRD20			PREG16(_GPT_GPTPRD20_ADDR)
#define GPTPRD20				_GPT_GPTPRD20

#define _GPT_GPTPRD21_ADDR		(_GPT_GPTPRD2_ADDR(1))
#define _GPT_GPTPRD21			PREG16(_GPT_GPTPRD21_ADDR)
#define GPTPRD21				_GPT_GPTPRD21

#define _GPT_GPTPRD2_BASE			 (0xDu)
#define _GPT_GPTPRD2_ADDR(n)		 ((_GPT_GPTPRD2_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTPRD2(n)			 PREG16(_GPT_GPTPRD2_ADDR(n))
#define _GPT_GPTPRD2_ADDR_H(devNum)	 _GPT_GPTPRD2_ADDR(devNum)
#define _GPT_GPTPRD2_ADDRH(devNum)	 _GPT_GPTPRD2_ADDR(devNum)

/*--------------------- Register: GPTPRD3 -----------------------*/
#define _GPT_GPTPRD30_ADDR		(_GPT_GPTPRD3_ADDR(0))
#define _GPT_GPTPRD30			PREG16(_GPT_GPTPRD30_ADDR)
#define GPTPRD30				_GPT_GPTPRD30

#define _GPT_GPTPRD31_ADDR		(_GPT_GPTPRD3_ADDR(1))
#define _GPT_GPTPRD31			PREG16(_GPT_GPTPRD31_ADDR)
#define GPTPRD31				_GPT_GPTPRD31

#define _GPT_GPTPRD3_BASE			 (0xEu)
#define _GPT_GPTPRD3_ADDR(n)		 ((_GPT_GPTPRD3_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTPRD3(n)			 PREG16(_GPT_GPTPRD3_ADDR(n))
#define _GPT_GPTPRD3_ADDR_H(devNum)	 _GPT_GPTPRD3_ADDR(devNum)
#define _GPT_GPTPRD3_ADDRH(devNum)	 _GPT_GPTPRD3_ADDR(devNum)

/*--------------------- Register: GPTPRD4 -----------------------*/
#define _GPT_GPTPRD40_ADDR		(_GPT_GPTPRD4_ADDR(0))
#define _GPT_GPTPRD40			PREG16(_GPT_GPTPRD40_ADDR)
#define GPTPRD40				_GPT_GPTPRD40

#define _GPT_GPTPRD41_ADDR		(_GPT_GPTPRD4_ADDR(1))
#define _GPT_GPTPRD41			PREG16(_GPT_GPTPRD41_ADDR)
#define GPTPRD41				_GPT_GPTPRD41

#define _GPT_GPTPRD4_BASE			 (0xFu)
#define _GPT_GPTPRD4_ADDR(n)		 ((_GPT_GPTPRD4_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTPRD4(n)			 PREG16(_GPT_GPTPRD4_ADDR(n))
#define _GPT_GPTPRD4_ADDR_H(devNum)	 _GPT_GPTPRD4_ADDR(devNum)
#define _GPT_GPTPRD4_ADDRH(devNum)	 _GPT_GPTPRD4_ADDR(devNum)

/*--------------------- Register: GPTGPINT -----------------------*/
#define _GPT_GPTGPINT0_ADDR		(_GPT_GPTGPINT_ADDR(0))
#define _GPT_GPTGPINT0			PREG16(_GPT_GPTGPINT0_ADDR)
#define GPTGPINT0				_GPT_GPTGPINT0

#define _GPT_GPTGPINT1_ADDR		(_GPT_GPTGPINT_ADDR(1))
#define _GPT_GPTGPINT1			PREG16(_GPT_GPTGPINT1_ADDR)
#define GPTGPINT1				_GPT_GPTGPINT1

#define _GPT_GPTGPINT_BASE			 (0x4u)
#define _GPT_GPTGPINT_ADDR(n)		 ((_GPT_GPTGPINT_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTGPINT(n)			 PREG16(_GPT_GPTGPINT_ADDR(n))
#define _GPT_GPTGPINT_ADDR_H(devNum)	 _GPT_GPTGPINT_ADDR(devNum)
#define _GPT_GPTGPINT_ADDRH(devNum)	 _GPT_GPTGPINT_ADDR(devNum)

/*--------------------- Register: GPTGPEN -----------------------*/
#define _GPT_GPTGPEN0_ADDR		(_GPT_GPTGPEN_ADDR(0))
#define _GPT_GPTGPEN0			PREG16(_GPT_GPTGPEN0_ADDR)
#define GPTGPEN0				_GPT_GPTGPEN0

#define _GPT_GPTGPEN1_ADDR		(_GPT_GPTGPEN_ADDR(1))
#define _GPT_GPTGPEN1			PREG16(_GPT_GPTGPEN1_ADDR)
#define GPTGPEN1				_GPT_GPTGPEN1

#define _GPT_GPTGPEN_BASE			 (0x5u)
#define _GPT_GPTGPEN_ADDR(n)		 ((_GPT_GPTGPEN_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTGPEN(n)			 PREG16(_GPT_GPTGPEN_ADDR(n))
#define _GPT_GPTGPEN_ADDR_H(devNum)	 _GPT_GPTGPEN_ADDR(devNum)
#define _GPT_GPTGPEN_ADDRH(devNum)	 _GPT_GPTGPEN_ADDR(devNum)

/*--------------------- Register: GPTGPDIR -----------------------*/
#define _GPT_GPTGPDIR0_ADDR		(_GPT_GPTGPDIR_ADDR(0))
#define _GPT_GPTGPDIR0			PREG16(_GPT_GPTGPDIR0_ADDR)
#define GPTGPDIR0				_GPT_GPTGPDIR0

#define _GPT_GPTGPDIR1_ADDR		(_GPT_GPTGPDIR_ADDR(1))
#define _GPT_GPTGPDIR1			PREG16(_GPT_GPTGPDIR1_ADDR)
#define GPTGPDIR1				_GPT_GPTGPDIR1

#define _GPT_GPTGPDIR_BASE			 (0x7u)
#define _GPT_GPTGPDIR_ADDR(n)		 ((_GPT_GPTGPDIR_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTGPDIR(n)			 PREG16(_GPT_GPTGPDIR_ADDR(n))
#define _GPT_GPTGPDIR_ADDR_H(devNum)	 _GPT_GPTGPDIR_ADDR(devNum)
#define _GPT_GPTGPDIR_ADDRH(devNum)	 _GPT_GPTGPDIR_ADDR(devNum)

/*--------------------- Register: GPTGPDAT -----------------------*/
#define _GPT_GPTGPDAT0_ADDR		(_GPT_GPTGPDAT_ADDR(0))
#define _GPT_GPTGPDAT0			PREG16(_GPT_GPTGPDAT0_ADDR)
#define GPTGPDAT0				_GPT_GPTGPDAT0

#define _GPT_GPTGPDAT1_ADDR		(_GPT_GPTGPDAT_ADDR(1))
#define _GPT_GPTGPDAT1			PREG16(_GPT_GPTGPDAT1_ADDR)
#define GPTGPDAT1				_GPT_GPTGPDAT1

#define _GPT_GPTGPDAT_BASE			 (0x6u)
#define _GPT_GPTGPDAT_ADDR(n)		 ((_GPT_GPTGPDAT_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTGPDAT(n)			 PREG16(_GPT_GPTGPDAT_ADDR(n))
#define _GPT_GPTGPDAT_ADDR_H(devNum)	 _GPT_GPTGPDAT_ADDR(devNum)
#define _GPT_GPTGPDAT_ADDRH(devNum)	 _GPT_GPTGPDAT_ADDR(devNum)

/*--------------------- Register: GPTCTL1 -----------------------*/
#define _GPT_GPTCTL10_ADDR		(_GPT_GPTCTL1_ADDR(0))
#define _GPT_GPTCTL10			PREG16(_GPT_GPTCTL10_ADDR)
#define GPTCTL10				_GPT_GPTCTL10

#define _GPT_GPTCTL11_ADDR		(_GPT_GPTCTL1_ADDR(1))
#define _GPT_GPTCTL11			PREG16(_GPT_GPTCTL11_ADDR)
#define GPTCTL11				_GPT_GPTCTL11

#define _GPT_GPTCTL1_BASE			 (0x10u)
#define _GPT_GPTCTL1_ADDR(n)		 ((_GPT_GPTCTL1_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTCTL1(n)			 PREG16(_GPT_GPTCTL1_ADDR(n))
#define _GPT_GPTCTL1_ADDR_H(devNum)	 _GPT_GPTCTL1_ADDR(devNum)
#define _GPT_GPTCTL1_ADDRH(devNum)	 _GPT_GPTCTL1_ADDR(devNum)

/*--------------------- Register: GPTCTL2 -----------------------*/
#define _GPT_GPTCTL20_ADDR		(_GPT_GPTCTL2_ADDR(0))
#define _GPT_GPTCTL20			PREG16(_GPT_GPTCTL20_ADDR)
#define GPTCTL20				_GPT_GPTCTL20

#define _GPT_GPTCTL21_ADDR		(_GPT_GPTCTL2_ADDR(1))
#define _GPT_GPTCTL21			PREG16(_GPT_GPTCTL21_ADDR)
#define GPTCTL21				_GPT_GPTCTL21

#define _GPT_GPTCTL2_BASE			 (0x11u)
#define _GPT_GPTCTL2_ADDR(n)		 ((_GPT_GPTCTL2_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTCTL2(n)			 PREG16(_GPT_GPTCTL2_ADDR(n))
#define _GPT_GPTCTL2_ADDR_H(devNum)	 _GPT_GPTCTL2_ADDR(devNum)
#define _GPT_GPTCTL2_ADDRH(devNum)	 _GPT_GPTCTL2_ADDR(devNum)

/*--------------------- Register: GPTGCTL1 -----------------------*/
#define _GPT_GPTGCTL10_ADDR		(_GPT_GPTGCTL1_ADDR(0))
#define _GPT_GPTGCTL10			PREG16(_GPT_GPTGCTL10_ADDR)
#define GPTGCTL10				_GPT_GPTGCTL10

#define _GPT_GPTGCTL11_ADDR		(_GPT_GPTGCTL1_ADDR(1))
#define _GPT_GPTGCTL11			PREG16(_GPT_GPTGCTL11_ADDR)
#define GPTGCTL11				_GPT_GPTGCTL11

#define _GPT_GPTGCTL1_BASE			 (0x12u)
#define _GPT_GPTGCTL1_ADDR(n)		 ((_GPT_GPTGCTL1_BASE) + (_GPT_BASE_ADDRn(n)))
#define _GPT_GPTGCTL1(n)			 PREG16(_GPT_GPTGCTL1_ADDR(n))
#define _GPT_GPTGCTL1_ADDR_H(devNum)	 _GPT_GPTGCTL1_ADDR(devNum)
#define _GPT_GPTGCTL1_ADDRH(devNum)	 _GPT_GPTGCTL1_ADDR(devNum)


/*----------------------------------------------------------------*\
*		 Register Macros		
\*----------------------------------------------------------------*/

#define GPT_ADDR(Reg)		  _GPT_##Reg##_ADDR
#define GPT_RGET(Reg)		  _GPT_##Reg##_GET
#define GPT_RSET(Reg,Val)		  _GPT_##Reg##_SET(Val)
#define GPT_FGET(Reg,Field)		  _GPT_##Reg##_FGET(Field)
#define GPT_FSET(Reg,Field,Val)		  _GPT_##Reg##_FSET(Field, Val)
#define GPT_FMK(Reg,Field,Val)		  _GPT_##Reg##_##Field##_MK(Val)
#define GPT_RAOI(Reg,AND,OR,INV)		  _GPT_##Reg##_AOI(AND,OR,INV)
#define GPT_FAOI(Reg,Field,AND,OR,INV)	  _GPT_##Reg##_FAOI(Field,AND,OR,INV)
#define GPT_FMKS(Reg,Field,Sym)\
	  _GPT_##Reg##_##Field##_MK(GPT_##Reg##_##Field##_##Sym)
#define GPT_FSETS(Reg,Field,Sym)\
	 _GPT_##Reg##_FSET(Field,GPT_##Reg##_##Field##_##Sym)

#define GPT_ADDR_H(Handle,Reg)		  _GPT_##Reg##_ADDR_H(((GPT_PrivateObj*)(Handle))->devNum)
#define GPT_RGET_H(Handle,Reg)		  _GPT_##Reg##_GET(((GPT_PrivateObj*)(Handle))->devNum)
#define GPT_RSET_H(Handle,Reg,Val)		  _GPT_##Reg##_SET((((GPT_PrivateObj*)(Handle))->devNum),Val)
#define GPT_FGET_H(Handle,Reg,Field)	  _GPT_##Reg##_FGET((((GPT_PrivateObj*)(Handle))->devNum),Field)
#define GPT_FSET_H(Handle,Reg,Field,Val)	  _GPT_##Reg##_FSET((((GPT_PrivateObj*)(Handle))->devNum),Field,Val)
#define GPT_FMK_H(Handle,Reg,Field,Val)	  _GPT_##Reg##_##Field##_MK(Val)


#define GPT_ADDRH(Handle,Reg)		  _GPT_##Reg##_ADDRH(((GPT_PrivateObj*)(Handle))->devNum)
#define GPT_RGETH(Handle,Reg)		  _GPT_##Reg##_GET(((GPT_PrivateObj*)(Handle))->devNum)
#define GPT_RSETH(Handle,Reg,Val)		  _GPT_##Reg##_SET((((GPT_PrivateObj*)(Handle))->devNum),Val)
#define GPT_FGETH(Handle,Reg,Field)	  _GPT_##Reg##_FGET((((GPT_PrivateObj*)(Handle))->devNum),Field)
#define GPT_FSETH(Handle,Reg,Field,Val)	  _GPT_##Reg##_FSET((((GPT_PrivateObj*)(Handle))->devNum),Field,Val)
#define GPT_FMKH(Handle,Reg,Field,Val)	  _GPT_##Reg##_##Field##_MK(Val)

#define GPT_RAOI_H(Handle,Reg,AND,OR,INV)	  _GPT_##Reg##_AOI((((GPT_PrivateObj*)(Handle))->devNum),AND,OR,INV)
#define GPT_FAOI_H(Handle,Reg,Field,AND,OR,INV)\
	  _GPT_##Reg##_FAOI((((GPT_PrivateObj*)(Handle))->devNum),Field,AND,OR,INV)
#define GPT_FMKS_H(Handle,Reg,Field,Sym)\
	   _GPT_##Reg##_##Field##_MK(GPT_##Reg##_##Field##_##Sym)
#define GPT_FSETS_H(Handle,Reg,Field,Sym)\
	 _GPT_##Reg##_FSET(Handle,Field,GPT_##Reg##_##Field##_##Sym)


#define GPT_RAOIH(Handle,Reg,AND,OR,INV)	  _GPT_##Reg##_AOI((((GPT_PrivateObj*)(Handle))->devNum),AND,OR,INV)
#define GPT_FAOIH(Handle,Reg,Field,AND,OR,INV)\
	  _GPT_##Reg##_FAOI((((GPT_PrivateObj*)(Handle))->devNum),Field,AND,OR,INV)
#define GPT_FMKSH(Handle,Reg,Field,Sym)\
	   _GPT_##Reg##_##Field##_MK(GPT_##Reg##_##Field##_##Sym)
#define GPT_FSETSH(Handle,Reg,Field,Sym)\
	 _GPT_##Reg##_FSET(Handle,Field,GPT_##Reg##_##Field##_##Sym)



/*----------------------------------------------------------------*\
*		 Handle Registers Macros		
\*----------------------------------------------------------------*/


/*--------------------- Register: GPTPID1 -----------------------*/
#define _GPT_GPTPID1_GET(devNum)		  _PREG_GET(_GPT_GPTPID1_ADDR(devNum)) 
#define _GPT_GPTPID1_SET(devNum,Val)		  _PREG_SET(_GPT_GPTPID1_ADDR(devNum),Val)
#define _GPT_GPTPID1_FGET(devNum,Field)	          _PFIELD_GET(_GPT_GPTPID1_ADDR(devNum), _GPT_GPTPID1_##Field)
#define _GPT_GPTPID1_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTPID1_ADDR(devNum), _GPT_GPTPID1_##Field, Val)
#define _GPT_GPTPID1_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTPID1_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTPID1_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPID1_ADDR(devNum), _GPT_GPTPID1_##Field,AND,OR,INV)

#define _GPT_GPTPID10_GET		  _PREG_GET(_GPT_GPTPID1_ADDR(0)) 
#define _GPT_GPTPID10_SET(Val)		  _PREG_SET(_GPT_GPTPID1_ADDR(0),Val)
#define _GPT_GPTPID10_FGET(Field)	  _PFIELD_GET(_GPT_GPTPID1_ADDR(0), _GPT_GPTPID1_##Field)
#define _GPT_GPTPID10_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPID1_ADDR(0), _GPT_GPTPID1_##Field, Val)
#define _GPT_GPTPID10_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPID1_ADDR(0),AND,OR,INV)
#define _GPT_GPTPID10_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPID1_ADDR(0), _GPT_GPTPID1_##Field,AND,OR,INV)

#define _GPT_GPTPID11_GET		  _PREG_GET(_GPT_GPTPID1_ADDR(1)) 
#define _GPT_GPTPID11_SET(Val)		  _PREG_SET(_GPT_GPTPID1_ADDR(1),Val)
#define _GPT_GPTPID11_FGET(Field)	  _PFIELD_GET(_GPT_GPTPID1_ADDR(1), _GPT_GPTPID1_##Field)
#define _GPT_GPTPID11_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPID1_ADDR(1), _GPT_GPTPID1_##Field, Val)
#define _GPT_GPTPID11_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPID1_ADDR(1),AND,OR,INV)
#define _GPT_GPTPID11_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPID1_ADDR(1), _GPT_GPTPID1_##Field,AND,OR,INV)


/*--------------------- Register: GPTPID2 -----------------------*/
#define _GPT_GPTPID2_GET(devNum)			  _PREG_GET(_GPT_GPTPID2_ADDR(devNum)) 
#define _GPT_GPTPID2_SET(devNum,Val)		  _PREG_SET(_GPT_GPTPID2_ADDR(devNum),Val)
#define _GPT_GPTPID2_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTPID2_ADDR(devNum), _GPT_GPTPID2_##Field)
#define _GPT_GPTPID2_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTPID2_ADDR(devNum), _GPT_GPTPID2_##Field, Val)
#define _GPT_GPTPID2_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTPID2_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTPID2_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPID2_ADDR(devNum), _GPT_GPTPID2_##Field,AND,OR,INV)

#define _GPT_GPTPID20_GET		  _PREG_GET(_GPT_GPTPID2_ADDR(0)) 
#define _GPT_GPTPID20_SET(Val)		  _PREG_SET(_GPT_GPTPID2_ADDR(0),Val)
#define _GPT_GPTPID20_FGET(Field)	  _PFIELD_GET(_GPT_GPTPID2_ADDR(0), _GPT_GPTPID2_##Field)
#define _GPT_GPTPID20_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPID2_ADDR(0), _GPT_GPTPID2_##Field, Val)
#define _GPT_GPTPID20_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPID2_ADDR(0),AND,OR,INV)
#define _GPT_GPTPID20_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPID2_ADDR(0), _GPT_GPTPID2_##Field,AND,OR,INV)

#define _GPT_GPTPID21_GET		  _PREG_GET(_GPT_GPTPID2_ADDR(1)) 
#define _GPT_GPTPID21_SET(Val)		  _PREG_SET(_GPT_GPTPID2_ADDR(1),Val)
#define _GPT_GPTPID21_FGET(Field)	  _PFIELD_GET(_GPT_GPTPID2_ADDR(1), _GPT_GPTPID2_##Field)
#define _GPT_GPTPID21_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPID2_ADDR(1), _GPT_GPTPID2_##Field, Val)
#define _GPT_GPTPID21_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPID2_ADDR(1),AND,OR,INV)
#define _GPT_GPTPID21_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPID2_ADDR(1), _GPT_GPTPID2_##Field,AND,OR,INV)


/*--------------------- Register: GPTEMU -----------------------*/
#define _GPT_GPTEMU_GET(devNum)			  _PREG_GET(_GPT_GPTEMU_ADDR(devNum)) 
#define _GPT_GPTEMU_SET(devNum,Val)		  _PREG_SET(_GPT_GPTEMU_ADDR(devNum),Val)
#define _GPT_GPTEMU_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTEMU_ADDR(devNum), _GPT_GPTEMU_##Field)
#define _GPT_GPTEMU_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTEMU_ADDR(devNum), _GPT_GPTEMU_##Field, Val)
#define _GPT_GPTEMU_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTEMU_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTEMU_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTEMU_ADDR(devNum), _GPT_GPTEMU_##Field,AND,OR,INV)

#define _GPT_GPTEMU0_GET		  _PREG_GET(_GPT_GPTEMU_ADDR(0)) 
#define _GPT_GPTEMU0_SET(Val)		  _PREG_SET(_GPT_GPTEMU_ADDR(0),Val)
#define _GPT_GPTEMU0_FGET(Field)	  _PFIELD_GET(_GPT_GPTEMU_ADDR(0), _GPT_GPTEMU_##Field)
#define _GPT_GPTEMU0_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTEMU_ADDR(0), _GPT_GPTEMU_##Field, Val)
#define _GPT_GPTEMU0_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTEMU_ADDR(0),AND,OR,INV)
#define _GPT_GPTEMU0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTEMU_ADDR(0), _GPT_GPTEMU_##Field,AND,OR,INV)

#define _GPT_GPTEMU1_GET		  _PREG_GET(_GPT_GPTEMU_ADDR(1)) 
#define _GPT_GPTEMU1_SET(Val)		  _PREG_SET(_GPT_GPTEMU_ADDR(1),Val)
#define _GPT_GPTEMU1_FGET(Field)	  _PFIELD_GET(_GPT_GPTEMU_ADDR(1), _GPT_GPTEMU_##Field)
#define _GPT_GPTEMU1_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTEMU_ADDR(1), _GPT_GPTEMU_##Field, Val)
#define _GPT_GPTEMU1_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTEMU_ADDR(1),AND,OR,INV)
#define _GPT_GPTEMU1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTEMU_ADDR(1), _GPT_GPTEMU_##Field,AND,OR,INV)


/*--------------------- Register: GPTCLK -----------------------*/
#define _GPT_GPTCLK_GET(devNum)			  _PREG_GET(_GPT_GPTCLK_ADDR(devNum)) 
#define _GPT_GPTCLK_SET(devNum,Val)		  _PREG_SET(_GPT_GPTCLK_ADDR(devNum),Val)
#define _GPT_GPTCLK_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTCLK_ADDR(devNum), _GPT_GPTCLK_##Field)
#define _GPT_GPTCLK_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTCLK_ADDR(devNum), _GPT_GPTCLK_##Field, Val)
#define _GPT_GPTCLK_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTCLK_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTCLK_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCLK_ADDR(devNum), _GPT_GPTCLK_##Field,AND,OR,INV)

#define _GPT_GPTCLK0_GET		  _PREG_GET(_GPT_GPTCLK_ADDR(0)) 
#define _GPT_GPTCLK0_SET(Val)		  _PREG_SET(_GPT_GPTCLK_ADDR(0),Val)
#define _GPT_GPTCLK0_FGET(Field)	  _PFIELD_GET(_GPT_GPTCLK_ADDR(0), _GPT_GPTCLK_##Field)
#define _GPT_GPTCLK0_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCLK_ADDR(0), _GPT_GPTCLK_##Field, Val)
#define _GPT_GPTCLK0_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCLK_ADDR(0),AND,OR,INV)
#define _GPT_GPTCLK0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCLK_ADDR(0),  _GPT_GPTCLK_##Field,AND,OR,INV)

#define _GPT_GPTCLK1_GET		  _PREG_GET(_GPT_GPTCLK_ADDR(1)) 
#define _GPT_GPTCLK1_SET(Val)		  _PREG_SET(_GPT_GPTCLK_ADDR(1),Val)
#define _GPT_GPTCLK1_FGET(Field)	  _PFIELD_GET(_GPT_GPTCLK_ADDR(1), _GPT_GPTCLK_##Field)
#define _GPT_GPTCLK1_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCLK_ADDR(1), _GPT_GPTCLK_##Field, Val)
#define _GPT_GPTCLK1_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCLK_ADDR(1),AND,OR,INV)
#define _GPT_GPTCLK1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCLK_ADDR(1),  _GPT_GPTCLK_##Field,AND,OR,INV)


/*--------------------- Register: GPTCNT1 -----------------------*/
#define _GPT_GPTCNT1_GET(devNum)			  _PREG_GET(_GPT_GPTCNT1_ADDR(devNum)) 
#define _GPT_GPTCNT1_SET(devNum,Val)		  _PREG_SET(_GPT_GPTCNT1_ADDR(devNum),Val)
#define _GPT_GPTCNT1_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTCNT1_ADDR(devNum), _GPT_GPTCNT1_##Field)
#define _GPT_GPTCNT1_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTCNT1_ADDR(devNum), _GPT_GPTCNT1_##Field, Val)
#define _GPT_GPTCNT1_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTCNT1_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTCNT1_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT1_ADDR(devNum), _GPT_GPTCNT1_##Field,AND,OR,INV)

#define _GPT_GPTCNT10_GET		  _PREG_GET(_GPT_GPTCNT1_ADDR(0)) 
#define _GPT_GPTCNT10_SET(Val)		  _PREG_SET(_GPT_GPTCNT1_ADDR(0),Val)
#define _GPT_GPTCNT10_FGET(Field)	  _PFIELD_GET(_GPT_GPTCNT1_ADDR(0), _GPT_GPTCNT1_##Field)
#define _GPT_GPTCNT10_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCNT1_ADDR(0), _GPT_GPTCNT1_##Field, Val)
#define _GPT_GPTCNT10_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCNT1_ADDR(0),AND,OR,INV)
#define _GPT_GPTCNT10_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT1_ADDR(0), _GPT_GPTCNT1_##Field,AND,OR,INV)

#define _GPT_GPTCNT11_GET		  _PREG_GET(_GPT_GPTCNT1_ADDR(1)) 
#define _GPT_GPTCNT11_SET(Val)		  _PREG_SET(_GPT_GPTCNT1_ADDR(1),Val)
#define _GPT_GPTCNT11_FGET(Field)	  _PFIELD_GET(_GPT_GPTCNT1_ADDR(1), _GPT_GPTCNT1_##Field)
#define _GPT_GPTCNT11_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCNT1_ADDR(1), _GPT_GPTCNT1_##Field, Val)
#define _GPT_GPTCNT11_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCNT1_ADDR(1),AND,OR,INV)
#define _GPT_GPTCNT11_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT1_ADDR(1), _GPT_GPTCNT1_##Field,AND,OR,INV)


/*--------------------- Register: GPTCNT2 -----------------------*/
#define _GPT_GPTCNT2_GET(devNum)	       _PREG_GET(_GPT_GPTCNT2_ADDR(devNum)) 
#define _GPT_GPTCNT2_SET(devNum,Val)	       _PREG_SET(_GPT_GPTCNT2_ADDR(devNum),Val)
#define _GPT_GPTCNT2_FGET(devNum,Field)	       _PFIELD_GET(_GPT_GPTCNT2_ADDR(devNum), _GPT_GPTCNT2_##Field)
#define _GPT_GPTCNT2_FSET(devNum,Field,Val)    _PFIELD_SET(_GPT_GPTCNT2_ADDR(devNum), _GPT_GPTCNT2_##Field, Val)
#define _GPT_GPTCNT2_AOI(devNum,AND,OR,INV)    _PREG_AOI(_GPT_GPTCNT2_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTCNT2_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT2_ADDR(devNum), _GPT_GPTCNT2_##Field,AND,OR,INV)

#define _GPT_GPTCNT20_GET		  _PREG_GET(_GPT_GPTCNT2_ADDR(0)) 
#define _GPT_GPTCNT20_SET(Val)		  _PREG_SET(_GPT_GPTCNT2_ADDR(0),Val)
#define _GPT_GPTCNT20_FGET(Field)	  _PFIELD_GET(_GPT_GPTCNT2_ADDR(0), _GPT_GPTCNT2_##Field)
#define _GPT_GPTCNT20_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCNT2_ADDR(0), _GPT_GPTCNT2_##Field, Val)
#define _GPT_GPTCNT20_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCNT2_ADDR(0),AND,OR,INV)
#define _GPT_GPTCNT20_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT2_ADDR(0), _GPT_GPTCNT2_##Field,AND,OR,INV)

#define _GPT_GPTCNT21_GET		  _PREG_GET(_GPT_GPTCNT2_ADDR(1)) 
#define _GPT_GPTCNT21_SET(Val)		  _PREG_SET(_GPT_GPTCNT2_ADDR(1),Val)
#define _GPT_GPTCNT21_FGET(Field)	  _PFIELD_GET(_GPT_GPTCNT2_ADDR(1), _GPT_GPTCNT2_##Field)
#define _GPT_GPTCNT21_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCNT2_ADDR(1), _GPT_GPTCNT2_##Field, Val)
#define _GPT_GPTCNT21_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCNT2_ADDR(1),AND,OR,INV)
#define _GPT_GPTCNT21_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT2_ADDR(1), _GPT_GPTCNT2_##Field,AND,OR,INV)


/*--------------------- Register: GPTCNT3 -----------------------*/
#define _GPT_GPTCNT3_GET(devNum)	  _PREG_GET(_GPT_GPTCNT3_ADDR(devNum)) 
#define _GPT_GPTCNT3_SET(devNum,Val)	  _PREG_SET(_GPT_GPTCNT3_ADDR(devNum),Val)
#define _GPT_GPTCNT3_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTCNT3_ADDR(devNum), _GPT_GPTCNT3_##Field)
#define _GPT_GPTCNT3_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTCNT3_ADDR(devNum), _GPT_GPTCNT3_##Field, Val)
#define _GPT_GPTCNT3_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTCNT3_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTCNT3_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT3_ADDR(devNum),    _GPT_GPTCNT3_##Field,AND,OR,INV)

#define _GPT_GPTCNT30_GET		  _PREG_GET(_GPT_GPTCNT3_ADDR(0)) 
#define _GPT_GPTCNT30_SET(Val)		  _PREG_SET(_GPT_GPTCNT3_ADDR(0),Val)
#define _GPT_GPTCNT30_FGET(Field)	  _PFIELD_GET(_GPT_GPTCNT3_ADDR(0), _GPT_GPTCNT3_##Field)
#define _GPT_GPTCNT30_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCNT3_ADDR(0), _GPT_GPTCNT3_##Field, Val)
#define _GPT_GPTCNT30_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCNT3_ADDR(0),AND,OR,INV)
#define _GPT_GPTCNT30_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT3_ADDR(0), _GPT_GPTCNT3_##Field,AND,OR,INV)

#define _GPT_GPTCNT31_GET		  _PREG_GET(_GPT_GPTCNT3_ADDR(1)) 
#define _GPT_GPTCNT31_SET(Val)		  _PREG_SET(_GPT_GPTCNT3_ADDR(1),Val)
#define _GPT_GPTCNT31_FGET(Field)	  _PFIELD_GET(_GPT_GPTCNT3_ADDR(1), _GPT_GPTCNT3_##Field)
#define _GPT_GPTCNT31_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCNT3_ADDR(1), _GPT_GPTCNT3_##Field, Val)
#define _GPT_GPTCNT31_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCNT3_ADDR(1),AND,OR,INV)
#define _GPT_GPTCNT31_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT3_ADDR(1), _GPT_GPTCNT3_##Field,AND,OR,INV)


/*--------------------- Register: GPTCNT4 -----------------------*/
#define _GPT_GPTCNT4_GET(devNum)			  _PREG_GET(_GPT_GPTCNT4_ADDR(devNum)) 
#define _GPT_GPTCNT4_SET(devNum,Val)		  _PREG_SET(_GPT_GPTCNT4_ADDR(devNum),Val)
#define _GPT_GPTCNT4_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTCNT4_ADDR(devNum), _GPT_GPTCNT4_##Field)
#define _GPT_GPTCNT4_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTCNT4_ADDR(devNum), _GPT_GPTCNT4_##Field, Val)
#define _GPT_GPTCNT4_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTCNT4_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTCNT4_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT4_ADDR(devNum), _GPT_GPTCNT4_##Field,AND,OR,INV)

#define _GPT_GPTCNT40_GET		  _PREG_GET(_GPT_GPTCNT4_ADDR(0)) 
#define _GPT_GPTCNT40_SET(Val)		  _PREG_SET(_GPT_GPTCNT4_ADDR(0),Val)
#define _GPT_GPTCNT40_FGET(Field)	  _PFIELD_GET(_GPT_GPTCNT4_ADDR(0), _GPT_GPTCNT4_##Field)
#define _GPT_GPTCNT40_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCNT4_ADDR(0), _GPT_GPTCNT4_##Field, Val)
#define _GPT_GPTCNT40_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCNT4_ADDR(0),AND,OR,INV)
#define _GPT_GPTCNT40_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT4_ADDR(0), _GPT_GPTCNT4_##Field,AND,OR,INV)

#define _GPT_GPTCNT41_GET		  _PREG_GET(_GPT_GPTCNT4_ADDR(1)) 
#define _GPT_GPTCNT41_SET(Val)		  _PREG_SET(_GPT_GPTCNT4_ADDR(1),Val)
#define _GPT_GPTCNT41_FGET(Field)	  _PFIELD_GET(_GPT_GPTCNT4_ADDR(1), _GPT_GPTCNT4_##Field)
#define _GPT_GPTCNT41_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCNT4_ADDR(1), _GPT_GPTCNT4_##Field, Val)
#define _GPT_GPTCNT41_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCNT4_ADDR(1),AND,OR,INV)
#define _GPT_GPTCNT41_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCNT4_ADDR(1), _GPT_GPTCNT4_##Field,AND,OR,INV)


/*--------------------- Register: GPTPRD1 -----------------------*/
#define _GPT_GPTPRD1_GET(devNum)	  _PREG_GET(_GPT_GPTPRD1_ADDR(devNum)) 
#define _GPT_GPTPRD1_SET(devNum,Val)	  _PREG_SET(_GPT_GPTPRD1_ADDR(devNum),Val)
#define _GPT_GPTPRD1_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTPRD1_ADDR(devNum), _GPT_GPTPRD1_##Field)
#define _GPT_GPTPRD1_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTPRD1_ADDR(devNum), _GPT_GPTPRD1_##Field, Val)
#define _GPT_GPTPRD1_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD1_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTPRD1_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD1_ADDR(devNum), _GPT_GPTPRD1_##Field,AND,OR,INV)

#define _GPT_GPTPRD10_GET		  _PREG_GET(_GPT_GPTPRD1_ADDR(0)) 
#define _GPT_GPTPRD10_SET(Val)		  _PREG_SET(_GPT_GPTPRD1_ADDR(0),Val)
#define _GPT_GPTPRD10_FGET(Field)	  _PFIELD_GET(_GPT_GPTPRD1_ADDR(0), _GPT_GPTPRD1_##Field)
#define _GPT_GPTPRD10_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPRD1_ADDR(0), _GPT_GPTPRD1_##Field, Val)
#define _GPT_GPTPRD10_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD1_ADDR(0),AND,OR,INV)
#define _GPT_GPTPRD10_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD1_ADDR(0), _GPT_GPTPRD1_##Field,AND,OR,INV)

#define _GPT_GPTPRD11_GET		  _PREG_GET(_GPT_GPTPRD1_ADDR(1)) 
#define _GPT_GPTPRD11_SET(Val)		  _PREG_SET(_GPT_GPTPRD1_ADDR(1),Val)
#define _GPT_GPTPRD11_FGET(Field)	  _PFIELD_GET(_GPT_GPTPRD1_ADDR(1), _GPT_GPTPRD1_##Field)
#define _GPT_GPTPRD11_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPRD1_ADDR(1), _GPT_GPTPRD1_##Field, Val)
#define _GPT_GPTPRD11_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD1_ADDR(1),AND,OR,INV)
#define _GPT_GPTPRD11_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD1_ADDR(1), _GPT_GPTPRD1_##Field,AND,OR,INV)


/*--------------------- Register: GPTPRD2 -----------------------*/
#define _GPT_GPTPRD2_GET(devNum)	  _PREG_GET(_GPT_GPTPRD2_ADDR(devNum)) 
#define _GPT_GPTPRD2_SET(devNum,Val)	  _PREG_SET(_GPT_GPTPRD2_ADDR(devNum),Val)
#define _GPT_GPTPRD2_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTPRD2_ADDR(devNum), _GPT_GPTPRD2_##Field)
#define _GPT_GPTPRD2_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTPRD2_ADDR(devNum), _GPT_GPTPRD2_##Field, Val)
#define _GPT_GPTPRD2_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD2_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTPRD2_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD2_ADDR(devNum), _GPT_GPTPRD2_##Field,AND,OR,INV)

#define _GPT_GPTPRD20_GET		  _PREG_GET(_GPT_GPTPRD2_ADDR(0)) 
#define _GPT_GPTPRD20_SET(Val)		  _PREG_SET(_GPT_GPTPRD2_ADDR(0),Val)
#define _GPT_GPTPRD20_FGET(Field)	  _PFIELD_GET(_GPT_GPTPRD2_ADDR(0), _GPT_GPTPRD2_##Field)
#define _GPT_GPTPRD20_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPRD2_ADDR(0), _GPT_GPTPRD2_##Field, Val)
#define _GPT_GPTPRD20_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD2_ADDR(0),AND,OR,INV)
#define _GPT_GPTPRD20_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD2_ADDR(0), _GPT_GPTPRD2_##Field,AND,OR,INV)

#define _GPT_GPTPRD21_GET		  _PREG_GET(_GPT_GPTPRD2_ADDR(1)) 
#define _GPT_GPTPRD21_SET(Val)		  _PREG_SET(_GPT_GPTPRD2_ADDR(1),Val)
#define _GPT_GPTPRD21_FGET(Field)	  _PFIELD_GET(_GPT_GPTPRD2_ADDR(1), _GPT_GPTPRD2_##Field)
#define _GPT_GPTPRD21_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPRD2_ADDR(1), _GPT_GPTPRD2_##Field, Val)
#define _GPT_GPTPRD21_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD2_ADDR(1),AND,OR,INV)
#define _GPT_GPTPRD21_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD2_ADDR(1), _GPT_GPTPRD2_##Field,AND,OR,INV)


/*--------------------- Register: GPTPRD3 -----------------------*/
#define _GPT_GPTPRD3_GET(devNum)	  _PREG_GET(_GPT_GPTPRD3_ADDR(devNum)) 
#define _GPT_GPTPRD3_SET(devNum,Val)	  _PREG_SET(_GPT_GPTPRD3_ADDR(devNum),Val)
#define _GPT_GPTPRD3_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTPRD3_ADDR(devNum), _GPT_GPTPRD3_##Field)
#define _GPT_GPTPRD3_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTPRD3_ADDR(devNum), _GPT_GPTPRD3_##Field, Val)
#define _GPT_GPTPRD3_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD3_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTPRD3_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD3_ADDR(devNum), _GPT_GPTPRD3_##Field,AND,OR,INV)

#define _GPT_GPTPRD30_GET		  _PREG_GET(_GPT_GPTPRD3_ADDR(0)) 
#define _GPT_GPTPRD30_SET(Val)		  _PREG_SET(_GPT_GPTPRD3_ADDR(0),Val)
#define _GPT_GPTPRD30_FGET(Field)	  _PFIELD_GET(_GPT_GPTPRD3_ADDR(0), _GPT_GPTPRD3_##Field)
#define _GPT_GPTPRD30_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPRD3_ADDR(0), _GPT_GPTPRD3_##Field, Val)
#define _GPT_GPTPRD30_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD3_ADDR(0),AND,OR,INV)
#define _GPT_GPTPRD30_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD3_ADDR(0), _GPT_GPTPRD3_##Field,AND,OR,INV)

#define _GPT_GPTPRD31_GET		  _PREG_GET(_GPT_GPTPRD3_ADDR(1)) 
#define _GPT_GPTPRD31_SET(Val)		  _PREG_SET(_GPT_GPTPRD3_ADDR(1),Val)
#define _GPT_GPTPRD31_FGET(Field)	  _PFIELD_GET(_GPT_GPTPRD3_ADDR(1), _GPT_GPTPRD3_##Field)
#define _GPT_GPTPRD31_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPRD3_ADDR(1), _GPT_GPTPRD3_##Field, Val)
#define _GPT_GPTPRD31_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD3_ADDR(1),AND,OR,INV)
#define _GPT_GPTPRD31_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD3_ADDR(1), _GPT_GPTPRD3_##Field,AND,OR,INV)


/*--------------------- Register: GPTPRD4 -----------------------*/
#define _GPT_GPTPRD4_GET(devNum)	  _PREG_GET(_GPT_GPTPRD4_ADDR(devNum)) 
#define _GPT_GPTPRD4_SET(devNum,Val)	  _PREG_SET(_GPT_GPTPRD4_ADDR(devNum),Val)
#define _GPT_GPTPRD4_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTPRD4_ADDR(devNum), _GPT_GPTPRD4_##Field)
#define _GPT_GPTPRD4_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTPRD4_ADDR(devNum), _GPT_GPTPRD4_##Field, Val)
#define _GPT_GPTPRD4_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD4_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTPRD4_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD4_ADDR(devNum), _GPT_GPTPRD4_##Field,AND,OR,INV)

#define _GPT_GPTPRD40_GET		  _PREG_GET(_GPT_GPTPRD4_ADDR(0)) 
#define _GPT_GPTPRD40_SET(Val)		  _PREG_SET(_GPT_GPTPRD4_ADDR(0),Val)
#define _GPT_GPTPRD40_FGET(Field)	  _PFIELD_GET(_GPT_GPTPRD4_ADDR(0), _GPT_GPTPRD4_##Field)
#define _GPT_GPTPRD40_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPRD4_ADDR(0), _GPT_GPTPRD4_##Field, Val)
#define _GPT_GPTPRD40_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD4_ADDR(0),AND,OR,INV)
#define _GPT_GPTPRD40_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD4_ADDR(0), _GPT_GPTPRD4_##Field,AND,OR,INV)

#define _GPT_GPTPRD41_GET		  _PREG_GET(_GPT_GPTPRD4_ADDR(1)) 
#define _GPT_GPTPRD41_SET(Val)		  _PREG_SET(_GPT_GPTPRD4_ADDR(1),Val)
#define _GPT_GPTPRD41_FGET(Field)	  _PFIELD_GET(_GPT_GPTPRD4_ADDR(1), _GPT_GPTPRD4_##Field)
#define _GPT_GPTPRD41_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTPRD4_ADDR(1), _GPT_GPTPRD4_##Field, Val)
#define _GPT_GPTPRD41_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTPRD4_ADDR(1),AND,OR,INV)
#define _GPT_GPTPRD41_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTPRD4_ADDR(1), _GPT_GPTPRD4_##Field,AND,OR,INV)


/*--------------------- Register: GPTGPINT -----------------------*/
#define _GPT_GPTGPINT_GET(devNum)		  _PREG_GET(_GPT_GPTGPINT_ADDR(devNum)) 
#define _GPT_GPTGPINT_SET(devNum,Val)		  _PREG_SET(_GPT_GPTGPINT_ADDR(devNum),Val)
#define _GPT_GPTGPINT_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTGPINT_ADDR(devNum), _GPT_GPTGPINT_##Field)
#define _GPT_GPTGPINT_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTGPINT_ADDR(devNum), _GPT_GPTGPINT_##Field, Val)
#define _GPT_GPTGPINT_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPINT_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTGPINT_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPINT_ADDR(devNum), _GPT_GPTGPINT_##Field,AND,OR,INV)

#define _GPT_GPTGPINT0_GET		  _PREG_GET(_GPT_GPTGPINT_ADDR(0)) 
#define _GPT_GPTGPINT0_SET(Val)		  _PREG_SET(_GPT_GPTGPINT_ADDR(0),Val)
#define _GPT_GPTGPINT0_FGET(Field)	  _PFIELD_GET(_GPT_GPTGPINT_ADDR(0), _GPT_GPTGPINT_##Field)
#define _GPT_GPTGPINT0_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTGPINT_ADDR(0), _GPT_GPTGPINT_##Field, Val)
#define _GPT_GPTGPINT0_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPINT_ADDR(0),AND,OR,INV)
#define _GPT_GPTGPINT0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPINT_ADDR(0), _GPT_GPTGPINT_##Field,AND,OR,INV)

#define _GPT_GPTGPINT1_GET		  _PREG_GET(_GPT_GPTGPINT_ADDR(1)) 
#define _GPT_GPTGPINT1_SET(Val)		  _PREG_SET(_GPT_GPTGPINT_ADDR(1),Val)
#define _GPT_GPTGPINT1_FGET(Field)	  _PFIELD_GET(_GPT_GPTGPINT_ADDR(1), _GPT_GPTGPINT_##Field)
#define _GPT_GPTGPINT1_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTGPINT_ADDR(1), _GPT_GPTGPINT_##Field, Val)
#define _GPT_GPTGPINT1_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPINT_ADDR(1),AND,OR,INV)
#define _GPT_GPTGPINT1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPINT_ADDR(1), _GPT_GPTGPINT_##Field,AND,OR,INV)


/*--------------------- Register: GPTGPEN -----------------------*/
#define _GPT_GPTGPEN_GET(devNum)		  _PREG_GET(_GPT_GPTGPEN_ADDR(devNum)) 
#define _GPT_GPTGPEN_SET(devNum,Val)		  _PREG_SET(_GPT_GPTGPEN_ADDR(devNum),Val)
#define _GPT_GPTGPEN_FGET(devNum,Field)	          _PFIELD_GET(_GPT_GPTGPEN_ADDR(devNum), _GPT_GPTGPEN_##Field)
#define _GPT_GPTGPEN_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTGPEN_ADDR(devNum), _GPT_GPTGPEN_##Field, Val)
#define _GPT_GPTGPEN_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPEN_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTGPEN_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPEN_ADDR(devNum), _GPT_GPTGPEN_##Field,AND,OR,INV)

#define _GPT_GPTGPEN0_GET		  _PREG_GET(_GPT_GPTGPEN_ADDR(0)) 
#define _GPT_GPTGPEN0_SET(Val)		  _PREG_SET(_GPT_GPTGPEN_ADDR(0),Val)
#define _GPT_GPTGPEN0_FGET(Field)	  _PFIELD_GET(_GPT_GPTGPEN_ADDR(0), _GPT_GPTGPEN_##Field)
#define _GPT_GPTGPEN0_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTGPEN_ADDR(0), _GPT_GPTGPEN_##Field, Val)
#define _GPT_GPTGPEN0_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPEN_ADDR(0),AND,OR,INV)
#define _GPT_GPTGPEN0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPEN_ADDR(0), _GPT_GPTGPEN_##Field,AND,OR,INV)

#define _GPT_GPTGPEN1_GET		  _PREG_GET(_GPT_GPTGPEN_ADDR(1)) 
#define _GPT_GPTGPEN1_SET(Val)		  _PREG_SET(_GPT_GPTGPEN_ADDR(1),Val)
#define _GPT_GPTGPEN1_FGET(Field)	  _PFIELD_GET(_GPT_GPTGPEN_ADDR(1), _GPT_GPTGPEN_##Field)
#define _GPT_GPTGPEN1_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTGPEN_ADDR(1), _GPT_GPTGPEN_##Field, Val)
#define _GPT_GPTGPEN1_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPEN_ADDR(1),AND,OR,INV)
#define _GPT_GPTGPEN1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPEN_ADDR(1), _GPT_GPTGPEN_##Field,AND,OR,INV)


/*--------------------- Register: GPTGPDIR -----------------------*/
#define _GPT_GPTGPDIR_GET(devNum)		  _PREG_GET(_GPT_GPTGPDIR_ADDR(devNum)) 
#define _GPT_GPTGPDIR_SET(devNum,Val)		  _PREG_SET(_GPT_GPTGPDIR_ADDR(devNum),Val)
#define _GPT_GPTGPDIR_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTGPDIR_ADDR(devNum), _GPT_GPTGPDIR_##Field)
#define _GPT_GPTGPDIR_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTGPDIR_ADDR(devNum), _GPT_GPTGPDIR_##Field, Val)
#define _GPT_GPTGPDIR_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPDIR_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTGPDIR_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPDIR_ADDR(devNum), _GPT_GPTGPDIR_##Field,AND,OR,INV)

#define _GPT_GPTGPDIR0_GET		  _PREG_GET(_GPT_GPTGPDIR_ADDR(0)) 
#define _GPT_GPTGPDIR0_SET(Val)		  _PREG_SET(_GPT_GPTGPDIR_ADDR(0),Val)
#define _GPT_GPTGPDIR0_FGET(Field)	  _PFIELD_GET(_GPT_GPTGPDIR_ADDR(0), _GPT_GPTGPDIR_##Field)
#define _GPT_GPTGPDIR0_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTGPDIR_ADDR(0), _GPT_GPTGPDIR_##Field, Val)
#define _GPT_GPTGPDIR0_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPDIR_ADDR(0),AND,OR,INV)
#define _GPT_GPTGPDIR0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPDIR_ADDR(0), _GPT_GPTGPDIR_##Field,AND,OR,INV)

#define _GPT_GPTGPDIR1_GET		  _PREG_GET(_GPT_GPTGPDIR_ADDR(1)) 
#define _GPT_GPTGPDIR1_SET(Val)		  _PREG_SET(_GPT_GPTGPDIR_ADDR(1),Val)
#define _GPT_GPTGPDIR1_FGET(Field)	  _PFIELD_GET(_GPT_GPTGPDIR_ADDR(1), _GPT_GPTGPDIR_##Field)
#define _GPT_GPTGPDIR1_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTGPDIR_ADDR(1), _GPT_GPTGPDIR_##Field, Val)
#define _GPT_GPTGPDIR1_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPDIR_ADDR(1),AND,OR,INV)
#define _GPT_GPTGPDIR1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPDIR_ADDR(1), _GPT_GPTGPDIR_##Field,AND,OR,INV)


/*--------------------- Register: GPTGPDAT -----------------------*/
#define _GPT_GPTGPDAT_GET(devNum)		  _PREG_GET(_GPT_GPTGPDAT_ADDR(devNum)) 
#define _GPT_GPTGPDAT_SET(devNum,Val)		  _PREG_SET(_GPT_GPTGPDAT_ADDR(devNum),Val)
#define _GPT_GPTGPDAT_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTGPDAT_ADDR(devNum), _GPT_GPTGPDAT_##Field)
#define _GPT_GPTGPDAT_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTGPDAT_ADDR(devNum), _GPT_GPTGPDAT_##Field, Val)
#define _GPT_GPTGPDAT_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPDAT_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTGPDAT_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPDAT_ADDR(devNum), _GPT_GPTGPDAT_##Field,AND,OR,INV)

#define _GPT_GPTGPDAT0_GET		  _PREG_GET(_GPT_GPTGPDAT_ADDR(0)) 
#define _GPT_GPTGPDAT0_SET(Val)		  _PREG_SET(_GPT_GPTGPDAT_ADDR(0),Val)
#define _GPT_GPTGPDAT0_FGET(Field)	  _PFIELD_GET(_GPT_GPTGPDAT_ADDR(0), _GPT_GPTGPDAT_##Field)
#define _GPT_GPTGPDAT0_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTGPDAT_ADDR(0), _GPT_GPTGPDAT_##Field, Val)
#define _GPT_GPTGPDAT0_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPDAT_ADDR(0),AND,OR,INV)
#define _GPT_GPTGPDAT0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPDAT_ADDR(0), _GPT_GPTGPDAT_##Field,AND,OR,INV)

#define _GPT_GPTGPDAT1_GET		  _PREG_GET(_GPT_GPTGPDAT_ADDR(1)) 
#define _GPT_GPTGPDAT1_SET(Val)		  _PREG_SET(_GPT_GPTGPDAT_ADDR(1),Val)
#define _GPT_GPTGPDAT1_FGET(Field)	  _PFIELD_GET(_GPT_GPTGPDAT_ADDR(1), _GPT_GPTGPDAT_##Field)
#define _GPT_GPTGPDAT1_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTGPDAT_ADDR(1), _GPT_GPTGPDAT_##Field, Val)
#define _GPT_GPTGPDAT1_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTGPDAT_ADDR(1),AND,OR,INV)
#define _GPT_GPTGPDAT1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGPDAT_ADDR(1), _GPT_GPTGPDAT_##Field,AND,OR,INV)


/*--------------------- Register: GPTCTL1 -----------------------*/
#define _GPT_GPTCTL1_GET(devNum)	    _PREG_GET(_GPT_GPTCTL1_ADDR(devNum)) 
#define _GPT_GPTCTL1_SET(devNum,Val)	    _PREG_SET(_GPT_GPTCTL1_ADDR(devNum),Val)
#define _GPT_GPTCTL1_FGET(devNum,Field)	    _PFIELD_GET(_GPT_GPTCTL1_ADDR(devNum), _GPT_GPTCTL1_##Field)
#define _GPT_GPTCTL1_FSET(devNum,Field,Val) _PFIELD_SET(_GPT_GPTCTL1_ADDR(devNum), _GPT_GPTCTL1_##Field, Val)
#define _GPT_GPTCTL1_AOI(devNum,AND,OR,INV) _PREG_AOI(_GPT_GPTCTL1_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTCTL1_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCTL1_ADDR(devNum), _GPT_GPTCTL1_##Field,AND,OR,INV)

#define _GPT_GPTCTL10_GET		  _PREG_GET(_GPT_GPTCTL1_ADDR(0)) 
#define _GPT_GPTCTL10_SET(Val)		  _PREG_SET(_GPT_GPTCTL1_ADDR(0),Val)
#define _GPT_GPTCTL10_FGET(Field)	  _PFIELD_GET(_GPT_GPTCTL1_ADDR(0), _GPT_GPTCTL1_##Field)
#define _GPT_GPTCTL10_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCTL1_ADDR(0), _GPT_GPTCTL1_##Field, Val)
#define _GPT_GPTCTL10_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCTL1_ADDR(0),AND,OR,INV)
#define _GPT_GPTCTL10_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCTL1_ADDR(0), _GPT_GPTCTL1_##Field,AND,OR,INV)

#define _GPT_GPTCTL11_GET		  _PREG_GET(_GPT_GPTCTL1_ADDR(1)) 
#define _GPT_GPTCTL11_SET(Val)		  _PREG_SET(_GPT_GPTCTL1_ADDR(1),Val)
#define _GPT_GPTCTL11_FGET(Field)	  _PFIELD_GET(_GPT_GPTCTL1_ADDR(1), _GPT_GPTCTL1_##Field)
#define _GPT_GPTCTL11_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCTL1_ADDR(1), _GPT_GPTCTL1_##Field, Val)
#define _GPT_GPTCTL11_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCTL1_ADDR(1),AND,OR,INV)
#define _GPT_GPTCTL11_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCTL1_ADDR(1), _GPT_GPTCTL1_##Field,AND,OR,INV)


/*--------------------- Register: GPTCTL2 -----------------------*/
#define _GPT_GPTCTL2_GET(devNum)	        _PREG_GET(_GPT_GPTCTL2_ADDR(devNum)) 
#define _GPT_GPTCTL2_SET(devNum,Val)	        _PREG_SET(_GPT_GPTCTL2_ADDR(devNum),Val)
#define _GPT_GPTCTL2_FGET(devNum,Field)	        _PFIELD_GET(_GPT_GPTCTL2_ADDR(devNum), _GPT_GPTCTL2_##Field)
#define _GPT_GPTCTL2_FSET(devNum,Field,Val)	_PFIELD_SET(_GPT_GPTCTL2_ADDR(devNum), _GPT_GPTCTL2_##Field, Val)
#define _GPT_GPTCTL2_AOI(devNum,AND,OR,INV)	_PREG_AOI(_GPT_GPTCTL2_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTCTL2_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCTL2_ADDR(devNum), _GPT_GPTCTL2_##Field,AND,OR,INV)

#define _GPT_GPTCTL20_GET		  _PREG_GET(_GPT_GPTCTL2_ADDR(0)) 
#define _GPT_GPTCTL20_SET(Val)		  _PREG_SET(_GPT_GPTCTL2_ADDR(0),Val)
#define _GPT_GPTCTL20_FGET(Field)	  _PFIELD_GET(_GPT_GPTCTL2_ADDR(0), _GPT_GPTCTL2_##Field)
#define _GPT_GPTCTL20_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCTL2_ADDR(0), _GPT_GPTCTL2_##Field, Val)
#define _GPT_GPTCTL20_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCTL2_ADDR(0),AND,OR,INV)
#define _GPT_GPTCTL20_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCTL2_ADDR(0), _GPT_GPTCTL2_##Field,AND,OR,INV)

#define _GPT_GPTCTL21_GET		  _PREG_GET(_GPT_GPTCTL2_ADDR(1)) 
#define _GPT_GPTCTL21_SET(Val)		  _PREG_SET(_GPT_GPTCTL2_ADDR(1),Val)
#define _GPT_GPTCTL21_FGET(Field)	  _PFIELD_GET(_GPT_GPTCTL2_ADDR(1), _GPT_GPTCTL2_##Field)
#define _GPT_GPTCTL21_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTCTL2_ADDR(1), _GPT_GPTCTL2_##Field, Val)
#define _GPT_GPTCTL21_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTCTL2_ADDR(1),AND,OR,INV)
#define _GPT_GPTCTL21_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTCTL2_ADDR(1), _GPT_GPTCTL2_##Field,AND,OR,INV)


/*--------------------- Register: GPTGCTL1 -----------------------*/
#define _GPT_GPTGCTL1_GET(devNum)		  _PREG_GET(_GPT_GPTGCTL1_ADDR(devNum)) 
#define _GPT_GPTGCTL1_SET(devNum,Val)		  _PREG_SET(_GPT_GPTGCTL1_ADDR(devNum),Val)
#define _GPT_GPTGCTL1_FGET(devNum,Field)	  _PFIELD_GET(_GPT_GPTGCTL1_ADDR(devNum), _GPT_GPTGCTL1_##Field)
#define _GPT_GPTGCTL1_FSET(devNum,Field,Val)	  _PFIELD_SET(_GPT_GPTGCTL1_ADDR(devNum), _GPT_GPTGCTL1_##Field, Val)
#define _GPT_GPTGCTL1_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_GPT_GPTGCTL1_ADDR(devNum),AND,OR,INV)
#define _GPT_GPTGCTL1_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGCTL1_ADDR(devNum),   _GPT_GPTGCTL1_##Field,AND,OR,INV)

#define _GPT_GPTGCTL10_GET		  _PREG_GET(_GPT_GPTGCTL1_ADDR(0)) 
#define _GPT_GPTGCTL10_SET(Val)		  _PREG_SET(_GPT_GPTGCTL1_ADDR(0),Val)
#define _GPT_GPTGCTL10_FGET(Field)	  _PFIELD_GET(_GPT_GPTGCTL1_ADDR(0), _GPT_GPTGCTL1_##Field)
#define _GPT_GPTGCTL10_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTGCTL1_ADDR(0), _GPT_GPTGCTL1_##Field, Val)
#define _GPT_GPTGCTL10_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTGCTL1_ADDR(0),AND,OR,INV)
#define _GPT_GPTGCTL10_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGCTL1_ADDR(0), _GPT_GPTGCTL1_##Field,AND,OR,INV)

#define _GPT_GPTGCTL11_GET		  _PREG_GET(_GPT_GPTGCTL1_ADDR(1)) 
#define _GPT_GPTGCTL11_SET(Val)		  _PREG_SET(_GPT_GPTGCTL1_ADDR(1),Val)
#define _GPT_GPTGCTL11_FGET(Field)	  _PFIELD_GET(_GPT_GPTGCTL1_ADDR(1), _GPT_GPTGCTL1_##Field)
#define _GPT_GPTGCTL11_FSET(Field,Val)	  _PFIELD_SET(_GPT_GPTGCTL1_ADDR(1), _GPT_GPTGCTL1_##Field, Val)
#define _GPT_GPTGCTL11_AOI(AND,OR,INV)	  _PREG_AOI(_GPT_GPTGCTL1_ADDR(1),AND,OR,INV)
#define _GPT_GPTGCTL11_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_GPT_GPTGCTL1_ADDR(1), _GPT_GPTGCTL1_##Field,AND,OR,INV)



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTGPINT register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTGPINT	 - GPIO interrupt control register
*
* Fields:
*       (RW)   _GPT_GPTGPINT_TIN1INT	  
*       (RW)   _GPT_GPTGPINT_TIN1INV	  

\******************************************************************************/


/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGPINT_TIN1INT:
\*----------------------------------------------------------------*/

#define _GPT_GPTGPINT_TIN1INT_SHIFT		(000000u)
#define _GPT_GPTGPINT_TIN1INT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTGPINT_TIN1INT_SHIFT)
#define _GPT_GPTGPINT_TIN1INT_MASK		(_GPT_GPTGPINT_TIN1INT_MK(0x0001u))
#define _GPT_GPTGPINT_TIN1INT_CLR		(~(_GPT_GPTGPINT_TIN1INT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGPINT_TIN1INV:
\*----------------------------------------------------------------*/

#define _GPT_GPTGPINT_TIN1INV_SHIFT		(000004u)
#define _GPT_GPTGPINT_TIN1INV_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTGPINT_TIN1INV_SHIFT)
#define _GPT_GPTGPINT_TIN1INV_MASK		(_GPT_GPTGPINT_TIN1INV_MK(0x0001u))
#define _GPT_GPTGPINT_TIN1INV_CLR		(~(_GPT_GPTGPINT_TIN1INV_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTGPEN register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTGPEN	 - GPIO enable register
*
* Fields:
*       (RW)   _GPT_GPTGPEN_TIN1EN
*       (RW)   _GPT_GPTGPEN_TOUT1EN

\******************************************************************************/

/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGPEN_TIN12EN:	
\*----------------------------------------------------------------*/

#define _GPT_GPTGPEN_TIN1EN_SHIFT		(000000u)
#define _GPT_GPTGPEN_TIN1EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTGPEN_TIN1EN_SHIFT)
#define _GPT_GPTGPEN_TIN1EN_MASK		(_GPT_GPTGPEN_TIN1EN_MK(0x0001u))
#define _GPT_GPTGPEN_TIN1EN_CLR		        (~(_GPT_GPTGPEN_TIN1EN_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGPEN_TOUT1EN:	
\*----------------------------------------------------------------*/

#define _GPT_GPTGPEN_TOUT1EN_SHIFT		(000001u)
#define _GPT_GPTGPEN_TOUT1EN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTGPEN_TOUT1EN_SHIFT)
#define _GPT_GPTGPEN_TOUT1EN_MASK		(_GPT_GPTGPEN_TOUT1EN_MK(0x0001u))
#define _GPT_GPTGPEN_TOUT1EN_CLR		(~(_GPT_GPTGPEN_TOUT1EN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTCLK register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTCLK	 - Timer clock speed register
*
* Fields:
*	(R)   _GPT_GPTCLK_CLKDIV
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _GPT_GPTCLK_CLKDIV:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCLK_CLKDIV_SHIFT		(000000u)
#define _GPT_GPTCLK_CLKDIV_MK(n)		(((Uint16)(n) & 0x000fu) << _GPT_GPTCLK_CLKDIV_SHIFT)
#define _GPT_GPTCLK_CLKDIV_MASK		        (_GPT_GPTCLK_CLKDIV_MK(0x000fu))
#define _GPT_GPTCLK_CLKDIV_CLR		        (~(_GPT_GPTCLK_CLKDIV_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTGCTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTGCTL1	 - Note: Add description here
*
* Fields:
*	(RW)   _GPT_GPTGCTL1_TIM12RS	
*	(RW)   _GPT_GPTGCTL1_TIM34RS	
*	(RW)   _GPT_GPTGCTL1_TIMMODE	
*	(RW)   _GPT_GPTGCTL1_PSC34	
*	(R)   _GPT_GPTGCTL1_TDDR34	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGCTL1_TIM12RS:	
\*----------------------------------------------------------------*/

#define _GPT_GPTGCTL1_TIM12RS_SHIFT		(000000u)
#define _GPT_GPTGCTL1_TIM12RS_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTGCTL1_TIM12RS_SHIFT)
#define _GPT_GPTGCTL1_TIM12RS_MASK		(_GPT_GPTGCTL1_TIM12RS_MK(0x0001u))
#define _GPT_GPTGCTL1_TIM12RS_CLR		(~(_GPT_GPTGCTL1_TIM12RS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGCTL1_TIM34RS:	
\*----------------------------------------------------------------*/

#define _GPT_GPTGCTL1_TIM34RS_SHIFT		(0x0001u)
#define _GPT_GPTGCTL1_TIM34RS_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTGCTL1_TIM34RS_SHIFT)
#define _GPT_GPTGCTL1_TIM34RS_MASK		(_GPT_GPTGCTL1_TIM34RS_MK(0x0001u))
#define _GPT_GPTGCTL1_TIM34RS_CLR		(~(_GPT_GPTGCTL1_TIM34RS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGCTL1_TIMMODE:	
\*----------------------------------------------------------------*/

#define _GPT_GPTGCTL1_TIMMODE_SHIFT		(0x0002u)
#define _GPT_GPTGCTL1_TIMMODE_MK(n)		(((Uint16)(n) & 0x0003u) << _GPT_GPTGCTL1_TIMMODE_SHIFT)
#define _GPT_GPTGCTL1_TIMMODE_MASK		(_GPT_GPTGCTL1_TIMMODE_MK(0x0003u))
#define _GPT_GPTGCTL1_TIMMODE_CLR		(~(_GPT_GPTGCTL1_TIMMODE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGCTL1_PSC34:	
\*----------------------------------------------------------------*/

#define _GPT_GPTGCTL1_PSC34_SHIFT		(0x0008u)
#define _GPT_GPTGCTL1_PSC34_MK(n)		(((Uint16)(n) & 0x000fu) << _GPT_GPTGCTL1_PSC34_SHIFT)
#define _GPT_GPTGCTL1_PSC34_MASK		(_GPT_GPTGCTL1_PSC34_MK(0x000fu))
#define _GPT_GPTGCTL1_PSC34_CLR		        (~(_GPT_GPTGCTL1_PSC34_MASK))



/*----------------------------------------------------------------*\
*   (R)  _GPT_GPTGCTL1_TDDR34:	
\*----------------------------------------------------------------*/

#define _GPT_GPTGCTL1_TDDR34_SHIFT		(0x000cu)
#define _GPT_GPTGCTL1_TDDR34_MK(n)		(((Uint16)(n) & 0x000fu) << _GPT_GPTGCTL1_TDDR34_SHIFT)
#define _GPT_GPTGCTL1_TDDR34_MASK		(_GPT_GPTGCTL1_TDDR34_MK(0x000fu))
#define _GPT_GPTGCTL1_TDDR34_CLR		(~(_GPT_GPTGCTL1_TDDR34_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTGPDIR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTGPDIR	 - GPIO direction register
*
* Fields:
*	(RW)   _GPT_GPTGPDIR_TIN1DIR
*	(RW)   _GPT_GPTGPDIR_TOUT1DIR	

\******************************************************************************/


/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGPDIR_TIN1DIR:	
\*----------------------------------------------------------------*/

#define _GPT_GPTGPDIR_TIN1DIR_SHIFT		(000000u)
#define _GPT_GPTGPDIR_TIN1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTGPDIR_TIN1DIR_SHIFT)
#define _GPT_GPTGPDIR_TIN1DIR_MASK		(_GPT_GPTGPDIR_TIN1DIR_MK(0x0001u))
#define _GPT_GPTGPDIR_TIN1DIR_CLR		(~(_GPT_GPTGPDIR_TIN1DIR_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGPDIR_TOUT1DIR:	
\*----------------------------------------------------------------*/

#define _GPT_GPTGPDIR_TOUT1DIR_SHIFT		(000001u)
#define _GPT_GPTGPDIR_TOUT1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTGPDIR_TOUT1DIR_SHIFT)
#define _GPT_GPTGPDIR_TOUT1DIR_MASK		(_GPT_GPTGPDIR_TOUT1DIR_MK(0x0001u))
#define _GPT_GPTGPDIR_TOUT1DIR_CLR		(~(_GPT_GPTGPDIR_TOUT1DIR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTCTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTCTL1	 - Timer control register 1
*
* Fields:
*	(R)   _GPT_GPTCTL1_TSTAT	
*	(RW)   _GPT_GPTCTL1_INVOUT	
*	(RW)   _GPT_GPTCTL1_INVIN	
*	(RW)   _GPT_GPTCTL1_CP	
*	(RW)   _GPT_GPTCTL1_PWID	
*	(RW)   _GPT_GPTCTL1_ENAMODE	
*	(RW)   _GPT_GPTCTL1_CLKSRC	
*	(RW)   _GPT_GPTCTL1_TIEN	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _GPT_GPTCTL1_TSTAT:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL1_TSTAT_SHIFT		(000000u)
#define _GPT_GPTCTL1_TSTAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL1_TSTAT_SHIFT)
#define _GPT_GPTCTL1_TSTAT_MASK		        (_GPT_GPTCTL1_TSTAT_MK(0x0001u))
#define _GPT_GPTCTL1_TSTAT_CLR		        (~(_GPT_GPTCTL1_TSTAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL1_INVOUT:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL1_INVOUT_SHIFT		(0x0001u)
#define _GPT_GPTCTL1_INVOUT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL1_INVOUT_SHIFT)
#define _GPT_GPTCTL1_INVOUT_MASK		(_GPT_GPTCTL1_INVOUT_MK(0x0001u))
#define _GPT_GPTCTL1_INVOUT_CLR		        (~(_GPT_GPTCTL1_INVOUT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL1_INVIN:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL1_INVIN_SHIFT		(0x0002u)
#define _GPT_GPTCTL1_INVIN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL1_INVIN_SHIFT)
#define _GPT_GPTCTL1_INVIN_MASK			(_GPT_GPTCTL1_INVIN_MK(0x0001u))
#define _GPT_GPTCTL1_INVIN_CLR			(~(_GPT_GPTCTL1_INVIN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL1_CP:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL1_CP_SHIFT			(0x0003u)
#define _GPT_GPTCTL1_CP_MK(n)			(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL1_CP_SHIFT)
#define _GPT_GPTCTL1_CP_MASK			(_GPT_GPTCTL1_CP_MK(0x0001u))
#define _GPT_GPTCTL1_CP_CLR			(~(_GPT_GPTCTL1_CP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL1_PWID:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL1_PWID_SHIFT			(0x0004u)
#define _GPT_GPTCTL1_PWID_MK(n)			(((Uint16)(n) & 0x0003u) << _GPT_GPTCTL1_PWID_SHIFT)
#define _GPT_GPTCTL1_PWID_MASK			(_GPT_GPTCTL1_PWID_MK(0x0003u))
#define _GPT_GPTCTL1_PWID_CLR			(~(_GPT_GPTCTL1_PWID_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL1_ENAMODE:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL1_ENAMODE_SHIFT		(0x0006u)
#define _GPT_GPTCTL1_ENAMODE_MK(n)		(((Uint16)(n) & 0x0003u) << _GPT_GPTCTL1_ENAMODE_SHIFT)
#define _GPT_GPTCTL1_ENAMODE_MASK		(_GPT_GPTCTL1_ENAMODE_MK(0x0003u))
#define _GPT_GPTCTL1_ENAMODE_CLR		(~(_GPT_GPTCTL1_ENAMODE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL1_CLKSRC:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL1_CLKSRC_SHIFT		(0x0008u)
#define _GPT_GPTCTL1_CLKSRC_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL1_CLKSRC_SHIFT)
#define _GPT_GPTCTL1_CLKSRC_MASK		(_GPT_GPTCTL1_CLKSRC_MK(0x0001u))
#define _GPT_GPTCTL1_CLKSRC_CLR 		(~(_GPT_GPTCTL1_CLKSRC_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL1_TIEN:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL1_TIEN_SHIFT			(0x0009u)
#define _GPT_GPTCTL1_TIEN_MK(n)			(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL1_TIEN_SHIFT)
#define _GPT_GPTCTL1_TIEN_MASK			(_GPT_GPTCTL1_TIEN_MK(0x0001u))
#define _GPT_GPTCTL1_TIEN_CLR			(~(_GPT_GPTCTL1_TIEN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTCTL2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTCTL2	 - Timer control register 2
*
* Fields:
*	(R)    _GPT_GPTCTL2_TSTAT	
*	(RW)   _GPT_GPTCTL2_INVOUT	
*	(RW)   _GPT_GPTCTL2_INVIN	
*	(RW)   _GPT_GPTCTL2_CP	
*	(RW)   _GPT_GPTCTL2_PWID	
*	(RW)   _GPT_GPTCTL2_ENAMODE	
*	(RW)   _GPT_GPTCTL2_CLKSRC	
*	(RW)   _GPT_GPTCTL2_TIEN	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _GPT_GPTCTL2_TSTAT:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL2_TSTAT_SHIFT		(000000u)
#define _GPT_GPTCTL2_TSTAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL2_TSTAT_SHIFT)
#define _GPT_GPTCTL2_TSTAT_MASK		        (_GPT_GPTCTL2_TSTAT_MK(0x0001u))
#define _GPT_GPTCTL2_TSTAT_CLR		        (~(_GPT_GPTCTL2_TSTAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL2_INVOUT:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL2_INVOUT_SHIFT		(0x0001u)
#define _GPT_GPTCTL2_INVOUT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL2_INVOUT_SHIFT)
#define _GPT_GPTCTL2_INVOUT_MASK		(_GPT_GPTCTL2_INVOUT_MK(0x0001u))
#define _GPT_GPTCTL2_INVOUT_CLR		        (~(_GPT_GPTCTL2_INVOUT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL2_INVIN:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL2_INVIN_SHIFT		(0x0002u)
#define _GPT_GPTCTL2_INVIN_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL2_INVIN_SHIFT)
#define _GPT_GPTCTL2_INVIN_MASK			(_GPT_GPTCTL2_INVIN_MK(0x0001u))
#define _GPT_GPTCTL2_INVIN_CLR			(~(_GPT_GPTCTL2_INVIN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL2_CP:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL2_CP_SHIFT			(0x0003u)
#define _GPT_GPTCTL2_CP_MK(n)			(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL2_CP_SHIFT)
#define _GPT_GPTCTL2_CP_MASK			(_GPT_GPTCTL2_CP_MK(0x0001u))
#define _GPT_GPTCTL2_CP_CLR			(~(_GPT_GPTCTL2_CP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL2_PWID:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL2_PWID_SHIFT			(0x0004u)
#define _GPT_GPTCTL2_PWID_MK(n)			(((Uint16)(n) & 0x0003u) << _GPT_GPTCTL2_PWID_SHIFT)
#define _GPT_GPTCTL2_PWID_MASK			(_GPT_GPTCTL2_PWID_MK(0x0003u))
#define _GPT_GPTCTL2_PWID_CLR			(~(_GPT_GPTCTL2_PWID_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL2_ENAMODE:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL2_ENAMODE_SHIFT		(0x0006u)
#define _GPT_GPTCTL2_ENAMODE_MK(n)		(((Uint16)(n) & 0x0003u) << _GPT_GPTCTL2_ENAMODE_SHIFT)
#define _GPT_GPTCTL2_ENAMODE_MASK		(_GPT_GPTCTL2_ENAMODE_MK(0x0003u))
#define _GPT_GPTCTL2_ENAMODE_CLR		(~(_GPT_GPTCTL2_ENAMODE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL2_CLKSRC:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL2_CLKSRC_SHIFT		(0x0008u)
#define _GPT_GPTCTL2_CLKSRC_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL2_CLKSRC_SHIFT)
#define _GPT_GPTCTL2_CLKSRC_MASK		(_GPT_GPTCTL2_CLKSRC_MK(0x0001u))
#define _GPT_GPTCTL2_CLKSRC_CLR 		(~(_GPT_GPTCTL2_CLKSRC_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCTL2_TIEN:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCTL2_TIEN_SHIFT			(0x0009u)
#define _GPT_GPTCTL2_TIEN_MK(n)			(((Uint16)(n) & 0x0001u) << _GPT_GPTCTL2_TIEN_SHIFT)
#define _GPT_GPTCTL2_TIEN_MASK			(_GPT_GPTCTL2_TIEN_MK(0x0001u))
#define _GPT_GPTCTL2_TIEN_CLR			(~(_GPT_GPTCTL2_TIEN_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTCNT1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTCNT1	 - Timer count register 1
*
* Fields:
*	(RW)   _GPT_GPTCNT1_CNT1	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCNT1_CNT1:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCNT1_CNT1_SHIFT		(000000u)
#define _GPT_GPTCNT1_CNT1_MK(n)		(((Uint16)(n) & 0xffffu) << _GPT_GPTCNT1_CNT1_SHIFT)
#define _GPT_GPTCNT1_CNT1_MASK		(_GPT_GPTCNT1_CNT1_MK(0xffffu))
#define _GPT_GPTCNT1_CNT1_CLR		(~(_GPT_GPTCNT1_CNT1_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTPRD1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTPRD1	 - Note: Add description here
*
* Fields:
*	(RW)   _GPT_GPTPRD1_PRD1	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTPRD1_PRD1:	
\*----------------------------------------------------------------*/

#define _GPT_GPTPRD1_PRD1_SHIFT		(000000u)
#define _GPT_GPTPRD1_PRD1_MK(n)		(((Uint16)(n) & 0xffffu) << _GPT_GPTPRD1_PRD1_SHIFT)
#define _GPT_GPTPRD1_PRD1_MASK		(_GPT_GPTPRD1_PRD1_MK(0xffffu))
#define _GPT_GPTPRD1_PRD1_CLR		(~(_GPT_GPTPRD1_PRD1_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTCNT2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTCNT2	 - Timer count register 2
*
* Fields:
*	(RW)   _GPT_GPTCNT2_CNT2	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCNT2_CNT2:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCNT2_CNT2_SHIFT		(000000u)
#define _GPT_GPTCNT2_CNT2_MK(n)		(((Uint16)(n) & 0xffffu) << _GPT_GPTCNT2_CNT2_SHIFT)
#define _GPT_GPTCNT2_CNT2_MASK		(_GPT_GPTCNT2_CNT2_MK(0xffffu))
#define _GPT_GPTCNT2_CNT2_CLR		(~(_GPT_GPTCNT2_CNT2_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTPRD2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTPRD2	 - Note: Add description here
*
* Fields:
*	(RW)   _GPT_GPTPRD2_PRD2	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTPRD2_PRD2:	
\*----------------------------------------------------------------*/

#define _GPT_GPTPRD2_PRD2_SHIFT		(000000u)
#define _GPT_GPTPRD2_PRD2_MK(n)		(((Uint16)(n) & 0xffffu) << _GPT_GPTPRD2_PRD2_SHIFT)
#define _GPT_GPTPRD2_PRD2_MASK		(_GPT_GPTPRD2_PRD2_MK(0xffffu))
#define _GPT_GPTPRD2_PRD2_CLR		(~(_GPT_GPTPRD2_PRD2_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTEMU register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTEMU	 - Emulation management register
*
* Fields:
*	(R)   _GPT_GPTEMU_FREE
        (R)   _GPT_GPTEMU_SOFT 	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _GPT_GPTEMU_FREE:	
\*----------------------------------------------------------------*/

#define _GPT_GPTEMU_FREE_SHIFT		(000000u)
#define _GPT_GPTEMU_FREE_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTEMU_FREE_SHIFT)
#define _GPT_GPTEMU_FREE_MASK		(_GPT_GPTEMU_FREE_MK(0x0001u))
#define _GPT_GPTEMU_FREE_CLR		(~(_GPT_GPTEMU_FREE_MASK))

/*----------------------------------------------------------------*\
*   (R)  _GPT_GPTEMU_SOFT:	
\*----------------------------------------------------------------*/

#define _GPT_GPTEMU_SOFT_SHIFT		(000001u)
#define _GPT_GPTEMU_SOFT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTEMU_SOFT_SHIFT)
#define _GPT_GPTEMU_SOFT_MASK		(_GPT_GPTEMU_SOFT_MK(0x0001u))
#define _GPT_GPTEMU_SOFT_CLR		(~(_GPT_GPTEMU_SOFT_MASK))





/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTCNT3 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTCNT3	 - Timer count register 3
*
* Fields:
*	(RW)   _GPT_GPTCNT3_CNT3	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTCNT3_CNT3:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCNT3_CNT3_SHIFT		(000000u)
#define _GPT_GPTCNT3_CNT3_MK(n)		(((Uint16)(n) & 0xffffu) << _GPT_GPTCNT3_CNT3_SHIFT)
#define _GPT_GPTCNT3_CNT3_MASK		(_GPT_GPTCNT3_CNT3_MK(0xffffu))
#define _GPT_GPTCNT3_CNT3_CLR		(~(_GPT_GPTCNT3_CNT3_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTPRD3 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTPRD3	 - Note: Add description here
*
* Fields:
*	(RW)   _GPT_GPTPRD3_PRD3	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTPRD3_PRD3:	
\*----------------------------------------------------------------*/

#define _GPT_GPTPRD3_PRD3_SHIFT		(000000u)
#define _GPT_GPTPRD3_PRD3_MK(n)		(((Uint16)(n) & 0xffffu) << _GPT_GPTPRD3_PRD3_SHIFT)
#define _GPT_GPTPRD3_PRD3_MASK		(_GPT_GPTPRD3_PRD3_MK(0xffffu))
#define _GPT_GPTPRD3_PRD3_CLR		(~(_GPT_GPTPRD3_PRD3_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTCNT4 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTCNT4	 - Timer count register 4
*
* Fields:
*	(R)   _GPT_GPTCNT4_CNT4	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _GPT_GPTCNT4_CNT4:	
\*----------------------------------------------------------------*/

#define _GPT_GPTCNT4_CNT4_SHIFT		(000000u)
#define _GPT_GPTCNT4_CNT4_MK(n)		(((Uint16)(n) & 0xffffu) << _GPT_GPTCNT4_CNT4_SHIFT)
#define _GPT_GPTCNT4_CNT4_MASK		(_GPT_GPTCNT4_CNT4_MK(0xffffu))
#define _GPT_GPTCNT4_CNT4_CLR		(~(_GPT_GPTCNT4_CNT4_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTPRD4 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTPRD4	 - Note: Add description here
*
* Fields:
*	(RW)   _GPT_GPTPRD4_PRD4	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTPRD4_PRD4:	
\*----------------------------------------------------------------*/

#define _GPT_GPTPRD4_PRD4_SHIFT		(000000u)
#define _GPT_GPTPRD4_PRD4_MK(n)		(((Uint16)(n) & 0xffffu) << _GPT_GPTPRD4_PRD4_SHIFT)
#define _GPT_GPTPRD4_PRD4_MASK		(_GPT_GPTPRD4_PRD4_MK(0xffffu))
#define _GPT_GPTPRD4_PRD4_CLR		(~(_GPT_GPTPRD4_PRD4_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTGPDAT register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTGPDAT	 - GPIO data register
*
* Fields:
*	(RW)   _GPT_GPTGPDAT_TIN1DAT	
*	(RW)   _GPT_GPTGPDAT_TOUT1DAT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGPDAT_TIN1DAT:	
\*----------------------------------------------------------------*/

#define _GPT_GPTGPDAT_TIN1DAT_SHIFT		(000000u)
#define _GPT_GPTGPDAT_TIN1DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTGPDAT_TIN1DAT_SHIFT)
#define _GPT_GPTGPDAT_TIN1DAT_MASK		(_GPT_GPTGPDAT_TIN1DAT_MK(0x0001u))
#define _GPT_GPTGPDAT_TIN1DAT_CLR		(~(_GPT_GPTGPDAT_TIN1DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _GPT_GPTGPDAT_TOUT1DAT:	
\*----------------------------------------------------------------*/

#define _GPT_GPTGPDAT_TOUT1DAT_SHIFT		(000001u)
#define _GPT_GPTGPDAT_TOUT1DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _GPT_GPTGPDAT_TOUT1DAT_SHIFT)
#define _GPT_GPTGPDAT_TOUT1DAT_MASK		(_GPT_GPTGPDAT_TOUT1DAT_MK(0x0001u))
#define _GPT_GPTGPDAT_TOUT1DAT_CLR		(~(_GPT_GPTGPDAT_TOUT1DAT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTPID1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTPID1	 - Note: Add description here
*
* Fields:
*	(R)   _GPT_GPTPID1_REVISION	
*	(R)   _GPT_GPTPID1_CLASS	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _GPT_GPTPID1_REVISION:	
\*----------------------------------------------------------------*/

#define _GPT_GPTPID1_REVISION_SHIFT		(000000u)
#define _GPT_GPTPID1_REVISION_MK(n)		(((Uint16)(n) & 0x00ffu) << _GPT_GPTPID1_REVISION_SHIFT)
#define _GPT_GPTPID1_REVISION_MASK		(_GPT_GPTPID1_REVISION_MK(0x00ffu))
#define _GPT_GPTPID1_REVISION_CLR		(~(_GPT_GPTPID1_REVISION_MASK))



/*----------------------------------------------------------------*\
*   (R)  _GPT_GPTPID1_CLASS:	
\*----------------------------------------------------------------*/

#define _GPT_GPTPID1_CLASS_SHIFT		(0x0008u)
#define _GPT_GPTPID1_CLASS_MK(n)		(((Uint16)(n) & 0x00ffu) << _GPT_GPTPID1_CLASS_SHIFT)
#define _GPT_GPTPID1_CLASS_MASK		(_GPT_GPTPID1_CLASS_MK(0x00ffu))
#define _GPT_GPTPID1_CLASS_CLR		(~(_GPT_GPTPID1_CLASS_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the GPTPID2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _GPT_GPTPID2	 - Note: Add description here
*
* Fields:
*	(R)   _GPT_GPTPID2_TYPE	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _GPT_GPTPID2_TYPE:	
\*----------------------------------------------------------------*/

#define _GPT_GPTPID2_TYPE_SHIFT		(000000u)
#define _GPT_GPTPID2_TYPE_MK(n)		(((Uint16)(n) & 0x007fu) << _GPT_GPTPID2_TYPE_SHIFT)
#define _GPT_GPTPID2_TYPE_MASK		(_GPT_GPTPID2_TYPE_MK(0x007fu))
#define _GPT_GPTPID2_TYPE_CLR		(~(_GPT_GPTPID2_TYPE_MASK))


#else
    #ifndef _GPT_MOD_
	  #error GPT Hal Module Not Supported on Specified Target
    #endif
#endif  /* _GPT_SUPPORT  */

#endif  /* _CSL_GPTHAL_H  */

/******************************************************************************\
*     
*      End of csl_gpthal.h 
*
\******************************************************************************/

csl_hpi.h/      1051540738  0     0     0       18427     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... HPI
* FILENAME...... csl_hpi.h
* DATE CREATED.. Fri Mar 22 11:46:12 2002
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Fri Mar 22 11:46:12 2002 (Automatic generation)
*	 Last Modified:	3 April 2003 canged names to match datasheet sprs166c
*                       revised Feb 2003 and spru620A
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the HPI module 
*
\*************************************************************************/

#ifndef _CSL_HPI_H_
#define _CSL_HPI_H_


#include <csl_std.h>
#include <csl.h>
#include <csl_chiphal.h>

#if (_HPI_SUPPORT) 

#include <csl_hpihal.h>
#include <csl_hpidat.h>
/*----------------------------------------------------------------*\
*	 HPI scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _HPI_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/****************************************\
* HPI global macro declarations
\****************************************/

/* error codes */
#define HPI_ERR_MAJOR		   (ERR_BASE_HPI) 
#define HPI_ERR_ALLOC		   (0x00000000) 
#define HPI_ERR_INVALID_HANDLE  (0x00000001) 

/* ============================================================== */
 /* Make HGPIODAT register values based on symbolic constants  */

/*  HGPIODAT field values  */

	#define HPI_HGPIODAT_HD15_HIGH		(0x0001u)
	#define HPI_HGPIODAT_HD15_LOW			(000000u)
	#define HPI_HGPIODAT_HD15_DEFAULT		HPI_HGPIODAT_HD15_LOW

	#define HPI_HGPIODAT_HD14_HIGH		(0x0001u)
	#define HPI_HGPIODAT_HD14_LOW			(000000u)
	#define HPI_HGPIODAT_HD14_DEFAULT		HPI_HGPIODAT_HD14_LOW

	#define HPI_HGPIODAT_HD13_HIGH		(0x0001u)
	#define HPI_HGPIODAT_HD13_LOW			(000000u)
	#define HPI_HGPIODAT_HD13_DEFAULT		HPI_HGPIODAT_HD13_LOW

	#define HPI_HGPIODAT_HD12_HIGH		(0x0001u)
	#define HPI_HGPIODAT_HD12_LOW			(000000u)
	#define HPI_HGPIODAT_HD12_DEFAULT		HPI_HGPIODAT_HD12_LOW

	#define HPI_HGPIODAT_HD11_HIGH		(0x0001u)
	#define HPI_HGPIODAT_HD11_LOW			(000000u)
	#define HPI_HGPIODAT_HD11_DEFAULT		HPI_HGPIODAT_HD11_LOW

	#define HPI_HGPIODAT_HD10_HIGH		(0x0001u)
	#define HPI_HGPIODAT_HD10_LOW			(000000u)
	#define HPI_HGPIODAT_HD10_DEFAULT		HPI_HGPIODAT_HD10_LOW

	#define HPI_HGPIODAT_HD9_HIGH			(0x0001u)
	#define HPI_HGPIODAT_HD9_LOW			(000000u)
	#define HPI_HGPIODAT_HD9_DEFAULT		HPI_HGPIODAT_HD9_LOW

	#define HPI_HGPIODAT_HD8_HIGH			(0x0001u)
	#define HPI_HGPIODAT_HD8_LOW			(000000u)
	#define HPI_HGPIODAT_HD8_DEFAULT		HPI_HGPIODAT_HD8_LOW

	#define HPI_HGPIODAT_HD7_HIGH			(0x0001u)
	#define HPI_HGPIODAT_HD7_LOW			(000000u)
	#define HPI_HGPIODAT_HD7_DEFAULT		HPI_HGPIODAT_HD7_LOW

	#define HPI_HGPIODAT_HD6_HIGH			(0x0001u)
	#define HPI_HGPIODAT_HD6_LOW			(000000u)
	#define HPI_HGPIODAT_HD6_DEFAULT		HPI_HGPIODAT_HD6_LOW

	#define HPI_HGPIODAT_HD5_HIGH			(0x0001u)
	#define HPI_HGPIODAT_HD5_LOW			(000000u)
	#define HPI_HGPIODAT_HD5_DEFAULT		HPI_HGPIODAT_HD5_LOW

	#define HPI_HGPIODAT_HD4_HIGH			(0x0001u)
	#define HPI_HGPIODAT_HD4_LOW			(000000u)
	#define HPI_HGPIODAT_HD4_DEFAULT		HPI_HGPIODAT_HD4_LOW

	#define HPI_HGPIODAT_HD3_HIGH			(0x0001u)
	#define HPI_HGPIODAT_HD3_LOW			(000000u)
	#define HPI_HGPIODAT_HD3_DEFAULT		HPI_HGPIODAT_HD3_LOW

	#define HPI_HGPIODAT_HD2_HIGH			(0x0001u)
	#define HPI_HGPIODAT_HD2_LOW			(000000u)
	#define HPI_HGPIODAT_HD2_DEFAULT		HPI_HGPIODAT_HD2_LOW

	#define HPI_HGPIODAT_HD1_HIGH			(0x0001u)
	#define HPI_HGPIODAT_HD1_LOW			(000000u)
	#define HPI_HGPIODAT_HD1_DEFAULT		HPI_HGPIODAT_HD1_LOW

	#define HPI_HGPIODAT_HD0_HIGH			(0x0001u)
	#define HPI_HGPIODAT_HD0_LOW			(000000u)
	#define HPI_HGPIODAT_HD0_DEFAULT		HPI_HGPIODAT_HD0_LOW


#define HPI_HGPIODAT_RMK(hd7,hd6,hd5,hd4,hd3,hd2,hd1,hd0)\
 ((Uint16) ( \
  ( HPI_FMK(HGPIODAT,HD15,hd15))|\
  ( HPI_FMK(HGPIODAT,HD14,hd14))|\
  ( HPI_FMK(HGPIODAT,HD13,hd13))|\
  ( HPI_FMK(HGPIODAT,HD12,hd12))|\
  ( HPI_FMK(HGPIODAT,HD11,hd11))|\
  ( HPI_FMK(HGPIODAT,HD10,hd10))|\
  ( HPI_FMK(HGPIODAT,HD9,hd9))|\
  ( HPI_FMK(HGPIODAT,HD8,hd8))|\
  ( HPI_FMK(HGPIODAT,HD7,hd7))|\
  ( HPI_FMK(HGPIODAT,HD6,hd6))|\
  ( HPI_FMK(HGPIODAT,HD5,hd5))|\
  ( HPI_FMK(HGPIODAT,HD4,hd4))|\
  ( HPI_FMK(HGPIODAT,HD3,hd3))|\
  ( HPI_FMK(HGPIODAT,HD2,hd2))|\
  ( HPI_FMK(HGPIODAT,HD1,hd1))|\
  ( HPI_FMK(HGPIODAT,HD0,hd0))\
)\
 )

#define HPI_HGPIODAT_RMKS(hd15_sym,hd14_sym,hd13_sym,hd12_sym,hd11_sym,\
                          hd10_sym,hd9_sym,hd8_sym,hd7_sym,hd6_sym,hd5_sym,\
                          hd4_sym,hd3_sym,hd2_sym,hd1_sym,hd0_sym)\
 ((Uint16) ( \
  ( HPI_FMKS(HGPIODAT,HD15,hd15_sym))|\
  ( HPI_FMKS(HGPIODAT,HD14,hd14_sym))|\
  ( HPI_FMKS(HGPIODAT,HD13,hd13_sym))|\
  ( HPI_FMKS(HGPIODAT,HD12,hd12_sym))|\
  ( HPI_FMKS(HGPIODAT,HD11,hd11_sym))|\
  ( HPI_FMKS(HGPIODAT,HD10,hd10_sym))|\
  ( HPI_FMKS(HGPIODAT,HD9,hd9_sym))|\
  ( HPI_FMKS(HGPIODAT,HD8,hd8_sym))|\
  ( HPI_FMKS(HGPIODAT,HD7,hd7_sym))|\
  ( HPI_FMKS(HGPIODAT,HD6,hd6_sym))|\
  ( HPI_FMKS(HGPIODAT,HD5,hd5_sym))|\
  ( HPI_FMKS(HGPIODAT,HD4,hd4_sym))|\
  ( HPI_FMKS(HGPIODAT,HD3,hd3_sym))|\
  ( HPI_FMKS(HGPIODAT,HD2,hd2_sym))|\
  ( HPI_FMKS(HGPIODAT,HD1,hd1_sym))|\
  ( HPI_FMKS(HGPIODAT,HD0,hd0_sym))\
)\
 )

/*  Default HGPIODAT register value  */

/* ============================================================== */
 /* Make HGPIODIR register values based on symbolic constants  */

/*  HGPIODIR field values  */
	#define HPI_HGPIODIR_HD15_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD15_INPUT			(000000u)
	#define HPI_HGPIODIR_HD15_DEFAULT		HPI_HGPIODIR_HD15_INPUT

	#define HPI_HGPIODIR_HD14_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD14_INPUT			(000000u)
	#define HPI_HGPIODIR_HD14_DEFAULT		HPI_HGPIODIR_HD14_INPUT

	#define HPI_HGPIODIR_HD13_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD13_INPUT			(000000u)
	#define HPI_HGPIODIR_HD13_DEFAULT		HPI_HGPIODIR_HD13_INPUT

	#define HPI_HGPIODIR_HD12_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD12_INPUT			(000000u)
	#define HPI_HGPIODIR_HD12_DEFAULT		HPI_HGPIODIR_HD12_INPUT

	#define HPI_HGPIODIR_HD11_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD11_INPUT			(000000u)
	#define HPI_HGPIODIR_HD11_DEFAULT		HPI_HGPIODIR_HD11_INPUT

	#define HPI_HGPIODIR_HD10_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD10_INPUT			(000000u)
	#define HPI_HGPIODIR_HD10_DEFAULT		HPI_HGPIODIR_HD10_INPUT

	#define HPI_HGPIODIR_HD9_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD9_INPUT			(000000u)
	#define HPI_HGPIODIR_HD9_DEFAULT		HPI_HGPIODIR_HD9_INPUT

	#define HPI_HGPIODIR_HD8_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD8_INPUT			(000000u)
	#define HPI_HGPIODIR_HD8_DEFAULT		HPI_HGPIODIR_HD8_INPUT

	#define HPI_HGPIODIR_HD7_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD7_INPUT			(000000u)
	#define HPI_HGPIODIR_HD7_DEFAULT		HPI_HGPIODIR_HD7_INPUT

	#define HPI_HGPIODIR_HD6_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD6_INPUT			(000000u)
	#define HPI_HGPIODIR_HD6_DEFAULT		HPI_HGPIODIR_HD6_INPUT

	#define HPI_HGPIODIR_HD5_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD5_INPUT			(000000u)
	#define HPI_HGPIODIR_HD5_DEFAULT		HPI_HGPIODIR_HD5_INPUT

	#define HPI_HGPIODIR_HD4_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD4_INPUT			(000000u)
	#define HPI_HGPIODIR_HD4_DEFAULT		HPI_HGPIODIR_HD4_INPUT

	#define HPI_HGPIODIR_HD3_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD3_INPUT			(000000u)
	#define HPI_HGPIODIR_HD3_DEFAULT		HPI_HGPIODIR_HD3_INPUT

	#define HPI_HGPIODIR_HD2_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD2_INPUT			(000000u)
	#define HPI_HGPIODIR_HD2_DEFAULT		HPI_HGPIODIR_HD2_INPUT

	#define HPI_HGPIODIR_HD1_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD1_INPUT			(000000u)
	#define HPI_HGPIODIR_HD1_DEFAULT		HPI_HGPIODIR_HD1_INPUT

	#define HPI_HGPIODIR_HD0_OUPUT			(0x0001u)
	#define HPI_HGPIODIR_HD0_INPUT			(000000u)
	#define HPI_HGPIODIR_HD0_DEFAULT		HPI_HGPIODIR_HD0_INPUT


#define HPI_HGPIODIR_RMK(hd15,hd14,hd13,hd12,hd11,hd10,hd9,hd8,\
                         hd7,hd6,hd5,hd4,hd3,hd2,hd1,hd0)\
 ((Uint16) ( \
  ( HPI_FMK(HGPIODIR,HD15,hd15))|\
  ( HPI_FMK(HGPIODIR,HD14,hd14))|\
  ( HPI_FMK(HGPIODIR,HD13,hd13))|\
  ( HPI_FMK(HGPIODIR,HD12,hd12))|\
  ( HPI_FMK(HGPIODIR,HD11,hd11))|\
  ( HPI_FMK(HGPIODIR,HD10,hd10))|\
  ( HPI_FMK(HGPIODIR,HD9,hd9))|\
  ( HPI_FMK(HGPIODIR,HD8,hd8))|\
  ( HPI_FMK(HGPIODIR,HD7,hd7))|\
  ( HPI_FMK(HGPIODIR,HD6,hd6))|\
  ( HPI_FMK(HGPIODIR,HD5,hd5))|\
  ( HPI_FMK(HGPIODIR,HD4,hd4))|\
  ( HPI_FMK(HGPIODIR,HD3,hd3))|\
  ( HPI_FMK(HGPIODIR,HD2,hd2))|\
  ( HPI_FMK(HGPIODIR,HD1,hd1))|\
  ( HPI_FMK(HGPIODIR,HD0,hd0))\
)\
 )

#define HPI_HGPIODIR_RMKS(hd15_sym,hd14_sym,hd13_sym,hd12_sym,hd11_sym,hd10_sym,\
                          hd9_sym,hd8_sym,hd7_sym,hd6_sym,hd5_sym,hd4_sym,hd3_sym,\
                          hd2_sym,hd1_sym,hd0_sym)\
 ((Uint16) ( \
  ( HPI_FMKS(HGPIODIR,HD15,hd15_sym))|\
  ( HPI_FMKS(HGPIODIR,HD14,hd14_sym))|\
  ( HPI_FMKS(HGPIODIR,HD13,hd13_sym))|\
  ( HPI_FMKS(HGPIODIR,HD12,hd12_sym))|\
  ( HPI_FMKS(HGPIODIR,HD11,hd11_sym))|\
  ( HPI_FMKS(HGPIODIR,HD10,hd10_sym))|\
  ( HPI_FMKS(HGPIODIR,HD9,hd9_sym))|\
  ( HPI_FMKS(HGPIODIR,HD8,hd8_sym))|\
  ( HPI_FMKS(HGPIODIR,HD7,hd7_sym))|\
  ( HPI_FMKS(HGPIODIR,HD6,hd6_sym))|\
  ( HPI_FMKS(HGPIODIR,HD5,hd5_sym))|\
  ( HPI_FMKS(HGPIODIR,HD4,hd4_sym))|\
  ( HPI_FMKS(HGPIODIR,HD3,hd3_sym))|\
  ( HPI_FMKS(HGPIODIR,HD2,hd2_sym))|\
  ( HPI_FMKS(HGPIODIR,HD1,hd1_sym))|\
  ( HPI_FMKS(HGPIODIR,HD0,hd0_sym))\
)\
 )

/*  Default HGPIODIR register value  */

/* ============================================================== */
 /* Make HGPIOEN register values based on symbolic constants  */

/*  HGPIOEN field values  */
	#define HPI_HGPIOEN_EN12_ENABLE			(0x0001u)
	#define HPI_HGPIOEN_EN12_DISABLE			(000000u)
	#define HPI_HGPIOEN_EN12_DEFAULT		HPI_HGPIOEN_EN12_DISABLE

	#define HPI_HGPIOEN_EN11_ENABLE			(0x0001u)
	#define HPI_HGPIOEN_EN11_DISABLE			(000000u)
	#define HPI_HGPIOEN_EN11_DEFAULT		HPI_HGPIOEN_EN11_DISABLE

	#define HPI_HGPIOEN_EN8_ENABLE			(0x0001u)
	#define HPI_HGPIOEN_EN8_DISABLE			(000000u)
	#define HPI_HGPIOEN_EN8_DEFAULT		HPI_HGPIOEN_EN8_DISABLE

	#define HPI_HGPIOEN_EN7_ENABLE			(0x0001u)
	#define HPI_HGPIOEN_EN7_DISABLE			(000000u)
	#define HPI_HGPIOEN_EN7_DEFAULT		HPI_HGPIOEN_EN7_DISABLE

	#define HPI_HGPIOEN_EN6_ENABLE			(0x0001u)
	#define HPI_HGPIOEN_EN6_DISABLE			(000000u)
	#define HPI_HGPIOEN_EN6_DEFAULT		HPI_HGPIOEN_EN6_DISABLE

	#define HPI_HGPIOEN_EN4_ENABLE			(0x0001u)
	#define HPI_HGPIOEN_EN4_DISABLE			(000000u)
	#define HPI_HGPIOEN_EN4_DEFAULT		HPI_HGPIOEN_EN4_DISABLE

	#define HPI_HGPIOEN_EN2_ENABLE			(0x0001u)
	#define HPI_HGPIOEN_EN2_DISABLE			(000000u)
	#define HPI_HGPIOEN_EN2_DEFAULT		HPI_HGPIOEN_EN2_DISABLE

	#define HPI_HGPIOEN_EN1_ENABLE			(0x0001u)
	#define HPI_HGPIOEN_EN1_DISABLE			(000000u)
	#define HPI_HGPIOEN_EN1_DEFAULT		HPI_HGPIOEN_EN1_DISABLE

	#define HPI_HGPIOEN_EN0_ENABLE			(0x0001u)
	#define HPI_HGPIOEN_EN0_DISABLE			(000000u)
	#define HPI_HGPIOEN_EN0_DEFAULT		HPI_HGPIOEN_EN0_DISABLE


#define HPI_HGPIOEN_RMK(en12,en11,en8,en7,en6,en4,en2,en1,en0)\
 ((Uint16) ( \
  ( HPI_FMK(HGPIOEN,EN12,en12))|\
  ( HPI_FMK(HGPIOEN,EN11,en11))|\
  ( HPI_FMK(HGPIOEN,EN8,en8))|\
  ( HPI_FMK(HGPIOEN,EN7,en7))|\
  ( HPI_FMK(HGPIOEN,EN6,en6))|\
  ( HPI_FMK(HGPIOEN,EN4,en4))|\
  ( HPI_FMK(HGPIOEN,EN2,en2))|\
  ( HPI_FMK(HGPIOEN,EN1,en1))|\
  ( HPI_FMK(HGPIOEN,EN0,en0))\
)\
 )

#define HPI_HGPIOEN_RMKS(en12_sym,en11_sym,en8_sym,en7_sym,\
                         en6_sym,en4_sym,en2_sym,en1_sym,en0_sym)\
 ((Uint16) ( \
  ( HPI_FMKS(HGPIOEN,EN12,en12_sym))|\
  ( HPI_FMKS(HGPIOEN,EN11,en11_sym))|\
  ( HPI_FMKS(HGPIOEN,EN8,en8_sym))|\
  ( HPI_FMKS(HGPIOEN,EN7,en7_sym))|\
  ( HPI_FMKS(HGPIOEN,EN6,en6_sym))|\
  ( HPI_FMKS(HGPIOEN,EN4,en4_sym))|\
  ( HPI_FMKS(HGPIOEN,EN2,en2_sym))|\
  ( HPI_FMKS(HGPIOEN,EN1,en1_sym))|\
  ( HPI_FMKS(HGPIOEN,EN0,en0_sym))\
)\
 )

/*  Default HGPIOEN register value  */

/* ============================================================== */
 /* Make HPIAR register values based on symbolic constants  */

/*  HPIAR field values  */

	#define HPI_HPIAR_HPIAR_OF(x)			((Uint16)(x))
      #define HPI_HPIAR_HPIAR_DEFAULT                (0x0000u)

#define HPI_HPIAR_RMK(hpiar)\
 ((Uint16) ( \
  ( HPI_FMK(HPIAR,HPIAR,hpiar))\
)\
 )

#define HPI_HPIAR_RMKS(hpiar_sym)\
 ((Uint16) ( \
  ( HPI_FMKS(HPIAR,HPIAR,hpiar_sym))\
)\
 )

/*  Default HPIAR register value  */

/* ============================================================== */
 /* Make HPIAW register values based on symbolic constants  */

/*  HPIAW field values  */

	#define HPI_HPIAW_HPIAW_OF(x)			((Uint16)(x))
      #define HPI_HPIAW_HPIAW_DEFAULT                (0x0000u)

#define HPI_HPIAW_RMK(hpiaw)\
 ((Uint16) ( \
  ( HPI_FMK(HPIAW,HPIAW,hpiaw))\
)\
 )

#define HPI_HPIAW_RMKS(hpiaw_sym)\
 ((Uint16) ( \
  ( HPI_FMKS(HPIAW,HPIAW,hpiaw_sym))\
)\
 )

/*  Default HPIAW register value  */

/* ============================================================== */
 /* Make HPIC register values based on symbolic constants  */

/*  HPIC field values  */

	#define HPI_HPIC_HPIASEL_READ_ADDRESS			(0x0001u)
	#define HPI_HPIC_HPIASEL_WRITE_ADDRESS			(000000u)
	#define HPI_HPIC_HPIASEL_DEFAULT		HPI_HPIC_HPIASEL_WRITE_ADDRESS


	#define HPI_HPIC_DUALHPIA_ON			(0x0001u)
	#define HPI_HPIC_DUALHPIA_OFF			(000000u)
	#define HPI_HPIC_DUALHPIA_DEFAULT		HPI_HPIC_DUALHPIA_OFF

	#define HPI_HPIC_BOBSTAT_LEAST_SIGNIFICANT			(0x0001u)
	#define HPI_HPIC_BOBSTAT_MOST_SIGNIFICANT			(000000u)
	#define HPI_HPIC_BOBSTAT_DEFAULT		HPI_HPIC_BOBSTAT_MOST_SIGNIFICANT

	#define HPI_HPIC_HPIRST_FIFO_RESET			(0x0001u)
	#define HPI_HPIC_HPIRST_FIFO_NOT_RESET			(000000u)

	#define HPI_HPIC_FETCH_ON			(0x0001u)
	#define HPI_HPIC_FETCH_OFF			(000000u)
	#define HPI_HPIC_FETCH_DEFAULT		HPI_HPIC_FETCH_OFF

	#define HPI_HPIC_HRDY_ON			(0x0001u)
	#define HPI_HPIC_HRDY_OFF			(000000u)
	#define HPI_HPIC_HRDY_DEFAULT		HPI_HPIC_HRDY_OFF

	#define HPI_HPIC_HINT_ON			(0x0001u)
	#define HPI_HPIC_HINT_OFF			(000000u)
	#define HPI_HPIC_HINT_DEFAULT		HPI_HPIC_HINT_OFF

	#define HPI_HPIC_DSPINT_ON			(0x0001u)
	#define HPI_HPIC_DSPINT_OFF			(000000u)
	#define HPI_HPIC_DSPINT_DEFAULT		HPI_HPIC_DSPINT_OFF

	#define HPI_HPIC_BOB_LEAST_SIGNIFICANT_FIRST			(0x0001u)
	#define HPI_HPIC_BOB_MOST_SIGNIFICANT_FIRST			(000000u)
	#define HPI_HPIC_BOB_DEFAULT		HPI_HPIC_BOB_MOST_SIGNIFICANT_FIRST


#define HPI_HPIC_RMK(hpiasel,dualhpia,bobstat,hpirst,hint,bob)\
 ((Uint16) ( \
  ( HPI_FMK(HPIC,HPIASEL,hpiasel))|\
  ( HPI_FMK(HPIC,DUALHPIA,dualhpia))|\
  ( HPI_FMK(HPIC,BOBSTAT,bobstat))|\
  ( HPI_FMK(HPIC,HPIRST,hpirst))|\
  ( HPI_FMK(HPIC,HINT,hint))|\
  ( HPI_FMK(HPIC,BOB,bob))\
)\
 )

#define HPI_HPIC_RMKS(hpiasel_sym,dualhpia_sym,bobstat_sym,hpirst_sym,hint_sym,bob_sym)\
 ((Uint16) ( \
  ( HPI_FMKS(HPIC,HPIASEL,hpiasel_sym))|\
  ( HPI_FMKS(HPIC,DUALHPIA,dualhpia_sym))|\
  ( HPI_FMKS(HPIC,BOBSTAT,bobstat_sym))|\
  ( HPI_FMKS(HPIC,HPIRST,hpirst_sym))|\
  ( HPI_FMKS(HPIC,HINT,hint_sym))|\
  ( HPI_FMKS(HPIC,BOB,bob_sym))\
)\
 )

/*  Default HPIC register value  */

/* ============================================================== */
 /* Make PIDLSW register values based on symbolic constants  */

/*  PIDLSW field values  */


/*  Default PIDLSW register value  */

/* ============================================================== */
 /* Make PIDMSW register values based on symbolic constants  */

/*  PIDMSW field values  */
/*  Default PIDMSW register value  */

/* ============================================================== */
 /* Make PWREMU register values based on symbolic constants  */

/*  PWREMU field values  */

	#define HPI_HPWREMU_SOFT_OFF			(000000u)
	#define HPI_HPWREMU_SOFT_ON			(0x0001u)
	#define HPI_HPWREMU_SOFT_DEFAULT		HPI_HPWREMU_SOFT_OFF

	#define HPI_HPWREMU_FREE_ON			(0x0001u)
	#define HPI_HPWREMU_FREE_OFF			(000000u)
	#define HPI_HPWREMU_FREE_DEFAULT		HPI_HPWREMU_FREE_OFF


#define HPI_HPWREMU_RMK(soft,free)\
 ((Uint16) ( \
  ( HPI_FMK(PWREMU,SOFT,soft))|\
  ( HPI_FMK(PWREMU,FREE,free))\
)\
 )

#define HPI_HPWREMU_RMKS(soft_sym,free_sym)\
 ((Uint16) ( \
  ( HPI_FMKS(PWREMU,SOFT,soft_sym))|\
  ( HPI_FMKS(PWREMU,FREE,free_sym))\
)\
 )

/*  Default PWREMU register value  */

/*************************************************\
 HPI global typedef declarations 
\*************************************************/

typedef struct {
	Uint16 hpwremu;
	Uint16 hgpioen;
	Uint16 hgpiodir;
	Uint16 hpic;
} HPI_Config;

/*************************************************\
* HPI global variable declarations
\*************************************************/


/*************************************************\
* HPI global function declarations
\*************************************************/

CSLAPI void HPI_config(HPI_Config *myConfig);
CSLAPI void HPI_getConfig(HPI_Config *myConfig);

/*************************************************\
* HPI inline function declarations
\*************************************************/


#ifdef USEDEFS


#endif /*USEDEFS */

#else
    #ifndef _HPI_MOD_
	  #error HPI Hal Module Not Supported on Specified Target
    #endif
#endif  /* _HPI_SUPPORT  */

#endif  /* _CSL_HPIHAL_H  */

/******************************************************************************\
*     
*      End of csl_hpi.h 
*
\******************************************************************************/

csl_hpidat.h/   1051540736  0     0     0       2256      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... HPI
* FILENAME...... csl_hpidat.h
* DATE CREATED.. Thu Mar 21 09:27:17 2002
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu Mar 21 09:27:17 2002 (Automatic generation)
*	 Last Modified:	3 Apr 2003 changed module names to fit datasheet sprs166c
*                                  revised Feb 2003
*                   10 April 2003 added reference for CSL_UhpiData
*                                     for .csldata size fix               
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the HPI module 
*
\*************************************************************************/

#ifndef _CSL_HPIDAT_H_
#define _CSL_HPIDAT_H_

#include <csl_std.h>
#include <csl_chiphal.h>

#if (_HPI_SUPPORT) 

#include <csl_hpihal.h>

/*----------------------------------------------------------------*\
*	 HPI scope and inline control macros 			
\*----------------------------------------------------------------*/

typedef struct {
      Uint16 pidlsw;
      Uint16 pidmsw;
	Uint16 hpwremu;
      Uint16 rsrvd1[3];
	Uint16 hgpioen;
      Uint16 rsrvd2;
	Uint16 hgpiodir;
      Uint16 rsrvd3;
	Uint16 hgpiodat;
      Uint16 rsrvd4[13];
	Uint16 hpic;
      Uint16 rsrvd5;
      Uint16 hpiaw;
      Uint16 rsrvd6;
      Uint16 hpiar;
} HPI_RegObj;

typedef struct {
    Uint16 reserved;
} CSL_HpiDataObj;

#define CSL_HPIDATAINIT  {0x0000u}

extern CSL_HpiDataObj  CSL_HpiData;

#define CSL_HPI_DATA   CSL_HpiData

#endif  /* _HPI_SUPPORT  */

#endif  /* _CSL_HPIDAT_H  */

/******************************************************************************\
*     
*      End of csl_hpidat.h 
*
\******************************************************************************/
csl_hpihal.h/   1051540735  0     0     0       41355     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... HPI
* FILENAME...... csl_hpihal.h
* DATE CREATED.. Fri Mar 22 11:46:12 2002
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Fri Mar 22 11:46:12 2002 (Automatic generation)
*	 Last Modified:	3 Apr 2003 changed register and bit field names to match
*                                  datasheet (sprs166c and UG spru620A)
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL HAL interface file for the HPI module 
*
* Registers covered:
*
* 		 Note: Add registers description here
*	 PIDLSW		- 
*	 PIDMSW		- 
*	 HPWREMU		- 
*	 HGPIOEN		- 
*	 HGPIODIR		- 
*	 HGPIODAT		- 
*	 HPIC		- 
*	 HPIAW		- 
*	 HPIAR		- 
\*************************************************************************/

#ifndef _CSL_HPIHAL_H_
#define _CSL_HPIHAL_H_

#include <csl_chiphal.h>

#if (_HPI_SUPPORT) 

/*----------------------------------------------------------------*\
*	 HPI scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _HPI_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/*----------------------------------------------------------------*\
*		 Address Macros			
\*----------------------------------------------------------------*/
#define _HPI_BASE_ADDR                (0xA000u)
/*--------------------- Register: PIDLSW -----------------------*/
#define _HPI_PIDLSW_ADDR		(0xA000u)
#define _HPI_PIDLSW			PREG16(_HPI_PIDLSW_ADDR)
#define PIDLSW			_HPI_PIDLSW


/*--------------------- Register: PIDMSW -----------------------*/
#define _HPI_PIDMSW_ADDR		(0xA001u)
#define _HPI_PIDMSW			PREG16(_HPI_PIDMSW_ADDR)
#define PIDMSW			_HPI_PIDMSW


/*--------------------- Register: PWREMU -----------------------*/
#define _HPI_HPWREMU_ADDR		(0xA002u)
#define _HPI_HPWREMU			PREG16(_HPI_HPWREMU_ADDR)
#define PWREMU			_HPI_HPWREMU


/*--------------------- Register: HGPIOEN -----------------------*/
#define _HPI_HGPIOEN_ADDR		(0xA006u)
#define _HPI_HGPIOEN			PREG16(_HPI_HGPIOEN_ADDR)
#define HGPIOEN			_HPI_HGPIOEN


/*--------------------- Register: HGPIODIR -----------------------*/
#define _HPI_HGPIODIR_ADDR		(0xA008u)
#define _HPI_HGPIODIR			PREG16(_HPI_HGPIODIR_ADDR)
#define HGPIODIR			_HPI_HGPIODIR


/*--------------------- Register: HGPIODAT -----------------------*/
#define _HPI_HGPIODAT_ADDR		(0xA00Au)
#define _HPI_HGPIODAT			PREG16(_HPI_HGPIODAT_ADDR)
#define HGPIODAT			_HPI_HGPIODAT


/*--------------------- Register: HPIC -----------------------*/
#define _HPI_HPIC_ADDR		(0xa018u)
#define _HPI_HPIC			PREG16(_HPI_HPIC_ADDR)
#define HPIC			_HPI_HPIC


/*--------------------- Register: HPIAW -----------------------*/
#define _HPI_HPIAW_ADDR		(0xA020)
#define _HPI_HPIAW			PREG16(_HPI_HPIAW_ADDR)
#define HPIAW			_HPI_HPIAW


/*--------------------- Register: HPIAR -----------------------*/
#define _HPI_HPIAR_ADDR		(0xA022)
#define _HPI_HPIAR			PREG16(_HPI_HPIAR_ADDR)
#define HPIAR			_HPI_HPIAR


/*----------------------------------------------------------------*\
*		 Register Macros		
\*----------------------------------------------------------------*/

#define HPI_ADDR(Reg)		  _HPI_##Reg##_ADDR
#define HPI_RGET(Reg)		  _HPI_##Reg##_GET
#define HPI_RSET(Reg,Val)		  _HPI_##Reg##_SET(Val)
#define HPI_FGET(Reg,Field)		  _HPI_##Reg##_FGET(Field)
#define HPI_FSET(Reg,Field,Val)		  _HPI_##Reg##_FSET(Field, Val)
#define HPI_FMK(Reg,Field,Val)		  _HPI_##Reg##_##Field##_MK(Val)
#define HPI_RAOI(Reg,AND,OR,INV)		  _HPI_##Reg##_AOI(AND,OR,INV)
#define HPI_FAOI(Reg,Field,AND,OR,INV)	  _HPI_##Reg##_FAOI(Field,AND,OR,INV)
#define HPI_FMKS(Reg,Field,Sym)\
	  _HPI_##Reg##_##Field##_MK(HPI_##Reg##_##Field##_##Sym)
#define HPI_FSETS(Reg,Field,Sym)\
	  _HPI_FSET(Reg,Field,HPI_##Reg##_##Field##_##Sym)

/*----------------------------------------------------------------*\
*		 Non-handle Registers Macros		
\*----------------------------------------------------------------*/


/*--------------------- Register: PIDLSW -----------------------*/
#define _HPI_PIDLSW_GET		  _PREG_GET(_HPI_PIDLSW_ADDR) 
#define _HPI_PIDLSW_SET(Val)		  _PREG_SET(_HPI_PIDLSW_ADDR,Val)
#define _HPI_PIDLSW_FGET(Field)	  _PFIELD_GET(_HPI_PIDLSW_ADDR, _HPI_PIDLSW_##Field)
#define _HPI_PIDLSW_FSET(Field,Val)	  _PFIELD_SET(_HPI_PIDLSW_ADDR, _HPI_PIDLSW_##Field, Val)
#define _HPI_PIDLSW_AOI(AND,OR,INV)	  _PREG_AOI(_HPI_PIDLSW_ADDR,AND,OR,INV)
#define _HPI_PIDLSW_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_HPI_PIDLSW_ADDR, _HPI_PIDLSW_##Field,AND,OR,INV)


/*--------------------- Register: PIDMSW -----------------------*/
#define _HPI_PIDMSW_GET		  _PREG_GET(_HPI_PIDMSW_ADDR) 
#define _HPI_PIDMSW_SET(Val)		  _PREG_SET(_HPI_PIDMSW_ADDR,Val)
#define _HPI_PIDMSW_FGET(Field)	  _PFIELD_GET(_HPI_PIDMSW_ADDR, _HPI_PIDMSW_##Field)
#define _HPI_PIDMSW_FSET(Field,Val)	  _PFIELD_SET(_HPI_PIDMSW_ADDR, _HPI_PIDMSW_##Field, Val)
#define _HPI_PIDMSW_AOI(AND,OR,INV)	  _PREG_AOI(_HPI_PIDMSW_ADDR,AND,OR,INV)
#define _HPI_PIDMSW_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_HPI_PIDMSW_ADDR, _HPI_PIDMSW_##Field,AND,OR,INV)


/*--------------------- Register: PWREMU -----------------------*/
#define _HPI_HPWREMU_GET		  _PREG_GET(_HPI_HPWREMU_ADDR) 
#define _HPI_HPWREMU_SET(Val)		  _PREG_SET(_HPI_HPWREMU_ADDR,Val)
#define _HPI_HPWREMU_FGET(Field)	  _PFIELD_GET(_HPI_HPWREMU_ADDR, _HPI_HPWREMU_##Field)
#define _HPI_HPWREMU_FSET(Field,Val)	  _PFIELD_SET(_HPI_HPWREMU_ADDR, _HPI_HPWREMU_##Field, Val)
#define _HPI_HPWREMU_AOI(AND,OR,INV)	  _PREG_AOI(_HPI_HPWREMU_ADDR,AND,OR,INV)
#define _HPI_HPWREMU_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_HPI_HPWREMU_ADDR, _HPI_HPWREMU_##Field,AND,OR,INV)


/*--------------------- Register: HGPIOEN -----------------------*/
#define _HPI_HGPIOEN_GET		  _PREG_GET(_HPI_HGPIOEN_ADDR) 
#define _HPI_HGPIOEN_SET(Val)		  _PREG_SET(_HPI_HGPIOEN_ADDR,Val)
#define _HPI_HGPIOEN_FGET(Field)	  _PFIELD_GET(_HPI_HGPIOEN_ADDR, _HPI_HGPIOEN_##Field)
#define _HPI_HGPIOEN_FSET(Field,Val)	  _PFIELD_SET(_HPI_HGPIOEN_ADDR, _HPI_HGPIOEN_##Field, Val)
#define _HPI_HGPIOEN_AOI(AND,OR,INV)	  _PREG_AOI(_HPI_HGPIOEN_ADDR,AND,OR,INV)
#define _HPI_HGPIOEN_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_HPI_HGPIOEN_ADDR, _HPI_HGPIOEN_##Field,AND,OR,INV)


/*--------------------- Register: HGPIODIR -----------------------*/
#define _HPI_HGPIODIR_GET		  _PREG_GET(_HPI_HGPIODIR_ADDR) 
#define _HPI_HGPIODIR_SET(Val)		  _PREG_SET(_HPI_HGPIODIR_ADDR,Val)
#define _HPI_HGPIODIR_FGET(Field)	  _PFIELD_GET(_HPI_HGPIODIR_ADDR, _HPI_HGPIODIR_##Field)
#define _HPI_HGPIODIR_FSET(Field,Val)	  _PFIELD_SET(_HPI_HGPIODIR_ADDR, _HPI_HGPIODIR_##Field, Val)
#define _HPI_HGPIODIR_AOI(AND,OR,INV)	  _PREG_AOI(_HPI_HGPIODIR_ADDR,AND,OR,INV)
#define _HPI_HGPIODIR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_HPI_HGPIODIR_ADDR, _HPI_HGPIODIR_##Field,AND,OR,INV)


/*--------------------- Register: HGPIODAT -----------------------*/
#define _HPI_HGPIODAT_GET		  _PREG_GET(_HPI_HGPIODAT_ADDR) 
#define _HPI_HGPIODAT_SET(Val)		  _PREG_SET(_HPI_HGPIODAT_ADDR,Val)
#define _HPI_HGPIODAT_FGET(Field)	  _PFIELD_GET(_HPI_HGPIODAT_ADDR, _HPI_HGPIODAT_##Field)
#define _HPI_HGPIODAT_FSET(Field,Val)	  _PFIELD_SET(_HPI_HGPIODAT_ADDR, _HPI_HGPIODAT_##Field, Val)
#define _HPI_HGPIODAT_AOI(AND,OR,INV)	  _PREG_AOI(_HPI_HGPIODAT_ADDR,AND,OR,INV)
#define _HPI_HGPIODAT_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_HPI_HGPIODAT_ADDR, _HPI_HGPIODAT_##Field,AND,OR,INV)


/*--------------------- Register: HPIC -----------------------*/
#define _HPI_HPIC_GET		  _PREG_GET(_HPI_HPIC_ADDR) 
#define _HPI_HPIC_SET(Val)		  _PREG_SET(_HPI_HPIC_ADDR,Val)
#define _HPI_HPIC_FGET(Field)	  _PFIELD_GET(_HPI_HPIC_ADDR, _HPI_HPIC_##Field)
#define _HPI_HPIC_FSET(Field,Val)	  _PFIELD_SET(_HPI_HPIC_ADDR, _HPI_HPIC_##Field, Val)
#define _HPI_HPIC_AOI(AND,OR,INV)	  _PREG_AOI(_HPI_HPIC_ADDR,AND,OR,INV)
#define _HPI_HPIC_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_HPI_HPIC_ADDR, _HPI_HPIC_##Field,AND,OR,INV)


/*--------------------- Register: HPIAW -----------------------*/
#define _HPI_HPIAW_GET		  _PREG_GET(_HPI_HPIAW_ADDR) 
#define _HPI_HPIAW_SET(Val)		  _PREG_SET(_HPI_HPIAW_ADDR,Val)
#define _HPI_HPIAW_FGET(Field)	  _PFIELD_GET(_HPI_HPIAW_ADDR, _HPI_HPIAW_##Field)
#define _HPI_HPIAW_FSET(Field,Val)	  _PFIELD_SET(_HPI_HPIAW_ADDR, _HPI_HPIAW_##Field, Val)
#define _HPI_HPIAW_AOI(AND,OR,INV)	  _PREG_AOI(_HPI_HPIAW_ADDR,AND,OR,INV)
#define _HPI_HPIAW_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_HPI_HPIAW_ADDR, _HPI_HPIAW_##Field,AND,OR,INV)


/*--------------------- Register: HPIAR -----------------------*/
#define _HPI_HPIAR_GET		  _PREG_GET(_HPI_HPIAR_ADDR) 
#define _HPI_HPIAR_SET(Val)		  _PREG_SET(_HPI_HPIAR_ADDR,Val)
#define _HPI_HPIAR_FGET(Field)	  _PFIELD_GET(_HPI_HPIAR_ADDR, _HPI_HPIAR_##Field)
#define _HPI_HPIAR_FSET(Field,Val)	  _PFIELD_SET(_HPI_HPIAR_ADDR, _HPI_HPIAR_##Field, Val)
#define _HPI_HPIAR_AOI(AND,OR,INV)	  _PREG_AOI(_HPI_HPIAR_ADDR,AND,OR,INV)
#define _HPI_HPIAR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_HPI_HPIAR_ADDR, _HPI_HPIAR_##Field,AND,OR,INV)



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the HPIAR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _HPI_HPIAR	 - Note: Add description here
*
* Fields:
*	(RW)   _HPI_HPIAR_HPIAR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _HPI_HPIAR_HPIAR:	
\*----------------------------------------------------------------*/

#define _HPI_HPIAR_HPIAR_SHIFT		(000000u)
#define _HPI_HPIAR_HPIAR_MK(n)		(((Uint16)(n) & 0xffffu) << _HPI_HPIAR_HPIAR_SHIFT)
#define _HPI_HPIAR_HPIAR_MASK		(_HPI_HPIAR_HPIAR_MK(0xffffu))
#define _HPI_HPIAR_HPIAR_CLR		(~(_HPI_HPIAR_HPIAR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the HPIC register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _HPI_HPIC	 - Note: Add description here
*
* Fields:
*	(RW)   _HPI_HPIC_BOB	
*	(R)    _HPI_HPIC_DSPINT	
*	(RW)   _HPI_HPIC_HINT	
*	(R)    _HPI_HPIC_HRDY	
*	(R)    _HPI_HPIC_FETCH	
*	(RW)   _HPI_HPIC_HPIRST	
*	(RW)   _HPI_HPIC_BOBSTAT	
*	(RW)   _HPI_HPIC_DUALHPIA	
*	(RW)   _HPI_HPIC_HPIASEL	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _HPI_HPIC_BOB:	
\*----------------------------------------------------------------*/

#define _HPI_HPIC_BOB_SHIFT		(000000u)
#define _HPI_HPIC_BOB_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HPIC_BOB_SHIFT)
#define _HPI_HPIC_BOB_MASK		(_HPI_HPIC_BOB_MK(0x0001u))
#define _HPI_HPIC_BOB_CLR		(~(_HPI_HPIC_BOB_MASK))



/*----------------------------------------------------------------*\
*   (R)  _HPI_HPIC_DSPINT:	
\*----------------------------------------------------------------*/

#define _HPI_HPIC_DSPINT_SHIFT		(0x0001u)
#define _HPI_HPIC_DSPINT_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HPIC_DSPINT_SHIFT)
#define _HPI_HPIC_DSPINT_MASK		(_HPI_HPIC_DSPINT_MK(0x0001u))
#define _HPI_HPIC_DSPINT_CLR		(~(_HPI_HPIC_DSPINT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HPIC_HINT:	
\*----------------------------------------------------------------*/

#define _HPI_HPIC_HINT_SHIFT		(0x0002u)
#define _HPI_HPIC_HINT_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HPIC_HINT_SHIFT)
#define _HPI_HPIC_HINT_MASK		(_HPI_HPIC_HINT_MK(0x0001u))
#define _HPI_HPIC_HINT_CLR		(~(_HPI_HPIC_HINT_MASK))



/*----------------------------------------------------------------*\
*   (R)  _HPI_HPIC_HRDY:	
\*----------------------------------------------------------------*/

#define _HPI_HPIC_HRDY_SHIFT		(0x0003u)
#define _HPI_HPIC_HRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HPIC_HRDY_SHIFT)
#define _HPI_HPIC_HRDY_MASK		(_HPI_HPIC_HRDY_MK(0x0001u))
#define _HPI_HPIC_HRDY_CLR		(~(_HPI_HPIC_HRDY_MASK))



/*----------------------------------------------------------------*\
*   (R)  _HPI_HPIC_FETCH:	
\*----------------------------------------------------------------*/

#define _HPI_HPIC_FETCH_SHIFT		(0x0004u)
#define _HPI_HPIC_FETCH_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HPIC_FETCH_SHIFT)
#define _HPI_HPIC_FETCH_MASK		(_HPI_HPIC_FETCH_MK(0x0001u))
#define _HPI_HPIC_FETCH_CLR		(~(_HPI_HPIC_FETCH_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HPIC_HPIRST:	
\*----------------------------------------------------------------*/

#define _HPI_HPIC_HPIRST_SHIFT		(0x0007u)
#define _HPI_HPIC_HPIRST_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HPIC_HPIRST_SHIFT)
#define _HPI_HPIC_HPIRST_MASK		(_HPI_HPIC_HPIRST_MK(0x0001u))
#define _HPI_HPIC_HPIRST_CLR		(~(_HPI_HPIC_HPIRST_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HPIC_BOBSTAT:	
\*----------------------------------------------------------------*/

#define _HPI_HPIC_BOBSTAT_SHIFT		(0x0008u)
#define _HPI_HPIC_BOBSTAT_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HPIC_BOBSTAT_SHIFT)
#define _HPI_HPIC_BOBSTAT_MASK		(_HPI_HPIC_BOBSTAT_MK(0x0001u))
#define _HPI_HPIC_BOBSTAT_CLR		(~(_HPI_HPIC_BOBSTAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HPIC_DUALHPIA:	
\*----------------------------------------------------------------*/

#define _HPI_HPIC_DUALHPIA_SHIFT		(0x0009u)
#define _HPI_HPIC_DUALHPIA_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HPIC_DUALHPIA_SHIFT)
#define _HPI_HPIC_DUALHPIA_MASK		(_HPI_HPIC_DUALHPIA_MK(0x0001u))
#define _HPI_HPIC_DUALHPIA_CLR		(~(_HPI_HPIC_DUALHPIA_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _HPI_HPIC_HPIASEL:	
\*----------------------------------------------------------------*/

#define _HPI_HPIC_HPIASEL_SHIFT		(0x000bu)
#define _HPI_HPIC_HPIASEL_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HPIC_HPIASEL_SHIFT)
#define _HPI_HPIC_HPIASEL_MASK		(_HPI_HPIC_HPIASEL_MK(0x0001u))
#define _HPI_HPIC_HPIASEL_CLR		(~(_HPI_HPIC_HPIASEL_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the XHPIAR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _HPI_XHPIAR	 - Note: Add description here
*
* Fields:
*	(RW)   _HPI_XHPIAR_XHPIAR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _HPI_XHPIAR_XHPIAR:	
\*----------------------------------------------------------------*/

#define _HPI_XHPIAR_XHPIAR_SHIFT		(000000u)
#define _HPI_XHPIAR_XHPIAR_MK(n)		(((Uint16)(n) & 0xffffu) << _HPI_XHPIAR_XHPIAR_SHIFT)
#define _HPI_XHPIAR_XHPIAR_MASK		(_HPI_XHPIAR_XHPIAR_MK(0xffffu))
#define _HPI_XHPIAR_XHPIAR_CLR		(~(_HPI_XHPIAR_XHPIAR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the HPIAW register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _HPI_HPIAW	 - Note: Add description here
*
* Fields:
*	(RW)   _HPI_HPIAW_HPIAW	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _HPI_HPIAW_HPIAW:	
\*----------------------------------------------------------------*/

#define _HPI_HPIAW_HPIAW_SHIFT		(000000u)
#define _HPI_HPIAW_HPIAW_MK(n)		(((Uint16)(n) & 0xffffu) << _HPI_HPIAW_HPIAW_SHIFT)
#define _HPI_HPIAW_HPIAW_MASK		(_HPI_HPIAW_HPIAW_MK(0xffffu))
#define _HPI_HPIAW_HPIAW_CLR		(~(_HPI_HPIAW_HPIAW_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PWREMU register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _HPI_HPWREMU	 - Note: Add description here
*
* Fields:
*	(RW)   _HPI_HPWREMU_FREE	
*	(RW)   _HPI_HPWREMU_SOFT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _HPI_HPWREMU_FREE:	
\*----------------------------------------------------------------*/

#define _HPI_HPWREMU_FREE_SHIFT		(000000u)
#define _HPI_HPWREMU_FREE_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HPWREMU_FREE_SHIFT)
#define _HPI_HPWREMU_FREE_MASK		(_HPI_HPWREMU_FREE_MK(0x0001u))
#define _HPI_HPWREMU_FREE_CLR		(~(_HPI_HPWREMU_FREE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HPWREMU_SOFT:	
\*----------------------------------------------------------------*/

#define _HPI_HPWREMU_SOFT_SHIFT		(0x0001u)
#define _HPI_HPWREMU_SOFT_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HPWREMU_SOFT_SHIFT)
#define _HPI_HPWREMU_SOFT_MASK		(_HPI_HPWREMU_SOFT_MK(0x0001u))
#define _HPI_HPWREMU_SOFT_CLR		(~(_HPI_HPWREMU_SOFT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the XHPIAW register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _HPI_XHPIAW	 - Note: Add description here
*
* Fields:
*	(RW)   _HPI_XHPIAW_XHPIAW	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _HPI_XHPIAW_XHPIAW:	
\*----------------------------------------------------------------*/

#define _HPI_XHPIAW_XHPIAW_SHIFT		(000000u)
#define _HPI_XHPIAW_XHPIAW_MK(n)		(((Uint16)(n) & 0xffffu) << _HPI_XHPIAW_XHPIAW_SHIFT)
#define _HPI_XHPIAW_XHPIAW_MASK		(_HPI_XHPIAW_XHPIAW_MK(0xffffu))
#define _HPI_XHPIAW_XHPIAW_CLR		(~(_HPI_XHPIAW_XHPIAW_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the HGPIOEN register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _HPI_HGPIOEN	 - Note: Add description here
*
* Fields:
*	(RW)   _HPI_HGPIOEN_EN0	
*	(RW)   _HPI_HGPIOEN_EN1	
*	(RW)   _HPI_HGPIOEN_EN2	
*	(RW)   _HPI_HGPIOEN_EN4	
*	(RW)   _HPI_HGPIOEN_EN5	
*	(RW)   _HPI_HGPIOEN_EN6	
*	(RW)   _HPI_HGPIOEN_EN7	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIOEN_EN0:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIOEN_EN0_SHIFT		(000000u)
#define _HPI_HGPIOEN_EN0_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIOEN_EN0_SHIFT)
#define _HPI_HGPIOEN_EN0_MASK		(_HPI_HGPIOEN_EN0_MK(0x0001u))
#define _HPI_HGPIOEN_EN0_CLR		(~(_HPI_HGPIOEN_EN0_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIOEN_EN1:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIOEN_EN1_SHIFT		(0x0001u)
#define _HPI_HGPIOEN_EN1_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIOEN_EN1_SHIFT)
#define _HPI_HGPIOEN_EN1_MASK		(_HPI_HGPIOEN_EN1_MK(0x0001u))
#define _HPI_HGPIOEN_EN1_CLR		(~(_HPI_HGPIOEN_EN1_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIOEN_EN2:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIOEN_EN2_SHIFT		(0x0002u)
#define _HPI_HGPIOEN_EN2_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIOEN_EN2_SHIFT)
#define _HPI_HGPIOEN_EN2_MASK		(_HPI_HGPIOEN_EN2_MK(0x0001u))
#define _HPI_HGPIOEN_EN2_CLR		(~(_HPI_HGPIOEN_EN2_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIOEN_EN4:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIOEN_EN4_SHIFT		(0x0004u)
#define _HPI_HGPIOEN_EN4_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIOEN_EN4_SHIFT)
#define _HPI_HGPIOEN_EN4_MASK		(_HPI_HGPIOEN_EN4_MK(0x0001u))
#define _HPI_HGPIOEN_EN4_CLR		(~(_HPI_HGPIOEN_EN4_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIOEN_EN5:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIOEN_EN5_SHIFT		(0x0005u)
#define _HPI_HGPIOEN_EN5_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIOEN_EN5_SHIFT)
#define _HPI_HGPIOEN_EN5_MASK		(_HPI_HGPIOEN_EN5_MK(0x0001u))
#define _HPI_HGPIOEN_EN5_CLR		(~(_HPI_HGPIOEN_EN5_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIOEN_EN6:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIOEN_EN6_SHIFT		(0x0006u)
#define _HPI_HGPIOEN_EN6_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIOEN_EN6_SHIFT)
#define _HPI_HGPIOEN_EN6_MASK		(_HPI_HGPIOEN_EN6_MK(0x0001u))
#define _HPI_HGPIOEN_EN6_CLR		(~(_HPI_HGPIOEN_EN6_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIOEN_EN7:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIOEN_EN7_SHIFT		(0x0007u)
#define _HPI_HGPIOEN_EN7_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIOEN_EN7_SHIFT)
#define _HPI_HGPIOEN_EN7_MASK		(_HPI_HGPIOEN_EN7_MK(0x0001u))
#define _HPI_HGPIOEN_EN7_CLR		(~(_HPI_HGPIOEN_EN7_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PIDLSW register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _HPI_PIDLSW	 - Note: Add description here
*
* Fields:
*	(R)   _HPI_PIDLSW_REV	
*	(R)   _HPI_PIDLSW_CLASS	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _HPI_PIDLSW_REV:	
\*----------------------------------------------------------------*/

#define _HPI_PIDLSW_REV_SHIFT		(000000u)
#define _HPI_PIDLSW_REV_MK(n)		(((Uint16)(n) & 0x00ffu) << _HPI_PIDLSW_REV_SHIFT)
#define _HPI_PIDLSW_REV_MASK		(_HPI_PIDLSW_REV_MK(0x00ffu))
#define _HPI_PIDLSW_REV_CLR		(~(_HPI_PIDLSW_REV_MASK))



/*----------------------------------------------------------------*\
*   (R)  _HPI_PIDLSW_CLASS:	
\*----------------------------------------------------------------*/

#define _HPI_PIDLSW_CLASS_SHIFT		(0x0008u)
#define _HPI_PIDLSW_CLASS_MK(n)		(((Uint16)(n) & 0x00ffu) << _HPI_PIDLSW_CLASS_SHIFT)
#define _HPI_PIDLSW_CLASS_MASK		(_HPI_PIDLSW_CLASS_MK(0x00ffu))
#define _HPI_PIDLSW_CLASS_CLR		(~(_HPI_PIDLSW_CLASS_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the HGPIODIR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _HPI_HGPIODIR	 - Note: Add description here
*
* Fields:
*	(RW)   _HPI_HGPIODIR_HD0	
*	(RW)   _HPI_HGPIODIR_HD1	
*	(RW)   _HPI_HGPIODIR_HD2	
*	(RW)   _HPI_HGPIODIR_HD3	
*	(RW)   _HPI_HGPIODIR_HD4	
*	(RW)   _HPI_HGPIODIR_HD5	
*	(RW)   _HPI_HGPIODIR_HD6	
*	(RW)   _HPI_HGPIODIR_HD7
*	(RW)   _HPI_HGPIODIR_HD8	
*	(RW)   _HPI_HGPIODIR_HD9	
*	(RW)   _HPI_HGPIODIR_HD10	
*	(RW)   _HPI_HGPIODIR_HD11	
*	(RW)   _HPI_HGPIODIR_HD12	
*	(RW)   _HPI_HGPIODIR_HD13	
*	(RW)   _HPI_HGPIODIR_HD14	
*	(RW)   _HPI_HGPIODIR_HD15	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD0:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD0_SHIFT		(000000u)
#define _HPI_HGPIODIR_HD0_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD0_SHIFT)
#define _HPI_HGPIODIR_HD0_MASK		(_HPI_HGPIODIR_HD0_MK(0x0001u))
#define _HPI_HGPIODIR_HD0_CLR		(~(_HPI_HGPIODIR_HD0_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD1:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD1_SHIFT		(0x0001u)
#define _HPI_HGPIODIR_HD1_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD1_SHIFT)
#define _HPI_HGPIODIR_HD1_MASK		(_HPI_HGPIODIR_HD1_MK(0x0001u))
#define _HPI_HGPIODIR_HD1_CLR		(~(_HPI_HGPIODIR_HD1_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD2:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD2_SHIFT		(0x0002u)
#define _HPI_HGPIODIR_HD2_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD2_SHIFT)
#define _HPI_HGPIODIR_HD2_MASK		(_HPI_HGPIODIR_HD2_MK(0x0001u))
#define _HPI_HGPIODIR_HD2_CLR		(~(_HPI_HGPIODIR_HD2_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD3:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD3_SHIFT		(0x0003u)
#define _HPI_HGPIODIR_HD3_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD3_SHIFT)
#define _HPI_HGPIODIR_HD3_MASK		(_HPI_HGPIODIR_HD3_MK(0x0001u))
#define _HPI_HGPIODIR_HD3_CLR		(~(_HPI_HGPIODIR_HD3_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD4:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD4_SHIFT		(0x0004u)
#define _HPI_HGPIODIR_HD4_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD4_SHIFT)
#define _HPI_HGPIODIR_HD4_MASK		(_HPI_HGPIODIR_HD4_MK(0x0001u))
#define _HPI_HGPIODIR_HD4_CLR		(~(_HPI_HGPIODIR_HD4_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD5:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD5_SHIFT		(0x0005u)
#define _HPI_HGPIODIR_HD5_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD5_SHIFT)
#define _HPI_HGPIODIR_HD5_MASK		(_HPI_HGPIODIR_HD5_MK(0x0001u))
#define _HPI_HGPIODIR_HD5_CLR		(~(_HPI_HGPIODIR_HD5_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD6:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD6_SHIFT		(0x0006u)
#define _HPI_HGPIODIR_HD6_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD6_SHIFT)
#define _HPI_HGPIODIR_HD6_MASK		(_HPI_HGPIODIR_HD6_MK(0x0001u))
#define _HPI_HGPIODIR_HD6_CLR		(~(_HPI_HGPIODIR_HD6_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD7:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD7_SHIFT		(0x0007u)
#define _HPI_HGPIODIR_HD7_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD7_SHIFT)
#define _HPI_HGPIODIR_HD7_MASK		(_HPI_HGPIODIR_HD7_MK(0x0001u))
#define _HPI_HGPIODIR_HD7_CLR		(~(_HPI_HGPIODIR_HD7_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD8:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD8_SHIFT		(0x0008u)
#define _HPI_HGPIODIR_HD8_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD8_SHIFT)
#define _HPI_HGPIODIR_HD8_MASK		(_HPI_HGPIODIR_HD8_MK(0x0001u))
#define _HPI_HGPIODIR_HD8_CLR		(~(_HPI_HGPIODIR_HD8_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD9:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD9_SHIFT		(0x0009u)
#define _HPI_HGPIODIR_HD9_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD9_SHIFT)
#define _HPI_HGPIODIR_HD9_MASK		(_HPI_HGPIODIR_HD9_MK(0x0001u))
#define _HPI_HGPIODIR_HD9_CLR		(~(_HPI_HGPIODIR_HD9_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD10:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD10_SHIFT		(0x000Au)
#define _HPI_HGPIODIR_HD10_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD10_SHIFT)
#define _HPI_HGPIODIR_HD10_MASK		(_HPI_HGPIODIR_HD10_MK(0x0001u))
#define _HPI_HGPIODIR_HD10_CLR		(~(_HPI_HGPIODIR_HD10_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD11:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD11_SHIFT		(0x000Bu)
#define _HPI_HGPIODIR_HD11_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD11_SHIFT)
#define _HPI_HGPIODIR_HD11_MASK		(_HPI_HGPIODIR_HD11_MK(0x0001u))
#define _HPI_HGPIODIR_HD11_CLR		(~(_HPI_HGPIODIR_HD11_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD12:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD12_SHIFT		(0x000Cu)
#define _HPI_HGPIODIR_HD12_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD12_SHIFT)
#define _HPI_HGPIODIR_HD12_MASK		(_HPI_HGPIODIR_HD12_MK(0x0001u))
#define _HPI_HGPIODIR_HD12_CLR		(~(_HPI_HGPIODIR_HD12_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD13:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD13_SHIFT		(0x000Du)
#define _HPI_HGPIODIR_HD13_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD13_SHIFT)
#define _HPI_HGPIODIR_HD13_MASK		(_HPI_HGPIODIR_HD13_MK(0x0001u))
#define _HPI_HGPIODIR_HD13_CLR		(~(_HPI_HGPIODIR_HD13_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD14:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD14_SHIFT		(0x000Eu)
#define _HPI_HGPIODIR_HD14_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD14_SHIFT)
#define _HPI_HGPIODIR_HD14_MASK		(_HPI_HGPIODIR_HD14_MK(0x0001u))
#define _HPI_HGPIODIR_HD14_CLR		(~(_HPI_HGPIODIR_HD14_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODIR_HD15:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODIR_HD15_SHIFT		(0x000Fu)
#define _HPI_HGPIODIR_HD15_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODIR_HD15_SHIFT)
#define _HPI_HGPIODIR_HD15_MASK		(_HPI_HGPIODIR_HD15_MK(0x0001u))
#define _HPI_HGPIODIR_HD15_CLR		(~(_HPI_HGPIODIR_HD15_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PIDMSW register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _HPI_PIDMSW	 - Note: Add description here
*
* Fields:
*	(R)   _HPI_PIDMSW_TYPE	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _HPI_PIDMSW_TYPE:	
\*----------------------------------------------------------------*/

#define _HPI_PIDMSW_TYPE_SHIFT		(000000u)
#define _HPI_PIDMSW_TYPE_MK(n)		(((Uint16)(n) & 0x00ffu) << _HPI_PIDMSW_TYPE_SHIFT)
#define _HPI_PIDMSW_TYPE_MASK		(_HPI_PIDMSW_TYPE_MK(0x00ffu))
#define _HPI_PIDMSW_TYPE_CLR		(~(_HPI_PIDMSW_TYPE_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the HGPIODAT register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _HPI_HGPIODAT	 - Note: Add description here
*
* Fields:
*	(RW)   _HPI_HGPIODAT_HD0	
*	(RW)   _HPI_HGPIODAT_HD1	
*	(RW)   _HPI_HGPIODAT_HD2	
*	(RW)   _HPI_HGPIODAT_HD3	
*	(RW)   _HPI_HGPIODAT_HD4	
*	(RW)   _HPI_HGPIODAT_HD5	
*	(RW)   _HPI_HGPIODAT_HD6	
*	(RW)   _HPI_HGPIODAT_HD7
*	(RW)   _HPI_HGPIODAT_HD8	
*	(RW)   _HPI_HGPIODAT_HD9	
*	(RW)   _HPI_HGPIODAT_HD10	
*	(RW)   _HPI_HGPIODAT_HD11	
*	(RW)   _HPI_HGPIODAT_HD12	
*	(RW)   _HPI_HGPIODAT_HD13	
*	(RW)   _HPI_HGPIODAT_HD14	
*	(RW)   _HPI_HGPIODAT_HD15	
*
\******************************************************************************/


/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD0:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD0_SHIFT		(000000u)
#define _HPI_HGPIODAT_HD0_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD0_SHIFT)
#define _HPI_HGPIODAT_HD0_MASK		(_HPI_HGPIODAT_HD0_MK(0x0001u))
#define _HPI_HGPIODAT_HD0_CLR		      (~(_HPI_HGPIODAT_HD0_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD1:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD1_SHIFT		(0x0001u)
#define _HPI_HGPIODAT_HD1_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD1_SHIFT)
#define _HPI_HGPIODAT_HD1_MASK		(_HPI_HGPIODAT_HD1_MK(0x0001u))
#define _HPI_HGPIODAT_HD1_CLR		(~(_HPI_HGPIODAT_HD1_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD2:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD2_SHIFT		(0x0002u)
#define _HPI_HGPIODAT_HD2_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD2_SHIFT)
#define _HPI_HGPIODAT_HD2_MASK		(_HPI_HGPIODAT_HD2_MK(0x0001u))
#define _HPI_HGPIODAT_HD2_CLR		(~(_HPI_HGPIODAT_HD2_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD3:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD3_SHIFT		(0x0003u)
#define _HPI_HGPIODAT_HD3_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD3_SHIFT)
#define _HPI_HGPIODAT_HD3_MASK		(_HPI_HGPIODAT_HD3_MK(0x0001u))
#define _HPI_HGPIODAT_HD3_CLR		(~(_HPI_HGPIODAT_HD3_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD4:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD4_SHIFT		(0x0004u)
#define _HPI_HGPIODAT_HD4_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD4_SHIFT)
#define _HPI_HGPIODAT_HD4_MASK		(_HPI_HGPIODAT_HD4_MK(0x0001u))
#define _HPI_HGPIODAT_HD4_CLR		(~(_HPI_HGPIODAT_HD4_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD5:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD5_SHIFT		(0x0005u)
#define _HPI_HGPIODAT_HD5_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD5_SHIFT)
#define _HPI_HGPIODAT_HD5_MASK		(_HPI_HGPIODAT_HD5_MK(0x0001u))
#define _HPI_HGPIODAT_HD5_CLR		(~(_HPI_HGPIODAT_HD5_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD6:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD6_SHIFT		(0x0006u)
#define _HPI_HGPIODAT_HD6_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD6_SHIFT)
#define _HPI_HGPIODAT_HD6_MASK		(_HPI_HGPIODAT_HD6_MK(0x0001u))
#define _HPI_HGPIODAT_HD6_CLR		(~(_HPI_HGPIODAT_HD6_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD7:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD7_SHIFT		(0x0007u)
#define _HPI_HGPIODAT_HD7_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD7_SHIFT)
#define _HPI_HGPIODAT_HD7_MASK		(_HPI_HGPIODAT_HD7_MK(0x0001u))
#define _HPI_HGPIODAT_HD7_CLR		(~(_HPI_HGPIODAT_HD7_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD8:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD8_SHIFT		(0x0008u)
#define _HPI_HGPIODAT_HD8_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD8_SHIFT)
#define _HPI_HGPIODAT_HD8_MASK		(_HPI_HGPIODAT_HD8_MK(0x0001u))
#define _HPI_HGPIODAT_HD8_CLR		      (~(_HPI_HGPIODAT_HD8_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD9:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD9_SHIFT		(0x0009u)
#define _HPI_HGPIODAT_HD9_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD9_SHIFT)
#define _HPI_HGPIODAT_HD9_MASK		(_HPI_HGPIODAT_HD9_MK(0x0001u))
#define _HPI_HGPIODAT_HD9_CLR		      (~(_HPI_HGPIODAT_HD9_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD10:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD10_SHIFT		(0x000Au)
#define _HPI_HGPIODAT_HD10_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD10_SHIFT)
#define _HPI_HGPIODAT_HD10_MASK		(_HPI_HGPIODAT_HD10_MK(0x0001u))
#define _HPI_HGPIODAT_HD10_CLR		(~(_HPI_HGPIODAT_HD10_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD11:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD11_SHIFT		(0x000Bu)
#define _HPI_HGPIODAT_HD11_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD11_SHIFT)
#define _HPI_HGPIODAT_HD11_MASK		(_HPI_HGPIODAT_HD11_MK(0x0001u))
#define _HPI_HGPIODAT_HD11_CLR		(~(_HPI_HGPIODAT_HD11_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD12:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD12_SHIFT		(0x000Cu)
#define _HPI_HGPIODAT_HD12_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD12_SHIFT)
#define _HPI_HGPIODAT_HD12_MASK		(_HPI_HGPIODAT_HD12_MK(0x0001u))
#define _HPI_HGPIODAT_HD12_CLR		(~(_HPI_HGPIODAT_HD12_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD13:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD13_SHIFT		(0x000Du)
#define _HPI_HGPIODAT_HD13_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD13_SHIFT)
#define _HPI_HGPIODAT_HD13_MASK		(_HPI_HGPIODAT_HD13_MK(0x0001u))
#define _HPI_HGPIODAT_HD13_CLR		(~(_HPI_HGPIODAT_HD13_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD14:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD14_SHIFT		(0x000Eu)
#define _HPI_HGPIODAT_HD14_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD14_SHIFT)
#define _HPI_HGPIODAT_HD14_MASK		(_HPI_HGPIODAT_HD14_MK(0x0001u))
#define _HPI_HGPIODAT_HD14_CLR		(~(_HPI_HGPIODAT_HD14_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _HPI_HGPIODAT_HD15:	
\*----------------------------------------------------------------*/

#define _HPI_HGPIODAT_HD15_SHIFT		(0x000Fu)
#define _HPI_HGPIODAT_HD15_MK(n)		(((Uint16)(n) & 0x0001u) << _HPI_HGPIODAT_HD15_SHIFT)
#define _HPI_HGPIODAT_HD15_MASK		(_HPI_HGPIODAT_HD15_MK(0x0001u))
#define _HPI_HGPIODAT_HD15_CLR		(~(_HPI_HGPIODAT_HD15_MASK))

#elif (!(_HPI_MOD))
	#error HPI Hal Module Not Supported on Specified Target
#endif  /* _HPI_SUPPORT  */

#endif  /* _CSL_HPIHAL_H  */

/******************************************************************************\
*     
*      End of csl_hpihal.h 
*
\******************************************************************************/

csl_i2c.h/      1057234047  0     0     0       18847     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... I2C
* FILENAME...... csl_i2c.h
* DATE CREATED.. Thu Aug 16 10:16:34 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS..
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu Aug 16 10:16:34 2001 (Automatic generation)
*	 Modified: 04/04/2002 Changed name of I2C_init ==> I2C_setup
*        Modified: 03/18/2003 Added I2C_Init structure def for backward
*                              compatability to I2C_init function definition
*        Modified: 07/03/2003  Added CSLAPI  scope and inline control macro for
*                               I2C functions to avoid compiler errors with C++
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the I2C module
*
\*************************************************************************/

#ifndef _CSL_I2C_H_
#define _CSL_I2C_H_

#include <csl_chiphal.h>


#if (_I2C_SUPPORT)

#include <_csl.h>
#include <csl_i2chal.h>
#include <csl_i2cdat.h>
/*----------------------------------------------------------------*\
*	 I2C scope and inline control macros
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _I2C_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/****************************************\
* I2C global macro declarations
\****************************************/

/* error codes */
#define I2C_ERR_MAJOR		   (ERR_BASE_I2C) 
#define I2C_ERR_ALLOC		   (0x00000000) 
#define I2C_ERR_INVALID_HANDLE  (0x00000001)

#define IRQ_EVT_IIC		  IRQ_EVT_I2C


/******************************************\
* I2C Symbolic Register Field Values
\******************************************/
/*  I2COAR field values  */

#define I2C_I2COAR_OAR_OF(x)         ((Uint16)(x))

/*  I2CIER field values  */

	#define I2C_I2CIER_ICXRDY_DISABLE			(000000u)
	#define I2C_I2CIER_ICXRDY_ENABLE			(0x0001u)
	#define I2C_I2CIER_ICXRDY_DEFAULT		I2C_I2CIER_ICXRDY_DISABLE

	#define I2C_I2CIER_ICRRDY_DISABLE			(000000u)
	#define I2C_I2CIER_ICRRDY_ENABLE			(0x0001u)
	#define I2C_I2CIER_ICRRDY_DEFAULT		I2C_I2CIER_ICRRDY_DISABLE

	#define I2C_I2CIER_ARDY_DISABLE			(000000u)
	#define I2C_I2CIER_ARDY_ENABLE			(0x0001u)
	#define I2C_I2CIER_ARDY_DEFAULT		I2C_I2CIER_ARDY_DISABLE

	#define I2C_I2CIER_NACK_DISABLE			(000000u)
	#define I2C_I2CIER_NACK_ENABLE			(0x0001u)
	#define I2C_I2CIER_NACK_DEFAULT		I2C_I2CIER_NACK_DISABLE

	#define I2C_I2CIER_AL_DISABLE			(000000u)
	#define I2C_I2CIER_AL_ENABLE			(0x0001u)
	#define I2C_I2CIER_AL_DEFAULT		I2C_I2CIER_AL_DISABLE

/*  I2CSTR field values  */

	#define I2C_I2CSTR_BB_FREE			(000000u)
	#define I2C_I2CSTR_BB_BUSY			(0x0001u)
	#define I2C_I2CSTR_BB_DEFAULT		I2C_I2CSTR_BB_FREE

	#define I2C_I2CSTR_RSFULL_FALSE			(000000u)
	#define I2C_I2CSTR_RSFULL_TRUE			(0x0001u)
	#define I2C_I2CSTR_RSFULL_DEFAULT		I2C_I2CSTR_RSFULL_FALSE

	#define I2C_I2CSTR_XSMT_FALSE			(0x0001u)
	#define I2C_I2CSTR_XSMT_TRUE			(000000u)
	#define I2C_I2CSTR_XSMT_DEFAULT		I2C_I2CSTR_XSMT_FALSE

	#define I2C_I2CSTR_AAS_OFF			(000000u)
	#define I2C_I2CSTR_AAS_ON			(0x0001u)
	#define I2C_I2CSTR_AAS_DEFAULT		I2C_I2CSTR_AAS_OFF

	#define I2C_I2CSTR_AD0_OFF			(000000u)
	#define I2C_I2CSTR_AD0_ON			(0x0001u)
	#define I2C_I2CSTR_AD0_DEFAULT		I2C_I2CSTR_AD0_OFF

	#define I2C_I2CSTR_XRDY_OFF			(000000u)
	#define I2C_I2CSTR_XRDY_ON			(0x0001u)
	#define I2C_I2CSTR_XRDY_DEFAULT		I2C_I2CSTR_XRDY_OFF

	#define I2C_I2CSTR_RRDY_OFF			(000000u)
	#define I2C_I2CSTR_RRDY_ON			(0x0001u)
	#define I2C_I2CSTR_RRDY_DEFAULT		I2C_I2CSTR_RRDY_OFF

	#define I2C_I2CSTR_ARDY_NORDY			(000000u)
	#define I2C_I2CSTR_ARDY_RDY			(0x0001u)
	#define I2C_I2CSTR_ARDY_DEFAULT		I2C_I2CSTR_ARDY_NORDY

	#define I2C_I2CSTR_NACK_FALSE			(000000u)
	#define I2C_I2CSTR_NACK_TRUE			(0x0001u)
	#define I2C_I2CSTR_NACK_DEFAULT		I2C_I2CSTR_NACK_FALSE

	#define I2C_I2CSTR_AL_OFF			(000000u)
	#define I2C_I2CSTR_AL_ON			(0x0001u)
	#define I2C_I2CSTR_AL_DEFAULT		I2C_I2CSTR_AL_OFF

/*  I2CCLKL field values  */

#define I2C_I2CCLKL_ICCL_OF(x)         ((Uint16)(x))

/*  I2CCLKH field values  */

#define I2C_I2CCLKH_ICCH_OF(x)         ((Uint16)(x))

/*  I2CCNT field values  */

#define I2C_I2CCNT_ICDC_OF(x)         ((Uint16)(x))

/*  I2CSAR field values  */

#define I2C_I2CSAR_SAR_OF(x)         ((Uint16)(x))

/*  I2CMDR field values  */

	#define I2C_I2CMDR_FREE_OFF			(000000u)
	#define I2C_I2CMDR_FREE_ON			(0x0001u)
	#define I2C_I2CMDR_FREE_DEFAULT		I2C_I2CMDR_FREE_OFF

	#define I2C_I2CMDR_STT_OFF			(000000u)
	#define I2C_I2CMDR_STT_ON			(0x0001u)
	#define I2C_I2CMDR_STT_DEFAULT		I2C_I2CMDR_STT_OFF

	#define I2C_I2CMDR_IDLEEN_NOIDLE			(000000u)
	#define I2C_I2CMDR_IDLEEN_IDLE			(0x0001u)
	#define I2C_I2CMDR_IDLEEN_DEFAULT		I2C_I2CMDR_IDLEEN_NOIDLE

	#define I2C_I2CMDR_STP_OFF			(000000u)
	#define I2C_I2CMDR_STP_ON			(0x0001u)
	#define I2C_I2CMDR_STP_DEFAULT		I2C_I2CMDR_STP_OFF

	#define I2C_I2CMDR_MST_OFF			(000000u)
	#define I2C_I2CMDR_MST_ON			(0x0001u)
	#define I2C_I2CMDR_MST_DEFAULT		I2C_I2CMDR_MST_ON

	#define I2C_I2CMDR_TRX_RECEIVE			(000000u)
	#define I2C_I2CMDR_TRX_TRANSMIT			(0x0001u)
	#define I2C_I2CMDR_TRX_DEFAULT		I2C_I2CMDR_TRX_TRANSMIT

	#define I2C_I2CMDR_XA_7BIT			(000000u)
	#define I2C_I2CMDR_XA_10BIT			(0x0001u)
	#define I2C_I2CMDR_XA_DEFAULT		I2C_I2CMDR_XA_7BIT

	#define I2C_I2CMDR_RM_OFF			(000000u)
	#define I2C_I2CMDR_RM_ON			(0x0001u)
	#define I2C_I2CMDR_RM_DEFAULT		I2C_I2CMDR_RM_OFF

	#define I2C_I2CMDR_DLB_DISABLE			(000000u)
	#define I2C_I2CMDR_DLB_ENABLE			(0x0001u)
	#define I2C_I2CMDR_DLB_DEFAULT		I2C_I2CMDR_DLB_DISABLE

	#define I2C_I2CMDR_IRS_RESET			(000000u)
	#define I2C_I2CMDR_IRS_ENABLE			(0x0001u)
	#define I2C_I2CMDR_IRS_DEFAULT		I2C_I2CMDR_IRS_ENABLE

	#define I2C_I2CMDR_STB_OFF			(000000u)
	#define I2C_I2CMDR_STB_ON			(0x0001u)
	#define I2C_I2CMDR_STB_DEFAULT		I2C_I2CMDR_STB_OFF

	#define I2C_I2CMDR_FDF_OFF			(000000u)
	#define I2C_I2CMDR_FDF_ON			(0x0001u)
	#define I2C_I2CMDR_FDF_DEFAULT		I2C_I2CMDR_FDF_OFF

	#define I2C_I2CMDR_BC_OF(x)         ((Uint16)(x))

/*  I2CISRC field values  */

	#define I2C_I2CISRC_INTCODE_NONE			(000000u)
	#define I2C_I2CISRC_INTCODE_AL			(0x0001u)
	#define I2C_I2CISRC_INTCODE_NACK			(0x0002u)
	#define I2C_I2CISRC_INTCODE_ARDY			(0x0003u)
	#define I2C_I2CISRC_INTCODE_RRDY			(0x0004u)
	#define I2C_I2CISRC_INTCODE_XRDY			(0x0005u)
	#define I2C_I2CISRC_INTCODE_DEFAULT		I2C_I2CISRC_INTCODE_NONE

/*  I2CPSC field values  */

#define I2C_I2CPSC_IPSC_OF(x)         ((Uint16)(x))

/* ============================================================== */
 /* Make I2CCLKH register values based on symbolic constants  */

#define I2C_I2CCLKH_RMK(icch)\
 ((Uint16) ( \
  ( I2C_FMK(I2CCLKH,ICCH,icch))\
)\
 )

#define I2C_I2CCLKH_RMKS(icch_sym)\
 ((Uint16) ( \
  ( I2C_FMKS(I2CCLKH,ICCH,icch_sym))\
)\
 )

/*  Default I2CCLKH register value  */

/*  I2CCLKH field values  */


/* ============================================================== */
 /* Make I2CCLKL register values based on symbolic constants  */

#define I2C_I2CCLKL_RMK(iccl)\
 ((Uint16) ( \
  ( I2C_FMK(I2CCLKL,ICCL,iccl))\
)\
 )

#define I2C_I2CCLKL_RMKS(iccl_sym)\
 ((Uint16) ( \
  ( I2C_FMKS(I2CCLKL,ICCL,iccl_sym))\
)\
 )

/*  Default I2CCLKL register value  */

/*  I2CCLKL field values  */


/* ============================================================== */
 /* Make I2CCNT register values based on symbolic constants  */

#define I2C_I2CCNT_RMK(icdc)\
 ((Uint16) ( \
  ( I2C_FMK(I2CCNT,ICDC,icdc))\
)\
 )

#define I2C_I2CCNT_RMKS(icdc_sym)\
 ((Uint16) ( \
  ( I2C_FMKS(I2CCNT,ICDC,icdc_sym))\
)\
 )

/*  Default I2CCNT register value  */

/*  I2CCNT field values  */


/* ============================================================== */
 /* Make I2CDRR register values based on symbolic constants  */

/*  Default I2CDRR register value  */

/*  I2CDRR field values  */


/* ============================================================== */
 /* Make I2CDXR register values based on symbolic constants  */

/*  Default I2CDXR register value  */

/*  I2CDXR field values  */


/* ============================================================== */
 /* Make I2CIER register values based on symbolic constants  */

#define I2C_I2CIER_RMK(xrdy,rrdy,ardy,nack,al)\
 ((Uint16) ( \
  ( I2C_FMK(I2CIER,XRDY,xrdy))|\
  ( I2C_FMK(I2CIER,RRDY,rrdy))|\
  ( I2C_FMK(I2CIER,ARDY,ardy))|\
  ( I2C_FMK(I2CIER,NACK,nack))|\
  ( I2C_FMK(I2CIER,AL,al))\
)\
 )

#define I2C_I2CIER_RMKS(xrdy_sym,rrdy_sym,ardy_sym,nack_sym,al_sym)\
 ((Uint16) ( \
  ( I2C_FMKS(I2CIER,XRDY,xrdy_sym))|\
  ( I2C_FMKS(I2CIER,RRDY,rrdy_sym))|\
  ( I2C_FMKS(I2CIER,ARDY,ardy_sym))|\
  ( I2C_FMKS(I2CIER,NACK,nack_sym))|\
  ( I2C_FMKS(I2CIER,AL,al_sym))\
)\
 )

/*  Default I2CIER register value  */

/*  I2CIER field values  */


/* ============================================================== */
 /* Make I2CISRC register values based on symbolic constants  */

#define I2C_I2CISRC_RMK(testmd)\
 ((Uint16) ( \
  ( I2C_FMK(I2CISRC,TESTMD,testmd))\
)\
 )

#define I2C_I2CISRC_RMKS(testmd_sym)\
 ((Uint16) ( \
  ( I2C_FMKS(I2CISRC,TESTMD,testmd_sym))\
)\
 )

/*  Default I2CISRC register value  */

/*  I2CISRC field values  */


/* ============================================================== */
 /* Make I2CMDR register values based on symbolic constants  */

#define I2C_I2CMDR_RMK(free,stt,idleen,stp,mst,trx,xa,rm,dlb,irs,stb,fdf,bc)\
 ((Uint16) ( \
  ( I2C_FMK(I2CMDR,FREE,free))|\
  ( I2C_FMK(I2CMDR,STT,stt))|\
  ( I2C_FMK(I2CMDR,IDLEEN,idleen))|\
  ( I2C_FMK(I2CMDR,STP,stp))|\
  ( I2C_FMK(I2CMDR,MST,mst))|\
  ( I2C_FMK(I2CMDR,TRX,trx))|\
  ( I2C_FMK(I2CMDR,XA,xa))|\
  ( I2C_FMK(I2CMDR,RM,rm))|\
  ( I2C_FMK(I2CMDR,DLB,dlb))|\
  ( I2C_FMK(I2CMDR,IRS,irs))|\
  ( I2C_FMK(I2CMDR,STB,stb))|\
  ( I2C_FMK(I2CMDR,FDF,fdf))|\
  ( I2C_FMK(I2CMDR,BC,bc))\
)\
 )

#define I2C_I2CMDR_RMKS(free_sym,stt_sym,idleen_sym,stp_sym,mst_sym,trx_sym,xa_sym,rm_sym,dlb_sym,irs_sym,stb_sym,fdf_sym,bc_sym)\
 ((Uint16) ( \
  ( I2C_FMKS(I2CMDR,FREE,free_sym))|\
  ( I2C_FMKS(I2CMDR,STT,stt_sym))|\
  ( I2C_FMKS(I2CMDR,IDLEEN,idleen_sym))|\
  ( I2C_FMKS(I2CMDR,STP,stp_sym))|\
  ( I2C_FMKS(I2CMDR,MST,mst_sym))|\
  ( I2C_FMKS(I2CMDR,TRX,trx_sym))|\
  ( I2C_FMKS(I2CMDR,XA,xa_sym))|\
  ( I2C_FMKS(I2CMDR,RM,rm_sym))|\
  ( I2C_FMKS(I2CMDR,DLB,dlb_sym))|\
  ( I2C_FMKS(I2CMDR,IRS,irs_sym))|\
  ( I2C_FMKS(I2CMDR,STB,stb_sym))|\
  ( I2C_FMKS(I2CMDR,FDF,fdf_sym))|\
  ( I2C_FMKS(I2CMDR,BC,bc_sym))\
)\
 )

/*  Default I2CMDR register value  */

/*  I2CMDR field values  */
/* Reset, rfull, rrdy, xempty, xrdy, read, sendStop, and start macro definitions */

#define I2C_reset() I2C_FSET(I2CMDR,IRS,0)

#define I2C_rfull() I2C_FGET(I2CSTR,RSFULL)

#define I2C_rrdy() I2C_FGET(I2CSTR,RRDY)

#define I2C_xempty() I2C_FGET(I2CSTR,XSMT)

#define I2C_xrdy() I2C_FGET(I2CSTR,XRDY)

#define I2C_writeByte(n) I2C_RSET(I2CDXR,n)

#define I2C_readByte() I2C_RGET(I2CDRR)

#define I2C_sendStop() I2C_FSET(I2CMDR,STP,1)

#define I2C_start() I2C_FSET(I2CMDR,STT,1)

/* ============================================================== */
 /* Make I2COAR register values based on symbolic constants  */

#define I2C_I2COAR_RMK(oar)\
 ((Uint16) ( \
  ( I2C_FMK(I2COAR,OAR,oar))\
)\
 )

#define I2C_I2COAR_RMKS(oar_sym)\
 ((Uint16) ( \
  ( I2C_FMKS(I2COAR,OAR,oar_sym))\
)\
 )

/*  Default I2COAR register value  */

/*  I2COAR field values  */


/* ============================================================== */
 /* Make I2CPSC register values based on symbolic constants  */

#define I2C_I2CPSC_RMK(ipsc)\
 ((Uint16) ( \
  ( I2C_FMK(I2CPSC,IPSC,ipsc))\
)\
 )

#define I2C_I2CPSC_RMKS(ipsc_sym)\
 ((Uint16) ( \
  ( I2C_FMKS(I2CPSC,IPSC,ipsc_sym))\
)\
 )

/*  Default I2CPSC register value  */

/*  I2CPSC field values  */


/* ============================================================== */
 /* Make I2CSAR register values based on symbolic constants  */

#define I2C_I2CSAR_RMK(sar)\
 ((Uint16) ( \
  ( I2C_FMK(I2CSAR,SAR,sar))\
)\
 )

#define I2C_I2CSAR_RMKS(sar_sym)\
 ((Uint16) ( \
  ( I2C_FMKS(I2CSAR,SAR,sar_sym))\
)\
 )

/*  Default I2CSAR register value  */

/*  I2CSAR field values  */


/* ============================================================== */
 /* Make I2CSTR register values based on symbolic constants  */

#define I2C_I2CSTR_RMK(rrdy)\
 ((Uint16) ( \
  ( I2C_FMK(I2CSTR,RRDY,rrdy))\
)\
 )

#define I2C_I2CSTR_RMKS(rrdy_sym)\
 ((Uint16) ( \
  ( I2C_FMKS(I2CSTR,RRDY,rrdy_sym))\
)\
 )

/*  Default I2CSTR register value  */

/*  I2CSTR field values  */

/*************************************************\
 I2C global typedef declarations 
\*************************************************/

typedef struct {
	Uint16 i2coar;
	Uint16 i2cier;
	Uint16 i2cstr;
	Uint16 i2cclkl;
	Uint16 i2cclkh;
	Uint16 i2ccnt;
	Uint16 i2csar;
	Uint16 i2cmdr;
	Uint16 i2cisrc;
	Uint16 i2cpsc;
} I2C_Config;

typedef struct {
	
	Uint16 addrmode;        /* 7 or 10 bit address mode */
	Uint16 ownaddr;         /* don't care if master */
	Uint16 sysinclock;      /* clkout value (Mhz)  */
	Uint16 rate;            /* a number between 10 and 400*/
	Uint16 bitbyte;         /* number of bits/byte to be received or transmitted */
	Uint16 dlb;             /* data loopback mode */
	Uint16 free;	/* free mode */
	
} I2C_Setup;

typedef struct {
	
	Uint16 addrmode;        /* 7 or 10 bit address mode */
	Uint16 ownaddr;         /* don't care if master */
	Uint16 sysinclock;      /* clkout value (Mhz)  */
	Uint16 rate;            /* a number between 10 and 400*/
	Uint16 bitbyte;         /* number of bits/byte to be received or transmitted */
	Uint16 dlb;             /* data loopback mode */
	Uint16 free;	/* free mode */
	
} I2C_Init;

typedef struct
{
   void (*alAddr)(void);          // Arbitration status
   void (*nackAddr)(void);         // No acknowledgement 
   void (*ardyAddr)(void);         // register access ready
   void (*rrdyAddr)(void);         // receive data ready
   void (*xrdyAddr)(void);         // transmit data ready
} I2C_IsrAddr;

#define    I2C_EVT_AL     0x01     // Arbitration win/lose
#define    I2C_EVT_NACK   0x02     // No acknowledgement 
#define    I2C_EVT_ARDY   0x04     // register access ready
#define    I2C_EVT_RRDY   0x08     // receive data ready
#define    I2C_EVT_XRDY   0x10     // transmit data ready


/*************************************************\
* I2C global variable declarations
\*************************************************/

/*************************************************\
* I2C global function declarations
\*************************************************/




IDECL void I2C_config(I2C_Config *myConfig);
IDECL void I2C_configArgs(Uint16 i2coar,Uint16 i2cier,Uint16 i2cstr,Uint16 i2cclkl,Uint16 i2cclkh,Uint16 i2ccnt,Uint16 i2csar,Uint16 i2cmdr,Uint16 i2cisrc,Uint16 i2cpsc);
IDECL void I2C_getConfig(I2C_Config *myConfig);
CSLAPI void I2C_setup(I2C_Setup *Init);
CSLAPI int I2C_write(Uint16 *data,int length,int master,Uint16 slaveaddress,int transfermode,int timeout);
CSLAPI int I2C_read(Uint16 *data,int length,int master,Uint16 slaveaddress,int transfermode,int timeout,int checkbus);
CSLAPI void I2C_eventEnable(Uint16 isrmask);
CSLAPI void I2C_eventDisable(Uint16 ierMask);
CSLAPI void I2C_setCallback(I2C_IsrAddr *isrAddr);
interrupt void I2C_intrDispatch(void);
CSLAPI int I2C_getEventId(void);
/*************************************************\
* I2C inline function declarations
\*************************************************/


#ifdef USEDEFS



/*----------------------------------------------------------------------------*/

IDEF void I2C_config(I2C_Config *Config) {

  int old_intm;

  old_intm = IRQ_globalDisable();  
  I2C_RSET(I2COAR,Config->i2coar);
  I2C_RSET(I2CIER,Config->i2cier);
  I2C_RSET(I2CPSC,Config->i2cpsc);	
  I2C_RSET(I2CCLKL,Config->i2cclkl);
  I2C_RSET(I2CCLKH,Config->i2cclkh);
  I2C_RSET(I2CCNT,Config->i2ccnt);
  I2C_RSET(I2CSAR,Config->i2csar);				 
  I2C_RSET(I2CMDR,Config->i2cmdr);
  I2C_RSET(I2CSTR,Config->i2cstr);
  I2C_RSET(I2CISRC,Config->i2cisrc);
  IRQ_globalRestore(old_intm);   



}

IDEF void I2C_getConfig(I2C_Config *Config) {

  int old_intm;

  old_intm = IRQ_globalDisable();
  Config->i2coar = I2C_RGET(I2COAR);
  Config->i2cier = I2C_RGET(I2CIER);
  Config->i2cpsc = I2C_RGET(I2CPSC);
  Config->i2cclkl = I2C_RGET(I2CCLKL);
  Config->i2cclkh = I2C_RGET(I2CCLKH);
  Config->i2ccnt = I2C_RGET(I2CCNT);
  Config->i2csar = I2C_RGET(I2CSAR);
  Config->i2cmdr = I2C_RGET(I2CMDR);
  Config->i2cstr = I2C_RGET(I2CSTR);
  Config->i2cisrc = I2C_RGET(I2CISRC);
  IRQ_globalRestore(old_intm);   



}


IDEF void I2C_configArgs(Uint16 i2coar,Uint16 i2cier,Uint16 i2cstr,Uint16 i2cclkl,Uint16 i2cclkh,Uint16 i2ccnt,Uint16 i2csar,Uint16 i2cmdr,Uint16 i2cisrc,Uint16 i2cpsc) {

  int old_intm;

  old_intm = IRQ_globalDisable();  
  I2C_RSET(I2COAR,i2coar);
  I2C_RSET(I2CIER,i2cier);
  I2C_RSET(I2CPSC,i2cpsc);	
  I2C_RSET(I2CCLKL,i2cclkl);
  I2C_RSET(I2CCLKH,i2cclkh);
  I2C_RSET(I2CCNT,i2ccnt);
  I2C_RSET(I2CSAR,i2csar);				 
  I2C_RSET(I2CMDR,i2cmdr);
  I2C_RSET(I2CSTR,i2cstr);
  I2C_RSET(I2CISRC,i2cisrc);
  IRQ_globalRestore(old_intm);   

}


/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /*USEDEFS */

#else
   #ifndef _I2C_MOD_
	#error I2C Hal Module Not Supported on Specified Target
   #endif
#endif  /* _I2C_SUPPORT  */

#endif  /* _CSL_I2CHAL_H  */

/******************************************************************************\
*     
*      End of csl_i2c.h 
*
\******************************************************************************/

csl_i2cdat.h/   1051539341  0     0     0       1359      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... RTC
* FILENAME...... csl_i2cdat.h
* DATE CREATED.. Thu 02/20/2001
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   MODIFIED: 
*   LAST MODIFIED: 10 April 2003 added reference to CSL_I2cData for .csldata
*                                size fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the RTC module)
*       Reserved ROM Area for RTC Data 
*
*
\******************************************************************************/
#ifndef _CSL_I2C_DATA_H_
#define _CSL_I2C_DATA_H_

  #include <csl_std.h>

  #define CSL_I2CDATAINIT\
  { 0x00000000u,\
    0x00000000u,\
    0x00000000u,\
    0x00000000u,\
    0x00000000u,\
    0x00000000u\
  }

  

  typedef struct {
    Uint32 I2C_isrDispatchTable[6];
  } CSL_I2cDataObj;

extern CSL_I2cDataObj CSL_I2cData;

#define CSL_I2C_DATA  CSL_I2cData

#endif

csl_i2chal.h/   1049976890  0     0     0       35758     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... I2C
* FILENAME...... csl_I2Chal.h
* DATE CREATED.. Thu Aug 16 10:16:34 2001
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu Aug 16 10:16:34 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL HAL interface file for the I2C module 
*
* Registers covered:
*
* 		 Note: Add registers description here
*	 I2COAR		- 
*	 I2CIER		- 
*	 I2CSTR		- 
*	 I2CCLKL		- 
*	 I2CCLKH		- 
*	 I2CCNT		- 
*	 I2CDRR		- 
*	 I2CSAR		- 
*	 I2CDXR		- 
*	 I2CMDR		- 
*	 I2CISRC		- 
*	 I2CGPIO		- 
*	 I2CPSC		- 
*
\*************************************************************************/

#ifndef _CSL_I2CHAL_H_
#define _CSL_I2CHAL_H_

#include <csl_chiphal.h>

#if (_I2C_SUPPORT) 

/*----------------------------------------------------------------*\
*	 I2C scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _I2C_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/*----------------------------------------------------------------*\
*		 Address Macros			
\*----------------------------------------------------------------*/

/*--------------------- Register: I2COAR -----------------------*/
#define _I2C_I2COAR_ADDR		(0x3C00u)
#define _I2C_I2COAR			PREG16(_I2C_I2COAR_ADDR)
#define I2COAR			_I2C_I2COAR


/*--------------------- Register: I2CIER -----------------------*/
#define _I2C_I2CIER_ADDR		(0x3C01u)
#define _I2C_I2CIER			PREG16(_I2C_I2CIER_ADDR)
#define I2CIER			_I2C_I2CIER


/*--------------------- Register: I2CSTR -----------------------*/
#define _I2C_I2CSTR_ADDR		(0x3C02u)
#define _I2C_I2CSTR			PREG16(_I2C_I2CSTR_ADDR)
#define I2CSTR			_I2C_I2CSTR


/*--------------------- Register: I2CCLKL -----------------------*/
#define _I2C_I2CCLKL_ADDR		(0x3C03u)
#define _I2C_I2CCLKL			PREG16(_I2C_I2CCLKL_ADDR)
#define I2CCLKL			_I2C_I2CCLKL


/*--------------------- Register: I2CCLKH -----------------------*/
#define _I2C_I2CCLKH_ADDR		(0x3C04u)
#define _I2C_I2CCLKH			PREG16(_I2C_I2CCLKH_ADDR)
#define I2CCLKH			_I2C_I2CCLKH


/*--------------------- Register: I2CCNT -----------------------*/
#define _I2C_I2CCNT_ADDR		(0x3C05u)
#define _I2C_I2CCNT			PREG16(_I2C_I2CCNT_ADDR)
#define I2CCNT			_I2C_I2CCNT


/*--------------------- Register: I2CDRR -----------------------*/
#define _I2C_I2CDRR_ADDR		(0x3C06u)
#define _I2C_I2CDRR			PREG16(_I2C_I2CDRR_ADDR)
#define I2CDRR			_I2C_I2CDRR


/*--------------------- Register: I2CSAR -----------------------*/
#define _I2C_I2CSAR_ADDR		(0x3C07u)
#define _I2C_I2CSAR			PREG16(_I2C_I2CSAR_ADDR)
#define I2CSAR			_I2C_I2CSAR


/*--------------------- Register: I2CDXR -----------------------*/
#define _I2C_I2CDXR_ADDR		(0x3C08u)
#define _I2C_I2CDXR			PREG16(_I2C_I2CDXR_ADDR)
#define I2CDXR			_I2C_I2CDXR


/*--------------------- Register: I2CMDR -----------------------*/
#define _I2C_I2CMDR_ADDR		(0x3C09u)
#define _I2C_I2CMDR			PREG16(_I2C_I2CMDR_ADDR)
#define I2CMDR			_I2C_I2CMDR


/*--------------------- Register: I2CISRC -----------------------*/
#define _I2C_I2CISRC_ADDR		(0x3C0Au)
#define _I2C_I2CISRC			PREG16(_I2C_I2CISRC_ADDR)
#define I2CISRC			_I2C_I2CISRC


/*--------------------- Register: I2CGPIO -----------------------*/
#define _I2C_I2CGPIO_ADDR		(0x3C0Bu)
#define _I2C_I2CGPIO			PREG16(_I2C_I2CGPIO_ADDR)
#define I2CGPIO			_I2C_I2CGPIO


/*--------------------- Register: I2CPSC -----------------------*/
#define _I2C_I2CPSC_ADDR		(0x3C0Cu)
#define _I2C_I2CPSC			PREG16(_I2C_I2CPSC_ADDR)
#define I2CPSC			_I2C_I2CPSC



/*----------------------------------------------------------------*\
*		 Register Macros		
\*----------------------------------------------------------------*/

#define I2C_ADDR(Reg)		  _I2C_##Reg##_ADDR
#define I2C_RGET(Reg)		  _I2C_##Reg##_GET
#define I2C_RSET(Reg,Val)		  _I2C_##Reg##_SET(Val)
#define I2C_FGET(Reg,Field)		  _I2C_##Reg##_FGET(##Field)
#define I2C_FSET(Reg,Field,Val)		  _I2C_##Reg##_FSET(##Field, Val)
#define I2C_FMK(Reg,Field,Val)		  _I2C_##Reg##_##Field##_MK(Val)
#define I2C_RAOI(Reg,AND,OR,INV)		  _I2C_##Reg##_AOI(AND,OR,INV)
#define I2C_FAOI(Reg,Field,AND,OR,INV)	  _I2C_##Reg##_FAOI(##Field,AND,OR,INV)
#define I2C_FMKS(Reg,Field,Sym)\
	  _I2C_##Reg##_##Field##_MK(I2C_##Reg##_##Field##_##Sym)
#define I2C_FSETS(Reg,Field,Sym)\
	  _I2C_FSET(##Reg,##Field,I2C_##Reg##_##Field##_##Sym)

/*----------------------------------------------------------------*\
*		 Non-handle Registers Macros		
\*----------------------------------------------------------------*/


/*--------------------- Register: I2COAR -----------------------*/
#define _I2C_I2COAR_GET		  _PREG_GET(_I2C_I2COAR_ADDR) 
#define _I2C_I2COAR_SET(Val)		  _PREG_SET(_I2C_I2COAR_ADDR,Val)
#define _I2C_I2COAR_FGET(Field)	  _PFIELD_GET(_I2C_I2COAR_ADDR, _I2C_I2COAR_##Field)
#define _I2C_I2COAR_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2COAR_ADDR, _I2C_I2COAR_##Field, Val)
#define _I2C_I2COAR_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2COAR_ADDR,AND,OR,INV)
#define _I2C_I2COAR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2COAR_ADDR, _I2C_I2COAR_##Field,AND,OR,INV)


/*--------------------- Register: I2CIER -----------------------*/
#define _I2C_I2CIER_GET		  _PREG_GET(_I2C_I2CIER_ADDR) 
#define _I2C_I2CIER_SET(Val)		  _PREG_SET(_I2C_I2CIER_ADDR,Val)
#define _I2C_I2CIER_FGET(Field)	  _PFIELD_GET(_I2C_I2CIER_ADDR, _I2C_I2CIER_##Field)
#define _I2C_I2CIER_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2CIER_ADDR, _I2C_I2CIER_##Field, Val)
#define _I2C_I2CIER_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2CIER_ADDR,AND,OR,INV)
#define _I2C_I2CIER_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CIER_ADDR, _I2C_I2CIER_##Field,AND,OR,INV)


/*--------------------- Register: I2CSTR -----------------------*/
#define _I2C_I2CSTR_GET		  _PREG_GET(_I2C_I2CSTR_ADDR) 
#define _I2C_I2CSTR_SET(Val)		  _PREG_SET(_I2C_I2CSTR_ADDR,Val)
#define _I2C_I2CSTR_FGET(Field)	  _PFIELD_GET(_I2C_I2CSTR_ADDR, _I2C_I2CSTR_##Field)
#define _I2C_I2CSTR_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2CSTR_ADDR, _I2C_I2CSTR_##Field, Val)
#define _I2C_I2CSTR_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2CSTR_ADDR,AND,OR,INV)
#define _I2C_I2CSTR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CSTR_ADDR, _I2C_I2CSTR_##Field,AND,OR,INV)


/*--------------------- Register: I2CCLKL -----------------------*/
#define _I2C_I2CCLKL_GET		  _PREG_GET(_I2C_I2CCLKL_ADDR) 
#define _I2C_I2CCLKL_SET(Val)		  _PREG_SET(_I2C_I2CCLKL_ADDR,Val)
#define _I2C_I2CCLKL_FGET(Field)	  _PFIELD_GET(_I2C_I2CCLKL_ADDR, _I2C_I2CCLKL_##Field)
#define _I2C_I2CCLKL_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2CCLKL_ADDR, _I2C_I2CCLKL_##Field, Val)
#define _I2C_I2CCLKL_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2CCLKL_ADDR,AND,OR,INV)
#define _I2C_I2CCLKL_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CCLKL_ADDR, _I2C_I2CCLKL_##Field,AND,OR,INV)


/*--------------------- Register: I2CCLKH -----------------------*/
#define _I2C_I2CCLKH_GET		  _PREG_GET(_I2C_I2CCLKH_ADDR) 
#define _I2C_I2CCLKH_SET(Val)		  _PREG_SET(_I2C_I2CCLKH_ADDR,Val)
#define _I2C_I2CCLKH_FGET(Field)	  _PFIELD_GET(_I2C_I2CCLKH_ADDR, _I2C_I2CCLKH_##Field)
#define _I2C_I2CCLKH_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2CCLKH_ADDR, _I2C_I2CCLKH_##Field, Val)
#define _I2C_I2CCLKH_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2CCLKH_ADDR,AND,OR,INV)
#define _I2C_I2CCLKH_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CCLKH_ADDR, _I2C_I2CCLKH_##Field,AND,OR,INV)


/*--------------------- Register: I2CCNT -----------------------*/
#define _I2C_I2CCNT_GET		  _PREG_GET(_I2C_I2CCNT_ADDR) 
#define _I2C_I2CCNT_SET(Val)		  _PREG_SET(_I2C_I2CCNT_ADDR,Val)
#define _I2C_I2CCNT_FGET(Field)	  _PFIELD_GET(_I2C_I2CCNT_ADDR, _I2C_I2CCNT_##Field)
#define _I2C_I2CCNT_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2CCNT_ADDR, _I2C_I2CCNT_##Field, Val)
#define _I2C_I2CCNT_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2CCNT_ADDR,AND,OR,INV)
#define _I2C_I2CCNT_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CCNT_ADDR, _I2C_I2CCNT_##Field,AND,OR,INV)


/*--------------------- Register: I2CDRR -----------------------*/
#define _I2C_I2CDRR_GET		  _PREG_GET(_I2C_I2CDRR_ADDR) 
#define _I2C_I2CDRR_SET(Val)		  _PREG_SET(_I2C_I2CDRR_ADDR,Val)
#define _I2C_I2CDRR_FGET(Field)	  _PFIELD_GET(_I2C_I2CDRR_ADDR, _I2C_I2CDRR_##Field)
#define _I2C_I2CDRR_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2CDRR_ADDR, _I2C_I2CDRR_##Field, Val)
#define _I2C_I2CDRR_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2CDRR_ADDR,AND,OR,INV)
#define _I2C_I2CDRR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CDRR_ADDR, _I2C_I2CDRR_##Field,AND,OR,INV)


/*--------------------- Register: I2CSAR -----------------------*/
#define _I2C_I2CSAR_GET		  _PREG_GET(_I2C_I2CSAR_ADDR) 
#define _I2C_I2CSAR_SET(Val)		  _PREG_SET(_I2C_I2CSAR_ADDR,Val)
#define _I2C_I2CSAR_FGET(Field)	  _PFIELD_GET(_I2C_I2CSAR_ADDR, _I2C_I2CSAR_##Field)
#define _I2C_I2CSAR_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2CSAR_ADDR, _I2C_I2CSAR_##Field, Val)
#define _I2C_I2CSAR_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2CSAR_ADDR,AND,OR,INV)
#define _I2C_I2CSAR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CSAR_ADDR, _I2C_I2CSAR_##Field,AND,OR,INV)


/*--------------------- Register: I2CDXR -----------------------*/
#define _I2C_I2CDXR_GET		  _PREG_GET(_I2C_I2CDXR_ADDR) 
#define _I2C_I2CDXR_SET(Val)		  _PREG_SET(_I2C_I2CDXR_ADDR,Val)
#define _I2C_I2CDXR_FGET(Field)	  _PFIELD_GET(_I2C_I2CDXR_ADDR, _I2C_I2CDXR_##Field)
#define _I2C_I2CDXR_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2CDXR_ADDR, _I2C_I2CDXR_##Field, Val)
#define _I2C_I2CDXR_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2CDXR_ADDR,AND,OR,INV)
#define _I2C_I2CDXR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CDXR_ADDR, _I2C_I2CDXR_##Field,AND,OR,INV)


/*--------------------- Register: I2CMDR -----------------------*/
#define _I2C_I2CMDR_GET		  _PREG_GET(_I2C_I2CMDR_ADDR) 
#define _I2C_I2CMDR_SET(Val)		  _PREG_SET(_I2C_I2CMDR_ADDR,Val)
#define _I2C_I2CMDR_FGET(Field)	  _PFIELD_GET(_I2C_I2CMDR_ADDR, _I2C_I2CMDR_##Field)
#define _I2C_I2CMDR_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2CMDR_ADDR, _I2C_I2CMDR_##Field, Val)
#define _I2C_I2CMDR_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2CMDR_ADDR,AND,OR,INV)
#define _I2C_I2CMDR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CMDR_ADDR, _I2C_I2CMDR_##Field,AND,OR,INV)


/*--------------------- Register: I2CISRC -----------------------*/
#define _I2C_I2CISRC_GET		  _PREG_GET(_I2C_I2CISRC_ADDR) 
#define _I2C_I2CISRC_SET(Val)		  _PREG_SET(_I2C_I2CISRC_ADDR,Val)
#define _I2C_I2CISRC_FGET(Field)	  _PFIELD_GET(_I2C_I2CISRC_ADDR, _I2C_I2CISRC_##Field)
#define _I2C_I2CISRC_FSET(Field,Val)  _PFIELD_SET(_I2C_I2CISRC_ADDR, _I2C_I2CISRC_##Field, Val)
#define _I2C_I2CISRC_AOI(AND,OR,INV)  _PREG_AOI(_I2C_I2CISRC_ADDR,AND,OR,INV)
#define _I2C_I2CISRC_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CISRC_ADDR, _I2C_I2CISRC_##Field,AND,OR,INV)


/*--------------------- Register: I2CGPIO -----------------------*/
#define _I2C_I2CGPIO_GET		  _PREG_GET(_I2C_I2CGPIO_ADDR) 
#define _I2C_I2CGPIO_SET(Val)		  _PREG_SET(_I2C_I2CGPIO_ADDR,Val)
#define _I2C_I2CGPIO_FGET(Field)	  _PFIELD_GET(_I2C_I2CGPIO_ADDR, _I2C_I2CGPIO_##Field)
#define _I2C_I2CGPIO_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2CGPIO_ADDR, _I2C_I2CGPIO_##Field, Val)
#define _I2C_I2CGPIO_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2CGPIO_ADDR,AND,OR,INV)
#define _I2C_I2CGPIO_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CGPIO_ADDR, _I2C_I2CGPIO_##Field,AND,OR,INV)


/*--------------------- Register: I2CPSC -----------------------*/
#define _I2C_I2CPSC_GET		  _PREG_GET(_I2C_I2CPSC_ADDR) 
#define _I2C_I2CPSC_SET(Val)		  _PREG_SET(_I2C_I2CPSC_ADDR,Val)
#define _I2C_I2CPSC_FGET(Field)	  _PFIELD_GET(_I2C_I2CPSC_ADDR, _I2C_I2CPSC_##Field)
#define _I2C_I2CPSC_FSET(Field,Val)	  _PFIELD_SET(_I2C_I2CPSC_ADDR, _I2C_I2CPSC_##Field, Val)
#define _I2C_I2CPSC_AOI(AND,OR,INV)	  _PREG_AOI(_I2C_I2CPSC_ADDR,AND,OR,INV)
#define _I2C_I2CPSC_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_I2C_I2CPSC_ADDR, _I2C_I2CPSC_##Field,AND,OR,INV)



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2CIER register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2CIER	 - Note: Add description here
*
* Fields:
*	(RW)   _I2C_I2CIER_AL	
*	(RW)   _I2C_I2CIER_NACK	
*	(RW)   _I2C_I2CIER_ARDY	
*	(RW)   _I2C_I2CIER_RRDY	
*	(RW)   _I2C_I2CIER_XRDY	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CIER_AL:	
\*----------------------------------------------------------------*/

#define _I2C_I2CIER_AL_SHIFT		(000000u)
#define _I2C_I2CIER_AL_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CIER_AL_SHIFT)
#define _I2C_I2CIER_AL_MASK		(_I2C_I2CIER_AL_MK(0x0001u))
#define _I2C_I2CIER_AL_CLR		(~(_I2C_I2CIER_AL_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CIER_NACK:	
\*----------------------------------------------------------------*/

#define _I2C_I2CIER_NACK_SHIFT		(0x0001u)
#define _I2C_I2CIER_NACK_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CIER_NACK_SHIFT)
#define _I2C_I2CIER_NACK_MASK		      (_I2C_I2CIER_NACK_MK(0x0001u))
#define _I2C_I2CIER_NACK_CLR		      (~(_I2C_I2CIER_NACK_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CIER_ARDY:	
\*----------------------------------------------------------------*/

#define _I2C_I2CIER_ARDY_SHIFT		(0x0002u)
#define _I2C_I2CIER_ARDY_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CIER_ARDY_SHIFT)
#define _I2C_I2CIER_ARDY_MASK		      (_I2C_I2CIER_ARDY_MK(0x0001u))
#define _I2C_I2CIER_ARDY_CLR		      (~(_I2C_I2CIER_ARDY_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CIER_RRDY:	
\*----------------------------------------------------------------*/

#define _I2C_I2CIER_RRDY_SHIFT		(0x0003u)
#define _I2C_I2CIER_RRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CIER_RRDY_SHIFT)
#define _I2C_I2CIER_RRDY_MASK		      (_I2C_I2CIER_RRDY_MK(0x0001u))
#define _I2C_I2CIER_RRDY_CLR		      (~(_I2C_I2CIER_RRDY_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CIER_XRDY:	
\*----------------------------------------------------------------*/

#define _I2C_I2CIER_XRDY_SHIFT		(0x0004u)
#define _I2C_I2CIER_XRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CIER_XRDY_SHIFT)
#define _I2C_I2CIER_XRDY_MASK		      (_I2C_I2CIER_XRDY_MK(0x0001u))
#define _I2C_I2CIER_XRDY_CLR		      (~(_I2C_I2CIER_XRDY_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2CPSC register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2CPSC	 - Note: Add description here
*
* Fields:
*	(RW)   _I2C_I2CPSC_IPSC	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CPSC_IPSC:	
\*----------------------------------------------------------------*/

#define _I2C_I2CPSC_IPSC_SHIFT		(000000u)
#define _I2C_I2CPSC_IPSC_MK(n)		(((Uint16)(n) & 0x00ffu) << _I2C_I2CPSC_IPSC_SHIFT)
#define _I2C_I2CPSC_IPSC_MASK		      (_I2C_I2CPSC_IPSC_MK(0x00ffu))
#define _I2C_I2CPSC_IPSC_CLR		      (~(_I2C_I2CPSC_IPSC_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2CISRC register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2CISRC	 - Note: Add description here
*
* Fields:
*	(R)   _I2C_I2CISRC_INTCODE	
*	(RW)   _I2C_I2CISRC_TESTMD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CISRC_INTCODE:	
\*----------------------------------------------------------------*/

#define _I2C_I2CISRC_INTCODE_SHIFT		(000000u)
#define _I2C_I2CISRC_INTCODE_MK(n)		(((Uint16)(n) & 0x0007u) << _I2C_I2CISRC_INTCODE_SHIFT)
#define _I2C_I2CISRC_INTCODE_MASK		(_I2C_I2CISRC_INTCODE_MK(0x0007u))
#define _I2C_I2CISRC_INTCODE_CLR		(~(_I2C_I2CISRC_INTCODE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CISRC_TESTMD:	
\*----------------------------------------------------------------*/

#define _I2C_I2CISRC_TESTMD_SHIFT		(0x0008u)
#define _I2C_I2CISRC_TESTMD_MK(n)		(((Uint16)(n) & 0x000fu) << _I2C_I2CISRC_TESTMD_SHIFT)
#define _I2C_I2CISRC_TESTMD_MASK		(_I2C_I2CISRC_TESTMD_MK(0x000fu))
#define _I2C_I2CISRC_TESTMD_CLR		(~(_I2C_I2CISRC_TESTMD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2CCNT register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2CCNT	 - Note: Add description here
*
* Fields:
*	(RW)   _I2C_I2CCNT_ICDC	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CCNT_ICDC:	
\*----------------------------------------------------------------*/

#define _I2C_I2CCNT_ICDC_SHIFT		(000000u)
#define _I2C_I2CCNT_ICDC_MK(n)		(((Uint16)(n) & 0xffffu) << _I2C_I2CCNT_ICDC_SHIFT)
#define _I2C_I2CCNT_ICDC_MASK		(_I2C_I2CCNT_ICDC_MK(0xffffu))
#define _I2C_I2CCNT_ICDC_CLR		(~(_I2C_I2CCNT_ICDC_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2CSAR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2CSAR	 - Note: Add description here
*
* Fields:
*	(RW)   _I2C_I2CSAR_SAR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CSAR_SAR:	
\*----------------------------------------------------------------*/

#define _I2C_I2CSAR_SAR_SHIFT		(000000u)
#define _I2C_I2CSAR_SAR_MK(n)		(((Uint16)(n) & 0x03ffu) << _I2C_I2CSAR_SAR_SHIFT)
#define _I2C_I2CSAR_SAR_MASK		(_I2C_I2CSAR_SAR_MK(0x03ffu))
#define _I2C_I2CSAR_SAR_CLR		(~(_I2C_I2CSAR_SAR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2CDXR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2CDXR	 - Note: Add description here
*
* Fields:
*	(R)   _I2C_I2CDXR_DATA	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CDXR_DATA:	
\*----------------------------------------------------------------*/

#define _I2C_I2CDXR_DATA_SHIFT		(000000u)
#define _I2C_I2CDXR_DATA_MK(n)		(((Uint16)(n) & 0x00ffu) << _I2C_I2CDXR_DATA_SHIFT)
#define _I2C_I2CDXR_DATA_MASK		(_I2C_I2CDXR_DATA_MK(0x00ffu))
#define _I2C_I2CDXR_DATA_CLR		(~(_I2C_I2CDXR_DATA_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2CCLKH register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2CCLKH	 - Note: Add description here
*
* Fields:
*	(RW)   _I2C_I2CCLKH_ICCH	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CCLKH_ICCH:	
\*----------------------------------------------------------------*/

#define _I2C_I2CCLKH_ICCH_SHIFT		(000000u)
#define _I2C_I2CCLKH_ICCH_MK(n)		(((Uint16)(n) & 0xffffu) << _I2C_I2CCLKH_ICCH_SHIFT)
#define _I2C_I2CCLKH_ICCH_MASK		(_I2C_I2CCLKH_ICCH_MK(0xffffu))
#define _I2C_I2CCLKH_ICCH_CLR		(~(_I2C_I2CCLKH_ICCH_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2CMDR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2CMDR	 - Note: Add description here
*
* Fields:
*	(RW)   _I2C_I2CMDR_BC	
*	(RW)   _I2C_I2CMDR_FDF	
*	(RW)   _I2C_I2CMDR_STB	
*	(RW)   _I2C_I2CMDR_IRS	
*	(RW)   _I2C_I2CMDR_DLB	
*	(RW)   _I2C_I2CMDR_RM	
*	(RW)   _I2C_I2CMDR_XA	
*	(RW)   _I2C_I2CMDR_TRX	
*	(RW)   _I2C_I2CMDR_MST	
*	(RW)   _I2C_I2CMDR_STP	
*	(RW)   _I2C_I2CMDR_IDLEEN	
*	(RW)   _I2C_I2CMDR_STT	
*	(RW)   _I2C_I2CMDR_FREE	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_BC:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_BC_SHIFT		(000000u)
#define _I2C_I2CMDR_BC_MK(n)		(((Uint16)(n) & 0x0007u) << _I2C_I2CMDR_BC_SHIFT)
#define _I2C_I2CMDR_BC_MASK		(_I2C_I2CMDR_BC_MK(0x0007u))
#define _I2C_I2CMDR_BC_CLR		(~(_I2C_I2CMDR_BC_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_FDF:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_FDF_SHIFT		(0x0003u)
#define _I2C_I2CMDR_FDF_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_FDF_SHIFT)
#define _I2C_I2CMDR_FDF_MASK		(_I2C_I2CMDR_FDF_MK(0x0001u))
#define _I2C_I2CMDR_FDF_CLR		(~(_I2C_I2CMDR_FDF_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_STB:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_STB_SHIFT		(0x0004u)
#define _I2C_I2CMDR_STB_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_STB_SHIFT)
#define _I2C_I2CMDR_STB_MASK		(_I2C_I2CMDR_STB_MK(0x0001u))
#define _I2C_I2CMDR_STB_CLR		(~(_I2C_I2CMDR_STB_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_IRS:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_IRS_SHIFT		(0x0005u)
#define _I2C_I2CMDR_IRS_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_IRS_SHIFT)
#define _I2C_I2CMDR_IRS_MASK		(_I2C_I2CMDR_IRS_MK(0x0001u))
#define _I2C_I2CMDR_IRS_CLR		(~(_I2C_I2CMDR_IRS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_DLB:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_DLB_SHIFT		(0x0006u)
#define _I2C_I2CMDR_DLB_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_DLB_SHIFT)
#define _I2C_I2CMDR_DLB_MASK		(_I2C_I2CMDR_DLB_MK(0x0001u))
#define _I2C_I2CMDR_DLB_CLR		(~(_I2C_I2CMDR_DLB_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_RM:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_RM_SHIFT		(0x0007u)
#define _I2C_I2CMDR_RM_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_RM_SHIFT)
#define _I2C_I2CMDR_RM_MASK		(_I2C_I2CMDR_RM_MK(0x0001u))
#define _I2C_I2CMDR_RM_CLR		(~(_I2C_I2CMDR_RM_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_XA:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_XA_SHIFT		(0x0008u)
#define _I2C_I2CMDR_XA_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_XA_SHIFT)
#define _I2C_I2CMDR_XA_MASK		(_I2C_I2CMDR_XA_MK(0x0001u))
#define _I2C_I2CMDR_XA_CLR		(~(_I2C_I2CMDR_XA_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_TRX:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_TRX_SHIFT		(0x0009u)
#define _I2C_I2CMDR_TRX_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_TRX_SHIFT)
#define _I2C_I2CMDR_TRX_MASK		(_I2C_I2CMDR_TRX_MK(0x0001u))
#define _I2C_I2CMDR_TRX_CLR		(~(_I2C_I2CMDR_TRX_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_MST:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_MST_SHIFT		(0x000au)
#define _I2C_I2CMDR_MST_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_MST_SHIFT)
#define _I2C_I2CMDR_MST_MASK		(_I2C_I2CMDR_MST_MK(0x0001u))
#define _I2C_I2CMDR_MST_CLR		(~(_I2C_I2CMDR_MST_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_STP:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_STP_SHIFT		(0x000bu)
#define _I2C_I2CMDR_STP_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_STP_SHIFT)
#define _I2C_I2CMDR_STP_MASK		(_I2C_I2CMDR_STP_MK(0x0001u))
#define _I2C_I2CMDR_STP_CLR		(~(_I2C_I2CMDR_STP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_IDLEEN:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_IDLEEN_SHIFT		(0x000cu)
#define _I2C_I2CMDR_IDLEEN_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_IDLEEN_SHIFT)
#define _I2C_I2CMDR_IDLEEN_MASK		(_I2C_I2CMDR_IDLEEN_MK(0x0001u))
#define _I2C_I2CMDR_IDLEEN_CLR		(~(_I2C_I2CMDR_IDLEEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_STT:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_STT_SHIFT		(0x000du)
#define _I2C_I2CMDR_STT_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_STT_SHIFT)
#define _I2C_I2CMDR_STT_MASK		(_I2C_I2CMDR_STT_MK(0x0001u))
#define _I2C_I2CMDR_STT_CLR		(~(_I2C_I2CMDR_STT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CMDR_FREE:	
\*----------------------------------------------------------------*/

#define _I2C_I2CMDR_FREE_SHIFT		(0x000eu)
#define _I2C_I2CMDR_FREE_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CMDR_FREE_SHIFT)
#define _I2C_I2CMDR_FREE_MASK		(_I2C_I2CMDR_FREE_MK(0x0001u))
#define _I2C_I2CMDR_FREE_CLR		(~(_I2C_I2CMDR_FREE_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2COAR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2COAR	 - Note: Add description here
*
* Fields:
*	(RW)   _I2C_I2COAR_OAR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2COAR_OAR:	
\*----------------------------------------------------------------*/

#define _I2C_I2COAR_OAR_SHIFT		(000000u)
#define _I2C_I2COAR_OAR_MK(n)		(((Uint16)(n) & 0x03ffu) << _I2C_I2COAR_OAR_SHIFT)
#define _I2C_I2COAR_OAR_MASK		(_I2C_I2COAR_OAR_MK(0x03ffu))
#define _I2C_I2COAR_OAR_CLR		(~(_I2C_I2COAR_OAR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2CCLKL register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2CCLKL	 - Note: Add description here
*
* Fields:
*	(RW)   _I2C_I2CCLKL_ICCL	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CCLKL_ICCL:	
\*----------------------------------------------------------------*/

#define _I2C_I2CCLKL_ICCL_SHIFT		(000000u)
#define _I2C_I2CCLKL_ICCL_MK(n)		(((Uint16)(n) & 0xffffu) << _I2C_I2CCLKL_ICCL_SHIFT)
#define _I2C_I2CCLKL_ICCL_MASK		(_I2C_I2CCLKL_ICCL_MK(0xffffu))
#define _I2C_I2CCLKL_ICCL_CLR		(~(_I2C_I2CCLKL_ICCL_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2CDRR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2CDRR	 - Note: Add description here
*
* Fields:
*	(R)   _I2C_I2CDRR_DATA	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CDRR_DATA:	
\*----------------------------------------------------------------*/

#define _I2C_I2CDRR_DATA_SHIFT		(000000u)
#define _I2C_I2CDRR_DATA_MK(n)		(((Uint16)(n) & 0x00ffu) << _I2C_I2CDRR_DATA_SHIFT)
#define _I2C_I2CDRR_DATA_MASK		(_I2C_I2CDRR_DATA_MK(0x00ffu))
#define _I2C_I2CDRR_DATA_CLR		(~(_I2C_I2CDRR_DATA_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the I2CSTR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _I2C_I2CSTR	 - Note: Add description here
*
* Fields:
*	(R)   _I2C_I2CSTR_AL	
*	(R)   _I2C_I2CSTR_NACK	
*	(R)   _I2C_I2CSTR_ARDY	
*	(RW)   _I2C_I2CSTR_RRDY	
*	(R)   _I2C_I2CSTR_XRDY	
*	(R)   _I2C_I2CSTR_AD0	
*	(R)   _I2C_I2CSTR_AAS	
*	(R)   _I2C_I2CSTR_XSMT	
*	(R)   _I2C_I2CSTR_RSFULL	
*	(R)   _I2C_I2CSTR_BB	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CSTR_AL:	
\*----------------------------------------------------------------*/

#define _I2C_I2CSTR_AL_SHIFT		(000000u)
#define _I2C_I2CSTR_AL_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CSTR_AL_SHIFT)
#define _I2C_I2CSTR_AL_MASK		(_I2C_I2CSTR_AL_MK(0x0001u))
#define _I2C_I2CSTR_AL_CLR		(~(_I2C_I2CSTR_AL_MASK))



/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CSTR_NACK:	
\*----------------------------------------------------------------*/

#define _I2C_I2CSTR_NACK_SHIFT		(0x0001u)
#define _I2C_I2CSTR_NACK_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CSTR_NACK_SHIFT)
#define _I2C_I2CSTR_NACK_MASK		(_I2C_I2CSTR_NACK_MK(0x0001u))
#define _I2C_I2CSTR_NACK_CLR		(~(_I2C_I2CSTR_NACK_MASK))



/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CSTR_ARDY:	
\*----------------------------------------------------------------*/

#define _I2C_I2CSTR_ARDY_SHIFT		(0x0002u)
#define _I2C_I2CSTR_ARDY_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CSTR_ARDY_SHIFT)
#define _I2C_I2CSTR_ARDY_MASK		(_I2C_I2CSTR_ARDY_MK(0x0001u))
#define _I2C_I2CSTR_ARDY_CLR		(~(_I2C_I2CSTR_ARDY_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _I2C_I2CSTR_RRDY:	
\*----------------------------------------------------------------*/

#define _I2C_I2CSTR_RRDY_SHIFT		(0x0003u)
#define _I2C_I2CSTR_RRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CSTR_RRDY_SHIFT)
#define _I2C_I2CSTR_RRDY_MASK		(_I2C_I2CSTR_RRDY_MK(0x0001u))
#define _I2C_I2CSTR_RRDY_CLR		(~(_I2C_I2CSTR_RRDY_MASK))



/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CSTR_XRDY:	
\*----------------------------------------------------------------*/

#define _I2C_I2CSTR_XRDY_SHIFT		(0x0004u)
#define _I2C_I2CSTR_XRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CSTR_XRDY_SHIFT)
#define _I2C_I2CSTR_XRDY_MASK		(_I2C_I2CSTR_XRDY_MK(0x0001u))
#define _I2C_I2CSTR_XRDY_CLR		(~(_I2C_I2CSTR_XRDY_MASK))



/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CSTR_AD0:	
\*----------------------------------------------------------------*/

#define _I2C_I2CSTR_AD0_SHIFT		(0x0008u)
#define _I2C_I2CSTR_AD0_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CSTR_AD0_SHIFT)
#define _I2C_I2CSTR_AD0_MASK		(_I2C_I2CSTR_AD0_MK(0x0001u))
#define _I2C_I2CSTR_AD0_CLR		(~(_I2C_I2CSTR_AD0_MASK))



/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CSTR_AAS:	
\*----------------------------------------------------------------*/

#define _I2C_I2CSTR_AAS_SHIFT		(0x0009u)
#define _I2C_I2CSTR_AAS_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CSTR_AAS_SHIFT)
#define _I2C_I2CSTR_AAS_MASK		(_I2C_I2CSTR_AAS_MK(0x0001u))
#define _I2C_I2CSTR_AAS_CLR		(~(_I2C_I2CSTR_AAS_MASK))



/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CSTR_XSMT:	
\*----------------------------------------------------------------*/

#define _I2C_I2CSTR_XSMT_SHIFT		(0x000au)
#define _I2C_I2CSTR_XSMT_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CSTR_XSMT_SHIFT)
#define _I2C_I2CSTR_XSMT_MASK		(_I2C_I2CSTR_XSMT_MK(0x0001u))
#define _I2C_I2CSTR_XSMT_CLR		(~(_I2C_I2CSTR_XSMT_MASK))



/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CSTR_RSFULL:	
\*----------------------------------------------------------------*/

#define _I2C_I2CSTR_RSFULL_SHIFT		(0x000bu)
#define _I2C_I2CSTR_RSFULL_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CSTR_RSFULL_SHIFT)
#define _I2C_I2CSTR_RSFULL_MASK		(_I2C_I2CSTR_RSFULL_MK(0x0001u))
#define _I2C_I2CSTR_RSFULL_CLR		(~(_I2C_I2CSTR_RSFULL_MASK))



/*----------------------------------------------------------------*\
*   (R)  _I2C_I2CSTR_BB:	
\*----------------------------------------------------------------*/

#define _I2C_I2CSTR_BB_SHIFT		(0x000cu)
#define _I2C_I2CSTR_BB_MK(n)		(((Uint16)(n) & 0x0001u) << _I2C_I2CSTR_BB_SHIFT)
#define _I2C_I2CSTR_BB_MASK		(_I2C_I2CSTR_BB_MK(0x0001u))
#define _I2C_I2CSTR_BB_CLR		(~(_I2C_I2CSTR_BB_MASK))


#else
   #ifndef _I2C_MOD_
	#error I2C Hal Module Not Supported on Specified Target
   #endif
#endif  /* _I2C_SUPPORT  */

#endif  /* _CSL_I2CHAL_H  */

/******************************************************************************\
*     
*      End of csl_I2Chal.h 
*
\******************************************************************************/
csl_icachdat.h/ 1051539341  0     0     0       1346      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... ICACHE
* FILENAME...... csl_icachdat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... MCRTE - multichannel runtime environment
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   
*    	CREATED:  03/30/2000
*     MODIFIED: 04/12/2001 Changed FILENAME comment to match filename
*     MODIFIED: 10 April 2003 added reference to CSL_IcacheData for .csldata 
*                             size fix
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the ICACHE module)
*       Reserved Area for ICACHE Data 
*
*
\******************************************************************************/
#ifndef _ICACHE_DATA_H_
#define _ICACHE_DATA_H_
 #define CSL_ICACHEDATAINIT\
  { 0x0000u }

  

  typedef struct {
    Uint16 reserved;
  } CSL_IcacheDataObj;

extern CSL_IcacheDataObj CSL_IcacheData;

#define CSL_ICACHE_DATA  CSL_IcacheData

#endif
csl_icache.h/   1051539340  0     0     0       16032     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... ICACHE
* FILENAME...... csl_icache.h
* DATE CREATED.. Mon 05/22/2000 
* PROJECT....... MCRTE - multichannel runtime environment
* COMPONENT..... CSL service layer
* PREREQUISITS.. csl_icachhal.h, stdinc.h, chiphal.h, csl.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:          05/22/2000
*   MODIFIED:         04/12/2001  Changed FILENAME to match actual name
*   LAST MODIFIED:    01/02/2002  Adapted for Rev 2.1
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface for ICACHE Module)
\******************************************************************************/
#ifndef _ICACHE_H_
#define _ICACHE_H_    

#include <csl_std.h>
#include <csl_chiphal.h>
#include <csl.h>

#if (_ICACHE_SUPPORT)

#include <csl_icachhal.h> 

/****************************************\
* ICACHE scope and inline control macros
\****************************************/

#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _ICACHE_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/****************************************\
* ICACHE global macro declarations
\****************************************/


/* error codes */
#define ICACHE_ERR_MAJOR            (ERR_BASE_ICACHE) 
#define ICACHE_ERR_ALLOC            (0x00000000)
#define ICACHE_ERR_INVALID_HANDLE   (0x00000001)

#if (CHIP_5510) | (CHIP_5510PG2_0)

/******************************************************************************
* ICACHE ICGC Global Control Register Macros
*
*
* Fields:
*   (RW) RMODE
*
\******************************************************************************/



/*---------------------------------------*\
* ICACHE_ICGC_RMK Macros
\*---------------------------------------*/

#define ICACHE_ICGC_RMK(rMode)\
    (Uint16) (ICACHE_FMK(ICGC,RMODE,rMode))

#define ICACHE_ICGC_RMKS(rMode_s)\
    (Uint16) (ICACHE_FMKS(ICGC,RMODE,rMode_s))

/*---------------------------------------*\
* ICGC Field Values
\*---------------------------------------*/


 #define ICACHE_ICGC_RMODE_0RAMSET    (0xCBFFu)
 #define ICACHE_ICGC_RMODE_1RAMSET    (0xCE1Fu)
 #define ICACHE_ICGC_RMODE_2RAMSET    (0xCFFFu)


/******************************************************************************\
* ICACHE ICWC - ICACHE N-Way Control Register Macros
*
* Fields:
*   (RW) WINIT
*
\******************************************************************************/

/*---------------------------------------*\
* ICACHE_ICWC_RMK Macros
\*---------------------------------------*/

#define ICACHE_ICWC_RMK(wInit)\
  (Uint16) ( ICACHE_FMK(ICWC,WINIT,wInit))


#define ICACHE_ICWC_RMKS(wInit_s)\
  (Uint16) ( ICACHE_FMKS(ICWC,WINIT,wInit_s))

/*---------------------------------------*\
* ICWC Field Values
\*---------------------------------------*/


 #define ICACHE_ICWC_WINIT_WINIT    (0xFu)

/******************************************************************************\
* ICACHE ICRC1 - 1/2 RamSet Control Register 1 Macros
*
* Fields:
*   (R ) R1TVALID
*   (RW) R1INIT
*
\******************************************************************************/

/*---------------------------------------*\
* ICACHE_ICRC1_MK Macro
\*---------------------------------------*/

#define ICACHE_ICRC1_RMK(r1Init)\
   (Uint16) ( ICACHE_FMK(ICRC1,R1INIT,r1Init))

#define ICACHE_ICRC1_RMKS(r1Init_s)\
   (Uint16) ( ICACHE_FMKS(ICRC1,R1INIT,r1Init_s))


/*---------------------------------------*\
* ICRC1 Field Values
\*---------------------------------------*/

 #define ICACHE_ICRC1_R1TVALID_NO    (0x0u)
 #define ICACHE_ICRC1_R1TVALID_YES    (0x1u)
 #define ICACHE_ICRC1_R1INIT_INIT    (0x3u)


/******************************************************************************\
* ICACHE ICRC2 - 1/2 RamSet Control Register 2 Macros
*
* Fields:
*   (R ) R2TVALID
*   (RW) R2INIT
*
\******************************************************************************/

/*---------------------------------------*\
* ICACHE_ICRC2_MK Macro
\*---------------------------------------*/

#define ICACHE_ICRC2_RMK(r2Init)\
   (Uint16) ( ICACHE_FMK(ICRC2,R2INIT,r2Init))

#define ICACHE_ICRC2_RMKS(r2Init_s)\
   (Uint16) ( ICACHE_FMKS(ICRC2,R2INIT,r2Init_s))

/*---------------------------------------*\
* ICRC2 Field Values
\*---------------------------------------*/

 #define ICACHE_ICRC1_R2TVALID_NO    (0x0u)
 #define ICACHE_ICRC1_R2TVALID_YES    (0x1u)
 #define ICACHE_ICRC2_R2INIT_INIT    (0x3u)

/******************************************************************************\
* ICACHE ICRTAG1 - ICACHE 1/2 Ram-set Tag Register 1 Macros
*
* Fields:
*   (RW) R1TAG
*
\******************************************************************************/


/*---------------------------------------*\
* ICACHE_ICRTAG1_MK Macro
\*---------------------------------------*/

#define ICACHE_ICRTAG1_RMK(r1tag)\
           (Uint16) (ICACHE_FMK(ICRTAG1,R1TAG,r1tag))

/*---------------------------------------*\
* ICRTAG1 Field Values
\*---------------------------------------*/

#define ICACHE_ICRTAG1_R1TAG_OF(x)         ((Uint16)(x))

/******************************************************************************\
* ICACHE ICRTAG2 - ICACHE 1/2 Ram-set Tag Register 2 Macros
*
* Fields:
*   (RW) R2TAG
*
\******************************************************************************/

/*---------------------------------------*\
* ICACHE_ICRTAG2_MK Macro
\*---------------------------------------*/

#define ICACHE_ICRTAG2_RMK(r2tag)\
           (Uint16) (ICACHE_FMK(ICRTAG2,R2TAG,r2tag))

/*---------------------------------------*\
* ICRTAG2 Field Values
\*---------------------------------------*/

#define ICACHE_ICRTAG2_R2TAG_OF(x)         ((Uint16)(x))


/******************************************************************************\
* ICACHE ICST - ICACHE Status Register
*
* Fields:
*   (R) IEN
*
\******************************************************************************/

/*---------------------------------------*\
* ICST Field Values
\*---------------------------------------*/

#define ICACHE_ICST_IEN_ENABLED         (0x1u)
#define ICACHE_ICST_IEN_DISABLED         (0x0u)


/*******************************************\
* ICACHE global macro definition : ROMABILITY
\*******************************************/  
/* Reserved ROM Area by icachedata.h */

#define ICache_Initialized           ICACHE_SYM(0)


/****************************************\
* ICACHE type definitions
\****************************************/

typedef struct
{
   Uint16              rmode;
   Uint32              r1addr;
   Uint32              r2addr;
} ICACHE_Setup;

typedef struct
{
   Uint16              rmode;
   Uint32              r1addr;
   Uint32              r2addr;
} ICACHE_Init;

typedef struct
{
   Uint32              r1addr;
   Uint32              r2addr;
} ICACHE_Tagset;


typedef struct {
Uint16 icgc;
Uint16 icwc;
Uint16 icrc1;
Uint16 icrtag1;
Uint16 icrc2;
Uint16 icrtag2;
} ICACHE_Config;



#endif

#if CHIP_5502

/******************************************************************************
* ICACHE ICGC Global Control Register Macros
*
* Fields:
*   (RW) _ICACHE_ICGC_FLUSHLINE
*
\******************************************************************************/


/*---------------------------------------*\
* ICACHE_ICGC_RMK Macros
\*---------------------------------------*/

#define ICACHE_ICGC_RMK(flushLine)\
    (Uint16) (ICACHE_FMK(ICGC,FLUSHLINE,flushLine)|\
)

#define ICACHE_ICGC_RMKS(flushLine_s)\
    (Uint16) (ICACHE_FMKS(ICGC,FLUSHLINE,flushLine_s)|\
)


/******************************************************************************\
* _ICACHE_ICFLARL - ICache Flush Line Address Low Register 
*
* Fields:
*   (RW) _ICACHE_ICFLARL_LAL
*
\******************************************************************************/


/*---------------------------------------*\
* CACHE_ICFLARL_RMK Macros
\*---------------------------------------*/

#define ICACHE_ICFLARL_RMK(lal)\
       (Uint16)(ICACHE_FMK(ICFLARL,LAL,lal))

#define ICACHE_ICFLARL_RMKS(lal_s)\
       (Uint16)(ICACHE_FMKS(ICFLARL,LAL,lal_s))



/******************************************************************************\
* _ICACHE_ICFLARH - ICache Flush Line Address High Register 
*
* Fields:
*   (RW) _ICACHE_ICFLARL_LAH
*
\******************************************************************************/


/*---------------------------------------*\
* ICACHE_ICFLARH_RMK Macros
\*---------------------------------------*/

#define ICACHE_ICFLARH_RMK(lah)\
       (Uint16)(ICACHE_FMK(ICFLARH,LAH,lah))

#define ICACHE_ICFLARH_RMKS(lah_s)\
       (Uint16)(ICACHE_FMKS(ICFLARH,LAH,lah_s))



/******************************************************************************\
* _ICACHE_ICWMC - ICACHE N-Way Miss Counter Register
*
* Fields:
*
*   (RW ) _ICACHE_ICWMC_MISSCNT
*
\******************************************************************************/


/*---------------------------------------*\
* ICACHE_ICWMC_RMK Macros
\*---------------------------------------*/

#define ICACHE_ICWMC_RMK(missCnt)\
       (Uint16)(ICACHE_FMK(ICWMC,MISSCNT,missCnt))

#define ICACHE_ICWMC_RMKS(missCnt_s)\
       (Uint16)(ICACHE_FMKS(ICWMC,MISSCNT,missCnt_s))



/*******************************************\
* ICACHE global macro definition : ROMABILITY
\*******************************************/  
/* Reserved ROM Area by cachedata.h */

#define ICache_Initialized           CACHE_SYM(0)



/****************************************\
* ICACHE type definitions
\****************************************/


typedef struct {
Uint16 icgc;

} ICACHE_Config;


#endif

/****************************************\
* ICACHE global function declarations
\****************************************/

IDECL  void ICACHE_enable();
IDECL  void ICACHE_disable();
IDECL  void ICACHE_flush();
IDECL  void ICACHE_freeze();
IDECL  void ICACHE_unfreeze();
IDECL  void ICACHE_config(ICACHE_Config *Config);

#if (CHIP_5510) | (CHIP_5510PG2_0)
IDECL  void ICACHE_setup(ICACHE_Setup *params);
IDECL  void ICACHE_init(ICACHE_Init *params);
IDECL  void ICACHE_tagset(ICACHE_Tagset *params);
IDECL  void ICACHE_configArgs(Uint16 icgc, Uint16 icwc, Uint16 icrc1, Uint16 icrtag1,\
                         Uint16 icrc2, Uint16 icrtag2);
#endif 


#if CHIP_5502
IDECL  void ICACHE_setup();
IDECL  void ICACHE_configArgs(Uint16 icgc);
#endif


/****************************************\
* ICACHE Inline Functions
\****************************************/
#ifdef  USEDEFS


/*----------------------------------------------------------------------------*/
IDEF  void ICACHE_unfreeze()
	{
	CHIP_FSET(ST3_55,CAFRZ,0);  
	}


/*----------------------------------------------------------------------------*/
IDEF  void ICACHE_freeze()
	{
	CHIP_FSET(ST3_55,CAFRZ,1);  
	}

/*----------------------------------------------------------------------------*/
IDEF  void ICACHE_flush()
	{
	CHIP_FSET(ST3_55,CACLR,1);   
	}

/*----------------------------------------------------------------------------*/
IDEF  void ICACHE_disable()
	{
	CHIP_FSET(ST3_55,CAEN,0);    
	}

/*----------------------------------------------------------------------------*/
IDEF  void ICACHE_enable()
	{
	CHIP_FSET(ST3_55,CAEN,1);    
	}
/*----------------------------------------------------------------------------*/

#if (CHIP_5510) | (CHIP_5510PG2_0)

IDEF  void ICACHE_setup(ICACHE_Setup *params)
	{
	
	Uint16 r1tag, r2tag;
   /* Set Ramset Mode in GCR register */

	ICACHE_RSET(ICGC, params -> rmode);
	
   /* Initialize Ramset N-Way Control Registers*/
   
   	ICACHE_FSET(ICWC,WINIT, ICACHE_ICWC_WINIT_WINIT);
   	ICACHE_FSET(ICRC1,R1INIT, ICACHE_ICRC1_R1INIT_INIT);
  	ICACHE_FSET(ICRC2,R2INIT,ICACHE_ICRC2_R2INIT_INIT);    	
   /* Enable ICACHE */
	CHIP_FSET(ST3_55,CAEN,1);  

   /* Poll to validate enable */	
    	while(!ICACHE_FGET(ICST, IEN));

   /* Initialize tags according to rmode values */

   if ((params -> rmode) == ICACHE_ICGC_RMODE_1RAMSET)		/* 1 RAMSET */
	{ 	
	
	   r1tag = (Uint16)(((params -> r1addr)>>12)&0x0FFFu);
	   ICACHE_FSET(ICRTAG1, R1TAG, r1tag);
	   while(!ICACHE_FGET(ICRC1, R1TVALID));

  	} 

   if ((params -> rmode) == ICACHE_ICGC_RMODE_2RAMSET)		/* 2 RAMSET */
	{ 
	
	 r1tag = (Uint16)(((params -> r1addr)>>12)&0x0FFFu);
	 r2tag = (Uint16)(((params -> r2addr)>>12)&0x0FFFu);	
	   ICACHE_FSET(ICRTAG1, R1TAG, r1tag);
	   while(!ICACHE_FGET(ICRC1, R1TVALID));
	   ICACHE_FSET(ICRTAG2, R2TAG, r2tag);
	   while(!ICACHE_FGET(ICRC2, R2TVALID));

  	}

   if ((params -> rmode) == ICACHE_ICGC_RMODE_0RAMSET)		/* 0 RAMSET */
      {}

}

/*----------------------------------------------------------------------------*/

	IDEF  void ICACHE_tagset(ICACHE_Tagset *params)
	{
	Uint16	rmode;
	Uint16 r1tag, r2tag;
    rmode = ICACHE_RGET(ICGC);

   /* Initialize tags according to rmode values */

   if (rmode == ICACHE_ICGC_RMODE_1RAMSET )		/* 1 RAMSET */
	{ 	
	
	   r1tag = (Uint16)(((params -> r1addr)>>12)&0x0FFFu);
	   ICACHE_FSET(ICRTAG1, R1TAG, r1tag);
	   while(ICACHE_FGET(ICRC1, R1TVALID));

  	} 

   if (rmode == ICACHE_ICGC_RMODE_2RAMSET)		/* 2 RAMSET */
	{ 	
	
	   r1tag = (Uint16)(((params -> r1addr)>>12)&0x0FFFu);
	   r2tag = (Uint16)(((params -> r2addr)>>12)&0x0FFFu);
	   ICACHE_FSET(ICRTAG1, R1TAG, r1tag);
	   while(ICACHE_FGET(ICRC1, R1TVALID));
	   ICACHE_FSET(ICRTAG2, R2TAG, r2tag);
	   while(ICACHE_FGET(ICRC2, R2TVALID));

  	}

}

/*----------------------------------------------------------------------------*/

IDEF void ICACHE_config(ICACHE_Config *Config) 
	{

	ICACHE_RSET(ICGC, Config -> icgc);      
        ICACHE_RSET(ICWC, Config -> icwc);
        ICACHE_RSET(ICRC1, Config -> icrc1);
	ICACHE_RSET(ICRTAG1, Config -> icrtag1);
        ICACHE_RSET(ICRC2, Config -> icrc2);
        ICACHE_RSET(ICRTAG2, Config -> icrtag2);
	}

/*----------------------------------------------------------------------------*/


IDEF void ICACHE_configArgs(Uint16 icgc, Uint16 icwc, Uint16 icrc1, Uint16 icrtag1, Uint16 icrc2, Uint16 icrtag2) 
{

	ICACHE_RSET(ICGC, icgc);     
        ICACHE_RSET(ICWC, icwc);
        ICACHE_RSET(ICRC1, icrc1);
	 ICACHE_RSET(ICRTAG1, icrtag1);
        ICACHE_RSET(ICRC2, icrc2);
        ICACHE_RSET(ICRTAG2, icrtag2);


}

#endif 

#if CHIP_5502

IDEF  void ICACHE_setup()
	{


}

IDEF void ICACHE_config(ICACHE_Config *Config) 
	{

	ICACHE_RSET(ICGC, Config -> icgc);      
	}

/*----------------------------------------------------------------------------*/


IDEF void ICACHE_configArgs(Uint16 icgc) 
{
	ICACHE_RSET(ICGC, icgc);     
}

#endif /*5502 */

#endif /*USEDEFS */


#else

     #ifndef _ICACHE_MOD_
     #error ICACHE Module Not Supported on Specified Target
     #endif

#endif /* _ICACHE_SUPPORT */

#endif /* _ICACHE_H_ */
/******************************************************************************\
* End of csl_icache.h
\******************************************************************************/

csl_icachhal.h/ 1049976894  0     0     0       14690     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... ICACHE
* FILENAME...... csl_icachhal.h
* DATE CREATED.. Thu 08/19/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:          08/19/1999 Created
*   MODIFIED:         05/11/2000 modified for TMS320C55xx
*   LAST MODIFIED:    04/12/2001 changed FILENAME to match actual filename
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the CHIP module)
* 
* ICACHE Control Registers Covered
*   _ICACHE_ICGC  - ICACHE global control register
*   _ICACHE_ICWC  - ICACHE N-way control register
*   _ICACHE_ICST  - ICACHE Status Register
*   _ICACHE_ICRC1 - ICACHE 1/2 ram-set 1 control register
*   _ICACHE_ICRTAG1 - ICACHE 1/2 ram-set 1 tag register
*   _ICACHE_ICRC2 - ICACHE 1/2 ram-set 2 control register
*   _ICACHE_ICRTAG2 - ICACHE 1/2 ram-set 2 tag register
\******************************************************************************/

#ifndef _ICACHEHAL_H_
#define _ICACHEHAL_H_
/****************************************\
* include files
\****************************************/    
#include <csl_chiphal.h>
#include <csl_std.h>
#include <csl_stdhal.h>

#if (_ICACHE_SUPPORT)

/*============================================================================*\
* Generic ICACHE register/field get/set macros
\*============================================================================*/

#define ICACHE_ADDR(Reg)                   _ICACHE_##Reg##_ADDR
#define ICACHE_RGET(Reg)                   _PREG_GET(ICACHE_ADDR(##Reg))
#define ICACHE_RSET(Reg,Val)               _PREG_SET(ICACHE_ADDR(##Reg),Val)
#define ICACHE_RAOI(Reg,AND,OR,INV)        _PREG_AOI(ICACHE_ADDR(##Reg),AND,OR,INV)
#define ICACHE_FGET(Reg,Field)             _PFIELD_GET(ICACHE_ADDR(##Reg),_ICACHE_##Reg##_##Field)

#define ICACHE_FSET(Reg,Field,Val)\
   _PFIELD_SET(ICACHE_ADDR(##Reg),_ICACHE_##Reg##_##Field,Val)

#define ICACHE_FSETS(Reg,Field,Sym)\
   ICACHE_FSET(##Reg,##Field,ICACHE_##Reg##_##Field##_##Sym)

#define ICACHE_FAOI(Reg,Field,AND,OR,INV)\
   _PFIELD_AOI(ICACHE_ADDR(##Reg),_ICACHE_##Reg##_##Field,AND,OR,INV)

#define ICACHE_FMK(Reg,Field,Val)          _ICACHE_##Reg##_##Field##_MK(Val)

#define ICACHE_FMKS(Reg,Field,Sym)\
  ICACHE_FMK(##Reg,##Field,ICACHE_##Reg##_##Field##_##Sym)

#if (CHIP_5510) | (CHIP_5510PG2_0)

/******************************************************************************\
* _ICACHE_ICGC - Icache global control register
*
* Fields:
*   (RW) _ICACHE_ICGC_RMODE	
*
\******************************************************************************/
#define _ICACHE_ICGC_ADDR    (0x1400u)
#define _ICACHE_ICGC          PREG16(_ICACHE_ICGC_ADDR)
#define _ICGC                 _ICACHE_ICGC


/*----------------------------------------------------------------------------*\
* (RW) _ICACHE_ICGC_RMODE :  Ramset Mode Configuration
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICGC_RMODE_SHIFT        (0x0000u)
#define _ICACHE_ICGC_RMODE_MK(n)        (((Uint16)n & 0xFFFFu) << _ICACHE_ICGC_RMODE_SHIFT)
#define _ICACHE_ICGC_RMODE_MASK         (_ICACHE_ICGC_RMODE_MK(0xFFFFu))
#define _ICACHE_ICGC_RMODE_CLR          (~(_ICACHE_ICGC_RMODE_MASK))

#define _ICACHE_ICGC_CFG(rmode)\
  _PREG_SET(_ICACHE_ICGC_ADDR, _ICACHE_ICGC_RMODE_MK(rmode))

   
/******************************************************************************\
* _ICACHE_ICWC - ICache N-Way Control Register ICWC
*
* Fields:
*   (RW) _ICACHE_ICWC_WINIT
*
\******************************************************************************/
#define _ICACHE_ICWC_ADDR    (0x1403u)
#define _ICACHE_ICWC         PREG16(_ICACHE_ICWC_ADDR)
#define _ICWC                _ICACHE_ICWC


/*----------------------------------------------------------------------------*\
* (RW) _ICACHE_ICWC_WINIT : N-way mask init
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICWC_WINIT_SHIFT           (0x0000u)
#define _ICACHE_ICWC_WINIT_MK(n)           (((Uint16)n & 0x000Fu) << _ICACHE_ICWC_WINIT_SHIFT)
#define _ICACHE_ICWC_WINIT_MASK            (_ICACHE_ICWC_WINIT_MK(0x000Fu))
#define _ICACHE_ICWC_WINIT_CLR             (~(_ICACHE_ICWC_WINIT_MASK))

#define _ICACHE_ICWC_CFG(winit)\
  _PREG_SET(_ICACHE_ICWC_ADDR, _ICACHE_ICWC_WINIT_MK(winit))


/******************************************************************************\
* _ICACHE_ICRC - 1/2 RamSet Control Register 1 & 2
*
* Fields:
*   (R ) _ICACHE_ICRC1_R1&2TVALID
*   (RW) _ICACHE_ICRC1_R1&2INIT
*
\******************************************************************************/
#define _ICACHE_ICRC1_ADDR    (0x1405u)
#define _ICACHE_ICRC1         PREG16(_ICACHE_ICRC1_ADDR)
#define _ICRC1                _ICACHE_ICRC1

#define _ICACHE_ICRC2_ADDR    (0x1407u)
#define _ICACHE_ICRC2         PREG16(_ICACHE_ICRC2_ADDR)
#define _ICRC2                _ICACHE_ICRC2

/*----------------------------------------------------------------------------*\
* (R) _ICACHE_ICRC1_R1TVALID : Tag Valid flag
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICRC1_R1TVALID_SHIFT  (0x000Fu)
#define _ICACHE_ICRC1_R1TVALID_MK(n)  (((Uint16)n & 0x0001u) << _ICACHE_ICRC1_R1TVALID_SHIFT)
#define _ICACHE_ICRC1_R1TVALID_MASK   (_ICACHE_ICRC1_R1TVALID_MK(0x0001u))

/*----------------------------------------------------------------------------*\
* (RW) _ICACHE_ICRC1_R1INIT : Ramset 1 init mask
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICRC1_R1INIT_SHIFT           (0x0000u)
#define _ICACHE_ICRC1_R1INIT_MK(n)           (((Uint16)n & 0x0003u) << _ICACHE_ICRC1_R1INIT_SHIFT)
#define _ICACHE_ICRC1_R1INIT_MASK            (_ICACHE_ICRC1_R1INIT_MK(0x0003u))
#define _ICACHE_ICRC1_R1INIT_CLR             (~(_ICACHE_ICRC1_R1INIT_MASK))


/*----------------------------------------------------------------------------*\
* (RW) _ICACHE_ICRC2_R2TVALID : Tag Valid flag
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICRC2_R2TVALID_SHIFT  (0x000Fu)
#define _ICACHE_ICRC2_R2TVALID_MK(n)  (((Uint16)n & 0x0001u) << _ICACHE_ICRC2_R2TVALID_SHIFT)
#define _ICACHE_ICRC2_R2TVALID_MASK   (_ICACHE_ICRC2_R2TVALID_MK(0x0001u))

/*----------------------------------------------------------------------------*\
* (RW) _ICACHE_ICRC2_R2INIT : Ramset 2 init mask
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICRC2_R2INIT_SHIFT           (0x0000u)
#define _ICACHE_ICRC2_R2INIT_MK(n)           (((Uint16)n & 0x0003u) << _ICACHE_ICRC2_R2INIT_SHIFT)
#define _ICACHE_ICRC2_R2INIT_MASK            (_ICACHE_ICRC2_R2INIT_MK(0x0003u))
#define _ICACHE_ICRC2_R2INIT_CLR             (~(_ICACHE_ICRC2_R2INIT_MASK))



#define _ICACHE_ICRC1_CFG(r1init)\
  _PREG_SET(_ICACHE_ICRC1_ADDR,_ICACHE_ICRC1_R1INIT_MK(r1init))

#define _ICACHE_ICRC2_CFG(r2init)\
  _PREG_SET(_ICACHE_ICRC2_ADDR,_ICACHE_ICRC2_R2INIT_MK(r2init))



/******************************************************************************\
* _ICACHE_ICRTAG1 - ICACHE 1/2 Ram-set Tag Register 1 & 2
*
* Fields:
*   (RW) _ICACHE_ICRTAG1_R1TAG
*
\******************************************************************************/
#define _ICACHE_ICRTAG1_ADDR    (0x1406u)
#define _ICACHE_ICRTAG1         PREG16(_ICACHE_ICRTAG1_ADDR)
#define _ICRTAG1                _ICACHE_ICRTAG1

#define _ICACHE_ICRTAG2_ADDR    (0x1408u)
#define _ICACHE_ICRTAG2         PREG16(_ICACHE_ICRTAG2_ADDR)
#define _ICRTAG2                _ICACHE_ICRTAG2

/*----------------------------------------------------------------------------*\
* (RW) _ICACHE_ICRTAG1_R1TAG : Tag
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICRTAG1_R1TAG_SHIFT            (0x0000u)
#define _ICACHE_ICRTAG1_R1TAG_MK(n)            (((Uint16)n & 0x7FFFu) << _ICACHE_ICRTAG1_R1TAG_SHIFT)
#define _ICACHE_ICRTAG1_R1TAG_MASK             (_ICACHE_ICRTAG1_R1TAG_MK(0x7FFFu))
#define _ICACHE_ICRTAG1_R1TAG_CLR              (~(_ICACHE_ICRTAG1_R1TAG_MASK))

/*----------------------------------------------------------------------------*\
* (RW) _ICACHE_ICRTAG_R2TAG : Tag
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICRTAG2_R2TAG_SHIFT            (0x0000u)
#define _ICACHE_ICRTAG2_R2TAG_MK(n)            (((Uint16)n & 0x7FFFu) << _ICACHE_ICRTAG2_R2TAG_SHIFT)
#define _ICACHE_ICRTAG2_R2TAG_MASK             (_ICACHE_ICRTAG2_R2TAG_MK(0x7FFFu))
#define _ICACHE_ICRTAG2_R2TAG_CLR              (~(_ICACHE_ICRTAG2_R2TAG_MASK))


#define _ICACHE_ICRTAG1_CFG(r1tag)\
  _PREG_SET(_ICACHE_ICRTAG1_ADDR, _ICACHE_ICRTAG1_R1TAG_MK(r1tag))

#define _ICACHE_ICRTAG2_CFG(r2tag)\
  _PREG_SET(_ICACHE_ICRTAG2_ADDR, _ICACHE_ICRTAG2_R2TAG_MK(r2tag))



/******************************************************************************\
* _ICACHE_ICST - ICACHE Status Register ICST
*
* Fields:
*   (R ) _ICACHE_ICST_IEN
*
\******************************************************************************/
#define _ICACHE_ICST_ADDR    (0x1404u)
#define _ICACHE_ICST         PREG16(_ICACHE_ICST_ADDR)
#define _ICST                _ICACHE_ICST

/*----------------------------------------------------------------------------*\
* (R) _ICACHE_ICST_IEN : Enable
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICST_IEN_SHIFT          (0x0002u)
#define _ICACHE_ICST_IEN_MK(n)          (((Uint16)n & 0x0001u) << _ICACHE_ICST_IEN_SHIFT)
#define _ICACHE_ICST_IEN_MASK           (_ICACHE_ICST_IEN_MK(0x0001u))


#endif

#if CHIP_5502

/******************************************************************************\
* _ICACHE_ICGC - ICACHE global control register
*
* Fields:
*   (RW) _ICACHE_ICGC_FLUSHLINE
*
\******************************************************************************/
#define _ICACHE_ICGC_ADDR    (0x1400u)
#define _ICACHE_ICGC          PREG16(_ICACHE_ICGC_ADDR)
#define _ICGC                 _ICACHE_ICGC


/*----------------------------------------------------------------------------*\
* (RW) _ICACHE_ICGC_FLUSHLINE : Flush line specified in Flush Line Addr Register
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICGC_FLUSHLINE_SHIFT        (0x000Cu)
#define _ICACHE_ICGC_FLUSHLINE_MK(n)        (((Uint16)n & 0x0001u) << _ICACHE_ICGC_FLUSHLINE_SHIFT)
#define _ICACHE_ICGC_FLUSHLINE_MASK         (_ICACHE_ICGC_FLUSHLINE_MK(1))
#define _ICACHE_ICGC_FLUSHLINE_CLR          (~(_ICACHE_ICGC_FLUSHLINE_MASK))


/******************************************************************************\
* _ICACHE_ICFLARL - ICACHE Flush Line Address Low Register 
*
* Fields:
*   (RW) _ICACHE_ICFLARL_LAL
*
\******************************************************************************/
#define _ICACHE_ICFLARL_ADDR    (0x1401u)
#define _ICACHE_ICFLARL         PREG16(_ICACHE_ICFLARL_ADDR)
#define _ICFLARL                _ICACHE_ICFLARL

/*----------------------------------------------------------------------------*\
* (RW) _ICACHE_ICFLARL_LAL : Lower 16 bits of line address to flush
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICFLARL_LAL_SHIFT     (0x0000u)
#define _ICACHE_ICFLARL_LAL_MK(n)     (((Uint16)n & 0xFFFFu) << _ICACHE_ICFLARL_LAL_SHIFT)
#define _ICACHE_ICFLARL_LAL_MASK      (_ICACHE_ICFLARL_LAL_MK(0xFFFFu))
#define _ICACHE_ICFLARL_LAL_CLR       (~(_ICACHE_ICFLARL_LAL_MASK))

#define _ICACHE_ICFLARL_CFG(lineAddress)\
  _PREG_SET(_ICACHE_ICFLARL_ADDR, _ICACHE_ICFLARL_LAL_MK(lineAddress))

/******************************************************************************\
* _ICACHE_ICFLARH - ICACHE Flush Line Address High Register 1 
*                  (Upper 8 bits of flush line address)
*
* Fields:
*   (RW) _ICACHE_ICFLARH_LAH
*
\******************************************************************************/
#define _ICACHE_ICFLARH_ADDR    (0x1402u)
#define _ICACHE_ICFLARH         PREG16(_ICACHE_ICFLARH_ADDR)
#define _ICFLARH                _ICACHE_ICFLARH

/*----------------------------------------------------------------------------*\
* (RW) _ICACHE_ICFLARH_LAH : Upper 8 bits of line address to flush
\*----------------------------------------------------------------------------*/ 
#define _ICACHE_ICFLARH_LAH_SHIFT     (0x0000u)
#define _ICACHE_ICFLARH_LAH_MK(n)     (((Uint16)n & 0x00FFu) << _ICACHE_ICFLARH_LAH_SHIFT)
#define _ICACHE_ICFLARH_LAH_MASK      (_ICACHE_ICFLARH_LAH_MK(0x00FFu))
#define _ICACHE_ICFLARH_LAH_CLR       (~(_ICACHE_ICFLARH_LAH_MASK))

/******************************************************************************\
* _ICACHE_ICWMC - ICACHE N-Way Miss Counter Register
*
* Fields:
*
*   (RW ) _ICACHE_ICWMC_MISSCNT
*
\******************************************************************************/
#define _ICACHE_ICWMC_ADDR    (0x1409u)
#define _ICACHE_ICWMC         PREG16(_ICACHE_ICWMC_ADDR)
#define _ICWMC                _ICACHE_ICWMC

/*----------------------------------------------------------------------------*\
* (RW) _ICACHE_ICWMC_MISSCNT
\*----------------------------------------------------------------------------*/
#define _ICACHE_ICWMC_MISSCNT_SHIFT      (0x0000u)
#define _ICACHE_ICWMC_MISSCNT_MK(n)      (((Uint16)(n) & 0xffffu)<< _ICACHE_ICWMC_MISSCNT_SHIFT)
#define _ICACHE_ICWMC_MISSCNT_MASK       (_ICACHE_ICWMC_MISSCNT_MK(0xffffu))
#define _ICACHE_ICWMC_MISSCNT_CLR        (~(_ICACHE_ICWMC_MISSCNT_MASK))

#define _ICACHE_ICWMC_CFG(missCnt)\
  _PREG_SET(_ICACHE_ICWMC_ADDR, _ICACHE_ICWMC_MISSCNT_MK(missCnt))

#endif




#else

     #ifndef _ICACHE_MOD_
     #error ICACHE Module Not Supported on Specified Target
     #endif

#endif /* _ICACHE_SUPPORT */
#endif /* _ICACHEHAL_H_ */
/******************************************************************************\
* End of csl_icachhal.h
\******************************************************************************/

csl_irq.h/      1051539339  0     0     0       11859     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME......  csl_irq.h
*-------------------------------------------------------------------------------
* HISTORY
*   CREATED  07/10/2000
*   MODIFIED 03/22/2001
*   MODIFIED 06/28/2001 updated to support new CSL initialization model
*   MODIFIED 08/01/2001 removed IVPH from irq_setvecs function def and added
*                       support for 5509 interrupts (I2C,USB,RTC,ADC,...)
*   MODIFIED 01/18/2002 fixed IRQ mapping problem for INT1
*   MODIFIED 02/15/2002 added support for 5502 (setPriority)
*   MODIFIED 10 April 2003 added #include for csl_irqdat.h
\******************************************************************************/
#ifndef _CSL_IRQ_H_
#define _CSL_IRQ_H_

#include <_csl.h>
#include <csl_irqhal.h>
#include <csl_irqdat.h>


#if (_IRQ_SUPPORT)
/****************************************\
* IRQ scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern
#endif 

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _IRQ_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/****************************************\
* IRQ global macro declarations
\****************************************/
/* misc global settings */

#define IRQ_GIEROUTINES_IN_ASSEMBLY 0
#define IRQ_EVENT_NOT_MAPPED_ERROR  0x00001u

/*Hardware Interrupts */
#define IRQ_EVT_RESET        (0)
#define IRQ_EVT_NMI          (1)

#define IRQ_EVT_INT0         (2)
#define IRQ_EVT_INT2         (3)
#define IRQ_EVT_TINT0        (4)
#define IRQ_EVT_RINT0        (5)
#define IRQ_EVT_RINT1        (6)

#define IRQ_EVT_XINT1        (7)
#define IRQ_EVT_MMC0         (7)
#define IRQ_EVT_MST0         (7)

#define IRQ_EVT_USB          (8)
#define IRQ_EVT_LCKINT       (8)

#define IRQ_EVT_DMAC1        (9)
#define IRQ_EVT_DSPINT       (10)

#define IRQ_EVT_INT3         (11)
#define IRQ_EVT_WDTIM        (11)
#define IRQ_EVT_TINT2        (11)

#define IRQ_EVT_RINT2        (12)
#define IRQ_EVT_UART         (12)

#define IRQ_EVT_XINT2        (13)
#define IRQ_EVT_MMC1         (13)
#define IRQ_EVT_MST1         (13)

#define IRQ_EVT_DMAC4        (14)
#define IRQ_EVT_DMAC5        (15)
#define IRQ_EVT_INT1         (16)
#define IRQ_EVT_XINT0        (17)
#define IRQ_EVT_DMAC0        (18)

#define IRQ_EVT_INT4         (19)
#define IRQ_EVT_RTC          (19)

#define IRQ_EVT_DMAC2        (20)
#define IRQ_EVT_DMAC3        (21)
#define IRQ_EVT_TINT1        (22)

#define IRQ_EVT_INT5         (23)
#define IRQ_EVT_I2C          (23)

  
/* Mask for IMR and IFR */
#define IRQ_MASK_NA (0x0000)
#define IRQ_MASK_00 (0x0001)
#define IRQ_MASK_01 (0x0002)
#define IRQ_MASK_02 (0x0004)
#define IRQ_MASK_03 (0x0008)
#define IRQ_MASK_04 (0x0010)
#define IRQ_MASK_05 (0x0020)
#define IRQ_MASK_06 (0x0040)
#define IRQ_MASK_07 (0x0080)
#define IRQ_MASK_08 (0x0100)
#define IRQ_MASK_09 (0x0200)
#define IRQ_MASK_10 (0x0400)
#define IRQ_MASK_11 (0x0800)
#define IRQ_MASK_12 (0x1000)
#define IRQ_MASK_13 (0x2000)
#define IRQ_MASK_14 (0x4000)
#define IRQ_MASK_15 (0x8000) 

/* Mask for IERMASK for DSPBIOS Dispatch Table */
#define IRQ_IEMASK_ALL      (0x0000FFFFu)
#define IRQ_IEMASK_SELF     (0x80000000u)
#define IRQ_IEMASK_DEFAULT  IRQ_IEMASK_DEFAULT

/* Macro for Converting Data Addresses for Vector Table */
#define IRQ_DAT2PRG(n)      ((Uint32)n<<2)

/* Allows to mask the bit "x"*/
/* of IFR or IMR registers */ 
#define IRQ_MASK32(x)          ((Uint32)(0x1ul<<x))     
#define IRQ_MASK16(x)          ((Uint16)(0x1ul<<x))  
#define IRQ_IER_MASK(x)        (IRQ_MASK32(x))   

#define _IRQ_DISPATCHTBL_CNT   (IRQ_EVENT_CNT+1)
#define _IRQ_EVENT2INTTBL_CNT  (IRQ_EVENT_CNT+1)
#define _IRQ_INT2EVENTTBL_CNT  (IRQ_INT_CNT)

/****************************************\
* IRQ global typedef declarations
\****************************************/


/****************************************\
* IRQ global typedef declarations
\****************************************/

typedef struct {
IRQ_IsrPtr funcAddr;
Uint32 ierMask;
Uint32 cacheCtrl;
Uint32 funcArg;
} IRQ_Config;



/****************************************\
* IRQ global variable declarations
\****************************************/

CSLAPI CSLInt  IRQ_plug(Uint16 EventId, IRQ_IsrPtr funcAddr);
CSLAPI CSLInt  _IRQ_plug(Uint16 EventId, IRQ_IsrPtr funcAddr);


/****************************************\
* IRQ inline function declarations
\****************************************/
IDECL void    IRQ_clear(Uint16 EventId);
IDECL void    IRQ_config(Uint16 EventId, IRQ_Config *Config);
IDECL void    IRQ_configArgs(Uint16 EventId, IRQ_IsrPtr funcAddr, Uint32 funcArg , Uint32 ierMask, Uint32 cacheCtrl);
IDECL int     IRQ_disable(Uint16 EventId);
IDECL int     IRQ_enable(Uint16 EventId);
IDECL void    IRQ_restore(Uint16 EventId, Uint16 Old_flag);
IDECL Uint32  IRQ_getArg(Uint16 EventId);
IDECL void    IRQ_getConfig(Uint16 EventId, IRQ_Config *Config);
CSLAPI int    IRQ_globalDisable();
CSLAPI int    IRQ_globalEnable();
CSLAPI void   IRQ_globalRestore(int gie);
IDECL void    _IRQ_init(_IRQ_Dispatch *dispatch_table, Uint16 bios_present);

IDECL void    IRQ_map(Uint16 EventId);
IDECL void    IRQ_setArg(Uint16 EventId, Uint32 val);
IDECL int     IRQ_setVecs(Uint32 Ivpd);
IDECL CSLBool IRQ_test(Uint16 EventId);

/****************************************\
* IRQ inline function definitions
\****************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
  IDEF int IRQ_enable(Uint16 EventId) {
   Uint16 bit,reg,prev,value,mask;
   int old_intm, old_flag;

   bit= EventId & 0xfu; 
   reg=((EventId & 0x10) >> 4);
   mask= IRQ_MASK16(bit);
   old_intm = IRQ_globalDisable();
   prev = (reg) ? CHIP_RGET(IER1) : CHIP_RGET(IER0);
   old_flag = (prev & mask)>>bit;
   value= (prev | mask);
   if (reg) 
     _IER1 = value;
   else 
    _IER0 = value; 
   IRQ_globalRestore(old_intm);
   return old_flag;
} 
/*----------------------------------------------------------------------------*/
  IDEF void IRQ_restore(Uint16 EventId, Uint16 Old_flag) {
   Uint16 bit,reg,prev,value,mask;
   int old_intm;

   bit= EventId & 0xfu; 
   reg=((EventId & 0x10) >> 4);
   mask= IRQ_MASK16(bit);
   old_intm = IRQ_globalDisable();
   prev = (reg) ? CHIP_RGET(IER1) : CHIP_RGET(IER0);
   value= (prev & (~mask)) | (Old_flag << bit);
   if (reg) 
     _IER1 = value;
   else 
    _IER0  = value; 
   IRQ_globalRestore(old_intm);
} 
/*----------------------------------------------------------------------------*/
 IDEF int IRQ_disable(Uint16 EventId) { 
  Uint16 bit,reg,mask,prev;
  int old_intm,old_flag;

  bit= EventId & 0xfu; 
  reg=((EventId & 0x10) >> 4);
  mask=IRQ_MASK16(bit);
  old_intm = IRQ_globalDisable();
  prev = (reg) ? CHIP_RGET(IER1) : CHIP_RGET(IER0);
  old_flag = (prev & mask) >> bit;
  if (reg) 
    _IER1 &= ~mask;
  else 
    _IER0 &= ~mask; 
  IRQ_globalRestore(old_intm);
  return old_flag;
}                                 
/*----------------------------------------------------------------------------*/
 IDEF void IRQ_clear(Uint16 EventId) {   
  Uint16 bit, reg, mask;
  int old_intm;
  bit= EventId & 0xfu; 
  reg=((EventId & 0x10) >> 4);
  mask=IRQ_MASK16(bit);
  old_intm = IRQ_globalDisable();
  if (reg)
    _IFR1 = mask;
  else
    _IFR0 = mask;
  IRQ_globalRestore(old_intm);
}
/*----------------------------------------------------------------------------*/
 IDEF void _IRQ_init(_IRQ_Dispatch *dispatchTable, Uint16 biosPresent){
   Uint16 i; 

   if (dispatchTable != INV) {
     CSL_IRQ_DATA.IrqDispatchTable = dispatchTable;
   }

   for (i=0; i<=IRQ_EVENT_CNT-1; i++)
    CSL_IRQ_DATA.IrqIntTable[i] = i;
   
   for(i=0; i<= IRQ_EVENT_CNT-1; i++)
    CSL_IRQ_DATA.IrqEventTable[i] = IRQ_MASK32(i);

    CSL_SYS_DATA.OsPresent = biosPresent;               
 }     
/*----------------------------------------------------------------------------*/
IDEF CSLBool IRQ_test(Uint16 EventId) {
  Uint16 bit,reg,mask;
  int old_intm;
  bit= EventId & 0xfu; 
  reg=((EventId & 0x10) >> 4);
  mask=IRQ_MASK16(bit);
  old_intm = IRQ_globalDisable();
  bit = (CSLBool)((reg?(_IFR1 & mask): (_IFR0 & mask)) != 0);
  IRQ_globalRestore(old_intm);
  return bit;
}
/*----------------------------------------------------------------------------*/
 IDEF void IRQ_config(Uint16 EventId, IRQ_Config *Config) {
    CSL_IRQ_DATA.IrqDispatchTable[EventId].funcAddr = Config->funcAddr;
    CSL_IRQ_DATA.IrqDispatchTable[EventId].ierMask = (Config->ierMask == IRQ_IEMASK_SELF)? 
                                                                  ((Uint32)1u<<EventId) : Config->ierMask;
    CSL_IRQ_DATA.IrqDispatchTable[EventId].cacheCtrl = Config->cacheCtrl;
    CSL_IRQ_DATA.IrqDispatchTable[EventId].funcArg = Config->funcArg;
  
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_configArgs(Uint16 EventId, IRQ_IsrPtr funcAddr, Uint32 funcArg, Uint32 ierMask, Uint32 cacheCtrl) {
    CSL_IRQ_DATA.IrqDispatchTable[EventId].funcAddr = funcAddr;
    CSL_IRQ_DATA.IrqDispatchTable[EventId].ierMask = (ierMask == IRQ_IEMASK_SELF)?
                                                                 ((Uint32)1u<<EventId): ierMask;
    CSL_IRQ_DATA.IrqDispatchTable[EventId].cacheCtrl = cacheCtrl;
    CSL_IRQ_DATA.IrqDispatchTable[EventId].funcArg = funcArg; 
}

/*----------------------------------------------------------------------------*/
IDEF Uint32 IRQ_getArg(Uint16 EventId){
 return (CSL_IRQ_DATA.IrqDispatchTable[EventId].funcArg);
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_setArg(Uint16 EventId, Uint32 val){
 CSL_IRQ_DATA.IrqDispatchTable[EventId].funcArg = val;
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_map(Uint16 EventId){
  CSL_IRQ_DATA.IrqEventTable[EventId] = IRQ_MASK32(EventId);
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_getConfig(Uint16 EventId, IRQ_Config *Config) {
   Config->funcAddr = (IRQ_IsrPtr)(CSL_IRQ_DATA.IrqDispatchTable[EventId].funcAddr);
   Config->ierMask =  CSL_IRQ_DATA.IrqDispatchTable[EventId].ierMask;
   Config->cacheCtrl = CSL_IRQ_DATA.IrqDispatchTable[EventId].cacheCtrl;
   Config->funcArg = CSL_IRQ_DATA.IrqDispatchTable[EventId].funcArg; 
}
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
 IDEF int IRQ_setVecs(Uint32 Ivpd) {
   int old_intm;
   Uint16 old_ivpd;
   Uint16 val = (Uint16)((Ivpd & 0xFFFFFF00)>>8);
   old_intm = IRQ_globalDisable();
   old_ivpd = _IVPD;
   _IVPD = val;
   _IVPH = val;
   IRQ_globalRestore(old_intm);
   return old_ivpd;
 }  

#endif /* USEDEFS */

#elif (!(_IRQ_MOD_)) /* IRQ_SUPPORT */
  #error IRQ HAL Module Not Supported on Specified Target
#endif /* IRQ_SUPPORT */
#endif /* _CSL_IRQ_H_ */
/******************************************************************************\
* End of csl_irq.h
\******************************************************************************/


csl_irqdat.h/   1051539338  0     0     0       3258      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... csl_irqdat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       03/30/2000
*   MODIFIED:      06/19/2000
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the IRQ module)
*       Reserved ROM Area for IRQ Data 
*
*
\******************************************************************************/
#ifndef _CSL_IRQ_DATA_H_
  #define _CSL_IRQ_DATA_H_ 

  #include <csl_std.h>
  #include <csl_stdhal.h>

  #define _IRQ_INT_CNT    (32)  /* number of interrupt events */
  #define IRQ_INT_CNT     (32)   /* number of physical interrupts */  
  #define IRQ_EVENT_CNT   (32)


typedef void (*IRQ_IsrPtr)(void);


typedef struct {
  IRQ_IsrPtr funcAddr;
  Uint32 ierMask;
  Uint32 cacheCtrl;
  Uint32 funcArg;
} _IRQ_Dispatch;


typedef struct {
  _IRQ_Dispatch *IrqDispatchTable;
  Uint16 *perRegs;
  Uint32 IrqIntTable[IRQ_INT_CNT];
  Uint32 IrqEventTable[IRQ_EVENT_CNT];
} CSL_IrqDataObj;

  #define CSL_IRQDATAINIT\
  {  (_IRQ_Dispatch *)0x0000u,\
     (Uint16 *)0x0003u,\
    /* IRQ Physical Interrupt Table */\
        0x00000000u,\
        0x00000001u,\
        0x00000002u,\
        0x00000003u,\
        0x00000004u,\
        0x00000005u,\
        0x00000006u,\
        0x00000007u,\
        0x00000008u,\
        0x00000009u,\
        0x0000000Au,\
        0x0000000Bu,\
        0x0000000Cu,\
        0x0000000Fu,\
        0x00000010u,\
        0x00000011u,\
        0x00000012u,\
        0x00000013u,\
        0x00000014u,\
        0x00000015u,\
        0x00000016u,\
        0x00000017u,\
        0x00000018u,\
        0x00000019u,\
        0x0000001Au,\
        0x0000001Bu,\
        0x0000001Cu,\
        0x0000001Du,\
        0x0000001Eu,\
        0x0000001Fu,\
      /* IRQ EventId Table */\
        0x00000000u,\
        0x00000001u,\
        0x00000002u,\
        0x00000004u,\
        0x00000008u,\
        0x00000010u,\
        0x00000020u,\
        0x00000040u,\
        0x00000080u,\
        0x00000100u,\
        0x00000200u,\
        0x00000400u,\
        0x00000800u,\
        0x00001000u,\
        0x00002000u,\
        0x00004000u,\
        0x00008000u,\
        0x00010000u,\
        0x00020000u,\
        0x00040000u,\
        0x00080000u,\
        0x00100000u,\
        0x00200000u,\
        0x00400000u,\
        0x00800000u,\
        0x01000000u,\
        0x02000000u,\
        0x04000000u,\
        0x08000000u,\
        0x10000000u,\
        0x20000000u,\
        0x40000000u}
 
extern CSL_IrqDataObj  CSL_IrqData;

#define CSL_IRQ_DATA   CSL_IrqData

#endif
csl_irqhal.h/   1049976899  0     0     0       1774      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... IRQ
* FILENAME...... csl_irqhal.h
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. csl_stdinc.h, csl_stdinchal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       06/20/1999 
*   MODIFIED:      12/02/1999 Modified for TMS320C54xx
*   MODIFIED:      06/19/2000 header names consistent with #ifdefs, eliminate
*                             LIBBUILD 
*   MODIFIED:      07/11/2000 Modified for TMS320C5510
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the IRQ module)
*
* Registers Covered:
*
\******************************************************************************/
#ifndef _CSL_IRQHAL_H_
#define _CSL_IRQHAL_H_
  
#include <csl_chiphal.h>  
  
  
#if (_IRQ_SUPPORT)
/*============================================================================*\
* misc declarations
\*============================================================================*/
#define _IRQ_BASE_ADDR     (_CHIP_PERBASE_ADDR)


#elif (!(_IRQ_MOD_)) /* IRQ_SUPPORT */
  #error IRQ HAL Module Not Supported on Specified Target
#endif /* IRQ_SUPPORT */

#endif /* _CSL_IRQHAL_H_ */
/******************************************************************************\
* End of csl_irqhal.h
\******************************************************************************/

csl_mcbsp.h/    1070367896  0     0     0       45534     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... MCBSP
* FILENAME...... csl_mcbsp.h
* DATE CREATED.. Fri 06/11/1999
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... SL - Service Layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:    06/11/1999 Created
*   MODIFIED:   11/18/1999 Modified for TMS320C54xx
*   MODIFIED:   02/15/2000 C54x Romability
*   MODIFIED:   06/01/2000 Modified for TMS320C55x
*   MODIFIED:   04/16/2001 updated FILENAME and other header comments
*   MODIFIED:   05/11/2001 updated to include MCBSP_getConfig()
*   MODIFIED:   05/16/2001 updated to include MCBSP_read16/write16
*   MODIFIED:   06/28/2001 updated for new CSL initialization model
*   MODIFIED:   01/24/2002 added MCBS_read and MCBSP_write for C54x
*                          CSL compatability
*   MODIFIED:   05/07/2002 Added MCBSP_Private typedef for C++ type checking
*   MODIFIED:   09/25/2003 Removed xrdy/rrdy polling from MCBSP_write32()and MCBSP_read32()
*   MODIFIED:   10/07/2003 Removed READONLY fields from SPCR,PCR RMK macros
*   MODIFIED:   12/02/2003 Fixed ~ in MCBSP_xempty() with !
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the MCBSP module)
*
*
*
\******************************************************************************/
#ifndef _MCBSP_H_
#define _MCBSP_H_

#include <_csl.h>
#include <csl_mcbsphal.h>
#include <csl_mcbspdat.h>

#if (_MCBSP_SUPPORT)
/****************************************\
* MCBSP scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _MCBSP_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/****************************************\
* MCBSP global macro declarations
\****************************************/

#define MCBSP_PORT_CNT             _MCBSP_PORT_CNT

/* MCBSP_Open() flags */
#define MCBSP_OPEN_RESET          (0x0001)


/* error codes */
#define MCBSP_ERR_MAJOR            (0x00000004)
#define MCBSP_ERR_ALLOC            (0x00000000)
#define MCBSP_ERR_INVALID_HANDLE   (0x00000001)

/* device identifiers for MCBSP_Open() */
#define MCBSP_PORT0    (0)
#define MCBSP_PORT1    (1)
#define MCBSP_PORT2    (2)
#define MCBSP_PORT_ANY (-1)
/*#if (MCBSP_PORT_CNT == XX)*/

/* Constants for MCBSP_start */
#define MCBSP_RCV_START       (1u)
#define MCBSP_XMIT_START      (2u)
#define MCBSP_SRGR_START      (4u)
#define MCBSP_SRGR_FRAMESYNC  (8u)
#define MCBSP_SRGR_DEFAULT_DELAY  (0xFFFFu)

/*******************************************\
* MCBSP global macro definition : ROMABILITY
\*******************************************/
/* Reserved ROM Area by Mcbspdata.h */

/* Data definition */

/* Predefined Device Handlers */
#define MCBSP_HDEV0   ((MCBSP_Handle)&(CSL_MCBSP_DATA.mcbspPort[0]))
#define MCBSP_HDEV1   ((MCBSP_Handle)&(CSL_MCBSP_DATA.mcbspPort[1]))
#define MCBSP_HDEV2   ((MCBSP_Handle)&(CSL_MCBSP_DATA.mcbspPort[2]))
#define MCBSP_HDEV(n) ((MCBSP_Handle)&(CSL_MCBSP_DATA.mcbspPort[n]))

/* Get IRQ_EventNumber listed into the IRQ.h file */

#define MCBSP_getXmtEventId(_MCBSP) (\
  MCBSP_ASSERT_HANDLE(_MCBSP,return 0xFFFF)\
  (((MCBSP_PrivateObj*)_MCBSP)->XmtEvent)\
)
#define MCBSP_getRcvEventId(_MCBSP) (\
  MCBSP_ASSERT_HANDLE(_MCBSP,return 0xFFFF)\
  (((MCBSP_PrivateObj*)_MCBSP)->RcvEvent)\
)


#define MCBSP_xempty(_MCBSP)\
     (!(MCBSP_FGETH(_MCBSP,SPCR2,XEMPTY)))

#define MCBSP_xrdy(_MCBSP)\
      MCBSP_FGETH(_MCBSP,SPCR2,XRDY)

#define MCBSP_rrdy(_MCBSP)\
      MCBSP_FGETH(_MCBSP,SPCR1,RRDY)

#define MCBSP_rfull(_MCBSP)\
      MCBSP_FGETH(_MCBSP,SPCR1,RFULL)

#define MCBSP_getPort(_MCBSP)\
     ((MCBSP_PrivateObj *)(_MCBSP))->Port


/*Enable-Disable Receive-Transmit Channels;*/
#define MCBSP_channelEnable(_MCBSP,Reg,Channels)\
 MCBSP_RSETH(_MCBSP,Reg,Channels)


#define MCBSP_channelDisable(_MCBSP,Reg,Channels)\
 MCBSP_RAOIH(_MCBSP,Reg,~Channels,0,0)

#define MCBSP_channelStatus(_MCBSP,Reg,Channels) \
 (((MCBSP_RGETH(_MCBSP,Reg)) & (Channels))!=0)


/*******************************************/
/* Define a debuging assertion macro */
/* for validating device handles */

#ifdef _MCRTE_DEBUG
  #define MCBSP_ASSERT_HANDLE(_MCBSP,RetExp) \
    if (_MCBSP == INV) { \
      ERR_submit(MCBSP_ERR_MAJOR, MCBSP_ERR_INVALID_HANDLE); \
      RetExp; \
    }
#else
  #define MCBSP_ASSERT_HANDLE(_MCBSP,RetExp)
#endif

#define MCBSP_CHAN0     0x0001
#define MCBSP_CHAN1     0x0002
#define MCBSP_CHAN2     0x0004
#define MCBSP_CHAN3     0x0008
#define MCBSP_CHAN4     0x0010
#define MCBSP_CHAN5     0x0020
#define MCBSP_CHAN6     0x0040
#define MCBSP_CHAN7     0x0080
#define MCBSP_CHAN8     0x0100
#define MCBSP_CHAN9     0x0200
#define MCBSP_CHAN10    0x0400
#define MCBSP_CHAN11    0x0800
#define MCBSP_CHAN12    0x1000
#define MCBSP_CHAN13    0x2000
#define MCBSP_CHAN14    0x4000
#define MCBSP_CHAN15    0x8000


/*-----------------------------------------------------------------------*/
/* The following macros are used to construct peripheral register        */
/* values based on symbolic constants. They will be useful to initialize */
/* the MCBSP_Config structure in a readable way.                         */
/*-----------------------------------------------------------------------*/

/*===========================================================================*\
* MCBSP SPCR1   - Serial Port Control Register 1 Macros
*
* Fields:
*  (RW) DLB
*  (RW) RJUST
*  (RW) CLKSTP
*  (RW) DXENA
*  (RW) ABIS
*  (RW) RINTM
*  (RW) RSYNCERR
*  (R)  RFULL
*  (R)  RRDY
*  (RW) RRST
\*==========================================================================*/

#define MCBSP_SPCR1_DEFAULT                (0x0000u)



/*---------------------------------------*\
* MCBSP_SPCR1_MK Macro
\*---------------------------------------*/

#define MCBSP_SPCR1_RMK(dlb,rjust,clkstp, dxena, abis, rintm, rsyncerr,rrst)\
    ((Uint16)( \
    (MCBSP_FMK(SPCR1,RRST,rrst))         |\
    (MCBSP_FMK(SPCR1,RSYNCERR,rsyncerr)) |\
    (MCBSP_FMK(SPCR1,RINTM,rintm))       |\
    (MCBSP_FMK(SPCR1,ABIS,abis))         |\
    (MCBSP_FMK(SPCR1,DXENA,dxena))       |\
    (MCBSP_FMK(SPCR1,CLKSTP,clkstp))     |\
    (MCBSP_FMK(SPCR1,RJUST,rjust))       |\
    (MCBSP_FMK(SPCR1,DLB,dlb))            \
  ) \
)

#define MCBSP_SPCR1_RMKS(dlb_s,rjust_s,clkstp_s, dxena_s, abis_s, rintm_s, rrst_s)\
    ((Uint16)( \
    (MCBSP_FMKS(SPCR1,RRST,rrst_s))| \
    (MCBSP_FMKS(SPCR1,RINTM,rintm_s))| \
    (MCBSP_FMKS(SPCR1,ABIS,abis_s))| \
    (MCBSP_FMKS(SPCR1,DXENA,dxena_s))| \
    (MCBSP_FMKS(SPCR1,CLKSTP,clkstp_s))| \
    (MCBSP_FMKS(SPCR1,RJUST,rjust_s))| \
    (MCBSP_FMKS(SPCR1,DLB,dlb_s)) \
  ) \
)


/* SPCR1 field values */
#define MCBSP_SPCR1_RRST_DISABLE           (0x0000u)
#define MCBSP_SPCR1_RRST_ENABLE            (0x0001u)
#define MCBSP_SPCR1_RRDY_NO                (0x0000u)
#define MCBSP_SPCR1_RRDY_YES               (0x0001u)
#define MCBSP_SPCR1_RFULL_NO               (0x0000u)
#define MCBSP_SPCR1_RFULL_YES              (0x0001u)
#define MCBSP_SPCR1_RSYNCERR_NO            (0x0000u)
#define MCBSP_SPCR1_RSYNCERR_YES           (0x0001u)
#define MCBSP_SPCR1_RINTM_RRDY             (0x0000u)
#define MCBSP_SPCR1_RINTM_EOS              (0x0001u)
#define MCBSP_SPCR1_RINTM_FRM              (0x0002u)
#define MCBSP_SPCR1_RINTM_RSYNCERR         (0x0003u)
#define MCBSP_SPCR1_ABIS_DISABLE           (0x0000u)
#define MCBSP_SPCR1_ABIS_ENABLE            (0x0001u)
#define MCBSP_SPCR1_DXENA_NA               (0x0000u)
#define MCBSP_SPCR1_DXENA_OFF              (0x0000u)
#define MCBSP_SPCR1_DXENA_ON               (0x0001u)
#define MCBSP_SPCR1_CLKSTP_DISABLE         (0x0000u)
#define MCBSP_SPCR1_CLKSTP_NODELAY         (0x0002u)
#define MCBSP_SPCR1_CLKSTP_DELAY           (0x0003u)
#define MCBSP_SPCR1_RJUST_RZF              (0x0000u)
#define MCBSP_SPCR1_RJUST_RSE              (0x0001u)
#define MCBSP_SPCR1_RJUST_LZF              (0x0002u)
#define MCBSP_SPCR1_DLB_OFF                (0x0000u)
#define MCBSP_SPCR1_DLB_ON                 (0x0001u)



/*===========================================================================*\
* _MCBSP_SPCR2   - Serial Port Control Register 2 Macros
*
* Fields:
*  (RW) FREE
*  (RW) SOFT
*  (RW) FRST
*  (RW) GRST
*  (RW) XINTM
*  (RW) XSYNCERR
*  (R)  XEMPTY
*  (R)  XRDY
*  (RW) XRST
\*==========================================================================*/

/*---------------------------------------*\
* MCBSP_SPCR2_MK Macro
\*---------------------------------------*/

#define MCBSP_SPCR2_RMK(free,soft,frst,grst,xintm,xsyncerr,xrst)\
    ((Uint16)( \
    (MCBSP_FMK(SPCR2,XRST,xrst))         |\
    (MCBSP_FMK(SPCR2,XSYNCERR,xsyncerr)) |\
    (MCBSP_FMK(SPCR2,XINTM,xintm))       |\
    (MCBSP_FMK(SPCR2,GRST,grst))         |\
    (MCBSP_FMK(SPCR2,FRST,frst))         |\
    (MCBSP_FMK(SPCR2,SOFT,soft))         |\
    (MCBSP_FMK(SPCR2,FREE,free))          \
  ) \
)

#define MCBSP_SPCR2_RMKS(free_s,soft_s,frst_s,grst_s,xintm_s,xsyncerr_s,xrst_s)\
    ((Uint16)( \
    (MCBSP_FMKS(SPCR2,XRST,xrst_s))|\
    (MCBSP_FMKS(SPCR2,XINTM,xintm_s))|\
    (MCBSP_FMKS(SPCR2,XSYNCERR,xsyncerr_s))|\
    (MCBSP_FMKS(SPCR2,GRST,grst_s))|\
    (MCBSP_FMKS(SPCR2,FRST,frst_s))|\
    (MCBSP_FMKS(SPCR2,SOFT,soft_s))|\
    (MCBSP_FMKS(SPCR2,FREE,free_s))\
  ) \
)

/* SPCR2 field values */
#define MCBSP_SPCR2_DEFAULT                (0x0000u)

#define MCBSP_SPCR2_XRST_DISABLE           (0x0000u)
#define MCBSP_SPCR2_XRST_ENABLE            (0x0001u)
#define MCBSP_SPCR2_XRDY_NO                (0x0000u)
#define MCBSP_SPCR2_XRDY_YES               (0x0001u)
#define MCBSP_SPCR2_XEMPTY_YES             (0x0000u)
#define MCBSP_SPCR2_XEMPTY_NO              (0x0001u)
#define MCBSP_SPCR2_XSYNCERR_NO            (0x0000u)
#define MCBSP_SPCR2_XSYNCERR_YES           (0x0001u)
#define MCBSP_SPCR2_XINTM_XRDY             (0x0000u)
#define MCBSP_SPCR2_XINTM_EOS              (0x0001u)
#define MCBSP_SPCR2_XINTM_FRM              (0x0002u)
#define MCBSP_SPCR2_XINTM_XSYNCERR         (0x0003u)
#define MCBSP_SPCR2_GRST_RESET             (0x0000u)
#define MCBSP_SPCR2_GRST_CLKG              (0x0001u)
#define MCBSP_SPCR2_FRST_RESET             (0x0000u)
#define MCBSP_SPCR2_FRST_FSG               (0x0001u)
#define MCBSP_SPCR2_SOFT_NO                (0x0000u)
#define MCBSP_SPCR2_SOFT_YES               (0x0001u)
#define MCBSP_SPCR2_FREE_NO                (0x0000u)
#define MCBSP_SPCR2_FREE_YES               (0x0001u)


/*===========================================================================*\
* MCBSP RCR1   - Receive Control Register 2 Macros
*
* Fields:
*  (RW) RFRLEN1
*  (RW) RWDLEN1
\*==========================================================================*/

/* default RCR1 register value */
#define MCBSP_RCR1_DEFAULT                 (0x0000u)


/*---------------------------------------*\
* MCBSP_RCR1_MK Macro
\*---------------------------------------*/

#define MCBSP_RCR1_RMK(rfrlen1,rwdlen1)\
  ((Uint16)(\
    (MCBSP_FMK(RCR1,RWDLEN1,rwdlen1))|\
    (MCBSP_FMK(RCR1,RFRLEN1,rfrlen1))\
  ) \
)

#define MCBSP_RCR1_RMKS(rfrlen1_s,rwdlen1_s)\
  ((Uint16)(\
    (MCBSP_FMKS(RCR1,RWDLEN1,rwdlen1_s))|\
    (MCBSP_FMKS(RCR1,RFRLEN1,rfrlen1_s))\
  ) \
)

/* RCR1 field values */
#define MCBSP_RCR1_RWDLEN1_8BIT            (0x0000u)
#define MCBSP_RCR1_RWDLEN1_12BIT           (0x0001u)
#define MCBSP_RCR1_RWDLEN1_16BIT           (0x0002u)
#define MCBSP_RCR1_RWDLEN1_20BIT           (0x0003u)
#define MCBSP_RCR1_RWDLEN1_24BIT           (0x0004u)
#define MCBSP_RCR1_RWDLEN1_32BIT           (0x0005u)
#define MCBSP_RCR1_RFRLEN1_OF(x)           ((Uint16)(x))

/*===========================================================================*\
* MCBSP RCR2   - Receive Control Register 2 Macros
*
* Fields:
*  (RW) RPHASE
*  (RW) RFRLEN2
*  (RW) RWDLEN2
*  (RW) RCOMPAND
*  (RW) RFIG
*  (RW) RDATDLY
\*==========================================================================*/

/* default RCR2 register value */
#define MCBSP_RCR2_DEFAULT                 (0x0000u)


/*---------------------------------------*\
* MCBSP_RCR2_MK Macro
\*---------------------------------------*/

#define MCBSP_RCR2_RMK(rphase,rfrlen2,rwdlen2,rcompand,rfig,rdatdly)\
   ((Uint16)(\
    (MCBSP_FMK(RCR2,RDATDLY,rdatdly))   |\
    (MCBSP_FMK(RCR2,RFIG,rfig))         |\
    (MCBSP_FMK(RCR2,RCOMPAND,rcompand)) |\
    (MCBSP_FMK(RCR2,RWDLEN2,rwdlen2))   |\
    (MCBSP_FMK(RCR2,RFRLEN2,rfrlen2))   |\
    (MCBSP_FMK(RCR2,RPHASE,rphase))      \
  ) \
)

#define MCBSP_RCR2_RMKS(rphase_s,rfrlen2_s,rwdlen2_s,rcompand_s,rfig_s,rdatdly_s)\
   ((Uint16)(\
    (MCBSP_FMKS(RCR2,RDATDLY,rdatdly_s))   |\
    (MCBSP_FMKS(RCR2,RFIG,rfig_s))         |\
    (MCBSP_FMKS(RCR2,RCOMPAND,rcompand_s)) |\
    (MCBSP_FMKS(RCR2,RWDLEN2,rwdlen2_s))   |\
    (MCBSP_FMKS(RCR2,RFRLEN2,rfrlen2_s))   |\
    (MCBSP_FMKS(RCR2,RPHASE,rphase_s))      \
  ) \
)


/* RCR2 field values */
#define MCBSP_RCR2_RDATDLY_0BIT            (0x0000u)
#define MCBSP_RCR2_RDATDLY_1BIT            (0x0001u)
#define MCBSP_RCR2_RDATDLY_2BIT            (0x0002u)
#define MCBSP_RCR2_RFIG_YES                (0x0000u)
#define MCBSP_RCR2_RFIG_NO                 (0x0001u)
#define MCBSP_RCR2_RCOMPAND_MSB            (0x0000u)
#define MCBSP_RCR2_RCOMPAND_8BITLSB        (0x0001u)
#define MCBSP_RCR2_RCOMPAND_ULAW           (0x0002u)
#define MCBSP_RCR2_RCOMPAND_ALAW           (0x0003u)
#define MCBSP_RCR2_RWDLEN2_8BIT            (0x0000u)
#define MCBSP_RCR2_RWDLEN2_12BIT           (0x0001u)
#define MCBSP_RCR2_RWDLEN2_16BIT           (0x0002u)
#define MCBSP_RCR2_RWDLEN2_20BIT           (0x0003u)
#define MCBSP_RCR2_RWDLEN2_24BIT           (0x0004u)
#define MCBSP_RCR2_RWDLEN2_32BIT           (0x0005u)
#define MCBSP_RCR2_RFRLEN2_OF(x)           ((Uint16)(x))
#define MCBSP_RCR2_RPHASE_SINGLE           (0x0000u)
#define MCBSP_RCR2_RPHASE_DUAL             (0x0001u)


/*===========================================================================*\
* _MCBSP_XCR1   - Transmit Control Register 1
*
* Fields:
*  (RW) _MCBSP_XCR1_XFRLEN1
*  (RW) _MCBSP_XCR1_XWDLEN1
\*==========================================================================*/

/* default XCR1 register value */
#define MCBSP_XCR1_DEFAULT                (0x0000u)



/*---------------------------------------*\
* MCBSP_XCR1_MK Macro
\*---------------------------------------*/

#define MCBSP_XCR1_RMK(xfrlen1,xwdlen1)\
  ((Uint16)(\
    (MCBSP_FMK(XCR1,XWDLEN1,xwdlen1))|\
    (MCBSP_FMK(XCR1,XFRLEN1,xfrlen1))\
  ) \
)

#define MCBSP_XCR1_RMKS(xfrlen1_s,xwdlen1_s)\
  ((Uint16)(\
    (MCBSP_FMKS(XCR1,XWDLEN1,xwdlen1_s))|\
    (MCBSP_FMKS(XCR1,XFRLEN1,xfrlen1_s))\
  ) \
)

/* XCR1 field values */
#define MCBSP_XCR1_XWDLEN1_8BIT            (0x0000u)
#define MCBSP_XCR1_XWDLEN1_12BIT           (0x0001u)
#define MCBSP_XCR1_XWDLEN1_16BIT           (0x0002u)
#define MCBSP_XCR1_XWDLEN1_20BIT           (0x0003u)
#define MCBSP_XCR1_XWDLEN1_24BIT           (0x0004u)
#define MCBSP_XCR1_XWDLEN1_32BIT           (0x0005u)
#define MCBSP_XCR1_XFRLEN1_OF(x)           ((Uint16)(x))


/*===========================================================================*\
*  MCBSP XCR2   - Transmit Control Register 2 Macros
*
* Fields:
*  (RW) XPHASE
*  (RW) XFRLEN2
*  (RW) XWDLEN2
*  (RW) XCOMPAND
*  (RW) XFIG
*  (RW) XDATDLY
\*==========================================================================*/

/* default XCR register value */
#define MCBSP_XCR2_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_XCR2_MK Macro
\*---------------------------------------*/

#define MCBSP_XCR2_RMK(xphase,xfrlen2,xwdlen2,xcompand,xfig,xdatdly)\
   ((Uint16)(\
    (MCBSP_FMK(XCR2,XDATDLY,xdatdly))|\
    (MCBSP_FMK(XCR2,XFIG,xfig))|\
    (MCBSP_FMK(XCR2,XCOMPAND,xcompand))|\
    (MCBSP_FMK(XCR2,XWDLEN2,xwdlen2))|\
    (MCBSP_FMK(XCR2,XFRLEN2,xfrlen2))|\
    (MCBSP_FMK(XCR2,XPHASE,xphase))\
  ) \
)

#define MCBSP_XCR2_RMKS(xphase_s,xfrlen2_s,xwdlen2_s,xcompand_s,xfig_s,xdatdly_s)\
   ((Uint16)(\
    (MCBSP_FMKS(XCR2,XDATDLY,xdatdly_s))|\
    (MCBSP_FMKS(XCR2,XFIG,xfig_s))|\
    (MCBSP_FMKS(XCR2,XCOMPAND,xcompand_s))|\
    (MCBSP_FMKS(XCR2,XWDLEN2,xwdlen2_s))|\
    (MCBSP_FMKS(XCR2,XFRLEN2,xfrlen2_s))|\
    (MCBSP_FMKS(XCR2,XPHASE,xphase_s))\
  ) \
)


/* XCR2 field values */
#define MCBSP_XCR2_XDATDLY_0BIT            (0x0000u)
#define MCBSP_XCR2_XDATDLY_1BIT            (0x0001u)
#define MCBSP_XCR2_XDATDLY_2BIT            (0x0002u)
#define MCBSP_XCR2_XFIG_YES                (0x0000u)
#define MCBSP_XCR2_XFIG_NO                 (0x0001u)
#define MCBSP_XCR2_XCOMPAND_MSB            (0x0000u)
#define MCBSP_XCR2_XCOMPAND_8BITLSB        (0x0001u)
#define MCBSP_XCR2_XCOMPAND_ULAW           (0x0002u)
#define MCBSP_XCR2_XCOMPAND_ALAW           (0x0003u)
#define MCBSP_XCR2_XWDLEN2_8BIT            (0x0000u)
#define MCBSP_XCR2_XWDLEN2_12BIT           (0x0001u)
#define MCBSP_XCR2_XWDLEN2_16BIT           (0x0002u)
#define MCBSP_XCR2_XWDLEN2_20BIT           (0x0003u)
#define MCBSP_XCR2_XWDLEN2_24BIT           (0x0004u)
#define MCBSP_XCR2_XWDLEN2_32BIT           (0x0005u)
#define MCBSP_XCR2_XFRLEN2_OF(x)           ((Uint16)(x))
#define MCBSP_XCR2_XPHASE_SINGLE           (0x0000u)
#define MCBSP_XCR2_XPHASE_DUAL             (0x0001u)


/*===========================================================================*\
*  MCBSP SRGR1 -  Sample Rate Generator Register 1 Macros
*
* Fields:
*  (RW) _MCBSP_SRGR1_FWID
*  (RW) _MCBSP_SRGR1_CLKGDV
\*==========================================================================*/

/* default SRGR register value */
#define MCBSP_SRGR1_DEFAULT                (0x0001u)



/*---------------------------------------*\
* MCBSP_SRGR1_MK Macro
\*---------------------------------------*/

#define MCBSP_SRGR1_RMK(fwid,clkgdv) (\
  (Uint16)(\
    (MCBSP_FMK(SRGR1,CLKGDV,clkgdv))|\
    (MCBSP_FMK(SRGR1,FWID,fwid))\
  )\
)

#define MCBSP_SRGR1_RMKS(fwid_s,clkgdv_s) (\
  (Uint16)(\
    (MCBSP_FMKS(SRGR1,CLKGDV,clkgdv_s))|\
    (MCBSP_FMKS(SRGR1,FWID,fwid_s))\
  )\
)

/* SRGR1 field values */
#define MCBSP_SRGR1_CLKGDV_OF(x)           ((Uint16)(x))
#define MCBSP_SRGR1_FWID_OF(x)             ((Uint16)(x))


/*===========================================================================*\
* _MCBSP_SRGR2 -  Sample Rate Generator Register 2
*
* Fields:
*  (RW) _MCBSP_SRGR2_GSYNC
*  (RW) _MCBSP_SRGR2_CLKSP
*  (RW) _MCBSP_SRGR2_CLKSM
*  (RW) _MCBSP_SRGR2_FSGM
*  (RW) _MCBSP_SRGR2_FPER
\*==========================================================================*/

/* default SRGR2 register value */
#define MCBSP_SRGR2_DEFAULT                (0x2000u)


/*---------------------------------------*\
* MCBSP_SRGR2_MK Macro
\*---------------------------------------*/

#define MCBSP_SRGR2_RMK(gsync,clksp,clksm,fsgm,fper)(\
  (Uint16)(\
    (MCBSP_FMK(SRGR2,FPER,fper))|\
    (MCBSP_FMK(SRGR2,FSGM,fsgm))|\
    (MCBSP_FMK(SRGR2,CLKSM,clksm))|\
    (MCBSP_FMK(SRGR2,CLKSP,clksp))|\
    (MCBSP_FMK(SRGR2,GSYNC,gsync))\
  )\
)

#define MCBSP_SRGR2_RMKS(gsync_s,clksp_s,clksm_s,fsgm_s,fper_s)(\
  (Uint16)(\
    (MCBSP_FMKS(SRGR2,FPER,fper_s))|\
    (MCBSP_FMKS(SRGR2,FSGM,fsgm_s))|\
    (MCBSP_FMKS(SRGR2,CLKSM,clksm_s))|\
    (MCBSP_FMKS(SRGR2,CLKSP,clksp_s))|\
    (MCBSP_FMKS(SRGR2,GSYNC,gsync_s))\
  )\
)


/* SRGR2 field values */
#define MCBSP_SRGR2_FPER_OF(x)             ((Uint16)(x))
#define MCBSP_SRGR2_FSGM_DXR2XSR           (0x0000u)
#define MCBSP_SRGR2_FSGM_FSG               (0x0001u)
#define MCBSP_SRGR2_CLKSM_CLKS             (0x0000u)
#define MCBSP_SRGR2_CLKSM_INTERNAL         (0x0001u)
#define MCBSP_SRGR2_CLKSP_RISING           (0x0000u)
#define MCBSP_SRGR2_CLKSP_FALLING          (0x0001u)
#define MCBSP_SRGR2_GSYNC_FREE             (0x0000u)
#define MCBSP_SRGR2_GSYNC_SYNC             (0x0001u)


/*===========================================================================*\
*  MCBSP MCR1 -  Multi-channel Control Register 1 Macros
*
* Fields:
*  (RW) RMCME
*  (RW) RPBBLK
*  (RW) RPABLK
*  (R)  RCBLK
*  (RW) RMCM
\*==========================================================================*/

/* default MCR register value */
#define MCBSP_MCR1_DEFAULT                 (0x0000u)

/*---------------------------------------*\
* MCBSP_MCR1_MK Macro
\*---------------------------------------*/

    #define MCBSP_MCR1_RMK(rmcme, rpbblk, rpablk, rcblk, rmcm)\
  ((Uint16)(\
     (MCBSP_FMK(MCR1,RMCM,rmcm))    |\
     (MCBSP_FMK(MCR1,RPABLK,rpablk))|\
     (MCBSP_FMK(MCR1,RPBBLK,rpbblk))|\
     (MCBSP_FMK(MCR1,RCBLK,rcblk))  |\
     (MCBSP_FMK(MCR1,RMCME,rmcme))   \
    )\
  )

    #define MCBSP_MCR1_RMKS(rmcme_s,rpbblk_s, rpablk_s, rcblk_s, rmcm_s)\
  ((Uint16)(\
     (MCBSP_FMKS(MCR1,RMCM,rmcm_s))    |\
     (MCBSP_FMKS(MCR1,RPABLK,rpablk_s))|\
     (MCBSP_FMKS(MCR1,RPBBLK,rpbblk_s))|\
     (MCBSP_FMKS(MCR1,RCBLK,rcblk_s))  |\
     (MCBSP_FMKS(MCR1,RMCME,rmcme_s))   \
    )\
  )

/* MCR1 field values */
#define MCBSP_MCR1_RMCM_CHENABLE           (0x0000u)
#define MCBSP_MCR1_RMCM_ELDISABLE          (0x0001u)
#define MCBSP_MCR1_RCBLK_SF0               (0x0000u)
#define MCBSP_MCR1_RCBLK_SF1               (0x0001u)
#define MCBSP_MCR1_RCBLK_SF2               (0x0002u)
#define MCBSP_MCR1_RCBLK_SF3               (0x0003u)
#define MCBSP_MCR1_RCBLK_SF4               (0x0004u)
#define MCBSP_MCR1_RCBLK_SF5               (0x0005u)
#define MCBSP_MCR1_RCBLK_SF6               (0x0006u)
#define MCBSP_MCR1_RCBLK_SF7               (0x0007u)
#define MCBSP_MCR1_RPABLK_SF0              (0x0000u)
#define MCBSP_MCR1_RPABLK_SF2              (0x0001u)
#define MCBSP_MCR1_RPABLK_SF4              (0x0002u)
#define MCBSP_MCR1_RPABLK_SF6              (0x0003u)
#define MCBSP_MCR1_RPBBLK_SF1              (0x0000u)
#define MCBSP_MCR1_RPBBLK_SF3              (0x0001u)
#define MCBSP_MCR1_RPBBLK_SF5              (0x0002u)
#define MCBSP_MCR1_RPBBLK_SF7              (0x0003u)
#define MCBSP_MCR1_RMCME_NO                (0x0000u)
#define MCBSP_MCR1_RMCME_AtoH              (0x0001u)


/*===========================================================================*\
* MCBSP MCR2 -  Multi-channel Control Register 2 Macros
*
* Fields:
*  (RW) _MCBSP_MCR2_XMCME
*  (RW) _MCBSP_MCR2_XPBBLK
*  (RW) _MCBSP_MCR2_XPABLK
*  (R)  _MCBSP_MCR2_XCBLK
*  (RW) _MCBSP_MCR2_XMCM
\*==========================================================================*/

/* default MCR register value */
#define MCBSP_MCR2_DEFAULT                 (0x0000u)


/*---------------------------------------*\
* MCBSP_MCR2_MK Macro
\*---------------------------------------*/

   #define MCBSP_MCR2_RMK(xmcme,xpbblk,xpablk,xcblk,xmcm)\
  ( (Uint16)(\
      (MCBSP_FMK(MCR2,XMCM,xmcm))    |\
      (MCBSP_FMK(MCR2,XPABLK,xpablk))|\
      (MCBSP_FMK(MCR2,XPBBLK,xpbblk))|\
      (MCBSP_FMK(MCR2,XCBLK,xcblk))  |\
      (MCBSP_FMK(MCR2,XMCME,xmcme))   \
     )\
   )

   #define MCBSP_MCR2_RMKS(xmcme_s,xpbblk_s,xpablk_s,xcblk_s,xmcm_s)\
  ( (Uint16)(\
      (MCBSP_FMKS(MCR2,XMCM,xmcm_s))    |\
      (MCBSP_FMKS(MCR2,XPABLK,xpablk_s))|\
      (MCBSP_FMKS(MCR2,XPBBLK,xpbblk_s))|\
      (MCBSP_FMKS(MCR2,XCBLK,xcblk_s))  |\
      (MCBSP_FMKS(MCR2,XMCME,xmcme_s))   \
     )\
   )



/* MCR2 field values */

#define MCBSP_MCR2_XMCM_ENNOMASK           (0x0000u)
#define MCBSP_MCR2_XMCM_DISXP              (0x0001u)
#define MCBSP_MCR2_XMCM_ENMASK             (0x0002u)
#define MCBSP_MCR2_XMCM_DISRP              (0x0003u)
#define MCBSP_MCR2_XCBLK_SF0               (0x0000u)
#define MCBSP_MCR2_XCBLK_SF1               (0x0001u)
#define MCBSP_MCR2_XCBLK_SF2               (0x0002u)
#define MCBSP_MCR2_XCBLK_SF3               (0x0003u)
#define MCBSP_MCR2_XCBLK_SF4               (0x0004u)
#define MCBSP_MCR2_XCBLK_SF5               (0x0005u)
#define MCBSP_MCR2_XCBLK_SF6               (0x0006u)
#define MCBSP_MCR2_XCBLK_SF7               (0x0007u)
#define MCBSP_MCR2_XPABLK_SF0              (0x0000u)
#define MCBSP_MCR2_XPABLK_SF2              (0x0001u)
#define MCBSP_MCR2_XPABLK_SF4              (0x0002u)
#define MCBSP_MCR2_XPABLK_SF6              (0x0003u)
#define MCBSP_MCR2_XPBBLK_SF1              (0x0000u)
#define MCBSP_MCR2_XPBBLK_SF3              (0x0001u)
#define MCBSP_MCR2_XPBBLK_SF5              (0x0002u)
#define MCBSP_MCR2_XPBBLK_SF7              (0x0003u)
#define MCBSP_MCR2_XMCME_NO                (0x0000u)
#define MCBSP_MCR2_XMCME_AtoH              (0x0001u)


/*===========================================================================
* MCBSP RCERA -  Receive Channel Enable Register A Macros
*
* Fields:
*  (RW) RCE15
*  (RW) RCE14
*  (RW) RCE13
*  (RW) RCE12
*  (RW) RCE11
*  (RW) RCE10
*  (RW) RCE9
*  (RW) RCE8
*  (RW) RCE7
*  (RW) RCE6
*  (RW) RCE5
*  (RW) RCE4
*  (RW) RCE3
*  (RW) RCE2
*  (RW) RCE1
*  (RW) RCE0
\*==========================================================================*/

/* default RCER register value */
#define MCBSP_RCERA_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_RCERA_MK Macro
\*---------------------------------------*/

#define MCBSP_RCERA_RMK(rcea)((Uint16)(\
    (((Uint16)(rcea))&0xFFFFu)\
  )\
)\

/*===========================================================================
* MCBSP RCERB -  Receive Channel Enable Register B Macros
\*==========================================================================*/

/* default RCER register value */
#define MCBSP_RCERB_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_RCERB_MK Macro
\*---------------------------------------*/

#define MCBSP_RCERB_RMK(rceb)((Uint16)(\
    (((Uint16)(rceb))&0xFFFFu)\
  )\
)\

/*===========================================================================
* MCBSP RCERC -  Receive Channel Enable Register C Macros
\*==========================================================================*/

/* default RCER register value */
#define MCBSP_RCERC_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_RCERC_MK Macro
\*---------------------------------------*/

#define MCBSP_RCERC_RMK(rcec)((Uint16)(\
    (((Uint16)(rcec))&0xFFFFu)\
  )\
)\

/*===========================================================================
* MCBSP RCERD -  Receive Channel Enable Register D Macros
\*==========================================================================*/

/* default RCER register value */
#define MCBSP_RCERD_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_RCERD_MK Macro
\*---------------------------------------*/

#define MCBSP_RCERD_RMK(rced)((Uint16)(\
    (((Uint16)(rced))&0xFFFFu)\
  )\
)\


/*===========================================================================
* MCBSP RCERE -  Receive Channel Enable Register E Macros
\*==========================================================================*/

/* default RCER register value */
#define MCBSP_RCERE_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_RCERE_MK Macro
\*---------------------------------------*/

#define MCBSP_RCERE_RMK(rcee)((Uint16)(\
    (((Uint16)(rcee))&0xFFFFu)\
  )\
)\

/*===========================================================================
* MCBSP RCERF -  Receive Channel Enable Register F Macros
\*==========================================================================*/

/* default RCER register value */
#define MCBSP_RCERF_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_RCERF_MK Macro
\*---------------------------------------*/

#define MCBSP_RCERF_RMK(rcef)((Uint16)(\
    (((Uint16)(rcef))&0xFFFFu)\
  )\
)\

/*===========================================================================
* MCBSP RCERG -  Receive Channel Enable Register G Macros
\*==========================================================================*/

/* default RCER register value */
#define MCBSP_RCERG_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_RCERG_GET Macro
\*---------------------------------------*/

/*---------------------------------------*\
* MCBSP_RCERG_MK Macro
\*---------------------------------------*/

#define MCBSP_RCERG_RMK(rceg)((Uint16)(\
    (((Uint16)(rceg))&0xFFFFu)\
  )\
)\


/*===========================================================================
* MCBSP RCERH -  Receive Channel Enable Register G Macros
\*==========================================================================*/

/* default RCER register value */
#define MCBSP_RCERH_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_RCERH_RMK Macro
\*---------------------------------------*/

#define MCBSP_RCERH_RMK(rceh)((Uint16)(\
    (((Uint16)(rceh))&0xFFFFu)\
  )\
)\


/*===========================================================================*\
* MCBSP XCERA -  Transmit Channel Enable Register A
*
* Fields:
*  (RW) XCE15
*  (RW) XCE14
*  (RW) XCE13
*  (RW) XCE12
*  (RW) XCE11
*  (RW) XCE10
*  (RW) XCE9
*  (RW) XCE8
*  (RW) XCE7
*  (RW) XCE6
*  (RW) XCE5
*  (RW) XCE4
*  (RW) XCE3
*  (RW) XCE2
*  (RW) XCE1
*  (RW) XCE0
\*==========================================================================*/

/* default XCERA register value */
#define MCBSP_XCERA_DEFAULT                (0x0000u)



/*---------------------------------------*\
* MCBSP_XCERA_MK Macro
\*---------------------------------------*/

#define MCBSP_XCERA_RMK(xcea) ((Uint16)(\
    (((Uint16)(xcea))&0xFFFFu)\
  )\
)

/*===========================================================================*\
* MCBSP XCERB -  Transmit Channel Enable Register B
\*==========================================================================*/


/* default XCERB register value */
#define MCBSP_XCERB_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_XCERB_MK Macro
\*---------------------------------------*/

#define MCBSP_XCERB_RMK(xceb) ((Uint16)(\
    (((Uint16)(xceb))&0xFFFFu)\
  )\
)



/*===========================================================================*\
* MCBSP XCERC -  Transmit Channel Enable Register C
\*==========================================================================*/

/* default XCER register value */
#define MCBSP_XCERC_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_XCERC_MK Macro
\*---------------------------------------*/

#define MCBSP_XCERC_RMK(xcec) ((Uint16)(\
    (((Uint16)(xcec))&0xFFFFu)\
  )\
)

/*===========================================================================*\
* MCBSP XCERD -  Transmit Channel Enable Register D
\*==========================================================================*/

/* default XCERD register value */
#define MCBSP_XCERD_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_XCERD_MK Macro
\*---------------------------------------*/

#define MCBSP_XCERD_RMK(xced) ((Uint16)(\
    (((Uint16)(xced))&0xFFFFu)\
  )\
)

/*===========================================================================*\
* MCBSP XCERE -  Transmit Channel Enable Register E
\*==========================================================================*/

/* default XCERE register value */
#define MCBSP_XCERE_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_XCERE_MK Macro
\*---------------------------------------*/

#define MCBSP_XCERE_RMK(xcee) ((Uint16)(\
    (((Uint16)(xcee))&0xFFFFu)\
  )\
)


/*===========================================================================*\
* MCBSP XCERF -  Transmit Channel Enable Register F
\*==========================================================================*/

/* default XCERF register value */
#define MCBSP_XCERF_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_XCERF_MK Macro
\*---------------------------------------*/

#define MCBSP_XCERF_RMK(xcef) ((Uint16)(\
    (((Uint16)(xcef))&0xFFFFu)\
  )\
)

/*===========================================================================*\
* MCBSP XCERG -  Transmit Channel Enable Register G
\*==========================================================================*/

/* default XCERG register value */
#define MCBSP_XCERG_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_XCERG_MK Macro
\*---------------------------------------*/

#define MCBSP_XCERG_RMK(xceg) ((Uint16)(\
    (((Uint16)(xceg))&0xFFFFu)\
  )\
)

/*===========================================================================*\
* MCBSP XCERH -  Transmit Channel Enable Register H
\*==========================================================================*/

/* default XCERH register value */
#define MCBSP_XCERH_DEFAULT                (0x0000u)


/*---------------------------------------*\
* MCBSP_XCERH_MK Macro
\*---------------------------------------*/

#define MCBSP_XCERH_RMK(xceh) (Uint16)(\
    (((Uint16)(xceh))&0xFFFFu)\
  )\

#define MCBSP_XCER_RMK(xce15,xce14,xce13,xce12,xce11,xce10,xce9,xce8,\
                     xce7,xce6,xce5,xce4,xce3,xce2,xce1,xce0)\
  (Uint16) (MCBSP_FMK(XCERA,XCE15,xce15)   |\
            MCBSP_FMK(XCERA,XCE14,xce14)   |\
            MCBSP_FMK(XCERA,XCE13,xce13)   |\
            MCBSP_FMK(XCERA,XCE12,xce12)   |\
            MCBSP_FMK(XCERA,XCE11,xce11)   |\
            MCBSP_FMK(XCERA,XCE10,xce10)   |\
            MCBSP_FMK(XCERA,XCE9,xce9)     |\
            MCBSP_FMK(XCERA,XCE8,xce8)     |\
            MCBSP_FMK(XCERA,XCE7,xce7)     |\
            MCBSP_FMK(XCERA,XCE6,xce6)     |\
            MCBSP_FMK(XCERA,XCE5,xce5)     |\
            MCBSP_FMK(XCERA,XCE4,xce4)     |\
            MCBSP_FMK(XCERA,XCE3,xce3)     |\
            MCBSP_FMK(XCERA,XCE2,xce2)     |\
            MCBSP_FMK(XCERA,XCE1,xce1)     |\
            MCBSP_FMK(XCERA,XCE0,xce0)      \
)

#define MCBSP_RCER_RMK(rce15,rce14,rce13,rce12,rce11,rce10,rce9,rce8,\
                     rce7,rce6,rce5,rce4,rce3,rce2,rce1,rce0)\
  (Uint16) (MCBSP_FMK(RCERA,RCE15,rce15)   |\
            MCBSP_FMK(RCERA,RCE14,rce14)   |\
            MCBSP_FMK(RCERA,RCE13,rce13)   |\
            MCBSP_FMK(RCERA,RCE12,rce12)   |\
            MCBSP_FMK(RCERA,RCE11,rce11)   |\
            MCBSP_FMK(RCERA,RCE10,rce10)   |\
            MCBSP_FMK(RCERA,RCE9,rce9)     |\
            MCBSP_FMK(RCERA,RCE8,rce8)     |\
            MCBSP_FMK(RCERA,RCE7,rce7)     |\
            MCBSP_FMK(RCERA,RCE6,rce6)     |\
            MCBSP_FMK(RCERA,RCE5,rce5)     |\
            MCBSP_FMK(RCERA,RCE4,rce4)     |\
            MCBSP_FMK(RCERA,RCE3,rce3)     |\
            MCBSP_FMK(RCERA,RCE2,rce2)     |\
            MCBSP_FMK(RCERA,RCE1,rce1)     |\
            MCBSP_FMK(RCERA,RCE0,rce0)      \
)

/*===========================================================================/
* MCBSP PCR   - Pin Control Register Macros
*
* Fields:
*  (RW) SCLKME
*  (R)  CLKSSTAT
*  (RW) DXSTAT
*  (R)  DRSTAT
*  (RW) FSXP
*  (RW) FSRP
*  (RW) CLKXP
*  (RW) CLKRP
*  (RW) IDLEEN
*  (RW) XIOEN
*  (RW) RIOEN
*  (RW) FSXM
*  (RW) FSRM
*  (RW) CLKXM
*  (RW) CLKRM
\*==========================================================================*/

/* default PCR register value */
#define MCBSP_PCR_DEFAULT                 (0x0000u)

/*---------------------------------------*\
* MCBSP_PCR_MK Macro
\*---------------------------------------*/

#if(!CHIP_5502)

#define MCBSP_PCR_RMK(idleen,xioen,rioen,fsxm,fsrm,clkxm,clkrm,\
						sclkme,dxstat,fsxp,fsrp,clkxp,clkrp) \
   ((Uint16)(\
       (MCBSP_FMK(PCR,CLKRP,clkrp))       |\
       (MCBSP_FMK(PCR,CLKXP,clkxp))       |\
       (MCBSP_FMK(PCR,FSRP,fsrp))         |\
       (MCBSP_FMK(PCR,FSXP,fsxp))         |\
       (MCBSP_FMK(PCR,CLKRM,clkrm))       |\
       (MCBSP_FMK(PCR,CLKXM,clkxm))       |\
       (MCBSP_FMK(PCR,DXSTAT,dxstat))     |\
       (MCBSP_FMK(PCR,SCLKME,sclkme))     |\
       (MCBSP_FMK(PCR,FSRM,fsrm))         |\
       (MCBSP_FMK(PCR,FSXM,fsxm))         |\
       (MCBSP_FMK(PCR,RIOEN,rioen))       |\
       (MCBSP_FMK(PCR,XIOEN,xioen))       |\
       (MCBSP_FMK(PCR,IDLEEN,idleen))      \
       )\
     )

#define MCBSP_PCR_RMKS(idleen_s,xioen_s,rioen_s,fsxm_s,fsrm_s,clkxm_s,clkrm_s,\
						sclkme_s,dxstat_s,fsxp_s,fsrp_s,clkxp_s,clkrp_s) \
   ((Uint16)(\
       (MCBSP_FMKS(PCR,CLKRP,clkrp_s))|\
       (MCBSP_FMKS(PCR,CLKXP,clkxp_s))|\
       (MCBSP_FMKS(PCR,FSRP,fsrp_s))|\
       (MCBSP_FMKS(PCR,FSXP,fsxp_s))|\
       (MCBSP_FMKS(PCR,CLKRM,clkrm_s))|\
       (MCBSP_FMKS(PCR,DXSTAT,dxstat_s))|\
       (MCBSP_FMKS(PCR,CLKXM,clkxm_s))|\
       (MCBSP_FMKS(PCR,SCLKME,sclkme_s))|\
       (MCBSP_FMKS(PCR,FSRM,fsrm_s))|\
       (MCBSP_FMKS(PCR,FSXM,fsxm_s))|\
       (MCBSP_FMKS(PCR,RIOEN,rioen_s))|\
       (MCBSP_FMKS(PCR,XIOEN,xioen_s))|\
       (MCBSP_FMKS(PCR,IDLEEN,idleen_s))\
       )\
     )

#else
#define MCBSP_PCR_RMK(xioen,rioen,fsxm,fsrm,clkxm,clkrm,\
						sclkme,dxstat,fsxp,fsrp,clkxp,clkrp) \
   ((Uint16)(\
       (MCBSP_FMK(PCR,CLKRP,clkrp))       |\
       (MCBSP_FMK(PCR,CLKXP,clkxp))       |\
       (MCBSP_FMK(PCR,FSRP,fsrp))         |\
       (MCBSP_FMK(PCR,FSXP,fsxp))         |\
       (MCBSP_FMK(PCR,CLKRM,clkrm))       |\
       (MCBSP_FMK(PCR,CLKXM,clkxm))       |\
       (MCBSP_FMK(PCR,DXSTAT,dxstat))     |\
       (MCBSP_FMK(PCR,SCLKME,sclkme))     |\
       (MCBSP_FMK(PCR,FSRM,fsrm))         |\
       (MCBSP_FMK(PCR,FSXM,fsxm))         |\
       (MCBSP_FMK(PCR,RIOEN,rioen))       |\
       (MCBSP_FMK(PCR,XIOEN,xioen))       \
       )\
     )

#define MCBSP_PCR_RMKS(xioen_s,rioen_s,fsxm_s,fsrm_s,clkxm_s,clkrm_s,\
						sclkme_s,dxstat_s,fsxp_s,fsrp_s,clkxp_s,clkrp_s) \
   ((Uint16)(\
       (MCBSP_FMKS(PCR,CLKRP,clkrp_s))|\
       (MCBSP_FMKS(PCR,CLKXP,clkxp_s))|\
       (MCBSP_FMKS(PCR,FSRP,fsrp_s))|\
       (MCBSP_FMKS(PCR,FSXP,fsxp_s))|\
       (MCBSP_FMKS(PCR,CLKRM,clkrm_s))|\
       (MCBSP_FMKS(PCR,CLKXM,clkxm_s))|\
       (MCBSP_FMKS(PCR,SCLKME,sclkme_s))|\
       (MCBSP_FMKS(PCR,FSRM,fsrm_s))|\
       (MCBSP_FMKS(PCR,FSXM,fsxm_s))|\
       (MCBSP_FMKS(PCR,RIOEN,rioen_s))|\
       (MCBSP_FMKS(PCR,XIOEN,xioen_s))\
       )\
     )

#endif

/* PCR field values */
#define MCBSP_PCR_CLKRP_FALLING           (0x0000u)
#define MCBSP_PCR_CLKRP_RISING            (0x0001u)
#define MCBSP_PCR_CLKXP_RISING            (0x0000u)
#define MCBSP_PCR_CLKXP_FALLING           (0x0001u)
#define MCBSP_PCR_FSRP_ACTIVEHIGH         (0x0000u)
#define MCBSP_PCR_FSRP_ACTIVELOW          (0x0001u)
#define MCBSP_PCR_FSXP_ACTIVEHIGH         (0x0000u)
#define MCBSP_PCR_FSXP_ACTIVELOW          (0x0001u)
#define MCBSP_PCR_DRSTAT_0                (0x0000u)
#define MCBSP_PCR_DRSTAT_1                (0x0001u)
#define MCBSP_PCR_DXSTAT_0                (0x0000u)
#define MCBSP_PCR_DXSTAT_1                (0x0001u)
#define MCBSP_PCR_CLKSSTAT_0              (0x0000u)
#define MCBSP_PCR_CLKSSTAT_1              (0x0001u)
#if(!CHIP_5502)
#define MCBSP_PCR_IDLEEN_RESET            (0x0000u)
#define MCBSP_PCR_IDLEEN_ON               (0x0001u)
#endif
#define MCBSP_PCR_SCLKME_BCLK             (0x0001u)
#define MCBSP_PCR_SCLKME_NO               (0x0000u)
#define MCBSP_PCR_CLKRM_INPUT             (0x0000u)
#define MCBSP_PCR_CLKRM_OUTPUT            (0x0001u)
#define MCBSP_PCR_CLKXM_INPUT             (0x0000u)
#define MCBSP_PCR_CLKXM_OUTPUT            (0x0001u)
#define MCBSP_PCR_FSRM_EXTERNAL           (0x0000u)
#define MCBSP_PCR_FSRM_INTERNAL           (0x0001u)
#define MCBSP_PCR_FSXM_EXTERNAL           (0x0000u)
#define MCBSP_PCR_FSXM_INTERNAL           (0x0001u)
#define MCBSP_PCR_RIOEN_SP                (0x0000u)
#define MCBSP_PCR_RIOEN_GPIO              (0x0001u)
#define MCBSP_PCR_XIOEN_SP                (0x0000u)
#define MCBSP_PCR_XIOEN_GPIO              (0x0001u)

/****************************************\
* MCBSP global typedef declarations
\****************************************/

/* device handle type */
typedef struct {
  Uint32 Private;
} MCBSP_Private,*MCBSP_Handle;

/* private object, not to be used by application code */
/* device configuration structure */
typedef struct {
  Uint16 spcr1;
  Uint16 spcr2;
  Uint16 rcr1;
  Uint16 rcr2;
  Uint16 xcr1;
  Uint16 xcr2;
  Uint16 srgr1;
  Uint16 srgr2;
  Uint16 mcr1;
  Uint16 mcr2;
  Uint16 pcr;
  Uint16 rcera;
  Uint16 rcerb;
  Uint16 rcerc;
  Uint16 rcerd;
  Uint16 rcere;
  Uint16 rcerf;
  Uint16 rcerg;
  Uint16 rcerh;
  Uint16 xcera;
  Uint16 xcerb;
  Uint16 xcerc;
  Uint16 xcerd;
  Uint16 xcere;
  Uint16 xcerf;
  Uint16 xcerg;
  Uint16 xcerh;

} MCBSP_Config;



/****************************************\
* MCBSP global variable declarations
\****************************************/

/****************************************\
* MCBSP global function declarations
\****************************************/
CSLAPI void MCBSP_init();
CSLAPI void MCBSP_reset(MCBSP_Handle _MCBSP);

CSLAPI MCBSP_Handle MCBSP_open(int DevNum, Uint32 Flags);
CSLAPI void MCBSP_close(MCBSP_Handle _MCBSP);

CSLAPI void MCBSP_config(MCBSP_Handle _MCBSP, MCBSP_Config *Config);
CSLAPI void MCBSP_configArgs(MCBSP_Handle _MCBSP, Uint16 spcr1, Uint16 spcr2,
  Uint16 rcr1, Uint16 rcr2, Uint16 xcr1, Uint16 xcr2,
  Uint16 srgr1, Uint16 srgr2,Uint16 mcr1, Uint16 mcr2,Uint16 pcr,
  Uint16 rcera, Uint16 rcerb, Uint16 rcerc, Uint16 rcerd,
  Uint16 rcere, Uint16 rcerf,Uint16 rcerg, Uint16 rcerh,
  Uint16 xcera,Uint16 xcerb, Uint16 xcerc,Uint16 xcerd,
  Uint16 xcere,Uint16 xcerf,Uint16 xcerg,Uint16 xcerh);

CSLAPI void MCBSP_getConfig(MCBSP_Handle _MCBSP, MCBSP_Config *Config);
CSLAPI CSLBool MCBSP_start(MCBSP_Handle hMcbsp, Uint16 StartMask, Uint32 SampleRateDelay);

/*------------------------------------------*\
 * Static Inline Functions
\*------------------------------------------*/

IDECL Uint32 MCBSP_read32(MCBSP_Handle _MCBSP);
IDECL void MCBSP_write32(MCBSP_Handle _MCBSP,Uint32 Val);
IDECL Uint16 MCBSP_read16(MCBSP_Handle _MCBSP);
IDECL Uint16 MCBSP_read(MCBSP_Handle _MCBSP);
IDECL void MCBSP_write16(MCBSP_Handle _MCBSP,Uint16 Val);
IDECL void MCBSP_write(MCBSP_Handle _MCBSP,Uint16 Val);

#ifdef USEDEFS
/*-----------------------------------------------------------------*/
IDEF Uint32 MCBSP_read32(MCBSP_Handle _MCBSP) {
  Uint16 drr2, drr1;
  Uint32 val;
  MCBSP_ASSERT_HANDLE(_MCBSP,return 0xFFFFFFFF);
  drr2 = _PREG_GET(((MCBSP_PrivateObj*)_MCBSP)->Drr2Addr);
  drr1 = _PREG_GET(((MCBSP_PrivateObj*)_MCBSP)->Drr1Addr);
  val = (((Uint32)drr2<<16)&0xFFFF0000 )|(drr1 &0x0000FFFF);
  return val;
}
/*-----------------------------------------------------------------*/
IDEF void MCBSP_write32(MCBSP_Handle _MCBSP,Uint32 Val) {
  MCBSP_ASSERT_HANDLE(_MCBSP,return);
  _PREG_SET((((MCBSP_PrivateObj*)_MCBSP)->Dxr2Addr),(Val>>16));
  _PREG_SET((((MCBSP_PrivateObj*)_MCBSP)->Dxr1Addr),(Val&0x0000FFFF));
}
/*-----------------------------------------------------------------*/
IDEF Uint16 MCBSP_read16(MCBSP_Handle _MCBSP) {
  Uint16 val;
  MCBSP_ASSERT_HANDLE(_MCBSP,return 0xFFFFFFFF);
  val = _PREG_GET(((MCBSP_PrivateObj*)_MCBSP)->Drr1Addr);
  return val;
}
/*-----------------------------------------------------------------*/
IDEF Uint16 MCBSP_read(MCBSP_Handle _MCBSP) {
  Uint16 val;
  MCBSP_ASSERT_HANDLE(_MCBSP,return 0xFFFFFFFF);
  val = _PREG_GET(((MCBSP_PrivateObj*)_MCBSP)->Drr1Addr);
  return val;
}
/*-----------------------------------------------------------------*/
IDEF void MCBSP_write16(MCBSP_Handle _MCBSP,Uint16 Val) {
MCBSP_ASSERT_HANDLE(_MCBSP,return);
_PREG_SET((((MCBSP_PrivateObj*)_MCBSP)->Dxr1Addr),(Val));
}
/*-----------------------------------------------------------------*/
IDEF void MCBSP_write(MCBSP_Handle _MCBSP,Uint16 Val) {
MCBSP_ASSERT_HANDLE(_MCBSP,return);
_PREG_SET((((MCBSP_PrivateObj*)_MCBSP)->Dxr1Addr),(Val));
}
#endif /* USEDEFS */

#endif /* MCBSP_SUPPORT */
#endif /* _MCBSP_H_ */
/******************************************************************************\
* End of csl_mcbsp.h
\******************************************************************************/

csl_mcbspdat.h/ 1051539337  0     0     0       13954     `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... MCBSP
* FILENAME...... csl_mcbspdat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       03/30/2000
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments
*   MODIFIED:      10 Apr 2003 added reference for CSL_McbspData for .csldata fix  
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the MCBSP module)
*       Reserved Area for MCBSP Data 
*
*
\******************************************************************************/
#ifndef _MCBSP_DATA_H_
#define _MCBSP_DATA_H_

#include <csl_std.h>

#define _MCBSP_PORT_CNT   3

#if (!CHIP_5502)
#define CSL_MCBSPDATAINIT\
{ /*MCBSP Port #0 Handle Initialization Data*/\
  0,                              /*MCBSP Port#*/\
  ((0)*0x0400u)+(0x2800u+ 0x1),   /*MCBSP0_Drr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x0),   /*MCBSP0_Drr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x3),   /*MCBSP0_Dxr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x2),   /*MCBSP0_Dxr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x5),   /*MCBSP0_Spcr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x4),   /*MCBSP0_Spcr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x7),   /*MCBSP0_Rcr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x6),   /*MCBSP0_Rcr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x9),   /*MCBSP0_Xcr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x8),   /*MCBSP0_Xcr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0xB),   /*MCBSP0_Srgr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0xA),   /*MCBSP0_Srgr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0xD),   /*MCBSP0_Mcr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0xC),   /*MCBSP0_Mcr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0xE),   /*MCBSP0_RceraAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0xF),   /*MCBSP0_RcerbAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x13),  /*MCBSP0_RcercAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x14),  /*MCBSP0_RcerdAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x17),  /*MCBSP0_RcereAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x18),  /*MCBSP0_RcerfAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1B),  /*MCBSP0_RcergAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1C),  /*MCBSP0_RcerhAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x10),  /*MCBSP0_XceraAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x11),  /*MCBSP0_XcerbAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x15),  /*MCBSP0_XcercAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x16),  /*MCBSP0_XcerdAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x19),  /*MCBSP0_XcereAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1A),  /*MCBSP0_XcerfAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1D),  /*MCBSP0_XcergAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1E),  /*MCBSP0_XcerhAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x12),  /*MCBSP0_PcrAddr*/\
  17,                             /*MCBSP0_XmtEvent*/\
  5 ,                             /*MCBSP0_RcvEvent*/\
 /* MCBSP Port #1 Handle Initialization Data*/\
  1,                              /*MCBSP Port#*/\
  ((1)*0x0400u)+(0x2800u+ 0x1),   /*MCBSP1_Drr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x0),   /*MCBSP1_Drr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x3),   /*MCBSP1_Dxr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x2),   /*MCBSP1_Dxr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x5),   /*MCBSP1_Spcr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x4),   /*MCBSP1_Spcr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x7),   /*MCBSP1_Rcr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x6),   /*MCBSP1_Rcr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x9),   /*MCBSP1_Xcr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x8),   /*MCBSP1_Xcr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0xB),   /*MCBSP1_Srgr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0xA),   /*MCBSP1_Srgr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0xD),   /*MCBSP1_Mcr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0xC),   /*MCBSP1_Mcr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0xE),   /*MCBSP1_RceraAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0xF),   /*MCSBP0_RcerbAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x13),  /*MCBSP1_RcercAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x14),  /*MCBSP1_RcerdAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x17),  /*MCBSP1_RcereAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x18),  /*MCBSP1_RcerfAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1B),  /*MCBSP1_RcergAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1C),  /*MCBSP1_RcerhAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x10),  /*MCBSP1_XceraAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x11),  /*MCBSP1_XcerbAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x15),  /*MCBSP1_XcercAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x16),  /*MCBSP1_XcerdAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x19),  /*MCBSP1_XcereAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1A),  /*MCBSP1_XcerfAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1D),  /*MCBSP1_XcergAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1E),  /*MCBSP1_XcerhAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x12),  /*MCBSP1_PcrAddr*/\
  7,                              /*MCBSP1_XmtEvent*/\
  6,                              /*MCBSP1_RcvEvent*/\
 /* MCBSP Port #2 Handle Initialization Data*/\
  2,                              /*MCBSP Port#*/\
  ((2)*0x0400u)+(0x2800u+ 0x1),   /*MCBSP2_Drr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x0),   /*MCBSP2_Drr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x3),   /*MCBSP2_Dxr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x2),   /*MCBSP2_Dxr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x5),   /*MCBSP2_Spcr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x4),   /*MCBSP2_Spcr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x7),   /*MCBSP2_Rcr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x6),   /*MCBSP2_Rcr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x9),   /*MCBSP2_Xcr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x8),   /*MCBSP2_Xcr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0xB),   /*MCBSP2_Srgr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0xA),   /*MCBSP2_Srgr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0xD),   /*MCBSP2_Mcr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0xC),   /*MCBSP2_Mcr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0xE),   /*MCBSP2_RceraAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0xF),   /*MCBSP2_RcerbAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x13),  /*MCBSP2_RcercAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x14),  /*MCBSP2_RcerdAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x17),  /*MCBSP2_RcereAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x18),  /*MCBSP2_RcerfAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1B),  /*MCBSP2_RcergAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1C),  /*MCBSP2_RcerhAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x10),  /*MCBSP2_XceraAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x11),  /*MCBSP2_XcerbAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x15),  /*MCBSP2_XcercAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x16),  /*MCBSP2_XcerdAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x19),  /*MCBSP2_XcereAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1A),  /*MCBSP2_XcerfAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1D),  /*MCBSP2_XcergAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1E),  /*MCBSP2_XcerhAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x12),  /*MCBSP2_PcrAddr*/\
  13,                             /*MCBSP2_XmtEvent*/\
  12                              /*MCBSP2_RcvEvent*/\
}
#else
#define CSL_MCBSPDATAINIT\
{ /*MCBSP Port #0 Handle Initialization Data*/\
  0,                              /*MCBSP Port#*/\
  ((0)*0x0400u)+(0x2800u+ 0x0),   /*MCBSP0_Drr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1),   /*MCBSP0_Drr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x2),   /*MCBSP0_Dxr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x3),   /*MCBSP0_Dxr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x4),   /*MCBSP0_Spcr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x5),   /*MCBSP0_Spcr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x6),   /*MCBSP0_Rcr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x7),   /*MCBSP0_Rcr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x8),   /*MCBSP0_Xcr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0x9),   /*MCBSP0_Xcr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0xA),   /*MCBSP0_Srgr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0xB),   /*MCBSP0_Srgr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0xC),   /*MCBSP0_Mcr1Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0xD),   /*MCBSP0_Mcr2Addr*/\
  ((0)*0x0400u)+(0x2800u+ 0xE),   /*MCBSP0_RceraAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0xF),   /*MCBSP0_RcerbAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x14),  /*MCBSP0_RcercAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x15),  /*MCBSP0_RcerdAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x18),  /*MCBSP0_RcereAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x19),  /*MCBSP0_RcerfAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1C),  /*MCBSP0_RcergAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1D),  /*MCBSP0_RcerhAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x10),  /*MCBSP0_XceraAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x11),  /*MCBSP0_XcerbAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x16),  /*MCBSP0_XcercAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x17),  /*MCBSP0_XcerdAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1A),  /*MCBSP0_XcereAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1B),  /*MCBSP0_XcerfAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1E),  /*MCBSP0_XcergAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x1F),  /*MCBSP0_XcerhAddr*/\
  ((0)*0x0400u)+(0x2800u+ 0x12),  /*MCBSP0_PcrAddr*/\
  17,                             /*MCBSP0_XmtEvent*/\
  5 ,                             /*MCBSP0_RcvEvent*/\
 /* MCBSP Port #1 Handle Initialization Data*/\
  1,                              /*MCBSP Port#*/\
  ((1)*0x0400u)+(0x2800u+ 0x0),   /*MCBSP0_Drr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1),   /*MCBSP0_Drr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x2),   /*MCBSP0_Dxr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x3),   /*MCBSP0_Dxr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x4),   /*MCBSP0_Spcr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x5),   /*MCBSP0_Spcr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x6),   /*MCBSP0_Rcr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x7),   /*MCBSP0_Rcr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x8),   /*MCBSP0_Xcr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0x9),   /*MCBSP0_Xcr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0xA),   /*MCBSP0_Srgr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0xB),   /*MCBSP0_Srgr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0xC),   /*MCBSP0_Mcr1Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0xD),   /*MCBSP0_Mcr2Addr*/\
  ((1)*0x0400u)+(0x2800u+ 0xE),   /*MCBSP0_RceraAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0xF),   /*MCBSP0_RcerbAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x14),  /*MCBSP0_RcercAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x15),  /*MCBSP0_RcerdAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x18),  /*MCBSP0_RcereAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x19),  /*MCBSP0_RcerfAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1C),  /*MCBSP0_RcergAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1D),  /*MCBSP0_RcerhAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x10),  /*MCBSP0_XceraAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x11),  /*MCBSP0_XcerbAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x16),  /*MCBSP0_XcercAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x17),  /*MCBSP0_XcerdAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1A),  /*MCBSP0_XcereAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1B),  /*MCBSP0_XcerfAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1E),  /*MCBSP0_XcergAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x1F),  /*MCBSP0_XcerhAddr*/\
  ((1)*0x0400u)+(0x2800u+ 0x12),  /*MCBSP0_PcrAddr*/\
  7,                              /*MCBSP1_XmtEvent*/\
  6,                              /*MCBSP1_RcvEvent*/\
 /* MCBSP Port #2 Handle Initialization Data*/\
  2,                              /*MCBSP Port#*/\
  ((2)*0x0400u)+(0x2800u+ 0x0),   /*MCBSP0_Drr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1),   /*MCBSP0_Drr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x2),   /*MCBSP0_Dxr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x3),   /*MCBSP0_Dxr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x4),   /*MCBSP0_Spcr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x5),   /*MCBSP0_Spcr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x6),   /*MCBSP0_Rcr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x7),   /*MCBSP0_Rcr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x8),   /*MCBSP0_Xcr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0x9),   /*MCBSP0_Xcr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0xA),   /*MCBSP0_Srgr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0xB),   /*MCBSP0_Srgr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0xC),   /*MCBSP0_Mcr1Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0xD),   /*MCBSP0_Mcr2Addr*/\
  ((2)*0x0400u)+(0x2800u+ 0xE),   /*MCBSP0_RceraAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0xF),   /*MCBSP0_RcerbAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x14),  /*MCBSP0_RcercAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x15),  /*MCBSP0_RcerdAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x18),  /*MCBSP0_RcereAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x19),  /*MCBSP0_RcerfAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1C),  /*MCBSP0_RcergAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1D),  /*MCBSP0_RcerhAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x10),  /*MCBSP0_XceraAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x11),  /*MCBSP0_XcerbAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x16),  /*MCBSP0_XcercAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x17),  /*MCBSP0_XcerdAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1A),  /*MCBSP0_XcereAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1B),  /*MCBSP0_XcerfAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1E),  /*MCBSP0_XcergAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x1F),  /*MCBSP0_XcerhAddr*/\
  ((2)*0x0400u)+(0x2800u+ 0x12),  /*MCBSP0_PcrAddr*/\
  13,                             /*MCBSP2_XmtEvent*/\
  12                              /*MCBSP2_RcvEvent*/\
}
#endif

typedef struct {
  Uint16 Port;
  Uint16 Drr1Addr;
  Uint16 Drr2Addr;
  Uint16 Dxr1Addr;
  Uint16 Dxr2Addr;
  Uint16 Spcr1Addr;
  Uint16 Spcr2Addr;
  Uint16 Rcr1Addr;
  Uint16 Rcr2Addr;
  Uint16 Xcr1Addr;
  Uint16 Xcr2Addr;
  Uint16 Srgr1Addr;
  Uint16 Srgr2Addr;
  Uint16 Mcr1Addr;
  Uint16 Mcr2Addr;
  Uint16 RceraAddr;
  Uint16 RcerbAddr;
  Uint16 RcercAddr;
  Uint16 RcerdAddr;
  Uint16 RcereAddr;
  Uint16 RcerfAddr;
  Uint16 RcergAddr;
  Uint16 RcerhAddr;
  Uint16 XceraAddr;
  Uint16 XcerbAddr;
  Uint16 XcercAddr;
  Uint16 XcerdAddr;
  Uint16 XcereAddr;
  Uint16 XcerfAddr;
  Uint16 XcergAddr;
  Uint16 XcerhAddr;
  Uint16 PcrAddr;
  Uint16 XmtEvent;
  Uint16 RcvEvent;
} MCBSP_PrivateObj;

typedef struct {
  MCBSP_PrivateObj mcbspPort[_MCBSP_PORT_CNT];
} CSL_McbspDataObj;

extern CSL_McbspDataObj  CSL_McbspData;

#define CSL_MCBSP_DATA   CSL_McbspData

#endif
csl_mcbsphal.h/ 1065792083  0     0     0       206246    `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... MCBSP
* FILENAME...... csl_mcbsphal.h
* DATE CREATED.. Wed 05/31/2000
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. csl_stdinc.h, csl_chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:        05/31/2000 created
*   MODIFIED:       04/16/2001 updated FILENAME and other header comments
*   LAST MODIFIED:  05/23/2001 fixed _MCBSP_DXR/DRR base address macros
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the MCBSP module)
*
* Registers Covered:
*   (RW) _MCBSP_SPCR10 -  Serial Port Control Register 1, McBSP #0
*   (RW) _MCBSP_SPCR20 -  Serial Port Control Register 2, McBSP #0
*   (RW) _MCBSP_SPCR11 -  Serial Port Control Register 1, McBSP #1
*   (RW) _MCBSP_SPCR21 -  Serial Port Control Register 2, McBSP #1
*   (RW) _MCBSP_SPCR12 -  Serial Port Control Register 1, McBSP #2
*   (RW) _MCBSP_SPCR22_ -  Serial Port Control Register 2, McBSP #2
*   (RW) _MCBSP_PCR0    -  Pin Control Register, McBSP #0
*   (RW) _MCBSP_PCR1    -  Pin Control Register, McBSP #1
*   (RW) _MCBSP_PCR2    -  Pin Control Register, McBSP #2
*   (RW) _MCBSP_RCR10  -  Receive and Transmit Control Register 1, McBSP #0
*   (RW) _MCBSP_RCR20  -  Receive and Transmit Control Register 2, McBSP #0
*   (RW) _MCBSP_RCR11  -  Receive and Transmit Control Register 1, McBSP #1
*   (RW) _MCBSP_RCR21  -  Receive and Transmit Control Register 2, McBSP #1
*   (RW) _MCBSP_RCR12  -  Receive and Transmit Control Register 1, McBSP #2
*   (RW) _MCBSP_RCR22  -  Receive and Transmit Control Register 2, McBSP #2
*   (RW) _MCBSP_XCR10  -  Transmit Control Register 1, McBSP #0
*   (RW) _MCBSP_XCR20  -  Transmit Control Register 2, McBSP #0
*   (RW) _MCBSP_XCR11  -  Transmit Control Register 1, McBSP #1
*   (RW) _MCBSP_XCR21  -  Transmit Control Register 2, McBSP #1
*   (RW) _MCBSP_XCR12  -  Transmit Control Register 1, McBSP #2
*   (RW) _MCBSP_XCR22  -  Transmit Control Register 2, McBSP #2
*   (RW) _MCBSP_SRGR10 -  Sample Rate Generator Register 1, McBSP #0
*   (RW) _MCBSP_SRGR20 -  Sample Rate Generator Register 2, McBSP #0
*   (RW) _MCBSP_SRGR11 -  Sample Rate Generator Register 1, McBSP #1
*   (RW) _MCBSP_SRGR21 -  Sample Rate Generator Register 2, McBSP #1
*   (RW) _MCBSP_SRGR12 -  Sample Rate Generator Register 1, McBSP #2
*   (RW) _MCBSP_SRGR22 -  Sample Rate Generator Register 2, McBSP #2
*   (RW) _MCBSP_MCR10  -  Multi-channel Control Register 1, McBSP #0
*   (RW) _MCBSP_MCR20  -  Multi-channel Control Register 2, McBSP #0
*   (RW) _MCBSP_MCR11  -  Multi-channel Control Register 1, McBSP #1
*   (RW) _MCBSP_MCR21  -  Multi-channel Control Register 2, McBSP #1
*   (RW) _MCBSP_MCR12  -  Multi-channel Control Register 1, McBSP #2
*   (RW) _MCBSP_MCR22  -  Multi-channel Control Register 2, McBSP #2
*   (RW) _MCBSP_XCERA0 -  Transmit Channel Enable Register Partition A, McBSP #0
*   (RW) _MCBSP_XCERB0 -  Transmit Channel Enable Register Partition B, McBSP #0
*   (RW) _MCBSP_XCERC0 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_XCERD0 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_XCERE0 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_XCERF0 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_XCERG0 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_XCERH0 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_XCERA1 -  Transmit Channel Enable Register Partition A, McBSP #1
*   (RW) _MCBSP_XCERB1 -  Transmit Channel Enable Register Partition B, McBSP #1
*   (RW) _MCBSP_XCERC1 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_XCERD1 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_XCERE1 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_XCERF1 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_XCERG1 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_XCERH1 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_XCERA2 -  Transmit Channel Enable Register Partition A, McBSP #2
*   (RW) _MCBSP_XCERB2 -  Transmit Channel Enable Register Partition B, McBSP #2
*   (RW) _MCBSP_XCERC2 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_XCERD2 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_XCERE2 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_XCERF2 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_XCERG2 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_XCERH2 -  Additional Transmit Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_RCERA0 -  Receive Channel Enable Register Partition A, McBSP #0
*   (RW) _MCBSP_RCERB0 -  Receive Channel Enable Register Partition A, McBSP #0
*   (RW) _MCBSP_RCERC0 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_RCERD0 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_RCERE0 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_RCERF0 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_RCERG0 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_RCERH0 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #0
*   (RW) _MCBSP_RCERA1 -  Receive Channel Enable Register Partition A, McBSP #1
*   (RW) _MCBSP_RCERB1 -  Receive Channel Enable Register Partition A, McBSP #1
*   (RW) _MCBSP_RCERC1 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_RCERD1 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_RCERE1 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_RCERF1 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_RCERG1 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_RCERH1 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #1
*   (RW) _MCBSP_RCERA2 -  Receive Channel Enable Register Partition A, McBSP #2
*   (RW) _MCBSP_RCERB2 -  Receive Channel Enable Register Partition A, McBSP #2
*   (RW) _MCBSP_RCERC2 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_RCERD2 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_RCERE2 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_RCERF2 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_RCERG2 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_RCERH2 -  Additional Receive Channel Enable Register for 128 channel selection, McBSP #2
*   (RW) _MCBSP_DRR10  -  Data Receive Register 1, McBSP #0
*   (RW) _MCBSP_DRR20  -  Data Receive Register 2, McBSP #0
*   (RW) _MCBSP_DRR11  -  Data Receive Register 1, McBSP #1
*   (RW) _MCBSP_DRR21  -  Data Receive Register 2, McBSP #1
*   (RW) _MCBSP_DRR12  -  Data Receive Register 1, McBSP #2
*   (RW) _MCBSP_DRR22  -  Data Receive Register 2, McBSP #2
*   (RW) _MCBSP_DXR10  -  Data Transmit Register 1, McBSP #0
*   (RW) _MCBSP_DXR20  -  Data Transmist Register 2, McBSP #0
*   (RW) _MCBSP_DXR11  -  Data Transmit Register 1, McBSP #1
*   (RW) _MCBSP_DXR21  -  Data Transmist Register 2, McBSP #1
*   (RW) _MCBSP_DXR12  -  Data Transmit Register 1, McBSP #2
*   (RW) _MCBSP_DXR22  -  Data Transmist Register 2, McBSP #2
\******************************************************************************/
#ifndef _MCBSPHAL_H_
#define _MCBSPHAL_H_

#include <csl_chiphal.h>

#if (_MCBSP_SUPPORT)

/*============================================================================*\
* misc declarations
\*============================================================================*/
#define _MCBSP_DEVICE_CNT			(3)

/*============================================================================*\
* memory mapped register addresses
\*============================================================================*/

#if (!CHIP_5502)
  #define _MCBSP_DRR20_ADDR			(0x2800u)
  #define _MCBSP_DRR10_ADDR			(0x2801u)
  #define _MCBSP_DXR20_ADDR               (0x2802u)
  #define _MCBSP_DXR10_ADDR               (0x2803u)

  #define _MCBSP_DRR21_ADDR			(0x2C00u)
  #define _MCBSP_DRR11_ADDR			(0x2C01u)
  #define _MCBSP_DXR21_ADDR               (0x2C02u)
  #define _MCBSP_DXR11_ADDR               (0x2C03u)

  #define _MCBSP_DRR22_ADDR			(0x3000u)
  #define _MCBSP_DRR12_ADDR			(0x3001u)
  #define _MCBSP_DXR22_ADDR			(0x3002u)
  #define _MCBSP_DXR12_ADDR			(0x3003u)

  #define _MCBSP_DRR1_BASE_ADDR             (0x2801u)
  #define _MCBSP_DRR2_BASE_ADDR             (0x2800u)
  #define _MCBSP_DXR1_BASE_ADDR             (0x2803u)
  #define _MCBSP_DXR2_BASE_ADDR             (0x2802u)

  #define _MCBSP_SPCR1_BASE_ADDR            (0x2805u)
  #define _MCBSP_SPCR2_BASE_ADDR            (0x2804u)
  #define _MCBSP_PCR_BASE_ADDR              (0x2812u)
  #define _MCBSP_RCR1_BASE_ADDR             (0x2807u)
  #define _MCBSP_RCR2_BASE_ADDR             (0x2806u)
  #define _MCBSP_XCR1_BASE_ADDR             (0x2809u)
  #define _MCBSP_XCR2_BASE_ADDR             (0x2808u)
  #define _MCBSP_SRGR1_BASE_ADDR            (0x280Bu)
  #define _MCBSP_SRGR2_BASE_ADDR            (0x280Au)
  #define _MCBSP_MCR1_BASE_ADDR             (0x280Du)
  #define _MCBSP_MCR2_BASE_ADDR             (0x280Cu)

  #define _MCBSP_XCERA_BASE_ADDR            (0x2810u)
  #define _MCBSP_XCERB_BASE_ADDR            (0x2811u)
  #define _MCBSP_XCERC_BASE_ADDR            (0x2815u)
  #define _MCBSP_XCERD_BASE_ADDR            (0x2816u)
  #define _MCBSP_XCERE_BASE_ADDR            (0x2819u)
  #define _MCBSP_XCERF_BASE_ADDR            (0x281Au)
  #define _MCBSP_XCERG_BASE_ADDR            (0x281Du)
  #define _MCBSP_XCERH_BASE_ADDR            (0x281Eu)

  #define _MCBSP_RCERA_BASE_ADDR            (0x280Eu)
  #define _MCBSP_RCERB_BASE_ADDR            (0x280Fu)
  #define _MCBSP_RCERC_BASE_ADDR            (0x2813u)
  #define _MCBSP_RCERD_BASE_ADDR            (0x2814u)
  #define _MCBSP_RCERE_BASE_ADDR            (0x2817u)
  #define _MCBSP_RCERF_BASE_ADDR            (0x2818u)
  #define _MCBSP_RCERG_BASE_ADDR            (0x281Bu)
  #define _MCBSP_RCERH_BASE_ADDR            (0x281Cu)
#else
  #define _MCBSP_DRR10_ADDR			(0x2800u)
  #define _MCBSP_DRR20_ADDR			(0x2801u)
  #define _MCBSP_DXR10_ADDR               (0x2802u)
  #define _MCBSP_DXR20_ADDR               (0x2803u)

  #define _MCBSP_DRR11_ADDR			(0x2C00u)
  #define _MCBSP_DRR21_ADDR			(0x2C01u)
  #define _MCBSP_DXR11_ADDR               (0x2C02u)
  #define _MCBSP_DXR21_ADDR               (0x2C03u)

  #define _MCBSP_DRR12_ADDR			(0x3000u)
  #define _MCBSP_DRR22_ADDR			(0x3001u)
  #define _MCBSP_DXR12_ADDR			(0x3002u)
  #define _MCBSP_DXR22_ADDR			(0x3003u)

  #define _MCBSP_DRR2_BASE_ADDR             (0x2801u)
  #define _MCBSP_DRR1_BASE_ADDR             (0x2800u)
  #define _MCBSP_DXR2_BASE_ADDR             (0x2803u)
  #define _MCBSP_DXR1_BASE_ADDR             (0x2802u)

  #define _MCBSP_SPCR2_BASE_ADDR            (0x2805u)
  #define _MCBSP_SPCR1_BASE_ADDR            (0x2804u)
  #define _MCBSP_PCR_BASE_ADDR              (0x2812u)
  #define _MCBSP_RCR2_BASE_ADDR             (0x2807u)
  #define _MCBSP_RCR1_BASE_ADDR             (0x2806u)
  #define _MCBSP_XCR2_BASE_ADDR             (0x2809u)
  #define _MCBSP_XCR1_BASE_ADDR             (0x2808u)
  #define _MCBSP_SRGR2_BASE_ADDR            (0x280Bu)
  #define _MCBSP_SRGR1_BASE_ADDR            (0x280Au)
  #define _MCBSP_MCR2_BASE_ADDR             (0x280Du)
  #define _MCBSP_MCR1_BASE_ADDR             (0x280Cu)

  #define _MCBSP_XCERA_BASE_ADDR            (0x2810u)
  #define _MCBSP_XCERB_BASE_ADDR            (0x2811u)
  #define _MCBSP_XCERC_BASE_ADDR            (0x2816u)
  #define _MCBSP_XCERD_BASE_ADDR            (0x2817u)
  #define _MCBSP_XCERE_BASE_ADDR            (0x281Au)
  #define _MCBSP_XCERF_BASE_ADDR            (0x281Bu)
  #define _MCBSP_XCERG_BASE_ADDR            (0x281Eu)
  #define _MCBSP_XCERH_BASE_ADDR            (0x281Fu)

  #define _MCBSP_RCERA_BASE_ADDR            (0x280Eu)
  #define _MCBSP_RCERB_BASE_ADDR            (0x280Fu)
  #define _MCBSP_RCERC_BASE_ADDR            (0x2814u)
  #define _MCBSP_RCERD_BASE_ADDR            (0x2815u)
  #define _MCBSP_RCERE_BASE_ADDR            (0x2818u)
  #define _MCBSP_RCERF_BASE_ADDR            (0x2819u)
  #define _MCBSP_RCERG_BASE_ADDR            (0x281Cu)
  #define _MCBSP_RCERH_BASE_ADDR            (0x281Du)
#endif
#define _MCBSP_RCERA_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_RCERA_BASE_ADDR)
#define _MCBSP_RCERB_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_RCERB_BASE_ADDR)
#define _MCBSP_RCERC_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_RCERC_BASE_ADDR)
#define _MCBSP_RCERD_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_RCERD_BASE_ADDR)
#define _MCBSP_RCERE_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_RCERE_BASE_ADDR)
#define _MCBSP_RCERF_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_RCERF_BASE_ADDR)
#define _MCBSP_RCERG_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_RCERG_BASE_ADDR)
#define _MCBSP_RCERH_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_RCERH_BASE_ADDR)

#define _MCBSP_XCERA_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_XCERA_BASE_ADDR)
#define _MCBSP_XCERB_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_XCERB_BASE_ADDR)
#define _MCBSP_XCERC_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_XCERC_BASE_ADDR)
#define _MCBSP_XCERD_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_XCERD_BASE_ADDR)
#define _MCBSP_XCERE_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_XCERE_BASE_ADDR)
#define _MCBSP_XCERF_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_XCERF_BASE_ADDR)
#define _MCBSP_XCERG_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_XCERG_BASE_ADDR)
#define _MCBSP_XCERH_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_XCERH_BASE_ADDR)


#define _MCBSP_SPCR1_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_SPCR1_BASE_ADDR)
#define _MCBSP_SPCR2_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_SPCR2_BASE_ADDR)
#define _MCBSP_RCR1_ADDR(Port)            ((Port * 0x0400u) + _MCBSP_RCR1_BASE_ADDR)
#define _MCBSP_RCR2_ADDR(Port)            ((Port * 0x0400u) + _MCBSP_RCR2_BASE_ADDR)
#define _MCBSP_XCR1_ADDR(Port)            ((Port * 0x0400u) + _MCBSP_XCR1_BASE_ADDR)
#define _MCBSP_XCR2_ADDR(Port)            ((Port * 0x0400u) + _MCBSP_XCR2_BASE_ADDR)
#define _MCBSP_MCR1_ADDR(Port)            ((Port * 0x0400u) + _MCBSP_MCR1_BASE_ADDR)
#define _MCBSP_MCR2_ADDR(Port)            ((Port * 0x0400u) + _MCBSP_MCR2_BASE_ADDR)
#define _MCBSP_SRGR1_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_SRGR1_BASE_ADDR)
#define _MCBSP_SRGR2_ADDR(Port)           ((Port * 0x0400u) + _MCBSP_SRGR2_BASE_ADDR)
#define _MCBSP_PCR_ADDR(Port)             ((Port * 0x0400u) + _MCBSP_PCR_BASE_ADDR)


#define _MCBSP_DRR1_ADDR(Port)            ((Port * 0x0400u) + _MCBSP_DRR1_BASE_ADDR)
#define _MCBSP_DRR2_ADDR(Port)            ((Port * 0x0400u) + _MCBSP_DRR2_BASE_ADDR)
#define _MCBSP_DXR1_ADDR(Port)            ((Port * 0x0400u) + _MCBSP_DXR1_BASE_ADDR)
#define _MCBSP_DXR2_ADDR(Port)            ((Port * 0x0400u) + _MCBSP_DXR2_BASE_ADDR)


#define MCBSP_ADDR(Reg)                   (_MCBSP_##Reg##_ADDR)
#define MCBSP_RGET(Reg)                    _PREG_GET(MCBSP_ADDR(##Reg))
#define MCBSP_RSET(Reg,Val)                _PREG_SET(MCBSP_ADDR(##Reg),Val)
#define MCBSP_RAOI(Reg,AND,OR,INV)         _PREG_AOI(MCBSP_ADDR(##Reg),AND,OR,INV)

#define MCBSP_FGET(Reg,Field)              _MCBSP_##Reg##_FGET(##Field)
#define MCBSP_FSET(Reg,Field,Val)          _MCBSP_##Reg##_FSET(##Field,Val)
#define MCBSP_FMK(Reg,Field,Val)           _MCBSP_##Reg##_FMK(##Field,Val)
#define MCBSP_FMKS(Reg,Field,Sym)          _MCBSP_##Reg##_FMKS(##Field,Sym)
#define MCBSP_FAOI(Reg,Field,AND,OR,INV)   _MCBSP_##Reg##_FAOI(##Field,AND,OR,INV)

#define MCBSP_ADDRH(Handle,Reg)            (_MCBSP_##Reg##_ADDR(((MCBSP_PrivateObj*)(Handle))->Port))
#define MCBSP_RGETH(Handle,Reg)             _PREG_GET(MCBSP_ADDRH(Handle,##Reg))
#define MCBSP_RSETH(Handle,Reg,Val)         _PREG_SET(MCBSP_ADDRH(Handle,##Reg),Val)
#define MCBSP_RAOIH(Handle,Reg,AND,OR,INV)  _PREG_AOI(MCBSP_ADDRH(Handle,##Reg),AND,OR,INV)

#define MCBSP_FGETH(Handle,Reg,Field)       _MCBSP_##Reg##_FGET(((MCBSP_PrivateObj*)(Handle))->Port,##Field)
#define MCBSP_FSETH(Handle,Reg,Field,Val)   _MCBSP_##Reg##_FSET(((MCBSP_PrivateObj*)(Handle))->Port,##Field,Val)
#define MCBSP_FAOIH(Reg,Field,AND,OR,INV)\
   _PFIELD_AOI(MCBSP_ADDRH(Handle,##Reg),_MCBSP_##Reg##_##Field,AND,OR,INV)

#define MCBSP_ADDR_H(Handle,Reg)            (_MCBSP_##Reg##_ADDR(((MCBSP_PrivateObj*)(Handle))->Port))
#define MCBSP_RGET_H(Handle,Reg)             _PREG_GET(MCBSP_ADDRH(Handle,##Reg))
#define MCBSP_RSET_H(Handle,Reg,Val)         _PREG_SET(MCBSP_ADDRH(Handle,##Reg),Val)
#define MCBSP_RAOI_H(Handle,Reg,AND,OR,INV)  _PREG_AOI(MCBSP_ADDRH(Handle,##Reg),AND,OR,INV)

#define MCBSP_FGET_H(Handle,Reg,Field)       _MCBSP_##Reg##_FGET(((MCBSP_PrivateObj*)(Handle))->Port,##Field)
#define MCBSP_FSET_H(Handle,Reg,Field,Val)   _MCBSP_##Reg##_FSET(((MCBSP_PrivateObj*)(Handle))->Port,##Field,Val)
#define MCBSP_FAOI_H(Reg,Field,AND,OR,INV)\
   _PFIELD_AOI(MCBSP_ADDR_H(Handle,##Reg),_MCBSP_##Reg##_##Field,AND,OR,INV)

#define _MCBSP_SPCR1_FGET(Port,Field)      _PFIELD_GET(_MCBSP_SPCR1_ADDR(Port),_MCBSP_SPCR1_##Field)
#define _MCBSP_SPCR1_FSET(Port,Field,Val)  _PFIELD_SET(_MCBSP_SPCR1_ADDR(Port),_MCBSP_SPCR1_##Field,Val)
#define _MCBSP_SPCR1_FSETS(Port,Field,Sym)\
  MCBSP_SPCR1_FSET(Port,##Field,MCBSP_SPCR1_##Field##_##Sym)

#define _MCBSP_SPCR1_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_SET(_MCBSP_SPCR1_ADDR(Port),_MCBSP_SPCR1_##Field,AND,OR,INV)
#define _MCBSP_SPCR1_FMK(Field,Val)        _MCBSP_SPCR1_##Field##_MK(Val)
#define _MCBSP_SPCR1_FMKS(Field,Sym)       _MCBSP_SPCR1_##Field##_MK(MCBSP_SPCR1_##Field##_##Sym)

#define _MCBSP_SPCR10_FGET(Field)            _MCBSP_SPCR1_FGET(0,##Field)
#define _MCBSP_SPCR11_FGET(Field)            _MCBSP_SPCR1_FGET(1,##Field)
#define _MCBSP_SPCR12_FGET(Field)            _MCBSP_SPCR1_FGET(2,##Field)
#define _MCBSP_SPCR10_FSET(Field,Val)        _MCBSP_SPCR1_FSET(0,##Field,Val)
#define _MCBSP_SPCR11_FSET(Field,Val)        _MCBSP_SPCR1_FSET(1,##Field,Val)
#define _MCBSP_SPCR12_FSET(Field,Val)        _MCBSP_SPCR1_FSET(2,##Field,Val)
#define _MCBSP_SPCR10_FSETS(Field,Sym)       _MCBSP_SPCR1_FSETS(0,##Field,Sym)
#define _MCBSP_SPCR11_FSETS(Field,Sym)       _MCBSP_SPCR1_FSETS(1,##Field,Sym)
#define _MCBSP_SPCR12_FSETS(Field,Sym)       _MCBSP_SPCR1_FSETS(2,##Field,Sym)
#define _MCBSP_SPCR10_FAOI(Field,AND,OR,INV) _MCBSP_SPCR1_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_SPCR11_FAOI(Field,AND,OR,INV) _MCBSP_SPCR1_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_SPCR12_FAOI(Field,AND,OR,INV) _MCBSP_SPCR1_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_SPCR10_FMK(Field,Val)         _MCBSP_SPCR1_##Field##_MK(Val)
#define _MCBSP_SPCR11_FMK(Field,Val)         _MCBSP_SPCR1_##Field##_MK(Val)
#define _MCBSP_SPCR12_FMK(Field,Val)         _MCBSP_SPCR1_##Field##_MK(Val)
#define _MCBSP_SPCR10_FMKS(Field,Sym)        _MCBSP_SPCR1_##Field##_MK(MCBSP_SPCR1_##Field##_##Sym)
#define _MCBSP_SPCR11_FMKS(Field,Sym)        _MCBSP_SPCR1_##Field##_MK(MCBSP_SPCR1_##Field##_##Sym)
#define _MCBSP_SPCR12_FMKS(Field,Sym)        _MCBSP_SPCR1_##Field##_MK(MCBSP_SPCR1_##Field##_##Sym)

#define _MCBSP_SPCR2_FGET(Port,Field)      _PFIELD_GET(_MCBSP_SPCR2_ADDR(Port),_MCBSP_SPCR2_##Field)
#define _MCBSP_SPCR2_FSET(Port,Field,Val)  _PFIELD_SET(_MCBSP_SPCR2_ADDR(Port),_MCBSP_SPCR2_##Field,Val)
#define _MCBSP_SPCR2_FSETS(Port,Field,Sym)\
  MCBSP_SPCR2_FSET(Port,##Field,MCBSP_SPCR2_##Field##_##Sym)

#define _MCBSP_SPCR2_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_SET(_MCBSP_SPCR2_ADDR(Port),_MCBSP_SPCR2_##Field,AND,OR,INV)
#define _MCBSP_SPCR2_FMK(Field,Val)        _MCBSP_SPCR2_##Field##_MK(Val)
#define _MCBSP_SPCR2_FMKS(Field,Sym)       _MCBSP_SPCR2_##Field##_MK(MCBSP_SPCR2_##Field##_##Sym)

#define _MCBSP_SPCR20_FGET(Field)         _MCBSP_SPCR2_FGET(0,##Field)
#define _MCBSP_SPCR21_FGET(Field)         _MCBSP_SPCR2_FGET(1,##Field)
#define _MCBSP_SPCR22_FGET(Field)         _MCBSP_SPCR2_FGET(2,##Field)
#define _MCBSP_SPCR20_FSET(Field,Val)     _MCBSP_SPCR2_FSET(0,##Field,Val)
#define _MCBSP_SPCR21_FSET(Field,Val)     _MCBSP_SPCR2_FSET(1,##Field,Val)
#define _MCBSP_SPCR22_FSET(Field,Val)     _MCBSP_SPCR2_FSET(2,##Field,Val)
#define _MCBSP_SPCR20_FSETS(Field,Sym)    _MCBSP_SPCR2_FSETS(0,##Field,Sym)
#define _MCBSP_SPCR21_FSETS(Field,Sym)    _MCBSP_SPCR2_FSETS(1,##Field,Sym)
#define _MCBSP_SPCR22_FSETS(Field,Sym)    _MCBSP_SPCR2_FSETS(2,##Field,Sym)
#define _MCBSP_SPCR20_FAOI(Field,AND,OR,INV) _MCBSP_SPCR2_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_SPCR21_FAOI(Field,AND,OR,INV) _MCBSP_SPCR2_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_SPCR22_FAOI(Field,AND,OR,INV) _MCBSP_SPCR2_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_SPCR20_FMK(Field,Val)      _MCBSP_SPCR2_##Field##_MK(Val)
#define _MCBSP_SPCR21_FMK(Field,Val)      _MCBSP_SPCR2_##Field##_MK(Val)
#define _MCBSP_SPCR22_FMK(Field,Val)      _MCBSP_SPCR2_##Field##_MK(Val)
#define _MCBSP_SPCR20_FMKS(Field,Sym)     _MCBSP_SPCR2_##Field##_MK(MCBSP_SPCR2_##Field##_##Sym)
#define _MCBSP_SPCR21_FMKS(Field,Sym)     _MCBSP_SPCR2_##Field##_MK(MCBSP_SPCR2_##Field##_##Sym)
#define _MCBSP_SPCR22_FMKS(Field,Sym)     _MCBSP_SPCR2_##Field##_MK(MCBSP_SPCR2_##Field##_##Sym)

#define _MCBSP_SRGR1_FGET(Port,Field)      _PFIELD_GET(_MCBSP_SRGR1_ADDR(Port),_MCBSP_SRGR1_##Field)
#define _MCBSP_SRGR1_FSET(Port,Field,Val)  _PFIELD_SET(_MCBSP_SRGR1_ADDR(Port),_MCBSP_SRGR1_##Field,Val)
#define _MCBSP_SRGR1_FSETS(Port,Field,Sym)\
  MCBSP_SRGR1_FSET(Port,##Field,MCBSP_SRGR1_##Field##_##Sym)

#define _MCBSP_SRGR1_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_SET(_MCBSP_SRGR1_ADDR(Port),_MCBSP_SRGR1_##Field,AND,OR,INV)
#define _MCBSP_SRGR1_FMK(Field,Val)        _MCBSP_SRGR1_##Field##_MK(Val)
#define _MCBSP_SRGR1_FMKS(Field,Sym)       _MCBSP_SRGR1_##Field##_MK(MCBSP_SRGR1_##Field##_##Sym)

#define _MCBSP_SRGR10_FGET(Field)         _MCBSP_SRGR1_FGET(0,##Field)
#define _MCBSP_SRGR11_FGET(Field)         _MCBSP_SRGR1_FGET(1,##Field)
#define _MCBSP_SRGR12_FGET(Field)         _MCBSP_SRGR1_FGET(2,##Field)
#define _MCBSP_SRGR10_FSET(Field,Val)     _MCBSP_SRGR1_FSET(0,##Field,Val)
#define _MCBSP_SRGR11_FSET(Field,Val)     _MCBSP_SRGR1_FSET(1,##Field,Val)
#define _MCBSP_SRGR12_FSET(Field,Val)     _MCBSP_SRGR1_FSET(2,##Field,Val)
#define _MCBSP_SRGR10_FSETS(Field,Sym)    _MCBSP_SRGR1_FSETS(0,##Field,Sym)
#define _MCBSP_SRGR11_FSETS(Field,Sym)    _MCBSP_SRGR1_FSETS(1,##Field,Sym)
#define _MCBSP_SRGR12_FSETS(Field,Sym)    _MCBSP_SRGR1_FSETS(2,##Field,Sym)
#define _MCBSP_SRGR10_FAOI(Field,AND,OR,INV) _MCBSP_SRGR1_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_SRGR11_FAOI(Field,AND,OR,INV) _MCBSP_SRGR1_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_SRGR12_FAOI(Field,AND,OR,INV) _MCBSP_SRGR1_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_SRGR10_FMK(Field,Val)      _MCBSP_SRGR1_##Field##_MK(Val)
#define _MCBSP_SRGR11_FMK(Field,Val)      _MCBSP_SRGR1_##Field##_MK(Val)
#define _MCBSP_SRGR12_FMK(Field,Val)      _MCBSP_SRGR1_##Field##_MK(Val)
#define _MCBSP_SRGR10_FMKS(Field,Sym)     _MCBSP_SRGR1_##Field##_MK(MCBSP_SRGR1_##Field##_##Sym)
#define _MCBSP_SRGR11_FMKS(Field,Sym)     _MCBSP_SRGR1_##Field##_MK(MCBSP_SRGR1_##Field##_##Sym)
#define _MCBSP_SRGR12_FMKS(Field,Sym)     _MCBSP_SRGR1_##Field##_MK(MCBSP_SRGR1_##Field##_##Sym)

#define _MCBSP_SRGR2_FGET(Port,Field)      _PFIELD_GET(_MCBSP_SRGR2_ADDR(Port),_MCBSP_SRGR2_##Field)
#define _MCBSP_SRGR2_FSET(Port,Field,Val)  _PFIELD_SET(_MCBSP_SRGR2_ADDR(Port),_MCBSP_SRGR2_##Field,Val)
#define _MCBSP_SRGR2_FSETS(Port,Field,Sym)\
  MCBSP_SRGR2_FSET(Port,##Field,MCBSP_SRGR2_##Field##_##Sym)

#define _MCBSP_SRGR2_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_SET(_MCBSP_SRGR2_ADDR(Port),_MCBSP_SRGR2_##Field,AND,OR,INV)
#define _MCBSP_SRGR2_FMK(Field,Val)        _MCBSP_SRGR2_##Field##_MK(Val)
#define _MCBSP_SRGR2_FMKS(Field,Sym)       _MCBSP_SRGR2_##Field##_MK(MCBSP_SRGR2_##Field##_##Sym)

#define _MCBSP_SRGR20_FGET(Field)         _MCBSP_SRGR2_FGET(0,##Field)
#define _MCBSP_SRGR21_FGET(Field)         _MCBSP_SRGR2_FGET(1,##Field)
#define _MCBSP_SRGR22_FGET(Field)         _MCBSP_SRGR2_FGET(2,##Field)
#define _MCBSP_SRGR20_FSET(Field,Val)     _MCBSP_SRGR2_FSET(0,##Field,Val)
#define _MCBSP_SRGR21_FSET(Field,Val)     _MCBSP_SRGR2_FSET(1,##Field,Val)
#define _MCBSP_SRGR22_FSET(Field,Val)     _MCBSP_SRGR2_FSET(2,##Field,Val)
#define _MCBSP_SRGR20_FSETS(Field,Sym)    _MCBSP_SRGR2_FSETS(0,##Field,Sym)
#define _MCBSP_SRGR21_FSETS(Field,Sym)    _MCBSP_SRGR2_FSETS(1,##Field,Sym)
#define _MCBSP_SRGR22_FSETS(Field,Sym)    _MCBSP_SRGR2_FSETS(2,##Field,Sym)
#define _MCBSP_SRGR20_FAOI(Field,AND,OR,INV) _MCBSP_SRGR2_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_SRGR21_FAOI(Field,AND,OR,INV) _MCBSP_SRGR2_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_SRGR22_FAOI(Field,AND,OR,INV) _MCBSP_SRGR2_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_SRGR20_FMK(Field,Val)      _MCBSP_SRGR2_##Field##_MK(Val)
#define _MCBSP_SRGR21_FMK(Field,Val)      _MCBSP_SRGR2_##Field##_MK(Val)
#define _MCBSP_SRGR22_FMK(Field,Val)      _MCBSP_SRGR2_##Field##_MK(Val)
#define _MCBSP_SRGR20_FMKS(Field,Sym)     _MCBSP_SRGR2_##Field##_MK(MCBSP_SRGR2_##Field##_##Sym)
#define _MCBSP_SRGR21_FMKS(Field,Sym)     _MCBSP_SRGR2_##Field##_MK(MCBSP_SRGR2_##Field##_##Sym)
#define _MCBSP_SRGR22_FMKS(Field,Sym)     _MCBSP_SRGR2_##Field##_MK(MCBSP_SRGR2_##Field##_##Sym)

#define _MCBSP_RCR1_FGET(Port,Field)      _PFIELD_GET(_MCBSP_RCR1_ADDR(Port),_MCBSP_RCR1_##Field)
#define _MCBSP_RCR1_FSET(Port,Field,Val)  _PFIELD_SET(_MCBSP_RCR1_ADDR(Port),_MCBSP_RCR1_##Field,Val)
#define _MCBSP_RCR1_FSETS(Port,Field,Sym)\
  MCBSP_RCR1_FSET(Port,##Field,MCBSP_RCR1_##Field##_##Sym)

#define _MCBSP_RCR1_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_SET(_MCBSP_RCR1_ADDR(Port),_MCBSP_RCR1_##Field,AND,OR,INV)
#define _MCBSP_RCR1_FMK(Field,Val)        _MCBSP_RCR1_##Field##_MK(Val)
#define _MCBSP_RCR1_FMKS(Field,Sym)       _MCBSP_RCR1_##Field##_MK(MCBSP_RCR1_##Field##_##Sym)

#define _MCBSP_RCR10_FGET(Field)         _MCBSP_RCR1_FGET(0,##Field)
#define _MCBSP_RCR11_FGET(Field)         _MCBSP_RCR1_FGET(1,##Field)
#define _MCBSP_RCR12_FGET(Field)         _MCBSP_RCR1_FGET(2,##Field)
#define _MCBSP_RCR10_FSET(Field,Val)     _MCBSP_RCR1_FSET(0,##Field,Val)
#define _MCBSP_RCR11_FSET(Field,Val)     _MCBSP_RCR1_FSET(1,##Field,Val)
#define _MCBSP_RCR12_FSET(Field,Val)     _MCBSP_RCR1_FSET(2,##Field,Val)
#define _MCBSP_RCR10_FSETS(Field,Sym)    _MCBSP_RCR1_FSETS(0,##Field,Sym)
#define _MCBSP_RCR11_FSETS(Field,Sym)    _MCBSP_RCR1_FSETS(1,##Field,Sym)
#define _MCBSP_RCR12_FSETS(Field,Sym)    _MCBSP_RCR1_FSETS(2,##Field,Sym)
#define _MCBSP_RCR10_FAOI(Field,AND,OR,INV) _MCBSP_RCR1_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_RCR11_FAOI(Field,AND,OR,INV) _MCBSP_RCR1_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_RCR12_FAOI(Field,AND,OR,INV) _MCBSP_RCR1_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_RCR10_FMK(Field,Val)      _MCBSP_RCR1_##Field##_MK(Val)
#define _MCBSP_RCR11_FMK(Field,Val)      _MCBSP_RCR1_##Field##_MK(Val)
#define _MCBSP_RCR12_FMK(Field,Val)      _MCBSP_RCR1_##Field##_MK(Val)
#define _MCBSP_RCR10_FMKS(Field,Sym)     _MCBSP_RCR1_##Field##_MK(MCBSP_RCR1_##Field##_##Sym)
#define _MCBSP_RCR11_FMKS(Field,Sym)     _MCBSP_RCR1_##Field##_MK(MCBSP_RCR1_##Field##_##Sym)
#define _MCBSP_RCR12_FMKS(Field,Sym)     _MCBSP_RCR1_##Field##_MK(MCBSP_RCR1_##Field##_##Sym)

#define _MCBSP_RCR2_FGET(Port,Field)      _PFIELD_GET(_MCBSP_RCR2_ADDR(Port),_MCBSP_RCR2_##Field)
#define _MCBSP_RCR2_FSET(Port,Field,Val)  _PFIELD_SET(_MCBSP_RCR2_ADDR(Port),_MCBSP_RCR2_##Field,Val)
#define _MCBSP_RCR2_FSETS(Port,Field,Sym)\
  MCBSP_RCR2_FSET(Port,##Field,MCBSP_RCR2_##Field##_##Sym)

#define _MCBSP_RCR2_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_SET(_MCBSP_RCR2_ADDR(Port),_MCBSP_RCR2_##Field,AND,OR,INV)
#define _MCBSP_RCR2_FMK(Field,Val)        _MCBSP_RCR2_##Field##_MK(Val)
#define _MCBSP_RCR2_FMKS(Field,Sym)       _MCBSP_RCR2_##Field##_MK(MCBSP_RCR2_##Field##_##Sym)

#define _MCBSP_RCR20_FGET(Field)         _MCBSP_RCR2_FGET(0,##Field)
#define _MCBSP_RCR21_FGET(Field)         _MCBSP_RCR2_FGET(1,##Field)
#define _MCBSP_RCR22_FGET(Field)         _MCBSP_RCR2_FGET(2,##Field)
#define _MCBSP_RCR20_FSET(Field,Val)     _MCBSP_RCR2_FSET(0,##Field,Val)
#define _MCBSP_RCR21_FSET(Field,Val)     _MCBSP_RCR2_FSET(1,##Field,Val)
#define _MCBSP_RCR22_FSET(Field,Val)     _MCBSP_RCR2_FSET(2,##Field,Val)
#define _MCBSP_RCR20_FSETS(Field,Sym)    _MCBSP_RCR2_FSETS(0,##Field,Sym)
#define _MCBSP_RCR21_FSETS(Field,Sym)    _MCBSP_RCR2_FSETS(1,##Field,Sym)
#define _MCBSP_RCR22_FSETS(Field,Sym)    _MCBSP_RCR2_FSETS(2,##Field,Sym)
#define _MCBSP_RCR20_FAOI(Field,AND,OR,INV) _MCBSP_RCR2_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_RCR21_FAOI(Field,AND,OR,INV) _MCBSP_RCR2_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_RCR22_FAOI(Field,AND,OR,INV) _MCBSP_RCR2_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_RCR20_FMK(Field,Val)      _MCBSP_RCR2_##Field##_MK(Val)
#define _MCBSP_RCR21_FMK(Field,Val)      _MCBSP_RCR2_##Field##_MK(Val)
#define _MCBSP_RCR22_FMK(Field,Val)      _MCBSP_RCR2_##Field##_MK(Val)
#define _MCBSP_RCR20_FMKS(Field,Sym)     _MCBSP_RCR2_##Field##_MK(MCBSP_RCR2_##Field##_##Sym)
#define _MCBSP_RCR21_FMKS(Field,Sym)     _MCBSP_RCR2_##Field##_MK(MCBSP_RCR2_##Field##_##Sym)
#define _MCBSP_RCR22_FMKS(Field,Sym)     _MCBSP_RCR2_##Field##_MK(MCBSP_RCR2_##Field##_##Sym)

#define _MCBSP_XCR1_FGET(Port,Field)      _PFIELD_GET(_MCBSP_XCR1_ADDR(Port),_MCBSP_XCR1_##Field)
#define _MCBSP_XCR1_FSET(Port,Field,Val)  _PFIELD_SET(_MCBSP_XCR1_ADDR(Port),_MCBSP_XCR1_##Field,Val)
#define _MCBSP_XCR1_FSETS(Port,Field,Sym)\
  MCBSP_XCR1_FSET(Port,##Field,MCBSP_XCR1_##Field##_##Sym)

#define _MCBSP_XCR1_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_SET(_MCBSP_XCR1_ADDR(Port),_MCBSP_XCR1_##Field,AND,OR,INV)
#define _MCBSP_XCR1_FMK(Field,Val)        _MCBSP_XCR1_##Field##_MK(Val)
#define _MCBSP_XCR1_FMKS(Field,Sym)       _MCBSP_XCR1_##Field##_MK(MCBSP_XCR1_##Field##_##Sym)

#define _MCBSP_XCR10_FGET(Field)         _MCBSP_XCR1_FGET(0,##Field)
#define _MCBSP_XCR11_FGET(Field)         _MCBSP_XCR1_FGET(1,##Field)
#define _MCBSP_XCR12_FGET(Field)         _MCBSP_XCR1_FGET(2,##Field)
#define _MCBSP_XCR10_FSET(Field,Val)     _MCBSP_XCR1_FSET(0,##Field,Val)
#define _MCBSP_XCR11_FSET(Field,Val)     _MCBSP_XCR1_FSET(1,##Field,Val)
#define _MCBSP_XCR12_FSET(Field,Val)     _MCBSP_XCR1_FSET(2,##Field,Val)
#define _MCBSP_XCR10_FSETS(Field,Sym)    _MCBSP_XCR1_FSETS(0,##Field,Sym)
#define _MCBSP_XCR11_FSETS(Field,Sym)    _MCBSP_XCR1_FSETS(1,##Field,Sym)
#define _MCBSP_XCR12_FSETS(Field,Sym)    _MCBSP_XCR1_FSETS(2,##Field,Sym)
#define _MCBSP_XCR10_FAOI(Field,AND,OR,INV) _MCBSP_XCR1_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_XCR11_FAOI(Field,AND,OR,INV) _MCBSP_XCR1_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_XCR12_FAOI(Field,AND,OR,INV) _MCBSP_XCR1_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_XCR10_FMK(Field,Val)      _MCBSP_XCR1_##Field##_MK(Val)
#define _MCBSP_XCR11_FMK(Field,Val)      _MCBSP_XCR1_##Field##_MK(Val)
#define _MCBSP_XCR12_FMK(Field,Val)      _MCBSP_XCR1_##Field##_MK(Val)
#define _MCBSP_XCR10_FMKS(Field,Sym)     _MCBSP_XCR1_##Field##_MK(MCBSP_XCR1_##Field##_##Sym)
#define _MCBSP_XCR11_FMKS(Field,Sym)     _MCBSP_XCR1_##Field##_MK(MCBSP_XCR1_##Field##_##Sym)
#define _MCBSP_XCR12_FMKS(Field,Sym)     _MCBSP_XCR1_##Field##_MK(MCBSP_XCR1_##Field##_##Sym)

#define _MCBSP_XCR2_FGET(Port,Field)      _PFIELD_GET(_MCBSP_XCR2_ADDR(Port),_MCBSP_XCR2_##Field)
#define _MCBSP_XCR2_FSET(Port,Field,Val)  _PFIELD_SET(_MCBSP_XCR2_ADDR(Port),_MCBSP_XCR2_##Field,Val)
#define _MCBSP_XCR2_FSETS(Port,Field,Sym)\
  MCBSP_XCR2_FSET(Port,##Field,MCBSP_XCR2_##Field##_##Sym)

#define _MCBSP_XCR2_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_SET(_MCBSP_XCR2_ADDR(Port),_MCBSP_XCR2_##Field,AND,OR,INV)
#define _MCBSP_XCR2_FMK(Field,Val)        _MCBSP_XCR2_##Field##_MK(Val)
#define _MCBSP_XCR2_FMKS(Field,Sym)       _MCBSP_XCR2_##Field##_MK(MCBSP_XCR2_##Field##_##Sym)

#define _MCBSP_XCR20_FGET(Field)         _MCBSP_XCR2_FGET(0,##Field)
#define _MCBSP_XCR21_FGET(Field)         _MCBSP_XCR2_FGET(1,##Field)
#define _MCBSP_XCR22_FGET(Field)         _MCBSP_XCR2_FGET(2,##Field)
#define _MCBSP_XCR20_FSET(Field,Val)     _MCBSP_XCR2_FSET(0,##Field,Val)
#define _MCBSP_XCR21_FSET(Field,Val)     _MCBSP_XCR2_FSET(1,##Field,Val)
#define _MCBSP_XCR22_FSET(Field,Val)     _MCBSP_XCR2_FSET(2,##Field,Val)
#define _MCBSP_XCR20_FSETS(Field,Sym)    _MCBSP_XCR2_FSETS(0,##Field,Sym)
#define _MCBSP_XCR21_FSETS(Field,Sym)    _MCBSP_XCR2_FSETS(1,##Field,Sym)
#define _MCBSP_XCR22_FSETS(Field,Sym)    _MCBSP_XCR2_FSETS(2,##Field,Sym)
#define _MCBSP_XCR20_FAOI(Field,AND,OR,INV) _MCBSP_XCR2_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_XCR21_FAOI(Field,AND,OR,INV) _MCBSP_XCR2_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_XCR22_FAOI(Field,AND,OR,INV) _MCBSP_XCR2_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_XCR20_FMK(Field,Val)      _MCBSP_XCR2_##Field##_MK(Val)
#define _MCBSP_XCR21_FMK(Field,Val)      _MCBSP_XCR2_##Field##_MK(Val)
#define _MCBSP_XCR22_FMK(Field,Val)      _MCBSP_XCR2_##Field##_MK(Val)
#define _MCBSP_XCR20_FMKS(Field,Sym)     _MCBSP_XCR2_##Field##_MK(MCBSP_XCR2_##Field##_##Sym)
#define _MCBSP_XCR21_FMKS(Field,Sym)     _MCBSP_XCR2_##Field##_MK(MCBSP_XCR2_##Field##_##Sym)
#define _MCBSP_XCR22_FMKS(Field,Sym)     _MCBSP_XCR2_##Field##_MK(MCBSP_XCR2_##Field##_##Sym)


#define _MCBSP_MCR1_FGET(Port,Field)      _PFIELD_GET(_MCBSP_MCR1_ADDR(Port),_MCBSP_MCR1_##Field)
#define _MCBSP_MCR1_FSET(Port,Field,Val)  _PFIELD_SET(_MCBSP_MCR1_ADDR(Port),_MCBSP_MCR1_##Field,Val)
#define _MCBSP_MCR1_FSETS(Port,Field,Sym)\
  MCBSP_MCR1_FSET(Port,##Field,MCBSP_MCR1_##Field##_##Sym)

#define _MCBSP_MCR1_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_SET(_MCBSP_MCR1_ADDR(Port),_MCBSP_MCR1_##Field,AND,OR,INV)
#define _MCBSP_MCR1_FMK(Field,Val)        _MCBSP_MCR1_##Field##_MK(Val)
#define _MCBSP_MCR1_FMKS(Field,Sym)       _MCBSP_MCR1_##Field##_MK(MCBSP_MCR1_##Field##_##Sym)

#define _MCBSP_MCR10_FGET(Field)         _MCBSP_MCR1_FGET(0,##Field)
#define _MCBSP_MCR11_FGET(Field)         _MCBSP_MCR1_FGET(1,##Field)
#define _MCBSP_MCR12_FGET(Field)         _MCBSP_MCR1_FGET(2,##Field)
#define _MCBSP_MCR10_FSET(Field,Val)     _MCBSP_MCR1_FSET(0,##Field,Val)
#define _MCBSP_MCR11_FSET(Field,Val)     _MCBSP_MCR1_FSET(1,##Field,Val)
#define _MCBSP_MCR12_FSET(Field,Val)     _MCBSP_MCR1_FSET(2,##Field,Val)
#define _MCBSP_MCR10_FSETS(Field,Sym)    _MCBSP_MCR1_FSET(0,##Field,Sym)
#define _MCBSP_MCR11_FSETS(Field,Sym)    _MCBSP_MCR1_FSET(1,##Field,Sym)
#define _MCBSP_MCR12_FSETS(Field,Sym)    _MCBSP_MCR1_FSET(2,##Field,Sym)
#define _MCBSP_MCR10_FAOI(Field,AND,OR,INV) _MCBSP_MCR_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_MCR11_FAOI(Field,AND,OR,INV) _MCBSP_MCR_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_MCR12_FAOI(Field,AND,OR,INV) _MCBSP_MCR_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_MCR10_FMK(Field,Val)      _MCBSP_MCR1_##Field##_MK(Val)
#define _MCBSP_MCR11_FMK(Field,Val)      _MCBSP_MCR1_##Field##_MK(Val)
#define _MCBSP_MCR12_FMK(Field,Val)      _MCBSP_MCR1_##Field##_MK(Val)
#define _MCBSP_MCR10_FMKS(Field,Sym)     _MCBSP_MCR1_##Field##_MK(MCBSP_MCR1_##Field##_##Sym)
#define _MCBSP_MCR11_FMKS(Field,Sym)     _MCBSP_MCR1_##Field##_MK(MCBSP_MCR1_##Field##_##Sym)
#define _MCBSP_MCR12_FMKS(Field,Sym)     _MCBSP_MCR1_##Field##_MK(MCBSP_MCR1_##Field##_##Sym)


#define _MCBSP_MCR2_FGET(Port,Field)      _PFIELD_GET(_MCBSP_MCR2_ADDR(Port),_MCBSP_MCR2_##Field)
#define _MCBSP_MCR2_FSET(Port,Field,Val)  _PFIELD_SET(_MCBSP_MCR2_ADDR(Port),_MCBSP_MCR2_##Field,Val)
#define _MCBSP_MCR2_FSETS(Port,Field,Sym)\
  MCBSP_MCR2_FSET(Port,##Field,MCBSP_MCR2_##Field##_##Sym)

#define _MCBSP_MCR2_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_SET(_MCBSP_MCR2_ADDR(Port),_MCBSP_MCR2_##Field,AND,OR,INV)
#define _MCBSP_MCR2_FMK(Field,Val)        _MCBSP_MCR2_##Field##_MK(Val)
#define _MCBSP_MCR2_FMKS(Field,Sym)       _MCBSP_MCR2_##Field##_MK(MCBSP_MCR2_##Field##_##Sym)

#define _MCBSP_MCR20_FGET(Field)         _MCBSP_MCR2_FGET(0,##Field)
#define _MCBSP_MCR21_FGET(Field)         _MCBSP_MCR2_FGET(1,##Field)
#define _MCBSP_MCR22_FGET(Field)         _MCBSP_MCR2_FGET(2,##Field)
#define _MCBSP_MCR20_FSET(Field,Val)     _MCBSP_MCR2_FSET(0,##Field,Val)
#define _MCBSP_MCR21_FSET(Field,Val)     _MCBSP_MCR2_FSET(1,##Field,Val)
#define _MCBSP_MCR22_FSET(Field,Val)     _MCBSP_MCR2_FSET(2,##Field,Val)
#define _MCBSP_MCR20_FSETS(Field,Sym)    _MCBSP_MCR2_FSETS(0,##Field,Sym)
#define _MCBSP_MCR21_FSETS(Field,Sym)    _MCBSP_MCR2_FSETS(1,##Field,Sym)
#define _MCBSP_MCR22_FSETS(Field,Sym)    _MCBSP_MCR2_FSETS(2,##Field,Sym)
#define _MCBSP_MCR20_FAOI(Field,AND,OR,INV) _MCBSP_MCR_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_MCR21_FAOI(Field,AND,OR,INV) _MCBSP_MCR_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_MCR22_FAOI(Field,AND,OR,INV) _MCBSP_MCR_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_MCR20_FMK(Field,Val)      _MCBSP_MCR2_##Field##_MK(Val)
#define _MCBSP_MCR21_FMK(Field,Val)      _MCBSP_MCR2_##Field##_MK(Val)
#define _MCBSP_MCR22_FMK(Field,Val)      _MCBSP_MCR2_##Field##_MK(Val)
#define _MCBSP_MCR20_FMKS(Field,Sym)     _MCBSP_MCR2_##Field##_MK(MCBSP_MCR2_##Field##_##Sym)
#define _MCBSP_MCR21_FMKS(Field,Sym)     _MCBSP_MCR2_##Field##_MK(MCBSP_MCR2_##Field##_##Sym)
#define _MCBSP_MCR22_FMKS(Field,Sym)     _MCBSP_MCR2_##Field##_MK(MCBSP_MCR2_##Field##_##Sym)


#define _MCBSP_PCR_FGET(Port,Field)      _PFIELD_GET(_MCBSP_PCR_ADDR(Port),_MCBSP_PCR_##Field)
#define _MCBSP_PCR_FSET(Port,Field,Val)  _PFIELD_SET(_MCBSP_PCR_ADDR(Port),_MCBSP_PCR_##Field,Val)
#define _MCBSP_PCR_FSETS(Port,Field,Sym)\
  MCBSP_PCR_FSET(Port,##Field,MCBSP_PCR_##Field##_##Sym)

#define _MCBSP_PCR_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_SET(_MCBSP_PCR_ADDR(Port),_MCBSP_PCR_##Field,AND,OR,INV)
#define _MCBSP_PCR_FMK(Field,Val)        _MCBSP_PCR_##Field##_MK(Val)
#define _MCBSP_PCR_FMKS(Field,Sym)       _MCBSP_PCR_##Field##_MK(MCBSP_PCR_##Field##_##Sym)

#define _MCBSP_PCR0_FGET(Field)            _MCBSP_PCR_FGET(0,##Field)
#define _MCBSP_PCR1_FGET(Field)            _MCBSP_PCR_FGET(1,##Field)
#define _MCBSP_PCR2_FGET(Field)            _MCBSP_PCR_FGET(2,##Field)
#define _MCBSP_PCR0_FSET(Field,Val)        _MCBSP_PCR_FSET(0,##Field,Val)
#define _MCBSP_PCR1_FSET(Field,Val)        _MCBSP_PCR_FSET(1,##Field,Val)
#define _MCBSP_PCR2_FSET(Field,Val)        _MCBSP_PCR_FSET(2,##Field,Val)
#define _MCBSP_PCR0_FSETS(Field,Sym)       _MCBSP_PCR_FSET(0,##Field,Sym)
#define _MCBSP_PCR1_FSETS(Field,Sym)       _MCBSP_PCR_FSET(1,##Field,Sym)
#define _MCBSP_PCR2_FSETS(Field,Sym)       _MCBSP_PCR_FSET(2,##Field,Sym)
#define _MCBSP_PCR0_FAOI(Field,AND,OR,INV) _MCBSP_PCR_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_PCR1_FAOI(Field,AND,OR,INV) _MCBSP_PCR_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_PCR2_FAOI(Field,AND,OR,INV) _MCBSP_PCR_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_PCR0_FMK(Field,Val)         _MCBSP_PCR_##Field##_MK(Val)
#define _MCBSP_PCR1_FMK(Field,Val)         _MCBSP_PCR_##Field##_MK(Val)
#define _MCBSP_PCR2_FMK(Field,Val)         _MCBSP_PCR_##Field##_MK(Val)
#define _MCBSP_PCR0_FMKS(Field,Sym)        _MCBSP_PCR_##Field##_MK(MCBSP_PCR_##Field##_##Sym)
#define _MCBSP_PCR1_FMKS(Field,Sym)        _MCBSP_PCR_##Field##_MK(MCBSP_PCR_##Field##_##Sym)
#define _MCBSP_PCR2_FMKS(Field,Sym)        _MCBSP_PCR_##Field##_MK(MCBSP_PCR_##Field##_##Sym)

#define _MCBSP_RCERA_FGET(Port,Field)     _PFIELD_GET(_MCBSP_RCERA_ADDR(Port),_MCBSP_RCER_##Field)
#define _MCBSP_RCERA_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_RCERA_ADDR(Port),_MCBSP_RCER_##Field,Val)
#define _MCBSP_RCERA_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_RCERA_ADDR(Port),_MCBSP_RCER_##Field,MCBSP_RCER_##Field##_##Sym)
#define _MCBSP_RCERA_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_RCERA_ADDR(Port),_MCBSP_RCER_##Field,AND,OR,INV)

#define _MCBSP_RCERA_FMK(Field,Val)          _MCBSP_RCER_##Field##_MK(Val)
#define _MCBSP_RCERA_FMKS(Field,Sym)         _MCBSP_RCER_##Field##_MK(MCBSP_RCER_##Field##_##Sym)

#define _MCBSP_RCERA0_FGET(Field)            _MCBSP_RCERA_FGET(0,##Field)
#define _MCBSP_RCERA1_FGET(Field)            _MCBSP_RCERA_FGET(1,##Field)
#define _MCBSP_RCERA2_FGET(Field)            _MCBSP_RCERA_FGET(2,##Field)
#define _MCBSP_RCERA0_FSET(Field,Val)        _MCBSP_RCERA_FSET(0,##Field,Val)
#define _MCBSP_RCERA1_FSET(Field,Val)        _MCBSP_RCERA_FSET(1,##Field,Val)
#define _MCBSP_RCERA2_FSET(Field,Val)        _MCBSP_RCERA_FSET(2,##Field,Val)
#define _MCBSP_RCERA0_FSETS(Field,Sym)       _MCBSP_RCERA_FSETS(0,##Field,Sym)
#define _MCBSP_RCERA1_FSETS(Field,Sym)       _MCBSP_RCERA_FSETS(1,##Field,Sym)
#define _MCBSP_RCERA2_FSETS(Field,Sym)       _MCBSP_RCERA_FSETS(2,##Field,Sym)
#define _MCBSP_RCERA0_FAOI(Field,AND,OR,INV) _MCBSP_RCERA_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_RCERA1_FAOI(Field,AND,OR,INV) _MCBSP_RCERA_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_RCERA2_FAOI(Field,AND,OR,INV) _MCBSP_RCERA_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_RCERA0_FMK(Field,Val)         _MCBSP_RCERA_FMK(##Field,Val)
#define _MCBSP_RCERA1_FMK(Field,Val)         _MCBSP_RCERA_FMK(##Field,Val)
#define _MCBSP_RCERA2_FMK(Field,Val)         _MCBSP_RCERA_FMK(##Field,Val)
#define _MCBSP_RCERA0_FMKS(Field,Sym)        _MCBSP_RCERA_FMKS(##Field,Sym)
#define _MCBSP_RCERA1_FMKS(Field,Sym)        _MCBSP_RCERA_FMKS(##Field,Sym)
#define _MCBSP_RCERA2_FMKS(Field,Sym)        _MCBSP_RCERA_FMKS(##Field,Sym)

#define _MCBSP_RCERB_FGET(Port,Field)     _PFIELD_GET(_MCBSP_RCERB_ADDR(Port),_MCBSP_RCER_##Field)
#define _MCBSP_RCERB_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_RCERB_ADDR(Port),_MCBSP_RCER_##Field,Val)
#define _MCBSP_RCERB_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_RCERB_ADDR(Port),_MCBSP_RCER_##Field,MCBSP_RCER_##Field##_##Sym)
#define _MCBSP_RCERB_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_RCERB_ADDR(Port),_MCBSP_RCER_##Field,AND,OR,INV)
#define _MCBSP_RCERB_FMK(Field,Val)          _MCBSP_RCER_##Field##_MK(Val)
#define _MCBSP_RCERB_FMKS(Field,Sym)         _MCBSP_RCER_##Field##_MK(MCBSP_RCER_##Field##_##Sym)

#define _MCBSP_RCERB0_FGET(Field)            _MCBSP_RCERB_FGET(0,##Field)
#define _MCBSP_RCERB1_FGET(Field)            _MCBSP_RCERB_FGET(1,##Field)
#define _MCBSP_RCERB2_FGET(Field)            _MCBSP_RCERB_FGET(2,##Field)
#define _MCBSP_RCERB0_FSET(Field,Val)        _MCBSP_RCERB_FSET(0,##Field,Val)
#define _MCBSP_RCERB1_FSET(Field,Val)        _MCBSP_RCERB_FSET(1,##Field,Val)
#define _MCBSP_RCERB2_FSET(Field,Val)        _MCBSP_RCERB_FSET(2,##Field,Val)
#define _MCBSP_RCERB0_FSETS(Field,Sym)       _MCBSP_RCERB_FSETS(0,##Field,Sym)
#define _MCBSP_RCERB1_FSETS(Field,Sym)       _MCBSP_RCERB_FSETS(1,##Field,Sym)
#define _MCBSP_RCERB2_FSETS(Field,Sym)       _MCBSP_RCERB_FSETS(2,##Field,Sym)
#define _MCBSP_RCERB0_FAOI(Field,AND,OR,INV) _MCBSP_RCERB_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_RCERB1_FAOI(Field,AND,OR,INV) _MCBSP_RCERB_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_RCERB2_FAOI(Field,AND,OR,INV) _MCBSP_RCERB_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_RCERB0_FMK(Field,Val)         _MCBSP_RCERB_FMK(##Field,Val)
#define _MCBSP_RCERB1_FMK(Field,Val)         _MCBSP_RCERB_FMK(##Field,Val)
#define _MCBSP_RCERB2_FMK(Field,Val)         _MCBSP_RCERB_FMK(##Field,Val)
#define _MCBSP_RCERB0_FMKS(Field,Sym)        _MCBSP_RCERB_FMKS(##Field,Sym)
#define _MCBSP_RCERB1_FMKS(Field,Sym)        _MCBSP_RCERB_FMKS(##Field,Sym)
#define _MCBSP_RCERB2_FMKS(Field,Sym)        _MCBSP_RCERB_FMKS(##Field,Sym)

#define _MCBSP_RCERC_FGET(Port,Field)     _PFIELD_GET(_MCBSP_RCERC_ADDR(Port),_MCBSP_RCER_##Field)
#define _MCBSP_RCERC_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_RCERC_ADDR(Port),_MCBSP_RCER_##Field,Val)
#define _MCBSP_RCERC_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_RCERC_ADDR(Port),_MCBSP_RCER_##Field,MCBSP_RCER_##Field##_##Sym)
#define _MCBSP_RCERC_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_RCERC_ADDR(Port),_MCBSP_RCER_##Field,AND,OR,INV)
#define _MCBSP_RCERC_FMK(Field,Val)          _MCBSP_RCER_##Field##_MK(Val)
#define _MCBSP_RCERC_FMKS(Field,Sym)         _MCBSP_RCER_##Field##_MK(MCBSP_RCER_##Field##_##Sym)

#define _MCBSP_RCERC0_FGET(Field)            _MCBSP_RCERC_FGET(0,##Field)
#define _MCBSP_RCERC1_FGET(Field)            _MCBSP_RCERC_FGET(1,##Field)
#define _MCBSP_RCERC2_FGET(Field)            _MCBSP_RCERC_FGET(2,##Field)
#define _MCBSP_RCERC0_FSET(Field,Val)        _MCBSP_RCERC_FSET(0,##Field,Val)
#define _MCBSP_RCERC1_FSET(Field,Val)        _MCBSP_RCERC_FSET(1,##Field,Val)
#define _MCBSP_RCERC2_FSET(Field,Val)        _MCBSP_RCERC_FSET(2,##Field,Val)
#define _MCBSP_RCERC0_FSETS(Field,Sym)       _MCBSP_RCERC_FSETS(0,##Field,Sym)
#define _MCBSP_RCERC1_FSETS(Field,Sym)       _MCBSP_RCERC_FSETS(1,##Field,Sym)
#define _MCBSP_RCERC2_FSETS(Field,Sym)       _MCBSP_RCERC_FSETS(2,##Field,Sym)
#define _MCBSP_RCERC0_FAOI(Field,AND,OR,INV) _MCBSP_RCERC_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_RCERC1_FAOI(Field,AND,OR,INV) _MCBSP_RCERC_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_RCERC2_FAOI(Field,AND,OR,INV) _MCBSP_RCERC_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_RCERC0_FMK(Field,Val)         _MCBSP_RCERC_FMK(##Field,Val)
#define _MCBSP_RCERC1_FMK(Field,Val)         _MCBSP_RCERC_FMK(##Field,Val)
#define _MCBSP_RCERC2_FMK(Field,Val)         _MCBSP_RCERC_FMK(##Field,Val)
#define _MCBSP_RCERC0_FMKS(Field,Sym)        _MCBSP_RCERC_FMKS(##Field,Sym)
#define _MCBSP_RCERC1_FMKS(Field,Sym)        _MCBSP_RCERC_FMKS(##Field,Sym)
#define _MCBSP_RCERC2_FMKS(Field,Sym)        _MCBSP_RCERC_FMKS(##Field,Sym)


#define _MCBSP_RCERD_FGET(Port,Field)     _PFIELD_GET(_MCBSP_RCERD_ADDR(Port),_MCBSP_RCER_##Field)
#define _MCBSP_RCERD_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_RCERD_ADDR(Port),_MCBSP_RCER_##Field,Val)
#define _MCBSP_RCERD_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_RCERD_ADDR(Port),_MCBSP_RCER_##Field,MCBSP_RCER_##Field##_##Sym)
#define _MCBSP_RCERD_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_RCERD_ADDR(Port),_MCBSP_RCER_##Field,AND,OR,INV)
#define _MCBSP_RCERD_FMK(Field,Val)          _MCBSP_RCER_##Field##_MK(Val)
#define _MCBSP_RCERD_FMKS(Field,Sym)         _MCBSP_RCER_##Field##_MK(MCBSP_RCER_##Field##_##Sym)

#define _MCBSP_RCERD0_FGET(Field)            _MCBSP_RCERD_FGET(0,##Field)
#define _MCBSP_RCERD1_FGET(Field)            _MCBSP_RCERD_FGET(1,##Field)
#define _MCBSP_RCERD2_FGET(Field)            _MCBSP_RCERD_FGET(2,##Field)
#define _MCBSP_RCERD0_FSET(Field,Val)        _MCBSP_RCERD_FSET(0,##Field,Val)
#define _MCBSP_RCERD1_FSET(Field,Val)        _MCBSP_RCERD_FSET(1,##Field,Val)
#define _MCBSP_RCERD2_FSET(Field,Val)        _MCBSP_RCERD_FSET(2,##Field,Val)
#define _MCBSP_RCERD0_FSETS(Field,Sym)       _MCBSP_RCERD_FSETS(0,##Field,Sym)
#define _MCBSP_RCERD1_FSETS(Field,Sym)       _MCBSP_RCERD_FSETS(1,##Field,Sym)
#define _MCBSP_RCERD2_FSETS(Field,Sym)       _MCBSP_RCERD_FSETS(2,##Field,Sym)
#define _MCBSP_RCERD0_FAOI(Field,AND,OR,INV) _MCBSP_RCERD_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_RCERD1_FAOI(Field,AND,OR,INV) _MCBSP_RCERD_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_RCERD2_FAOI(Field,AND,OR,INV) _MCBSP_RCERD_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_RCERD0_FMK(Field,Val)         _MCBSP_RCERD_FMK(##Field,Val)
#define _MCBSP_RCERD1_FMK(Field,Val)         _MCBSP_RCERD_FMK(##Field,Val)
#define _MCBSP_RCERD2_FMK(Field,Val)         _MCBSP_RCERD_FMK(##Field,Val)
#define _MCBSP_RCERD0_FMKS(Field,Sym)        _MCBSP_RCERD_FMKS(##Field,Sym)
#define _MCBSP_RCERD1_FMKS(Field,Sym)        _MCBSP_RCERD_FMKS(##Field,Sym)
#define _MCBSP_RCERD2_FMKS(Field,Sym)        _MCBSP_RCERD_FMKS(##Field,Sym)


#define _MCBSP_RCERE_FGET(Port,Field)     _PFIELD_GET(_MCBSP_RCERE_ADDR(Port),_MCBSP_RCER_##Field)
#define _MCBSP_RCERE_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_RCERE_ADDR(Port),_MCBSP_RCER_##Field,Val)
#define _MCBSP_RCERE_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_RCERE_ADDR(Port),_MCBSP_RCER_##Field,MCBSP_RCER_##Field##_##Sym)
#define _MCBSP_RCERE_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_RCERE_ADDR(Port),_MCBSP_RCER_##Field,AND,OR,INV)
#define _MCBSP_RCERE_FMK(Field,Val)          _MCBSP_RCER_##Field##_MK(Val)
#define _MCBSP_RCERE_FMKS(Field,Sym)         _MCBSP_RCER_##Field##_MK(MCBSP_RCER_##Field##_##Sym)

#define _MCBSP_RCERE0_FGET(Field)            _MCBSP_RCERE_FGET(0,##Field)
#define _MCBSP_RCERE1_FGET(Field)            _MCBSP_RCERE_FGET(1,##Field)
#define _MCBSP_RCERE2_FGET(Field)            _MCBSP_RCERE_FGET(2,##Field)
#define _MCBSP_RCERE0_FSET(Field,Val)        _MCBSP_RCERE_FSET(0,##Field,Val)
#define _MCBSP_RCERE1_FSET(Field,Val)        _MCBSP_RCERE_FSET(1,##Field,Val)
#define _MCBSP_RCERE2_FSET(Field,Val)        _MCBSP_RCERE_FSET(2,##Field,Val)
#define _MCBSP_RCERE0_FSETS(Field,Sym)       _MCBSP_RCERE_FSETS(0,##Field,Sym)
#define _MCBSP_RCERE1_FSETS(Field,Sym)       _MCBSP_RCERE_FSETS(1,##Field,Sym)
#define _MCBSP_RCERE2_FSETS(Field,Sym)       _MCBSP_RCERE_FSETS(2,##Field,Sym)
#define _MCBSP_RCERE0_FAOI(Field,AND,OR,INV) _MCBSP_RCERE_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_RCERE1_FAOI(Field,AND,OR,INV) _MCBSP_RCERE_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_RCERE2_FAOI(Field,AND,OR,INV) _MCBSP_RCERE_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_RCERE0_FMK(Field,Val)         _MCBSP_RCERE_FMK(##Field,Val)
#define _MCBSP_RCERE1_FMK(Field,Val)         _MCBSP_RCERE_FMK(##Field,Val)
#define _MCBSP_RCERE2_FMK(Field,Val)         _MCBSP_RCERE_FMK(##Field,Val)
#define _MCBSP_RCERE0_FMKS(Field,Sym)        _MCBSP_RCERE_FMKS(##Field,Sym)
#define _MCBSP_RCERE1_FMKS(Field,Sym)        _MCBSP_RCERE_FMKS(##Field,Sym)
#define _MCBSP_RCERE2_FMKS(Field,Sym)        _MCBSP_RCERE_FMKS(##Field,Sym)

#define _MCBSP_RCERF_FGET(Port,Field)     _PFIELD_GET(_MCBSP_RCERF_ADDR(Port),_MCBSP_RCER_##Field)
#define _MCBSP_RCERF_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_RCERF_ADDR(Port),_MCBSP_RCER_##Field,Val)
#define _MCBSP_RCERF_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_RCERF_ADDR(Port),_MCBSP_RCER_##Field,MCBSP_RCER_##Field##_##Sym)
#define _MCBSP_RCERF_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_RCERF_ADDR(Port),_MCBSP_RCER_##Field,AND,OR,INV)
#define _MCBSP_RCERF_FMK(Field,Val)          _MCBSP_RCER_##Field##_MK(Val)
#define _MCBSP_RCERF_FMKS(Field,Sym)         _MCBSP_RCER_##Field##_MK(MCBSP_RCER_##Field##_##Sym)

#define _MCBSP_RCERF0_FGET(Field)            _MCBSP_RCERF_FGET(0,##Field)
#define _MCBSP_RCERF1_FGET(Field)            _MCBSP_RCERF_FGET(1,##Field)
#define _MCBSP_RCERF2_FGET(Field)            _MCBSP_RCERF_FGET(2,##Field)
#define _MCBSP_RCERF0_FSET(Field,Val)        _MCBSP_RCERF_FSET(0,##Field,Val)
#define _MCBSP_RCERF1_FSET(Field,Val)        _MCBSP_RCERF_FSET(1,##Field,Val)
#define _MCBSP_RCERF2_FSET(Field,Val)        _MCBSP_RCERF_FSET(2,##Field,Val)
#define _MCBSP_RCERF0_FSETS(Field,Sym)       _MCBSP_RCERF_FSETS(0,##Field,Sym)
#define _MCBSP_RCERF1_FSETS(Field,Sym)       _MCBSP_RCERF_FSETS(1,##Field,Sym)
#define _MCBSP_RCERF2_FSETS(Field,Sym)       _MCBSP_RCERF_FSETS(2,##Field,Sym)
#define _MCBSP_RCERF0_FAOI(Field,AND,OR,INV) _MCBSP_RCERF_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_RCERF1_FAOI(Field,AND,OR,INV) _MCBSP_RCERF_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_RCERF2_FAOI(Field,AND,OR,INV) _MCBSP_RCERF_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_RCERF0_FMK(Field,Val)         _MCBSP_RCERF_FMK(##Field,Val)
#define _MCBSP_RCERF1_FMK(Field,Val)         _MCBSP_RCERF_FMK(##Field,Val)
#define _MCBSP_RCERF2_FMK(Field,Val)         _MCBSP_RCERF_FMK(##Field,Val)
#define _MCBSP_RCERF0_FMKS(Field,Sym)        _MCBSP_RCERF_FMKS(##Field,Sym)
#define _MCBSP_RCERF1_FMKS(Field,Sym)        _MCBSP_RCERF_FMKS(##Field,Sym)
#define _MCBSP_RCERF2_FMKS(Field,Sym)        _MCBSP_RCERF_FMKS(##Field,Sym)


#define _MCBSP_RCERG_FGET(Port,Field)     _PFIELD_GET(_MCBSP_RCERG_ADDR(Port),_MCBSP_RCER_##Field)
#define _MCBSP_RCERG_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_RCERG_ADDR(Port),_MCBSP_RCER_##Field,Val)
#define _MCBSP_RCERG_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_RCERG_ADDR(Port),_MCBSP_RCER_##Field,MCBSP_RCER_##Field##_##Sym)
#define _MCBSP_RCERG_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_RCERG_ADDR(Port),_MCBSP_RCER_##Field,AND,OR,INV)
#define _MCBSP_RCERG_FMK(Field,Val)          _MCBSP_RCER_##Field##_MK(Val)
#define _MCBSP_RCERG_FMKS(Field,Sym)         _MCBSP_RCER_##Field##_MK(MCBSP_RCER_##Field##_##Sym)

#define _MCBSP_RCERG0_FGET(Field)            _MCBSP_RCERG_FGET(0,##Field)
#define _MCBSP_RCERG1_FGET(Field)            _MCBSP_RCERG_FGET(1,##Field)
#define _MCBSP_RCERG2_FGET(Field)            _MCBSP_RCERG_FGET(2,##Field)
#define _MCBSP_RCERG0_FSET(Field,Val)        _MCBSP_RCERG_FSET(0,##Field,Val)
#define _MCBSP_RCERG1_FSET(Field,Val)        _MCBSP_RCERG_FSET(1,##Field,Val)
#define _MCBSP_RCERG2_FSET(Field,Val)        _MCBSP_RCERG_FSET(2,##Field,Val)
#define _MCBSP_RCERG0_FSETS(Field,Sym)       _MCBSP_RCERG_FSETS(0,##Field,Sym)
#define _MCBSP_RCERG1_FSETS(Field,Sym)       _MCBSP_RCERG_FSETS(1,##Field,Sym)
#define _MCBSP_RCERG2_FSETS(Field,Sym)       _MCBSP_RCERG_FSETS(2,##Field,Sym)
#define _MCBSP_RCERG0_FAOI(Field,AND,OR,INV) _MCBSP_RCERG_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_RCERG1_FAOI(Field,AND,OR,INV) _MCBSP_RCERG_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_RCERG2_FAOI(Field,AND,OR,INV) _MCBSP_RCERG_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_RCERG0_FMK(Field,Val)         _MCBSP_RCERG_FMK(##Field,Val)
#define _MCBSP_RCERG1_FMK(Field,Val)         _MCBSP_RCERG_FMK(##Field,Val)
#define _MCBSP_RCERG2_FMK(Field,Val)         _MCBSP_RCERG_FMK(##Field,Val)
#define _MCBSP_RCERG0_FMKS(Field,Sym)        _MCBSP_RCERG_FMKS(##Field,Sym)
#define _MCBSP_RCERG1_FMKS(Field,Sym)        _MCBSP_RCERG_FMKS(##Field,Sym)
#define _MCBSP_RCERG2_FMKS(Field,Sym)        _MCBSP_RCERG_FMKS(##Field,Sym)


#define _MCBSP_RCERH_FGET(Port,Field)     _PFIELD_GET(_MCBSP_RCERH_ADDR(Port),_MCBSP_RCER_##Field)
#define _MCBSP_RCERH_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_RCERH_ADDR(Port),_MCBSP_RCER_##Field,Val)
#define _MCBSP_RCERH_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_RCERH_ADDR(Port),_MCBSP_RCER_##Field,MCBSP_RCER_##Field##_##Sym)
#define _MCBSP_RCERH_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_RCERH_ADDR(Port),_MCBSP_RCER_##Field,AND,OR,INV)
#define _MCBSP_RCERH_FMK(Field,Val)          _MCBSP_RCER_##Field##_MK(Val)
#define _MCBSP_RCERH_FMKS(Field,Sym)         _MCBSP_RCER_##Field##_MK(MCBSP_RCER_##Field##_##Sym)

#define _MCBSP_RCERH0_FGET(Field)            _MCBSP_RCERH_FGET(0,##Field)
#define _MCBSP_RCERH1_FGET(Field)            _MCBSP_RCERH_FGET(1,##Field)
#define _MCBSP_RCERH2_FGET(Field)            _MCBSP_RCERH_FGET(2,##Field)
#define _MCBSP_RCERH0_FSET(Field,Val)        _MCBSP_RCERH_FSET(0,##Field,Val)
#define _MCBSP_RCERH1_FSET(Field,Val)        _MCBSP_RCERH_FSET(1,##Field,Val)
#define _MCBSP_RCERH2_FSET(Field,Val)        _MCBSP_RCERH_FSET(2,##Field,Val)
#define _MCBSP_RCERH0_FSETS(Field,Sym)       _MCBSP_RCERH_FSETS(0,##Field,Sym)
#define _MCBSP_RCERH1_FSETS(Field,Sym)       _MCBSP_RCERH_FSETS(1,##Field,Sym)
#define _MCBSP_RCERH2_FSETS(Field,Sym)       _MCBSP_RCERH_FSETS(2,##Field,Sym)
#define _MCBSP_RCERH0_FAOI(Field,AND,OR,INV) _MCBSP_RCERH_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_RCERH1_FAOI(Field,AND,OR,INV) _MCBSP_RCERH_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_RCERH2_FAOI(Field,AND,OR,INV) _MCBSP_RCERH_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_RCERH0_FMK(Field,Val)         _MCBSP_RCERH_FMK(##Field,Val)
#define _MCBSP_RCERH1_FMK(Field,Val)         _MCBSP_RCERH_FMK(##Field,Val)
#define _MCBSP_RCERH2_FMK(Field,Val)         _MCBSP_RCERH_FMK(##Field,Val)
#define _MCBSP_RCERH0_FMKS(Field,Sym)        _MCBSP_RCERH_FMKS(##Field,Sym)
#define _MCBSP_RCERH1_FMKS(Field,Sym)        _MCBSP_RCERH_FMKS(##Field,Sym)
#define _MCBSP_RCERH2_FMKS(Field,Sym)        _MCBSP_RCERH_FMKS(##Field,Sym)
#define _MCBSP_XCERA_FGET(Port,Field)       _PFIELD_GET(_MCBSP_XCERA_ADDR(Port),_MCBSP_XCER_##Field)

#define _MCBSP_XCERA_FSET(Port,Field,Val)   _PFIELD_SET(_MCBSP_XCERA_ADDR(Port),_MCBSP_XCER_##Field,Val)
#define _MCBSP_XCERA_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_XCERA_ADDR(Port),_MCBSP_XCER_##Field,MCBSP_XCER_##Field##_##Sym)
#define _MCBSP_XCERA_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_XCERA_ADDR(Port),_MCBSP_XCER_##Field,AND,OR,INV)
#define _MCBSP_XCERA_FMK(Field,Val)       _MCBSP_XCER_##Field##_MK(Val)
#define _MCBSP_XCERA_FMKS(Port,Field,Sym) _MCBSP_XCER_##Field##_MK(MCBSP_XCER_##Field##_##Sym)

#define _MCBSP_XCERA0_FGET(Field)            _MCBSP_XCERA_FGET(0,##Field)
#define _MCBSP_XCERA1_FGET(Field)            _MCBSP_XCERA_FGET(1,##Field)
#define _MCBSP_XCERA2_FGET(Field)            _MCBSP_XCERA_FGET(2,##Field)
#define _MCBSP_XCERA0_FSET(Field,Val)        _MCBSP_XCERA_FSET(0,##Field,Val)
#define _MCBSP_XCERA1_FSET(Field,Val)        _MCBSP_XCERA_FSET(1,##Field,Val)
#define _MCBSP_XCERA2_FSET(Field,Val)        _MCBSP_XCERA_FSET(2,##Field,Val)
#define _MCBSP_XCERA0_FSETS(Field,Sym)       _MCBSP_XCERA_FSETS(0,##Field,Sym)
#define _MCBSP_XCERA1_FSETS(Field,Sym)       _MCBSP_XCERA_FSETS(1,##Field,Sym)
#define _MCBSP_XCERA2_FSETS(Field,Sym)       _MCBSP_XCERA_FSETS(2,##Field,Sym)
#define _MCBSP_XCERA0_FAOI(Field,AND,OR,INV) _MCBSP_XCERA_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_XCERA1_FAOI(Field,AND,OR,INV) _MCBSP_XCERA_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_XCERA2_FAOI(Field,AND,OR,INV) _MCBSP_XCERA_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_XCERA0_FMK(Field,Val)         _MCBSP_XCERA_FMK(##Field,Val)
#define _MCBSP_XCERA1_FMK(Field,Val)         _MCBSP_XCERA_FMK(##Field,Val)
#define _MCBSP_XCERA2_FMK(Field,Val)         _MCBSP_XCERA_FMK(##Field,Val)
#define _MCBSP_XCERA0_FMKS(Field,Sym)        _MCBSP_XCERA_FMKS(##Field,Sym)
#define _MCBSP_XCERA1_FMKS(Field,Sym)        _MCBSP_XCERA_FMKS(##Field,Sym)
#define _MCBSP_XCERA2_FMKS(Field,Sym)        _MCBSP_XCERA_FMKS(##Field,Sym)

#define _MCBSP_XCERB_FGET(Port,Field)     _PFIELD_GET(_MCBSP_XCERB_ADDR(Port),_MCBSP_XCER_##Field)
#define _MCBSP_XCERB_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_XCERB_ADDR(Port),_MCBSP_XCER_##Field,Val)
#define _MCBSP_XCERB_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_XCERB_ADDR(Port),_MCBSP_XCER_##Field,MCBSP_XCER_##Field##_##Sym)
#define _MCBSP_XCERB_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_XCERB_ADDR(Port),_MCBSP_XCER_##Field,AND,OR,INV)
#define _MCBSP_XCERB_FMK(Field,Val)  _MCBSP_XCER_##Field##_MK(Val)
#define _MCBSP_XCERB_FMKS(Field,Sym) _MCBSP_XCER_##Field##_MK(MCBSP_XCER_##Field##_##Sym)

#define _MCBSP_XCERB0_FGET(Field)            _MCBSP_XCERB_FGET(0,##Field)
#define _MCBSP_XCERB1_FGET(Field)            _MCBSP_XCERB_FGET(1,##Field)
#define _MCBSP_XCERB2_FGET(Field)            _MCBSP_XCERB_FGET(2,##Field)
#define _MCBSP_XCERB0_FSET(Field,Val)        _MCBSP_XCERB_FSET(0,##Field,Val)
#define _MCBSP_XCERB1_FSET(Field,Val)        _MCBSP_XCERB_FSET(1,##Field,Val)
#define _MCBSP_XCERB2_FSET(Field,Val)        _MCBSP_XCERB_FSET(2,##Field,Val)
#define _MCBSP_XCERB0_FSETS(Field,Sym)       _MCBSP_XCERB_FSETS(0,##Field,Sym)
#define _MCBSP_XCERB1_FSETS(Field,Sym)       _MCBSP_XCERB_FSETS(1,##Field,Sym)
#define _MCBSP_XCERB2_FSETS(Field,Sym)       _MCBSP_XCERB_FSETS(2,##Field,Sym)
#define _MCBSP_XCERB0_FAOI(Field,AND,OR,INV) _MCBSP_XCERB_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_XCERB1_FAOI(Field,AND,OR,INV) _MCBSP_XCERB_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_XCERB2_FAOI(Field,AND,OR,INV) _MCBSP_XCERB_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_XCERB0_FMK(Field,Val)         _MCBSP_XCERB_FMK(##Field,Val)
#define _MCBSP_XCERB1_FMK(Field,Val)         _MCBSP_XCERB_FMK(##Field,Val)
#define _MCBSP_XCERB2_FMK(Field,Val)         _MCBSP_XCERB_FMK(##Field,Val)
#define _MCBSP_XCERB0_FMKS(Field,Sym)        _MCBSP_XCERB_FMKS(##Field,Sym)
#define _MCBSP_XCERB1_FMKS(Field,Sym)        _MCBSP_XCERB_FMKS(##Field,Sym)
#define _MCBSP_XCERB2_FMKS(Field,Sym)        _MCBSP_XCERB_FMKS(##Field,Sym)

#define _MCBSP_XCERC_FGET(Port,Field)     _PFIELD_GET(_MCBSP_XCERC_ADDR(Port),_MCBSP_XCER_##Field)
#define _MCBSP_XCERC_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_XCERC_ADDR(Port),_MCBSP_XCER_##Field,Val)
#define _MCBSP_XCERC_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_XCERC_ADDR(Port),_MCBSP_XCER_##Field,MCBSP_XCER_##Field##_##Sym)
#define _MCBSP_XCERC_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_XCERC_ADDR(Port),_MCBSP_XCER_##Field,AND,OR,INV)
#define _MCBSP_XCERC_FMK(Field,Val)         _MCBSP_XCER_##Field##_MK(Val)
#define _MCBSP_XCERC_FMKS(Field,Sym)        _MCBSP_XCER_##Field##_MK(MCBSP_XCER_##Field##_##Sym)


#define _MCBSP_XCERC0_FGET(Field)            _MCBSP_XCERC_FGET(0,##Field)
#define _MCBSP_XCERC1_FGET(Field)            _MCBSP_XCERC_FGET(1,##Field)
#define _MCBSP_XCERC2_FGET(Field)            _MCBSP_XCERC_FGET(2,##Field)
#define _MCBSP_XCERC0_FSET(Field,Val)        _MCBSP_XCERC_FSET(0,##Field,Val)
#define _MCBSP_XCERC1_FSET(Field,Val)        _MCBSP_XCERC_FSET(1,##Field,Val)
#define _MCBSP_XCERC2_FSET(Field,Val)        _MCBSP_XCERC_FSET(2,##Field,Val)
#define _MCBSP_XCERC0_FSETS(Field,Sym)       _MCBSP_XCERC_FSETS(0,##Field,Sym)
#define _MCBSP_XCERC1_FSETS(Field,Sym)       _MCBSP_XCERC_FSETS(1,##Field,Sym)
#define _MCBSP_XCERC2_FSETS(Field,Sym)       _MCBSP_XCERC_FSETS(2,##Field,Sym)
#define _MCBSP_XCERC0_FAOI(Field,AND,OR,INV) _MCBSP_XCERC_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_XCERC1_FAOI(Field,AND,OR,INV) _MCBSP_XCERC_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_XCERC2_FAOI(Field,AND,OR,INV) _MCBSP_XCERC_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_XCERC0_FMK(Field,Val)         _MCBSP_XCERC_FMK(##Field,Val)
#define _MCBSP_XCERC1_FMK(Field,Val)         _MCBSP_XCERC_FMK(##Field,Val)
#define _MCBSP_XCERC2_FMK(Field,Val)         _MCBSP_XCERC_FMK(##Field,Val)
#define _MCBSP_XCERC0_FMKS(Field,Sym)        _MCBSP_XCERC_FMKS(##Field,Sym)
#define _MCBSP_XCERC1_FMKS(Field,Sym)        _MCBSP_XCERC_FMKS(##Field,Sym)
#define _MCBSP_XCERC2_FMKS(Field,Sym)        _MCBSP_XCERC_FMKS(##Field,Sym)


#define _MCBSP_XCERD_FGET(Port,Field)     _PFIELD_GET(_MCBSP_XCERD_ADDR(Port),_MCBSP_XCER_##Field)
#define _MCBSP_XCERD_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_XCERD_ADDR(Port),_MCBSP_XCER_##Field,Val)
#define _MCBSP_XCERD_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_XCERD_ADDR(Port),_MCBSP_XCER_##Field,MCBSP_XCER_##Field##_##Sym)
#define _MCBSP_XCERD_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_XCERD_ADDR(Port),_MCBSP_XCER_##Field,AND,OR,INV)
#define _MCBSP_XCERD_FMK(Field,Val)       _MCBSP_XCER_##Field##_MK(Val)
#define _MCBSP_XCERD_FMKS(Field,Sym)      _MCBSP_XCER_##Field##_MK(MCBSP_XCER_##Field##_##Sym)

#define _MCBSP_XCERD0_FGET(Field)            _MCBSP_XCERD_FGET(0,##Field)
#define _MCBSP_XCERD1_FGET(Field)            _MCBSP_XCERD_FGET(1,##Field)
#define _MCBSP_XCERD2_FGET(Field)            _MCBSP_XCERD_FGET(2,##Field)
#define _MCBSP_XCERD0_FSET(Field,Val)        _MCBSP_XCERD_FSET(0,##Field,Val)
#define _MCBSP_XCERD1_FSET(Field,Val)        _MCBSP_XCERD_FSET(1,##Field,Val)
#define _MCBSP_XCERD2_FSET(Field,Val)        _MCBSP_XCERD_FSET(2,##Field,Val)
#define _MCBSP_XCERD0_FSETS(Field,Sym)       _MCBSP_XCERD_FSETS(0,##Field,Sym)
#define _MCBSP_XCERD1_FSETS(Field,Sym)       _MCBSP_XCERD_FSETS(1,##Field,Sym)
#define _MCBSP_XCERD2_FSETS(Field,Sym)       _MCBSP_XCERD_FSETS(2,##Field,Sym)
#define _MCBSP_XCERD0_FAOI(Field,AND,OR,INV) _MCBSP_XCERD_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_XCERD1_FAOI(Field,AND,OR,INV) _MCBSP_XCERD_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_XCERD2_FAOI(Field,AND,OR,INV) _MCBSP_XCERD_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_XCERD0_FMK(Field,Val)         _MCBSP_XCERD_FMK(##Field,Val)
#define _MCBSP_XCERD1_FMK(Field,Val)         _MCBSP_XCERD_FMK(##Field,Val)
#define _MCBSP_XCERD2_FMK(Field,Val)         _MCBSP_XCERD_FMK(##Field,Val)
#define _MCBSP_XCERD0_FMKS(Field,Sym)        _MCBSP_XCERD_FMKS(##Field,Sym)
#define _MCBSP_XCERD1_FMKS(Field,Sym)        _MCBSP_XCERD_FMKS(##Field,Sym)
#define _MCBSP_XCERD2_FMKS(Field,Sym)        _MCBSP_XCERD_FMKS(##Field,Sym)


#define _MCBSP_XCERE_FGET(Port,Field)     _PFIELD_GET(_MCBSP_XCERE_ADDR(Port),_MCBSP_XCER_##Field)
#define _MCBSP_XCERE_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_XCERE_ADDR(Port),_MCBSP_XCER_##Field,Val)
#define _MCBSP_XCERE_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_XCERE_ADDR(Port),_MCBSP_XCER_##Field,MCBSP_XCER_##Field##_##Sym)
#define _MCBSP_XCERE_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_XCERE_ADDR(Port),_MCBSP_XCER_##Field,AND,OR,INV)
#define _MCBSP_XCERE_FMK(Field,Val)       _MCBSP_XCER_##Field##_MK(Val)
#define _MCBSP_XCERE_FMKS(Field,Sym)      _MCBSP_XCER_##Field##_MK(MCBSP_XCER_##Field##_##Sym)

#define _MCBSP_XCERE0_FGET(Field)         _MCBSP_XCERE_FGET(0,##Field)
#define _MCBSP_XCERE1_FGET(Field)         _MCBSP_XCERE_FGET(1,##Field)
#define _MCBSP_XCERE2_FGET(Field)         _MCBSP_XCERE_FGET(2,##Field)
#define _MCBSP_XCERE0_FSET(Field,Val)     _MCBSP_XCERE_FSET(0,##Field,Val)
#define _MCBSP_XCERE1_FSET(Field,Val)     _MCBSP_XCERE_FSET(1,##Field,Val)
#define _MCBSP_XCERE2_FSET(Field,Val)     _MCBSP_XCERE_FSET(2,##Field,Val)
#define _MCBSP_XCERE0_FSETS(Field,Sym)    _MCBSP_XCERE_FSETS(0,##Field,Sym)
#define _MCBSP_XCERE1_FSETS(Field,Sym)    _MCBSP_XCERE_FSETS(1,##Field,Sym)
#define _MCBSP_XCERE2_FSETS(Field,Sym)    _MCBSP_XCERE_FSETS(2,##Field,Sym)
#define _MCBSP_XCERE0_FAOI(Field,AND,OR,INV) _MCBSP_XCERE_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_XCERE1_FAOI(Field,AND,OR,INV) _MCBSP_XCERE_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_XCERE2_FAOI(Field,AND,OR,INV) _MCBSP_XCERE_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_XCERE0_FMK(Field,Val)         _MCBSP_XCERE_FMK(##Field,Val)
#define _MCBSP_XCERE1_FMK(Field,Val)         _MCBSP_XCERE_FMK(##Field,Val)
#define _MCBSP_XCERE2_FMK(Field,Val)         _MCBSP_XCERE_FMK(##Field,Val)
#define _MCBSP_XCERE0_FMKS(Field,Sym)        _MCBSP_XCERE_FMKS(##Field,Sym)
#define _MCBSP_XCERE1_FMKS(Field,Sym)        _MCBSP_XCERE_FMKS(##Field,Sym)
#define _MCBSP_XCERE2_FMKS(Field,Sym)        _MCBSP_XCERE_FMKS(##Field,Sym)


#define _MCBSP_XCERF_FGET(Port,Field)     _PFIELD_GET(_MCBSP_XCERF_ADDR(Port),_MCBSP_XCER_##Field)
#define _MCBSP_XCERF_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_XCERF_ADDR(Port),_MCBSP_XCER_##Field,Val)
#define _MCBSP_XCERF_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_XCERF_ADDR(Port),_MCBSP_XCER_##Field,MCBSP_XCER_##Field##_##Sym)
#define _MCBSP_XCERF_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_XCERF_ADDR(Port),_MCBSP_XCER_##Field,AND,OR,INV)
#define _MCBSP_XCERF_FMK(Field,Val)       _MCBSP_XCER_##Field##_MK(Val)
#define _MCBSP_XCERF_FMKS(Field,Sym)      _MCBSP_XCER_##Field##_MK(MCBSP_XCER_##Field##_##Sym)

#define _MCBSP_XCERF0_FGET(Field)         _MCBSP_XCERF_FGET(0,##Field)
#define _MCBSP_XCERF1_FGET(Field)         _MCBSP_XCERF_FGET(1,##Field)
#define _MCBSP_XCERF2_FGET(Field)         _MCBSP_XCERF_FGET(2,##Field)
#define _MCBSP_XCERF0_FSET(Field,Val)     _MCBSP_XCERF_FSET(0,##Field,Val)
#define _MCBSP_XCERF1_FSET(Field,Val)     _MCBSP_XCERF_FSET(1,##Field,Val)
#define _MCBSP_XCERF2_FSET(Field,Val)     _MCBSP_XCERF_FSET(2,##Field,Val)
#define _MCBSP_XCERF0_FSETS(Field,Sym)    _MCBSP_XCERF_FSETS(0,##Field,Sym)
#define _MCBSP_XCERF1_FSETS(Field,Sym)    _MCBSP_XCERF_FSETS(1,##Field,Sym)
#define _MCBSP_XCERF2_FSETS(Field,Sym)    _MCBSP_XCERF_FSETS(2,##Field,Sym)
#define _MCBSP_XCERF0_FAOI(Field,AND,OR,INV) _MCBSP_XCERF_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_XCERF1_FAOI(Field,AND,OR,INV) _MCBSP_XCERF_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_XCERF2_FAOI(Field,AND,OR,INV) _MCBSP_XCERF_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_XCERF0_FMK(Field,Val)         _MCBSP_XCERF_FMK(##Field,Val)
#define _MCBSP_XCERF1_FMK(Field,Val)         _MCBSP_XCERF_FMK(##Field,Val)
#define _MCBSP_XCERF2_FMK(Field,Val)         _MCBSP_XCERF_FMK(##Field,Val)
#define _MCBSP_XCERF0_FMKS(Field,Sym)        _MCBSP_XCERF_FMKS(##Field,Sym)
#define _MCBSP_XCERF1_FMKS(Field,Sym)        _MCBSP_XCERF_FMKS(##Field,Sym)
#define _MCBSP_XCERF2_FMKS(Field,Sym)        _MCBSP_XCERF_FMKS(##Field,Sym)

#define _MCBSP_XCERG_FGET(Port,Field)     _PFIELD_GET(_MCBSP_XCERG_ADDR(Port),_MCBSP_XCER_##Field)
#define _MCBSP_XCERG_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_XCERG_ADDR(Port),_MCBSP_XCER_##Field,Val)
#define _MCBSP_XCERG_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_XCERG_ADDR(Port),_MCBSP_XCER_##Field,MCBSP_XCER_##Field##_##Sym)
#define _MCBSP_XCERG_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_XCERG_ADDR(Port),_MCBSP_XCER_##Field,AND,OR,INV)
#define _MCBSP_XCERG_FMK(Field,Val)       _MCBSP_XCER_##Field##_MK(Val)
#define _MCBSP_XCERG_FMKS(Field,Sym)      _MCBSP_XCER_##Field##_MK(MCBSP_XCER_##Field##_##Sym)

#define _MCBSP_XCERG0_FGET(Field)         _MCBSP_XCERG_FGET(0,##Field)
#define _MCBSP_XCERG1_FGET(Field)         _MCBSP_XCERG_FGET(1,##Field)
#define _MCBSP_XCERG2_FGET(Field)         _MCBSP_XCERG_FGET(2,##Field)
#define _MCBSP_XCERG0_FSET(Field,Val)     _MCBSP_XCERG_FSET(0,##Field,Val)
#define _MCBSP_XCERG1_FSET(Field,Val)     _MCBSP_XCERG_FSET(1,##Field,Val)
#define _MCBSP_XCERG2_FSET(Field,Val)     _MCBSP_XCERG_FSET(2,##Field,Val)
#define _MCBSP_XCERG0_FSETS(Field,Sym)    _MCBSP_XCERG_FSETS(0,##Field,Sym)
#define _MCBSP_XCERG1_FSETS(Field,Sym)    _MCBSP_XCERG_FSETS(1,##Field,Sym)
#define _MCBSP_XCERG2_FSETS(Field,Sym)    _MCBSP_XCERG_FSETS(2,##Field,Sym)
#define _MCBSP_XCERG0_FAOI(Field,AND,OR,INV) _MCBSP_XCERG_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_XCERG1_FAOI(Field,AND,OR,INV) _MCBSP_XCERG_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_XCERG2_FAOI(Field,AND,OR,INV) _MCBSP_XCERG_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_XCERG0_FMK(Field,Val)         _MCBSP_XCERG_FMK(##Field,Val)
#define _MCBSP_XCERG1_FMK(Field,Val)         _MCBSP_XCERG_FMK(##Field,Val)
#define _MCBSP_XCERG2_FMK(Field,Val)         _MCBSP_XCERG_FMK(##Field,Val)
#define _MCBSP_XCERG0_FMKS(Field,Sym)        _MCBSP_XCERG_FMKS(##Field,Sym)
#define _MCBSP_XCERG1_FMKS(Field,Sym)        _MCBSP_XCERG_FMKS(##Field,Sym)
#define _MCBSP_XCERG2_FMKS(Field,Sym)        _MCBSP_XCERG_FMKS(##Field,Sym)

#define _MCBSP_XCERH_FGET(Port,Field)     _PFIELD_GET(_MCBSP_XCERH_ADDR(Port),_MCBSP_XCER_##Field)
#define _MCBSP_XCERH_FSET(Port,Field,Val) _PFIELD_SET(_MCBSP_XCERH_ADDR(Port),_MCBSP_XCER_##Field,Val)
#define _MCBSP_XCERH_FSETS(Port,Field,Sym)\
  _PFIELD_SET(_MCBSP_XCERH_ADDR(Port),_MCBSP_XCER_##Field,MCBSP_XCER_##Field##_##Sym)
#define _MCBSP_XCERH_FAOI(Port,Field,AND,OR,INV)\
  _PFIELD_AOI(_MCBSP_XCERH_ADDR(Port),_MCBSP_XCER_##Field,AND,OR,INV)
#define _MCBSP_XCERH_FMK(Field,Val)       _MCBSP_XCER_##Field##_MK(Val)
#define _MCBSP_XCERH_FMKS(Field,Sym)      _MCBSP_XCER_##Field##_MK(MCBSP_XCER_##Field##_##Sym)

#define _MCBSP_XCERH0_FGET(Field)         _MCBSP_XCERH_FGET(0,##Field)
#define _MCBSP_XCERH1_FGET(Field)         _MCBSP_XCERH_FGET(1,##Field)
#define _MCBSP_XCERH2_FGET(Field)         _MCBSP_XCERH_FGET(2,##Field)
#define _MCBSP_XCERH0_FSET(Field,Val)     _MCBSP_XCERH_FSET(0,##Field,Val)
#define _MCBSP_XCERH1_FSET(Field,Val)     _MCBSP_XCERH_FSET(1,##Field,Val)
#define _MCBSP_XCERH2_FSET(Field,Val)     _MCBSP_XCERH_FSET(2,##Field,Val)
#define _MCBSP_XCERH0_FSETS(Field,Sym)    _MCBSP_XCERH_FSETS(0,##Field,Sym)
#define _MCBSP_XCERH1_FSETS(Field,Sym)    _MCBSP_XCERH_FSETS(1,##Field,Sym)
#define _MCBSP_XCERH2_FSETS(Field,Sym)    _MCBSP_XCERH_FSETS(2,##Field,Sym)
#define _MCBSP_XCERH0_FAOI(Field,AND,OR,INV) _MCBSP_XCERH_FAOI(0,##Field,AND,OR,INV)
#define _MCBSP_XCERH1_FAOI(Field,AND,OR,INV) _MCBSP_XCERH_FAOI(1,##Field,AND,OR,INV)
#define _MCBSP_XCERH2_FAOI(Field,AND,OR,INV) _MCBSP_XCERH_FAOI(2,##Field,AND,OR,INV)
#define _MCBSP_XCERH0_FMK(Field,Val)         _MCBSP_XCERH_FMK(##Field,Val)
#define _MCBSP_RCERH1_FMK(Field,Val)         _MCBSP_RCERH_FMK(##Field,Val)
#define _MCBSP_RCERH2_FMK(Field,Val)         _MCBSP_RCERH_FMK(##Field,Val)
#define _MCBSP_RCERH0_FMKS(Field,Sym)        _MCBSP_RCERH_FMKS(##Field,Sym)
#define _MCBSP_RCERH1_FMKS(Field,Sym)        _MCBSP_RCERH_FMKS(##Field,Sym)
#define _MCBSP_RCERH2_FMKS(Field,Sym)        _MCBSP_RCERH_FMKS(##Field,Sym)

/*============================================================================*\
* (RW) _MCBSP_SPCR10 -  Serial Port Control Register 1, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SPCR10_ADDR				(0x2805u)
  #define _MCBSP_SPCR10                       	PREG16(_MCBSP_SPCR10_ADDR)
  #define _SPCR10                              	_MCBSP_SPCR10
#else
  #define _MCBSP_SPCR10_ADDR				(0x2804u)
  #define _MCBSP_SPCR10                       	PREG16(_MCBSP_SPCR10_ADDR)
  #define _SPCR10                              	_MCBSP_SPCR10
#endif
/*============================================================================*\
* (RW) _MCBSP_SPCR11 -  Serial Port Control Register 1, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SPCR11_ADDR				(0x2C05u)
  #define _MCBSP_SPCR11                       	PREG16(_MCBSP_SPCR11_ADDR)
  #define _SPCR11                              	_MCBSP_SPCR11
#else
  #define _MCBSP_SPCR11_ADDR				(0x2C04u)
  #define _MCBSP_SPCR11                       	PREG16(_MCBSP_SPCR11_ADDR)
  #define _SPCR11                              	_MCBSP_SPCR11
#endif

/*============================================================================*\
* (RW) _MCBSP_SPCR12 -  Serial Port Control Register 1, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SPCR12_ADDR				(0x3005)
  #define _MCBSP_SPCR12                       	PREG16(_MCBSP_SPCR12_ADDR)
  #define _SPCR12                              	_MCBSP_SPCR12
#else
  #define _MCBSP_SPCR12_ADDR				(0x3004)
  #define _MCBSP_SPCR12                       	PREG16(_MCBSP_SPCR12_ADDR)
  #define _SPCR12                              	_MCBSP_SPCR12
#endif
/*============================================================================*\
 _MCBSP_SPCR1_GET and _MCBSP_SPCR1_SET
\*============================================================================*/
#define _MCBSP_SPCR1_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_SPCR1_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_SPCR20 -  Serial Port Control Register 2, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SPCR20_ADDR				(0x2804u)
  #define _MCBSP_SPCR20                       	PREG16(_MCBSP_SPCR20_ADDR)
  #define _SPCR20                              	_MCBSP_SPCR20
#else
  #define _MCBSP_SPCR20_ADDR				(0x2805u)
  #define _MCBSP_SPCR20                       	PREG16(_MCBSP_SPCR20_ADDR)
  #define _SPCR20                              	_MCBSP_SPCR20
#endif

/*============================================================================*\
* (RW) _MCBSP_SPCR21_ -  Serial Port Control Register 2, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SPCR21_ADDR				(0x2C04u)
  #define _MCBSP_SPCR21                       	PREG16(_MCBSP_SPCR21_ADDR)
  #define _SPCR21                              	_MCBSP_SPCR21
#else
  #define _MCBSP_SPCR21_ADDR				(0x2C05u)
  #define _MCBSP_SPCR21                       	PREG16(_MCBSP_SPCR21_ADDR)
  #define _SPCR21                              	_MCBSP_SPCR21
#endif
/*============================================================================*\
* (RW) _MCBSP_SPCR22_ -  Serial Port Control Register 2, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SPCR22_ADDR				(0x3004)
  #define _MCBSP_SPCR22_                       	PREG16(_MCBSP_SPCR22_ADDR)
  #define _SPCR22_                              	_MCBSP_SPCR22_
#else
  #define _MCBSP_SPCR22_ADDR				(0x3005)
  #define _MCBSP_SPCR22_                       	PREG16(_MCBSP_SPCR22_ADDR)
  #define _SPCR22_                              	_MCBSP_SPCR22_
#endif
/*============================================================================*\
* _MCBSP_SPCR2_GET and _MCBSP_SPCR2_SET
\*============================================================================*/
#define _MCBSP_SPCR2_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_SPCR2_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_PCR0  -  Pin Control Register, McBSP #0
\*============================================================================*/
  #define _MCBSP_PCR0_ADDR				(0x2812u)
  #define _MCBSP_PCR0                       	PREG16(_MCBSP_PCR0_ADDR)
  #define _PCR0                              	_MCBSP_PCR0

/*============================================================================*\
* (RW) _MCBSP_PCR1  -  Pin Control Register, McBSP #1
\*============================================================================*/
  #define _MCBSP_PCR1_ADDR				(0x2C12u)
  #define _MCBSP_PCR1                       	PREG16(_MCBSP_PCR1_ADDR)
  #define _PCR1                              	_MCBSP_PCR1

/*============================================================================*\
* (RW) _MCBSP_PCR2  -  Pin Control Register, McBSP #2
\*============================================================================*/
  #define _MCBSP_PCR2_ADDR				(0x3012)
  #define _MCBSP_PCR2                       	PREG16(_MCBSP_PCR2_ADDR)
  #define _PCR2                              	_MCBSP_PCR2

/*============================================================================*\
* _MCBSP_PCR_GET and _MCBSP_PCR_SET
\*============================================================================*/
#define _MCBSP_PCR_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_PCR_SET(RegAddr,Val)			_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_RCR10  -  Receive and Transmit Control Register 1, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCR10_ADDR				(0x2807u)
  #define _MCBSP_RCR10					PREG16(_MCBSP_RCR10_ADDR)
  #define _RCR10						_MCBSP_RCR10
#else
  #define _MCBSP_RCR10_ADDR				(0x2806u)
  #define _MCBSP_RCR10					PREG16(_MCBSP_RCR10_ADDR)
  #define _RCR10						_MCBSP_RCR10
#endif
/*============================================================================*\
* (RW) _MCBSP_RCR11  -  Receive and Transmit Control Register 1, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCR11_ADDR				(0x2C07u)
  #define _MCBSP_RCR11					PREG16(_MCBSP_RCR11_ADDR)
  #define _RCR11						_MCBSP_RCR11
#else
  #define _MCBSP_RCR11_ADDR				(0x2C06u)
  #define _MCBSP_RCR11					PREG16(_MCBSP_RCR11_ADDR)
  #define _RCR11						_MCBSP_RCR11
#endif

/*============================================================================*\
* (RW) _MCBSP_RCR12  -  Receive and Transmit Control Register 1, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCR12_ADDR				(0x3007u)
  #define _MCBSP_RCR12					PREG16(_MCBSP_RCR12_ADDR)
  #define _RCR12						_MCBSP_RCR12
#else
  #define _MCBSP_RCR12_ADDR				(0x3006u)
  #define _MCBSP_RCR12					PREG16(_MCBSP_RCR12_ADDR)
  #define _RCR12						_MCBSP_RCR12
#endif
/*============================================================================*\
* _MCBSP_RCR1_GET and _MCBSP_RCR1_SET
\*============================================================================*/
#define _MCBSP_RCR1_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_RCR1_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_RCR20  -  Receive and Transmit Control Register 2, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCR20_ADDR				(0x2806u)
  #define _MCBSP_RCR20					PREG16(_MCBSP_RCR20_ADDR)
  #define _RCR20						_MCBSP_RCR20
#else
  #define _MCBSP_RCR20_ADDR				(0x2807u)
  #define _MCBSP_RCR20					PREG16(_MCBSP_RCR20_ADDR)
  #define _RCR20						_MCBSP_RCR20
#endif

/*============================================================================*\
* (RW) _MCBSP_RCR21  -  Receive and Transmit Control Register 2, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCR21_ADDR				(0x2C06u)
  #define _MCBSP_RCR21					PREG16(_MCBSP_RCR21_ADDR)
  #define _RCR21						_MCBSP_RCR21
#else
  #define _MCBSP_RCR21_ADDR				(0x2C07u)
  #define _MCBSP_RCR21					PREG16(_MCBSP_RCR21_ADDR)
  #define _RCR21						_MCBSP_RCR21
#endif

/*============================================================================*\
* (RW) _MCBSP_RCR22  -  Receive and Transmit Control Register 2, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCR22_ADDR				(0x3006u)
  #define _MCBSP_RCR22					PREG16(_MCBSP_RCR22_ADDR)
  #define _RCR22						_MCBSP_RCR22
#else
  #define _MCBSP_RCR22_ADDR				(0x3007u)
  #define _MCBSP_RCR22					PREG16(_MCBSP_RCR22_ADDR)
  #define _RCR22						_MCBSP_RCR22
#endif

/*============================================================================*\
* _MCBSP_RCR2_GET and _MCBSP_RCR2_SET
\*============================================================================*/
#define _MCBSP_RCR2_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_RCR2_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_XCR10  -  Transmit Control Register 1, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCR10_ADDR				(0x2809u)
  #define _MCBSP_XCR10					PREG16(_MCBSP_XCR10_ADDR)
  #define _XCR10						_MCBSP_XCR10
#else
  #define _MCBSP_XCR10_ADDR				(0x2808u)
  #define _MCBSP_XCR10					PREG16(_MCBSP_XCR10_ADDR)
  #define _XCR10						_MCBSP_XCR10
#endif

/*============================================================================*\
* (RW) _MCBSP_XCR11  -  Transmit Control Register 1, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCR11_ADDR				(0x2C09u)
  #define _MCBSP_XCR11					PREG16(_MCBSP_XCR11_ADDR)
  #define _XCR11						_MCBSP_XCR11
#else
  #define _MCBSP_XCR11_ADDR				(0x2C08u)
  #define _MCBSP_XCR11					PREG16(_MCBSP_XCR11_ADDR)
  #define _XCR11						_MCBSP_XCR11
#endif

/*============================================================================*\
* (RW) _MCBSP_XCR12  -  Transmit Control Register 1, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCR12_ADDR				(0x3009u)
  #define _MCBSP_XCR12					PREG16(_MCBSP_XCR12_ADDR)
  #define _XCR12						_MCBSP_XCR12
#else
  #define _MCBSP_XCR12_ADDR				(0x3008u)
  #define _MCBSP_XCR12					PREG16(_MCBSP_XCR12_ADDR)
  #define _XCR12						_MCBSP_XCR12
#endif

/*============================================================================*\
* _MCBSP_XCR1_GET and _MCBSP_XCR1_SET
\*============================================================================*/
#define _MCBSP_XCR1_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_XCR1_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_XCR20  -  Transmit Control Register 2, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCR20_ADDR				(0x2808u)
  #define _MCBSP_XCR20					PREG16(_MCBSP_XCR20_ADDR)
  #define _XCR20						_MCBSP_XCR20
#else
  #define _MCBSP_XCR20_ADDR				(0x2809u)
  #define _MCBSP_XCR20					PREG16(_MCBSP_XCR20_ADDR)
  #define _XCR20						_MCBSP_XCR20
#endif

/*============================================================================*\
* (RW) _MCBSP_XCR21  -  Transmit Control Register 2, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCR21_ADDR				(0x2C08u)
  #define _MCBSP_XCR21					PREG16(_MCBSP_XCR21_ADDR)
  #define _XCR21						_MCBSP_XCR21
#else
  #define _MCBSP_XCR21_ADDR				(0x2C09u)
  #define _MCBSP_XCR21					PREG16(_MCBSP_XCR21_ADDR)
  #define _XCR21						_MCBSP_XCR21
#endif

/*============================================================================*\
* (RW) _MCBSP_XCR22  -  Transmit Control Register 2, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCR22_ADDR				(0x3008u)
  #define _MCBSP_XCR22					PREG16(_MCBSP_XCR22_ADDR)
  #define _XCR22						_MCBSP_XCR22
#else
  #define _MCBSP_XCR22_ADDR				(0x3009u)
  #define _MCBSP_XCR22					PREG16(_MCBSP_XCR22_ADDR)
  #define _XCR22						_MCBSP_XCR22
#endif
/*============================================================================*\
* _MCBSP_XCR2_GET and _MCBSP_XCR2_SET
\*============================================================================*/
#define _MCBSP_XCR2_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_XCR2_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_SRGR10 -  Sample Rate Generator Register 1, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SRGR10_ADDR				(0x280Bu)
  #define _MCBSP_SRGR10					PREG16(_MCBSP_SRGR10_ADDR)
  #define _SRGR10						_MCBSP_SRGR10
#else
  #define _MCBSP_SRGR10_ADDR				(0x280Au)
  #define _MCBSP_SRGR10					PREG16(_MCBSP_SRGR10_ADDR)
  #define _SRGR10						_MCBSP_SRGR10
#endif

/*============================================================================*\
* (RW) _MCBSP_SRGR11 -  Sample Rate Generator Register 1, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SRGR11_ADDR				(0x2C0Bu)
  #define _MCBSP_SRGR11					PREG16(_MCBSP_SRGR11_ADDR)
  #define _SRGR11						_MCBSP_SRGR11
#else
  #define _MCBSP_SRGR11_ADDR				(0x2C0Au)
  #define _MCBSP_SRGR11					PREG16(_MCBSP_SRGR11_ADDR)
  #define _SRGR11						_MCBSP_SRGR11
#endif

/*============================================================================*\
* (RW) _MCBSP_SRGR12 -  Sample Rate Generator Register 1, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SRGR12_ADDR				(0x300Bu)
  #define _MCBSP_SRGR12					PREG16(_MCBSP_SRGR12_ADDR)
  #define _SRGR12						_MCBSP_SRGR12
#else
  #define _MCBSP_SRGR12_ADDR				(0x300Au)
  #define _MCBSP_SRGR12					PREG16(_MCBSP_SRGR12_ADDR)
  #define _SRGR12						_MCBSP_SRGR12
#endif

/*============================================================================*\
* _MCBSP_SRGR1_GET and _MCBSP_SRGR1_SET
\*============================================================================*/
#define _MCBSP_SRGR1_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_SRGR1_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_SRGR20 -  Sample Rate Generator Register 2, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SRGR20_ADDR				(0x280Au)
  #define _MCBSP_SRGR20					PREG16(_MCBSP_SRGR20_ADDR)
  #define _SRGR20						_MCBSP_SRGR20
#else
  #define _MCBSP_SRGR20_ADDR				(0x280Bu)
  #define _MCBSP_SRGR20					PREG16(_MCBSP_SRGR20_ADDR)
  #define _SRGR20						_MCBSP_SRGR20
#endif

/*============================================================================*\
* (RW) _MCBSP_SRGR21 -  Sample Rate Generator Register 2, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SRGR21_ADDR				(0x2C0Au)
  #define _MCBSP_SRGR21					PREG16(_MCBSP_SRGR21_ADDR)
  #define _SRGR21						_MCBSP_SRGR21
#else
  #define _MCBSP_SRGR21_ADDR				(0x2C0Bu)
  #define _MCBSP_SRGR21					PREG16(_MCBSP_SRGR21_ADDR)
  #define _SRGR21						_MCBSP_SRGR21
#endif

/*============================================================================*\
* (RW) _MCBSP_SRGR22 -  Sample Rate Generator Register 2, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_SRGR22_ADDR				(0x300Au)
  #define _MCBSP_SRGR22					PREG16(_MCBSP_SRGR22_ADDR)
  #define _SRGR22						_MCBSP_SRGR22
#else
  #define _MCBSP_SRGR22_ADDR				(0x300Bu)
  #define _MCBSP_SRGR22					PREG16(_MCBSP_SRGR22_ADDR)
  #define _SRGR22						_MCBSP_SRGR22
#endif

/*============================================================================*\
* _MCBSP_SRGR2_GET and _MCBSP_SRGR2_SET
\*============================================================================*/
#define _MCBSP_SRGR2_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_SRGR2_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_MCR10  -  Multi-channel Control Register 1, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_MCR10_ADDR				(0x280Du)
  #define _MCBSP_MCR10					PREG16(_MCBSP_MCR10_ADDR)
  #define _MCR10						_MCBSP_MCR10
#else
  #define _MCBSP_MCR10_ADDR				(0x280Cu)
  #define _MCBSP_MCR10					PREG16(_MCBSP_MCR10_ADDR)
  #define _MCR10						_MCBSP_MCR10
#endif

/*============================================================================*\
* (RW) _MCBSP_MCR11  -  Multi-channel Control Register 1, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_MCR11_ADDR				(0x2C0Du)
  #define _MCBSP_MCR11					PREG16(_MCBSP_MCR11_ADDR)
  #define _MCR11						_MCBSP_MCR11
#else
  #define _MCBSP_MCR11_ADDR				(0x2C0Cu)
  #define _MCBSP_MCR11					PREG16(_MCBSP_MCR11_ADDR)
  #define _MCR11						_MCBSP_MCR11
#endif

/*============================================================================*\
* (RW) _MCBSP_MCR12  -  Multi-channel Control Register 1, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_MCR12_ADDR				(0x300Du)
  #define _MCBSP_MCR12					PREG16(_MCBSP_MCR12_ADDR)
  #define _MCR12						_MCBSP_MCR12
#else
  #define _MCBSP_MCR12_ADDR				(0x300Cu)
  #define _MCBSP_MCR12					PREG16(_MCBSP_MCR12_ADDR)
  #define _MCR12						_MCBSP_MCR12
#endif

/*============================================================================*\
* _MCBSP_MCR1_GET and _MCBSP_MCR1_SET
\*============================================================================*/
#define _MCBSP_MCR1_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_MCR1_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_MCR20  -  Multi-channel Control Register 2, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_MCR20_ADDR				(0x280Cu)
  #define _MCBSP_MCR20					PREG16(_MCBSP_MCR20_ADDR)
  #define _MCR20						_MCBSP_MCR20
#else
  #define _MCBSP_MCR20_ADDR				(0x280Du)
  #define _MCBSP_MCR20					PREG16(_MCBSP_MCR20_ADDR)
  #define _MCR20						_MCBSP_MCR20
#endif

/*============================================================================*\
* (RW) _MCBSP_MCR21  -  Multi-channel Control Register 2, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_MCR21_ADDR				(0x2C0Cu)
  #define _MCBSP_MCR21					PREG16(_MCBSP_MCR21_ADDR)
  #define _MCR21						_MCBSP_MCR21
#else
  #define _MCBSP_MCR21_ADDR				(0x2C0Du)
  #define _MCBSP_MCR21					PREG16(_MCBSP_MCR21_ADDR)
  #define _MCR21						_MCBSP_MCR21
#endif

/*============================================================================*\
* (RW) _MCBSP_MCR22  -  Multi-channel Control Register 2, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_MCR22_ADDR				(0x300Cu)
  #define _MCBSP_MCR22					PREG16(_MCBSP_MCR22_ADDR)
  #define _MCR22						_MCBSP_MCR22
#else
  #define _MCBSP_MCR22_ADDR				(0x300Du)
  #define _MCBSP_MCR22					PREG16(_MCBSP_MCR22_ADDR)
  #define _MCR22						_MCBSP_MCR22
#endif

/*============================================================================*\
* _MCBSP_MCR2_GET and _MCBSP_MCR2_SET
\*============================================================================*/
#define _MCBSP_MCR2_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_MCR2_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_XCERA0 -  Transmit Channel Enable Register Partition A, McBSP #0
\*============================================================================*/
  #define _MCBSP_XCERA0_ADDR				(0x2810u)
  #define _MCBSP_XCERA0					PREG16(_MCBSP_XCERA0_ADDR)
  #define _XCERA0						_MCBSP_XCERA0

/*============================================================================*\
* (RW) _MCBSP_XCERA1 -  Transmit Channel Enable Register Partition A, McBSP #1
\*============================================================================*/
#define _MCBSP_XCERA1_ADDR				(0x2C10u)
#define _MCBSP_XCERA1					PREG16(_MCBSP_XCERA1_ADDR)
#define _XCERA1						_MCBSP_XCERA1

/*============================================================================*\
* (RW) _MCBSP_XCERA2 -  Transmit Channel Enable Register Partition A, McBSP #2
\*============================================================================*/
#define _MCBSP_XCERA2_ADDR				(0x3010u)
#define _MCBSP_XCERA2					PREG16(_MCBSP_XCERA2_ADDR)
#define _XCERA2						_MCBSP_XCERA2

/*============================================================================*\
* _MCBSP_XCERA_GET and _MCBSP_XCERA_SET
\*============================================================================*/
#define _MCBSP_XCERA_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_XCERA_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_XCERB0 -  Transmit Channel Enable Register Partition B, McBSP #0
\*============================================================================*/
#define _MCBSP_XCERB0_ADDR				(0x2811u)
#define _MCBSP_XCERB0					PREG16(_MCBSP_XCERB0_ADDR)
#define _XCERB0						_MCBSP_XCERB0

/*============================================================================*\
* (RW) _MCBSP_XCERB1 -  Transmit Channel Enable Register Partition B, McBSP #1
\*============================================================================*/
#define _MCBSP_XCERB1_ADDR				(0x2C11u)
#define _MCBSP_XCERB1					PREG16(_MCBSP_XCERB1_ADDR)
#define _XCERB1						_MCBSP_XCERB1

/*============================================================================*\
* (RW) _MCBSP_XCERB2 -  Transmit Channel Enable Register Partition B, McBSP #2
\*============================================================================*/
#define _MCBSP_XCERB2_ADDR				(0x3011u)
#define _MCBSP_XCERB2					PREG16(_MCBSP_XCERB2_ADDR)
#define _XCERB2						_MCBSP_XCERB2

/*============================================================================*\
* _MCBSP_XCERB_GET and _MCBSP_XCERB_SET
\*============================================================================*/
#define _MCBSP_XCERB_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_XCERB_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_XCERC0 -  Transmit Channel Enable Register Partition C, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERC0_ADDR				(0x2815u)
  #define _MCBSP_XCERC0					PREG16(_MCBSP_XCERC0_ADDR)
  #define _XCERC0						_MCBSP_XCERC0
#else
  #define _MCBSP_XCERC0_ADDR				(0x2816u)
  #define _MCBSP_XCERC0					PREG16(_MCBSP_XCERC0_ADDR)
  #define _XCERC0						_MCBSP_XCERC0
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERC1 -  Transmit Channel Enable Register Partition C, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERC1_ADDR				(0x2C15u)
  #define _MCBSP_XCERC1					PREG16(_MCBSP_XCERC1_ADDR)
  #define _XCERC1						_MCBSP_XCERC1
#else
  #define _MCBSP_XCERC1_ADDR				(0x2C16u)
  #define _MCBSP_XCERC1					PREG16(_MCBSP_XCERC1_ADDR)
  #define _XCERC1						_MCBSP_XCERC1
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERC2 -  Transmit Channel Enable Register Partition C, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERC2_ADDR				(0x3015u)
  #define _MCBSP_XCERC2					PREG16(_MCBSP_XCERC2_ADDR)
  #define _XCERC2						_MCBSP_XCERC2
#else
  #define _MCBSP_XCERC2_ADDR				(0x3016u)
  #define _MCBSP_XCERC2					PREG16(_MCBSP_XCERC2_ADDR)
  #define _XCERC2						_MCBSP_XCERC2
#endif

/*============================================================================*\
* _MCBSP_XCERC_GET and _MCBSP_XCERC_SET
\*============================================================================*/
#define _MCBSP_XCERC_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_XCERC_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_XCERD0 -  Transmit Channel Enable Register Partition D, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERD0_ADDR				(0x2816u)
  #define _MCBSP_XCERD0					PREG16(_MCBSP_XCERD0_ADDR)
  #define _XCERD0						_MCBSP_XCERD0
#else
  #define _MCBSP_XCERD0_ADDR				(0x2817u)
  #define _MCBSP_XCERD0					PREG16(_MCBSP_XCERD0_ADDR)
  #define _XCERD0						_MCBSP_XCERD0
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERD1 -  Transmit Channel Enable Register Partition D, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERD1_ADDR				(0x2C16u)
  #define _MCBSP_XCERD1					PREG16(_MCBSP_XCERD1_ADDR)
  #define _XCERD1						_MCBSP_XCERD1
#else
  #define _MCBSP_XCERD1_ADDR				(0x2C17u)
  #define _MCBSP_XCERD1					PREG16(_MCBSP_XCERD1_ADDR)
  #define _XCERD1						_MCBSP_XCERD1
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERD2 -  Transmit Channel Enable Register Partition D, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERD2_ADDR				(0x3016u)
  #define _MCBSP_XCERD2					PREG16(_MCBSP_XCERD2_ADDR)
  #define _XCERD2						_MCBSP_XCERD2
#else
  #define _MCBSP_XCERD2_ADDR				(0x3017u)
  #define _MCBSP_XCERD2					PREG16(_MCBSP_XCERD2_ADDR)
  #define _XCERD2						_MCBSP_XCERD2
#endif

/*============================================================================*\
* _MCBSP_XCERD_GET and _MCBSP_XCERD_SET
\*============================================================================*/
#define _MCBSP_XCERD_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_XCERD_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_XCERE0 -  Transmit Channel Enable Register Partition E, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERE0_ADDR				(0x2819u)
  #define _MCBSP_XCERE0					PREG16(_MCBSP_XCERE0_ADDR)
  #define _XCERE0						_MCBSP_XCERE0
#else
  #define _MCBSP_XCERE0_ADDR				(0x281Au)
  #define _MCBSP_XCERE0					PREG16(_MCBSP_XCERE0_ADDR)
  #define _XCERE0						_MCBSP_XCERE0
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERE1 -  Transmit Channel Enable Register Partition E, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERE1_ADDR				(0x2C19u)
  #define _MCBSP_XCERE1					PREG16(_MCBSP_XCERE1_ADDR)
  #define _XCERE1						_MCBSP_XCERE1
#else
  #define _MCBSP_XCERE1_ADDR				(0x2C1Au)
  #define _MCBSP_XCERE1					PREG16(_MCBSP_XCERE1_ADDR)
  #define _XCERE1						_MCBSP_XCERE1
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERE2 -  Transmit Channel Enable Register Partition E, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERE2_ADDR				(0x3019u)
  #define _MCBSP_XCERE2					PREG16(_MCBSP_XCERE2_ADDR)
  #define _XCERE2						_MCBSP_XCERE2
#else
  #define _MCBSP_XCERE2_ADDR				(0x301Au)
  #define _MCBSP_XCERE2					PREG16(_MCBSP_XCERE2_ADDR)
  #define _XCERE2						_MCBSP_XCERE2
#endif

/*============================================================================*\
* _MCBSP_XCERE_GET and _MCBSP_XCERE_SET
\*============================================================================*/
#define _MCBSP_XCERE_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_XCERE_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_XCERF0 -  Transmit Channel Enable Register Partition F, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERF0_ADDR				(0x281Au)
  #define _MCBSP_XCERF0					PREG16(_MCBSP_XCERF0_ADDR)
  #define _XCERF0						_MCBSP_XCERF0
#else
  #define _MCBSP_XCERF0_ADDR				(0x281Bu)
  #define _MCBSP_XCERF0					PREG16(_MCBSP_XCERF0_ADDR)
  #define _XCERF0						_MCBSP_XCERF0
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERF1 -  Transmit Channel Enable Register Partition F, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERF1_ADDR				(0x2C1Au)
  #define _MCBSP_XCERF1					PREG16(_MCBSP_XCERF1_ADDR)
  #define _XCERF1						_MCBSP_XCERF1
#else
  #define _MCBSP_XCERF1_ADDR				(0x2C1Bu)
  #define _MCBSP_XCERF1					PREG16(_MCBSP_XCERF1_ADDR)
  #define _XCERF1						_MCBSP_XCERF1
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERF2 -  Transmit Channel Enable Register Partition F, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERF2_ADDR				(0x301Au)
  #define _MCBSP_XCERF2					PREG16(_MCBSP_XCERF2_ADDR)
  #define _XCERF2						_MCBSP_XCERF2
#else
  #define _MCBSP_XCERF2_ADDR				(0x301Bu)
  #define _MCBSP_XCERF2					PREG16(_MCBSP_XCERF2_ADDR)
  #define _XCERF2						_MCBSP_XCERF2
#endif

/*============================================================================*\
* _MCBSP_XCERF_GET and _MCBSP_XCERF_SET
\*============================================================================*/
#define _MCBSP_XCERF_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_XCERF_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_XCERG0 -  Transmit Channel Enable Register Partition G, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERG0_ADDR				(0x281Du)
  #define _MCBSP_XCERG0					PREG16(_MCBSP_XCERG0_ADDR)
  #define _XCERG0						_MCBSP_XCERG0
#else
  #define _MCBSP_XCERG0_ADDR				(0x281Eu)
  #define _MCBSP_XCERG0					PREG16(_MCBSP_XCERG0_ADDR)
  #define _XCERG0						_MCBSP_XCERG0
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERG1 -  Transmit Channel Enable Register Partition G, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERG1_ADDR				(0x2C1Du)
  #define _MCBSP_XCERG1					PREG16(_MCBSP_XCERG1_ADDR)
  #define _XCERG1						_MCBSP_XCERG1
#else
  #define _MCBSP_XCERG1_ADDR				(0x2C1Eu)
  #define _MCBSP_XCERG1					PREG16(_MCBSP_XCERG1_ADDR)
  #define _XCERG1						_MCBSP_XCERG1
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERG2 -  Transmit Channel Enable Register Partition G, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERG2_ADDR				(0x301Du)
  #define _MCBSP_XCERG2					PREG16(_MCBSP_XCERG2_ADDR)
  #define _XCERG2						_MCBSP_XCERG2
#else
  #define _MCBSP_XCERG2_ADDR				(0x301Eu)
  #define _MCBSP_XCERG2					PREG16(_MCBSP_XCERG2_ADDR)
  #define _XCERG2						_MCBSP_XCERG2
#endif

/*============================================================================*\
* _MCBSP_XCERG_GET and _MCBSP_XCERG_SET
\*============================================================================*/
#define _MCBSP_XCERG_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_XCERG_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_XCERH0 -  Transmit Channel Enable Register Partition H, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERH0_ADDR				(0x281Eu)
  #define _MCBSP_XCERH0					PREG16(_MCBSP_XCERH0_ADDR)
  #define _XCERH0						_MCBSP_XCERH0
#else
  #define _MCBSP_XCERH0_ADDR				(0x281Fu)
  #define _MCBSP_XCERH0					PREG16(_MCBSP_XCERH0_ADDR)
  #define _XCERH0						_MCBSP_XCERH0
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERH1 -  Transmit Channel Enable Register Partition H, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERH1_ADDR				(0x2C1Eu)
  #define _MCBSP_XCERH1					PREG16(_MCBSP_XCERH1_ADDR)
  #define _XCERH1						_MCBSP_XCERH1
#else
  #define _MCBSP_XCERH1_ADDR				(0x2C1Fu)
  #define _MCBSP_XCERH1					PREG16(_MCBSP_XCERH1_ADDR)
  #define _XCERH1						_MCBSP_XCERH1
#endif

/*============================================================================*\
* (RW) _MCBSP_XCERH2 -  Transmit Channel Enable Register Partition H, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_XCERH2_ADDR				(0x301Eu)
  #define _MCBSP_XCERH2					PREG16(_MCBSP_XCERH2_ADDR)
  #define _XCERH2						_MCBSP_XCERH2
#else
  #define _MCBSP_XCERH2_ADDR				(0x301Fu)
  #define _MCBSP_XCERH2					PREG16(_MCBSP_XCERH2_ADDR)
  #define _XCERH2						_MCBSP_XCERH2
#endif

/*============================================================================*\
* _MCBSP_XCERH_GET and _MCBSP_XCERH_SET
\*============================================================================*/
#define _MCBSP_XCERH_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_XCERH_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_RCERA0 -  Receive Channel Enable Register Partition A, McBSP #0
\*============================================================================*/
  #define _MCBSP_RCERA0_ADDR				(0x280Eu)
  #define _MCBSP_RCERA0					PREG16(_MCBSP_RCERA0_ADDR)
  #define _RCERA0						_MCBSP_RCERA0

/*============================================================================*\
* (RW) _MCBSP_RCERA1 -  Receive Channel Enable Register Partition A, McBSP #1
\*============================================================================*/
#define _MCBSP_RCERA1_ADDR				(0x2C0Eu)
#define _MCBSP_RCERA1					PREG16(_MCBSP_RCERA1_ADDR)
#define _RCERA1						_MCBSP_RCERA1

/*============================================================================*\
* (RW) _MCBSP_RCERA2 -  Receive Channel Enable Register Partition A, McBSP #2
\*============================================================================*/
#define _MCBSP_RCERA2_ADDR				(0x300Eu)
#define _MCBSP_RCERA2					PREG16(_MCBSP_RCERA2_ADDR)
#define _RCERA2						_MCBSP_RCERA2

/*============================================================================*\
* _MCBSP_RCERA_GET and _MCBSP_RCERA_SET
\*============================================================================*/
#define _MCBSP_RCERA_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_RCERA_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_RCERB0 -  Receive Channel Enable Register Partition B, McBSP #0
\*============================================================================*/
#define _MCBSP_RCERB0_ADDR				(0x280Fu)
#define _MCBSP_RCERB0					PREG16(_MCBSP_RCERB0_ADDR)
#define _RCERB0						_MCBSP_RCERB0

/*============================================================================*\
* (RW) _MCBSP_RCERB1 -  Receive Channel Enable Register Partition B, McBSP #1
\*============================================================================*/
#define _MCBSP_RCERB1_ADDR				(0x2C0Fu)
#define _MCBSP_RCERB1					PREG16(_MCBSP_RCERB1_ADDR)
#define _RCERB1						_MCBSP_RCERB1

/*============================================================================*\
* (RW) _MCBSP_RCERB2 -  Receive Channel Enable Register Partition B, McBSP #2
\*============================================================================*/
#define _MCBSP_RCERB2_ADDR				(0x300Fu)
#define _MCBSP_RCERB2					PREG16(_MCBSP_RCERB2_ADDR)
#define _RCERB2						_MCBSP_RCERB2

/*============================================================================*\
* _MCBSP_RCERB_GET and _MCBSP_RCERB_SET
\*============================================================================*/
#define _MCBSP_RCERB_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_RCERB_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_RCERC0 -  Receive Channel Enable Register Partition C, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERC0_ADDR				(0x2813u)
  #define _MCBSP_RCERC0					PREG16(_MCBSP_RCERC0_ADDR)
  #define _RCERC0						_MCBSP_RCERC0
#else
  #define _MCBSP_RCERC0_ADDR				(0x2814u)
  #define _MCBSP_RCERC0					PREG16(_MCBSP_RCERC0_ADDR)
  #define _RCERC0						_MCBSP_RCERC0
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERC1 -  Receive Channel Enable Register Partition C, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERC1_ADDR				(0x2C13u)
  #define _MCBSP_RCERC1					PREG16(_MCBSP_RCERC1_ADDR)
  #define _RCERC1						_MCBSP_RCERC1
#else
  #define _MCBSP_RCERC1_ADDR				(0x2C14u)
  #define _MCBSP_RCERC1					PREG16(_MCBSP_RCERC1_ADDR)
  #define _RCERC1						_MCBSP_RCERC1
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERC2 -  Receive Channel Enable Register Partition C, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERC2_ADDR				(0x3013u)
  #define _MCBSP_RCERC2					PREG16(_MCBSP_RCERC2_ADDR)
  #define _RCERC2						_MCBSP_RCERC2
#else
  #define _MCBSP_RCERC2_ADDR				(0x3014u)
  #define _MCBSP_RCERC2					PREG16(_MCBSP_RCERC2_ADDR)
  #define _RCERC2						_MCBSP_RCERC2
#endif

/*============================================================================*\
* _MCBSP_RCERC_GET and _MCBSP_RCERC_SET
\*============================================================================*/
#define _MCBSP_RCERC_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_RCERC_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_RCERD0 -  Receive Channel Enable Register Partition D, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERD0_ADDR				(0x2814u)
  #define _MCBSP_RCERD0					PREG16(_MCBSP_RCERD0_ADDR)
  #define _RCERD0						_MCBSP_RCERD0
#else
  #define _MCBSP_RCERD0_ADDR				(0x2815u)
  #define _MCBSP_RCERD0					PREG16(_MCBSP_RCERD0_ADDR)
  #define _RCERD0						_MCBSP_RCERD0
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERD1 -  Receive Channel Enable Register Partition D, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERD1_ADDR				(0x2C14u)
  #define _MCBSP_RCERD1					PREG16(_MCBSP_RCERD1_ADDR)
  #define _RCERD1						_MCBSP_RCERD1
#else
  #define _MCBSP_RCERD1_ADDR				(0x2C15u)
  #define _MCBSP_RCERD1					PREG16(_MCBSP_RCERD1_ADDR)
  #define _RCERD1						_MCBSP_RCERD1
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERD2 -  Receive Channel Enable Register Partition D, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERD2_ADDR				(0x3014u)
  #define _MCBSP_RCERD2					PREG16(_MCBSP_RCERD2_ADDR)
  #define _RCERD2						_MCBSP_RCERD2
#else
  #define _MCBSP_RCERD2_ADDR				(0x3015u)
  #define _MCBSP_RCERD2					PREG16(_MCBSP_RCERD2_ADDR)
  #define _RCERD2						_MCBSP_RCERD2
#endif

/*============================================================================*\
* _MCBSP_RCERD_GET and _MCBSP_RCERD_SET
\*============================================================================*/
#define _MCBSP_RCERD_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_RCERD_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_RCERE0 -  Receive Channel Enable Register Partition E, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERE0_ADDR				(0x2817u)
  #define _MCBSP_RCERE0					PREG16(_MCBSP_RCERE0_ADDR)
  #define _RCERE0						_MCBSP_RCERE0
#else
  #define _MCBSP_RCERE0_ADDR				(0x2818u)
  #define _MCBSP_RCERE0					PREG16(_MCBSP_RCERE0_ADDR)
  #define _RCERE0						_MCBSP_RCERE0
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERE1 -  Receive Channel Enable Register Partition E, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERE1_ADDR				(0x2C17u)
  #define _MCBSP_RCERE1					PREG16(_MCBSP_RCERE1_ADDR)
  #define _RCERE1						_MCBSP_RCERE1
#else
  #define _MCBSP_RCERE1_ADDR				(0x2C18u)
  #define _MCBSP_RCERE1					PREG16(_MCBSP_RCERE1_ADDR)
  #define _RCERE1						_MCBSP_RCERE1
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERE2 -  Receive Channel Enable Register Partition E, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERE2_ADDR				(0x3017u)
  #define _MCBSP_RCERE2					PREG16(_MCBSP_RCERE2_ADDR)
  #define _RCERE2						_MCBSP_RCERE2
#else
  #define _MCBSP_RCERE2_ADDR				(0x3018u)
  #define _MCBSP_RCERE2					PREG16(_MCBSP_RCERE2_ADDR)
  #define _RCERE2						_MCBSP_RCERE2
#endif

/*============================================================================*\
* _MCBSP_RCERE_GET and _MCBSP_RCERE_SET
\*============================================================================*/
#define _MCBSP_RCERE_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_RCERE_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_RCERF0 -  Receive Channel Enable Register Partition F, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERF0_ADDR				(0x2818u)
  #define _MCBSP_RCERF0					PREG16(_MCBSP_RCERF0_ADDR)
  #define _RCERF0						_MCBSP_RCERF0
#else
  #define _MCBSP_RCERF0_ADDR				(0x2819u)
  #define _MCBSP_RCERF0					PREG16(_MCBSP_RCERF0_ADDR)
  #define _RCERF0						_MCBSP_RCERF0
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERF1 -  Receive Channel Enable Register Partition F, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERF1_ADDR				(0x2C18u)
  #define _MCBSP_RCERF1					PREG16(_MCBSP_RCERF1_ADDR)
  #define _RCERF1						_MCBSP_RCERF1
#else
  #define _MCBSP_RCERF1_ADDR				(0x2C19u)
  #define _MCBSP_RCERF1					PREG16(_MCBSP_RCERF1_ADDR)
  #define _RCERF1						_MCBSP_RCERF1
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERF2 -  Receive Channel Enable Register Partition F, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERF2_ADDR				(0x3018u)
  #define _MCBSP_RCERF2					PREG16(_MCBSP_RCERF2_ADDR)
  #define _RCERF2						_MCBSP_RCERF2
#else
  #define _MCBSP_RCERF2_ADDR				(0x3019u)
  #define _MCBSP_RCERF2					PREG16(_MCBSP_RCERF2_ADDR)
  #define _RCERF2						_MCBSP_RCERF2
#endif

/*============================================================================*\
* _MCBSP_RCERF_GET and _MCBSP_RCERF_SET
\*============================================================================*/
#define _MCBSP_RCERF_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_RCERF_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_RCERG0 -  Receive Channel Enable Register Partition G, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERG0_ADDR				(0x281Bu)
  #define _MCBSP_RCERG0					PREG16(_MCBSP_RCERG0_ADDR)
  #define _RCERG0						_MCBSP_RCERG0
#else
  #define _MCBSP_RCERG0_ADDR				(0x281Cu)
  #define _MCBSP_RCERG0					PREG16(_MCBSP_RCERG0_ADDR)
  #define _RCERG0						_MCBSP_RCERG0
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERG1 -  Receive Channel Enable Register Partition G, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERG1_ADDR				(0x2C1Bu)
  #define _MCBSP_RCERG1					PREG16(_MCBSP_RCERG1_ADDR)
  #define _RCERG1						_MCBSP_RCERG1
#else
  #define _MCBSP_RCERG1_ADDR				(0x2C1Cu)
  #define _MCBSP_RCERG1					PREG16(_MCBSP_RCERG1_ADDR)
  #define _RCERG1						_MCBSP_RCERG1
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERG2 -  Receive Channel Enable Register Partition G, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERG2_ADDR				(0x301Bu)
  #define _MCBSP_RCERG2					PREG16(_MCBSP_RCERG2_ADDR)
  #define _RCERG2						_MCBSP_RCERG2
#else
  #define _MCBSP_RCERG2_ADDR				(0x301Cu)
  #define _MCBSP_RCERG2					PREG16(_MCBSP_RCERG2_ADDR)
  #define _RCERG2						_MCBSP_RCERG2
#endif

/*============================================================================*\
* _MCBSP_RCERG_GET and _MCBSP_RCERG_SET
\*============================================================================*/
#define _MCBSP_RCERG_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_RCERG_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_RCERH0 -  Receive Channel Enable Register Partition H, McBSP #0
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERH0_ADDR				(0x281Cu)
  #define _MCBSP_RCERH0					PREG16(_MCBSP_RCERH0_ADDR)
  #define _RCERH0						_MCBSP_RCERH0
#else
  #define _MCBSP_RCERH0_ADDR				(0x281Du)
  #define _MCBSP_RCERH0					PREG16(_MCBSP_RCERH0_ADDR)
  #define _RCERH0						_MCBSP_RCERH0
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERH1 -  Receive Channel Enable Register Partition H, McBSP #1
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERH1_ADDR				(0x2C1Cu)
  #define _MCBSP_RCERH1					PREG16(_MCBSP_RCERH1_ADDR)
  #define _RCERH1						_MCBSP_RCERH1
#else
  #define _MCBSP_RCERH1_ADDR				(0x2C1Du)
  #define _MCBSP_RCERH1					PREG16(_MCBSP_RCERH1_ADDR)
  #define _RCERH1						_MCBSP_RCERH1
#endif

/*============================================================================*\
* (RW) _MCBSP_RCERH2 -  Receive Channel Enable Register Partition H, McBSP #2
\*============================================================================*/
#if (!CHIP_5502)
  #define _MCBSP_RCERH2_ADDR				(0x301Cu)
  #define _MCBSP_RCERH2					PREG16(_MCBSP_RCERH2_ADDR)
  #define _RCERH2						_MCBSP_RCERH2
#else
  #define _MCBSP_RCERH2_ADDR				(0x301Du)
  #define _MCBSP_RCERH2					PREG16(_MCBSP_RCERH2_ADDR)
  #define _RCERH2						_MCBSP_RCERH2
#endif

/*============================================================================*\
* _MCBSP_RCERH_GET and _MCBSP_RCERH_SET
\*============================================================================*/
#define _MCBSP_RCERH_GET(RegAddr)			_PREG_GET(RegAddr)
#define _MCBSP_RCERH_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_DRR10  -  Data Receive Register 1, McBSP #0
\*============================================================================*/
#define _MCBSP_DRR10					PREG16(_MCBSP_DRR10_ADDR)
#define _DRR10						_MCBSP_DRR10

/*============================================================================*\
* (RW) _MCBSP_DRR11  -  Data Receive Register 1, McBSP #1
\*============================================================================*/
#define _MCBSP_DRR11					PREG16(_MCBSP_DRR11_ADDR)
#define _DRR11						_MCBSP_DRR11

/*============================================================================*\
* (RW) _MCBSP_DRR12  -  Data Receive Register 1, McBSP #2
\*============================================================================*/
#define _MCBSP_DRR12					PREG16(_MCBSP_DRR12_ADDR)
#define _DRR12						_MCBSP_DRR12

/*============================================================================*\
* _MCBSP_DRR1_GET and _MCBSP_DRR1_SET
\*============================================================================*/
#define _MCBSP_DRR1_GET(RegAddr)		_PREG_GET(RegAddr)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_DRR20  -  Data Receive Register 2, McBSP #0
\*============================================================================*/
#define _MCBSP_DRR20					PREG16(_MCBSP_DRR20_ADDR)
#define _DRR20						_MCBSP_DRR20

/*============================================================================*\
* (RW) _MCBSP_DRR21  -  Data Receive Register 2, McBSP #1
\*============================================================================*/
#define _MCBSP_DRR21					PREG16(_MCBSP_DRR21_ADDR)
#define _DRR21						_MCBSP_DRR21

/*============================================================================*\
* (RW) _MCBSP_DRR22  -  Data Receive Register 2, McBSP #2
\*============================================================================*/
#define _MCBSP_DRR22					PREG16(_MCBSP_DRR22_ADDR)
#define _DRR22						_MCBSP_DRR22

/*============================================================================*\
* _MCBSP_DRR2_GET
\*============================================================================*/
#define _MCBSP_DRR2_GET(RegAddr)			_PREG_GET(RegAddr)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_DXR10  -  Data Transmit Register 1, McBSP #0
\*============================================================================*/
#define _MCBSP_DXR10					PREG16(_MCBSP_DXR10_ADDR)
#define _DXR10						_MCBSP_DXR10

/*============================================================================*\
* (RW) _MCBSP_DXR11  -  Data Transmit Register 1, McBSP #0
\*============================================================================*/
#define _MCBSP_DXR11					PREG16(_MCBSP_DXR11_ADDR)
#define _DXR11						_MCBSP_DXR11

/*============================================================================*\
* (RW) _MCBSP_DXR12  -  Data Transmit Register 1, McBSP #0
\*============================================================================*/
#define _MCBSP_DXR12					PREG16(_MCBSP_DXR12_ADDR)
#define _DXR12						_MCBSP_DXR12

/*============================================================================*\
* _MCBSP_DXR1_SET
\*============================================================================*/
#define _MCBSP_DXR1_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _MCBSP_DXR20  -  Data Transmit Register 2, McBSP #0
\*============================================================================*/
#define _MCBSP_DXR20					PREG16(_MCBSP_DXR20_ADDR)
#define _DXR20						_MCBSP_DXR20

/*============================================================================*\
* (RW) _MCBSP_DXR21  -  Data Transmit Register 2, McBSP #0
\*============================================================================*/
#define _MCBSP_DXR21					PREG16(_MCBSP_DXR21_ADDR)
#define _DXR21						_MCBSP_DXR21

/*============================================================================*\
* (RW) _MCBSP_DXR22  -  Data Transmit Register 2, McBSP #0
\*============================================================================*/
#define _MCBSP_DXR22					PREG16(_MCBSP_DXR22_ADDR)
#define _DXR22						_MCBSP_DXR22

/*============================================================================*\
* _MCBSP_DXR2_GET and _MCBSP_DXR2_SET
\*============================================================================*/
#define _MCBSP_DXR2_SET(RegAddr,Val)		_PREG_SET(RegAddr,Val)

/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================*\
* _MCBSP_SPCR1   - Serial Port Control Register 1
*
* Fields:
*  (RW) _MCBSP_SPCR1_DLB
*  (RW) _MCBSP_SPCR1_RJUST
*  (RW) _MCBSP_SPCR1_CLKSTP
*  (RW) _MCBSP_SPCR1_DXENA
*  (RW) _MCBSP_SPCR1_ABIS
*  (RW) _MCBSP_SPCR1_RINTM
*  (RW) _MCBSP_SPCR1_RSYNCERR
*  (R)  _MCBSP_SPCR1_RFULL
*  (R)  _MCBSP_SPCR1_RRDY
*  (RW) _MCBSP_SPCR1_RRST
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_SPCR1_DLB
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR1_DLB_SHIFT		(0x000Fu)
#define _MCBSP_SPCR1_DLB_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR1_DLB_SHIFT)
#define _MCBSP_SPCR1_DLB_MASK       	(_MCBSP_SPCR1_DLB_MK(0x0001u))
#define _MCBSP_SPCR1_DLB_CLR        	(~(_MCBSP_SPCR1_DLB_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_SPCR1_RJUST
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR1_RJUST_SHIFT		(0x000Du)
#define _MCBSP_SPCR1_RJUST_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_SPCR1_RJUST_SHIFT)
#define _MCBSP_SPCR1_RJUST_MASK       	(_MCBSP_SPCR1_RJUST_MK(0x0003u))
#define _MCBSP_SPCR1_RJUST_CLR        	(~(_MCBSP_SPCR1_RJUST_MK(0x0003u)))

/*==========================================================================*\
* (RW) _MCBSP_SPCR1_CLKSTP
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR1_CLKSTP_SHIFT		(0x000Bu)
#define _MCBSP_SPCR1_CLKSTP_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_SPCR1_CLKSTP_SHIFT)
#define _MCBSP_SPCR1_CLKSTP_MASK       	(_MCBSP_SPCR1_CLKSTP_MK(0x0003u))
#define _MCBSP_SPCR1_CLKSTP_CLR        	(~(_MCBSP_SPCR1_CLKSTP_MK(0x0003u)))

/*==========================================================================*\
* (RW) _MCBSP_SPCR1_DXENA
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR1_DXENA_SHIFT		(0x0007u)
#define _MCBSP_SPCR1_DXENA_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR1_DXENA_SHIFT)
#define _MCBSP_SPCR1_DXENA_MASK       	(_MCBSP_SPCR1_DXENA_MK(0x0001u))
#define _MCBSP_SPCR1_DXENA_CLR        	(~(_MCBSP_SPCR1_DXENA_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_SPCR1_ABIS
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR1_ABIS_SHIFT		(0x0006u)
#define _MCBSP_SPCR1_ABIS_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR1_ABIS_SHIFT)
#define _MCBSP_SPCR1_ABIS_MASK       	(_MCBSP_SPCR1_ABIS_MK(0x0001u))
#define _MCBSP_SPCR1_ABIS_CLR        	(~(_MCBSP_SPCR1_ABIS_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_SPCR1_RINTM
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR1_RINTM_SHIFT		(0x0004u)
#define _MCBSP_SPCR1_RINTM_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_SPCR1_RINTM_SHIFT)
#define _MCBSP_SPCR1_RINTM_MASK       	(_MCBSP_SPCR1_RINTM_MK(0x0003u))
#define _MCBSP_SPCR1_RINTM_CLR        	(~(_MCBSP_SPCR1_RINTM_MK(0x0003u)))

/*==========================================================================*\
* (RW) _MCBSP_SPCR1_RSYNCERR
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR1_RSYNCERR_SHIFT		(0x0003u)
#define _MCBSP_SPCR1_RSYNCERR_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR1_RSYNCERR_SHIFT)
#define _MCBSP_SPCR1_RSYNCERR_MASK       	(_MCBSP_SPCR1_RSYNCERR_MK(0x0001u))
#define _MCBSP_SPCR1_RSYNCERR_CLR        	(~(_MCBSP_SPCR1_RSYNCERR_MK(0x0001u)))

/*==========================================================================*\
* (R)  _MCBSP_SPCR1_RFULL
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR1_RFULL_SHIFT		(0x0002u)
#define _MCBSP_SPCR1_RFULL_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR1_RFULL_SHIFT)
#define _MCBSP_SPCR1_RFULL_MASK       	(_MCBSP_SPCR1_RFULL_MK(0x0001u))
#define _MCBSP_SPCR1_RFULL_CLR            (~(_MCBSP_SPCR1_RFULL_MASK))

/*==========================================================================*\
* (R)  _MCBSP_SPCR1_RRDY
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR1_RRDY_SHIFT		(0x0001u)
#define _MCBSP_SPCR1_RRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR1_RRDY_SHIFT)
#define _MCBSP_SPCR1_RRDY_MASK       	(_MCBSP_SPCR1_RRDY_MK(0x0001u))
#define _MCBSP_SPCR1_RRDY_CLR             (~(_MCBSP_SPCR1_RRDY_MASK))

/*==========================================================================*\
* (RW) _MCBSP_SPCR1_RRST
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR1_RRST_SHIFT		(0x0000u)
#define _MCBSP_SPCR1_RRST_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR1_RRST_SHIFT)
#define _MCBSP_SPCR1_RRST_MASK       	(_MCBSP_SPCR1_RRST_MK(0x0001u))
#define _MCBSP_SPCR1_RRST_CLR        	(~(_MCBSP_SPCR1_RRST_MK(0x0001u)))

/*==========================================================================*\
* _MCBSP_SPCR1		- Serial Port Control Register 1
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR1_CFG(RegAddr,dlb,rjust,clkstp,dxena,abis,rintm,rsyncerr, \
				rrst) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_SPCR1_DLB_MK(dlb) 		|	\
				_MCBSP_SPCR1_RJUST_MK(rjust) 		|	\
				_MCBSP_SPCR1_CLKSTP_MK(clkstp)	|	\
				_MCBSP_SPCR1_DXENA_MK(dxena) 		|	\
				_MCBSP_SPCR1_ABIS_MK(abis) 		|	\
				_MCBSP_SPCR1_RINTM_MK(rintm) 		|	\
				_MCBSP_SPCR1_RSYNCERR_MK(rsyncerr) 	|	\
				_MCBSP_SPCR1_RRST_MK(rrst) 			\
             ))


/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================*\
* _MCBSP_SPCR2   - Serial Port Control Register 2
*
* Fields:
*  (RW) _MCBSP_SPCR2_FREE
*  (RW) _MCBSP_SPCR2_SOFT
*  (RW) _MCBSP_SPCR2_FRST
*  (RW) _MCBSP_SPCR2_GRST
*  (RW) _MCBSP_SPCR2_XINTM
*  (RW) _MCBSP_SPCR2_XSYNCERR
*  (R)  _MCBSP_SPCR2_XEMPTY
*  (R)  _MCBSP_SPCR2_XRDY
*  (RW) _MCBSP_SPCR2_XRST
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_SPCR2_FREE
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR2_FREE_SHIFT		(0x0009u)
#define _MCBSP_SPCR2_FREE_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR2_FREE_SHIFT)
#define _MCBSP_SPCR2_FREE_MASK       	(_MCBSP_SPCR2_FREE_MK(0x0001u))
#define _MCBSP_SPCR2_FREE_CLR        	(~(_MCBSP_SPCR2_FREE_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_SPCR2_SOFT
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR2_SOFT_SHIFT		(0x0008u)
#define _MCBSP_SPCR2_SOFT_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR2_SOFT_SHIFT)
#define _MCBSP_SPCR2_SOFT_MASK       	(_MCBSP_SPCR2_SOFT_MK(0x0001u))
#define _MCBSP_SPCR2_SOFT_CLR        	(~(_MCBSP_SPCR2_SOFT_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_SPCR2_FRST
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR2_FRST_SHIFT		(0x0007u)
#define _MCBSP_SPCR2_FRST_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR2_FRST_SHIFT)
#define _MCBSP_SPCR2_FRST_MASK       	(_MCBSP_SPCR2_FRST_MK(0x0001u))
#define _MCBSP_SPCR2_FRST_CLR        	(~(_MCBSP_SPCR2_FRST_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_SPCR2_GRST
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR2_GRST_SHIFT		(0x0006u)
#define _MCBSP_SPCR2_GRST_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR2_GRST_SHIFT)
#define _MCBSP_SPCR2_GRST_MASK       	(_MCBSP_SPCR2_GRST_MK(0x0001u))
#define _MCBSP_SPCR2_GRST_CLR        	(~(_MCBSP_SPCR2_GRST_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_SPCR2_XINTM
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR2_XINTM_SHIFT		(0x0004u)
#define _MCBSP_SPCR2_XINTM_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_SPCR2_XINTM_SHIFT)
#define _MCBSP_SPCR2_XINTM_MASK       	(_MCBSP_SPCR2_XINTM_MK(0x0003u))
#define _MCBSP_SPCR2_XINTM_CLR        	(~(_MCBSP_SPCR2_XINTM_MK(0x0003u)))

/*==========================================================================*\
* (RW) _MCBSP_SPCR2_XSYNCERR
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR2_XSYNCERR_SHIFT		(0x0003u)
#define _MCBSP_SPCR2_XSYNCERR_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR2_XSYNCERR_SHIFT)
#define _MCBSP_SPCR2_XSYNCERR_MASK       	(_MCBSP_SPCR2_XSYNCERR_MK(0x0001u))
#define _MCBSP_SPCR2_XSYNCERR_CLR        	(~(_MCBSP_SPCR2_XSYNCERR_MK(0x0001u)))

/*==========================================================================*\
* (R) _MCBSP_SPCR2_XEMPTY
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR2_XEMPTY_SHIFT		(0x0002u)
#define _MCBSP_SPCR2_XEMPTY_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR2_XEMPTY_SHIFT)
#define _MCBSP_SPCR2_XEMPTY_MASK       	(_MCBSP_SPCR2_XEMPTY_MK(0x0001u))
#define _MCBSP_SPCR2_XEMPTY_CLR           (~(_MCBSP_SPCR2_XEMPTY_MASK))

/*==========================================================================*\
* (R) _MCBSP_SPCR2_XRDY
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR2_XRDY_SHIFT		(0x0001u)
#define _MCBSP_SPCR2_XRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR2_XRDY_SHIFT)
#define _MCBSP_SPCR2_XRDY_MASK       	(_MCBSP_SPCR2_XRDY_MK(0x0001u))
#define _MCBSP_SPCR2_XRDY_CLR        	(~(_MCBSP_SPCR2_XRDY_MASK))

/*==========================================================================*\
* (RW) _MCBSP_SPCR2_XRST
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR2_XRST_SHIFT		(0x0000u)
#define _MCBSP_SPCR2_XRST_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SPCR2_XRST_SHIFT)
#define _MCBSP_SPCR2_XRST_MASK       	(_MCBSP_SPCR2_XRST_MK(0x0001u))
#define _MCBSP_SPCR2_XRST_CLR        	(~(_MCBSP_SPCR2_XRST_MK(0x0001u)))

/*==========================================================================*\
* _MCBSP_SPCR2		- Serial Port Control Register 2
\*--------------------------------------------------------------------------*/
#define _MCBSP_SPCR2_CFG(RegAddr,free,soft,frst,grst,xintm,xsyncerr,xrst) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_SPCR2_FREE_MK(free) 		|	\
				_MCBSP_SPCR2_SOFT_MK(soft) 		|	\
				_MCBSP_SPCR2_FRST_MK(frst)		|	\
				_MCBSP_SPCR2_GRST_MK(grst) 		|	\
				_MCBSP_SPCR2_XINTM_MK(xintm) 		|	\
				_MCBSP_SPCR2_XSYNCERR_MK(xsyncerr) 	|	\
				_MCBSP_SPCR2_XRST_MK(xrst) 			\
             ))


/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================/
* _MCBSP_PCR   - Pin Control Register
*
* Fields:
*  (RW) _MCBSP_PCR_SCLKME
*  (R)  _MCBSP_PCR_CLKSSTAT
*  (RW) _MCBSP_PCR_DXSTAT
*  (R)  _MCBSP_PCR_DRSTAT
*  (RW) _MCBSP_PCR_FSXP
*  (RW) _MCBSP_PCR_FSRP
*  (RW) _MCBSP_PCR_CLKXP
*  (RW) _MCBSP_PCR_CLKRP
*  (RW) _MCBSP_PCR_IDLEEN
*  (RW) _MCBSP_PCR_XIOEN
*  (RW) _MCBSP_PCR_RIOEN
*  (RW) _MCBSP_PCR_FSXM
*  (RW) _MCBSP_PCR_FSRM
*  (RW) _MCBSP_PCR_CLKXM
*  (RW) _MCBSP_PCR_CLKRM
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_PCR_SCLKME
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_SCLKME_SHIFT		(0x0007u)
#define _MCBSP_PCR_SCLKME_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_SCLKME_SHIFT)
#define _MCBSP_PCR_SCLKME_MASK       	(_MCBSP_PCR_SCLKME_MK(0x0001u))
#define _MCBSP_PCR_SCLKME_CLR        	(~(_MCBSP_PCR_SCLKME_MK(0x0001u)))

/*==========================================================================*\
* (R)  _MCBSP_PCR_CLKSSTAT
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_CLKSSTAT_SHIFT		(0x0006u)
#define _MCBSP_PCR_CLKSSTAT_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_CLKSSTAT_SHIFT)
#define _MCBSP_PCR_CLKSSTAT_MASK       	(_MCBSP_PCR_CLKSSTAT_MK(0x0001u))
#define _MCBSP_PCR_CLKSSTAT_CLR       	(~(_MCBSP_PCR_CLKSSTAT_MASK))

/*==========================================================================*\
* (RW) _MCBSP_PCR_DXSTAT
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_DXSTAT_SHIFT		(0x0005u)
#define _MCBSP_PCR_DXSTAT_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_DXSTAT_SHIFT)
#define _MCBSP_PCR_DXSTAT_MASK       	(_MCBSP_PCR_DXSTAT_MK(0x0001u))
#define _MCBSP_PCR_DXSTAT_CLR        	(~(_MCBSP_PCR_DXSTAT_MK(0x0001u)))

/*==========================================================================*\
* (R)  _MCBSP_PCR_DRSTAT
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_DRSTAT_SHIFT		(0x0004u)
#define _MCBSP_PCR_DRSTAT_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_DRSTAT_SHIFT)
#define _MCBSP_PCR_DRSTAT_MASK       	(_MCBSP_PCR_DRSTAT_MK(0x0001u))
#define _MCBSP_PCR_DRSTAT_CLR       	(~(_MCBSP_PCR_DRSTAT_MASK))

/*==========================================================================*\
* (RW) _MCBSP_PCR_FSXP
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_FSXP_SHIFT		(0x0003u)
#define _MCBSP_PCR_FSXP_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_FSXP_SHIFT)
#define _MCBSP_PCR_FSXP_MASK       	(_MCBSP_PCR_FSXP_MK(0x0001u))
#define _MCBSP_PCR_FSXP_CLR        	(~(_MCBSP_PCR_FSXP_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_PCR_FSRP
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_FSRP_SHIFT		(0x0002u)
#define _MCBSP_PCR_FSRP_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_FSRP_SHIFT)
#define _MCBSP_PCR_FSRP_MASK       	(_MCBSP_PCR_FSRP_MK(0x0001u))
#define _MCBSP_PCR_FSRP_CLR        	(~(_MCBSP_PCR_FSRP_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_PCR_CLKXP
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_CLKXP_SHIFT		(0x0001u)
#define _MCBSP_PCR_CLKXP_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_CLKXP_SHIFT)
#define _MCBSP_PCR_CLKXP_MASK       	(_MCBSP_PCR_CLKXP_MK(0x0001u))
#define _MCBSP_PCR_CLKXP_CLR        	(~(_MCBSP_PCR_CLKXP_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_PCR_CLKRP
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_CLKRP_SHIFT		(0x0000u)
#define _MCBSP_PCR_CLKRP_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_CLKRP_SHIFT)
#define _MCBSP_PCR_CLKRP_MASK       	(_MCBSP_PCR_CLKRP_MK(0x0001u))
#define _MCBSP_PCR_CLKRP_CLR        	(~(_MCBSP_PCR_CLKRP_MK(0x0001u)))

#if (!CHIP_5502)

/*==========================================================================*\
* (RW) _MCBSP_PCR_IDLEEN
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_IDLEEN_SHIFT		(0x000Eu)
#define _MCBSP_PCR_IDLEEN_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_IDLEEN_SHIFT)
#define _MCBSP_PCR_IDLEEN_MASK       	(_MCBSP_PCR_IDLEEN_MK(0x0001u))
#define _MCBSP_PCR_IDLEEN_CLR        	(~(_MCBSP_PCR_IDLEEN_MK(0x0001u)))

#endif

/*==========================================================================*\
* (RW) _MCBSP_PCR_XIOEN
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_XIOEN_SHIFT		(0x000Du)
#define _MCBSP_PCR_XIOEN_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_XIOEN_SHIFT)
#define _MCBSP_PCR_XIOEN_MASK       	(_MCBSP_PCR_XIOEN_MK(0x0001u))
#define _MCBSP_PCR_XIOEN_CLR        	(~(_MCBSP_PCR_XIOEN_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_PCR_RIOEN
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_RIOEN_SHIFT		(0x000Cu)
#define _MCBSP_PCR_RIOEN_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_RIOEN_SHIFT)
#define _MCBSP_PCR_RIOEN_MASK       	(_MCBSP_PCR_RIOEN_MK(0x0001u))
#define _MCBSP_PCR_RIOEN_CLR        	(~(_MCBSP_PCR_RIOEN_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_PCR_FSXM
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_FSXM_SHIFT		(0x000Bu)
#define _MCBSP_PCR_FSXM_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_FSXM_SHIFT)
#define _MCBSP_PCR_FSXM_MASK       	(_MCBSP_PCR_FSXM_MK(0x0001u))
#define _MCBSP_PCR_FSXM_CLR        	(~(_MCBSP_PCR_FSXM_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_PCR_FSRM
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_FSRM_SHIFT		(0x000Au)
#define _MCBSP_PCR_FSRM_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_FSRM_SHIFT)
#define _MCBSP_PCR_FSRM_MASK       	(_MCBSP_PCR_FSRM_MK(0x0001u))
#define _MCBSP_PCR_FSRM_CLR        	(~(_MCBSP_PCR_FSRM_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_PCR_CLKXM
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_CLKXM_SHIFT		(0x0009u)
#define _MCBSP_PCR_CLKXM_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_CLKXM_SHIFT)
#define _MCBSP_PCR_CLKXM_MASK       	(_MCBSP_PCR_CLKXM_MK(0x0001u))
#define _MCBSP_PCR_CLKXM_CLR        	(~(_MCBSP_PCR_CLKXM_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_PCR_CLKRM
\*--------------------------------------------------------------------------*/
#define _MCBSP_PCR_CLKRM_SHIFT		(0x0008u)
#define _MCBSP_PCR_CLKRM_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_PCR_CLKRM_SHIFT)
#define _MCBSP_PCR_CLKRM_MASK       	(_MCBSP_PCR_CLKRM_MK(0x0001u))
#define _MCBSP_PCR_CLKRM_CLR        	(~(_MCBSP_PCR_CLKRM_MK(0x0001u)))

/*==========================================================================*\
* _MCBSP_PCR		- Pin Control Register
\*--------------------------------------------------------------------------*/
#if(CHIP_5502)

#define _MCBSP_PCR_CFG(RegAddr,xioen,rioen,fsxm,fsrm,clkxm,clkrm,\
						sclkme,dxstat,fsxp,fsrp,clkxp,clkrp) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_PCR_SCLKME_MK(sclkme) 		|	\
				_MCBSP_PCR_DXSTAT_MK(dxstat) 		|	\
				_MCBSP_PCR_FSXP_MK(fsxp) 		|	\
				_MCBSP_PCR_FSRP_MK(fsrp) 		|	\
				_MCBSP_PCR_CLKXP_MK(clkxp) 		|	\
				_MCBSP_PCR_CLKRP_MK(clkrp) 		|	\
				_MCBSP_PCR_XIOEN_MK(xioen) 		|	\
				_MCBSP_PCR_RIOEN_MK(rioen) 		|	\
				_MCBSP_PCR_FSXM_MK(fsxm) 		|	\
				_MCBSP_PCR_FSRM_MK(fsrm) 		|	\
				_MCBSP_PCR_CLKXM_MK(clkxm) 		|	\
				_MCBSP_PCR_CLKRM_MK(clkrm) 			\
             ))

#else

#define _MCBSP_PCR_CFG(RegAddr,idleen,xioen,rioen,fsxm,fsrm,clkxm,clkrm,\
						sclkme,dxstat,fsxp,fsrp,clkxp,clkrp) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_PCR_SCLKME_MK(sclkme) 		|	\
				_MCBSP_PCR_DXSTAT_MK(dxstat) 		|	\
				_MCBSP_PCR_FSXP_MK(fsxp) 		|	\
				_MCBSP_PCR_FSRP_MK(fsrp) 		|	\
				_MCBSP_PCR_CLKXP_MK(clkxp) 		|	\
				_MCBSP_PCR_CLKRP_MK(clkrp) 		|	\
				_MCBSP_PCR_IDLEEN_MK(idleen) 		|	\
				_MCBSP_PCR_XIOEN_MK(xioen) 		|	\
				_MCBSP_PCR_RIOEN_MK(rioen) 		|	\
				_MCBSP_PCR_FSXM_MK(fsxm) 		|	\
				_MCBSP_PCR_FSRM_MK(fsrm) 		|	\
				_MCBSP_PCR_CLKXM_MK(clkxm) 		|	\
				_MCBSP_PCR_CLKRM_MK(clkrm) 			\
             ))

#endif

/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================*\
* _MCBSP_RCR1   - Receive Control Register 2
*
* Fields:
*  (RW) _MCBSP_RCR1_RFRLEN1
*  (RW) _MCBSP_RCR1_RWDLEN1
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_RCR1_RFRLEN1
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCR1_RFRLEN1_SHIFT		(0x0008u)
#define _MCBSP_RCR1_RFRLEN1_MK(n)		(((Uint16)(n) & 0x007Fu) << _MCBSP_RCR1_RFRLEN1_SHIFT)
#define _MCBSP_RCR1_RFRLEN1_MASK       	(_MCBSP_RCR1_RFRLEN1_MK(0x007Fu))
#define _MCBSP_RCR1_RFRLEN1_CLR        	(~(_MCBSP_RCR1_RFRLEN1_MK(0x007Fu)))

/*==========================================================================*\
* (RW) _MCBSP_RCR1_RWDLEN1
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCR1_RWDLEN1_SHIFT		(0x0005u)
#define _MCBSP_RCR1_RWDLEN1_MK(n)		(((Uint16)(n) & 0x0007u) << _MCBSP_RCR1_RWDLEN1_SHIFT)
#define _MCBSP_RCR1_RWDLEN1_MASK       	(_MCBSP_RCR1_RWDLEN1_MK(0x0007u))
#define _MCBSP_RCR1_RWDLEN1_CLR        	(~(_MCBSP_RCR1_RWDLEN1_MK(0x0007u)))

/*==========================================================================*\
* _MCBSP_RCR1		- Receive Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCR1_CFG(RegAddr,rfrlen1,rwdlen1) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_RCR1_RFRLEN1_MK(rfrlen1) 		|	\
				_MCBSP_RCR1_RWDLEN1_MK(rwdlen1) 			\
             ))

/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================*\
* _MCBSP_RCR2   - Receive Control Register 2
*
* Fields:
*  (RW) _MCBSP_RCR2_RPHASE
*  (RW) _MCBSP_RCR2_RFRLEN2
*  (RW) _MCBSP_RCR2_RWDLEN2
*  (RW) _MCBSP_RCR2_RCOMPAND
*  (RW) _MCBSP_RCR2_RFIG
*  (RW) _MCBSP_RCR2_RDATDLY
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_RCR2_RPHASE
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCR2_RPHASE_SHIFT		(0x000Fu)
#define _MCBSP_RCR2_RPHASE_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCR2_RPHASE_SHIFT)
#define _MCBSP_RCR2_RPHASE_MASK       	(_MCBSP_RCR2_RPHASE_MK(0x0001u))
#define _MCBSP_RCR2_RPHASE_CLR        	(~(_MCBSP_RCR2_RPHASE_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCR2_RFRLEN2
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCR2_RFRLEN2_SHIFT		(0x0008u)
#define _MCBSP_RCR2_RFRLEN2_MK(n)		(((Uint16)(n) & 0x007Fu) << _MCBSP_RCR2_RFRLEN2_SHIFT)
#define _MCBSP_RCR2_RFRLEN2_MASK       	(_MCBSP_RCR2_RFRLEN2_MK(0x007Fu))
#define _MCBSP_RCR2_RFRLEN2_CLR        	(~(_MCBSP_RCR2_RFRLEN2_MK(0x007Fu)))

/*==========================================================================*\
* (RW) _MCBSP_RCR2_RWDLEN2
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCR2_RWDLEN2_SHIFT		(0x0005u)
#define _MCBSP_RCR2_RWDLEN2_MK(n)		(((Uint16)(n) & 0x0007u) << _MCBSP_RCR2_RWDLEN2_SHIFT)
#define _MCBSP_RCR2_RWDLEN2_MASK       	(_MCBSP_RCR2_RWDLEN2_MK(0x0007u))
#define _MCBSP_RCR2_RWDLEN2_CLR        	(~(_MCBSP_RCR2_RWDLEN2_MK(0x0007u)))

/*==========================================================================*\
* (RW) _MCBSP_RCR2_RCOMPAND
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCR2_RCOMPAND_SHIFT		(0x0003u)
#define _MCBSP_RCR2_RCOMPAND_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_RCR2_RCOMPAND_SHIFT)
#define _MCBSP_RCR2_RCOMPAND_MASK       	(_MCBSP_RCR2_RCOMPAND_MK(0x0003u))
#define _MCBSP_RCR2_RCOMPAND_CLR        	(~(_MCBSP_RCR2_RCOMPAND_MK(0x0003u)))

/*==========================================================================*\
* (RW) _MCBSP_RCR2_RFIG
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCR2_RFIG_SHIFT		(0x0002u)
#define _MCBSP_RCR2_RFIG_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCR2_RFIG_SHIFT)
#define _MCBSP_RCR2_RFIG_MASK       	(_MCBSP_RCR2_RFIG_MK(0x0001u))
#define _MCBSP_RCR2_RFIG_CLR        	(~(_MCBSP_RCR2_RFIG_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCR2_RDATDLY
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCR2_RDATDLY_SHIFT		(0x0000u)
#define _MCBSP_RCR2_RDATDLY_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_RCR2_RDATDLY_SHIFT)
#define _MCBSP_RCR2_RDATDLY_MASK       	(_MCBSP_RCR2_RDATDLY_MK(0x0003u))
#define _MCBSP_RCR2_RDATDLY_CLR        	(~(_MCBSP_RCR2_RDATDLY_MK(0x0003u)))

/*==========================================================================*\
* _MCBSP_RCR2		- Receive Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCR2_CFG(RegAddr,rphase,rfrlen2,rwdlen2,rcompand,rfig,rdatdly) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_RCR2_RPHASE_MK(rphase)	 		|	\
				_MCBSP_RCR2_RFRLEN2_MK(rfrlen2) 		|	\
				_MCBSP_RCR2_RWDLEN2_MK(rwdlen2) 		|	\
				_MCBSP_RCR2_RCOMPAND_MK(rcompand) 		|	\
				_MCBSP_RCR2_RFIG_MK(rfig) 			|	\
				_MCBSP_RCR2_RDATDLY_MK(rdatdly) 			\
             ))


/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================*\
* _MCBSP_XCR1   - Transmit Control Register 1
*
* Fields:
*  (RW) _MCBSP_XCR1_XFRLEN1
*  (RW) _MCBSP_XCR1_XWDLEN1
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_XCR1_XFRLEN1
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCR1_XFRLEN1_SHIFT		(0x0008u)
#define _MCBSP_XCR1_XFRLEN1_MK(n)		(((Uint16)(n) & 0x007Fu) << _MCBSP_XCR1_XFRLEN1_SHIFT)
#define _MCBSP_XCR1_XFRLEN1_MASK       	(_MCBSP_XCR1_XFRLEN1_MK(0x007Fu))
#define _MCBSP_XCR1_XFRLEN1_CLR        	(~(_MCBSP_XCR1_XFRLEN1_MK(0x007Fu)))

/*==========================================================================*\
* (RW) _MCBSP_XCR1_XWDLEN1
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCR1_XWDLEN1_SHIFT		(0x0005u)
#define _MCBSP_XCR1_XWDLEN1_MK(n)		(((Uint16)(n) & 0x0007u) << _MCBSP_XCR1_XWDLEN1_SHIFT)
#define _MCBSP_XCR1_XWDLEN1_MASK       	(_MCBSP_XCR1_XWDLEN1_MK(0x0007u))
#define _MCBSP_XCR1_XWDLEN1_CLR        	(~(_MCBSP_XCR1_XWDLEN1_MK(0x0007u)))

/*==========================================================================*\
* _MCBSP_XCR1	- Transmit Control Register 1
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCR1_CFG(RegAddr,xfrlen1,xwdlen1) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_XCR1_XFRLEN1_MK(xfrlen1)	|	\
				_MCBSP_XCR1_XWDLEN1_MK(xwdlen1)		\
             ))


/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================*\
* _MCBSP_XCR2   - Transmit Control Register 2
*
* Fields:
*  (RW) _MCBSP_XCR2_XPHASE
*  (RW) _MCBSP_XCR2_XFRLEN2
*  (RW) _MCBSP_XCR2_XWDLEN2
*  (RW) _MCBSP_XCR2_XCOMPAND
*  (RW) _MCBSP_XCR2_XFIG
*  (RW) _MCBSP_XCR2_XDATDLY
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_XCR2_XPHASE
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCR2_XPHASE_SHIFT		(0x000Fu)
#define _MCBSP_XCR2_XPHASE_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCR2_XPHASE_SHIFT)
#define _MCBSP_XCR2_XPHASE_MASK       	(_MCBSP_XCR2_XPHASE_MK(0x0001u))
#define _MCBSP_XCR2_XPHASE_CLR        	(~(_MCBSP_XCR2_XPHASE_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCR2_XFRLEN2
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCR2_XFRLEN2_SHIFT		(0x0008u)
#define _MCBSP_XCR2_XFRLEN2_MK(n)		(((Uint16)(n) & 0x007Fu) << _MCBSP_XCR2_XFRLEN2_SHIFT)
#define _MCBSP_XCR2_XFRLEN2_MASK       	(_MCBSP_XCR2_XFRLEN2_MK(0x007Fu))
#define _MCBSP_XCR2_XFRLEN2_CLR        	(~(_MCBSP_XCR2_XFRLEN2_MK(0x007Fu)))

/*==========================================================================*\
* (RW) _MCBSP_XCR2_XWDLEN2
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCR2_XWDLEN2_SHIFT		(0x0005u)
#define _MCBSP_XCR2_XWDLEN2_MK(n)		(((Uint16)(n) & 0x0007u) << _MCBSP_XCR2_XWDLEN2_SHIFT)
#define _MCBSP_XCR2_XWDLEN2_MASK       	(_MCBSP_XCR2_XWDLEN2_MK(0x0007u))
#define _MCBSP_XCR2_XWDLEN2_CLR        	(~(_MCBSP_XCR2_XWDLEN2_MK(0x0007u)))

/*==========================================================================*\
* (RW) _MCBSP_XCR2_XCOMPAND
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCR2_XCOMPAND_SHIFT		(0x0003u)
#define _MCBSP_XCR2_XCOMPAND_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_XCR2_XCOMPAND_SHIFT)
#define _MCBSP_XCR2_XCOMPAND_MASK       	(_MCBSP_XCR2_XCOMPAND_MK(0x0003u))
#define _MCBSP_XCR2_XCOMPAND_CLR        	(~(_MCBSP_XCR2_XCOMPAND_MK(0x0003u)))

/*==========================================================================*\
* (RW) _MCBSP_XCR2_XFIG
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCR2_XFIG_SHIFT		(0x0002u)
#define _MCBSP_XCR2_XFIG_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCR2_XFIG_SHIFT)
#define _MCBSP_XCR2_XFIG_MASK       	(_MCBSP_XCR2_XFIG_MK(0x0001u))
#define _MCBSP_XCR2_XFIG_CLR        	(~(_MCBSP_XCR2_XFIG_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCR2_XDATDLY
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCR2_XDATDLY_SHIFT		(0x0000u)
#define _MCBSP_XCR2_XDATDLY_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_XCR2_XDATDLY_SHIFT)
#define _MCBSP_XCR2_XDATDLY_MASK       	(_MCBSP_XCR2_XDATDLY_MK(0x0003u))
#define _MCBSP_XCR2_XDATDLY_CLR        	(~(_MCBSP_XCR2_XDATDLY_MK(0x0003u)))

/*==========================================================================*\
* _MCBSP_XCR2	- Transmit Control Register 2
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCR2_CFG(RegAddr,xphase,xfrlen2,xwdlen2,xcompand,xfig,xdatdly) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_XCR2_XPHASE_MK(xphase)	|	\
				_MCBSP_XCR2_XFRLEN2_MK(xfrlen2)	|	\
				_MCBSP_XCR2_XWDLEN2_MK(xwdlen2)	|	\
				_MCBSP_XCR2_XCOMPAND_MK(xcompand)	|	\
				_MCBSP_XCR2_XFIG_MK(xfig)		|	\
				_MCBSP_XCR2_XDATDLY_MK(xdatdly)		\
             ))


/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================*\
* _MCBSP_SRGR1 -  Sample Rate Generator Register 1
*
* Fields:
*  (RW) _MCBSP_SRGR1_FWID
*  (RW) _MCBSP_SRGR1_CLKGDV
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_SRGR1_FWID
\*--------------------------------------------------------------------------*/
#define _MCBSP_SRGR1_FWID_SHIFT		(0x0008u)
#define _MCBSP_SRGR1_FWID_MK(n)		(((Uint16)(n) & 0x00FFu) << _MCBSP_SRGR1_FWID_SHIFT)
#define _MCBSP_SRGR1_FWID_MASK       	(_MCBSP_SRGR1_FWID_MK(0x00FFu))
#define _MCBSP_SRGR1_FWID_CLR        	(~(_MCBSP_SRGR1_FWID_MK(0x00FFu)))

/*==========================================================================*\
* (RW) _MCBSP_SRGR1_CLKGDV
\*--------------------------------------------------------------------------*/
#define _MCBSP_SRGR1_CLKGDV_SHIFT		(0x0000u)
#define _MCBSP_SRGR1_CLKGDV_MK(n)		(((Uint16)(n) & 0x00FFu) << _MCBSP_SRGR1_CLKGDV_SHIFT)
#define _MCBSP_SRGR1_CLKGDV_MASK       	(_MCBSP_SRGR1_CLKGDV_MK(0x00FFu))
#define _MCBSP_SRGR1_CLKGDV_CLR        	(~(_MCBSP_SRGR1_CLKGDV_MK(0x00FFu)))

/*==========================================================================*\
* _MCBSP_SRGR1	- Sample Rate Generator Register 1
\*--------------------------------------------------------------------------*/
#define _MCBSP_SRGR1_CFG(RegAddr,fwid,clkgdv) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_SRGR1_FWID_MK(fwid)		|	\
				_MCBSP_SRGR1_CLKGDV_MK(clkgdv)		\
             ))

/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================*\
* _MCBSP_SRGR2 -  Sample Rate Generator Register 2
*
* Fields:
*  (RW) _MCBSP_SRGR2_GSYNC
*  (RW) _MCBSP_SRGR2_CLKSP
*  (RW) _MCBSP_SRGR2_CLKSM
*  (RW) _MCBSP_SRGR2_FSGM
*  (RW) _MCBSP_SRGR2_FPER
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_SRGR2_GSYNC
\*--------------------------------------------------------------------------*/
#define _MCBSP_SRGR2_GSYNC_SHIFT		(0x000Fu)
#define _MCBSP_SRGR2_GSYNC_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SRGR2_GSYNC_SHIFT)
#define _MCBSP_SRGR2_GSYNC_MASK       	(_MCBSP_SRGR2_GSYNC_MK(0x0001u))
#define _MCBSP_SRGR2_GSYNC_CLR        	(~(_MCBSP_SRGR2_GSYNC_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_SRGR2_CLKSP
\*--------------------------------------------------------------------------*/
#define _MCBSP_SRGR2_CLKSP_SHIFT		(0x000Eu)
#define _MCBSP_SRGR2_CLKSP_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SRGR2_CLKSP_SHIFT)
#define _MCBSP_SRGR2_CLKSP_MASK       	(_MCBSP_SRGR2_CLKSP_MK(0x0001u))
#define _MCBSP_SRGR2_CLKSP_CLR        	(~(_MCBSP_SRGR2_CLKSP_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_SRGR2_CLKSM
\*--------------------------------------------------------------------------*/
#define _MCBSP_SRGR2_CLKSM_SHIFT		(0x000Du)
#define _MCBSP_SRGR2_CLKSM_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SRGR2_CLKSM_SHIFT)
#define _MCBSP_SRGR2_CLKSM_MASK       	(_MCBSP_SRGR2_CLKSM_MK(0x0001u))
#define _MCBSP_SRGR2_CLKSM_CLR        	(~(_MCBSP_SRGR2_CLKSM_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_SRGR2_FSGM
\*--------------------------------------------------------------------------*/
#define _MCBSP_SRGR2_FSGM_SHIFT		(0x000Cu)
#define _MCBSP_SRGR2_FSGM_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_SRGR2_FSGM_SHIFT)
#define _MCBSP_SRGR2_FSGM_MASK       	(_MCBSP_SRGR2_FSGM_MK(0x0001u))
#define _MCBSP_SRGR2_FSGM_CLR        	(~(_MCBSP_SRGR2_FSGM_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_SRGR2_FPER
\*--------------------------------------------------------------------------*/
#define _MCBSP_SRGR2_FPER_SHIFT		(0x0000u)
#define _MCBSP_SRGR2_FPER_MK(n)		(((Uint16)(n) & 0x0FFFu) << _MCBSP_SRGR2_FPER_SHIFT)
#define _MCBSP_SRGR2_FPER_MASK       	(_MCBSP_SRGR2_FPER_MK(0x0FFFu))
#define _MCBSP_SRGR2_FPER_CLR        	(~(_MCBSP_SRGR2_FPER_MK(0x0FFFu)))

/*==========================================================================*\
* _MCBSP_SRGR2	- Sample Rate Generator Register 2
\*--------------------------------------------------------------------------*/
#define _MCBSP_SRGR2_CFG(RegAddr,gsync,clksp,clksm,fsgm,fper) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_SRGR2_GSYNC_MK(gsync)		|	\
				_MCBSP_SRGR2_CLKSP_MK(clksp)		|	\
				_MCBSP_SRGR2_CLKSM_MK(clksm)		|	\
				_MCBSP_SRGR2_FSGM_MK(fsgm)		|	\
				_MCBSP_SRGR2_FPER_MK(fper)			\
             ))

/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================*\
* _MCBSP_MCR1 -  Multi-channel Control Register 1
*
* Fields:
*  (RW) _MCBSP_MCR1_RMCME
*  (RW) _MCBSP_MCR1_RPBBLK
*  (RW) _MCBSP_MCR1_RPABLK
*  (R)  _MCBSP_MCR1_RCBLK
*  (RW) _MCBSP_MCR1_RMCM
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_MCR1_RMCME
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR1_RMCME_SHIFT		(0x0009u)
#define _MCBSP_MCR1_RMCME_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_MCR1_RMCME_SHIFT)
#define _MCBSP_MCR1_RMCME_MASK       	(_MCBSP_MCR1_RMCME_MK(0x0001u))
#define _MCBSP_MCR1_RMCME_CLR        	(~(_MCBSP_MCR1_RMCME_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_MCR1_RPBBLK
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR1_RPBBLK_SHIFT		(0x0007u)
#define _MCBSP_MCR1_RPBBLK_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_MCR1_RPBBLK_SHIFT)
#define _MCBSP_MCR1_RPBBLK_MASK       	(_MCBSP_MCR1_RPBBLK_MK(0x0003u))
#define _MCBSP_MCR1_RPBBLK_CLR        	(~(_MCBSP_MCR1_RPBBLK_MK(0x0003u)))

/*==========================================================================*\
* (RW) _MCBSP_MCR1_RPABLK
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR1_RPABLK_SHIFT		(0x0005u)
#define _MCBSP_MCR1_RPABLK_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_MCR1_RPABLK_SHIFT)
#define _MCBSP_MCR1_RPABLK_MASK       	(_MCBSP_MCR1_RPABLK_MK(0x0003u))
#define _MCBSP_MCR1_RPABLK_CLR        	(~(_MCBSP_MCR1_RPABLK_MK(0x0003u)))

/*==========================================================================*\
* (R) _MCBSP_MCR1_RCBLK
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR1_RCBLK_SHIFT		(0x0002u)
#define _MCBSP_MCR1_RCBLK_MK(n)		(((Uint16)(n) & 0x0007u) << _MCBSP_MCR1_RCBLK_SHIFT)
#define _MCBSP_MCR1_RCBLK_MASK       	(_MCBSP_MCR1_RCBLK_MK(0x0007u))
#define _MCBSP_MCR1_RCBLK_CLR       	(~(_MCBSP_MCR1_RCBLK_MASK))

/*==========================================================================*\
* (RW) _MCBSP_MCR1_RMCM
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR1_RMCM_SHIFT		(0x0000u)
#define _MCBSP_MCR1_RMCM_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_MCR1_RMCM_SHIFT)
#define _MCBSP_MCR1_RMCM_MASK       	(_MCBSP_MCR1_RMCM_MK(0x0001u))
#define _MCBSP_MCR1_RMCM_CLR        	(~(_MCBSP_MCR1_RMCM_MK(0x0001u)))

/*==========================================================================*\
* _MCBSP_MCR1	- Mutli-channel Control Register 1 Config
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR1_CFG(RegAddr,rmcme,rpbblk,rpablk,rmcm) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_MCR1_RMCME_MK(rmcme)		|	\
				_MCBSP_MCR1_RPBBLK_MK(rpbblk)		|	\
				_MCBSP_MCR1_RPABLK_MK(rpablk)		|	\
				_MCBSP_MCR1_RMCM_MK(rmcm)			\
             ))

/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================*\
* _MCBSP_MCR2 -  Multi-channel Control Register 2
*
* Fields:
*  (RW) _MCBSP_MCR2_XMCME
*  (RW) _MCBSP_MCR2_XPBBLK
*  (RW) _MCBSP_MCR2_XPABLK
*  (R)  _MCBSP_MCR2_XCBLK
*  (RW) _MCBSP_MCR2_XMCM
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_MCR2_XMCME
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR2_XMCME_SHIFT		(0x0009u)
#define _MCBSP_MCR2_XMCME_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_MCR2_XMCME_SHIFT)
#define _MCBSP_MCR2_XMCME_MASK       	(_MCBSP_MCR2_XMCME_MK(0x0001u))
#define _MCBSP_MCR2_XMCME_CLR        	(~(_MCBSP_MCR2_XMCME_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_MCR2_XPBBLK
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR2_XPBBLK_SHIFT		(0x0007u)
#define _MCBSP_MCR2_XPBBLK_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_MCR2_XPBBLK_SHIFT)
#define _MCBSP_MCR2_XPBBLK_MASK       	(_MCBSP_MCR2_XPBBLK_MK(0x0003u))
#define _MCBSP_MCR2_XPBBLK_CLR        	(~(_MCBSP_MCR2_XPBBLK_MK(0x0003u)))

/*==========================================================================*\
* (RW) _MCBSP_MCR2_XPABLK
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR2_XPABLK_SHIFT		(0x0005u)
#define _MCBSP_MCR2_XPABLK_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_MCR2_XPABLK_SHIFT)
#define _MCBSP_MCR2_XPABLK_MASK       	(_MCBSP_MCR2_XPABLK_MK(0x0003u))
#define _MCBSP_MCR2_XPABLK_CLR        	(~(_MCBSP_MCR2_XPABLK_MK(0x0003u)))

/*==========================================================================*\
* (RW) _MCBSP_MCR2_XCBLK
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR2_XCBLK_SHIFT		(0x0002u)
#define _MCBSP_MCR2_XCBLK_MK(n)		(((Uint16)(n) & 0x0007u) << _MCBSP_MCR2_XCBLK_SHIFT)
#define _MCBSP_MCR2_XCBLK_MASK       	(_MCBSP_MCR2_XCBLK_MK(0x0007u))
#define _MCBSP_MCR2_XCBLK_CLR        	(~(_MCBSP_MCR2_XCBLK_MK(0x0007u)))

/*==========================================================================*\
* (RW) _MCBSP_MCR2_XMCM
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR2_XMCM_SHIFT		(0x0000u)
#define _MCBSP_MCR2_XMCM_MK(n)		(((Uint16)(n) & 0x0003u) << _MCBSP_MCR2_XMCM_SHIFT)
#define _MCBSP_MCR2_XMCM_MASK       	(_MCBSP_MCR2_XMCM_MK(0x0003u))
#define _MCBSP_MCR2_XMCM_CLR        	(~(_MCBSP_MCR2_XMCM_MK(0x0003u)))

/*==========================================================================*\
* _MCBSP_MCR2	- Mutli-channel Control Register 2 Config
\*--------------------------------------------------------------------------*/
#define _MCBSP_MCR2_CFG(RegAddr,xmcme,xpbblk,xpablk,xmcm) \
	_PREG_SET(RegAddr,							\
    		(Uint16) (	_MCBSP_MCR2_XMCME_MK(xmcme)		|	\
				_MCBSP_MCR2_XPBBLK_MK(xpbblk)		|	\
				_MCBSP_MCR2_XPABLK_MK(xpablk)		|	\
				_MCBSP_MCR2_XMCM_MK(xmcm)			\
             ))

/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/*===========================================================================*\
* _MCBSP_XCER -  Transmit Channel Enable Registers
*
* Fields:
*  (RW) _MCBSP_XCER_xce15
*  (RW) _MCBSP_XCER_xce14
*  (RW) _MCBSP_XCER_xce13
*  (RW) _MCBSP_XCER_xce12
*  (RW) _MCBSP_XCER_xce11
*  (RW) _MCBSP_XCER_xce10
*  (RW) _MCBSP_XCER_xce9
*  (RW) _MCBSP_XCER_xce8
*  (RW) _MCBSP_XCER_xce7
*  (RW) _MCBSP_XCER_xce6
*  (RW) _MCBSP_XCER_XCE5
*  (RW) _MCBSP_XCER_XCE4
*  (RW) _MCBSP_XCER_XCE3
*  (RW) _MCBSP_XCER_XCE2
*  (RW) _MCBSP_XCER_XCE1
*  (RW) _MCBSP_XCER_XCE0
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE15
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE15_SHIFT		(0x000Fu)
#define _MCBSP_XCER_XCE15_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE15_SHIFT)
#define _MCBSP_XCER_XCE15_MASK       	(_MCBSP_XCER_XCE15_MK(0x0001u))
#define _MCBSP_XCER_XCE15_CLR        	(~(_MCBSP_XCER_XCE15_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE14
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE14_SHIFT		(0x000Eu)
#define _MCBSP_XCER_XCE14_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE14_SHIFT)
#define _MCBSP_XCER_XCE14_MASK       	(_MCBSP_XCER_XCE14_MK(0x0001u))
#define _MCBSP_XCER_XCE14_CLR        	(~(_MCBSP_XCER_XCE14_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE13
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE13_SHIFT		(0x000Du)
#define _MCBSP_XCER_XCE13_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE13_SHIFT)
#define _MCBSP_XCER_XCE13_MASK       	(_MCBSP_XCER_XCE13_MK(0x0001u))
#define _MCBSP_XCER_XCE13_CLR        	(~(_MCBSP_XCER_XCE13_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE12
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE12_SHIFT		(0x000Cu)
#define _MCBSP_XCER_XCE12_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE12_SHIFT)
#define _MCBSP_XCER_XCE12_MASK       	(_MCBSP_XCER_XCE12_MK(0x0001u))
#define _MCBSP_XCER_XCE12_CLR        	(~(_MCBSP_XCER_XCE12_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE11
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE11_SHIFT		(0x000Bu)
#define _MCBSP_XCER_XCE11_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE11_SHIFT)
#define _MCBSP_XCER_XCE11_MASK       	(_MCBSP_XCER_XCE11_MK(0x0001u))
#define _MCBSP_XCER_XCE11_CLR        	(~(_MCBSP_XCER_XCE11_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE10
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE10_SHIFT		(0x000Au)
#define _MCBSP_XCER_XCE10_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE10_SHIFT)
#define _MCBSP_XCER_XCE10_MASK       	(_MCBSP_XCER_XCE10_MK(0x0001u))
#define _MCBSP_XCER_XCE10_CLR        	(~(_MCBSP_XCER_XCE10_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE9
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE9_SHIFT		(0x0009u)
#define _MCBSP_XCER_XCE9_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE9_SHIFT)
#define _MCBSP_XCER_XCE9_MASK       	(_MCBSP_XCER_XCE9_MK(0x0001u))
#define _MCBSP_XCER_XCE9_CLR        	(~(_MCBSP_XCER_XCE9_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE8
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE8_SHIFT		(0x0008u)
#define _MCBSP_XCER_XCE8_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE8_SHIFT)
#define _MCBSP_XCER_XCE8_MASK       	(_MCBSP_XCER_XCE8_MK(0x0001u))
#define _MCBSP_XCER_XCE8_CLR        	(~(_MCBSP_XCER_XCE8_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE7
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE7_SHIFT		(0x0007u)
#define _MCBSP_XCER_XCE7_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE7_SHIFT)
#define _MCBSP_XCER_XCE7_MASK       	(_MCBSP_XCER_XCE7_MK(0x0001u))
#define _MCBSP_XCER_XCE7_CLR        	(~(_MCBSP_XCER_XCE7_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE6
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE6_SHIFT		(0x0006u)
#define _MCBSP_XCER_XCE6_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE6_SHIFT)
#define _MCBSP_XCER_XCE6_MASK       	(_MCBSP_XCER_XCE6_MK(0x0001u))
#define _MCBSP_XCER_XCE6_CLR        	(~(_MCBSP_XCER_XCE6_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE5
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE5_SHIFT		(0x0005u)
#define _MCBSP_XCER_XCE5_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE5_SHIFT)
#define _MCBSP_XCER_XCE5_MASK       	(_MCBSP_XCER_XCE5_MK(0x0001u))
#define _MCBSP_XCER_XCE5_CLR        	(~(_MCBSP_XCER_XCE5_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE4
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE4_SHIFT		(0x0004u)
#define _MCBSP_XCER_XCE4_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE4_SHIFT)
#define _MCBSP_XCER_XCE4_MASK       	(_MCBSP_XCER_XCE4_MK(0x0001u))
#define _MCBSP_XCER_XCE4_CLR        	(~(_MCBSP_XCER_XCE4_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE3
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE3_SHIFT		(0x0003u)
#define _MCBSP_XCER_XCE3_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE3_SHIFT)
#define _MCBSP_XCER_XCE3_MASK       	(_MCBSP_XCER_XCE3_MK(0x0001u))
#define _MCBSP_XCER_XCE3_CLR        	(~(_MCBSP_XCER_XCE3_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE2
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE2_SHIFT		(0x0002u)
#define _MCBSP_XCER_XCE2_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE2_SHIFT)
#define _MCBSP_XCER_XCE2_MASK       	(_MCBSP_XCER_XCE2_MK(0x0001u))
#define _MCBSP_XCER_XCE2_CLR        	(~(_MCBSP_XCER_XCE2_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE1
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE1_SHIFT		(0x0001u)
#define _MCBSP_XCER_XCE1_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE1_SHIFT)
#define _MCBSP_XCER_XCE1_MASK       	(_MCBSP_XCER_XCE1_MK(0x0001u))
#define _MCBSP_XCER_XCE1_CLR        	(~(_MCBSP_XCER_XCE1_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_XCER_XCE0
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_XCE0_SHIFT		(0x0000u)
#define _MCBSP_XCER_XCE0_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_XCER_XCE0_SHIFT)
#define _MCBSP_XCER_XCE0_MASK       	(_MCBSP_XCER_XCE0_MK(0x0001u))
#define _MCBSP_XCER_XCE0_CLR        	(~(_MCBSP_XCER_XCE0_MK(0x0001u)))

/*==========================================================================*\
*  _MCBSP_XCER  -  Transmit Channel Enable Config
\*--------------------------------------------------------------------------*/
#define _MCBSP_XCER_CFG(RegAddr,xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)  \
	_PREG_SET(RegAddr,							\
		(Uint16) (	_MCBSP_XCER_XCE15_MK(xcey15) 	|	\
				_MCBSP_XCER_XCE14_MK(xcey14) 	|	\
				_MCBSP_XCER_XCE13_MK(xcey13) 	|	\
				_MCBSP_XCER_XCE12_MK(xcey12) 	|	\
				_MCBSP_XCER_XCE11_MK(xcey11) 	|	\
				_MCBSP_XCER_XCE10_MK(xcey10) 	|	\
				_MCBSP_XCER_XCE9_MK(xcey9) 		|	\
				_MCBSP_XCER_XCE8_MK(xcey8) 		|	\
				_MCBSP_XCER_XCE7_MK(xcey7) 		|	\
				_MCBSP_XCER_XCE6_MK(xcey6) 		|	\
				_MCBSP_XCER_XCE5_MK(xcey5) 		|	\
				_MCBSP_XCER_XCE4_MK(xcey4) 		|	\
				_MCBSP_XCER_XCE3_MK(xcey3) 		|	\
				_MCBSP_XCER_XCE2_MK(xcey2) 		|	\
				_MCBSP_XCER_XCE1_MK(xcey1) 		|	\
				_MCBSP_XCER_XCE0_MK(xcey0) 			\
             ))


/* ////////////////////////////////////////////////////////////////////////// */
/* /////////////////////////////////////////////////////////////////////////// */
/* /////////////////////////////////////////////////////////////////////////// */
/* /////////////////////////////////////////////////////////////////////////// */
/* /////////////////////////////////////////////////////////////////////////// */
/*===========================================================================
* _MCBSP_RCER -  Receive Channel Enable Registers
*
* Fields:
*  (RW) _MCBSP_RCER_RCE15
*  (RW) _MCBSP_RCER_RCE14
*  (RW) _MCBSP_RCER_RCE13
*  (RW) _MCBSP_RCER_RCE12
*  (RW) _MCBSP_RCER_RCE11
*  (RW) _MCBSP_RCER_RCE10
*  (RW) _MCBSP_RCER_RCE9
*  (RW) _MCBSP_RCER_RCE8
*  (RW) _MCBSP_RCER_RCE7
*  (RW) _MCBSP_RCER_RCE6
*  (RW) _MCBSP_RCER_RCE5
*  (RW) _MCBSP_RCER_RCE4
*  (RW) _MCBSP_RCER_RCE3
*  (RW) _MCBSP_RCER_RCE2
*  (RW) _MCBSP_RCER_RCE1
*  (RW) _MCBSP_RCER_RCE0
\*==========================================================================*/

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE15
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE15_SHIFT		(0x000Fu)
#define _MCBSP_RCER_RCE15_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE15_SHIFT)
#define _MCBSP_RCER_RCE15_MASK       	(_MCBSP_RCER_RCE15_MK(0x0001u))
#define _MCBSP_RCER_RCE15_CLR        	(~(_MCBSP_RCER_RCE15_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE14
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE14_SHIFT		(0x000Eu)
#define _MCBSP_RCER_RCE14_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE14_SHIFT)
#define _MCBSP_RCER_RCE14_MASK       	(_MCBSP_RCER_RCE14_MK(0x0001u))
#define _MCBSP_RCER_RCE14_CLR        	(~(_MCBSP_RCER_RCE14_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE13
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE13_SHIFT		(0x000Du)
#define _MCBSP_RCER_RCE13_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE13_SHIFT)
#define _MCBSP_RCER_RCE13_MASK       	(_MCBSP_RCER_RCE13_MK(0x0001u))
#define _MCBSP_RCER_RCE13_CLR        	(~(_MCBSP_RCER_RCE13_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE12
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE12_SHIFT		(0x000Cu)
#define _MCBSP_RCER_RCE12_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE12_SHIFT)
#define _MCBSP_RCER_RCE12_MASK       	(_MCBSP_RCER_RCE12_MK(0x0001u))
#define _MCBSP_RCER_RCE12_CLR        	(~(_MCBSP_RCER_RCE12_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE11
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE11_SHIFT		(0x000Bu)
#define _MCBSP_RCER_RCE11_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE11_SHIFT)
#define _MCBSP_RCER_RCE11_MASK       	(_MCBSP_RCER_RCE11_MK(0x0001u))
#define _MCBSP_RCER_RCE11_CLR        	(~(_MCBSP_RCER_RCE11_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE10
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE10_SHIFT		(0x000Au)
#define _MCBSP_RCER_RCE10_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE10_SHIFT)
#define _MCBSP_RCER_RCE10_MASK       	(_MCBSP_RCER_RCE10_MK(0x0001u))
#define _MCBSP_RCER_RCE10_CLR        	(~(_MCBSP_RCER_RCE10_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE9
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE9_SHIFT		(0x0009u)
#define _MCBSP_RCER_RCE9_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE9_SHIFT)
#define _MCBSP_RCER_RCE9_MASK       	(_MCBSP_RCER_RCE9_MK(0x0001u))
#define _MCBSP_RCER_RCE9_CLR        	(~(_MCBSP_RCER_RCE9_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE8
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE8_SHIFT		(0x0008u)
#define _MCBSP_RCER_RCE8_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE8_SHIFT)
#define _MCBSP_RCER_RCE8_MASK       	(_MCBSP_RCER_RCE8_MK(0x0001u))
#define _MCBSP_RCER_RCE8_CLR        	(~(_MCBSP_RCER_RCE8_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE7
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE7_SHIFT		(0x0007u)
#define _MCBSP_RCER_RCE7_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE7_SHIFT)
#define _MCBSP_RCER_RCE7_MASK       	(_MCBSP_RCER_RCE7_MK(0x0001u))
#define _MCBSP_RCER_RCE7_CLR        	(~(_MCBSP_RCER_RCE7_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE6
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE6_SHIFT		(0x0006u)
#define _MCBSP_RCER_RCE6_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE6_SHIFT)
#define _MCBSP_RCER_RCE6_MASK       	(_MCBSP_RCER_RCE6_MK(0x0001u))
#define _MCBSP_RCER_RCE6_CLR        	(~(_MCBSP_RCER_RCE6_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE5
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE5_SHIFT		(0x0005u)
#define _MCBSP_RCER_RCE5_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE5_SHIFT)
#define _MCBSP_RCER_RCE5_MASK       	(_MCBSP_RCER_RCE5_MK(0x0001u))
#define _MCBSP_RCER_RCE5_CLR        	(~(_MCBSP_RCER_RCE5_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE4
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE4_SHIFT		(0x0004u)
#define _MCBSP_RCER_RCE4_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE4_SHIFT)
#define _MCBSP_RCER_RCE4_MASK       	(_MCBSP_RCER_RCE4_MK(0x0001u))
#define _MCBSP_RCER_RCE4_CLR        	(~(_MCBSP_RCER_RCE4_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE3
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE3_SHIFT		(0x0003u)
#define _MCBSP_RCER_RCE3_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE3_SHIFT)
#define _MCBSP_RCER_RCE3_MASK       	(_MCBSP_RCER_RCE3_MK(0x0001u))
#define _MCBSP_RCER_RCE3_CLR        	(~(_MCBSP_RCER_RCE3_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE2
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE2_SHIFT		(0x0002u)
#define _MCBSP_RCER_RCE2_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE2_SHIFT)
#define _MCBSP_RCER_RCE2_MASK       	(_MCBSP_RCER_RCE2_MK(0x0001u))
#define _MCBSP_RCER_RCE2_CLR        	(~(_MCBSP_RCER_RCE2_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE1
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE1_SHIFT		(0x0001u)
#define _MCBSP_RCER_RCE1_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE1_SHIFT)
#define _MCBSP_RCER_RCE1_MASK       	(_MCBSP_RCER_RCE1_MK(0x0001u))
#define _MCBSP_RCER_RCE1_CLR        	(~(_MCBSP_RCER_RCE1_MK(0x0001u)))

/*==========================================================================*\
* (RW) _MCBSP_RCER_RCE0
\*--------------------------------------------------------------------------*/
#define _MCBSP_RCER_RCE0_SHIFT		(0x0000u)
#define _MCBSP_RCER_RCE0_MK(n)		(((Uint16)(n) & 0x0001u) << _MCBSP_RCER_RCE0_SHIFT)
#define _MCBSP_RCER_RCE0_MASK       	(_MCBSP_RCER_RCE0_MK(0x0001u))
#define _MCBSP_RCER_RCE0_CLR        	(~(_MCBSP_RCER_RCE0_MK(0x0001u)))

/*==========================================================================*\
*  _MCBSP_RCER  -  Receive Channel Enable Config
\*--------------------------------------------------------------------------*/

#define MCBSP_RCER_CFG(RegAddr,rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)  \
	_PREG_SET(RegAddr,							\
		(Uint16) (	_MCBSP_RCER_RCE15_MK(rcey15) 	|	\
				_MCBSP_RCER_RCE14_MK(rcey14) 	|	\
				_MCBSP_RCER_RCE13_MK(rcey13) 	|	\
				_MCBSP_RCER_RCE12_MK(rcey12) 	|	\
				_MCBSP_RCER_RCE11_MK(rcey11) 	|	\
				_MCBSP_RCER_RCE10_MK(rcey10) 	|	\
				_MCBSP_RCER_RCE9_MK(rcey9) 		|	\
				_MCBSP_RCER_RCE8_MK(rcey8) 		|	\
				_MCBSP_RCER_RCE7_MK(rcey7) 		|	\
				_MCBSP_RCER_RCE6_MK(rcey6) 		|	\
				_MCBSP_RCER_RCE5_MK(rcey5) 		|	\
				_MCBSP_RCER_RCE4_MK(rcey4) 		|	\
				_MCBSP_RCER_RCE3_MK(rcey3) 		|	\
				_MCBSP_RCER_RCE2_MK(rcey2) 		|	\
				_MCBSP_RCER_RCE1_MK(rcey1) 		|	\
				_MCBSP_RCER_RCE0_MK(rcey0) 			\
             ))

#define MCBSP_RCERA_CFG(Port,rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)\
 MCBSP_RCER_CFG(_MCBSP_RCERA_ADDR(Port),rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)

#define MCBSP_RCERB_CFG(Port,rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)\
 MCBSP_RCER_CFG(_MCBSP_RCERB_ADDR(Port),rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)

#define MCBSP_RCERC_CFG(Port,rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)\
 MCBSP_RCER_CFG(_MCBSP_RCERC_ADDR(Port),rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)

#define MCBSP_RCERD_CFG(Port,rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)\
 MCBSP_RCER_CFG(_MCBSP_RCERD_ADDR(Port),rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)

#define MCBSP_RCERE_CFG(Port,rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)\
 MCBSP_RCER_CFG(_MCBSP_RCERE_ADDR(Port),rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)

#define MCBSP_RCERF_CFG(Port,rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)\
 MCBSP_RCER_CFG(_MCBSP_RCERF_ADDR(Port),rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)

#define MCBSP_RCERG_CFG(Port,rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)\
 MCBSP_RCER_CFG(_MCBSP_RCERG_ADDR(Port),rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)

#define MCBSP_RCERH_CFG(Port,rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)\
 MCBSP_RCER_CFG(_MCBSP_RCERH_ADDR(Port),rcey15,rcey14,rcey13,rcey12,rcey11,rcey10,rcey9,\
				rcey8,rcey7,rcey6,rcey5,rcey4,rcey3,rcey2,rcey1,rcey0)

/*==========================================================================*\
*  _MCBSP_XCER  -  Receive Channel Enable Config
\*--------------------------------------------------------------------------*/

#define MCBSP_XCER_CFG(RegAddr,xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)  \
	_PREG_SET(RegAddr,							\
		(Uint16) (	_MCBSP_XCER_XCE15_MK(xcey15) 	|	\
				_MCBSP_XCER_XCE14_MK(xcey14) 	|	\
				_MCBSP_XCER_XCE13_MK(xcey13) 	|	\
				_MCBSP_XCER_XCE12_MK(xcey12) 	|	\
				_MCBSP_XCER_XCE11_MK(xcey11) 	|	\
				_MCBSP_XCER_XCE10_MK(xcey10) 	|	\
				_MCBSP_XCER_XCE9_MK(xcey9) 		|	\
				_MCBSP_XCER_XCE8_MK(xcey8) 		|	\
				_MCBSP_XCER_XCE7_MK(xcey7) 		|	\
				_MCBSP_XCER_XCE6_MK(xcey6) 		|	\
				_MCBSP_XCER_XCE5_MK(xcey5) 		|	\
				_MCBSP_XCER_XCE4_MK(xcey4) 		|	\
				_MCBSP_XCER_XCE3_MK(xcey3) 		|	\
				_MCBSP_XCER_XCE2_MK(xcey2) 		|	\
				_MCBSP_XCER_XCE1_MK(xcey1) 		|	\
				_MCBSP_XCER_XCE0_MK(xcey0) 			\
             ))


#define MCBSP_XCERA_CFG(Port,xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)\
 MCBSP_XCER_CFG(_MCBSP_XCERA_ADDR(Port),xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)

#define MCBSP_XCERB_CFG(Port,xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)\
 MCBSP_XCER_CFG(_MCBSP_XCERB_ADDR(Port),xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)

#define MCBSP_XCERC_CFG(Port,xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)\
 MCBSP_XCER_CFG(_MCBSP_XCERC_ADDR(Port),xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)

#define MCBSP_XCERD_CFG(Port,xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)\
 MCBSP_XCER_CFG(_MCBSP_XCERD_ADDR(Port),xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)

#define MCBSP_XCERE_CFG(Port,xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)\
 MCBSP_XCER_CFG(_MCBSP_XCERE_ADDR(Port),xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)

#define MCBSP_XCERF_CFG(Port,xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)\
 MCBSP_XCER_CFG(_MCBSP_XCERF_ADDR(Port),xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)

#define MCBSP_XCERG_CFG(Port,xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)\
 MCBSP_XCER_CFG(_MCBSP_XCERG_ADDR(Port),xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)

#define MCBSP_XCERH_CFG(Port,xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)\
 MCBSP_XCER_CFG(_MCBSP_XCERH_ADDR(Port),xcey15,xcey14,xcey13,xcey12,xcey11,xcey10,xcey9,\
				xcey8,xcey7,xcey6,xcey5,xcey4,xcey3,xcey2,xcey1,xcey0)

#elif (!(_MCBSP_MOD))
	#error McBSP Hal Module Not Supported on Specified Target
#endif

#endif




csl_mmc.h/      1051539337  0     0     0       28948     `
/************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... csl_mmc.h
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Modified:	Wd April 9 2003 changed reg names MMCCIE ==> MMCIM
*                 MMCFCLK ==> MMCFCLKCTL as per SPSR163D
*
*------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the MMC module 
*
\*************************************************************************/

#ifndef _CSL_MMC_H_
#define _CSL_MMC_H_

#include <_csl.h>
#include <csl_mmchal.h>

#if (_MMC_SUPPORT) 

/*----------------------------------------------------------------*\
*	 MMC scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _MMC_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/****************************************\
* MMC global macro declarations
\****************************************/

/* error codes */
#define MMC_ERR_MAJOR		   (ERR_BASE_MMC) 
#define MMC_ERR_ALLOC		   (0x00000000) 
#define MMC_ERR_INVALID_HANDLE  (0x00000001) 

#define MMC_DEVICE_CNT		_MMC_DEVICE_CNT

/* MMC_Open() flags */
#define MMC_OPEN_RESET	  (0x0001)

/* device identifiers for MMC_Open() */
#define MMC_DEVANY  (-1)
#define MMC_DEV0    (0)
#define MMC_DEV1    (1)

/* define a debuging assertion macro for validating device handles */
#ifdef _MCRTE_DEBUG
  #define MMC_ASSERT_HANDLE(hMMC,RetExp) \
    if (hMMC == INV) { \
       ERR_submit(MMC_ERR_MAJOR, MMC_ERR_INVALID_HANDLE); \
       RetExp; \
    } 
#else
  #define MMC_ASSERT_HANDLE(hMMC,RetExp) 
#endif

/*******************************************\
* MMC global macro definition : ROMABILITY 
\*******************************************/ 
/* Reserved ROM Area for MMCData.h */
/* Data definition */  

/* Predefined Device Handlers */
#define MMC_hDev0   ((MMC_Handle)&(CSL_MMC_DATA.mmc[0]))
#define MMC_hDev1   ((MMC_Handle)&(CSL_MMC_DATA.mmc[1]))


/* ============================================================== */
 /* Make MMCARGH register values based on symbolic constants  */

#define MMC_MMCARGH_RMK(argh)\
 ((Uint16) ( \
  ( MMC_FMK(MMCARGH,ARGH,argh))\
)\
 )

#define MMC_MMCARGH_RMKS(argh_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCARGH,ARGH,argh_sym))\
)\
 )

/*  Default MMCARGH register value  */
#define MMC_MMCARGH_DEFAULT		MMC_STUFF_BITS

/*  MMCARGH field values  */
#define MMC_MMCARGH_ARGH_OF(n)      ((Uint16)(n))


/* ============================================================== */
 /* Make MMCARGL register values based on symbolic constants  */

#define MMC_MMCARGL_RMK(argl)\
 ((Uint16) ( \
  ( MMC_FMK(MMCARGL,ARGL,argl))\
)\
 )

#define MMC_MMCARGL_RMKS(argl_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCARGL,ARGL,argl_sym))\
)\
 )

/*  Default MMCARGL register value  */
#define MMC_MMCARGL_DEFAULT        MMC_STUFF_BITS

/*  MMCARGL field values  */
#define MMC_MMCARGL_ARGL_OF(n)    ((Uint16)(n))

/* ============================================================== */
 /* Make MMCBLEN register values based on symbolic constants  */

#define MMC_MMCBLEN_RMK(blen)\
 ((Uint16) ( \
  ( MMC_FMK(MMCBLEN,BLEN,blen))\
)\
 )

#define MMC_MMCBLEN_RMKS(blen_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCBLEN,BLEN,blen_sym))\
)\
 )

/*  Default MMCBLEN register value  */
#define MMC_MMCBLEN_DEFAULT      (0x0000u)

/*  MMCBLEN field values  */
#define MMC_MMCBLEN_BLEN_OF(n)   ((Uint16)(n))


/* ============================================================== */
 /* Make MMCCIDX register values based on symbolic constants  */

#define MMC_MMCCIDX_RMK(cidx)\
 ((Uint16) ( \
  ( MMC_FMK(MMCCIDX,CIDX,cidx))\
)\
 )

#define MMC_MMCCIDX_RMKS(cidx_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCCIDX,CIDX,cidx_sym))\
)\
 )

/*  Default MMCCIDX register value  */

/*  MMCCIDX field values  */


/* ============================================================== */
 /* Make MMCCIE register values based on symbolic constants  */

#define MMC_MMCCIE_RMK(datdne,bsydne,rspdne,toutrd,toutrs,crcwr,crcrd,crcrs,dxrdy,drrdy,dateg)\
 ((Uint16) ( \
  ( MMC_FMK(MMCCIE,DATDNE,datdne))|\
  ( MMC_FMK(MMCCIE,BSYDNE,bsydne))|\
  ( MMC_FMK(MMCCIE,RSPDNE,rspdne))|\
  ( MMC_FMK(MMCCIE,TOUTRD,toutrd))|\
  ( MMC_FMK(MMCCIE,TOUTRS,toutrs))|\
  ( MMC_FMK(MMCCIE,CRCWR,crcwr))|\
  ( MMC_FMK(MMCCIE,CRCRD,crcrd))|\
  ( MMC_FMK(MMCCIE,CRCRS,crcrs))|\
  ( MMC_FMK(MMCCIE,DXRDY,dxrdy))|\
  ( MMC_FMK(MMCCIE,DRRDY,drrdy))|\
  ( MMC_FMK(MMCCIE,DATEG,dateg))\
)\
 )

#define MMC_MMCCIE_RMKS(datdne_sym,bsydne_sym,rspdne_sym,toutrd_sym,toutrs_sym,crcwr_sym,crcrd_sym,crcrs_sym,dxrdy_sym,drrdy_sym,dateg_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCCIE,DATDNE,datdne_sym))|\
  ( MMC_FMKS(MMCCIE,BSYDNE,bsydne_sym))|\
  ( MMC_FMKS(MMCCIE,RSPDNE,rspdne_sym))|\
  ( MMC_FMKS(MMCCIE,TOUTRD,toutrd_sym))|\
  ( MMC_FMKS(MMCCIE,TOUTRS,toutrs_sym))|\
  ( MMC_FMKS(MMCCIE,CRCWR,crcwr_sym))|\
  ( MMC_FMKS(MMCCIE,CRCRD,crcrd_sym))|\
  ( MMC_FMKS(MMCCIE,CRCRS,crcrs_sym))|\
  ( MMC_FMKS(MMCCIE,DXRDY,dxrdy_sym))|\
  ( MMC_FMKS(MMCCIE,DRRDY,drrdy_sym))|\
  ( MMC_FMKS(MMCCIE,DATEG,dateg_sym))\
)\
 )

/*  Default MMCCIE register value  */

/*  MMCCIE field values  */

/* ============================================================== */
 /* Make MMCIM register values based on symbolic constants  */

#define MMC_MMCIM_RMK(datdne,bsydne,rspdne,toutrd,toutrs,crcwr,crcrd,crcrs,dxrdy,drrdy,dateg)\
 ((Uint16) ( \
  ( MMC_FMK(MMCIM,DATDNE,datdne))|\
  ( MMC_FMK(MMCIM,BSYDNE,bsydne))|\
  ( MMC_FMK(MMCIM,RSPDNE,rspdne))|\
  ( MMC_FMK(MMCIM,TOUTRD,toutrd))|\
  ( MMC_FMK(MMCIM,TOUTRS,toutrs))|\
  ( MMC_FMK(MMCIM,CRCWR,crcwr))|\
  ( MMC_FMK(MMCIM,CRCRD,crcrd))|\
  ( MMC_FMK(MMCIM,CRCRS,crcrs))|\
  ( MMC_FMK(MMCIM,DXRDY,dxrdy))|\
  ( MMC_FMK(MMCIM,DRRDY,drrdy))|\
  ( MMC_FMK(MMCIM,DATEG,dateg))\
)\
 )

#define MMC_MMCIM_RMKS(datdne_sym,bsydne_sym,rspdne_sym,toutrd_sym,toutrs_sym,crcwr_sym,crcrd_sym,crcrs_sym,dxrdy_sym,drrdy_sym,dateg_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCIM,DATDNE,datdne_sym))|\
  ( MMC_FMKS(MMCIM,BSYDNE,bsydne_sym))|\
  ( MMC_FMKS(MMCIM,RSPDNE,rspdne_sym))|\
  ( MMC_FMKS(MMCIM,TOUTRD,toutrd_sym))|\
  ( MMC_FMKS(MMCIM,TOUTRS,toutrs_sym))|\
  ( MMC_FMKS(MMCIM,CRCWR,crcwr_sym))|\
  ( MMC_FMKS(MMCIM,CRCRD,crcrd_sym))|\
  ( MMC_FMKS(MMCIM,CRCRS,crcrs_sym))|\
  ( MMC_FMKS(MMCIM,DXRDY,dxrdy_sym))|\
  ( MMC_FMKS(MMCIM,DRRDY,drrdy_sym))|\
  ( MMC_FMKS(MMCIM,DATEG,dateg_sym))\
)\
 )

/*  Default MMCIM register value  */

/*  MMCIM field values  */


/* ============================================================== */
 /* Make MMCCLK register values based on symbolic constants  */

#define MMC_MMCCLK_RMK(cdiv,clken)\
 ((Uint16) ( \
  ( MMC_FMK(MMCCLK,CDIV,cdiv))|\
  ( MMC_FMK(MMCCLK,CLKEN,clken))\
)\
 )

#define MMC_MMCCLK_RMKS(cdiv_sym,clken_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCCLK,CDIV,cdiv_sym))|\
  ( MMC_FMKS(MMCCLK,CLKEN,clken_sym))\
)\
 )

/*  Default MMCCLK register value  */

/*  MMCCLK field values  */


/* ============================================================== */
 /* Make MMCCMD register values based on symbolic constants  */

#define MMC_MMCCMD_RMK(cmd,bsyexp,rspfmt,write,stream,data,init,dclr)\
 ((Uint16) ( \
  ( MMC_FMK(MMCCMD,CMD,cmd))|\
  ( MMC_FMK(MMCCMD,BSYEXP,bsyexp))|\
  ( MMC_FMK(MMCCMD,RSPFMT,rspfmt))|\
  ( MMC_FMK(MMCCMD,WRITE,write))|\
  ( MMC_FMK(MMCCMD,STREAM,stream))|\
  ( MMC_FMK(MMCCMD,DATA,data))|\
  ( MMC_FMK(MMCCMD,INIT,init))|\
  ( MMC_FMK(MMCCMD,DCLR,dclr))\
)\
 )

#define MMC_MMCCMD_RMKS(cmd_sym,bsyexp_sym,rspfmt_sym,write_sym,stream_sym,data_sym,init_sym,dclr_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCCMD,CMD,cmd_sym))|\
  ( MMC_FMKS(MMCCMD,BSYEXP,bsyexp_sym))|\
  ( MMC_FMKS(MMCCMD,RSPFMT,rspfmt_sym))|\
  ( MMC_FMKS(MMCCMD,WRITE,write_sym))|\
  ( MMC_FMKS(MMCCMD,STREAM,stream_sym))|\
  ( MMC_FMKS(MMCCMD,DATA,data_sym))|\
  ( MMC_FMKS(MMCCMD,INIT,init_sym))|\
  ( MMC_FMKS(MMCCMD,DCLR,dclr_sym))\
)\
 )

/*  Default MMCCMD register value  */

/*  MMCCMD field values  */


/* ============================================================== */
 /* Make MMCCTL register values based on symbolic constants  */

#define MMC_MMCCTL_RMK(datrst,cmdrst,width,spien,dateg,dmaen,nacskp,clkpst,clkpre)\
 ((Uint16) ( \
  ( MMC_FMK(MMCCTL,DATRST,datrst))|\
  ( MMC_FMK(MMCCTL,CMDRST,cmdrst))|\
  ( MMC_FMK(MMCCTL,WIDTH,width))|\
  ( MMC_FMK(MMCCTL,SPIEN,spien))|\
  ( MMC_FMK(MMCCTL,DATEG,dateg))|\
  ( MMC_FMK(MMCCTL,DMAEN,dmaen))|\
  ( MMC_FMK(MMCCTL,NACSKP,nacskp))|\
  ( MMC_FMK(MMCCTL,CLKPST,clkpst))|\
  ( MMC_FMK(MMCCTL,CLKPRE,clkpre))\
)\
 )

#define MMC_MMCCTL_RMKS(datrst_sym,cmdrst_sym,width_sym,spien_sym,dateg_sym,dmaen_sym,nacskp_sym,clkpst_sym,clkpre_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCCTL,DATRST,datrst_sym))|\
  ( MMC_FMKS(MMCCTL,CMDRST,cmdrst_sym))|\
  ( MMC_FMKS(MMCCTL,WIDTH,width_sym))|\
  ( MMC_FMKS(MMCCTL,SPIEN,spien_sym))|\
  ( MMC_FMKS(MMCCTL,DATEG,dateg_sym))|\
  ( MMC_FMKS(MMCCTL,DMAEN,dmaen_sym))|\
  ( MMC_FMKS(MMCCTL,NACSKP,nacskp_sym))|\
  ( MMC_FMKS(MMCCTL,CLKPST,clkpst_sym))|\
  ( MMC_FMKS(MMCCTL,CLKPRE,clkpre_sym))\
)\
 )

/*  Default MMCCTL register value  */

/*  MMCCTL field values  */


/* ============================================================== */
 /* Make MMCDRR register values based on symbolic constants  */

#define MMC_MMCDRR_RMK(drr)\
 ((Uint16) ( \
  ( MMC_FMK(MMCDRR,DRR,drr))\
)\
 )

#define MMC_MMCDRR_RMKS(drr_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCDRR,DRR,drr_sym))\
)\
 )

/*  Default MMCDRR register value  */

/*  MMCDRR field values  */


/* ============================================================== */
 /* Make MMCDRSP register values based on symbolic constants  */

#define MMC_MMCDRSP_RMK(drsp)\
 ((Uint16) ( \
  ( MMC_FMK(MMCDRSP,DRSP,drsp))\
)\
 )

#define MMC_MMCDRSP_RMKS(drsp_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCDRSP,DRSP,drsp_sym))\
)\
 )

/*  Default MMCDRSP register value  */

/*  MMCDRSP field values  */


/* ============================================================== */
 /* Make MMCDXR register values based on symbolic constants  */

#define MMC_MMCDXR_RMK(dxr)\
 ((Uint16) ( \
  ( MMC_FMK(MMCDXR,DXR,dxr))\
)\
 )

#define MMC_MMCDXR_RMKS(dxr_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCDXR,DXR,dxr_sym))\
)\
 )

/*  Default MMCDXR register value  */

/*  MMCDXR field values  */


/* ============================================================== */
 /* Make MMCETOK register values based on symbolic constants  */

#define MMC_MMCETOK_RMK(etok)\
 ((Uint16) ( \
  ( MMC_FMK(MMCETOK,ETOK,etok))\
)\
 )

#define MMC_MMCETOK_RMKS(etok_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCETOK,ETOK,etok_sym))\
)\
 )

/*  Default MMCETOK register value  */

/*  MMCETOK field values  */


/* ============================================================== */
 /* Make MMCFCLK register values based on symbolic constants  */

#define MMC_MMCFCLK_RMK(fdiv,idleen)\
 ((Uint16) ( \
  ( MMC_FMK(MMCFCLK,FDIV,fdiv))|\
  ( MMC_FMK(MMCFCLK,IDLEEN,idleen))\
)\
 )

#define MMC_MMCFCLK_RMKS(fdiv_sym,idleen_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCFCLK,FDIV,fdiv_sym))|\
  ( MMC_FMKS(MMCFCLK,IDLEEN,idleen_sym))\
)\
 )

/*  Default MMCFCLK register value  */

/*  MMCFCLK field values  */

/* ============================================================== */
 /* Make MMCFCLKCTL register values based on symbolic constants  */

#define MMC_MMCFCLKCTL_RMK(fdiv,idleen)\
 ((Uint16) ( \
  ( MMC_FMK(MMCFCLKCTL,FDIV,fdiv))|\
  ( MMC_FMK(MMCFCLKCTL,IDLEEN,idleen))\
)\
 )

#define MMC_MMCFCLKCTL_RMKS(fdiv_sym,idleen_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCFCLKCTL,FDIV,fdiv_sym))|\
  ( MMC_FMKS(MMCFCLKCTL,IDLEEN,idleen_sym))\
)\
 )

/*  Default MMCFCLKCTL register value  */

/*  MMCFCLKCTL field values  */



/* ============================================================== */
 /* Make MMCNBLC register values based on symbolic constants  */

#define MMC_MMCNBLC_RMK)\
 ((Uint16) ( \
\
)\
 )

#define MMC_MMCNBLC_RMKS)\
 ((Uint16) ( \
\
)\
 )

/*  Default MMCNBLC register value  */

/*  MMCNBLC field values  */


/* ============================================================== */
 /* Make MMCNBLK register values based on symbolic constants  */

#define MMC_MMCNBLK_RMK(nblk)\
 ((Uint16) ( \
  ( MMC_FMK(MMCNBLK,NBLK,nblk))\
)\
 )

#define MMC_MMCNBLK_RMKS(nblk_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCNBLK,NBLK,nblk_sym))\
)\
 )

/*  Default MMCNBLK register value  */

/*  MMCNBLK field values  */


/* ============================================================== */
 /* Make MMCRSP0 register values based on symbolic constants  */

#define MMC_MMCRSP0_RMK(rsp)\
 ((Uint16) ( \
  ( MMC_FMK(MMCRSP0,RSP,rsp))\
)\
 )

#define MMC_MMCRSP0_RMKS(rsp_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCRSP0,RSP,rsp_sym))\
)\
 )

/*  Default MMCRSP0 register value  */

/*  MMCRSP0 field values  */


/* ============================================================== */
 /* Make MMCRSP1 register values based on symbolic constants  */

#define MMC_MMCRSP1_RMK(rsp)\
 ((Uint16) ( \
  ( MMC_FMK(MMCRSP1,RSP,rsp))\
)\
 )

#define MMC_MMCRSP1_RMKS(rsp_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCRSP1,RSP,rsp_sym))\
)\
 )

/*  Default MMCRSP1 register value  */

/*  MMCRSP1 field values  */


/* ============================================================== */
 /* Make MMCRSP2 register values based on symbolic constants  */

#define MMC_MMCRSP2_RMK(rsp)\
 ((Uint16) ( \
  ( MMC_FMK(MMCRSP2,RSP,rsp))\
)\
 )

#define MMC_MMCRSP2_RMKS(rsp_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCRSP2,RSP,rsp_sym))\
)\
 )

/*  Default MMCRSP2 register value  */

/*  MMCRSP2 field values  */


/* ============================================================== */
 /* Make MMCRSP3 register values based on symbolic constants  */

#define MMC_MMCRSP3_RMK(rsp)\
 ((Uint16) ( \
  ( MMC_FMK(MMCRSP3,RSP,rsp))\
)\
 )

#define MMC_MMCRSP3_RMKS(rsp_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCRSP3,RSP,rsp_sym))\
)\
 )

/*  Default MMCRSP3 register value  */

/*  MMCRSP3 field values  */


/* ============================================================== */
 /* Make MMCRSP4 register values based on symbolic constants  */

#define MMC_MMCRSP4_RMK(rsp)\
 ((Uint16) ( \
  ( MMC_FMK(MMCRSP4,RSP,rsp))\
)\
 )

#define MMC_MMCRSP4_RMKS(rsp_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCRSP4,RSP,rsp_sym))\
)\
 )

/*  Default MMCRSP4 register value  */

/*  MMCRSP4 field values  */


/* ============================================================== */
 /* Make MMCRSP5 register values based on symbolic constants  */

#define MMC_MMCRSP5_RMK(rsp)\
 ((Uint16) ( \
  ( MMC_FMK(MMCRSP5,RSP,rsp))\
)\
 )

#define MMC_MMCRSP5_RMKS(rsp_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCRSP5,RSP,rsp_sym))\
)\
 )

/*  Default MMCRSP5 register value  */

/*  MMCRSP5 field values  */


/* ============================================================== */
 /* Make MMCRSP6 register values based on symbolic constants  */

#define MMC_MMCRSP6_RMK(rsp)\
 ((Uint16) ( \
  ( MMC_FMK(MMCRSP6,RSP,rsp))\
)\
 )

#define MMC_MMCRSP6_RMKS(rsp_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCRSP6,RSP,rsp_sym))\
)\
 )

/*  Default MMCRSP6 register value  */

/*  MMCRSP6 field values  */


/* ============================================================== */
 /* Make MMCRSP7 register values based on symbolic constants  */

#define MMC_MMCRSP7_RMK(rsp)\
 ((Uint16) ( \
  ( MMC_FMK(MMCRSP7,RSP,rsp))\
)\
 )

#define MMC_MMCRSP7_RMKS(rsp_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCRSP7,RSP,rsp_sym))\
)\
 )

/*  Default MMCRSP7 register value  */

/*  MMCRSP7 field values  */


/* ============================================================== */
 /* Make MMCST0 register values based on symbolic constants  */

#define MMC_MMCST0_RMK)\
 ((Uint16) ( \
\
)\
 )

#define MMC_MMCST0_RMKS)\
 ((Uint16) ( \
\
)\
 )

/*  Default MMCST0 register value  */

/*  MMCST0 field values  */


/* ============================================================== */
 /* Make MMCST1 register values based on symbolic constants  */

#define MMC_MMCST1_RMK)\
 ((Uint16) ( \
\
)\
 )

#define MMC_MMCST1_RMKS)\
 ((Uint16) ( \
\
)\
 )

/*  Default MMCST1 register value  */

/*  MMCST1 field values  */


/* ============================================================== */
 /* Make MMCTOD register values based on symbolic constants  */

#define MMC_MMCTOD_RMK(tod)\
 ((Uint16) ( \
  ( MMC_FMK(MMCTOD,TOD,tod))\
)\
 )

#define MMC_MMCTOD_RMKS(tod_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCTOD,TOD,tod_sym))\
)\
 )

/*  Default MMCTOD register value  */

/*  MMCTOD field values  */


/* ============================================================== */
 /* Make MMCTOR register values based on symbolic constants  */

#define MMC_MMCTOR_RMK(tor)\
 ((Uint16) ( \
  ( MMC_FMK(MMCTOR,TOR,tor))\
)\
 )

#define MMC_MMCTOR_RMKS(tor_sym)\
 ((Uint16) ( \
  ( MMC_FMKS(MMCTOR,TOR,tor_sym))\
)\
 )

/*  Default MMCTOR register value  */
#define MMC_MMCTOR_DEFAULT         (0x0000u)

/*  MMCTOR field values  */
#define MMC_MMCTOR_TOR_OF(n)       ((Uint16)(n))

//----------------------------------------------------------------
// MMC PreDefined Symbolic Command Constants
//----------------------------------------------------------------
#define MMC_SET_MMC_MODE            (0x0001u)
#define MMC_STUFF_BITS              (0x0000u)
#define MMC_RSPNONE			(0x0000u)
#define MMC_RSP1                    (0x0200u)  
#define MMC_RSP2                    (0x0400u)
#define MMC_RSP3                    (0x0600u)
#define MMC_RSP4                     MMC_R1
#define MMC_RSP5                     MMC_R1
#define MMC_RSP6                     MMC_R1

#define MMC_CMD0				(0x0000u)
#define MMC_CMD1				(0x0001u)
#define MMC_CMD2				(0x0002u)
#define MMC_CMD3				(0x0003u)
#define MMC_CMD4				(0x0004u)
#define MMC_CMD5				(0x0005u)
#define MMC_CMD6				(0x0006u)
#define MMC_CMD7				(0x0007u)
#define MMC_CMD8				(0x0008u)
#define MMC_CMD9				(0x0009u)
#define MMC_CMD10                   (0x000Au)
#define MMC_CMD11                   (0x000Bu)
#define MMC_CMD12                   (0x000Cu)
#define MMC_CMD13                   (0x000Du)
#define MMC_CMD14                   (0x000Eu)
#define MMC_CMD15                   (0x000Fu)
#define MMC_CMD16                   (0x0010u)
#define MMC_CMD17                   (0x0011u)
#define MMC_CMD18                   (0x0012u)
#define MMC_CMD19                   (0x0013u)
#define MMC_CMD20                   (0x0014u)
#define MMC_CMD21                   (0x0015u)
#define MMC_CMD22                   (0x0016u)
#define MMC_CMD23                   (0x0017u)
#define MMC_CMD24                   (0x0018u)
#define MMC_CMD25                   (0x0019u)
#define MMC_CMD26                   (0x001Au)
#define MMC_CMD27                   (0x001Bu)
#define MMC_CMD28                   (0x001Cu)
#define MMC_CMD29                   (0x001Du)
#define MMC_CMD30                   (0x001Eu)
#define MMC_CMD31                   (0x001Fu)
#define MMC_CMD32                   (0x0020u)
#define MMC_CMD33                   (0x0021u)
#define MMC_CMD34                   (0x0022u)
#define MMC_CMD35                   (0x0023u)
#define MMC_CMD36                   (0x0024u)
#define MMC_CMD37                   (0x0025u)
#define MMC_CMD38                   (0x0026u)
#define MMC_CMD39                   (0x0027u)
#define MMC_CMD40                   (0x0028u)
#define MMC_CMD41                   (0x0029u)
#define MMC_CMD42                   (0x002Au)
#define MMC_CMD43                   (0x002Bu)
#define MMC_CMD44                   (0x002Cu)
#define MMC_CMD45                   (0x002Du)
#define MMC_CMD46                   (0x002Eu)
#define MMC_CMD47                   (0x002Fu)
#define MMC_CMD48                   (0x0030u)
#define MMC_CMD49                   (0x0031u)
#define MMC_CMD50                   (0x0032u)
#define MMC_CMD51                   (0x0033u)
#define MMC_CMD52                   (0x0034u)
#define MMC_CMD53                   (0x0035u)
#define MMC_CMD54                   (0x0036u)
#define MMC_CMD55                   (0x0037u)
#define MMC_CMD56                   (0x0038u)
#define MMC_CMD57                   (0x0039u)
#define MMC_CMD58                   (0x003Au)
#define MMC_CMD59                   (0x003Bu)
#define MMC_CMD60                   (0x003Cu)
#define MMC_CMD61                   (0x003Du)
#define MMC_CMD62                   (0x003Eu)
#define MMC_CMD63                   (0x003Fu)
#define MMC_CMD64                   (0x0040u)

#define MMC_GO_IDLE_STATE           (MMC_CMD0 | MMC_RSPNONE)
#define MMC_SEND_OP_COND            (MMC_CMD1 | MMC_RSP3)
#define MMC_ALL_SEND_CID		(MMC_CMD2 | MMC_RSP2)
#define MMC_SET_RELATIVE_ADDR       (MMC_CMD3 | MMC_RSP1)
#define MMC_SET_DSR                 (MMC_CMD4 | MMC_RSPNONE)
#define MMC_SELECT_CARD             (MMC_CMD7 | MMC_RSP1)
#define MMC_SEND_CSD                (MMC_CMD9 | MMC_RSP2)
#define MMC_SEND_CID                (MMC_CMD10 | MMC_RSP2)
#define MMC_SPI_SEND_CSD            (MMC_CMD9 | MMC_RSP1)
#define MMC_SPI_SEND_CID            (MMC_CMD9 | MMC_RSP1)
#define MMC_READ_DAT_UNTIL_STOP     (MMC_CMD11 | MMC_RSP1)
#define MMC_STOP_TRANSMISSION       (MMC_CMD12 | MMC_RSP1)
#define MMC_SEND_STATUS             (MMC_CMD13 | MMC_RSP1)
#define MMC_GO_INACTIVE_STATE       (MMC_CMD15 | MMC_RSPNONE)
#define MMC_SET_BLOCKLEN            (MMC_CMD16 | MMC_RSP1)
#define MMC_READ_SINGLE_BLOCK       (MMC_CMD17 | MMC_RSP1)
#define MMC_READ_MULTIPLE_BLOCK     (MMC_CMD18 | MMC_RSP1)
#define MMC_WRITE_DAT_UNTIL_STOP    (MMC_CMD20 | MMC_RSP1)
#define MMC_WRITE_BLOCK             (MMC_CMD24 | MMC_RSP1)
#define MMC_WRITE_MULTIPLE_BLOCK    (MMC_CMD25 | MMC_RSP1)
#define MMC_PROGRAM_CID             (MMC_CMD26 | MMC_RSP1)
#define MMC_PROGRAM_CSD             (MMC_CMD27 | MMC_RSP1)
#define MMC_SET_WRITE_PROT          (MMC_CMD28 | MMC_RSP1)
#define MMC_CLR_WRITE_PROT          (MMC_CMD29 | MMC_RSP1)
#define MMC_SEND_WRITE_PROT         (MMC_CMD30 | MMC_RSP1)
#define MMC_TAG_SECTOR_START        (MMC_CMD32 | MMC_RSP1)
#define MMC_TAG_SECTOR_END          (MMC_CMD33 | MMC_RSP1)
#define MMC_UNTAG_SECTOR            (MMC_CMD34 | MMC_RSP1)
#define MMC_TAG_ERASE_GROUP_START   (MMC_CMD35 | MMC_RSP1)
#define MMC_TAG_ERASE_GROUP_END     (MMC_CMD36 | MMC_RSP1)
#define MMC_UNTAG_ERASE_GROUP       (MMC_CMD37 | MMC_RSP1)
#define MMC_ERASE                   (MMC_CMD38 | MMC_RSP1)
#define MMC_FAST_IO                 (MMC_CMD39 | MMC_RSP4)
#define MMC_GO_IRQ_STATE            (MMC_CMD40 | MMC_RSP5)

#define MMC_WAIT_FOR_DATDNE         (0x0001u)
#define MMC_UNTAG_ERASE_SECTORS     (0x0008u)

#define MMC_VOLTAGE_RANGE_ONLY      (0x0001u)
#define MMC_FORCE_CARDS_INACTIVE    (0x0002u)

#define MMC_OPEN_ONLY               (0x0001u)
#define MMC_OPEN_INIT               (0x0002u)
#define MMC_OPEN_SPI                (0x0004u)
#define MMC_OPEN_NATIVE             (0x0008u)

#define MMC_EVT_DATDNE           (0x0001u)
#define MMC_EVT_BSYDNE           (0x0002u)
#define MMC_EVT_RSPDNE           (0x0004u)
#define MMC_EVT_TOUTRD           (0x0008u)
#define MMC_EVT_TOUTRS           (0x0010u)
#define MMC_EVT_CRCWR            (0x0020u)
#define MMC_EVT_CRCRD            (0x0040u)
#define MMC_EVT_CRCRS            (0x0080u)
#define MMC_EVT_DXRDY            (0x0200u)
#define MMC_EVT_DRRDY            (0x0400u)
#define MMC_EVT_DATEG            (0x0800u)

#define MMC_ST0_DATDNE           (_MMC_MMCST0_DATDNE_MK(1))
#define MMC_ST0_BSYDNE           (_MMC_MMCST0_BSYDNE_MK(1))
#define MMC_ST0_RSPDNE           (_MMC_MMCST0_RSPDNE_MK(1))
#define MMC_ST0_TOUTRD           (_MMC_MMCST0_TOUTRD_MK(1))
#define MMC_ST0_TOUTRS           (_MMC_MMCST0_TOUTRS_MK(1))
#define MMC_ST0_CRCWR            (_MMC_MMCST0_CRCWR_MK(1))
#define MMC_ST0_CRCRD            (_MMC_MMCST0_CRCRD_MK(1))
#define MMC_ST0_CRCRS            (_MMC_MMCST0_CRCRS_MK(1))
#define MMC_ST0_SPIERR           (_MMC_MMCST0_SPIERR_MK(1))
#define MMC_ST0_DXRDY            (_MMC_MMCST0_DXRDY_MK(1))
#define MMC_ST0_DRRDY            (_MMC_MMCST0_DRRDY_MK(1))
#define MMC_USE_LAST_STATUS      (0x80000000u)

#define MMC_DAT1_PIN              (0x6000000u)
#define MMC_DAT2_PIN              (0x7000000u)
#define MMC_DAT3_PIN              (0x8000000u)
#define MMC_CSEN_PIN              MMC_DAT3_PIN

#define MMC_RESPONSE_TIMEOUT      (0xFFFFu)

/*************************************************\
* MMC global variable declarations
\*************************************************/


/*************************************************\
* MMC global function declarations
\*************************************************/


CSLAPI MMC_Handle MMC_open(int devNum);
CSLAPI void MMC_close(MMC_Handle hMMC);
CSLAPI void MMC_config(MMC_Handle hMMC, MMC_Config *myConfig);
CSLAPI void MMC_configArgs(MMC_Handle mmc, Uint16 mmcctl, Uint16 mmcfclkctl, Uint16 mmcclk,
            Uint16 mmcim, Uint16 mmctor, Uint16 mmctod, Uint16 mmcblen,
            Uint16 mmcnblk);
CSLAPI int  MMC_selectCard(MMC_Handle mmc, MMC_CardObj *card);
CSLAPI void MMC_getConfig(MMC_Handle mmc, MMC_Config *mmcCfg);
CSLAPI int  MMC_getStatus(MMC_Handle mmc, Uint32 lmask);
CSLAPI int  MMC_getSpiCid(MMC_Handle mmc, MMC_CardIdObj *cid);

CSLAPI void MMC_clearResponse(MMC_Handle mmc);
CSLAPI int  MMC_read(MMC_Handle mmc, Uint32 cardAddr, Uint16 *buffer, Uint32 length);
CSLAPI int  MMC_sendAllCID(MMC_Handle mmc, MMC_CardIdObj *cid);
CSLAPI void MMC_sendGoIdle(MMC_Handle mmc);


CSLAPI int  MMC_sendCsd(MMC_Handle mmc, MMC_CardCsdObj *csd);
CSLAPI int  MMC_sendCmd(MMC_Handle mmc, Uint16 cmd, Uint16 argh, Uint16 argl, Uint16 waitForRsp);
CSLAPI void MMC_getCardId(MMC_Handle mmc, MMC_CardIdObj *cid);
CSLAPI void MMC_getCardCsd(MMC_Handle mmc, MMC_CardCsdObj *csd);

CSLAPI void MMC_setChipSelect(MMC_Handle mmc, Uint16 gpioPin, MMC_CardObj *card);
CSLAPI  int MMC_getNumberOfCards(MMC_Handle mmc, Uint16 *active, Uint16 *inactive);
CSLAPI void MMC_deselectCard(MMC_Handle mmc, MMC_CardObj *card);
CSLAPI  int MMC_drrdy(MMC_Handle mmc);
CSLAPI  int MMC_dxrdy(MMC_Handle mmc);
CSLAPI  int MMC_setRca(MMC_Handle mmc, MMC_CardObj *card, Uint16 rca);
CSLAPI void interrupt MMC_dispatch0();
CSLAPI void interrupt MMC_dispatch1();
CSLAPI void MMC_eventEnable(MMC_Handle mmc,Uint16 eventMask);
CSLAPI void MMC_eventDisable(MMC_Handle mmc, Uint16 eventMask);
CSLAPI void MMC_setCallBack(MMC_Handle mmc, Uint16 eventMask, MMC_CallBackObj *func);
CSLAPI void MMC_setCardPtr(MMC_Handle mmc, MMC_CardObj *cards);
CSLAPI int  MMC_saveStatus(MMC_Handle mmc);
CSLAPI int  MMC_stop(MMC_Handle mmc);
CSLAPI int  MMC_write(MMC_Handle mmc, Uint32 cardAddr, void *buffer, Uint32 bufLen);
CSLAPI int MMC_MMC_sendOpCond(MMC_Handle mmc, Uint32 hVddMask);
CSLAPI void MMC_setupNative(MMC_Handle mmc, MMC_SetupNative *mmcInit);
CSLAPI void MMC_setupSpi(MMC_Handle mmc, MMC_SetupSpi *mmcInit);

/*************************************************\
* MMC inline function declarations
\*************************************************/


#ifdef USEDEFS

/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /*USEDEFS */

#else
   #ifndef _MMC_MOD_
	#error MMC Hal Module Not Supported on Specified Target
   #endif
#endif  /* _MMC_SUPPORT  */

#endif  /* _CSL_MMCHAL_H  */

/******************************************************************************\
*     
*      End of csl_mmc.h 
*
\******************************************************************************/
csl_mmcdat.h/   1051539335  0     0     0       14615     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... csl_mmcdat.h
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Modified:	      Wed April 9 2003 change register names MMCCIE ===> MMCIM
*                       MMCFCLK ===>MMCFCLKCTL to match SPRS163D
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the MMC module 
*
\*************************************************************************/

#ifndef _CSL_MMCDAT_H_
#define _CSL_MMCDAT_H_

#include <csl_std.h>

//---------------------------------------------------
// MMC Module Global Data Initialization
//---------------------------------------------------

extern void interrupt MMC_dispatch0();
extern void interrupt MMC_dispatch1();

#define MMC_DEV_CNT     2

#define CSL_MMCDATAINIT \
{  /* MMC 0 Data Initialization*/\
   0x0000u,                 /* MMC Device number*/\
   0x0007u,                 /* MMC EventId*/\
   0x0000u,                 /* Last status */\
   (MMC_IsrPtr)0x0000u,     /* Default ISR dispatcher function */\
   (MMC_MmcRegObj *)0x4800u,   /* Pointer to start of MMC control registers*/\
   0x0000u,                 /* Next index in defining new cards to MMC module*/\
   0x0000u,                 /* Index of currently selected card*/\
   0x0000u,                 /* Total number of cards in system*/\
   0x0000u,                 /* Number of active cards in system*/\
   0x0000u,                 /* Number of inactive cards in system*/\
  (MMC_CardObj*)0x0000u,    /* Pointer to list of cards attached to MMC controller*/\
  /* Entries for MMC Dispatch Table*/\
     (MMC_CallBackPtr)0x0000u,\
     (MMC_CallBackPtr)0x0000u,\
     (MMC_CallBackPtr)0x0000u,\
     (MMC_CallBackPtr)0x0000u,\
     (MMC_CallBackPtr)0x0000u,\
     (MMC_CallBackPtr)0x0000u,\
     (MMC_CallBackPtr)0x0000u,\
     (MMC_CallBackPtr)0x0000u,\
     (MMC_CallBackPtr)0x0000u,\
     (MMC_CallBackPtr)0x0000u,\
     (MMC_CallBackPtr)0x0000u,\
     (MMC_CallBackPtr)0x0000u,\
 /* MMC 1 Data Initialization*/\
    0x0001u,                 /* MMC Device number*/\
    0x000Du,                 /* MMC EventId*/\
    0x0000u,                 /* Last status */\
    (MMC_IsrPtr)0x0000u,     /* Defualt MMC ISR handler */\
    (MMC_MmcRegObj *)0x4C00u,   /* Pointer to start of MMC control registers*/\
    0x0000u,                 /* Next index in defining new cards to MMC module*/\
    0x0000u,                 /* Index of currently selected card*/\
    0x0000u,                 /* Total number of cards in system*/\
    0x0000u,                 /* Number of active cards in system*/\
    0x0000u,                 /* Number of inactive cards in system*/\
   (MMC_CardObj*)0x0000u,    /* Pointer to list of cards attached to MMC controller*/\
     /*Entries for MMC 1 Dispatch Table*/\
   (MMC_CallBackPtr)0x0000u,\
   (MMC_CallBackPtr)0x0000u,\
   (MMC_CallBackPtr)0x0000u,\
   (MMC_CallBackPtr)0x0000u,\
   (MMC_CallBackPtr)0x0000u,\
   (MMC_CallBackPtr)0x0000u,\
   (MMC_CallBackPtr)0x0000u,\
   (MMC_CallBackPtr)0x0000u,\
   (MMC_CallBackPtr)0x0000u,\
   (MMC_CallBackPtr)0x0000u,\
   (MMC_CallBackPtr)0x0000u,\
   (MMC_CallBackPtr)0x0000u\
}

/*************************************************\
 MMC global typedef declarations 
\*************************************************/
typedef void (*MMC_CallBackPtr)();
typedef interrupt void(*MMC_IsrPtr)();

typedef struct {
   MMC_CallBackPtr mmcDatdneCallBack;
   MMC_CallBackPtr mmcBsydneCallBack;
   MMC_CallBackPtr mmcRspdneCallBack;
   MMC_CallBackPtr mmcToutrdCallBack;
   MMC_CallBackPtr mmcToutrsCallBack;
   MMC_CallBackPtr mmcCrcwrCallBack;
   MMC_CallBackPtr mmcCrcrdCallBack;
   MMC_CallBackPtr mmcCrcrsCallBack;
   MMC_CallBackPtr mmcSpierrCallBack;
   MMC_CallBackPtr mmcDxrdyCallBack;
   MMC_CallBackPtr mmcDrrdyCallBack;
   MMC_CallBackPtr mmcDategCallBack;
} MMC_CallBackObj;

typedef struct {
  Uint32 mfgId;                    /* 24 bit Manufacturers ID */
  char productName[8];             /* 7 character Product Name */
  Uint16 hwRev;                    /* 4 bit Hardware  Revision Number */
  Uint16 fwRev;                    /* 4 bit Firmware Revision Number */
  Uint32 serialNumber;             /* 24 bit Serial Number                    */
  Uint16 monthCode;                /* 4 bit Manufacturing Date (Month) */
  Uint16 yearCode;                 /* 4 bit Manufacturing Date (Year) */
  Uint16 checksum;                 /* 7 bit crc */
} MMC_CardIdObj;

typedef struct {
  Uint16 csdStructure;             /* 2 bit structure type field */
  Uint16 mmcProt;                  /* 2 bit MMC protocol */
  Uint16 taac;                     /* 8 bit TAAC */
  Uint16 nsac;                     /* 8 bit NSAC */
  Uint16 tranSpeed;                /* 8 bit max data transmission speed */
  Uint16 ccc;                      /* 12 bit card command classes */
  Uint16 readBlLen;                /* 4 bit maximum Read Block Length */
  Uint16 readBlPartial;            /* 1 bit indicates if partial read blocks allowed */
  Uint16 writeBlkMisalign;         /* 1 bit flag indicates write block misalignment */
  Uint16 readBlkMisalign;          /* 1 bit flag indicates read block misalignment */
  Uint16 dsrImp;                   /* 1 bit flag indicates whether card has DSR reg */
  Uint16 cSize;                    /* 12 bit device size */
  Uint16 vddRCurrMin;              /* 3 bit Max. Read Current @ Vdd Min  */
  Uint16 vddRCurrMax;              /* 3 bit Max. Read Current @ Vdd Max */
  Uint16 vddWCurrMin;              /* 3 bit Max. Write Current @ Vdd Min */
  Uint16 vddWCurrMax;              /* 3 bit Max. Write Current @ Vdd Max */
  Uint16 cSizeMult;                /* 3 bit device size multiplier */
  Uint16 sectorSize;               /* 5 bit erase sector size */
  Uint16 eraseGrpSize;             /* 5 bit erase group size */
  Uint16 wpGrpSize;                /* 5 bit write protect group size */
  Uint16 wpGrpEnable;              /* 1 bit write protect enable flag */    
  Uint16 defaultEcc;               /* 2 bit Manufacturer Default ECC */
  Uint16 r2wFactor;                /* 3 bit stream write factor */
  Uint16 writeBlLen;               /* 4 bit maximum write block length */
  Uint16 writeBlPartial;           /* 1 bit indicates if partial write blocks allowed */
  Uint16 copy;                     /* 1 bit copy flag */
  Uint16 permWriteProtect;         /* 1 bit to dis/en-able permanent write protection */
  Uint16 tmpWriteProtect;          /* 1 bit to dis/en-able temporary write protection */
  Uint16 ecc;                      /* 2 bit ECC code */
  Uint16 crc;                      /* 7 bit r/w/e redundancy check */
} MMC_CardCsdObj;

typedef struct {
  Uint16 securitySysId;           /* Security System ID */
  Uint16 securitySysVers;         /* Security System Version */
  Uint16 maxLicenses;             /* Maximum number of storable licenses */
  Uint32 xStatus;                 /* Extended status bits */
} MMC_CardXCsdObj;


typedef struct {
  Uint32 rca;                  /* User assigned relative card address (RCA) 
                                  MMC mode or GPIO pin mapping associated with 
                                  Chip Select in SPI mode */
  Uint16 status;               /* Last read status value */
  Uint16 cardIndex;            /* MMC module assignd index for card */
  Uint16 cardType;             /* MMC or SD */
  Uint32 maxXfrRate;           /* Maximum transfer rate */
  Uint32 readAccessTime;       /* TAAC - exp * mantissa */
  Uint32 cardCapacity;         /* Total memory available on card */
  Uint32 lastAddrRead;         /* Last Address Read from memory card */
  Uint32 lastAddrWritten;      /* Last Address written to on memory card */

  MMC_CardIdObj cid;           /* Manufacturers Card ID */
  MMC_CardCsdObj *csd;         /* Card specific data */
  MMC_CardXCsdObj *xcsd;       /* Extended CSD      */
} MMC_CardObj;


typedef struct {
  Uint16 argh;                 /* High part of command argument */
  Uint16 argl;                 /* Low part of command argument */
  Uint16 cmd;                  /* MMC command */
} MMC_CmdObj;
             
typedef struct {
  Uint16 dmaEnable;            /* Enable/disable DMA for data read/write */
  Uint16 dat3EdgeDetection;    /* Set level of edge detection for DAT3 pin */
  Uint16 goIdle;               /* Determines if MMC goes IDLE during IDLE instr */
  Uint16 enableClkPin;         /* Memory clk reflected on CLK Pin */
  Uint32 fdiv;                 /* CPU CLK to MMC function clk divide down */
  Uint32 cdiv;                 /* MMC function clk to memory clk divide down */
  Uint16 rspTimeout;           /* No. memory clks to wait before response timeout */
  Uint16 dataTimeout;          /* No. memory clks to wait before data timeout */
  Uint16 blockLen;             /* Block Length must be same as CSD */
} MMC_SetupNative, MMC_InitObj;

typedef struct {
  Uint16 dmaEnable;         // Enable/disable DMA for data read/write 
  Uint16 dat3EdgeDetection; // Set level of edge detection for DAT3 pin 
  Uint16 goIdle;            // Determines if MMC goes IDLE during IDLE instr 
  Uint16 enableClkPin;      // Memory clk reflected on CLK Pin 
  Uint32 fdiv;              // CPU CLK to MMC function clk divide down 
  Uint32 cdiv;              // MMC function clk to memory clk divide down 
  Uint16 rspTimeout;        // No. memory clks to wait before response timeout 
  Uint16 dataTimeout;       // No. memory clks to wait before data timeout 
  Uint16 blenOrCrc;          // Sets Block Length for Native Mode or
} MMC_Setup;


typedef struct {
  Uint16 dmaEnable;            /* Enable/disable DMA for data read/write */
  Uint16 dat3EdgeDetection;    /* Set level of edge detection for DAT3 pin */
  Uint16 goIdle;               /* Determines if MMC goes IDLE during IDLE instr */
  Uint16 enableClkPin;         /* Memory clk reflected on CLK Pin */
  Uint32 fdiv;                 /* CPU CLK to MMC function clk divide down */
  Uint32 cdiv;                 /* MMC function clk to memory clk divide down */
  Uint16 rspTimeout;           /* No. memory clks to wait before response timeout */
  Uint16 dataTimeout;          /* No. memory clks to wait before data timeout */
  Uint16 spiCrc;               /* Enable/disable CRC checking */
} MMC_SetupSpi;


typedef struct {
  Uint16 rsp0;              /* Response register 0-7 */
  Uint16 rsp1;              
  Uint16 rsp2;              
  Uint16 rsp3;              
  Uint16 rsp4;              
  Uint16 rsp5;              
  Uint16 rsp6;              
  Uint16 rsp7;              
} MMC_RspRegObj;

typedef struct {
  Uint16 mmcfclkctl;           /* MMCFCLKCTL register */
  Uint16 mmcctl;               /* MMCCTL register     */
  Uint16 mmcclk;               /* MMCCLK register     */
  Uint16 mmcst0;               /* MMCST0 register     */
  Uint16 mmcst1;               /* MMCST1 register     */
  Uint16 mmcim;                /* MMCCIM register     */
  Uint16 mmctor;               /* MMCTOR register     */
  Uint16 mmctod;               /* MMCTOD register     */
  Uint16 mmcblen;              /* MMCBLEN register    */
  Uint16 mmcnblk;              /* MMCNBLK register    */
  Uint16 mmcnblc;              /* MMCNBLC register    */
  Uint16 mmcdrr;               /* MMCDRR register     */
  Uint16 mmcdxr;               /* MMCDXR register     */
  Uint16 mmccmd;               /* MMCCMD register     */
  Uint16 mmcargl;              /* MMCARGL register    */
  Uint16 mmcargh;              /* MMCARGH register    */
  MMC_RspRegObj mmcrsp;        /* MMCRSP registers    */
  Uint16 mmcdrsp;              /* MMCDRSP register    */
  Uint16 mmcetok;              /* MMCETOK register    */
  Uint16 mmccidx;              /* MMCCIDX register    */
} MMC_MmcRegObj;


 typedef struct {
   Uint16 dev;                         /* MMC device number 0,1 */
   ioport MMC_MmcRegObj *mmcRegs;      /* Pointer to MMC regs for this device */
   Uint16 nextIndex;                   /* Next index to assign to an attached card */
   Uint16 currentCard;                 /* Index of currently addressed card */
   Uint16 numCards;                    /* Total Number of Cards */
   Uint16 numCardsActive;              /* Number of cards active/ready */
   Uint16 numCardsInactive;            /* Number of inactive cards */
   MMC_CardObj *cards;                 /* Pointer to card Objects */ 
} MMC_StatusObj;


/*************************************************\
 MMC global typedef declarations 
\*************************************************/

typedef struct {
  Uint16 mmcctl;
  Uint16 mmcfclkctl;
  Uint16 mmcclk;
  Uint16 mmcim;
  Uint16 mmctor;
  Uint16 mmctod;
  Uint16 mmcblen;
  Uint16 mmcnblk;
} MMC_Config;


typedef struct {
   Uint16 devNum;                      /* MMC device number 0,1 */
   Uint16 eventId;                     /* MMC eventId (IMR/IFR) */
   Uint16 status;                      /* MMC status */
   MMC_IsrPtr mmcDispatch;             /* Default MMC ISR dispatcher */
   MMC_MmcRegObj *mmcRegs;             /* Pointer to MMC regs for this device */
   Uint16 nextIndex;                   /* Next index to assign to an attached card */
   Uint16 currentCard;                 /* Index of currently addressed card */
   Uint16 numCards;                    /* Total Number of Cards */
   Uint16 numCardsActive;              /* Number of cards active/ready */
   Uint16 numCardsInactive;            /* Number of inactive cards */
   MMC_CardObj *cards;                 /* Pointer to card Objects */
   MMC_CallBackObj callBackTbl;        /* MMC dispatcher callback table */ 
} MMC_ControllerObj, MMC_PrivateObj, *MMC_Handle;

typedef struct {
 MMC_ControllerObj mmc[MMC_DEV_CNT];
}CSL_MmcDataObj;

extern CSL_MmcDataObj CSL_MmcData;

#define CSL_MMC_DATA  CSL_MmcData

#endif


csl_mmchal.h/   1051539334  0     0     0       125286    `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... MMC
* FILENAME...... csl_mmchal.h
* DATE CREATED.. Thu May 24 14:48:09 2001
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Thu May 24 14:48:09 2001 (Automatic generation)
*	 Modified:	      Wed April 9 2003 Updated register names as per SPSR163D
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL HAL interface file for the MMC module 
*
* Registers covered:
*
* 		 Note: Add registers description here
*	 MMCCTL		- 
*	 MMCFCLK		- Register renamed to MMCFCKCTL in data sheet SPSR163D
*	 MMCCLK		- 
*	 MMCCIE		- Register renamed to MMCIM in data sheet SPRS163D
*	 MMCTOR		- 
*	 MMCTOD		- 
*	 MMCBLEN		- 
*	 MMCNBLK		- 
*	 MMCST0		- 
*	 MMCST1		- 
*	 MMCNBLC		- 
*	 MMCDRR		- 
*	 MMCDXR		- 
*	 MMCCMD		- 
*	 MMCARGL		- 
*	 MMCARGH		- 
*	 MMCRSP0		- 
*	 MMCRSP0		- 
*	 MMCRSP1		- 
*	 MMCRSP2		- 
*	 MMCRSP3		- 
*	 MMCRSP4		- 
*	 MMCRSP5		- 
*	 MMCRSP6		- 
*	 MMCRSP7		- 
*	 MMCDRSP		- 
*	 MMCETOK		- 
*	 MMCCIDX		- 
*
\*************************************************************************/

#ifndef _CSL_MMCHAL_H_
#define _CSL_MMCHAL_H_

#include <csl_chiphal.h>

#if (_MMC_SUPPORT) 

/*----------------------------------------------------------------*\
*	 MMC scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _MMC_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/*----------------------------------------------------------------*\
*		 Address Macros			
\*----------------------------------------------------------------*/

#define _MMC_BASE_ADDR		(0x4800)


/*--------------------- Register: MMCCTL -----------------------*/
#define _MMC_MMCCTL0_ADDR		 _MMC_MMCCTL_ADDR(0)
#define _MMC_MMCCTL0			PREG16(_MMC_MMCCTL0_ADDR)
#define MMCCTL0				_MMC_MMCCTL0

#define _MMC_MMCCTL1_ADDR		 _MMC_MMCCTL_ADDR(1)
#define _MMC_MMCCTL1			PREG16(_MMC_MMCCTL1_ADDR)
#define MMCCTL1				_MMC_MMCCTL1

#define _MMC_MMCCTL_BASE			 (0x4801)
#define _MMC_MMCCTL_ADDR(n)		 (_MMC_MMCCTL_BASE + ((n)*0x400))
#define _MMC_MMCCTL(n)			 PREG16(_MMC_MMCCTL_ADDR(n))
#define _MMC_MMCCTL_ADDR_H(devNum)	 _MMC_MMCCTL_ADDR(devNum)

/*--------------------- Register: MMCFCLK -----------------------*/
#define _MMC_MMCFCLK0_ADDR		 _MMC_MMCFCLK_ADDR(0)
#define _MMC_MMCFCLK0			PREG16(_MMC_MMCFCLK0_ADDR)
#define MMCFCLK0				_MMC_MMCFCLK0

#define _MMC_MMCFCLK1_ADDR		 _MMC_MMCFCLK_ADDR(1)
#define _MMC_MMCFCLK1			PREG16(_MMC_MMCFCLK1_ADDR)
#define MMCFCLK1				_MMC_MMCFCLK1

#define _MMC_MMCFCLK_BASE			 (0x4800)
#define _MMC_MMCFCLK_ADDR(n)		 (_MMC_MMCFCLK_BASE + ((n)*0x400))
#define _MMC_MMCFCLK(n)			 PREG16(_MMC_MMCFCLK_ADDR(n))
#define _MMC_MMCFCLK_ADDR_H(devNum)	 _MMC_MMCFCLK_ADDR(devNum)

/*--------------------- Register: MMCFCKCTL -----------------------*/
#define _MMC_MMCFCKCTL0_ADDR		 _MMC_MMCFCKCTL_ADDR(0)
#define _MMC_MMCFCKCTL0			PREG16(_MMC_MMCFCKCTL0_ADDR)
#define MMCFCKCTL0				_MMC_MMCFCKCTL0

#define _MMC_MMCFCKCTL1_ADDR		 _MMC_MMCFCKCTL_ADDR(1)
#define _MMC_MMCFCKCTL1			PREG16(_MMC_MMCFCKCTL1_ADDR)
#define MMCFCKCTL1				_MMC_MMCFCKCTL1

#define _MMC_MMCFCKCTL_BASE			 (0x4800)
#define _MMC_MMCFCKCTL_ADDR(n)		 (_MMC_MMCFCKCTL_BASE + ((n)*0x400))
#define _MMC_MMCFCKCTL(n)			 PREG16(_MMC_MMCFCKCTL_ADDR(n))
#define _MMC_MMCFCKCTL_ADDR_H(devNum)	 _MMC_MMCFCKCTL_ADDR(devNum)


/*--------------------- Register: MMCCLK -----------------------*/
#define _MMC_MMCCLK0_ADDR		 _MMC_MMCCLK_ADDR(0)
#define _MMC_MMCCLK0			PREG16(_MMC_MMCCLK0_ADDR)
#define MMCCLK0				_MMC_MMCCLK0

#define _MMC_MMCCLK1_ADDR		 _MMC_MMCCLK_ADDR(1)
#define _MMC_MMCCLK1			PREG16(_MMC_MMCCLK1_ADDR)
#define MMCCLK1				_MMC_MMCCLK1

#define _MMC_MMCCLK_BASE			 (0x4802)
#define _MMC_MMCCLK_ADDR(n)		 (_MMC_MMCCLK_BASE + ((n)*0x400))
#define _MMC_MMCCLK(n)			 PREG16(_MMC_MMCCLK_ADDR(n))
#define _MMC_MMCCLK_ADDR_H(devNum)	 _MMC_MMCCLK_ADDR(devNum)

/*--------------------- Register: MMCCIE -----------------------*/
#define _MMC_MMCCIE0_ADDR		 _MMC_MMCCIE_ADDR(0)
#define _MMC_MMCCIE0			PREG16(_MMC_MMCCIE0_ADDR)
#define MMCCIE0				_MMC_MMCCIE0

#define _MMC_MMCCIE1_ADDR		 _MMC_MMCCIE_ADDR(1)
#define _MMC_MMCCIE1			PREG16(_MMC_MMCCIE1_ADDR)
#define MMCCIE1				_MMC_MMCCIE1

#define _MMC_MMCCIE_BASE			 (0x4805)
#define _MMC_MMCCIE_ADDR(n)		 (_MMC_MMCCIE_BASE + ((n)*0x400))
#define _MMC_MMCCIE(n)			 PREG16(_MMC_MMCCIE_ADDR(n))
#define _MMC_MMCCIE_ADDR_H(devNum)	 _MMC_MMCCIE_ADDR(devNum)

/*--------------------- Register: MMCIM -----------------------*/
#define _MMC_MMCIM0_ADDR		 _MMC_MMCIM_ADDR(0)
#define _MMC_MMCIM0			PREG16(_MMC_MMCIM0_ADDR)
#define MMCIM0				_MMC_MMCIM0

#define _MMC_MMCIM1_ADDR		 _MMC_MMCIM_ADDR(1)
#define _MMC_MMCIM1			PREG16(_MMC_MMCIM1_ADDR)
#define MMCIM1				_MMC_MMCIM1

#define _MMC_MMCIM_BASE			 (0x4805)
#define _MMC_MMCIM_ADDR(n)		 (_MMC_MMCIM_BASE + ((n)*0x400))
#define _MMC_MMCIM(n)			 PREG16(_MMC_MMCIM_ADDR(n))
#define _MMC_MMCIM_ADDR_H(devNum)	 _MMC_MMCIM_ADDR(devNum)


/*--------------------- Register: MMCTOR -----------------------*/
#define _MMC_MMCTOR0_ADDR		 _MMC_MMCTOR_ADDR(0)
#define _MMC_MMCTOR0			PREG16(_MMC_MMCTOR0_ADDR)
#define MMCTOR0				_MMC_MMCTOR0

#define _MMC_MMCTOR1_ADDR		 _MMC_MMCTOR_ADDR(1)
#define _MMC_MMCTOR1			PREG16(_MMC_MMCTOR1_ADDR)
#define MMCTOR1				_MMC_MMCTOR1

#define _MMC_MMCTOR_BASE			 (0x4806)
#define _MMC_MMCTOR_ADDR(n)		 (_MMC_MMCTOR_BASE + ((n)*0x400))
#define _MMC_MMCTOR(n)			 PREG16(_MMC_MMCTOR_ADDR(n))
#define _MMC_MMCTOR_ADDR_H(devNum)	 _MMC_MMCTOR_ADDR(devNum)

/*--------------------- Register: MMCTOD -----------------------*/
#define _MMC_MMCTOD0_ADDR		 _MMC_MMCTOD_ADDR(0)
#define _MMC_MMCTOD0			PREG16(_MMC_MMCTOD0_ADDR)
#define MMCTOD0				_MMC_MMCTOD0

#define _MMC_MMCTOD1_ADDR		 _MMC_MMCTOD_ADDR(1)
#define _MMC_MMCTOD1			PREG16(_MMC_MMCTOD1_ADDR)
#define MMCTOD1				_MMC_MMCTOD1

#define _MMC_MMCTOD_BASE			 (0x4807)
#define _MMC_MMCTOD_ADDR(n)		 (_MMC_MMCTOD_BASE + ((n)*0x400))
#define _MMC_MMCTOD(n)			 PREG16(_MMC_MMCTOD_ADDR(n))
#define _MMC_MMCTOD_ADDR_H(devNum)	 _MMC_MMCTOD_ADDR(devNum)

/*--------------------- Register: MMCBLEN -----------------------*/
#define _MMC_MMCBLEN0_ADDR		 _MMC_MMCBLEN_ADDR(0)
#define _MMC_MMCBLEN0			PREG16(_MMC_MMCBLEN0_ADDR)
#define MMCBLEN0				_MMC_MMCBLEN0

#define _MMC_MMCBLEN1_ADDR		 _MMC_MMCBLEN_ADDR(1)
#define _MMC_MMCBLEN1			PREG16(_MMC_MMCBLEN1_ADDR)
#define MMCBLEN1				_MMC_MMCBLEN1

#define _MMC_MMCBLEN_BASE			 (0x4808)
#define _MMC_MMCBLEN_ADDR(n)		 (_MMC_MMCBLEN_BASE + ((n)*0x400))
#define _MMC_MMCBLEN(n)			 PREG16(_MMC_MMCBLEN_ADDR(n))
#define _MMC_MMCBLEN_ADDR_H(devNum)	 _MMC_MMCBLEN_ADDR(devNum)

/*--------------------- Register: MMCNBLK -----------------------*/
#define _MMC_MMCNBLK0_ADDR		 _MMC_MMCNBLK_ADDR(0)
#define _MMC_MMCNBLK0			PREG16(_MMC_MMCNBLK0_ADDR)
#define MMCNBLK0				_MMC_MMCNBLK0

#define _MMC_MMCNBLK1_ADDR		 _MMC_MMCNBLK_ADDR(1)
#define _MMC_MMCNBLK1			PREG16(_MMC_MMCNBLK1_ADDR)
#define MMCNBLK1				_MMC_MMCNBLK1

#define _MMC_MMCNBLK_BASE			 (0x4809)
#define _MMC_MMCNBLK_ADDR(n)		 (_MMC_MMCNBLK_BASE + ((n)*0x400))
#define _MMC_MMCNBLK(n)			 PREG16(_MMC_MMCNBLK_ADDR(n))
#define _MMC_MMCNBLK_ADDR_H(devNum)	 _MMC_MMCNBLK_ADDR(devNum)

/*--------------------- Register: MMCST0 -----------------------*/
#define _MMC_MMCST00_ADDR		 _MMC_MMCST0_ADDR(0)
#define _MMC_MMCST00			PREG16(_MMC_MMCST00_ADDR)
#define MMCST00				_MMC_MMCST00

#define _MMC_MMCST01_ADDR		 _MMC_MMCST0_ADDR(1)
#define _MMC_MMCST01			PREG16(_MMC_MMCST01_ADDR)
#define MMCST01				_MMC_MMCST01

#define _MMC_MMCST0_BASE			 (0x4803)
#define _MMC_MMCST0_ADDR(n)		 (_MMC_MMCST0_BASE + ((n)*0x400))
#define _MMC_MMCST0(n)			 PREG16(_MMC_MMCST0_ADDR(n))
#define _MMC_MMCST0_ADDR_H(devNum)	 _MMC_MMCST0_ADDR(devNum)

/*--------------------- Register: MMCST1 -----------------------*/
#define _MMC_MMCST10_ADDR		 _MMC_MMCST1_ADDR(0)
#define _MMC_MMCST10			PREG16(_MMC_MMCST10_ADDR)
#define MMCST10				_MMC_MMCST10

#define _MMC_MMCST11_ADDR		 _MMC_MMCST1_ADDR(1)
#define _MMC_MMCST11			PREG16(_MMC_MMCST11_ADDR)
#define MMCST11				_MMC_MMCST11

#define _MMC_MMCST1_BASE			 (0x4804)
#define _MMC_MMCST1_ADDR(n)		 (_MMC_MMCST1_BASE + ((n)*0x400))
#define _MMC_MMCST1(n)			 PREG16(_MMC_MMCST1_ADDR(n))
#define _MMC_MMCST1_ADDR_H(devNum)	 _MMC_MMCST1_ADDR(devNum)

/*--------------------- Register: MMCNBLC -----------------------*/
#define _MMC_MMCNBLC0_ADDR		 _MMC_MMCNBLC_ADDR(0)
#define _MMC_MMCNBLC0			PREG16(_MMC_MMCNBLC0_ADDR)
#define MMCNBLC0				_MMC_MMCNBLC0

#define _MMC_MMCNBLC1_ADDR		 _MMC_MMCNBLC_ADDR(1)
#define _MMC_MMCNBLC1			PREG16(_MMC_MMCNBLC1_ADDR)
#define MMCNBLC1				_MMC_MMCNBLC1

#define _MMC_MMCNBLC_BASE			 (0x480A)
#define _MMC_MMCNBLC_ADDR(n)		 (_MMC_MMCNBLC_BASE + ((n)*0x400))
#define _MMC_MMCNBLC(n)			 PREG16(_MMC_MMCNBLC_ADDR(n))
#define _MMC_MMCNBLC_ADDR_H(devNum)	 _MMC_MMCNBLC_ADDR(devNum)

/*--------------------- Register: MMCDRR -----------------------*/
#define _MMC_MMCDRR0_ADDR		 _MMC_MMCDRR_ADDR(0)
#define _MMC_MMCDRR0			PREG16(_MMC_MMCDRR0_ADDR)
#define MMCDRR0				_MMC_MMCDRR0

#define _MMC_MMCDRR1_ADDR		 _MMC_MMCDRR_ADDR(1)
#define _MMC_MMCDRR1			PREG16(_MMC_MMCDRR1_ADDR)
#define MMCDRR1				_MMC_MMCDRR1

#define _MMC_MMCDRR_BASE			 (0x480B)
#define _MMC_MMCDRR_ADDR(n)		 (_MMC_MMCDRR_BASE + ((n)*0x400))
#define _MMC_MMCDRR(n)			 PREG16(_MMC_MMCDRR_ADDR(n))
#define _MMC_MMCDRR_ADDR_H(devNum)	 _MMC_MMCDRR_ADDR(devNum)

/*--------------------- Register: MMCDXR -----------------------*/
#define _MMC_MMCDXR0_ADDR		 _MMC_MMCDXR_ADDR(0)
#define _MMC_MMCDXR0			PREG16(_MMC_MMCDXR0_ADDR)
#define MMCDXR0				_MMC_MMCDXR0

#define _MMC_MMCDXR1_ADDR		 _MMC_MMCDXR_ADDR(1)
#define _MMC_MMCDXR1			PREG16(_MMC_MMCDXR1_ADDR)
#define MMCDXR1				_MMC_MMCDXR1

#define _MMC_MMCDXR_BASE			 (0x480C)
#define _MMC_MMCDXR_ADDR(n)		 (_MMC_MMCDXR_BASE + ((n)*0x400))
#define _MMC_MMCDXR(n)			 PREG16(_MMC_MMCDXR_ADDR(n))
#define _MMC_MMCDXR_ADDR_H(devNum)	 _MMC_MMCDXR_ADDR(devNum)

/*--------------------- Register: MMCCMD -----------------------*/
#define _MMC_MMCCMD0_ADDR		 _MMC_MMCCMD_ADDR(0)
#define _MMC_MMCCMD0			PREG16(_MMC_MMCCMD0_ADDR)
#define MMCCMD0				_MMC_MMCCMD0

#define _MMC_MMCCMD1_ADDR		 _MMC_MMCCMD_ADDR(1)
#define _MMC_MMCCMD1			PREG16(_MMC_MMCCMD1_ADDR)
#define MMCCMD1				_MMC_MMCCMD1

#define _MMC_MMCCMD_BASE			 (0x480D)
#define _MMC_MMCCMD_ADDR(n)		 (_MMC_MMCCMD_BASE + ((n)*0x400))
#define _MMC_MMCCMD(n)			 PREG16(_MMC_MMCCMD_ADDR(n))
#define _MMC_MMCCMD_ADDR_H(devNum)	 _MMC_MMCCMD_ADDR(devNum)

/*--------------------- Register: MMCARGL -----------------------*/
#define _MMC_MMCARGL0_ADDR		 _MMC_MMCARGL_ADDR(0)
#define _MMC_MMCARGL0			PREG16(_MMC_MMCARGL0_ADDR)
#define MMCARGL0				_MMC_MMCARGL0

#define _MMC_MMCARGL1_ADDR		 _MMC_MMCARGL_ADDR(1)
#define _MMC_MMCARGL1			PREG16(_MMC_MMCARGL1_ADDR)
#define MMCARGL1				_MMC_MMCARGL1

#define _MMC_MMCARGL_BASE			 (0x480E)
#define _MMC_MMCARGL_ADDR(n)		 (_MMC_MMCARGL_BASE + ((n)*0x400))
#define _MMC_MMCARGL(n)			 PREG16(_MMC_MMCARGL_ADDR(n))
#define _MMC_MMCARGL_ADDR_H(devNum)	 _MMC_MMCARGL_ADDR(devNum)

/*--------------------- Register: MMCARGH -----------------------*/
#define _MMC_MMCARGH0_ADDR		 _MMC_MMCARGH_ADDR(0)
#define _MMC_MMCARGH0			PREG16(_MMC_MMCARGH0_ADDR)
#define MMCARGH0				_MMC_MMCARGH0

#define _MMC_MMCARGH1_ADDR		 _MMC_MMCARGH_ADDR(1)
#define _MMC_MMCARGH1			PREG16(_MMC_MMCARGH1_ADDR)
#define MMCARGH1				_MMC_MMCARGH1

#define _MMC_MMCARGH_BASE			 (0x480F)
#define _MMC_MMCARGH_ADDR(n)		 (_MMC_MMCARGH_BASE + ((n)*0x400))
#define _MMC_MMCARGH(n)			 PREG16(_MMC_MMCARGH_ADDR(n))
#define _MMC_MMCARGH_ADDR_H(devNum)	 _MMC_MMCARGH_ADDR(devNum)

/*--------------------- Register: MMCRSP0 -----------------------*/
#define _MMC_MMCRSP00_ADDR		 _MMC_MMCRSP0_ADDR(0)
#define _MMC_MMCRSP00			PREG16(_MMC_MMCRSP00_ADDR)
#define MMCRSP00				_MMC_MMCRSP00

#define _MMC_MMCRSP01_ADDR		 _MMC_MMCRSP0_ADDR(1)
#define _MMC_MMCRSP01			PREG16(_MMC_MMCRSP01_ADDR)
#define MMCRSP01				_MMC_MMCRSP01

#define _MMC_MMCRSP0_BASE			 (0x4810)
#define _MMC_MMCRSP0_ADDR(n)		 (_MMC_MMCRSP0_BASE + ((n)*0x400))
#define _MMC_MMCRSP0(n)			 PREG16(_MMC_MMCRSP0_ADDR(n))
#define _MMC_MMCRSP0_ADDR_H(devNum)	 _MMC_MMCRSP0_ADDR(devNum)

/*--------------------- Register: MMCRSP0 -----------------------*/
#define _MMC_MMCRSP00_ADDR		 _MMC_MMCRSP0_ADDR(0)
#define _MMC_MMCRSP00			PREG16(_MMC_MMCRSP00_ADDR)
#define MMCRSP00				_MMC_MMCRSP00

#define _MMC_MMCRSP01_ADDR		 _MMC_MMCRSP0_ADDR(1)
#define _MMC_MMCRSP01			PREG16(_MMC_MMCRSP01_ADDR)
#define MMCRSP01				_MMC_MMCRSP01

#define _MMC_MMCRSP0_BASE			 (0x4810)
#define _MMC_MMCRSP0_ADDR(n)		 (_MMC_MMCRSP0_BASE + ((n)*0x400))
#define _MMC_MMCRSP0(n)			 PREG16(_MMC_MMCRSP0_ADDR(n))
#define _MMC_MMCRSP0_ADDR_H(devNum)	 _MMC_MMCRSP0_ADDR(devNum)

/*--------------------- Register: MMCRSP1 -----------------------*/
#define _MMC_MMCRSP10_ADDR		 _MMC_MMCRSP1_ADDR(0)
#define _MMC_MMCRSP10			PREG16(_MMC_MMCRSP10_ADDR)
#define MMCRSP10				_MMC_MMCRSP10

#define _MMC_MMCRSP11_ADDR		 _MMC_MMCRSP1_ADDR(1)
#define _MMC_MMCRSP11			PREG16(_MMC_MMCRSP11_ADDR)
#define MMCRSP11				_MMC_MMCRSP11

#define _MMC_MMCRSP1_BASE			 (0x4811)
#define _MMC_MMCRSP1_ADDR(n)		 (_MMC_MMCRSP1_BASE + ((n)*0x400))
#define _MMC_MMCRSP1(n)			 PREG16(_MMC_MMCRSP1_ADDR(n))
#define _MMC_MMCRSP1_ADDR_H(devNum)	 _MMC_MMCRSP1_ADDR(devNum)

/*--------------------- Register: MMCRSP2 -----------------------*/
#define _MMC_MMCRSP20_ADDR		 _MMC_MMCRSP2_ADDR(0)
#define _MMC_MMCRSP20			PREG16(_MMC_MMCRSP20_ADDR)
#define MMCRSP20				_MMC_MMCRSP20

#define _MMC_MMCRSP21_ADDR		 _MMC_MMCRSP2_ADDR(1)
#define _MMC_MMCRSP21			PREG16(_MMC_MMCRSP21_ADDR)
#define MMCRSP21				_MMC_MMCRSP21

#define _MMC_MMCRSP2_BASE			 (0x4812)
#define _MMC_MMCRSP2_ADDR(n)		 (_MMC_MMCRSP2_BASE + ((n)*0x400))
#define _MMC_MMCRSP2(n)			 PREG16(_MMC_MMCRSP2_ADDR(n))
#define _MMC_MMCRSP2_ADDR_H(devNum)	 _MMC_MMCRSP2_ADDR(devNum)

/*--------------------- Register: MMCRSP3 -----------------------*/
#define _MMC_MMCRSP30_ADDR		 _MMC_MMCRSP3_ADDR(0)
#define _MMC_MMCRSP30			PREG16(_MMC_MMCRSP30_ADDR)
#define MMCRSP30				_MMC_MMCRSP30

#define _MMC_MMCRSP31_ADDR		 _MMC_MMCRSP3_ADDR(1)
#define _MMC_MMCRSP31			PREG16(_MMC_MMCRSP31_ADDR)
#define MMCRSP31				_MMC_MMCRSP31

#define _MMC_MMCRSP3_BASE			 (0x4813)
#define _MMC_MMCRSP3_ADDR(n)		 (_MMC_MMCRSP3_BASE + ((n)*0x400))
#define _MMC_MMCRSP3(n)			 PREG16(_MMC_MMCRSP3_ADDR(n))
#define _MMC_MMCRSP3_ADDR_H(devNum)	 _MMC_MMCRSP3_ADDR(devNum)

/*--------------------- Register: MMCRSP4 -----------------------*/
#define _MMC_MMCRSP40_ADDR		 _MMC_MMCRSP4_ADDR(0)
#define _MMC_MMCRSP40			PREG16(_MMC_MMCRSP40_ADDR)
#define MMCRSP40				_MMC_MMCRSP40

#define _MMC_MMCRSP41_ADDR		 _MMC_MMCRSP4_ADDR(1)
#define _MMC_MMCRSP41			PREG16(_MMC_MMCRSP41_ADDR)
#define MMCRSP41				_MMC_MMCRSP41

#define _MMC_MMCRSP4_BASE			 (0x4814)
#define _MMC_MMCRSP4_ADDR(n)		 (_MMC_MMCRSP4_BASE + ((n)*0x400))
#define _MMC_MMCRSP4(n)			 PREG16(_MMC_MMCRSP4_ADDR(n))
#define _MMC_MMCRSP4_ADDR_H(devNum)	 _MMC_MMCRSP4_ADDR(devNum)

/*--------------------- Register: MMCRSP5 -----------------------*/
#define _MMC_MMCRSP50_ADDR		 _MMC_MMCRSP5_ADDR(0)
#define _MMC_MMCRSP50			PREG16(_MMC_MMCRSP50_ADDR)
#define MMCRSP50				_MMC_MMCRSP50

#define _MMC_MMCRSP51_ADDR		 _MMC_MMCRSP5_ADDR(1)
#define _MMC_MMCRSP51			PREG16(_MMC_MMCRSP51_ADDR)
#define MMCRSP51				_MMC_MMCRSP51

#define _MMC_MMCRSP5_BASE			 (0x4815)
#define _MMC_MMCRSP5_ADDR(n)		 (_MMC_MMCRSP5_BASE + ((n)*0x400))
#define _MMC_MMCRSP5(n)			 PREG16(_MMC_MMCRSP5_ADDR(n))
#define _MMC_MMCRSP5_ADDR_H(devNum)	 _MMC_MMCRSP5_ADDR(devNum)

/*--------------------- Register: MMCRSP6 -----------------------*/
#define _MMC_MMCRSP60_ADDR		 _MMC_MMCRSP6_ADDR(0)
#define _MMC_MMCRSP60			PREG16(_MMC_MMCRSP60_ADDR)
#define MMCRSP60				_MMC_MMCRSP60

#define _MMC_MMCRSP61_ADDR		 _MMC_MMCRSP6_ADDR(1)
#define _MMC_MMCRSP61			PREG16(_MMC_MMCRSP61_ADDR)
#define MMCRSP61				_MMC_MMCRSP61

#define _MMC_MMCRSP6_BASE			 (0x4816)
#define _MMC_MMCRSP6_ADDR(n)		 (_MMC_MMCRSP6_BASE + ((n)*0x400))
#define _MMC_MMCRSP6(n)			 PREG16(_MMC_MMCRSP6_ADDR(n))
#define _MMC_MMCRSP6_ADDR_H(devNum)	 _MMC_MMCRSP6_ADDR(devNum)

/*--------------------- Register: MMCRSP7 -----------------------*/
#define _MMC_MMCRSP70_ADDR		 _MMC_MMCRSP7_ADDR(0)
#define _MMC_MMCRSP70			PREG16(_MMC_MMCRSP70_ADDR)
#define MMCRSP70				_MMC_MMCRSP70

#define _MMC_MMCRSP71_ADDR		 _MMC_MMCRSP7_ADDR(1)
#define _MMC_MMCRSP71			PREG16(_MMC_MMCRSP71_ADDR)
#define MMCRSP71				_MMC_MMCRSP71

#define _MMC_MMCRSP7_BASE			 (0x4817)
#define _MMC_MMCRSP7_ADDR(n)		 (_MMC_MMCRSP7_BASE + ((n)*0x400))
#define _MMC_MMCRSP7(n)			 PREG16(_MMC_MMCRSP7_ADDR(n))
#define _MMC_MMCRSP7_ADDR_H(devNum)	 _MMC_MMCRSP7_ADDR(devNum)

/*--------------------- Register: MMCDRSP -----------------------*/
#define _MMC_MMCDRSP0_ADDR		 _MMC_MMCDRSP_ADDR(0)
#define _MMC_MMCDRSP0			PREG16(_MMC_MMCDRSP0_ADDR)
#define MMCDRSP0				_MMC_MMCDRSP0

#define _MMC_MMCDRSP1_ADDR		 _MMC_MMCDRSP_ADDR(1)
#define _MMC_MMCDRSP1			PREG16(_MMC_MMCDRSP1_ADDR)
#define MMCDRSP1				_MMC_MMCDRSP1

#define _MMC_MMCDRSP_BASE			 (0x4818)
#define _MMC_MMCDRSP_ADDR(n)		 (_MMC_MMCDRSP_BASE + ((n)*0x400))
#define _MMC_MMCDRSP(n)			 PREG16(_MMC_MMCDRSP_ADDR(n))
#define _MMC_MMCDRSP_ADDR_H(devNum)	 _MMC_MMCDRSP_ADDR(devNum)

/*--------------------- Register: MMCETOK -----------------------*/
#define _MMC_MMCETOK0_ADDR		 _MMC_MMCETOK_ADDR(0)
#define _MMC_MMCETOK0			PREG16(_MMC_MMCETOK0_ADDR)
#define MMCETOK0				_MMC_MMCETOK0

#define _MMC_MMCETOK1_ADDR		 _MMC_MMCETOK_ADDR(1)
#define _MMC_MMCETOK1			PREG16(_MMC_MMCETOK1_ADDR)
#define MMCETOK1				_MMC_MMCETOK1

#define _MMC_MMCETOK_BASE			 (0x4819)
#define _MMC_MMCETOK_ADDR(n)		 (_MMC_MMCETOK_BASE + ((n)*0x400))
#define _MMC_MMCETOK(n)			 PREG16(_MMC_MMCETOK_ADDR(n))
#define _MMC_MMCETOK_ADDR_H(devNum)	 _MMC_MMCETOK_ADDR(devNum)

/*--------------------- Register: MMCCIDX -----------------------*/
#define _MMC_MMCCIDX0_ADDR		 _MMC_MMCCIDX_ADDR(0)
#define _MMC_MMCCIDX0			PREG16(_MMC_MMCCIDX0_ADDR)
#define MMCCIDX0				_MMC_MMCCIDX0

#define _MMC_MMCCIDX1_ADDR		 _MMC_MMCCIDX_ADDR(1)
#define _MMC_MMCCIDX1			PREG16(_MMC_MMCCIDX1_ADDR)
#define MMCCIDX1				_MMC_MMCCIDX1

#define _MMC_MMCCIDX_BASE			 (0x481A)
#define _MMC_MMCCIDX_ADDR(n)		 (_MMC_MMCCIDX_BASE + ((n)*0x400))
#define _MMC_MMCCIDX(n)			 PREG16(_MMC_MMCCIDX_ADDR(n))
#define _MMC_MMCCIDX_ADDR_H(devNum)	 _MMC_MMCCIDX_ADDR(devNum)


/*----------------------------------------------------------------*\
*		 Register Macros		
\*----------------------------------------------------------------*/

#define MMC_ADDR(Reg)		        _MMC_##Reg##_ADDR
#define MMC_RGET(Reg)		        _MMC_##Reg##_GET
#define MMC_RSET(Reg,Val)		  _MMC_##Reg##_SET(Val)
#define MMC_FGET(Reg,Field)		  _MMC_##Reg##_FGET(##Field)
#define MMC_FSET(Reg,Field,Val)		  _MMC_##Reg##_FSET(##Field, Val)
#define MMC_FMK(Reg,Field,Val)		  _MMC_##Reg##_##Field##_MK(Val)
#define MMC_RAOI(Reg,AND,OR,INV)		  _MMC_##Reg##_AOI(AND,OR,INV)
#define MMC_FAOI(Reg,Field,AND,OR,INV)	  _MMC_##Reg##_FAOI(##Field,AND,OR,INV)
#define MMC_FMKS(Reg,Field,Sym)\
	  _MMC_##Reg##_##Field##_MK(MMC_##Reg##_##Field##_##Sym)
#define MMC_FSETS(Reg,Field,Sym)\
	  _MMC_FSET(##Reg,##Field,MMC_##Reg##_##Field##_##Sym)

#define MMC_ADDR_H(Handle,Reg)		  _MMC_##Reg##_ADDR_H(((MMC_PrivateObj*)(Handle))->devNum)
#define MMC_RGET_H(Handle,Reg)		  _MMC_##Reg##_GET(((MMC_PrivateObj*)(Handle))->devNum)
#define MMC_RSET_H(Handle,Reg,Val)		  _MMC_##Reg##_SET((((MMC_PrivateObj*)(Handle))->devNum),Val)
#define MMC_FGET_H(Handle,Reg,Field)	  _MMC_##Reg##_FGET((((MMC_PrivateObj*)(Handle))->devNum),Field)
#define MMC_FSET_H(Handle,Reg,Field,Val)	  _MMC_##Reg##_FSET((((MMC_PrivateObj*)(Handle))->devNum),Field,Val)
#define MMC_FMK_H(Handle,Reg,Field,Val)	  _MMC_##Reg##_##Field##_MK(Val)

#define MMC_RAOI_H(Handle,Reg,AND,OR,INV)	  _MMC_##Reg##_AOI((((MMC_PrivateObj*)(Handle))->devNum),AND,OR,INV)
#define MMC_FAOI_H(Handle,Reg,Field,AND,OR,INV)\
	  _MMC_##Reg##_FAOI((((MMC_PrivateObj*)(Handle))->devNum),##Field,AND,OR,INV)
#define MMC_FMKS_H(Handle,Reg,Field,Sym)\
	   _MMC_##Reg##_##Field##_MK(MMC_##Reg##_##Field##_##Sym)
#define MMC_FSETS_H(Handle,Reg,Field,Sym)\
	 _MMC_##Reg##_FSET(Handle,##Field,MMC_##Reg##_##Field##_##Sym)



/*----------------------------------------------------------------*\
*		 Handle Registers Macros		
\*----------------------------------------------------------------*/


/*--------------------- Register: MMCCTL -----------------------*/
#define _MMC_MMCCTL_GET(devNum)			  _PREG_GET(_MMC_MMCCTL_ADDR(devNum)) 
#define _MMC_MMCCTL_SET(devNum,Val)		  _PREG_SET(_MMC_MMCCTL_ADDR(devNum),Val)
#define _MMC_MMCCTL_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCCTL_ADDR(devNum), _MMC_MMCCTL_##Field)
#define _MMC_MMCCTL_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCCTL_ADDR(devNum), _MMC_MMCCTL_##Field, Val)
#define _MMC_MMCCTL_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCCTL_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCCTL_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCTL_ADDR(devNum), _MMC_MMCCTL_##Field,AND,OR,INV)

#define _MMC_MMCCTL0_GET		  _PREG_GET(_MMC_MMCCTL_ADDR(0)) 
#define _MMC_MMCCTL0_SET(Val)		  _PREG_SET(_MMC_MMCCTL_ADDR(0),Val)
#define _MMC_MMCCTL0_FGET(Field)	  _PFIELD_GET(_MMC_MMCCTL_ADDR(0), _MMC_MMCCTL_##Field)
#define _MMC_MMCCTL0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCCTL_ADDR(0), _MMC_MMCCTL_##Field, Val)
#define _MMC_MMCCTL0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCCTL_ADDR(0),AND,OR,INV)
#define _MMC_MMCCTL0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCTL_ADDR(0), _MMC_MMCCTL_##Field,AND,OR,INV)

#define _MMC_MMCCTL1_GET		  _PREG_GET(_MMC_MMCCTL_ADDR(1)) 
#define _MMC_MMCCTL1_SET(Val)		  _PREG_SET(_MMC_MMCCTL_ADDR(1),Val)
#define _MMC_MMCCTL1_FGET(Field)	  _PFIELD_GET(_MMC_MMCCTL_ADDR(1), _MMC_MMCCTL_##Field)
#define _MMC_MMCCTL1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCCTL_ADDR(1), _MMC_MMCCTL_##Field, Val)
#define _MMC_MMCCTL1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCCTL_ADDR(1),AND,OR,INV)
#define _MMC_MMCCTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCTL_ADDR(1), _MMC_MMCCTL_##Field,AND,OR,INV)


/*--------------------- Register: MMCFCLK -----------------------*/
#define _MMC_MMCFCLK_GET(devNum)			  _PREG_GET(_MMC_MMCFCLK_ADDR(devNum)) 
#define _MMC_MMCFCLK_SET(devNum,Val)		  _PREG_SET(_MMC_MMCFCLK_ADDR(devNum),Val)
#define _MMC_MMCFCLK_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCFCLK_ADDR(devNum), _MMC_MMCFCLK_##Field)
#define _MMC_MMCFCLK_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCFCLK_ADDR(devNum), _MMC_MMCFCLK_##Field, Val)
#define _MMC_MMCFCLK_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCFCLK_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCFCLK_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCFCLK_ADDR(devNum), _MMC_MMCFCLK_##Field,AND,OR,INV)

#define _MMC_MMCFCLK0_GET		  _PREG_GET(_MMC_MMCFCLK_ADDR(0)) 
#define _MMC_MMCFCLK0_SET(Val)		  _PREG_SET(_MMC_MMCFCLK_ADDR(0),Val)
#define _MMC_MMCFCLK0_FGET(Field)	  _PFIELD_GET(_MMC_MMCFCLK_ADDR(0), _MMC_MMCFCLK_##Field)
#define _MMC_MMCFCLK0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCFCLK_ADDR(0), _MMC_MMCFCLK_##Field, Val)
#define _MMC_MMCFCLK0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCFCLK_ADDR(0),AND,OR,INV)
#define _MMC_MMCFCLK0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCFCLK_ADDR(0), _MMC_MMCFCLK_##Field,AND,OR,INV)

#define _MMC_MMCFCLK1_GET		  _PREG_GET(_MMC_MMCFCLK_ADDR(1)) 
#define _MMC_MMCFCLK1_SET(Val)		  _PREG_SET(_MMC_MMCFCLK_ADDR(1),Val)
#define _MMC_MMCFCLK1_FGET(Field)	  _PFIELD_GET(_MMC_MMCFCLK_ADDR(1), _MMC_MMCFCLK_##Field)
#define _MMC_MMCFCLK1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCFCLK_ADDR(1), _MMC_MMCFCLK_##Field, Val)
#define _MMC_MMCFCLK1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCFCLK_ADDR(1),AND,OR,INV)
#define _MMC_MMCFCLK1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCFCLK_ADDR(1), _MMC_MMCFCLK_##Field,AND,OR,INV)


/*--------------------- Register: MMCFCKCTL -----------------------*/
#define _MMC_MMCFCKCTL_GET(devNum)			  _PREG_GET(_MMC_MMCFCKCTL_ADDR(devNum)) 
#define _MMC_MMCFCKCTL_SET(devNum,Val)		  _PREG_SET(_MMC_MMCFCKCTL_ADDR(devNum),Val)
#define _MMC_MMCFCKCTL_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCFCKCTL_ADDR(devNum), _MMC_MMCFCKCTL_##Field)
#define _MMC_MMCFCKCTL_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCFCKCTL_ADDR(devNum), _MMC_MMCFCKCTL_##Field, Val)
#define _MMC_MMCFCKCTL_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCFCKCTL_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCFCKCTL_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCFCKCTL_ADDR(devNum), _MMC_MMCFCKCTL_##Field,AND,OR,INV)

#define _MMC_MMCFCKCTL0_GET		  _PREG_GET(_MMC_MMCFCKCTL_ADDR(0)) 
#define _MMC_MMCFCKCTL0_SET(Val)		  _PREG_SET(_MMC_MMCFCKCTL_ADDR(0),Val)
#define _MMC_MMCFCKCTL0_FGET(Field)	  _PFIELD_GET(_MMC_MMCFCKCTL_ADDR(0), _MMC_MMCFCKCTL_##Field)
#define _MMC_MMCFCKCTL0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCFCKCTL_ADDR(0), _MMC_MMCFCKCTL_##Field, Val)
#define _MMC_MMCFCKCTL0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCFCKCTL_ADDR(0),AND,OR,INV)
#define _MMC_MMCFCKCTL0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCFCKCTL_ADDR(0), _MMC_MMCFCKCTL_##Field,AND,OR,INV)

#define _MMC_MMCFCKCTL1_GET		  _PREG_GET(_MMC_MMCFCKCTL_ADDR(1)) 
#define _MMC_MMCFCKCTL1_SET(Val)		  _PREG_SET(_MMC_MMCFCKCTL_ADDR(1),Val)
#define _MMC_MMCFCKCTL1_FGET(Field)	  _PFIELD_GET(_MMC_MMCFCKCTL_ADDR(1), _MMC_MMCFCKCTL_##Field)
#define _MMC_MMCFCKCTL1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCFCKCTL_ADDR(1), _MMC_MMCFCKCTL_##Field, Val)
#define _MMC_MMCFCKCTL1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCFCKCTL_ADDR(1),AND,OR,INV)
#define _MMC_MMCFCKCTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCFCKCTL_ADDR(1), _MMC_MMCFCKCTL_##Field,AND,OR,INV)


/*--------------------- Register: MMCCLK -----------------------*/
#define _MMC_MMCCLK_GET(devNum)			  _PREG_GET(_MMC_MMCCLK_ADDR(devNum)) 
#define _MMC_MMCCLK_SET(devNum,Val)		  _PREG_SET(_MMC_MMCCLK_ADDR(devNum),Val)
#define _MMC_MMCCLK_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCCLK_ADDR(devNum), _MMC_MMCCLK_##Field)
#define _MMC_MMCCLK_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCCLK_ADDR(devNum), _MMC_MMCCLK_##Field, Val)
#define _MMC_MMCCLK_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCCLK_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCCLK_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCLK_ADDR(devNum), _MMC_MMCCLK_##Field,AND,OR,INV)

#define _MMC_MMCCLK0_GET		  _PREG_GET(_MMC_MMCCLK_ADDR(0)) 
#define _MMC_MMCCLK0_SET(Val)		  _PREG_SET(_MMC_MMCCLK_ADDR(0),Val)
#define _MMC_MMCCLK0_FGET(Field)	  _PFIELD_GET(_MMC_MMCCLK_ADDR(0), _MMC_MMCCLK_##Field)
#define _MMC_MMCCLK0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCCLK_ADDR(0), _MMC_MMCCLK_##Field, Val)
#define _MMC_MMCCLK0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCCLK_ADDR(0),AND,OR,INV)
#define _MMC_MMCCLK0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCLK_ADDR(0), _MMC_MMCCLK_##Field,AND,OR,INV)

#define _MMC_MMCCLK1_GET		  _PREG_GET(_MMC_MMCCLK_ADDR(1)) 
#define _MMC_MMCCLK1_SET(Val)		  _PREG_SET(_MMC_MMCCLK_ADDR(1),Val)
#define _MMC_MMCCLK1_FGET(Field)	  _PFIELD_GET(_MMC_MMCCLK_ADDR(1), _MMC_MMCCLK_##Field)
#define _MMC_MMCCLK1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCCLK_ADDR(1), _MMC_MMCCLK_##Field, Val)
#define _MMC_MMCCLK1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCCLK_ADDR(1),AND,OR,INV)
#define _MMC_MMCCLK1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCLK_ADDR(1), _MMC_MMCCLK_##Field,AND,OR,INV)


/*--------------------- Register: MMCCIE -----------------------*/
#define _MMC_MMCCIE_GET(devNum)			  _PREG_GET(_MMC_MMCCIE_ADDR(devNum)) 
#define _MMC_MMCCIE_SET(devNum,Val)		  _PREG_SET(_MMC_MMCCIE_ADDR(devNum),Val)
#define _MMC_MMCCIE_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCCIE_ADDR(devNum), _MMC_MMCCIE_##Field)
#define _MMC_MMCCIE_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCCIE_ADDR(devNum), _MMC_MMCCIE_##Field, Val)
#define _MMC_MMCCIE_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCCIE_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCCIE_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCIE_ADDR(devNum), _MMC_MMCCIE_##Field,AND,OR,INV)

#define _MMC_MMCCIE0_GET		  _PREG_GET(_MMC_MMCCIE_ADDR(0)) 
#define _MMC_MMCCIE0_SET(Val)		  _PREG_SET(_MMC_MMCCIE_ADDR(0),Val)
#define _MMC_MMCCIE0_FGET(Field)	  _PFIELD_GET(_MMC_MMCCIE_ADDR(0), _MMC_MMCCIE_##Field)
#define _MMC_MMCCIE0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCCIE_ADDR(0), _MMC_MMCCIE_##Field, Val)
#define _MMC_MMCCIE0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCCIE_ADDR(0),AND,OR,INV)
#define _MMC_MMCCIE0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCIE_ADDR(0), _MMC_MMCCIE_##Field,AND,OR,INV)

#define _MMC_MMCCIE1_GET		  _PREG_GET(_MMC_MMCCIE_ADDR(1)) 
#define _MMC_MMCCIE1_SET(Val)		  _PREG_SET(_MMC_MMCCIE_ADDR(1),Val)
#define _MMC_MMCCIE1_FGET(Field)	  _PFIELD_GET(_MMC_MMCCIE_ADDR(1), _MMC_MMCCIE_##Field)
#define _MMC_MMCCIE1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCCIE_ADDR(1), _MMC_MMCCIE_##Field, Val)
#define _MMC_MMCCIE1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCCIE_ADDR(1),AND,OR,INV)
#define _MMC_MMCCIE1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCIE_ADDR(1), _MMC_MMCCIE_##Field,AND,OR,INV)

/*--------------------- Register: MMCIM -----------------------*/
#define _MMC_MMCIM_GET(devNum)			  _PREG_GET(_MMC_MMCIM_ADDR(devNum)) 
#define _MMC_MMCIM_SET(devNum,Val)		  _PREG_SET(_MMC_MMCIM_ADDR(devNum),Val)
#define _MMC_MMCIM_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCIM_ADDR(devNum), _MMC_MMCIM_##Field)
#define _MMC_MMCIM_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCIM_ADDR(devNum), _MMC_MMCIM_##Field, Val)
#define _MMC_MMCIM_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCIM_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCIM_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCIM_ADDR(devNum), _MMC_MMCIM_##Field,AND,OR,INV)

#define _MMC_MMCIM0_GET		  _PREG_GET(_MMC_MMCIM_ADDR(0)) 
#define _MMC_MMCIM0_SET(Val)		  _PREG_SET(_MMC_MMCIM_ADDR(0),Val)
#define _MMC_MMCIM0_FGET(Field)	  _PFIELD_GET(_MMC_MMCIM_ADDR(0), _MMC_MMCIM_##Field)
#define _MMC_MMCIM0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCIM_ADDR(0), _MMC_MMCIM_##Field, Val)
#define _MMC_MMCIM0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCIM_ADDR(0),AND,OR,INV)
#define _MMC_MMCIM0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCIM_ADDR(0), _MMC_MMCIM_##Field,AND,OR,INV)

#define _MMC_MMCIM1_GET		  _PREG_GET(_MMC_MMCIM_ADDR(1)) 
#define _MMC_MMCIM1_SET(Val)		  _PREG_SET(_MMC_MMCIM_ADDR(1),Val)
#define _MMC_MMCIM1_FGET(Field)	  _PFIELD_GET(_MMC_MMCIM_ADDR(1), _MMC_MMCIM_##Field)
#define _MMC_MMCIM1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCIM_ADDR(1), _MMC_MMCIM_##Field, Val)
#define _MMC_MMCIM1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCIM_ADDR(1),AND,OR,INV)
#define _MMC_MMCIM1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCIM_ADDR(1), _MMC_MMCIM_##Field,AND,OR,INV)



/*--------------------- Register: MMCTOR -----------------------*/
#define _MMC_MMCTOR_GET(devNum)			  _PREG_GET(_MMC_MMCTOR_ADDR(devNum)) 
#define _MMC_MMCTOR_SET(devNum,Val)		  _PREG_SET(_MMC_MMCTOR_ADDR(devNum),Val)
#define _MMC_MMCTOR_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCTOR_ADDR(devNum), _MMC_MMCTOR_##Field)
#define _MMC_MMCTOR_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCTOR_ADDR(devNum), _MMC_MMCTOR_##Field, Val)
#define _MMC_MMCTOR_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCTOR_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCTOR_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCTOR_ADDR(devNum), _MMC_MMCTOR_##Field,AND,OR,INV)

#define _MMC_MMCTOR0_GET		  _PREG_GET(_MMC_MMCTOR_ADDR(0)) 
#define _MMC_MMCTOR0_SET(Val)		  _PREG_SET(_MMC_MMCTOR_ADDR(0),Val)
#define _MMC_MMCTOR0_FGET(Field)	  _PFIELD_GET(_MMC_MMCTOR_ADDR(0), _MMC_MMCTOR_##Field)
#define _MMC_MMCTOR0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCTOR_ADDR(0), _MMC_MMCTOR_##Field, Val)
#define _MMC_MMCTOR0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCTOR_ADDR(0),AND,OR,INV)
#define _MMC_MMCTOR0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCTOR_ADDR(0), _MMC_MMCTOR_##Field,AND,OR,INV)

#define _MMC_MMCTOR1_GET		  _PREG_GET(_MMC_MMCTOR_ADDR(1)) 
#define _MMC_MMCTOR1_SET(Val)		  _PREG_SET(_MMC_MMCTOR_ADDR(1),Val)
#define _MMC_MMCTOR1_FGET(Field)	  _PFIELD_GET(_MMC_MMCTOR_ADDR(1), _MMC_MMCTOR_##Field)
#define _MMC_MMCTOR1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCTOR_ADDR(1), _MMC_MMCTOR_##Field, Val)
#define _MMC_MMCTOR1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCTOR_ADDR(1),AND,OR,INV)
#define _MMC_MMCTOR1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCTOR_ADDR(1), _MMC_MMCTOR_##Field,AND,OR,INV)


/*--------------------- Register: MMCTOD -----------------------*/
#define _MMC_MMCTOD_GET(devNum)			  _PREG_GET(_MMC_MMCTOD_ADDR(devNum)) 
#define _MMC_MMCTOD_SET(devNum,Val)		  _PREG_SET(_MMC_MMCTOD_ADDR(devNum),Val)
#define _MMC_MMCTOD_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCTOD_ADDR(devNum), _MMC_MMCTOD_##Field)
#define _MMC_MMCTOD_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCTOD_ADDR(devNum), _MMC_MMCTOD_##Field, Val)
#define _MMC_MMCTOD_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCTOD_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCTOD_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCTOD_ADDR(devNum), _MMC_MMCTOD_##Field,AND,OR,INV)

#define _MMC_MMCTOD0_GET		  _PREG_GET(_MMC_MMCTOD_ADDR(0)) 
#define _MMC_MMCTOD0_SET(Val)		  _PREG_SET(_MMC_MMCTOD_ADDR(0),Val)
#define _MMC_MMCTOD0_FGET(Field)	  _PFIELD_GET(_MMC_MMCTOD_ADDR(0), _MMC_MMCTOD_##Field)
#define _MMC_MMCTOD0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCTOD_ADDR(0), _MMC_MMCTOD_##Field, Val)
#define _MMC_MMCTOD0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCTOD_ADDR(0),AND,OR,INV)
#define _MMC_MMCTOD0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCTOD_ADDR(0), _MMC_MMCTOD_##Field,AND,OR,INV)

#define _MMC_MMCTOD1_GET		  _PREG_GET(_MMC_MMCTOD_ADDR(1)) 
#define _MMC_MMCTOD1_SET(Val)		  _PREG_SET(_MMC_MMCTOD_ADDR(1),Val)
#define _MMC_MMCTOD1_FGET(Field)	  _PFIELD_GET(_MMC_MMCTOD_ADDR(1), _MMC_MMCTOD_##Field)
#define _MMC_MMCTOD1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCTOD_ADDR(1), _MMC_MMCTOD_##Field, Val)
#define _MMC_MMCTOD1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCTOD_ADDR(1),AND,OR,INV)
#define _MMC_MMCTOD1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCTOD_ADDR(1), _MMC_MMCTOD_##Field,AND,OR,INV)


/*--------------------- Register: MMCBLEN -----------------------*/
#define _MMC_MMCBLEN_GET(devNum)			  _PREG_GET(_MMC_MMCBLEN_ADDR(devNum)) 
#define _MMC_MMCBLEN_SET(devNum,Val)		  _PREG_SET(_MMC_MMCBLEN_ADDR(devNum),Val)
#define _MMC_MMCBLEN_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCBLEN_ADDR(devNum), _MMC_MMCBLEN_##Field)
#define _MMC_MMCBLEN_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCBLEN_ADDR(devNum), _MMC_MMCBLEN_##Field, Val)
#define _MMC_MMCBLEN_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCBLEN_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCBLEN_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCBLEN_ADDR(devNum), _MMC_MMCBLEN_##Field,AND,OR,INV)

#define _MMC_MMCBLEN0_GET		  _PREG_GET(_MMC_MMCBLEN_ADDR(0)) 
#define _MMC_MMCBLEN0_SET(Val)		  _PREG_SET(_MMC_MMCBLEN_ADDR(0),Val)
#define _MMC_MMCBLEN0_FGET(Field)	  _PFIELD_GET(_MMC_MMCBLEN_ADDR(0), _MMC_MMCBLEN_##Field)
#define _MMC_MMCBLEN0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCBLEN_ADDR(0), _MMC_MMCBLEN_##Field, Val)
#define _MMC_MMCBLEN0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCBLEN_ADDR(0),AND,OR,INV)
#define _MMC_MMCBLEN0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCBLEN_ADDR(0), _MMC_MMCBLEN_##Field,AND,OR,INV)

#define _MMC_MMCBLEN1_GET		  _PREG_GET(_MMC_MMCBLEN_ADDR(1)) 
#define _MMC_MMCBLEN1_SET(Val)		  _PREG_SET(_MMC_MMCBLEN_ADDR(1),Val)
#define _MMC_MMCBLEN1_FGET(Field)	  _PFIELD_GET(_MMC_MMCBLEN_ADDR(1), _MMC_MMCBLEN_##Field)
#define _MMC_MMCBLEN1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCBLEN_ADDR(1), _MMC_MMCBLEN_##Field, Val)
#define _MMC_MMCBLEN1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCBLEN_ADDR(1),AND,OR,INV)
#define _MMC_MMCBLEN1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCBLEN_ADDR(1), _MMC_MMCBLEN_##Field,AND,OR,INV)


/*--------------------- Register: MMCNBLK -----------------------*/
#define _MMC_MMCNBLK_GET(devNum)			  _PREG_GET(_MMC_MMCNBLK_ADDR(devNum)) 
#define _MMC_MMCNBLK_SET(devNum,Val)		  _PREG_SET(_MMC_MMCNBLK_ADDR(devNum),Val)
#define _MMC_MMCNBLK_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCNBLK_ADDR(devNum), _MMC_MMCNBLK_##Field)
#define _MMC_MMCNBLK_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCNBLK_ADDR(devNum), _MMC_MMCNBLK_##Field, Val)
#define _MMC_MMCNBLK_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCNBLK_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCNBLK_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCNBLK_ADDR(devNum), _MMC_MMCNBLK_##Field,AND,OR,INV)

#define _MMC_MMCNBLK0_GET		  _PREG_GET(_MMC_MMCNBLK_ADDR(0)) 
#define _MMC_MMCNBLK0_SET(Val)		  _PREG_SET(_MMC_MMCNBLK_ADDR(0),Val)
#define _MMC_MMCNBLK0_FGET(Field)	  _PFIELD_GET(_MMC_MMCNBLK_ADDR(0), _MMC_MMCNBLK_##Field)
#define _MMC_MMCNBLK0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCNBLK_ADDR(0), _MMC_MMCNBLK_##Field, Val)
#define _MMC_MMCNBLK0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCNBLK_ADDR(0),AND,OR,INV)
#define _MMC_MMCNBLK0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCNBLK_ADDR(0), _MMC_MMCNBLK_##Field,AND,OR,INV)

#define _MMC_MMCNBLK1_GET		  _PREG_GET(_MMC_MMCNBLK_ADDR(1)) 
#define _MMC_MMCNBLK1_SET(Val)		  _PREG_SET(_MMC_MMCNBLK_ADDR(1),Val)
#define _MMC_MMCNBLK1_FGET(Field)	  _PFIELD_GET(_MMC_MMCNBLK_ADDR(1), _MMC_MMCNBLK_##Field)
#define _MMC_MMCNBLK1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCNBLK_ADDR(1), _MMC_MMCNBLK_##Field, Val)
#define _MMC_MMCNBLK1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCNBLK_ADDR(1),AND,OR,INV)
#define _MMC_MMCNBLK1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCNBLK_ADDR(1), _MMC_MMCNBLK_##Field,AND,OR,INV)


/*--------------------- Register: MMCST0 -----------------------*/
#define _MMC_MMCST0_GET(devNum)			  _PREG_GET(_MMC_MMCST0_ADDR(devNum)) 
#define _MMC_MMCST0_SET(devNum,Val)		  _PREG_SET(_MMC_MMCST0_ADDR(devNum),Val)
#define _MMC_MMCST0_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCST0_ADDR(devNum), _MMC_MMCST0_##Field)
#define _MMC_MMCST0_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCST0_ADDR(devNum), _MMC_MMCST0_##Field, Val)
#define _MMC_MMCST0_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCST0_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCST0_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCST0_ADDR(devNum), _MMC_MMCST0_##Field,AND,OR,INV)

#define _MMC_MMCST00_GET		  _PREG_GET(_MMC_MMCST0_ADDR(0)) 
#define _MMC_MMCST00_SET(Val)		  _PREG_SET(_MMC_MMCST0_ADDR(0),Val)
#define _MMC_MMCST00_FGET(Field)	  _PFIELD_GET(_MMC_MMCST0_ADDR(0), _MMC_MMCST0_##Field)
#define _MMC_MMCST00_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCST0_ADDR(0), _MMC_MMCST0_##Field, Val)
#define _MMC_MMCST00_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCST0_ADDR(0),AND,OR,INV)
#define _MMC_MMCST00_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCST0_ADDR(0), _MMC_MMCST0_##Field,AND,OR,INV)

#define _MMC_MMCST01_GET		  _PREG_GET(_MMC_MMCST0_ADDR(1)) 
#define _MMC_MMCST01_SET(Val)		  _PREG_SET(_MMC_MMCST0_ADDR(1),Val)
#define _MMC_MMCST01_FGET(Field)	  _PFIELD_GET(_MMC_MMCST0_ADDR(1), _MMC_MMCST0_##Field)
#define _MMC_MMCST01_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCST0_ADDR(1), _MMC_MMCST0_##Field, Val)
#define _MMC_MMCST01_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCST0_ADDR(1),AND,OR,INV)
#define _MMC_MMCST01_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCST0_ADDR(1), _MMC_MMCST0_##Field,AND,OR,INV)


/*--------------------- Register: MMCST1 -----------------------*/
#define _MMC_MMCST1_GET(devNum)			  _PREG_GET(_MMC_MMCST1_ADDR(devNum)) 
#define _MMC_MMCST1_SET(devNum,Val)		  _PREG_SET(_MMC_MMCST1_ADDR(devNum),Val)
#define _MMC_MMCST1_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCST1_ADDR(devNum), _MMC_MMCST1_##Field)
#define _MMC_MMCST1_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCST1_ADDR(devNum), _MMC_MMCST1_##Field, Val)
#define _MMC_MMCST1_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCST1_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCST1_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCST1_ADDR(devNum), _MMC_MMCST1_##Field,AND,OR,INV)

#define _MMC_MMCST10_GET		  _PREG_GET(_MMC_MMCST1_ADDR(0)) 
#define _MMC_MMCST10_SET(Val)		  _PREG_SET(_MMC_MMCST1_ADDR(0),Val)
#define _MMC_MMCST10_FGET(Field)	  _PFIELD_GET(_MMC_MMCST1_ADDR(0), _MMC_MMCST1_##Field)
#define _MMC_MMCST10_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCST1_ADDR(0), _MMC_MMCST1_##Field, Val)
#define _MMC_MMCST10_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCST1_ADDR(0),AND,OR,INV)
#define _MMC_MMCST10_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCST1_ADDR(0), _MMC_MMCST1_##Field,AND,OR,INV)

#define _MMC_MMCST11_GET		  _PREG_GET(_MMC_MMCST1_ADDR(1)) 
#define _MMC_MMCST11_SET(Val)		  _PREG_SET(_MMC_MMCST1_ADDR(1),Val)
#define _MMC_MMCST11_FGET(Field)	  _PFIELD_GET(_MMC_MMCST1_ADDR(1), _MMC_MMCST1_##Field)
#define _MMC_MMCST11_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCST1_ADDR(1), _MMC_MMCST1_##Field, Val)
#define _MMC_MMCST11_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCST1_ADDR(1),AND,OR,INV)
#define _MMC_MMCST11_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCST1_ADDR(1), _MMC_MMCST1_##Field,AND,OR,INV)


/*--------------------- Register: MMCNBLC -----------------------*/
#define _MMC_MMCNBLC_GET(devNum)			  _PREG_GET(_MMC_MMCNBLC_ADDR(devNum)) 
#define _MMC_MMCNBLC_SET(devNum,Val)		  _PREG_SET(_MMC_MMCNBLC_ADDR(devNum),Val)
#define _MMC_MMCNBLC_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCNBLC_ADDR(devNum), _MMC_MMCNBLC_##Field)
#define _MMC_MMCNBLC_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCNBLC_ADDR(devNum), _MMC_MMCNBLC_##Field, Val)
#define _MMC_MMCNBLC_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCNBLC_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCNBLC_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCNBLC_ADDR(devNum), _MMC_MMCNBLC_##Field,AND,OR,INV)

#define _MMC_MMCNBLC0_GET		  _PREG_GET(_MMC_MMCNBLC_ADDR(0)) 
#define _MMC_MMCNBLC0_SET(Val)		  _PREG_SET(_MMC_MMCNBLC_ADDR(0),Val)
#define _MMC_MMCNBLC0_FGET(Field)	  _PFIELD_GET(_MMC_MMCNBLC_ADDR(0), _MMC_MMCNBLC_##Field)
#define _MMC_MMCNBLC0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCNBLC_ADDR(0), _MMC_MMCNBLC_##Field, Val)
#define _MMC_MMCNBLC0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCNBLC_ADDR(0),AND,OR,INV)
#define _MMC_MMCNBLC0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCNBLC_ADDR(0), _MMC_MMCNBLC_##Field,AND,OR,INV)

#define _MMC_MMCNBLC1_GET		  _PREG_GET(_MMC_MMCNBLC_ADDR(1)) 
#define _MMC_MMCNBLC1_SET(Val)		  _PREG_SET(_MMC_MMCNBLC_ADDR(1),Val)
#define _MMC_MMCNBLC1_FGET(Field)	  _PFIELD_GET(_MMC_MMCNBLC_ADDR(1), _MMC_MMCNBLC_##Field)
#define _MMC_MMCNBLC1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCNBLC_ADDR(1), _MMC_MMCNBLC_##Field, Val)
#define _MMC_MMCNBLC1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCNBLC_ADDR(1),AND,OR,INV)
#define _MMC_MMCNBLC1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCNBLC_ADDR(1), _MMC_MMCNBLC_##Field,AND,OR,INV)


/*--------------------- Register: MMCDRR -----------------------*/
#define _MMC_MMCDRR_GET(devNum)			  _PREG_GET(_MMC_MMCDRR_ADDR(devNum)) 
#define _MMC_MMCDRR_SET(devNum,Val)		  _PREG_SET(_MMC_MMCDRR_ADDR(devNum),Val)
#define _MMC_MMCDRR_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCDRR_ADDR(devNum), _MMC_MMCDRR_##Field)
#define _MMC_MMCDRR_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCDRR_ADDR(devNum), _MMC_MMCDRR_##Field, Val)
#define _MMC_MMCDRR_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCDRR_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCDRR_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCDRR_ADDR(devNum), _MMC_MMCDRR_##Field,AND,OR,INV)

#define _MMC_MMCDRR0_GET		  _PREG_GET(_MMC_MMCDRR_ADDR(0)) 
#define _MMC_MMCDRR0_SET(Val)		  _PREG_SET(_MMC_MMCDRR_ADDR(0),Val)
#define _MMC_MMCDRR0_FGET(Field)	  _PFIELD_GET(_MMC_MMCDRR_ADDR(0), _MMC_MMCDRR_##Field)
#define _MMC_MMCDRR0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCDRR_ADDR(0), _MMC_MMCDRR_##Field, Val)
#define _MMC_MMCDRR0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCDRR_ADDR(0),AND,OR,INV)
#define _MMC_MMCDRR0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCDRR_ADDR(0), _MMC_MMCDRR_##Field,AND,OR,INV)

#define _MMC_MMCDRR1_GET		  _PREG_GET(_MMC_MMCDRR_ADDR(1)) 
#define _MMC_MMCDRR1_SET(Val)		  _PREG_SET(_MMC_MMCDRR_ADDR(1),Val)
#define _MMC_MMCDRR1_FGET(Field)	  _PFIELD_GET(_MMC_MMCDRR_ADDR(1), _MMC_MMCDRR_##Field)
#define _MMC_MMCDRR1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCDRR_ADDR(1), _MMC_MMCDRR_##Field, Val)
#define _MMC_MMCDRR1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCDRR_ADDR(1),AND,OR,INV)
#define _MMC_MMCDRR1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCDRR_ADDR(1), _MMC_MMCDRR_##Field,AND,OR,INV)


/*--------------------- Register: MMCDXR -----------------------*/
#define _MMC_MMCDXR_GET(devNum)			  _PREG_GET(_MMC_MMCDXR_ADDR(devNum)) 
#define _MMC_MMCDXR_SET(devNum,Val)		  _PREG_SET(_MMC_MMCDXR_ADDR(devNum),Val)
#define _MMC_MMCDXR_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCDXR_ADDR(devNum), _MMC_MMCDXR_##Field)
#define _MMC_MMCDXR_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCDXR_ADDR(devNum), _MMC_MMCDXR_##Field, Val)
#define _MMC_MMCDXR_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCDXR_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCDXR_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCDXR_ADDR(devNum), _MMC_MMCDXR_##Field,AND,OR,INV)

#define _MMC_MMCDXR0_GET		  _PREG_GET(_MMC_MMCDXR_ADDR(0)) 
#define _MMC_MMCDXR0_SET(Val)		  _PREG_SET(_MMC_MMCDXR_ADDR(0),Val)
#define _MMC_MMCDXR0_FGET(Field)	  _PFIELD_GET(_MMC_MMCDXR_ADDR(0), _MMC_MMCDXR_##Field)
#define _MMC_MMCDXR0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCDXR_ADDR(0), _MMC_MMCDXR_##Field, Val)
#define _MMC_MMCDXR0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCDXR_ADDR(0),AND,OR,INV)
#define _MMC_MMCDXR0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCDXR_ADDR(0), _MMC_MMCDXR_##Field,AND,OR,INV)

#define _MMC_MMCDXR1_GET		  _PREG_GET(_MMC_MMCDXR_ADDR(1)) 
#define _MMC_MMCDXR1_SET(Val)		  _PREG_SET(_MMC_MMCDXR_ADDR(1),Val)
#define _MMC_MMCDXR1_FGET(Field)	  _PFIELD_GET(_MMC_MMCDXR_ADDR(1), _MMC_MMCDXR_##Field)
#define _MMC_MMCDXR1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCDXR_ADDR(1), _MMC_MMCDXR_##Field, Val)
#define _MMC_MMCDXR1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCDXR_ADDR(1),AND,OR,INV)
#define _MMC_MMCDXR1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCDXR_ADDR(1), _MMC_MMCDXR_##Field,AND,OR,INV)


/*--------------------- Register: MMCCMD -----------------------*/
#define _MMC_MMCCMD_GET(devNum)			  _PREG_GET(_MMC_MMCCMD_ADDR(devNum)) 
#define _MMC_MMCCMD_SET(devNum,Val)		  _PREG_SET(_MMC_MMCCMD_ADDR(devNum),Val)
#define _MMC_MMCCMD_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCCMD_ADDR(devNum), _MMC_MMCCMD_##Field)
#define _MMC_MMCCMD_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCCMD_ADDR(devNum), _MMC_MMCCMD_##Field, Val)
#define _MMC_MMCCMD_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCCMD_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCCMD_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCMD_ADDR(devNum), _MMC_MMCCMD_##Field,AND,OR,INV)

#define _MMC_MMCCMD0_GET		  _PREG_GET(_MMC_MMCCMD_ADDR(0)) 
#define _MMC_MMCCMD0_SET(Val)		  _PREG_SET(_MMC_MMCCMD_ADDR(0),Val)
#define _MMC_MMCCMD0_FGET(Field)	  _PFIELD_GET(_MMC_MMCCMD_ADDR(0), _MMC_MMCCMD_##Field)
#define _MMC_MMCCMD0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCCMD_ADDR(0), _MMC_MMCCMD_##Field, Val)
#define _MMC_MMCCMD0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCCMD_ADDR(0),AND,OR,INV)
#define _MMC_MMCCMD0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCMD_ADDR(0), _MMC_MMCCMD_##Field,AND,OR,INV)

#define _MMC_MMCCMD1_GET		  _PREG_GET(_MMC_MMCCMD_ADDR(1)) 
#define _MMC_MMCCMD1_SET(Val)		  _PREG_SET(_MMC_MMCCMD_ADDR(1),Val)
#define _MMC_MMCCMD1_FGET(Field)	  _PFIELD_GET(_MMC_MMCCMD_ADDR(1), _MMC_MMCCMD_##Field)
#define _MMC_MMCCMD1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCCMD_ADDR(1), _MMC_MMCCMD_##Field, Val)
#define _MMC_MMCCMD1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCCMD_ADDR(1),AND,OR,INV)
#define _MMC_MMCCMD1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCMD_ADDR(1), _MMC_MMCCMD_##Field,AND,OR,INV)


/*--------------------- Register: MMCARGL -----------------------*/
#define _MMC_MMCARGL_GET(devNum)			  _PREG_GET(_MMC_MMCARGL_ADDR(devNum)) 
#define _MMC_MMCARGL_SET(devNum,Val)		  _PREG_SET(_MMC_MMCARGL_ADDR(devNum),Val)
#define _MMC_MMCARGL_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCARGL_ADDR(devNum), _MMC_MMCARGL_##Field)
#define _MMC_MMCARGL_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCARGL_ADDR(devNum), _MMC_MMCARGL_##Field, Val)
#define _MMC_MMCARGL_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCARGL_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCARGL_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCARGL_ADDR(devNum), _MMC_MMCARGL_##Field,AND,OR,INV)

#define _MMC_MMCARGL0_GET		  _PREG_GET(_MMC_MMCARGL_ADDR(0)) 
#define _MMC_MMCARGL0_SET(Val)		  _PREG_SET(_MMC_MMCARGL_ADDR(0),Val)
#define _MMC_MMCARGL0_FGET(Field)	  _PFIELD_GET(_MMC_MMCARGL_ADDR(0), _MMC_MMCARGL_##Field)
#define _MMC_MMCARGL0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCARGL_ADDR(0), _MMC_MMCARGL_##Field, Val)
#define _MMC_MMCARGL0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCARGL_ADDR(0),AND,OR,INV)
#define _MMC_MMCARGL0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCARGL_ADDR(0), _MMC_MMCARGL_##Field,AND,OR,INV)

#define _MMC_MMCARGL1_GET		  _PREG_GET(_MMC_MMCARGL_ADDR(1)) 
#define _MMC_MMCARGL1_SET(Val)		  _PREG_SET(_MMC_MMCARGL_ADDR(1),Val)
#define _MMC_MMCARGL1_FGET(Field)	  _PFIELD_GET(_MMC_MMCARGL_ADDR(1), _MMC_MMCARGL_##Field)
#define _MMC_MMCARGL1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCARGL_ADDR(1), _MMC_MMCARGL_##Field, Val)
#define _MMC_MMCARGL1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCARGL_ADDR(1),AND,OR,INV)
#define _MMC_MMCARGL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCARGL_ADDR(1), _MMC_MMCARGL_##Field,AND,OR,INV)


/*--------------------- Register: MMCARGH -----------------------*/
#define _MMC_MMCARGH_GET(devNum)			  _PREG_GET(_MMC_MMCARGH_ADDR(devNum)) 
#define _MMC_MMCARGH_SET(devNum,Val)		  _PREG_SET(_MMC_MMCARGH_ADDR(devNum),Val)
#define _MMC_MMCARGH_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCARGH_ADDR(devNum), _MMC_MMCARGH_##Field)
#define _MMC_MMCARGH_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCARGH_ADDR(devNum), _MMC_MMCARGH_##Field, Val)
#define _MMC_MMCARGH_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCARGH_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCARGH_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCARGH_ADDR(devNum), _MMC_MMCARGH_##Field,AND,OR,INV)

#define _MMC_MMCARGH0_GET		  _PREG_GET(_MMC_MMCARGH_ADDR(0)) 
#define _MMC_MMCARGH0_SET(Val)		  _PREG_SET(_MMC_MMCARGH_ADDR(0),Val)
#define _MMC_MMCARGH0_FGET(Field)	  _PFIELD_GET(_MMC_MMCARGH_ADDR(0), _MMC_MMCARGH_##Field)
#define _MMC_MMCARGH0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCARGH_ADDR(0), _MMC_MMCARGH_##Field, Val)
#define _MMC_MMCARGH0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCARGH_ADDR(0),AND,OR,INV)
#define _MMC_MMCARGH0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCARGH_ADDR(0), _MMC_MMCARGH_##Field,AND,OR,INV)

#define _MMC_MMCARGH1_GET		  _PREG_GET(_MMC_MMCARGH_ADDR(1)) 
#define _MMC_MMCARGH1_SET(Val)		  _PREG_SET(_MMC_MMCARGH_ADDR(1),Val)
#define _MMC_MMCARGH1_FGET(Field)	  _PFIELD_GET(_MMC_MMCARGH_ADDR(1), _MMC_MMCARGH_##Field)
#define _MMC_MMCARGH1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCARGH_ADDR(1), _MMC_MMCARGH_##Field, Val)
#define _MMC_MMCARGH1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCARGH_ADDR(1),AND,OR,INV)
#define _MMC_MMCARGH1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCARGH_ADDR(1), _MMC_MMCARGH_##Field,AND,OR,INV)


/*--------------------- Register: MMCRSP0 -----------------------*/
#define _MMC_MMCRSP0_GET(devNum)			  _PREG_GET(_MMC_MMCRSP0_ADDR(devNum)) 
#define _MMC_MMCRSP0_SET(devNum,Val)		  _PREG_SET(_MMC_MMCRSP0_ADDR(devNum),Val)
#define _MMC_MMCRSP0_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCRSP0_ADDR(devNum), _MMC_MMCRSP0_##Field)
#define _MMC_MMCRSP0_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCRSP0_ADDR(devNum), _MMC_MMCRSP0_##Field, Val)
#define _MMC_MMCRSP0_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP0_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCRSP0_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP0_ADDR(devNum), _MMC_MMCRSP0_##Field,AND,OR,INV)

#define _MMC_MMCRSP00_GET		  _PREG_GET(_MMC_MMCRSP0_ADDR(0)) 
#define _MMC_MMCRSP00_SET(Val)		  _PREG_SET(_MMC_MMCRSP0_ADDR(0),Val)
#define _MMC_MMCRSP00_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP0_ADDR(0), _MMC_MMCRSP0_##Field)
#define _MMC_MMCRSP00_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP0_ADDR(0), _MMC_MMCRSP0_##Field, Val)
#define _MMC_MMCRSP00_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP0_ADDR(0),AND,OR,INV)
#define _MMC_MMCRSP00_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP0_ADDR(0), _MMC_MMCRSP0_##Field,AND,OR,INV)

#define _MMC_MMCRSP01_GET		  _PREG_GET(_MMC_MMCRSP0_ADDR(1)) 
#define _MMC_MMCRSP01_SET(Val)		  _PREG_SET(_MMC_MMCRSP0_ADDR(1),Val)
#define _MMC_MMCRSP01_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP0_ADDR(1), _MMC_MMCRSP0_##Field)
#define _MMC_MMCRSP01_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP0_ADDR(1), _MMC_MMCRSP0_##Field, Val)
#define _MMC_MMCRSP01_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP0_ADDR(1),AND,OR,INV)
#define _MMC_MMCRSP01_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP0_ADDR(1), _MMC_MMCRSP0_##Field,AND,OR,INV)


/*--------------------- Register: MMCRSP0 -----------------------*/
#define _MMC_MMCRSP0_GET(devNum)			  _PREG_GET(_MMC_MMCRSP0_ADDR(devNum)) 
#define _MMC_MMCRSP0_SET(devNum,Val)		  _PREG_SET(_MMC_MMCRSP0_ADDR(devNum),Val)
#define _MMC_MMCRSP0_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCRSP0_ADDR(devNum), _MMC_MMCRSP0_##Field)
#define _MMC_MMCRSP0_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCRSP0_ADDR(devNum), _MMC_MMCRSP0_##Field, Val)
#define _MMC_MMCRSP0_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP0_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCRSP0_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP0_ADDR(devNum), _MMC_MMCRSP0_##Field,AND,OR,INV)

#define _MMC_MMCRSP00_GET		  _PREG_GET(_MMC_MMCRSP0_ADDR(0)) 
#define _MMC_MMCRSP00_SET(Val)		  _PREG_SET(_MMC_MMCRSP0_ADDR(0),Val)
#define _MMC_MMCRSP00_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP0_ADDR(0), _MMC_MMCRSP0_##Field)
#define _MMC_MMCRSP00_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP0_ADDR(0), _MMC_MMCRSP0_##Field, Val)
#define _MMC_MMCRSP00_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP0_ADDR(0),AND,OR,INV)
#define _MMC_MMCRSP00_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP0_ADDR(0), _MMC_MMCRSP0_##Field,AND,OR,INV)

#define _MMC_MMCRSP01_GET		  _PREG_GET(_MMC_MMCRSP0_ADDR(1)) 
#define _MMC_MMCRSP01_SET(Val)		  _PREG_SET(_MMC_MMCRSP0_ADDR(1),Val)
#define _MMC_MMCRSP01_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP0_ADDR(1), _MMC_MMCRSP0_##Field)
#define _MMC_MMCRSP01_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP0_ADDR(1), _MMC_MMCRSP0_##Field, Val)
#define _MMC_MMCRSP01_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP0_ADDR(1),AND,OR,INV)
#define _MMC_MMCRSP01_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP0_ADDR(1), _MMC_MMCRSP0_##Field,AND,OR,INV)


/*--------------------- Register: MMCRSP1 -----------------------*/
#define _MMC_MMCRSP1_GET(devNum)			  _PREG_GET(_MMC_MMCRSP1_ADDR(devNum)) 
#define _MMC_MMCRSP1_SET(devNum,Val)		  _PREG_SET(_MMC_MMCRSP1_ADDR(devNum),Val)
#define _MMC_MMCRSP1_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCRSP1_ADDR(devNum), _MMC_MMCRSP1_##Field)
#define _MMC_MMCRSP1_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCRSP1_ADDR(devNum), _MMC_MMCRSP1_##Field, Val)
#define _MMC_MMCRSP1_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP1_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCRSP1_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP1_ADDR(devNum), _MMC_MMCRSP1_##Field,AND,OR,INV)

#define _MMC_MMCRSP10_GET		  _PREG_GET(_MMC_MMCRSP1_ADDR(0)) 
#define _MMC_MMCRSP10_SET(Val)		  _PREG_SET(_MMC_MMCRSP1_ADDR(0),Val)
#define _MMC_MMCRSP10_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP1_ADDR(0), _MMC_MMCRSP1_##Field)
#define _MMC_MMCRSP10_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP1_ADDR(0), _MMC_MMCRSP1_##Field, Val)
#define _MMC_MMCRSP10_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP1_ADDR(0),AND,OR,INV)
#define _MMC_MMCRSP10_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP1_ADDR(0), _MMC_MMCRSP1_##Field,AND,OR,INV)

#define _MMC_MMCRSP11_GET		  _PREG_GET(_MMC_MMCRSP1_ADDR(1)) 
#define _MMC_MMCRSP11_SET(Val)		  _PREG_SET(_MMC_MMCRSP1_ADDR(1),Val)
#define _MMC_MMCRSP11_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP1_ADDR(1), _MMC_MMCRSP1_##Field)
#define _MMC_MMCRSP11_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP1_ADDR(1), _MMC_MMCRSP1_##Field, Val)
#define _MMC_MMCRSP11_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP1_ADDR(1),AND,OR,INV)
#define _MMC_MMCRSP11_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP1_ADDR(1), _MMC_MMCRSP1_##Field,AND,OR,INV)


/*--------------------- Register: MMCRSP2 -----------------------*/
#define _MMC_MMCRSP2_GET(devNum)			  _PREG_GET(_MMC_MMCRSP2_ADDR(devNum)) 
#define _MMC_MMCRSP2_SET(devNum,Val)		  _PREG_SET(_MMC_MMCRSP2_ADDR(devNum),Val)
#define _MMC_MMCRSP2_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCRSP2_ADDR(devNum), _MMC_MMCRSP2_##Field)
#define _MMC_MMCRSP2_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCRSP2_ADDR(devNum), _MMC_MMCRSP2_##Field, Val)
#define _MMC_MMCRSP2_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP2_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCRSP2_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP2_ADDR(devNum), _MMC_MMCRSP2_##Field,AND,OR,INV)

#define _MMC_MMCRSP20_GET		  _PREG_GET(_MMC_MMCRSP2_ADDR(0)) 
#define _MMC_MMCRSP20_SET(Val)		  _PREG_SET(_MMC_MMCRSP2_ADDR(0),Val)
#define _MMC_MMCRSP20_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP2_ADDR(0), _MMC_MMCRSP2_##Field)
#define _MMC_MMCRSP20_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP2_ADDR(0), _MMC_MMCRSP2_##Field, Val)
#define _MMC_MMCRSP20_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP2_ADDR(0),AND,OR,INV)
#define _MMC_MMCRSP20_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP2_ADDR(0), _MMC_MMCRSP2_##Field,AND,OR,INV)

#define _MMC_MMCRSP21_GET		  _PREG_GET(_MMC_MMCRSP2_ADDR(1)) 
#define _MMC_MMCRSP21_SET(Val)		  _PREG_SET(_MMC_MMCRSP2_ADDR(1),Val)
#define _MMC_MMCRSP21_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP2_ADDR(1), _MMC_MMCRSP2_##Field)
#define _MMC_MMCRSP21_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP2_ADDR(1), _MMC_MMCRSP2_##Field, Val)
#define _MMC_MMCRSP21_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP2_ADDR(1),AND,OR,INV)
#define _MMC_MMCRSP21_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP2_ADDR(1), _MMC_MMCRSP2_##Field,AND,OR,INV)


/*--------------------- Register: MMCRSP3 -----------------------*/
#define _MMC_MMCRSP3_GET(devNum)			  _PREG_GET(_MMC_MMCRSP3_ADDR(devNum)) 
#define _MMC_MMCRSP3_SET(devNum,Val)		  _PREG_SET(_MMC_MMCRSP3_ADDR(devNum),Val)
#define _MMC_MMCRSP3_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCRSP3_ADDR(devNum), _MMC_MMCRSP3_##Field)
#define _MMC_MMCRSP3_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCRSP3_ADDR(devNum), _MMC_MMCRSP3_##Field, Val)
#define _MMC_MMCRSP3_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP3_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCRSP3_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP3_ADDR(devNum), _MMC_MMCRSP3_##Field,AND,OR,INV)

#define _MMC_MMCRSP30_GET		  _PREG_GET(_MMC_MMCRSP3_ADDR(0)) 
#define _MMC_MMCRSP30_SET(Val)		  _PREG_SET(_MMC_MMCRSP3_ADDR(0),Val)
#define _MMC_MMCRSP30_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP3_ADDR(0), _MMC_MMCRSP3_##Field)
#define _MMC_MMCRSP30_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP3_ADDR(0), _MMC_MMCRSP3_##Field, Val)
#define _MMC_MMCRSP30_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP3_ADDR(0),AND,OR,INV)
#define _MMC_MMCRSP30_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP3_ADDR(0), _MMC_MMCRSP3_##Field,AND,OR,INV)

#define _MMC_MMCRSP31_GET		  _PREG_GET(_MMC_MMCRSP3_ADDR(1)) 
#define _MMC_MMCRSP31_SET(Val)		  _PREG_SET(_MMC_MMCRSP3_ADDR(1),Val)
#define _MMC_MMCRSP31_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP3_ADDR(1), _MMC_MMCRSP3_##Field)
#define _MMC_MMCRSP31_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP3_ADDR(1), _MMC_MMCRSP3_##Field, Val)
#define _MMC_MMCRSP31_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP3_ADDR(1),AND,OR,INV)
#define _MMC_MMCRSP31_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP3_ADDR(1), _MMC_MMCRSP3_##Field,AND,OR,INV)


/*--------------------- Register: MMCRSP4 -----------------------*/
#define _MMC_MMCRSP4_GET(devNum)			  _PREG_GET(_MMC_MMCRSP4_ADDR(devNum)) 
#define _MMC_MMCRSP4_SET(devNum,Val)		  _PREG_SET(_MMC_MMCRSP4_ADDR(devNum),Val)
#define _MMC_MMCRSP4_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCRSP4_ADDR(devNum), _MMC_MMCRSP4_##Field)
#define _MMC_MMCRSP4_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCRSP4_ADDR(devNum), _MMC_MMCRSP4_##Field, Val)
#define _MMC_MMCRSP4_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP4_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCRSP4_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP4_ADDR(devNum), _MMC_MMCRSP4_##Field,AND,OR,INV)

#define _MMC_MMCRSP40_GET		  _PREG_GET(_MMC_MMCRSP4_ADDR(0)) 
#define _MMC_MMCRSP40_SET(Val)		  _PREG_SET(_MMC_MMCRSP4_ADDR(0),Val)
#define _MMC_MMCRSP40_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP4_ADDR(0), _MMC_MMCRSP4_##Field)
#define _MMC_MMCRSP40_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP4_ADDR(0), _MMC_MMCRSP4_##Field, Val)
#define _MMC_MMCRSP40_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP4_ADDR(0),AND,OR,INV)
#define _MMC_MMCRSP40_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP4_ADDR(0), _MMC_MMCRSP4_##Field,AND,OR,INV)

#define _MMC_MMCRSP41_GET		  _PREG_GET(_MMC_MMCRSP4_ADDR(1)) 
#define _MMC_MMCRSP41_SET(Val)		  _PREG_SET(_MMC_MMCRSP4_ADDR(1),Val)
#define _MMC_MMCRSP41_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP4_ADDR(1), _MMC_MMCRSP4_##Field)
#define _MMC_MMCRSP41_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP4_ADDR(1), _MMC_MMCRSP4_##Field, Val)
#define _MMC_MMCRSP41_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP4_ADDR(1),AND,OR,INV)
#define _MMC_MMCRSP41_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP4_ADDR(1), _MMC_MMCRSP4_##Field,AND,OR,INV)


/*--------------------- Register: MMCRSP5 -----------------------*/
#define _MMC_MMCRSP5_GET(devNum)			  _PREG_GET(_MMC_MMCRSP5_ADDR(devNum)) 
#define _MMC_MMCRSP5_SET(devNum,Val)		  _PREG_SET(_MMC_MMCRSP5_ADDR(devNum),Val)
#define _MMC_MMCRSP5_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCRSP5_ADDR(devNum), _MMC_MMCRSP5_##Field)
#define _MMC_MMCRSP5_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCRSP5_ADDR(devNum), _MMC_MMCRSP5_##Field, Val)
#define _MMC_MMCRSP5_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP5_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCRSP5_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP5_ADDR(devNum), _MMC_MMCRSP5_##Field,AND,OR,INV)

#define _MMC_MMCRSP50_GET		  _PREG_GET(_MMC_MMCRSP5_ADDR(0)) 
#define _MMC_MMCRSP50_SET(Val)		  _PREG_SET(_MMC_MMCRSP5_ADDR(0),Val)
#define _MMC_MMCRSP50_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP5_ADDR(0), _MMC_MMCRSP5_##Field)
#define _MMC_MMCRSP50_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP5_ADDR(0), _MMC_MMCRSP5_##Field, Val)
#define _MMC_MMCRSP50_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP5_ADDR(0),AND,OR,INV)
#define _MMC_MMCRSP50_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP5_ADDR(0), _MMC_MMCRSP5_##Field,AND,OR,INV)

#define _MMC_MMCRSP51_GET		  _PREG_GET(_MMC_MMCRSP5_ADDR(1)) 
#define _MMC_MMCRSP51_SET(Val)		  _PREG_SET(_MMC_MMCRSP5_ADDR(1),Val)
#define _MMC_MMCRSP51_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP5_ADDR(1), _MMC_MMCRSP5_##Field)
#define _MMC_MMCRSP51_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP5_ADDR(1), _MMC_MMCRSP5_##Field, Val)
#define _MMC_MMCRSP51_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP5_ADDR(1),AND,OR,INV)
#define _MMC_MMCRSP51_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP5_ADDR(1), _MMC_MMCRSP5_##Field,AND,OR,INV)


/*--------------------- Register: MMCRSP6 -----------------------*/
#define _MMC_MMCRSP6_GET(devNum)			  _PREG_GET(_MMC_MMCRSP6_ADDR(devNum)) 
#define _MMC_MMCRSP6_SET(devNum,Val)		  _PREG_SET(_MMC_MMCRSP6_ADDR(devNum),Val)
#define _MMC_MMCRSP6_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCRSP6_ADDR(devNum), _MMC_MMCRSP6_##Field)
#define _MMC_MMCRSP6_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCRSP6_ADDR(devNum), _MMC_MMCRSP6_##Field, Val)
#define _MMC_MMCRSP6_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP6_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCRSP6_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP6_ADDR(devNum), _MMC_MMCRSP6_##Field,AND,OR,INV)

#define _MMC_MMCRSP60_GET		  _PREG_GET(_MMC_MMCRSP6_ADDR(0)) 
#define _MMC_MMCRSP60_SET(Val)		  _PREG_SET(_MMC_MMCRSP6_ADDR(0),Val)
#define _MMC_MMCRSP60_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP6_ADDR(0), _MMC_MMCRSP6_##Field)
#define _MMC_MMCRSP60_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP6_ADDR(0), _MMC_MMCRSP6_##Field, Val)
#define _MMC_MMCRSP60_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP6_ADDR(0),AND,OR,INV)
#define _MMC_MMCRSP60_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP6_ADDR(0), _MMC_MMCRSP6_##Field,AND,OR,INV)

#define _MMC_MMCRSP61_GET		  _PREG_GET(_MMC_MMCRSP6_ADDR(1)) 
#define _MMC_MMCRSP61_SET(Val)		  _PREG_SET(_MMC_MMCRSP6_ADDR(1),Val)
#define _MMC_MMCRSP61_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP6_ADDR(1), _MMC_MMCRSP6_##Field)
#define _MMC_MMCRSP61_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP6_ADDR(1), _MMC_MMCRSP6_##Field, Val)
#define _MMC_MMCRSP61_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP6_ADDR(1),AND,OR,INV)
#define _MMC_MMCRSP61_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP6_ADDR(1), _MMC_MMCRSP6_##Field,AND,OR,INV)


/*--------------------- Register: MMCRSP7 -----------------------*/
#define _MMC_MMCRSP7_GET(devNum)			  _PREG_GET(_MMC_MMCRSP7_ADDR(devNum)) 
#define _MMC_MMCRSP7_SET(devNum,Val)		  _PREG_SET(_MMC_MMCRSP7_ADDR(devNum),Val)
#define _MMC_MMCRSP7_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCRSP7_ADDR(devNum), _MMC_MMCRSP7_##Field)
#define _MMC_MMCRSP7_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCRSP7_ADDR(devNum), _MMC_MMCRSP7_##Field, Val)
#define _MMC_MMCRSP7_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP7_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCRSP7_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP7_ADDR(devNum), _MMC_MMCRSP7_##Field,AND,OR,INV)

#define _MMC_MMCRSP70_GET		  _PREG_GET(_MMC_MMCRSP7_ADDR(0)) 
#define _MMC_MMCRSP70_SET(Val)		  _PREG_SET(_MMC_MMCRSP7_ADDR(0),Val)
#define _MMC_MMCRSP70_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP7_ADDR(0), _MMC_MMCRSP7_##Field)
#define _MMC_MMCRSP70_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP7_ADDR(0), _MMC_MMCRSP7_##Field, Val)
#define _MMC_MMCRSP70_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP7_ADDR(0),AND,OR,INV)
#define _MMC_MMCRSP70_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP7_ADDR(0), _MMC_MMCRSP7_##Field,AND,OR,INV)

#define _MMC_MMCRSP71_GET		  _PREG_GET(_MMC_MMCRSP7_ADDR(1)) 
#define _MMC_MMCRSP71_SET(Val)		  _PREG_SET(_MMC_MMCRSP7_ADDR(1),Val)
#define _MMC_MMCRSP71_FGET(Field)	  _PFIELD_GET(_MMC_MMCRSP7_ADDR(1), _MMC_MMCRSP7_##Field)
#define _MMC_MMCRSP71_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCRSP7_ADDR(1), _MMC_MMCRSP7_##Field, Val)
#define _MMC_MMCRSP71_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCRSP7_ADDR(1),AND,OR,INV)
#define _MMC_MMCRSP71_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCRSP7_ADDR(1), _MMC_MMCRSP7_##Field,AND,OR,INV)


/*--------------------- Register: MMCDRSP -----------------------*/
#define _MMC_MMCDRSP_GET(devNum)			  _PREG_GET(_MMC_MMCDRSP_ADDR(devNum)) 
#define _MMC_MMCDRSP_SET(devNum,Val)		  _PREG_SET(_MMC_MMCDRSP_ADDR(devNum),Val)
#define _MMC_MMCDRSP_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCDRSP_ADDR(devNum), _MMC_MMCDRSP_##Field)
#define _MMC_MMCDRSP_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCDRSP_ADDR(devNum), _MMC_MMCDRSP_##Field, Val)
#define _MMC_MMCDRSP_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCDRSP_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCDRSP_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCDRSP_ADDR(devNum), _MMC_MMCDRSP_##Field,AND,OR,INV)

#define _MMC_MMCDRSP0_GET		  _PREG_GET(_MMC_MMCDRSP_ADDR(0)) 
#define _MMC_MMCDRSP0_SET(Val)		  _PREG_SET(_MMC_MMCDRSP_ADDR(0),Val)
#define _MMC_MMCDRSP0_FGET(Field)	  _PFIELD_GET(_MMC_MMCDRSP_ADDR(0), _MMC_MMCDRSP_##Field)
#define _MMC_MMCDRSP0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCDRSP_ADDR(0), _MMC_MMCDRSP_##Field, Val)
#define _MMC_MMCDRSP0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCDRSP_ADDR(0),AND,OR,INV)
#define _MMC_MMCDRSP0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCDRSP_ADDR(0), _MMC_MMCDRSP_##Field,AND,OR,INV)

#define _MMC_MMCDRSP1_GET		  _PREG_GET(_MMC_MMCDRSP_ADDR(1)) 
#define _MMC_MMCDRSP1_SET(Val)		  _PREG_SET(_MMC_MMCDRSP_ADDR(1),Val)
#define _MMC_MMCDRSP1_FGET(Field)	  _PFIELD_GET(_MMC_MMCDRSP_ADDR(1), _MMC_MMCDRSP_##Field)
#define _MMC_MMCDRSP1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCDRSP_ADDR(1), _MMC_MMCDRSP_##Field, Val)
#define _MMC_MMCDRSP1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCDRSP_ADDR(1),AND,OR,INV)
#define _MMC_MMCDRSP1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCDRSP_ADDR(1), _MMC_MMCDRSP_##Field,AND,OR,INV)


/*--------------------- Register: MMCETOK -----------------------*/
#define _MMC_MMCETOK_GET(devNum)			  _PREG_GET(_MMC_MMCETOK_ADDR(devNum)) 
#define _MMC_MMCETOK_SET(devNum,Val)		  _PREG_SET(_MMC_MMCETOK_ADDR(devNum),Val)
#define _MMC_MMCETOK_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCETOK_ADDR(devNum), _MMC_MMCETOK_##Field)
#define _MMC_MMCETOK_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCETOK_ADDR(devNum), _MMC_MMCETOK_##Field, Val)
#define _MMC_MMCETOK_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCETOK_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCETOK_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCETOK_ADDR(devNum), _MMC_MMCETOK_##Field,AND,OR,INV)

#define _MMC_MMCETOK0_GET		  _PREG_GET(_MMC_MMCETOK_ADDR(0)) 
#define _MMC_MMCETOK0_SET(Val)		  _PREG_SET(_MMC_MMCETOK_ADDR(0),Val)
#define _MMC_MMCETOK0_FGET(Field)	  _PFIELD_GET(_MMC_MMCETOK_ADDR(0), _MMC_MMCETOK_##Field)
#define _MMC_MMCETOK0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCETOK_ADDR(0), _MMC_MMCETOK_##Field, Val)
#define _MMC_MMCETOK0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCETOK_ADDR(0),AND,OR,INV)
#define _MMC_MMCETOK0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCETOK_ADDR(0), _MMC_MMCETOK_##Field,AND,OR,INV)

#define _MMC_MMCETOK1_GET		  _PREG_GET(_MMC_MMCETOK_ADDR(1)) 
#define _MMC_MMCETOK1_SET(Val)		  _PREG_SET(_MMC_MMCETOK_ADDR(1),Val)
#define _MMC_MMCETOK1_FGET(Field)	  _PFIELD_GET(_MMC_MMCETOK_ADDR(1), _MMC_MMCETOK_##Field)
#define _MMC_MMCETOK1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCETOK_ADDR(1), _MMC_MMCETOK_##Field, Val)
#define _MMC_MMCETOK1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCETOK_ADDR(1),AND,OR,INV)
#define _MMC_MMCETOK1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCETOK_ADDR(1), _MMC_MMCETOK_##Field,AND,OR,INV)


/*--------------------- Register: MMCCIDX -----------------------*/
#define _MMC_MMCCIDX_GET(devNum)			  _PREG_GET(_MMC_MMCCIDX_ADDR(devNum)) 
#define _MMC_MMCCIDX_SET(devNum,Val)		  _PREG_SET(_MMC_MMCCIDX_ADDR(devNum),Val)
#define _MMC_MMCCIDX_FGET(devNum,Field)	  _PFIELD_GET(_MMC_MMCCIDX_ADDR(devNum), _MMC_MMCCIDX_##Field)
#define _MMC_MMCCIDX_FSET(devNum,Field,Val)	  _PFIELD_SET(_MMC_MMCCIDX_ADDR(devNum), _MMC_MMCCIDX_##Field, Val)
#define _MMC_MMCCIDX_AOI(devNum,AND,OR,INV)	  _PREG_AOI(_MMC_MMCCIDX_ADDR(devNum),AND,OR,INV)
#define _MMC_MMCCIDX_FAOI(devNum,Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCIDX_ADDR(devNum), _MMC_MMCCIDX_##Field,AND,OR,INV)

#define _MMC_MMCCIDX0_GET		  _PREG_GET(_MMC_MMCCIDX_ADDR(0)) 
#define _MMC_MMCCIDX0_SET(Val)		  _PREG_SET(_MMC_MMCCIDX_ADDR(0),Val)
#define _MMC_MMCCIDX0_FGET(Field)	  _PFIELD_GET(_MMC_MMCCIDX_ADDR(0), _MMC_MMCCIDX_##Field)
#define _MMC_MMCCIDX0_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCCIDX_ADDR(0), _MMC_MMCCIDX_##Field, Val)
#define _MMC_MMCCIDX0_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCCIDX_ADDR(0),AND,OR,INV)
#define _MMC_MMCCIDX0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCIDX_ADDR(0), _MMC_MMCCIDX_##Field,AND,OR,INV)

#define _MMC_MMCCIDX1_GET		  _PREG_GET(_MMC_MMCCIDX_ADDR(1)) 
#define _MMC_MMCCIDX1_SET(Val)		  _PREG_SET(_MMC_MMCCIDX_ADDR(1),Val)
#define _MMC_MMCCIDX1_FGET(Field)	  _PFIELD_GET(_MMC_MMCCIDX_ADDR(1), _MMC_MMCCIDX_##Field)
#define _MMC_MMCCIDX1_FSET(Field,Val)	  _PFIELD_SET(_MMC_MMCCIDX_ADDR(1), _MMC_MMCCIDX_##Field, Val)
#define _MMC_MMCCIDX1_AOI(AND,OR,INV)	  _PREG_AOI(_MMC_MMCCIDX_ADDR(1),AND,OR,INV)
#define _MMC_MMCCIDX1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_MMC_MMCCIDX_ADDR(1), _MMC_MMCCIDX_##Field,AND,OR,INV)



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCRSP7 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCRSP7	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCRSP7_RSP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCRSP7_RSP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCRSP7_RSP_SHIFT		(000000u)
#define _MMC_MMCRSP7_RSP_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCRSP7_RSP_SHIFT)
#define _MMC_MMCRSP7_RSP_MASK		(_MMC_MMCRSP7_RSP_MK(0xffffu))
#define _MMC_MMCRSP7_RSP_CLR		(~(_MMC_MMCRSP7_RSP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCNBLC register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCNBLC	 - Note: Add description here
*
* Fields:
*	(R)   _MMC_MMCNBLC_NBLC	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCNBLC_NBLC:	
\*----------------------------------------------------------------*/

#define _MMC_MMCNBLC_NBLC_SHIFT		(000000u)
#define _MMC_MMCNBLC_NBLC_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCNBLC_NBLC_SHIFT)
#define _MMC_MMCNBLC_NBLC_MASK		(_MMC_MMCNBLC_NBLC_MK(0xffffu))
#define _MMC_MMCNBLC_NBLC_CLR		(~(_MMC_MMCNBLC_NBLC_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCETOK register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCETOK	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCETOK_ETOK	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCETOK_ETOK:	
\*----------------------------------------------------------------*/

#define _MMC_MMCETOK_ETOK_SHIFT		(000000u)
#define _MMC_MMCETOK_ETOK_MK(n)		(((Uint16)(n) & 0x00ffu) << _MMC_MMCETOK_ETOK_SHIFT)
#define _MMC_MMCETOK_ETOK_MASK		(_MMC_MMCETOK_ETOK_MK(0x00ffu))
#define _MMC_MMCETOK_ETOK_CLR		(~(_MMC_MMCETOK_ETOK_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCDRSP register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCDRSP	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCDRSP_DRSP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCDRSP_DRSP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCDRSP_DRSP_SHIFT		(000000u)
#define _MMC_MMCDRSP_DRSP_MK(n)		(((Uint16)(n) & 0x00ffu) << _MMC_MMCDRSP_DRSP_SHIFT)
#define _MMC_MMCDRSP_DRSP_MASK		(_MMC_MMCDRSP_DRSP_MK(0x00ffu))
#define _MMC_MMCDRSP_DRSP_CLR		(~(_MMC_MMCDRSP_DRSP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCCTL register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCCTL	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCCTL_CLKPRE	
*	(RW)   _MMC_MMCCTL_CLKPST	
*	(RW)   _MMC_MMCCTL_NACSKP	
*	(RW)   _MMC_MMCCTL_DMAEN	
*	(RW)   _MMC_MMCCTL_DATEG	
*	(RW)   _MMC_MMCCTL_SPIEN	
*	(RW)   _MMC_MMCCTL_WIDTH	
*	(RW)   _MMC_MMCCTL_CMDRST	
*	(RW)   _MMC_MMCCTL_DATRST	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCTL_CLKPRE:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCTL_CLKPRE_SHIFT		(0x000bu)
#define _MMC_MMCCTL_CLKPRE_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCTL_CLKPRE_SHIFT)
#define _MMC_MMCCTL_CLKPRE_MASK		(_MMC_MMCCTL_CLKPRE_MK(0x0001u))
#define _MMC_MMCCTL_CLKPRE_CLR		(~(_MMC_MMCCTL_CLKPRE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCTL_CLKPST:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCTL_CLKPST_SHIFT		(0x000au)
#define _MMC_MMCCTL_CLKPST_MK(n)		(((Uint16)(n) & 000000u) << _MMC_MMCCTL_CLKPST_SHIFT)
#define _MMC_MMCCTL_CLKPST_MASK		(_MMC_MMCCTL_CLKPST_MK(000000u))
#define _MMC_MMCCTL_CLKPST_CLR		(~(_MMC_MMCCTL_CLKPST_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCTL_NACSKP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCTL_NACSKP_SHIFT		(0x0009u)
#define _MMC_MMCCTL_NACSKP_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCTL_NACSKP_SHIFT)
#define _MMC_MMCCTL_NACSKP_MASK		(_MMC_MMCCTL_NACSKP_MK(0x0001u))
#define _MMC_MMCCTL_NACSKP_CLR		(~(_MMC_MMCCTL_NACSKP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCTL_DMAEN:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCTL_DMAEN_SHIFT		(0x0008u)
#define _MMC_MMCCTL_DMAEN_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCTL_DMAEN_SHIFT)
#define _MMC_MMCCTL_DMAEN_MASK		(_MMC_MMCCTL_DMAEN_MK(0x0001u))
#define _MMC_MMCCTL_DMAEN_CLR		(~(_MMC_MMCCTL_DMAEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCTL_DATEG:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCTL_DATEG_SHIFT		(0x0006u)
#define _MMC_MMCCTL_DATEG_MK(n)		(((Uint16)(n) & 0x0003u) << _MMC_MMCCTL_DATEG_SHIFT)
#define _MMC_MMCCTL_DATEG_MASK		(_MMC_MMCCTL_DATEG_MK(0x0003u))
#define _MMC_MMCCTL_DATEG_CLR		      (~(_MMC_MMCCTL_DATEG_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCTL_SPIEN:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCTL_SPIEN_SHIFT		(0x0005u)
#define _MMC_MMCCTL_SPIEN_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCTL_SPIEN_SHIFT)
#define _MMC_MMCCTL_SPIEN_MASK		(_MMC_MMCCTL_SPIEN_MK(0x0001u))
#define _MMC_MMCCTL_SPIEN_CLR		      (~(_MMC_MMCCTL_SPIEN_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCTL_CSEN:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCTL_CSEN_SHIFT		(0x0004u)
#define _MMC_MMCCTL_CSEN_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCTL_CSEN_SHIFT)
#define _MMC_MMCCTL_CSEN_MASK		      (_MMC_MMCCTL_CSEN_MK(0x0001u))
#define _MMC_MMCCTL_CSEN_CLR		      (~(_MMC_MMCCTL_CSEN_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCTL_SPICRC:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCTL_SPICRC_SHIFT		(0x0003u)
#define _MMC_MMCCTL_SPICRC_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCTL_SPICRC_SHIFT)
#define _MMC_MMCCTL_SPICRC_MASK		(_MMC_MMCCTL_SPICRC_MK(0x0001u))
#define _MMC_MMCCTL_SPICRC_CLR		(~(_MMC_MMCCTL_SPICRC_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCTL_WIDTH:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCTL_WIDTH_SHIFT		(0x0002u)
#define _MMC_MMCCTL_WIDTH_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCTL_WIDTH_SHIFT)
#define _MMC_MMCCTL_WIDTH_MASK		(_MMC_MMCCTL_WIDTH_MK(0x0001u))
#define _MMC_MMCCTL_WIDTH_CLR		      (~(_MMC_MMCCTL_WIDTH_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCTL_CMDRST:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCTL_CMDRST_SHIFT		(0x0001u)
#define _MMC_MMCCTL_CMDRST_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCTL_CMDRST_SHIFT)
#define _MMC_MMCCTL_CMDRST_MASK		(_MMC_MMCCTL_CMDRST_MK(0x0001u))
#define _MMC_MMCCTL_CMDRST_CLR		(~(_MMC_MMCCTL_CMDRST_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCTL_DATRST:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCTL_DATRST_SHIFT		(000000u)
#define _MMC_MMCCTL_DATRST_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCTL_DATRST_SHIFT)
#define _MMC_MMCCTL_DATRST_MASK		(_MMC_MMCCTL_DATRST_MK(0x0001u))
#define _MMC_MMCCTL_DATRST_CLR		(~(_MMC_MMCCTL_DATRST_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCTOD register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCTOD	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCTOD_TOD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCTOD_TOD:	
\*----------------------------------------------------------------*/

#define _MMC_MMCTOD_TOD_SHIFT		(000000u)
#define _MMC_MMCTOD_TOD_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCTOD_TOD_SHIFT)
#define _MMC_MMCTOD_TOD_MASK		(_MMC_MMCTOD_TOD_MK(0xffffu))
#define _MMC_MMCTOD_TOD_CLR		(~(_MMC_MMCTOD_TOD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCCIE register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCCIE	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCCIE_DATEG	
*	(RW)   _MMC_MMCCIE_DRRDY	
*	(RW)   _MMC_MMCCIE_DXRDY	
*	(RW)   _MMC_MMCCIE_CRCRS	
*	(RW)   _MMC_MMCCIE_CRCRD	
*	(RW)   _MMC_MMCCIE_CRCWR	
*	(RW)   _MMC_MMCCIE_TOUTRS	
*	(RW)   _MMC_MMCCIE_TOUTRD	
*	(RW)   _MMC_MMCCIE_RSPDNE	
*	(RW)   _MMC_MMCCIE_BSYDNE	
*	(RW)   _MMC_MMCCIE_DATDNE	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIE_DATEG:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIE_DATEG_SHIFT		(0x000bu)
#define _MMC_MMCCIE_DATEG_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCIE_DATEG_SHIFT)
#define _MMC_MMCCIE_DATEG_MASK		(_MMC_MMCCIE_DATEG_MK(0x0001u))
#define _MMC_MMCCIE_DATEG_CLR		(~(_MMC_MMCCIE_DATEG_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIE_DRRDY:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIE_DRRDY_SHIFT		(0x000au)
#define _MMC_MMCCIE_DRRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCIE_DRRDY_SHIFT)
#define _MMC_MMCCIE_DRRDY_MASK		(_MMC_MMCCIE_DRRDY_MK(0x0001u))
#define _MMC_MMCCIE_DRRDY_CLR		(~(_MMC_MMCCIE_DRRDY_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIE_DXRDY:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIE_DXRDY_SHIFT		(0x0009u)
#define _MMC_MMCCIE_DXRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCIE_DXRDY_SHIFT)
#define _MMC_MMCCIE_DXRDY_MASK		(_MMC_MMCCIE_DXRDY_MK(0x0001u))
#define _MMC_MMCCIE_DXRDY_CLR		(~(_MMC_MMCCIE_DXRDY_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIE_CRCRS:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIE_CRCRS_SHIFT		(0x0007u)
#define _MMC_MMCCIE_CRCRS_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCIE_CRCRS_SHIFT)
#define _MMC_MMCCIE_CRCRS_MASK		(_MMC_MMCCIE_CRCRS_MK(0x0001u))
#define _MMC_MMCCIE_CRCRS_CLR		(~(_MMC_MMCCIE_CRCRS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIE_CRCRD:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIE_CRCRD_SHIFT		(0x0006u)
#define _MMC_MMCCIE_CRCRD_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCIE_CRCRD_SHIFT)
#define _MMC_MMCCIE_CRCRD_MASK		(_MMC_MMCCIE_CRCRD_MK(0x0001u))
#define _MMC_MMCCIE_CRCRD_CLR		(~(_MMC_MMCCIE_CRCRD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIE_CRCWR:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIE_CRCWR_SHIFT		(0x0005u)
#define _MMC_MMCCIE_CRCWR_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCIE_CRCWR_SHIFT)
#define _MMC_MMCCIE_CRCWR_MASK		(_MMC_MMCCIE_CRCWR_MK(0x0001u))
#define _MMC_MMCCIE_CRCWR_CLR		(~(_MMC_MMCCIE_CRCWR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIE_TOUTRS:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIE_TOUTRS_SHIFT		(0x0004u)
#define _MMC_MMCCIE_TOUTRS_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCIE_TOUTRS_SHIFT)
#define _MMC_MMCCIE_TOUTRS_MASK		(_MMC_MMCCIE_TOUTRS_MK(0x0001u))
#define _MMC_MMCCIE_TOUTRS_CLR		(~(_MMC_MMCCIE_TOUTRS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIE_TOUTRD:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIE_TOUTRD_SHIFT		(0x0003u)
#define _MMC_MMCCIE_TOUTRD_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCIE_TOUTRD_SHIFT)
#define _MMC_MMCCIE_TOUTRD_MASK		(_MMC_MMCCIE_TOUTRD_MK(0x0001u))
#define _MMC_MMCCIE_TOUTRD_CLR		(~(_MMC_MMCCIE_TOUTRD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIE_RSPDNE:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIE_RSPDNE_SHIFT		(0x0002u)
#define _MMC_MMCCIE_RSPDNE_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCIE_RSPDNE_SHIFT)
#define _MMC_MMCCIE_RSPDNE_MASK		(_MMC_MMCCIE_RSPDNE_MK(0x0001u))
#define _MMC_MMCCIE_RSPDNE_CLR		(~(_MMC_MMCCIE_RSPDNE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIE_BSYDNE:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIE_BSYDNE_SHIFT		(0x0001u)
#define _MMC_MMCCIE_BSYDNE_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCIE_BSYDNE_SHIFT)
#define _MMC_MMCCIE_BSYDNE_MASK		(_MMC_MMCCIE_BSYDNE_MK(0x0001u))
#define _MMC_MMCCIE_BSYDNE_CLR		(~(_MMC_MMCCIE_BSYDNE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIE_DATDNE:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIE_DATDNE_SHIFT		(000000u)
#define _MMC_MMCCIE_DATDNE_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCIE_DATDNE_SHIFT)
#define _MMC_MMCCIE_DATDNE_MASK		(_MMC_MMCCIE_DATDNE_MK(0x0001u))
#define _MMC_MMCCIE_DATDNE_CLR		(~(_MMC_MMCCIE_DATDNE_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCIM register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCIM	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCIM_DATEG	
*	(RW)   _MMC_MMCIM_DRRDY	
*	(RW)   _MMC_MMCIM_DXRDY	
*	(RW)   _MMC_MMCIM_CRCRS	
*	(RW)   _MMC_MMCIM_CRCRD	
*	(RW)   _MMC_MMCIM_CRCWR	
*	(RW)   _MMC_MMCIM_TOUTRS	
*	(RW)   _MMC_MMCIM_TOUTRD	
*	(RW)   _MMC_MMCIM_RSPDNE	
*	(RW)   _MMC_MMCIM_BSYDNE	
*	(RW)   _MMC_MMCIM_DATDNE	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCIM_DATEG:	
\*----------------------------------------------------------------*/

#define _MMC_MMCIM_DATEG_SHIFT		(0x000bu)
#define _MMC_MMCIM_DATEG_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCIM_DATEG_SHIFT)
#define _MMC_MMCIM_DATEG_MASK		(_MMC_MMCIM_DATEG_MK(0x0001u))
#define _MMC_MMCIM_DATEG_CLR		(~(_MMC_MMCIM_DATEG_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCIM_DRRDY:	
\*----------------------------------------------------------------*/

#define _MMC_MMCIM_DRRDY_SHIFT		(0x000au)
#define _MMC_MMCIM_DRRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCIM_DRRDY_SHIFT)
#define _MMC_MMCIM_DRRDY_MASK		(_MMC_MMCIM_DRRDY_MK(0x0001u))
#define _MMC_MMCIM_DRRDY_CLR		(~(_MMC_MMCIM_DRRDY_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCIM_DXRDY:	
\*----------------------------------------------------------------*/

#define _MMC_MMCIM_DXRDY_SHIFT		(0x0009u)
#define _MMC_MMCIM_DXRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCIM_DXRDY_SHIFT)
#define _MMC_MMCIM_DXRDY_MASK		(_MMC_MMCIM_DXRDY_MK(0x0001u))
#define _MMC_MMCIM_DXRDY_CLR		(~(_MMC_MMCIM_DXRDY_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCIM_CRCRS:	
\*----------------------------------------------------------------*/

#define _MMC_MMCIM_CRCRS_SHIFT		(0x0007u)
#define _MMC_MMCIM_CRCRS_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCIM_CRCRS_SHIFT)
#define _MMC_MMCIM_CRCRS_MASK		(_MMC_MMCIM_CRCRS_MK(0x0001u))
#define _MMC_MMCIM_CRCRS_CLR		(~(_MMC_MMCIM_CRCRS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCIM_CRCRD:	
\*----------------------------------------------------------------*/

#define _MMC_MMCIM_CRCRD_SHIFT		(0x0006u)
#define _MMC_MMCIM_CRCRD_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCIM_CRCRD_SHIFT)
#define _MMC_MMCIM_CRCRD_MASK		(_MMC_MMCIM_CRCRD_MK(0x0001u))
#define _MMC_MMCIM_CRCRD_CLR		(~(_MMC_MMCIM_CRCRD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCIM_CRCWR:	
\*----------------------------------------------------------------*/

#define _MMC_MMCIM_CRCWR_SHIFT		(0x0005u)
#define _MMC_MMCIM_CRCWR_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCIM_CRCWR_SHIFT)
#define _MMC_MMCIM_CRCWR_MASK		(_MMC_MMCIM_CRCWR_MK(0x0001u))
#define _MMC_MMCIM_CRCWR_CLR		(~(_MMC_MMCIM_CRCWR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCIM_TOUTRS:	
\*----------------------------------------------------------------*/

#define _MMC_MMCIM_TOUTRS_SHIFT		(0x0004u)
#define _MMC_MMCIM_TOUTRS_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCIM_TOUTRS_SHIFT)
#define _MMC_MMCIM_TOUTRS_MASK		(_MMC_MMCIM_TOUTRS_MK(0x0001u))
#define _MMC_MMCIM_TOUTRS_CLR		(~(_MMC_MMCIM_TOUTRS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCIM_TOUTRD:	
\*----------------------------------------------------------------*/

#define _MMC_MMCIM_TOUTRD_SHIFT		(0x0003u)
#define _MMC_MMCIM_TOUTRD_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCIM_TOUTRD_SHIFT)
#define _MMC_MMCIM_TOUTRD_MASK		(_MMC_MMCIM_TOUTRD_MK(0x0001u))
#define _MMC_MMCIM_TOUTRD_CLR		(~(_MMC_MMCIM_TOUTRD_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCIM_RSPDNE:	
\*----------------------------------------------------------------*/

#define _MMC_MMCIM_RSPDNE_SHIFT		(0x0002u)
#define _MMC_MMCIM_RSPDNE_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCIM_RSPDNE_SHIFT)
#define _MMC_MMCIM_RSPDNE_MASK		(_MMC_MMCIM_RSPDNE_MK(0x0001u))
#define _MMC_MMCIM_RSPDNE_CLR		(~(_MMC_MMCIM_RSPDNE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCIM_BSYDNE:	
\*----------------------------------------------------------------*/

#define _MMC_MMCIM_BSYDNE_SHIFT		(0x0001u)
#define _MMC_MMCIM_BSYDNE_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCIM_BSYDNE_SHIFT)
#define _MMC_MMCIM_BSYDNE_MASK		(_MMC_MMCIM_BSYDNE_MK(0x0001u))
#define _MMC_MMCIM_BSYDNE_CLR		(~(_MMC_MMCIM_BSYDNE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCIM_DATDNE:	
\*----------------------------------------------------------------*/

#define _MMC_MMCIM_DATDNE_SHIFT		(000000u)
#define _MMC_MMCIM_DATDNE_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCIM_DATDNE_SHIFT)
#define _MMC_MMCIM_DATDNE_MASK		(_MMC_MMCIM_DATDNE_MK(0x0001u))
#define _MMC_MMCIM_DATDNE_CLR		(~(_MMC_MMCIM_DATDNE_MASK))




/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCNBLK register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCNBLK	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCNBLK_NBLK	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCNBLK_NBLK:	
\*----------------------------------------------------------------*/

#define _MMC_MMCNBLK_NBLK_SHIFT		(000000u)
#define _MMC_MMCNBLK_NBLK_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCNBLK_NBLK_SHIFT)
#define _MMC_MMCNBLK_NBLK_MASK		(_MMC_MMCNBLK_NBLK_MK(0xffffu))
#define _MMC_MMCNBLK_NBLK_CLR		(~(_MMC_MMCNBLK_NBLK_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCDRR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCDRR	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCDRR_DRR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCDRR_DRR:	
\*----------------------------------------------------------------*/

#define _MMC_MMCDRR_DRR_SHIFT		(000000u)
#define _MMC_MMCDRR_DRR_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCDRR_DRR_SHIFT)
#define _MMC_MMCDRR_DRR_MASK		(_MMC_MMCDRR_DRR_MK(0xffffu))
#define _MMC_MMCDRR_DRR_CLR		(~(_MMC_MMCDRR_DRR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCFCLK register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCFCLK	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCFCLK_IDLEEN	
*	(RW)   _MMC_MMCFCLK_FDIV	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCFCLK_IDLEEN:	
\*----------------------------------------------------------------*/

#define _MMC_MMCFCLK_IDLEEN_SHIFT		(0x0008u)
#define _MMC_MMCFCLK_IDLEEN_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCFCLK_IDLEEN_SHIFT)
#define _MMC_MMCFCLK_IDLEEN_MASK		(_MMC_MMCFCLK_IDLEEN_MK(0x0001u))
#define _MMC_MMCFCLK_IDLEEN_CLR		(~(_MMC_MMCFCLK_IDLEEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCFCLK_FDIV:	
\*----------------------------------------------------------------*/

#define _MMC_MMCFCLK_FDIV_SHIFT		(000000u)
#define _MMC_MMCFCLK_FDIV_MK(n)		(((Uint16)(n) & 0x00ffu) << _MMC_MMCFCLK_FDIV_SHIFT)
#define _MMC_MMCFCLK_FDIV_MASK		(_MMC_MMCFCLK_FDIV_MK(0x00ffu))
#define _MMC_MMCFCLK_FDIV_CLR		(~(_MMC_MMCFCLK_FDIV_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCFCKCTL register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCFCKCTL	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCFCKCTL_IDLEEN	
*	(RW)   _MMC_MMCFCKCTL_FDIV	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCFCKCTL_IDLEEN:	
\*----------------------------------------------------------------*/

#define _MMC_MMCFCKCTL_IDLEEN_SHIFT		(0x0008u)
#define _MMC_MMCFCKCTL_IDLEEN_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCFCKCTL_IDLEEN_SHIFT)
#define _MMC_MMCFCKCTL_IDLEEN_MASK		(_MMC_MMCFCKCTL_IDLEEN_MK(0x0001u))
#define _MMC_MMCFCKCTL_IDLEEN_CLR		(~(_MMC_MMCFCKCTL_IDLEEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCFCKCTL_FDIV:	
\*----------------------------------------------------------------*/

#define _MMC_MMCFCKCTL_FDIV_SHIFT		(000000u)
#define _MMC_MMCFCKCTL_FDIV_MK(n)		(((Uint16)(n) & 0x00ffu) << _MMC_MMCFCKCTL_FDIV_SHIFT)
#define _MMC_MMCFCKCTL_FDIV_MASK		(_MMC_MMCFCKCTL_FDIV_MK(0x00ffu))
#define _MMC_MMCFCKCTL_FDIV_CLR		(~(_MMC_MMCFCKCTL_FDIV_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCBLEN register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCBLEN	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCBLEN_BLEN	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCBLEN_BLEN:	
\*----------------------------------------------------------------*/

#define _MMC_MMCBLEN_BLEN_SHIFT		(000000u)
#define _MMC_MMCBLEN_BLEN_MK(n)		(((Uint16)(n) & 0x0fffu) << _MMC_MMCBLEN_BLEN_SHIFT)
#define _MMC_MMCBLEN_BLEN_MASK		(_MMC_MMCBLEN_BLEN_MK(0x0fffu))
#define _MMC_MMCBLEN_BLEN_CLR		(~(_MMC_MMCBLEN_BLEN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCCIDX register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCCIDX	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCCIDX_CIDX	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCIDX_CIDX:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCIDX_CIDX_SHIFT		(000000u)
#define _MMC_MMCCIDX_CIDX_MK(n)		(((Uint16)(n) & 0x00ffu) << _MMC_MMCCIDX_CIDX_SHIFT)
#define _MMC_MMCCIDX_CIDX_MASK		(_MMC_MMCCIDX_CIDX_MK(0x00ffu))
#define _MMC_MMCCIDX_CIDX_CLR		(~(_MMC_MMCCIDX_CIDX_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCCMD register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCCMD	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCCMD_DCLR	
*	(RW)   _MMC_MMCCMD_INIT	
*	(RW)   _MMC_MMCCMD_DATA	
*	(RW)   _MMC_MMCCMD_STREAM	
*	(RW)   _MMC_MMCCMD_WRITE	
*	(RW)   _MMC_MMCCMD_RSPFMT	
*	(RW)   _MMC_MMCCMD_BSYEXP	
*	(RW)   _MMC_MMCCMD_CMD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCMD_DCLR:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCMD_DCLR_SHIFT		(0x000fu)
#define _MMC_MMCCMD_DCLR_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCMD_DCLR_SHIFT)
#define _MMC_MMCCMD_DCLR_MASK		(_MMC_MMCCMD_DCLR_MK(0x0001u))
#define _MMC_MMCCMD_DCLR_CLR		(~(_MMC_MMCCMD_DCLR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCMD_INIT:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCMD_INIT_SHIFT		(0x000eu)
#define _MMC_MMCCMD_INIT_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCMD_INIT_SHIFT)
#define _MMC_MMCCMD_INIT_MASK		(_MMC_MMCCMD_INIT_MK(0x0001u))
#define _MMC_MMCCMD_INIT_CLR		(~(_MMC_MMCCMD_INIT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCMD_DATA:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCMD_DATA_SHIFT		(0x000du)
#define _MMC_MMCCMD_DATA_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCMD_DATA_SHIFT)
#define _MMC_MMCCMD_DATA_MASK		(_MMC_MMCCMD_DATA_MK(0x0001u))
#define _MMC_MMCCMD_DATA_CLR		(~(_MMC_MMCCMD_DATA_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCMD_STREAM:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCMD_STREAM_SHIFT		(0x000cu)
#define _MMC_MMCCMD_STREAM_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCMD_STREAM_SHIFT)
#define _MMC_MMCCMD_STREAM_MASK		(_MMC_MMCCMD_STREAM_MK(0x0001u))
#define _MMC_MMCCMD_STREAM_CLR		(~(_MMC_MMCCMD_STREAM_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCMD_WRITE:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCMD_WRITE_SHIFT		(0x000bu)
#define _MMC_MMCCMD_WRITE_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCMD_WRITE_SHIFT)
#define _MMC_MMCCMD_WRITE_MASK		(_MMC_MMCCMD_WRITE_MK(0x0001u))
#define _MMC_MMCCMD_WRITE_CLR		(~(_MMC_MMCCMD_WRITE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCMD_RSPFMT:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCMD_RSPFMT_SHIFT		(0x0009u)
#define _MMC_MMCCMD_RSPFMT_MK(n)		(((Uint16)(n) & 0x0003u) << _MMC_MMCCMD_RSPFMT_SHIFT)
#define _MMC_MMCCMD_RSPFMT_MASK		(_MMC_MMCCMD_RSPFMT_MK(0x0003u))
#define _MMC_MMCCMD_RSPFMT_CLR		(~(_MMC_MMCCMD_RSPFMT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCMD_BSYEXP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCMD_BSYEXP_SHIFT		(0x0008u)
#define _MMC_MMCCMD_BSYEXP_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCMD_BSYEXP_SHIFT)
#define _MMC_MMCCMD_BSYEXP_MASK		(_MMC_MMCCMD_BSYEXP_MK(0x0001u))
#define _MMC_MMCCMD_BSYEXP_CLR		(~(_MMC_MMCCMD_BSYEXP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCMD_CMD:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCMD_CMD_SHIFT		(000000u)
#define _MMC_MMCCMD_CMD_MK(n)		(((Uint16)(n) & 0x003fu) << _MMC_MMCCMD_CMD_SHIFT)
#define _MMC_MMCCMD_CMD_MASK		(_MMC_MMCCMD_CMD_MK(0x003fu))
#define _MMC_MMCCMD_CMD_CLR		(~(_MMC_MMCCMD_CMD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCCLK register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCCLK	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCCLK_CLKEN	
*	(RW)   _MMC_MMCCLK_CDIV	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCLK_CLKEN:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCLK_CLKEN_SHIFT		(0x0004u)
#define _MMC_MMCCLK_CLKEN_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCCLK_CLKEN_SHIFT)
#define _MMC_MMCCLK_CLKEN_MASK		(_MMC_MMCCLK_CLKEN_MK(0x0001u))
#define _MMC_MMCCLK_CLKEN_CLR		(~(_MMC_MMCCLK_CLKEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCCLK_CDIV:	
\*----------------------------------------------------------------*/

#define _MMC_MMCCLK_CDIV_SHIFT		(000000u)
#define _MMC_MMCCLK_CDIV_MK(n)		(((Uint16)(n) & 0x000fu) << _MMC_MMCCLK_CDIV_SHIFT)
#define _MMC_MMCCLK_CDIV_MASK		(_MMC_MMCCLK_CDIV_MK(0x000fu))
#define _MMC_MMCCLK_CDIV_CLR		(~(_MMC_MMCCLK_CDIV_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCTOR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCTOR	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCTOR_TOR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCTOR_TOR:	
\*----------------------------------------------------------------*/

#define _MMC_MMCTOR_TOR_SHIFT		(000000u)
#define _MMC_MMCTOR_TOR_MK(n)		(((Uint16)(n) & 0x00ffu) << _MMC_MMCTOR_TOR_SHIFT)
#define _MMC_MMCTOR_TOR_MASK		(_MMC_MMCTOR_TOR_MK(0x00ffu))
#define _MMC_MMCTOR_TOR_CLR		(~(_MMC_MMCTOR_TOR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCDXR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCDXR	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCDXR_DXR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCDXR_DXR:	
\*----------------------------------------------------------------*/

#define _MMC_MMCDXR_DXR_SHIFT		(000000u)
#define _MMC_MMCDXR_DXR_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCDXR_DXR_SHIFT)
#define _MMC_MMCDXR_DXR_MASK		(_MMC_MMCDXR_DXR_MK(0xffffu))
#define _MMC_MMCDXR_DXR_CLR		(~(_MMC_MMCDXR_DXR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCARGH register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCARGH	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCARGH_ARGH	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCARGH_ARGH:	
\*----------------------------------------------------------------*/

#define _MMC_MMCARGH_ARGH_SHIFT		(000000u)
#define _MMC_MMCARGH_ARGH_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCARGH_ARGH_SHIFT)
#define _MMC_MMCARGH_ARGH_MASK		(_MMC_MMCARGH_ARGH_MK(0xffffu))
#define _MMC_MMCARGH_ARGH_CLR		(~(_MMC_MMCARGH_ARGH_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCST0 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCST0	 - Note: Add description here
*
* Fields:
*	(R)   _MMC_MMCST0_DATEG	
*	(R)   _MMC_MMCST0_DRRDY	
*	(R)   _MMC_MMCST0_DXRDY	
*	(R)   _MMC_MMCST0_SPIERR	
*	(R)   _MMC_MMCST0_CRCRS	
*	(R)   _MMC_MMCST0_CRCRD	
*	(R)   _MMC_MMCST0_CRCWR	
*	(R)   _MMC_MMCST0_TOUTRS	
*	(R)   _MMC_MMCST0_TOUTRD	
*	(R)   _MMC_MMCST0_RSPDNE	
*	(R)   _MMC_MMCST0_BSYDNE	
*	(R)   _MMC_MMCST0_DATDNE	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_DATEG:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_DATEG_SHIFT		(0x000bu)
#define _MMC_MMCST0_DATEG_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_DATEG_SHIFT)
#define _MMC_MMCST0_DATEG_MASK		(_MMC_MMCST0_DATEG_MK(0x0001u))
#define _MMC_MMCST0_DATEG_CLR		(~(_MMC_MMCST0_DATEG_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_DRRDY:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_DRRDY_SHIFT		(0x000au)
#define _MMC_MMCST0_DRRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_DRRDY_SHIFT)
#define _MMC_MMCST0_DRRDY_MASK		(_MMC_MMCST0_DRRDY_MK(0x0001u))
#define _MMC_MMCST0_DRRDY_CLR		(~(_MMC_MMCST0_DRRDY_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_DXRDY:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_DXRDY_SHIFT		(0x0009u)
#define _MMC_MMCST0_DXRDY_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_DXRDY_SHIFT)
#define _MMC_MMCST0_DXRDY_MASK		(_MMC_MMCST0_DXRDY_MK(0x0001u))
#define _MMC_MMCST0_DXRDY_CLR		(~(_MMC_MMCST0_DXRDY_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_SPIERR:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_SPIERR_SHIFT		(0x0008u)
#define _MMC_MMCST0_SPIERR_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_SPIERR_SHIFT)
#define _MMC_MMCST0_SPIERR_MASK		(_MMC_MMCST0_SPIERR_MK(0x0001u))
#define _MMC_MMCST0_SPIERR_CLR		(~(_MMC_MMCST0_SPIERR_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_CRCRS:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_CRCRS_SHIFT		(0x0007u)
#define _MMC_MMCST0_CRCRS_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_CRCRS_SHIFT)
#define _MMC_MMCST0_CRCRS_MASK		(_MMC_MMCST0_CRCRS_MK(0x0001u))
#define _MMC_MMCST0_CRCRS_CLR		      (~(_MMC_MMCST0_CRCRS_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_CRCRD:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_CRCRD_SHIFT		(0x0006u)
#define _MMC_MMCST0_CRCRD_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_CRCRD_SHIFT)
#define _MMC_MMCST0_CRCRD_MASK		(_MMC_MMCST0_CRCRD_MK(0x0001u))
#define _MMC_MMCST0_CRCRD_CLR		(~(_MMC_MMCST0_CRCRD_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_CRCWR:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_CRCWR_SHIFT		(0x0005u)
#define _MMC_MMCST0_CRCWR_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_CRCWR_SHIFT)
#define _MMC_MMCST0_CRCWR_MASK		(_MMC_MMCST0_CRCWR_MK(0x0001u))
#define _MMC_MMCST0_CRCWR_CLR		(~(_MMC_MMCST0_CRCWR_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_TOUTRS:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_TOUTRS_SHIFT		(0x0004u)
#define _MMC_MMCST0_TOUTRS_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_TOUTRS_SHIFT)
#define _MMC_MMCST0_TOUTRS_MASK		(_MMC_MMCST0_TOUTRS_MK(0x0001u))
#define _MMC_MMCST0_TOUTRS_CLR		(~(_MMC_MMCST0_TOUTRS_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_TOUTRD:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_TOUTRD_SHIFT		(0x0003u)
#define _MMC_MMCST0_TOUTRD_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_TOUTRD_SHIFT)
#define _MMC_MMCST0_TOUTRD_MASK		(_MMC_MMCST0_TOUTRD_MK(0x0001u))
#define _MMC_MMCST0_TOUTRD_CLR		(~(_MMC_MMCST0_TOUTRD_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_RSPDNE:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_RSPDNE_SHIFT		(0x0002u)
#define _MMC_MMCST0_RSPDNE_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_RSPDNE_SHIFT)
#define _MMC_MMCST0_RSPDNE_MASK		(_MMC_MMCST0_RSPDNE_MK(0x0001u))
#define _MMC_MMCST0_RSPDNE_CLR		(~(_MMC_MMCST0_RSPDNE_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_BSYDNE:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_BSYDNE_SHIFT		(0x0001u)
#define _MMC_MMCST0_BSYDNE_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_BSYDNE_SHIFT)
#define _MMC_MMCST0_BSYDNE_MASK		(_MMC_MMCST0_BSYDNE_MK(0x0001u))
#define _MMC_MMCST0_BSYDNE_CLR		(~(_MMC_MMCST0_BSYDNE_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST0_DATDNE:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST0_DATDNE_SHIFT		(0x0000u)
#define _MMC_MMCST0_DATDNE_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST0_DATDNE_SHIFT)
#define _MMC_MMCST0_DATDNE_MASK		(_MMC_MMCST0_DATDNE_MK(0x0001u))
#define _MMC_MMCST0_DATDNE_CLR		(~(_MMC_MMCST0_DATDNE_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCRSP0 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCRSP0	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCRSP0_RSP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCRSP0_RSP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCRSP0_RSP_SHIFT		(000000u)
#define _MMC_MMCRSP0_RSP_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCRSP0_RSP_SHIFT)
#define _MMC_MMCRSP0_RSP_MASK		(_MMC_MMCRSP0_RSP_MK(0xffffu))
#define _MMC_MMCRSP0_RSP_CLR		(~(_MMC_MMCRSP0_RSP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCST1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCST1	 - Note: Add description here
*
* Fields:
*	(R)   _MMC_MMCST1_DAT	
*	(R)   _MMC_MMCST1_DXEMP	
*	(R)   _MMC_MMCST1_DRFUL	
*	(R)   _MMC_MMCST1_CLKSTP	
*	(R)   _MMC_MMCST1_BUSY	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST1_DAT:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST1_DAT_SHIFT		(0x0004u)
#define _MMC_MMCST1_DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST1_DAT_SHIFT)
#define _MMC_MMCST1_DAT_MASK		(_MMC_MMCST1_DAT_MK(0x0001u))
#define _MMC_MMCST1_DAT_CLR		(~(_MMC_MMCST1_DAT_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST1_DXEMP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST1_DXEMP_SHIFT		(0x0003u)
#define _MMC_MMCST1_DXEMP_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST1_DXEMP_SHIFT)
#define _MMC_MMCST1_DXEMP_MASK		(_MMC_MMCST1_DXEMP_MK(0x0001u))
#define _MMC_MMCST1_DXEMP_CLR		(~(_MMC_MMCST1_DXEMP_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST1_DRFUL:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST1_DRFUL_SHIFT		(0x0002u)
#define _MMC_MMCST1_DRFUL_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST1_DRFUL_SHIFT)
#define _MMC_MMCST1_DRFUL_MASK		(_MMC_MMCST1_DRFUL_MK(0x0001u))
#define _MMC_MMCST1_DRFUL_CLR		(~(_MMC_MMCST1_DRFUL_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST1_CLKSTP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST1_CLKSTP_SHIFT		(0x0001u)
#define _MMC_MMCST1_CLKSTP_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST1_CLKSTP_SHIFT)
#define _MMC_MMCST1_CLKSTP_MASK		(_MMC_MMCST1_CLKSTP_MK(0x0001u))
#define _MMC_MMCST1_CLKSTP_CLR		(~(_MMC_MMCST1_CLKSTP_MASK))



/*----------------------------------------------------------------*\
*   (R)  _MMC_MMCST1_BUSY:	
\*----------------------------------------------------------------*/

#define _MMC_MMCST1_BUSY_SHIFT		(000000u)
#define _MMC_MMCST1_BUSY_MK(n)		(((Uint16)(n) & 0x0001u) << _MMC_MMCST1_BUSY_SHIFT)
#define _MMC_MMCST1_BUSY_MASK		(_MMC_MMCST1_BUSY_MK(0x0001u))
#define _MMC_MMCST1_BUSY_CLR		(~(_MMC_MMCST1_BUSY_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCRSP1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCRSP1	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCRSP1_RSP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCRSP1_RSP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCRSP1_RSP_SHIFT		(000000u)
#define _MMC_MMCRSP1_RSP_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCRSP1_RSP_SHIFT)
#define _MMC_MMCRSP1_RSP_MASK		(_MMC_MMCRSP1_RSP_MK(0xffffu))
#define _MMC_MMCRSP1_RSP_CLR		(~(_MMC_MMCRSP1_RSP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCRSP2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCRSP2	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCRSP2_RSP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCRSP2_RSP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCRSP2_RSP_SHIFT		(000000u)
#define _MMC_MMCRSP2_RSP_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCRSP2_RSP_SHIFT)
#define _MMC_MMCRSP2_RSP_MASK		(_MMC_MMCRSP2_RSP_MK(0xffffu))
#define _MMC_MMCRSP2_RSP_CLR		(~(_MMC_MMCRSP2_RSP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCARGL register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCARGL	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCARGL_ARGL	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCARGL_ARGL:	
\*----------------------------------------------------------------*/

#define _MMC_MMCARGL_ARGL_SHIFT		(000000u)
#define _MMC_MMCARGL_ARGL_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCARGL_ARGL_SHIFT)
#define _MMC_MMCARGL_ARGL_MASK		(_MMC_MMCARGL_ARGL_MK(0xffffu))
#define _MMC_MMCARGL_ARGL_CLR		(~(_MMC_MMCARGL_ARGL_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCRSP3 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCRSP3	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCRSP3_RSP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCRSP3_RSP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCRSP3_RSP_SHIFT		(000000u)
#define _MMC_MMCRSP3_RSP_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCRSP3_RSP_SHIFT)
#define _MMC_MMCRSP3_RSP_MASK		(_MMC_MMCRSP3_RSP_MK(0xffffu))
#define _MMC_MMCRSP3_RSP_CLR		(~(_MMC_MMCRSP3_RSP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCRSP4 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCRSP4	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCRSP4_RSP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCRSP4_RSP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCRSP4_RSP_SHIFT		(000000u)
#define _MMC_MMCRSP4_RSP_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCRSP4_RSP_SHIFT)
#define _MMC_MMCRSP4_RSP_MASK		(_MMC_MMCRSP4_RSP_MK(0xffffu))
#define _MMC_MMCRSP4_RSP_CLR		(~(_MMC_MMCRSP4_RSP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCRSP5 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCRSP5	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCRSP5_RSP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCRSP5_RSP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCRSP5_RSP_SHIFT		(000000u)
#define _MMC_MMCRSP5_RSP_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCRSP5_RSP_SHIFT)
#define _MMC_MMCRSP5_RSP_MASK		(_MMC_MMCRSP5_RSP_MK(0xffffu))
#define _MMC_MMCRSP5_RSP_CLR		(~(_MMC_MMCRSP5_RSP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the MMCRSP6 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _MMC_MMCRSP6	 - Note: Add description here
*
* Fields:
*	(RW)   _MMC_MMCRSP6_RSP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _MMC_MMCRSP6_RSP:	
\*----------------------------------------------------------------*/

#define _MMC_MMCRSP6_RSP_SHIFT		(000000u)
#define _MMC_MMCRSP6_RSP_MK(n)		(((Uint16)(n) & 0xffffu) << _MMC_MMCRSP6_RSP_SHIFT)
#define _MMC_MMCRSP6_RSP_MASK		(_MMC_MMCRSP6_RSP_MK(0xffffu))
#define _MMC_MMCRSP6_RSP_CLR		(~(_MMC_MMCRSP6_RSP_MASK))


#else
   #ifndef _MMC_MOD_
	#error MMC Hal Module Not Supported on Specified Target
   #endif
#endif  /* _MMC_SUPPORT  */

#endif  /* _CSL_MMCHAL_H  */

/******************************************************************************\
*     
*      End of csl_mmchal.h 
*
\******************************************************************************/
csl_pll.h/      1049976909  0     0     0       1582      `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... csl_pll.h
* DATE CREATED.. Mon Jan 28 14:25:28 2002
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Mon Jan 28 14:25:28 2002 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the PLL module 
*              Supports PLL for 5510/5509/5502
*              pllA - 5510/5509 PLL
*              pllB - 5502 PLL
*
\*************************************************************************/

#ifndef _CSL_PLL_H_
  #define _CSL_PLL_H_

  #include <csl_std.h>
  #include <csl.h>
  #include <csl_chiphal.h>

  #if (_PLL_SUPPORT)
    #if (_PLLB_SUPPORT) 
       #include <csl_pllB.h>
    #elif (_PLLA_SUPPORT)
      #include <csl_pllA.h>
    #else
      #error PLL Support Not Defined
    #endif /* _PLLB_SUPPORT */
  #endif  /* _PLL_SUPPORT  */
#endif  /* CSL_PLL_H */

/******************************************************************************\
*     
*      End of csl_pll.h 
*
\******************************************************************************/
csl_pllA.h/     1049976910  0     0     0       7213      `
 /******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... pll.h
* DATE CREATED.. Mon 06/05/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/05/2000 Created.  
*   MODIFIED: 07/05/2001 Modified to include support for both DPLL and APLL
*   MODIFIED: 01/24/2002 fixed problem with CLKDIV support for 5510PG2
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the PLL module)
\******************************************************************************/
#ifndef _PLLA_H_
#define _PLLA_H_

#include <_csl.h>
#include <csl_pllAhal.h>

#if (_PLLA_SUPPORT)
/****************************************\
* PLL scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _PLL_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/****************************************\
* PLL global macro declarations
\****************************************/ 
#define PLL_DEVICE_CNT           HPLL_DEVICE_CNT

/* PLL_Open() flags */
#define PLL_OPEN_RESET           (0x0001)

/* error codes */
#define PLL_ERR_MAJOR            (ERR_BASE_PLL) 
#define PLL_ERR_ALLOC            (0x00000000)
#define PLL_ERR_INVALID_HANDLE   (0x00000001)


/*----------------------------------------------------------------------------*/
#define PLL_RESET(hPll)   CLKMD = hPll->reset


/*******************************************\
* PLL global macro definition : ROMABILITY
\*******************************************/ 
/* Reserved ROM Area for pllData.h */
/* Data definition */   

/* Predefined Device Handlers */
/* #define PLL_defaultHandle          PLL_SYM(2) */

/*******************************************/
/* Define a debuging assertion macro 	 */ 
/* for validating device handles 		 */


/*-----------------------------------------------------------------------*/
/* The following macros are used to construct peripheral register        */
/* values based on symbolic constants. They will be useful to initialize */
/* the TIMER_Config structure in a readable way.                         */
/*-----------------------------------------------------------------------*/

#if (!(_PLL_ANALOG_SUPPORT))	//Digital PLL (only one that works in 55xx)

/*===========================================================================*\
* PLL CLKMD Clock Mode Register Macros
*
* Fields:
*  (RW) IAI
*  (RW) IOB
*  (RW) TEST
*  (RW) PLLMULT
*  (RW) PLLDIV
*  (RW) PLLENABLE
*  (RW) BYPASSDIV
*  (R)  BREAKLN
*  (RW) LOCK
\*==========================================================================*/

/*---------------------------------------*\
* PLL_CLKMD_MK Macro
\*---------------------------------------*/

#define PLL_CLKMD_RMK(iai,iob,test,pllmult,plldiv,pllenable,bypassdiv)\
  ((Uint16) (PLL_FMK(CLKMD,IAI,iai) 				|	\
			PLL_FMK(CLKMD,IOB,iob) 				|	\
			PLL_FMK(CLKMD,TEST,test) 			|	\
			PLL_FMK(CLKMD,PLLMULT,pllmult) 		|	\
			PLL_FMK(CLKMD,PLLDIV,plldiv) 			|	\
			PLL_FMK(CLKMD,PLLENABLE,pllenable) 		|	\
			PLL_FMK(CLKMD,BYPASSDIV,bypassdiv) 			\
	   	))

#define PLL_CLKMD_RMKS(iai_s,iob_s,test_s,pllmult_s,plldiv_s,\
           pllenable_s,bypassdiv_s)\
  ((Uint16) (PLL_FMKS(CLKMD,IAI,iai_s) 			|\
		 PLL_FMKS(CLKMD,IOB,iob_s) 			|\
		 PLL_FMKS(CLKMD,TEST,test_s) 			|\
		 PLL_FMKS(CLKMD,PLLMULT,pllmult_s) 		|\
		 PLL_FMKS(CLKMD,PLLDIV,plldiv_s) 		|\
		 PLL_FMKS(CLKMD,PLLENABLE,pllenable_s) 	|\
		 PLL_FMKS(CLKMD,BYPASSDIV,bypassdiv_s) 	\
	   	))
	   	
#else	   			//Analog PLL

/*===========================================================================*\
* PLL CLKMD Clock Mode Register Macros
*
* Fields:
*  (RW) VCOONOFF
*  (RW) PLLMULT
*  (RW) PLLDIV
*  (RW) PLLENABLE
\*==========================================================================*/

#define PLL_CLKMD_RMK(vcoonoff,pllmult,plldiv,pllenable)\
  ((Uint16) (   	PLL_FMK(CLKMD,VCOONOFF,vcoonoff) 				|	\
			PLL_FMK(CLKMD,PLLMULT,pllmult) 		|	\
			PLL_FMK(CLKMD,PLLDIV,plldiv) 			|	\
			PLL_FMK(CLKMD,PLLENABLE,pllenable) 			\
	   	))

#define PLL_CLKMD_RMKS(vcoonoff_s,pllmult_s,plldiv_s,\
           pllenable_s)\
  ((Uint16) (PLL_FMKS(CLKMD,VCOONOFF,vcoonoff_s) 	|\
		 PLL_FMKS(CLKMD,PLLMULT,pllmult_s) 		|\
		 PLL_FMKS(CLKMD,PLLDIV,plldiv_s) 		|\
		 PLL_FMKS(CLKMD,PLLENABLE,pllenable_s) 	 \
	   	))
#endif

#define PLL_CLKMD_DEFAULT               	(0x0000u)

#define PLL_CLKMD_VCOONOFF_OFF           	(0x0000u)
#define PLL_CLKMD_VCOONOFF_ON            	(0x0001u)

#define PLL_CLKMD_IAI_OFF           	(0x0000u)
#define PLL_CLKMD_IAI_ON            	(0x0001u)

#define PLL_CLKMD_IOB_OFF           	(0x0000u)
#define PLL_CLKMD_IOB_ON            	(0x0001u)

#define PLL_CLKMD_TEST_OFF           	(0x0000u)
#define PLL_CLKMD_TEST_ON            	(0x0001u)

#define PLL_CLKMD_PLLMULT_OF(x)          	((Uint16)x)

#define PLL_CLKMD_PLLDIV_OF(x)           	((Uint16)x)

#define PLL_CLKMD_PLLENABLE_OFF           (0x0000u)
#define PLL_CLKMD_PLLENABLE_ON            (0x0001u)

#define PLL_CLKMD_BYPASSDIV_OF(x)         ((Uint16)x)

#define PLL_CLKMD_LOCK_OFF           	(0x0000u)
#define PLL_CLKMD_LOCK_ON            	(0x0001u)

/****************************************\
* PLL global typedef declarations
\****************************************/
/* device handle type */

#if (!(_PLL_ANALOG_SUPPORT))	//Digital PLL

/* device configuration structure */
typedef struct {
  Uint16 iai;
  Uint16 iob;
  Uint16 pllmult;
  Uint16 div;
} PLL_Config;

#else			//Analog PLL

typedef struct {
  Uint16 vcoonoff;
  Uint16 pllmult;
  Uint16 plldiv;
} PLL_Config;

#endif
/****************************************\
* PLL global function declarations
\****************************************/
CSLAPI void PLL_config(PLL_Config *Config);

#if (!(_PLL_ANALOG_SUPPORT))				//Digital PLL
	CSLAPI void PLL_configArgs(Uint16 iai, Uint16 iob, Uint16 pllmult, Uint16 div);
#else
	CSLAPI void PLL_configArgs(Uint16 vcoonoff, Uint16 pllmult,Uint16 plldiv);
#endif


CSLAPI void PLL_setFreq (Uint16 mul, Uint16 div);

#else
  #ifndef _PLL_MOD_ 						/*PLL_SUPPORT */
    #error PLL Module Not Supported on Specified Target
  #endif
#endif 								/*PLLA_SUPPORT */

#endif 								/* _PLLA_H_ */

/******************************************************************************\
* End of PLL.h
\******************************************************************************/

csl_pllAhal.h/  1049976912  0     0     0       10660     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... pllhal.h
* DATE CREATED.. Mon 06/05/2000
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. stdinc.h, chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   06/05/2000 (AP) created
*   07/05/2001 (IM) Modified to include support for both DPLL and APLL
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the PLL module)
*
* Registers Covered:
*   (RW) _PLL_CLKMD
\******************************************************************************/

#ifndef _PLLHAL_H_
#define _PLLHAL_H_

#include <csl_chiphal.h>

#if (_PLLA_SUPPORT)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _PLL_CLKMD
\*============================================================================*/
#define _PLL_CLKMD_ADDR					(0x1C00u)
#define _PLL_CLKMD                       		PREG16(_PLL_CLKMD_ADDR)
#define _CLKMD                              	_PLL_CLKMD

/*===========================================================================*\
* Generic PLL register/field get/set macros
\*===========================================================================*/

#define PLL_ADDR(Reg)                     _PLL_##Reg##_ADDR
#define PLL_RGET(Reg)                     _PREG_GET(PLL_ADDR(##Reg))
#define PLL_RSET(Reg,Val)                 _PREG_SET(PLL_ADDR(##Reg),Val)
#define PLL_RAOI(Reg,AND,OR,INV)          _PREG_AOI(PLL_ADDR(##Reg),AND,OR,INV)
#define PLL_FGET(Reg,Field)               _PFIELD_GET(PLL_ADDR(##Reg),_PLL_##Reg##_##Field)
#define PLL_FSET(Reg,Field,Val)\
  _PFIELD_SET(PLL_ADDR(##Reg),_PLL_##Reg##_##Field,Val)

#define PLL_FSETS(Reg,Field,Sym)\
  PLL_FSET(##Reg,##Field,PLL_##Reg##_##Field##_##Sym)

#define PLL_FAOI(Reg,Field,AND,OR,INV)\
  _PFIELD_AOI(PLL_ADDR(##Reg),_PLL_##Reg##_##Feld,AND,OR,INV)

#define PLL_FMK(Reg,Field,Val)            _PLL_##Reg##_##Field##_MK(Val)
#define PLL_FMKS(Reg,Field,Sym)           PLL_FMK(##Reg,##Field,PLL_##Reg##_##Field##_##Sym)


#if (!(_PLL_ANALOG_SUPPORT))	//Digital PLL

/*===========================================================================*\
* _PLL_CLKMD
*
* Fields:
*  (RW) _PLL_CLKMD_IAI
*  (RW) _PLL_CLKMD_IOB
*  (RW) _PLL_CLKMD_TEST
*  (RW) _PLL_CLKMD_PLLMULT
*  (RW) _PLL_CLKMD_PLLDIV
*  (RW) _PLL_CLKMD_PLLENABLE
*  (RW) _PLL_CLKMD_BYPASSDIV
*   (R) _PLL_CLKMD_BREAKLN
*   (R) _PLL_CLKMD_LOCK
\*==========================================================================*/

/*==========================================================================*\
* (RW) _PLL_CLKMD_IAI	- Initialize After Idle
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_IAI_SHIFT			(0x000Eu)
#define _PLL_CLKMD_IAI_MK(n)			(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_IAI_SHIFT)
#define _PLL_CLKMD_IAI_MASK       		(_PLL_CLKMD_IAI_MK(0x0001u))
#define _PLL_CLKMD_IAI_CLR        		(~(_PLL_CLKMD_IAI_MK(0x0001u)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_IOB	- Initialize on Break
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_IOB_SHIFT			(0x000Du)
#define _PLL_CLKMD_IOB_MK(n)			(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_IOB_SHIFT)
#define _PLL_CLKMD_IOB_MASK       		(_PLL_CLKMD_IOB_MK(0x0001u))
#define _PLL_CLKMD_IOB_CLR        		(~(_PLL_CLKMD_IOB_MK(0x0001u)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_TEST	- Test
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_TEST_SHIFT			(0x000Cu)
#define _PLL_CLKMD_TEST_MK(n)			(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_TEST_SHIFT)
#define _PLL_CLKMD_TEST_MASK       		(_PLL_CLKMD_TEST_MK(0x0001u))
#define _PLL_CLKMD_TEST_CLR        		(~(_PLL_CLKMD_TEST_MK(0x0001u)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_PLLMULT	- PLL Multiply Value
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_PLLMULT_SHIFT		(0x0007u)
#define _PLL_CLKMD_PLLMULT_MK(n)		(((Uint16)(n) & 0x001Fu) << _PLL_CLKMD_PLLMULT_SHIFT)
#define _PLL_CLKMD_PLLMULT_MASK       	(_PLL_CLKMD_PLLMULT_MK(0x001Fu))
#define _PLL_CLKMD_PLLMULT_CLR        	(~(_PLL_CLKMD_PLLMULT_MK(0x001Fu)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_PLLDIV	- PLL Divide Value
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_PLLDIV_SHIFT		(0x0005u)
#define _PLL_CLKMD_PLLDIV_MK(n)		(((Uint16)(n) & 0x0003u) << _PLL_CLKMD_PLLDIV_SHIFT)
#define _PLL_CLKMD_PLLDIV_MASK       	(_PLL_CLKMD_PLLDIV_MK(0x0003u))
#define _PLL_CLKMD_PLLDIV_CLR        	(~(_PLL_CLKMD_PLLDIV_MK(0x0003u)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_PLLENABLE	- PLL Enable Bit
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_PLLENABLE_SHIFT		(0x0004u)
#define _PLL_CLKMD_PLLENABLE_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_PLLENABLE_SHIFT)
#define _PLL_CLKMD_PLLENABLE_MASK       	(_PLL_CLKMD_PLLENABLE_MK(0x0001u))
#define _PLL_CLKMD_PLLENABLE_CLR        	(~(_PLL_CLKMD_PLLENABLE_MK(0x0001u)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_BYPASSDIV	- Determines CLKOUT Frequency
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_BYPASSDIV_SHIFT		(0x0002u)
#define _PLL_CLKMD_BYPASSDIV_MK(n)		(((Uint16)(n) & 0x0003u) << _PLL_CLKMD_BYPASSDIV_SHIFT)
#define _PLL_CLKMD_BYPASSDIV_MASK       	(_PLL_CLKMD_BYPASSDIV_MK(0x0003u))
#define _PLL_CLKMD_BYPASSDIV_CLR        	(~(_PLL_CLKMD_BYPASSDIV_MK(0x0003u)))

/*==========================================================================*\
* (R) _PLL_CLKMD_BREAKLN	- Broken Lock Bit
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_BREAKLN_SHIFT		(0x0001u)
#define _PLL_CLKMD_BREAKLN_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_BREAKLN_SHIFT)
#define _PLL_CLKMD_BREAKLN_MASK       	(_PLL_CLKMD_BREAKLN_MK(0x0001u))

/*==========================================================================*\
* (R) _PLL_CLKMD_LOCK	- Lock Mode Bit
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_LOCK_SHIFT			(0x0000u)
#define _PLL_CLKMD_LOCK_MK(n)			(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_LOCK_SHIFT)
#define _PLL_CLKMD_LOCK_MASK       		(_PLL_CLKMD_LOCK_MK(0x0001u))

/*==========================================================================*\
* _PLL_CLKMD 	- Config
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_CFG(iai,iob,test,pllmult,plldiv,pllenable,bypassdiv)  \
	_PREG_SET(_PLL_CLKMD_ADDR,							\
    		(Uint16) (	_PLL_CLKMD_IAI_MK(iai) 				|	\
				_PLL_CLKMD_IOB_MK(iob) 				|	\
				_PLL_CLKMD_TEST_MK(test) 			|	\
				_PLL_CLKMD_PLLMULT_MK(pllmult) 		|	\
				_PLL_CLKMD_PLLDIV_MK(plldiv) 			|	\
				_PLL_CLKMD_PLLENABLE_MK(pllenable) 		|	\
				_PLL_CLKMD_BYPASSDIV_MK(bypassdiv) 			\
	             ))

#else			// Analog PLL

/******************************************************************************\
* 
* _PLL_CLKMD	 - Note: Add description here
*
* Fields:
*	(RW)   _PLL_CLKMD_PLLENABLE	
*	(RW)   _PLL_CLKMD_PLLDIV	
*	(RW)   _PLL_CLKMD_PLLMULT	
*	(RW)   _PLL_CLKMD_VCOONOFF	
*
\******************************************************************************/


/*----------------------------------------------------------------*\
*   (RW)  _PLL_CLKMD_PLLENABLE:	
\*----------------------------------------------------------------*/

#define _PLL_CLKMD_PLLENABLE_SHIFT		(0x0004u)
#define _PLL_CLKMD_PLLENABLE_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_PLLENABLE_SHIFT)
#define _PLL_CLKMD_PLLENABLE_MASK		(_PLL_CLKMD_PLLENABLE_MK(0x0001u))
#define _PLL_CLKMD_PLLENABLE_CLR		(~(_PLL_CLKMD_PLLENABLE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_CLKMD_PLLDIV:	
\*----------------------------------------------------------------*/

#define _PLL_CLKMD_PLLDIV_SHIFT		(0x0005u)
#define _PLL_CLKMD_PLLDIV_MK(n)		(((Uint16)(n) & 0x0003u) << _PLL_CLKMD_PLLDIV_SHIFT)
#define _PLL_CLKMD_PLLDIV_MASK		(_PLL_CLKMD_PLLDIV_MK(0x0003u))
#define _PLL_CLKMD_PLLDIV_CLR		(~(_PLL_CLKMD_PLLDIV_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_CLKMD_PLLMULT:	
\*----------------------------------------------------------------*/

#define _PLL_CLKMD_PLLMULT_SHIFT		(0x0007u)
#define _PLL_CLKMD_PLLMULT_MK(n)		(((Uint16)(n) & 0x000fu) << _PLL_CLKMD_PLLMULT_SHIFT)
#define _PLL_CLKMD_PLLMULT_MASK		(_PLL_CLKMD_PLLMULT_MK(0x000fu))
#define _PLL_CLKMD_PLLMULT_CLR		(~(_PLL_CLKMD_PLLMULT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_CLKMD_VCOONOFF:	
\*----------------------------------------------------------------*/

#define _PLL_CLKMD_VCOONOFF_SHIFT		(0x000bu)
#define _PLL_CLKMD_VCOONOFF_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_VCOONOFF_SHIFT)
#define _PLL_CLKMD_VCOONOFF_MASK		(_PLL_CLKMD_VCOONOFF_MK(0x0001u))
#define _PLL_CLKMD_VCOONOFF_CLR		(~(_PLL_CLKMD_VCOONOFF_MASK))

/*==========================================================================*\
* _PLL_CLKMD 	- Config
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_CFG(vcoonoff,pllmult,plldiv,pllenable)  \
	_PREG_SET(_PLL_CLKMD_ADDR,							\
    		(Uint16) (	_PLL_CLKMD_VCOONOFF_MK(vcoonoff) 			|	\
				_PLL_CLKMD_PLLMULT_MK(pllmult) 		|	\
				_PLL_CLKMD_PLLDIV_MK(plldiv) 			|	\
				_PLL_CLKMD_PLLENABLE_MK(pllenable) 			\
	             ))

#endif

#else
   #ifndef _PLL_MOD_
     #error CLKMD Hal Module Not Supported on Specified Target
   #endif
#endif
#endif    

csl_pllB.h/     1065792226  0     0     0       13692     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... csl_pllB.h
* DATE CREATED.. Mon Jan 28 14:25:28 2002
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS..
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:  Mon Jan 28 14:25:28 2002 (Automatic generation)
*	 MODIFIED: 08/04/2003 Added CLKOUTSR register, Renamed CLKMD0 to CLKMD in
*                         Config structure and configArgs arguments list
*			   09/25/2003 Renamed WAKEUP -> WKEN, changed PLLDIV0,1,2,3 default
*						  value
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the PLLB module
*              Supports PLL for 5502
*
\*************************************************************************/

#ifndef _CSL_PLLB_H_
#define _CSL_PLLB_H_

#include <csl_pllBhal.h>
#include <csl_std.h>
#include <csl.h>
#include <csl_chiphal.h>

#if (_PLLB_SUPPORT)

/*----------------------------------------------------------------*\
*	 PLL scope and inline control macros
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _PLL_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/****************************************\
* PLL global macro declarations
\****************************************/

/* error codes */
#define PLL_ERR_MAJOR		   (ERR_BASE_PLL)
#define PLL_ERR_ALLOC		   (0x00000000)
#define PLL_ERR_INVALID_HANDLE  (0x00000001)

/* ============================================================== */
 /* Make OSCDIV1 register values based on symbolic constants  */

/*  OSCDIV1 field values  */

	#define PLL_OSCDIV1_OD1EN_DISABLED			(0x0000u)
	#define PLL_OSCDIV1_OD1EN_ENABLED			(0x0001u)
	#define PLL_OSCDIV1_OD1EN_DEFAULT		PLL_OSCDIV1_OD1EN_DISABLED

	#define PLL_OSCDIV1_OSCDIV1_OF(x)               ((Uint16)(x))
	#define PLL_OSCDIV1_OSCDIV1_DEFAULT			(0x0000u)


#define PLL_OSCDIV1_RMK(od1en,oscdiv1)\
 ((Uint16) ( \
  ( PLL_FMK(OSCDIV1,OD1EN,od1en))|\
  ( PLL_FMK(OSCDIV1,OSCDIV1,oscdiv1))\
)\
 )

#define PLL_OSCDIV1_RMKS(od1en_sym,oscdiv1_sym)\
 ((Uint16) ( \
  ( PLL_FMKS(OSCDIV1,OD1EN,od1en_sym))|\
  ( PLL_FMKS(OSCDIV1,OSCDIV1,oscdiv1_sym))\
)\
 )

/*  Default OSCDIV1 register value  */

/* ============================================================== */
 /* Make PLLCSR register values based on symbolic constants  */

/*  PLLCSR field values  */

	#define PLL_PLLCSR_STABLE_UNSTABLE			(000000u)
	#define PLL_PLLCSR_STABLE_STABLE			(0x0001u)
	#define PLL_PLLCSR_STABLE_DEFAULT		PLL_PLLCSR_STABLE_UNSTABLE

	#define PLL_PLLCSR_LOCK_NOTLOCKED			(0x0000u)
	#define PLL_PLLCSR_LOCK_LOCKED			(0x0001u)
	#define PLL_PLLCSR_LOCK_DEFAULT		PLL_PLLCSR_LOCK_NOTLOCKED

	#define PLL_PLLCSR_PLLRST_RESET_RELEASED		(0x0000u)
	#define PLL_PLLCSR_PLLRST_RESET_ASSERTED		(0x0001u)
	#define PLL_PLLCSR_PLLRST_DEFAULT		PLL_PLLCSR_PLLRST_RESET_RELEASED

	#define PLL_PLLCSR_OSCPWRDN_OSC_ON			(0x0000u)
	#define PLL_PLLCSR_OSCPWRDN_OSC_PWRDN		(0x0001u)
	#define PLL_PLLCSR_OSCPWRDN_DEFAULT		PLL_PLLCSR_OSCPWRDN_OSC_ON

	#define PLL_PLLCSR_PLLPWRDN_PLL_ON			(0x0000u)
	#define PLL_PLLCSR_PLLPWRDN_PLL_PWRDN		(0x0001u)
	#define PLL_PLLCSR_PLLPWRDN_DEFAULT		PLL_PLLCSR_PLLPWRDN_PLL_ON

	#define PLL_PLLCSR_PLLEN_BYPASS_MODE		(0x0000u)
	#define PLL_PLLCSR_PLLEN_PLL_MODE			(0x0001u)
	#define PLL_PLLCSR_PLLEN_DEFAULT		PLL_PLLCSR_PLLEN_BYPASS_MODE


#define PLL_PLLCSR_RMK(pllrst,oscpwrdn,pllpwrdn,pllen)\
 ((Uint16) ( \
  ( PLL_FMK(PLLCSR,PLLRST,pllrst))|\
  ( PLL_FMK(PLLCSR,OSCPWRDN,oscpwrdn))|\
  ( PLL_FMK(PLLCSR,PLLPWRDN,pllpwrdn))|\
  ( PLL_FMK(PLLCSR,PLLEN,pllen))\
)\
 )

#define PLL_PLLCSR_RMKS(pllrst_sym,oscpwrdn_sym,pllpwrdn_sym,pllen_sym)\
 ((Uint16) ( \
  ( PLL_FMKS(PLLCSR,PLLRST,pllrst_sym))|\
  ( PLL_FMKS(PLLCSR,OSCPWRDN,oscpwrdn_sym))|\
  ( PLL_FMKS(PLLCSR,PLLPWRDN,pllpwrdn_sym))|\
  ( PLL_FMKS(PLLCSR,PLLEN,pllen_sym))\
)\
 )

/*  Default PLLCSR register value  */

/* ============================================================== */
 /* Make PLLDIV0 register values based on symbolic constants  */

/*  PLLDIV0 field values  */

	#define PLL_PLLDIV0_D0EN_DISABLED			(0x0000u)
	#define PLL_PLLDIV0_D0EN_ENABLED			(0x0001u)
	#define PLL_PLLDIV0_D0EN_DEFAULT		PLL_PLLDIV0_D0EN_ENABLED

	#define PLL_PLLDIV0_PLLDIV0_OF(x)			((Uint16)(x))
	#define PLL_PLLDIV0_PLLDIV0_DEFAULT		      (0x0000u)


#define PLL_PLLDIV0_RMK(d0en,plldiv0)\
 ((Uint16) ( \
  ( PLL_FMK(PLLDIV0,D0EN,d0en))|\
  ( PLL_FMK(PLLDIV0,PLLDIV0,plldiv0))\
)\
 )

#define PLL_PLLDIV0_RMKS(d0en_sym,plldiv0_sym)\
 ((Uint16) ( \
  ( PLL_FMKS(PLLDIV0,D0EN,d0en_sym))|\
  ( PLL_FMKS(PLLDIV0,PLLDIV0,plldiv0_sym))\
)\
 )

/*  Default PLLDIV0 register value  */

/* ============================================================== */
 /* Make PLLDIV1 register values based on symbolic constants  */

/*  PLLDIV1 field values  */

	#define PLL_PLLDIV1_D1EN_DISABLED			(0x0000u)
	#define PLL_PLLDIV1_D1EN_ENABLED			(0x0001u)
	#define PLL_PLLDIV1_D1EN_DEFAULT		PLL_PLLDIV1_D1EN_ENABLED

	#define PLL_PLLDIV1_PLLDIV1_OF(x)		      ((Uint16)(x))
	#define PLL_PLLDIV1_PLLDIV1_DEFAULT		      (0x0003u)


#define PLL_PLLDIV1_RMK(d1en,plldiv1)\
 ((Uint16) ( \
  ( PLL_FMK(PLLDIV1,D1EN,d1en))|\
  ( PLL_FMK(PLLDIV1,PLLDIV1,plldiv1))\
)\
 )

#define PLL_PLLDIV1_RMKS(d1en_sym,plldiv1_sym)\
 ((Uint16) ( \
  ( PLL_FMKS(PLLDIV1,D1EN,d1en_sym))|\
  ( PLL_FMKS(PLLDIV1,PLLDIV1,plldiv1_sym))\
)\
 )

/*  Default PLLDIV1 register value  */

/* ============================================================== */
 /* Make PLLDIV2 register values based on symbolic constants  */

/*  PLLDIV2 field values  */

	#define PLL_PLLDIV2_D2EN_DISABLED			(0x0000u)
	#define PLL_PLLDIV2_D2EN_ENABLED			(0x0001u)
	#define PLL_PLLDIV2_D2EN_DEFAULT		PLL_PLLDIV2_D2EN_ENABLED

	#define PLL_PLLDIV2_PLLDIV2_OF(x)		       ((Uint16)(x))
	#define PLL_PLLDIV2_PLLDIV2_DEFAULT		       (0x0003u)


#define PLL_PLLDIV2_RMK(d2en,plldiv2)\
 ((Uint16) ( \
  ( PLL_FMK(PLLDIV2,D2EN,d2en))|\
  ( PLL_FMK(PLLDIV2,PLLDIV2,plldiv2))\
)\
 )

#define PLL_PLLDIV2_RMKS(d2en_sym,plldiv2_sym)\
 ((Uint16) ( \
  ( PLL_FMKS(PLLDIV2,D2EN,d2en_sym))|\
  ( PLL_FMKS(PLLDIV2,PLLDIV2,plldiv2_sym))\
)\
 )

/*  Default PLLDIV2 register value  */

/* ============================================================== */
 /* Make PLLDIV3 register values based on symbolic constants  */

/*  PLLDIV3 field values  */

	#define PLL_PLLDIV3_D3EN_DISABLED			(0x0000u)
	#define PLL_PLLDIV3_D3EN_ENABLED			(0x0001u)
	#define PLL_PLLDIV3_D3EN_DEFAULT		PLL_PLLDIV3_D3EN_ENABLED

	#define PLL_PLLDIV3_PLLDIV3_OF(x)			((Uint16)(x))
	#define PLL_PLLDIV3_PLLDIV3_DEFAULT		      (0x0003u)


#define PLL_PLLDIV3_RMK(d3en,plldiv3)\
 ((Uint16) ( \
  ( PLL_FMK(PLLDIV3,D3EN,d3en))|\
  ( PLL_FMK(PLLDIV3,PLLDIV3,plldiv3))\
)\
 )

#define PLL_PLLDIV3_RMKS(d3en_sym,plldiv3_sym)\
 ((Uint16) ( \
  ( PLL_FMKS(PLLDIV3,D3EN,d3en_sym))|\
  ( PLL_FMKS(PLLDIV3,PLLDIV3,plldiv3_sym))\
)\
 )

/*  Default PLLDIV3 register value  */

/* ============================================================== */
 /* Make PLLM register values based on symbolic constants  */

/*  PLLM field values  */

	#define PLL_PLLM_PLLM_OF(x)			((Uint16)(x))
	#define PLL_PLLM_PLLM_DEFAULT		      (0x0000u)


#define PLL_PLLM_RMK(pllm)\
 ((Uint16) ( \
  ( PLL_FMK(PLLM,PLLM,pllm))\
)\
 )

#define PLL_PLLM_RMKS(pllm_sym)\
 ((Uint16) ( \
  ( PLL_FMKS(PLLM,PLLM,pllm_sym))\
)\
 )

/*  Default PLLM register value  */

/* ============================================================== */
 /* Make WKEN register values based on symbolic constants  */

/*  WKEN field values  */

	#define PLL_WKEN_WKEN4_DISABLED			(0x0001u)
	#define PLL_WKEN_WKEN4_ENABLED			(0x0000u)
	#define PLL_WKEN_WKEN4_DEFAULT		PLL_WKEN_WKEN4_DISABLED

	#define PLL_WKEN_WKEN3_DISABLED			(0x0001u)
	#define PLL_WKEN_WKEN3_ENABLED			(0x0000u)
	#define PLL_WKEN_WKEN3_DEFAULT		PLL_WKEN_WKEN3_DISABLED

	#define PLL_WKEN_WKEN2_DISABLED			(0x0001u)
	#define PLL_WKEN_WKEN2_ENABLED			(0x0000u)
	#define PLL_WKEN_WKEN2_DEFAULT		PLL_WKEN_WKEN2_DISABLED

	#define PLL_WKEN_WKEN1_DISABLED			(0x0001u)
	#define PLL_WKEN_WKEN1_ENABLED			(0x0000u)
	#define PLL_WKEN_WKEN1_DEFAULT		PLL_WKEN_WKEN1_DISABLED

	#define PLL_WKEN_WKEN0_DISABLED			(0x0001u)
	#define PLL_WKEN_WKEN0_ENABLED			(0x0000u)
	#define PLL_WKEN_WKEN0_DEFAULT		PLL_WKEN_WKEN0_DISABLED


#define PLL_WKEN_RMK(wken4,wken3,wken2,wken1,wken0)\
 ((Uint16) ( \
  ( PLL_FMK(WKEN,WKEN4,wken4))|\
  ( PLL_FMK(WKEN,WKEN3,wken3))|\
  ( PLL_FMK(WKEN,WKEN2,wken2))|\
  ( PLL_FMK(WKEN,WKEN1,wken1))|\
  ( PLL_FMK(WKEN,WKEN0,wken0))\
)\
 )

#define PLL_WKEN_RMKS(wken4_sym,wken3_sym,wken2_sym,wken1_sym,wken0_sym)\
 ((Uint16) ( \
  ( PLL_FMKS(WKEN,WKEN4,wken4_sym))|\
  ( PLL_FMKS(WKEN,WKEN3,wken3_sym))|\
  ( PLL_FMKS(WKEN,WKEN2,wken2_sym))|\
  ( PLL_FMKS(WKEN,WKEN1,wken1_sym))|\
  ( PLL_FMKS(WKEN,WKEN0,wken0_sym))\
)\
 )

/*  Default CLKMD register value  */

/* ============================================================== */
 /* Make CLKMD register values based on symbolic constants  */

/*  CLKMD field values  */

#define PLL_CLKMD_CLKMD0_OSCOUT        (0x0000u)
#define PLL_CLKMD_CLKMD0_CLKIN        (0x0001u)
#define PLL_CLKMD_CLKMD0_DEFAULT      PLL_CLKMD_CLKMD0_OSCOUT

#define PLL_CLKMD_RMK(clkmd0)\
 ((Uint16)PLL_FMK(CLKMD,CLKMD0,clkmd0))

#define PLL_CLKMD_RMKS(clkmd0_sym)\
 ((Uint16)PLL_FMKS(CLKMD,CLKMD0,clkmd0_sym))

/*  Default CLKOUTSR register value  */

/* ============================================================== */
 /* Make CLKOUTSR register values based on symbolic constants  */

/*  CLKOUTSR field values  */

#define PLL_CLKOUTSR_CLKOSEL_SYSCLK1        (0x0001u)
#define PLL_CLKOUTSR_CLKOSEL_SYSCLK2        (0x0002u)
#define PLL_CLKOUTSR_CLKOSEL_SYSCLK3        (0x0003u)
#define PLL_CLKOUTSR_CLKOSEL_DEFAULT      PLL_CLKOUTSR_CLKOSEL_SYSCLK1

#define PLL_CLKOUTSR_CLKOUTDIS_ENABLED      (0x0000u)
#define PLL_CLKOUTSR_CLKOUTDIS_DISABLED     (0x0001u)
#define PLL_CLKOUTSR_CLKOUTDIS_DEFAULT     PLL_CLKOUTSR_CLKOUTDIS_ENABLED

#define PLL_CLKOUTSR_RMK(clkosel,clkoutdis)\
 ((Uint16)((PLL_FMK(CLKOUTSR,CLKOSEL,clkosel)) |\
           (PLL_FMK(CLKOUTSR,CLKOUTDIS,clkoutdis)))\
 )

#define PLL_CLKOUTSR_RMKS(clkosel_sym,clkoutdis_sym)\
 ((Uint16)((PLL_FMKS(CLKOUTSR,CLKOSEL,clkosel_sym)) |\
           (PLL_FMKS(CLKOUTSR,CLKOUTDIS,clkoutdis_sym)))\
 )

/*  Default CK3SEL register value  */

/* ============================================================== */
 /* Make CK3SEL register values based on symbolic constants  */

/*  CK3SEL field values  */

#define PLL_CK3SEL_CK3SEL_PLL        (0x000Bu)
#define PLL_CK3SEL_CK3SEL_DIV0		 (0x000Au)
#define PLL_CK3SEL_CK3SEL_NOCHANGE	 (0x0009u)
#define PLL_CK3SEL_CK3SEL_DEFAULT    PLL_CK3SEL_CK3SEL_PLL

#define PLL_CK3SEL_RMK(ck3sel)\
 ((Uint16)PLL_FMK(CK3SEL,CK3SEL,(ck3sel & PLL_CK3SEL_CK3SEL_PLL)))

#define PLL_CK3SEL_RMKS(ck3sel_sym)\
 ((Uint16)((PLL_FMKS(CK3SEL,CK3SEL,PLL)) & \
           (PLL_FMKS(CK3SEL,CK3SEL,ck3sel_sym))) \
 )

/*************************************************\
 PLL global typedef declarations
\*************************************************/

typedef struct {
	Uint16 pllcsr;
	Uint16 pllm;
	Uint16 plldiv0;
	Uint16 plldiv1;
	Uint16 plldiv2;
	Uint16 plldiv3;
	Uint16 oscdiv1;
	Uint16 wken;
	Uint16 clkmd;
	Uint16 clkoutsr;
} PLL_Config;

/*************************************************\
* PLL global variable declarations
\*************************************************/


/*************************************************\
* PLL global function declarations
\*************************************************/

CSLAPI void PLL_config(PLL_Config *myConfig);
CSLAPI void PLL_configArgs(Uint16 pllcsr,Uint16 pllm,Uint16 plldiv0,Uint16 plldiv1,Uint16 plldiv2,Uint16 plldiv3,
                           Uint16 oscdiv1,Uint16 wken,Uint16 clkmd, Uint16 clkoutsr);

CSLAPI void PLL_setFreq (Uint16 mode, Uint16 mul, Uint16 div0, Uint16 div1, Uint16 div2,
                  Uint16 div3, Uint16 oscdiv);

/*************************************************\
* PLL inline function declarations
\*************************************************/


#ifdef USEDEFS


/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/

#endif /*USEDEFS */

#elif (!(_PLL_MOD))
	#error PLL Hal Module Not Supported on Specified Target
#endif  /* _PLLB_SUPPORT  */

#endif  /* _CSL_PLLBHAL_H  */

/******************************************************************************\
*
*      End of csl_pllB.h
*
\******************************************************************************/
csl_pllBhal.h/  1074583734  0     0     0       27621     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... csl_pllhal.h
* DATE CREATED.. Mon Jan 28 14:25:28 2002
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS..
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Mon Jan 28 14:25:28 2002 (Automatic generation)
*	 MODIFIED:  08/04/2003 Added CLKOUTSR, Renamed CLKMD0 to CLKMD
*		    09/25/2003 Renamed WAKEUP -> WKEN
*                   01/18/2004 Fixed the problem - C5502 CSL- PLL macros give
*                               error if register and field names are same           

*------------------------------------------------------------------------------
* DESCRIPTION: CSL HAL interface file for the PLL module
*
* Registers covered:
*
* 		 Note: Add registers description here
*	 PLLCSR
*	 PLLM
*	 PLLDIV0
*	 PLLDIV1
*	 PLLDIV2
*	 PLLDIV3
*	 OSCDIV1
*	 WKEN
*	 CLKMD
*    CK3SEL
*    CLKOUTSR
*
\*************************************************************************/

#ifndef _CSL_PLLBHAL_H_
#define _CSL_PLLBHAL_H_

#include <csl_chiphal.h>

#if (_PLLB_SUPPORT)

/*----------------------------------------------------------------*\
*	 PLL scope and inline control macros
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _PLL_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/*----------------------------------------------------------------*\
*		 Address Macros
\*----------------------------------------------------------------*/

/*--------------------- Register: PLLCSR -----------------------*/
#define _PLL_PLLCSR_ADDR		(0x1c80u)
#define _PLL_PLLCSR			PREG16(_PLL_PLLCSR_ADDR)


/*--------------------- Register: PLLM -----------------------*/
#define _PLL_PLLM_ADDR		(0x1c88u)
#define _PLL_PLLM			PREG16(_PLL_PLLM_ADDR)


/*--------------------- Register: PLLDIV0 -----------------------*/
#define _PLL_PLLDIV0_ADDR		(0x1c8au)
#define _PLL_PLLDIV0			PREG16(_PLL_PLLDIV0_ADDR)


/*--------------------- Register: PLLDIV1 -----------------------*/
#define _PLL_PLLDIV1_ADDR		(0x1c8cu)
#define _PLL_PLLDIV1			PREG16(_PLL_PLLDIV1_ADDR)


/*--------------------- Register: PLLDIV2 -----------------------*/
#define _PLL_PLLDIV2_ADDR		(0x1c8eu)
#define _PLL_PLLDIV2			PREG16(_PLL_PLLDIV2_ADDR)


/*--------------------- Register: PLLDIV3 -----------------------*/
#define _PLL_PLLDIV3_ADDR		(0x1c90u)
#define _PLL_PLLDIV3			PREG16(_PLL_PLLDIV3_ADDR)


/*--------------------- Register: OSCDIV1 -----------------------*/
#define _PLL_OSCDIV1_ADDR		(0x1c92u)
#define _PLL_OSCDIV1			PREG16(_PLL_OSCDIV1_ADDR)


/*--------------------- Register: WKEN -----------------------*/
#define _PLL_WKEN_ADDR	(0x1c98u)
#define _PLL_WKEN			PREG16(_PLL_WKEN_ADDR)

/*--------------------- Register: CLKMD0 -----------------------*/
#define _PLL_CLKMD_ADDR		(0x8c00u)
#define _PLL_CLKMD			PREG16(_PLL_CLKMD_ADDR)

/*--------------------- Register: CK3SEL -----------------------*/
#define _PLL_CK3SEL_ADDR	(0x1c82u)
#define _PLL_CK3SEL			PREG16(_PLL_CK3SEL_ADDR)

/*--------------------- Register: CLKOUTSR  -----------------------*/
#define _PLL_CLKOUTSR_ADDR		(0x8400u)
#define _PLL_CLKOUTSR			PREG16(_PLL_CLKOUTSR_ADDR)

/*----------------------------------------------------------------*\
*		 Register Macros
\*----------------------------------------------------------------*/

#define PLL_ADDR(Reg)		  _PLL_##Reg##_ADDR
#define PLL_RGET(Reg)		  _PLL_##Reg##_GET
#define PLL_RSET(Reg,Val)		  _PLL_##Reg##_SET(Val)
#define PLL_FGET(Reg,Field)		  _PLL_##Reg##_FGET(Field)
#define PLL_FSET(Reg,Field,Val)		  _PLL_##Reg##_FSET(Field, Val)
#define PLL_FMK(Reg,Field,Val)		  _PLL_##Reg##_##Field##_MK(Val)
#define PLL_RAOI(Reg,AND,OR,INV)		  _PLL_##Reg##_AOI(AND,OR,INV)
#define PLL_FAOI(Reg,Field,AND,OR,INV)	  _PLL_##Reg##_FAOI(Field,AND,OR,INV)
#define PLL_FMKS(Reg,Field,Sym)\
	  _PLL_##Reg##_##Field##_MK(PLL_##Reg##_##Field##_##Sym)
#define PLL_FSETS(Reg,Field,Sym)\
	  _PLL_FSET(##Reg,##Field,PLL_##Reg##_##Field##_##Sym)

/*----------------------------------------------------------------*\
*		 Non-handle Registers Macros
\*----------------------------------------------------------------*/


/*--------------------- Register: PLLCSR -----------------------*/
#define _PLL_PLLCSR_GET		  _PREG_GET(_PLL_PLLCSR_ADDR)
#define _PLL_PLLCSR_SET(Val)		  _PREG_SET(_PLL_PLLCSR_ADDR,Val)
#define _PLL_PLLCSR_FGET(Field)	  _PFIELD_GET(_PLL_PLLCSR_ADDR, _PLL_PLLCSR_##Field)
#define _PLL_PLLCSR_FSET(Field,Val)	  _PFIELD_SET(_PLL_PLLCSR_ADDR, _PLL_PLLCSR_##Field, Val)
#define _PLL_PLLCSR_AOI(AND,OR,INV)	  _PREG_AOI(_PLL_PLLCSR_ADDR,AND,OR,INV)
#define _PLL_PLLCSR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_PLL_PLLCSR_ADDR, _PLL_PLLCSR_##Field,AND,OR,INV)


/*--------------------- Register: PLLM -----------------------*/
#define _PLL_PLLM_GET		  _PREG_GET(_PLL_PLLM_ADDR)
#define _PLL_PLLM_SET(Val)		  _PREG_SET(_PLL_PLLM_ADDR,Val)
#define _PLL_PLLM_FGET(Field)	  _PFIELD_GET(_PLL_PLLM_ADDR, _PLL_PLLM_##Field)
#define _PLL_PLLM_FSET(Field,Val)	  _PFIELD_SET(_PLL_PLLM_ADDR, _PLL_PLLM_##Field, Val)
#define _PLL_PLLM_AOI(AND,OR,INV)	  _PREG_AOI(_PLL_PLLM_ADDR,AND,OR,INV)
#define _PLL_PLLM_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_PLL_PLLM_ADDR, _PLL_PLLM_##Field,AND,OR,INV)


/*--------------------- Register: PLLDIV0 -----------------------*/
#define _PLL_PLLDIV0_GET		  _PREG_GET(_PLL_PLLDIV0_ADDR)
#define _PLL_PLLDIV0_SET(Val)		  _PREG_SET(_PLL_PLLDIV0_ADDR,Val)
#define _PLL_PLLDIV0_FGET(Field)	  _PFIELD_GET(_PLL_PLLDIV0_ADDR, _PLL_PLLDIV0_##Field)
#define _PLL_PLLDIV0_FSET(Field,Val)	  _PFIELD_SET(_PLL_PLLDIV0_ADDR, _PLL_PLLDIV0_##Field, Val)
#define _PLL_PLLDIV0_AOI(AND,OR,INV)	  _PREG_AOI(_PLL_PLLDIV0_ADDR,AND,OR,INV)
#define _PLL_PLLDIV0_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_PLL_PLLDIV0_ADDR, _PLL_PLLDIV0_##Field,AND,OR,INV)


/*--------------------- Register: PLLDIV1 -----------------------*/
#define _PLL_PLLDIV1_GET		  _PREG_GET(_PLL_PLLDIV1_ADDR)
#define _PLL_PLLDIV1_SET(Val)		  _PREG_SET(_PLL_PLLDIV1_ADDR,Val)
#define _PLL_PLLDIV1_FGET(Field)	  _PFIELD_GET(_PLL_PLLDIV1_ADDR, _PLL_PLLDIV1_##Field)
#define _PLL_PLLDIV1_FSET(Field,Val)	  _PFIELD_SET(_PLL_PLLDIV1_ADDR, _PLL_PLLDIV1_##Field, Val)
#define _PLL_PLLDIV1_AOI(AND,OR,INV)	  _PREG_AOI(_PLL_PLLDIV1_ADDR,AND,OR,INV)
#define _PLL_PLLDIV1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_PLL_PLLDIV1_ADDR, _PLL_PLLDIV1_##Field,AND,OR,INV)


/*--------------------- Register: PLLDIV2 -----------------------*/
#define _PLL_PLLDIV2_GET		  _PREG_GET(_PLL_PLLDIV2_ADDR)
#define _PLL_PLLDIV2_SET(Val)		  _PREG_SET(_PLL_PLLDIV2_ADDR,Val)
#define _PLL_PLLDIV2_FGET(Field)	  _PFIELD_GET(_PLL_PLLDIV2_ADDR, _PLL_PLLDIV2_##Field)
#define _PLL_PLLDIV2_FSET(Field,Val)	  _PFIELD_SET(_PLL_PLLDIV2_ADDR, _PLL_PLLDIV2_##Field, Val)
#define _PLL_PLLDIV2_AOI(AND,OR,INV)	  _PREG_AOI(_PLL_PLLDIV2_ADDR,AND,OR,INV)
#define _PLL_PLLDIV2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_PLL_PLLDIV2_ADDR, _PLL_PLLDIV2_##Field,AND,OR,INV)


/*--------------------- Register: PLLDIV3 -----------------------*/
#define _PLL_PLLDIV3_GET		  _PREG_GET(_PLL_PLLDIV3_ADDR)
#define _PLL_PLLDIV3_SET(Val)		  _PREG_SET(_PLL_PLLDIV3_ADDR,Val)
#define _PLL_PLLDIV3_FGET(Field)	  _PFIELD_GET(_PLL_PLLDIV3_ADDR, _PLL_PLLDIV3_##Field)
#define _PLL_PLLDIV3_FSET(Field,Val)	  _PFIELD_SET(_PLL_PLLDIV3_ADDR, _PLL_PLLDIV3_##Field, Val)
#define _PLL_PLLDIV3_AOI(AND,OR,INV)	  _PREG_AOI(_PLL_PLLDIV3_ADDR,AND,OR,INV)
#define _PLL_PLLDIV3_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_PLL_PLLDIV3_ADDR, _PLL_PLLDIV3_##Field,AND,OR,INV)


/*--------------------- Register: OSCDIV1 -----------------------*/
#define _PLL_OSCDIV1_GET		  _PREG_GET(_PLL_OSCDIV1_ADDR)
#define _PLL_OSCDIV1_SET(Val)		  _PREG_SET(_PLL_OSCDIV1_ADDR,Val)
#define _PLL_OSCDIV1_FGET(Field)	  _PFIELD_GET(_PLL_OSCDIV1_ADDR, _PLL_OSCDIV1_##Field)
#define _PLL_OSCDIV1_FSET(Field,Val)	  _PFIELD_SET(_PLL_OSCDIV1_ADDR, _PLL_OSCDIV1_##Field, Val)
#define _PLL_OSCDIV1_AOI(AND,OR,INV)	  _PREG_AOI(_PLL_OSCDIV1_ADDR,AND,OR,INV)
#define _PLL_OSCDIV1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_PLL_OSCDIV1_ADDR, _PLL_OSCDIV1_##Field,AND,OR,INV)


/*--------------------- Register: WKEN -----------------------*/
#define _PLL_WKEN_GET		  _PREG_GET(_PLL_WKEN_ADDR)
#define _PLL_WKEN_SET(Val)		  _PREG_SET(_PLL_WKEN_ADDR,Val)
#define _PLL_WKEN_FGET(Field)	  _PFIELD_GET(_PLL_WKEN_ADDR, _PLL_WKEN_##Field)
#define _PLL_WKEN_FSET(Field,Val)	  _PFIELD_SET(_PLL_WKEN_ADDR, _PLL_WKEN_##Field, Val)
#define _PLL_WKEN_AOI(AND,OR,INV)	  _PREG_AOI(_PLL_WKEN_ADDR,AND,OR,INV)
#define _PLL_WKEN_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_PLL_WKEN_ADDR, _PLL_WKEN_##Field,AND,OR,INV)


/*--------------------- Register:  -----------------------*/
#define _PLL_CLKMD_GET  	 _PREG_GET(_PLL_CLKMD_ADDR)
#define _PLL_CLKMD_SET(Val) 		 _PREG_SET(_PLL_CLKMD_ADDR,Val)
#define _PLL_CLKMD_FGET(Field)   _PFIELD_GET(_PLL_CLKMD_ADDR, _PLL_CLKMD_##Field)
#define _PLL_CLKMD_FSET(Field,Val)   _PFIELD_SET(_PLL_CLKMD_ADDR, _PLL_CLKMD_##Field, Val)
#define _PLL_CLKMD_AOI(AND,OR,INV)   _PREG_AOI(_PLL_CLKMD_ADDR,AND,OR,INV)
#define _PLL_CLKMD_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_PLL_CLKMD_ADDR, _PLL__##Field,AND,OR,INV)

/*--------------------- Register:  -----------------------*/
#define _PLL_CK3SEL_GET		  _PREG_GET(_PLL_CK3SEL_ADDR)
#define _PLL_CK3SEL_SET(Val)		  _PREG_SET(_PLL_CK3SEL_ADDR,Val)
#define _PLL_CK3SEL_FGET(Field)	  _PFIELD_GET(_PLL_CK3SEL_ADDR, _PLL_CK3SEL_##Field)
#define _PLL_CK3SEL_FSET(Field,Val)	  _PFIELD_SET(_PLL_CK3SEL_ADDR, _PLL_CK3SEL_##Field, Val)
#define _PLL_CK3SEL_AOI(AND,OR,INV)	  _PREG_AOI(_PLL_CK3SEL_ADDR,AND,OR,INV)
#define _PLL_CK3SEL_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_PLL_CK3SEL_ADDR, _PLL__##Field,AND,OR,INV)

/*--------------------- Register:  -----------------------*/
#define _PLL_CLKOUTSR_GET		        _PREG_GET(_PLL_CLKOUTSR_ADDR)
#define _PLL_CLKOUTSR_SET(Val)		  _PREG_SET(_PLL_CLKOUTSR_ADDR,Val)
#define _PLL_CLKOUTSR_FGET(Field)	        _PFIELD_GET(_PLL_CLKOUTSR_ADDR, _PLL_CLKOUTSR_##Field)
#define _PLL_CLKOUTSR_FSET(Field,Val)	  _PFIELD_SET(_PLL_CLKOUTSR_ADDR, _PLL_CLKOUTSR_##Field, Val)
#define _PLL_CLKOUTSR_AOI(AND,OR,INV)	  _PREG_AOI(_PLL_CLKOUTSR_ADDR,AND,OR,INV)
#define _PLL_CLKOUTSR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_PLL_CLKOUTSR_ADDR, _PLL__##Field,AND,OR,INV)


/******************************************************************************\
*
* _PLL_CLKMD	 - Clock Mode Control Register
*
* Fields:
*	(RW)   _PLL_CLKMD_CLKMD0
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _PLL_CLKMD_CLKMD0:
\*----------------------------------------------------------------*/

#define _PLL_CLKMD_CLKMD0_SHIFT 	   (000000u)
#define _PLL_CLKMD_CLKMD0_MK(n) 	   (((Uint16)(n) & 0x0001u) << _PLL_CLKMD_CLKMD0_SHIFT)
#define _PLL_CLKMD_CLKMD0_MASK     (_PLL_CLKMD_CLKMD0_MK(0x0001u))
#define _PLL_CLKMD_CLKMD0_CLR	   (~(_PLL_CLKMD_CLKMD0_MASK))

/******************************************************************************\
*
* _PLL_CLKOUTSR	 - CLKOUT Selection Register
*
* Fields:
*	(RW)   _PLL_CLKOUTSR_CLKOUTDIS
*   (RW)   _PLL_CLKOUTSR_CLKOSEL
*
\******************************************************************************/

/*----------------------------------------------------------------*\
*   (RW)  _PLL_CLKOUTSR_CLKOUTDIS:
\*----------------------------------------------------------------*/

#define _PLL_CLKOUTSR_CLKOUTDIS_SHIFT		(000000u)
#define _PLL_CLKOUTSR_CLKOUTDIS_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_CLKOUTSR_CLKOUTDIS_SHIFT)
#define _PLL_CLKOUTSR_CLKOUTDIS_MASK		(_PLL_CLKOUTSR_CLKOUTDIS_MK(0x0001u))
#define _PLL_CLKOUTSR_CLKOUTDIS_CLR		(~(_PLL_CLKOUTSR_CLKOUTDIS_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _PLL_CLKOUTSR_CLKOSEL:
\*----------------------------------------------------------------*/

#define _PLL_CLKOUTSR_CLKOSEL_SHIFT		(000001u)
#define _PLL_CLKOUTSR_CLKOSEL_MK(n)		(((Uint16)(n) & 0x0003u) << _PLL_CLKOUTSR_CLKOSEL_SHIFT)
#define _PLL_CLKOUTSR_CLKOSEL_MASK		(_PLL_CLKOUTSR_CLKOSEL_MK(0x0003u))
#define _PLL_CLKOUTSR_CLKOSEL_CLR		(~(_PLL_CLKOUTSR_CLKOSEL_MASK))


/******************************************************************************\
*
* _PLL_CK3SEL	 - CLKOUT3 Select Register
*
* Fields:
*	(RW)   _PLL_CK3SEL_CK3SEL
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _PLL_CK3SEL_CK3SEL:
\*----------------------------------------------------------------*/

#define _PLL_CK3SEL_CK3SEL_SHIFT		(000000u)
#define _PLL_CK3SEL_CK3SEL_MK(n)		(((Uint16)(n) & 0x000fu) << _PLL_CK3SEL_CK3SEL_SHIFT)
#define _PLL_CK3SEL_CK3SEL_MASK		(_PLL_CK3SEL_CK3SEL_MK(0x000fu))
#define _PLL_CK3SEL_CK3SEL_CLR		(~(_PLL_CK3SEL_CK3SEL_MASK))




/******************************************************************************\
*
* _PLL_OSCDIV1	 - Oscillator divide down register
*
* Fields:
*	(RW)   _PLL_OSCDIV1_OSCDIV1
*	(RW)   _PLL_OSCDIV1_OD1EN
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _PLL_OSCDIV1_OSCDIV1:
\*----------------------------------------------------------------*/

#define _PLL_OSCDIV1_OSCDIV1_SHIFT		(000000u)
#define _PLL_OSCDIV1_OSCDIV1_MK(n)		(((Uint16)(n) & 0x001fu) << _PLL_OSCDIV1_OSCDIV1_SHIFT)
#define _PLL_OSCDIV1_OSCDIV1_MASK		(_PLL_OSCDIV1_OSCDIV1_MK(0x001fu))
#define _PLL_OSCDIV1_OSCDIV1_CLR		(~(_PLL_OSCDIV1_OSCDIV1_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_OSCDIV1_OD1EN:
\*----------------------------------------------------------------*/

#define _PLL_OSCDIV1_OD1EN_SHIFT		(0x000fu)
#define _PLL_OSCDIV1_OD1EN_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_OSCDIV1_OD1EN_SHIFT)
#define _PLL_OSCDIV1_OD1EN_MASK		(_PLL_OSCDIV1_OD1EN_MK(0x0001u))
#define _PLL_OSCDIV1_OD1EN_CLR		(~(_PLL_OSCDIV1_OD1EN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WKEN register
\*----------------------------------------------------------------*/

/******************************************************************************\
*
* _PLL_WKEN	 - Wakeup (powerdown) Control Register
*
* Fields:
*	(RW)   _PLL_WKEN_WKEN0
*	(RW)   _PLL_WKEN_WKEN1
*	(RW)   _PLL_WKEN_WKEN2
*	(RW)   _PLL_WKEN_WKEN3
*   (RW)   _PLL_WKEN_WKEN4
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _PLL_WKEN_WKEN0:
\*----------------------------------------------------------------*/

#define _PLL_WKEN_WKEN0_SHIFT		(000000u)
#define _PLL_WKEN_WKEN0_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_WKEN_WKEN0_SHIFT)
#define _PLL_WKEN_WKEN0_MASK		(_PLL_WKEN_WKEN0_MK(0x0001u))
#define _PLL_WKEN_WKEN0_CLR		(~(_PLL_WKEN_WKEN0_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_WKEN_WKEN1:
\*----------------------------------------------------------------*/

#define _PLL_WKEN_WKEN1_SHIFT		(0x0001u)
#define _PLL_WKEN_WKEN1_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_WKEN_WKEN1_SHIFT)
#define _PLL_WKEN_WKEN1_MASK		(_PLL_WKEN_WKEN1_MK(0x0001u))
#define _PLL_WKEN_WKEN1_CLR		(~(_PLL_WKEN_WKEN1_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_WKEN_WKEN2:
\*----------------------------------------------------------------*/

#define _PLL_WKEN_WKEN2_SHIFT		(0x0002u)
#define _PLL_WKEN_WKEN2_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_WKEN_WKEN2_SHIFT)
#define _PLL_WKEN_WKEN2_MASK		(_PLL_WKEN_WKEN2_MK(0x0001u))
#define _PLL_WKEN_WKEN2_CLR		(~(_PLL_WKEN_WKEN2_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_WKEN_WKEN3:
\*----------------------------------------------------------------*/

#define _PLL_WKEN_WKEN3_SHIFT		(0x0003u)
#define _PLL_WKEN_WKEN3_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_WKEN_WKEN3_SHIFT)
#define _PLL_WKEN_WKEN3_MASK		(_PLL_WKEN_WKEN3_MK(0x0001u))
#define _PLL_WKEN_WKEN3_CLR		(~(_PLL_WKEN_WKEN3_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _PLL_WKEN_WKEN4:
\*----------------------------------------------------------------*/

#define _PLL_WKEN_WKEN4_SHIFT		(0x0004u)
#define _PLL_WKEN_WKEN4_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_WKEN_WKEN4_SHIFT)
#define _PLL_WKEN_WKEN4_MASK		(_PLL_WKEN_WKEN4_MK(0x0001u))
#define _PLL_WKEN_WKEN4_CLR		(~(_PLL_WKEN_WKEN4_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PLLDIV0 register
\*----------------------------------------------------------------*/

/******************************************************************************\
*
* _PLL_PLLDIV0	 - Clock 0 Divide Down Register
*
* Fields:
*	(RW)   _PLL_PLLDIV0_PLLDIV0
*	(RW)   _PLL_PLLDIV0_D0EN
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLDIV0_PLLDIV0:
\*----------------------------------------------------------------*/

#define _PLL_PLLDIV0_PLLDIV0_SHIFT		(000000u)
#define _PLL_PLLDIV0_PLLDIV0_MK(n)		(((Uint16)(n) & 0x001fu) << _PLL_PLLDIV0_PLLDIV0_SHIFT)
#define _PLL_PLLDIV0_PLLDIV0_MASK		(_PLL_PLLDIV0_PLLDIV0_MK(0x001fu))
#define _PLL_PLLDIV0_PLLDIV0_CLR		(~(_PLL_PLLDIV0_PLLDIV0_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLDIV0_D0EN:
\*----------------------------------------------------------------*/

#define _PLL_PLLDIV0_D0EN_SHIFT		(0x000fu)
#define _PLL_PLLDIV0_D0EN_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_PLLDIV0_D0EN_SHIFT)
#define _PLL_PLLDIV0_D0EN_MASK		(_PLL_PLLDIV0_D0EN_MK(0x0001u))
#define _PLL_PLLDIV0_D0EN_CLR		      (~(_PLL_PLLDIV0_D0EN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PLLM register
\*----------------------------------------------------------------*/

/******************************************************************************\
*
* _PLL_PLLM	 - Clock 0 Multiplier Register
*
* Fields:
*	(RW)   _PLL_PLLM_PLLM
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLM_PLLM:
\*----------------------------------------------------------------*/

#define _PLL_PLLM_PLLM_SHIFT		(000000u)
#define _PLL_PLLM_PLLM_MK(n)		(((Uint16)(n) & 0x001fu) << _PLL_PLLM_PLLM_SHIFT)
#define _PLL_PLLM_PLLM_MASK		(_PLL_PLLM_PLLM_MK(0x001fu))
#define _PLL_PLLM_PLLM_CLR		(~(_PLL_PLLM_PLLM_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PLLDIV1 register
\*----------------------------------------------------------------*/

/******************************************************************************\
*
* _PLL_PLLDIV1	 - Sysclk 1 Divide Down Register
*
* Fields:
*	(RW)   _PLL_PLLDIV1_PLLDIV1
*	(RW)   _PLL_PLLDIV1_D1EN
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLDIV1_PLLDIV1:
\*----------------------------------------------------------------*/

#define _PLL_PLLDIV1_PLLDIV1_SHIFT		(000000u)
#define _PLL_PLLDIV1_PLLDIV1_MK(n)		(((Uint16)(n) & 0x001fu) << _PLL_PLLDIV1_PLLDIV1_SHIFT)
#define _PLL_PLLDIV1_PLLDIV1_MASK		(_PLL_PLLDIV1_PLLDIV1_MK(0x001fu))
#define _PLL_PLLDIV1_PLLDIV1_CLR		(~(_PLL_PLLDIV1_PLLDIV1_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLDIV1_D1EN:
\*----------------------------------------------------------------*/

#define _PLL_PLLDIV1_D1EN_SHIFT		(0x000fu)
#define _PLL_PLLDIV1_D1EN_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_PLLDIV1_D1EN_SHIFT)
#define _PLL_PLLDIV1_D1EN_MASK		(_PLL_PLLDIV1_D1EN_MK(0x0001u))
#define _PLL_PLLDIV1_D1EN_CLR		(~(_PLL_PLLDIV1_D1EN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PLLCSR register
\*----------------------------------------------------------------*/

/******************************************************************************\
*
* _PLL_PLLCSR	 - PLL Control Register
*
* Fields:
*	(RW)   _PLL_PLLCSR_PLLEN
*	(RW)   _PLL_PLLCSR_PLLPWRDN
*	(RW)   _PLL_PLLCSR_OSCPWRDN
*	(RW)   _PLL_PLLCSR_PLLRST
*	(R)   _PLL_PLLCSR_LOCK
*	(R)   _PLL_PLLCSR_STABLE
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLCSR_PLLEN:
\*----------------------------------------------------------------*/

#define _PLL_PLLCSR_PLLEN_SHIFT		(000000u)
#define _PLL_PLLCSR_PLLEN_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_PLLCSR_PLLEN_SHIFT)
#define _PLL_PLLCSR_PLLEN_MASK		(_PLL_PLLCSR_PLLEN_MK(0x0001u))
#define _PLL_PLLCSR_PLLEN_CLR		(~(_PLL_PLLCSR_PLLEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLCSR_PLLPWRDN:
\*----------------------------------------------------------------*/

#define _PLL_PLLCSR_PLLPWRDN_SHIFT		(0x0001u)
#define _PLL_PLLCSR_PLLPWRDN_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_PLLCSR_PLLPWRDN_SHIFT)
#define _PLL_PLLCSR_PLLPWRDN_MASK		(_PLL_PLLCSR_PLLPWRDN_MK(0x0001u))
#define _PLL_PLLCSR_PLLPWRDN_CLR		(~(_PLL_PLLCSR_PLLPWRDN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLCSR_OSCPWRDN:
\*----------------------------------------------------------------*/

#define _PLL_PLLCSR_OSCPWRDN_SHIFT		(0x0002u)
#define _PLL_PLLCSR_OSCPWRDN_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_PLLCSR_OSCPWRDN_SHIFT)
#define _PLL_PLLCSR_OSCPWRDN_MASK		(_PLL_PLLCSR_OSCPWRDN_MK(0x0001u))
#define _PLL_PLLCSR_OSCPWRDN_CLR		(~(_PLL_PLLCSR_OSCPWRDN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLCSR_PLLRST:
\*----------------------------------------------------------------*/

#define _PLL_PLLCSR_PLLRST_SHIFT		(0x0003u)
#define _PLL_PLLCSR_PLLRST_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_PLLCSR_PLLRST_SHIFT)
#define _PLL_PLLCSR_PLLRST_MASK		(_PLL_PLLCSR_PLLRST_MK(0x0001u))
#define _PLL_PLLCSR_PLLRST_CLR		(~(_PLL_PLLCSR_PLLRST_MASK))



/*----------------------------------------------------------------*\
*   (R)  _PLL_PLLCSR_LOCK:
\*----------------------------------------------------------------*/

#define _PLL_PLLCSR_LOCK_SHIFT		(0x0005u)
#define _PLL_PLLCSR_LOCK_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_PLLCSR_LOCK_SHIFT)
#define _PLL_PLLCSR_LOCK_MASK		(_PLL_PLLCSR_LOCK_MK(0x0001u))
#define _PLL_PLLCSR_LOCK_CLR		(~(_PLL_PLLCSR_LOCK_MASK))



/*----------------------------------------------------------------*\
*   (R)  _PLL_PLLCSR_STABLE:
\*----------------------------------------------------------------*/

#define _PLL_PLLCSR_STABLE_SHIFT		(0x0006u)
#define _PLL_PLLCSR_STABLE_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_PLLCSR_STABLE_SHIFT)
#define _PLL_PLLCSR_STABLE_MASK		(_PLL_PLLCSR_STABLE_MK(0x0001u))
#define _PLL_PLLCSR_STABLE_CLR		(~(_PLL_PLLCSR_STABLE_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PLLDIV2 register
\*----------------------------------------------------------------*/

/******************************************************************************\
*
* _PLL_PLLDIV2	 - Sysclk2 Divide Down Register
*
* Fields:
*	(RW)   _PLL_PLLDIV2_PLLDIV2
*	(RW)   _PLL_PLLDIV2_D2EN
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLDIV2_PLLDIV2:
\*----------------------------------------------------------------*/

#define _PLL_PLLDIV2_PLLDIV2_SHIFT		(000000u)
#define _PLL_PLLDIV2_PLLDIV2_MK(n)		(((Uint16)(n) & 0x001fu) << _PLL_PLLDIV2_PLLDIV2_SHIFT)
#define _PLL_PLLDIV2_PLLDIV2_MASK		(_PLL_PLLDIV2_PLLDIV2_MK(0x001fu))
#define _PLL_PLLDIV2_PLLDIV2_CLR		(~(_PLL_PLLDIV2_PLLDIV2_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLDIV2_D2EN:
\*----------------------------------------------------------------*/

#define _PLL_PLLDIV2_D2EN_SHIFT		(0x000fu)
#define _PLL_PLLDIV2_D2EN_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_PLLDIV2_D2EN_SHIFT)
#define _PLL_PLLDIV2_D2EN_MASK		(_PLL_PLLDIV2_D2EN_MK(0x0001u))
#define _PLL_PLLDIV2_D2EN_CLR		(~(_PLL_PLLDIV2_D2EN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the PLLDIV3 register
\*----------------------------------------------------------------*/

/******************************************************************************\
*
* _PLL_PLLDIV3	 - Sysclk3 Divide Down Register
*
* Fields:
*	(RW)   _PLL_PLLDIV3_PLLDIV3
*	(RW)   _PLL_PLLDIV3_D3EN
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLDIV3_PLLDIV3:
\*----------------------------------------------------------------*/

#define _PLL_PLLDIV3_PLLDIV3_SHIFT		(000000u)
#define _PLL_PLLDIV3_PLLDIV3_MK(n)		(((Uint16)(n) & 0x001fu) << _PLL_PLLDIV3_PLLDIV3_SHIFT)
#define _PLL_PLLDIV3_PLLDIV3_MASK		(_PLL_PLLDIV3_PLLDIV3_MK(0x001fu))
#define _PLL_PLLDIV3_PLLDIV3_CLR		(~(_PLL_PLLDIV3_PLLDIV3_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_PLLDIV3_D3EN:
\*----------------------------------------------------------------*/

#define _PLL_PLLDIV3_D3EN_SHIFT		(0x000fu)
#define _PLL_PLLDIV3_D3EN_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_PLLDIV3_D3EN_SHIFT)
#define _PLL_PLLDIV3_D3EN_MASK		(_PLL_PLLDIV3_D3EN_MK(0x0001u))
#define _PLL_PLLDIV3_D3EN_CLR		(~(_PLL_PLLDIV3_D3EN_MASK))


#elif (!(_PLL_MOD))
	#error PLL Hal Module Not Supported on Specified Target
#endif  /* _PLLB_SUPPORT  */

#endif  /* _CSL_PLLBHAL_H  */

/******************************************************************************\
*
*      End of csl_pllBhal.h
*
\******************************************************************************/

csl_plldat.h/   1051539334  0     0     0       1261      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... csl_plldata.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... SL - Service Layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  03/30/2000
*   MODIFIED: 04/16/2001 updated FILENAME and other header comments
*   MODIFIED: 06/28/2001 updated for new CSL initialization model
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the PLL module)
*       Reserved Area for PLL Data 
*
*
\******************************************************************************/
#ifndef _PLL_DATA_H_
#define _PLL_DATA_H_

 #include <csl_std.h>

 #define CSL_PLLDATAINIT\
 { 0x0000u  }

 typedef struct {
   Uint16 PllReserved;
 } CSL_PllDataObj;

extern CSL_PllDataObj CSL_PllData;

#define CSL_PLL_DATA  CSL_Plldata

#endif

csl_pllhal.h/   1049976918  0     0     0       10659     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... pllhal.h
* DATE CREATED.. Mon 06/05/2000
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. stdinc.h, chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   06/05/2000 (AP) created
*   07/05/2001 (IM) Modified to include support for both DPLL and APLL
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the PLL module)
*
* Registers Covered:
*   (RW) _PLL_CLKMD
\******************************************************************************/

#ifndef _PLLHAL_H_
#define _PLLHAL_H_

#include <csl_chiphal.h>

#if (_PLL_SUPPORT)

/******************************************************************************\
\******************************************************************************/
/*============================================================================*\
* (RW) _PLL_CLKMD
\*============================================================================*/
#define _PLL_CLKMD_ADDR					(0x1C00u)
#define _PLL_CLKMD                       		PREG16(_PLL_CLKMD_ADDR)
#define _CLKMD                              	_PLL_CLKMD

/*===========================================================================*\
* Generic PLL register/field get/set macros
\*===========================================================================*/

#define PLL_ADDR(Reg)                     _PLL_##Reg##_ADDR
#define PLL_RGET(Reg)                     _PREG_GET(PLL_ADDR(##Reg))
#define PLL_RSET(Reg,Val)                 _PREG_SET(PLL_ADDR(##Reg),Val)
#define PLL_RAOI(Reg,AND,OR,INV)          _PREG_AOI(PLL_ADDR(##Reg),AND,OR,INV)
#define PLL_FGET(Reg,Field)               _PFIELD_GET(PLL_ADDR(##Reg),_PLL_##Reg##_##Field)
#define PLL_FSET(Reg,Field,Val)\
  _PFIELD_SET(PLL_ADDR(##Reg),_PLL_##Reg##_##Field,Val)

#define PLL_FSETS(Reg,Field,Sym)\
  PLL_FSET(##Reg,##Field,PLL_##Reg##_##Field##_##Sym)

#define PLL_FAOI(Reg,Field,AND,OR,INV)\
  _PFIELD_AOI(PLL_ADDR(##Reg),_PLL_##Reg##_##Feld,AND,OR,INV)

#define PLL_FMK(Reg,Field,Val)            _PLL_##Reg##_##Field##_MK(Val)
#define PLL_FMKS(Reg,Field,Sym)           PLL_FMK(##Reg,##Field,PLL_##Reg##_##Field##_##Sym)


#if (!(_PLL_ANALOG_SUPPORT))	//Digital PLL

/*===========================================================================*\
* _PLL_CLKMD
*
* Fields:
*  (RW) _PLL_CLKMD_IAI
*  (RW) _PLL_CLKMD_IOB
*  (RW) _PLL_CLKMD_TEST
*  (RW) _PLL_CLKMD_PLLMULT
*  (RW) _PLL_CLKMD_PLLDIV
*  (RW) _PLL_CLKMD_PLLENABLE
*  (RW) _PLL_CLKMD_BYPASSDIV
*   (R) _PLL_CLKMD_BREAKLN
*   (R) _PLL_CLKMD_LOCK
\*==========================================================================*/

/*==========================================================================*\
* (RW) _PLL_CLKMD_IAI	- Initialize After Idle
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_IAI_SHIFT			(0x000Eu)
#define _PLL_CLKMD_IAI_MK(n)			(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_IAI_SHIFT)
#define _PLL_CLKMD_IAI_MASK       		(_PLL_CLKMD_IAI_MK(0x0001u))
#define _PLL_CLKMD_IAI_CLR        		(~(_PLL_CLKMD_IAI_MK(0x0001u)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_IOB	- Initialize on Break
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_IOB_SHIFT			(0x000Du)
#define _PLL_CLKMD_IOB_MK(n)			(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_IOB_SHIFT)
#define _PLL_CLKMD_IOB_MASK       		(_PLL_CLKMD_IOB_MK(0x0001u))
#define _PLL_CLKMD_IOB_CLR        		(~(_PLL_CLKMD_IOB_MK(0x0001u)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_TEST	- Test
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_TEST_SHIFT			(0x000Cu)
#define _PLL_CLKMD_TEST_MK(n)			(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_TEST_SHIFT)
#define _PLL_CLKMD_TEST_MASK       		(_PLL_CLKMD_TEST_MK(0x0001u))
#define _PLL_CLKMD_TEST_CLR        		(~(_PLL_CLKMD_TEST_MK(0x0001u)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_PLLMULT	- PLL Multiply Value
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_PLLMULT_SHIFT		(0x0007u)
#define _PLL_CLKMD_PLLMULT_MK(n)		(((Uint16)(n) & 0x001Fu) << _PLL_CLKMD_PLLMULT_SHIFT)
#define _PLL_CLKMD_PLLMULT_MASK       	(_PLL_CLKMD_PLLMULT_MK(0x001Fu))
#define _PLL_CLKMD_PLLMULT_CLR        	(~(_PLL_CLKMD_PLLMULT_MK(0x001Fu)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_PLLDIV	- PLL Divide Value
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_PLLDIV_SHIFT		(0x0005u)
#define _PLL_CLKMD_PLLDIV_MK(n)		(((Uint16)(n) & 0x0003u) << _PLL_CLKMD_PLLDIV_SHIFT)
#define _PLL_CLKMD_PLLDIV_MASK       	(_PLL_CLKMD_PLLDIV_MK(0x0003u))
#define _PLL_CLKMD_PLLDIV_CLR        	(~(_PLL_CLKMD_PLLDIV_MK(0x0003u)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_PLLENABLE	- PLL Enable Bit
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_PLLENABLE_SHIFT		(0x0004u)
#define _PLL_CLKMD_PLLENABLE_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_PLLENABLE_SHIFT)
#define _PLL_CLKMD_PLLENABLE_MASK       	(_PLL_CLKMD_PLLENABLE_MK(0x0001u))
#define _PLL_CLKMD_PLLENABLE_CLR        	(~(_PLL_CLKMD_PLLENABLE_MK(0x0001u)))

/*==========================================================================*\
* (RW) _PLL_CLKMD_BYPASSDIV	- Determines CLKOUT Frequency
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_BYPASSDIV_SHIFT		(0x0002u)
#define _PLL_CLKMD_BYPASSDIV_MK(n)		(((Uint16)(n) & 0x0003u) << _PLL_CLKMD_BYPASSDIV_SHIFT)
#define _PLL_CLKMD_BYPASSDIV_MASK       	(_PLL_CLKMD_BYPASSDIV_MK(0x0003u))
#define _PLL_CLKMD_BYPASSDIV_CLR        	(~(_PLL_CLKMD_BYPASSDIV_MK(0x0003u)))

/*==========================================================================*\
* (R) _PLL_CLKMD_BREAKLN	- Broken Lock Bit
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_BREAKLN_SHIFT		(0x0001u)
#define _PLL_CLKMD_BREAKLN_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_BREAKLN_SHIFT)
#define _PLL_CLKMD_BREAKLN_MASK       	(_PLL_CLKMD_BREAKLN_MK(0x0001u))

/*==========================================================================*\
* (R) _PLL_CLKMD_LOCK	- Lock Mode Bit
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_LOCK_SHIFT			(0x0000u)
#define _PLL_CLKMD_LOCK_MK(n)			(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_LOCK_SHIFT)
#define _PLL_CLKMD_LOCK_MASK       		(_PLL_CLKMD_LOCK_MK(0x0001u))

/*==========================================================================*\
* _PLL_CLKMD 	- Config
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_CFG(iai,iob,test,pllmult,plldiv,pllenable,bypassdiv)  \
	_PREG_SET(_PLL_CLKMD_ADDR,							\
    		(Uint16) (	_PLL_CLKMD_IAI_MK(iai) 				|	\
				_PLL_CLKMD_IOB_MK(iob) 				|	\
				_PLL_CLKMD_TEST_MK(test) 			|	\
				_PLL_CLKMD_PLLMULT_MK(pllmult) 		|	\
				_PLL_CLKMD_PLLDIV_MK(plldiv) 			|	\
				_PLL_CLKMD_PLLENABLE_MK(pllenable) 		|	\
				_PLL_CLKMD_BYPASSDIV_MK(bypassdiv) 			\
	             ))

#else			// Analog PLL

/******************************************************************************\
* 
* _PLL_CLKMD	 - Note: Add description here
*
* Fields:
*	(RW)   _PLL_CLKMD_PLLENABLE	
*	(RW)   _PLL_CLKMD_PLLDIV	
*	(RW)   _PLL_CLKMD_PLLMULT	
*	(RW)   _PLL_CLKMD_VCOONOFF	
*
\******************************************************************************/


/*----------------------------------------------------------------*\
*   (RW)  _PLL_CLKMD_PLLENABLE:	
\*----------------------------------------------------------------*/

#define _PLL_CLKMD_PLLENABLE_SHIFT		(0x0004u)
#define _PLL_CLKMD_PLLENABLE_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_PLLENABLE_SHIFT)
#define _PLL_CLKMD_PLLENABLE_MASK		(_PLL_CLKMD_PLLENABLE_MK(0x0001u))
#define _PLL_CLKMD_PLLENABLE_CLR		(~(_PLL_CLKMD_PLLENABLE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_CLKMD_PLLDIV:	
\*----------------------------------------------------------------*/

#define _PLL_CLKMD_PLLDIV_SHIFT		(0x0005u)
#define _PLL_CLKMD_PLLDIV_MK(n)		(((Uint16)(n) & 0x0003u) << _PLL_CLKMD_PLLDIV_SHIFT)
#define _PLL_CLKMD_PLLDIV_MASK		(_PLL_CLKMD_PLLDIV_MK(0x0003u))
#define _PLL_CLKMD_PLLDIV_CLR		(~(_PLL_CLKMD_PLLDIV_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_CLKMD_PLLMULT:	
\*----------------------------------------------------------------*/

#define _PLL_CLKMD_PLLMULT_SHIFT		(0x0007u)
#define _PLL_CLKMD_PLLMULT_MK(n)		(((Uint16)(n) & 0x000fu) << _PLL_CLKMD_PLLMULT_SHIFT)
#define _PLL_CLKMD_PLLMULT_MASK		(_PLL_CLKMD_PLLMULT_MK(0x000fu))
#define _PLL_CLKMD_PLLMULT_CLR		(~(_PLL_CLKMD_PLLMULT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _PLL_CLKMD_VCOONOFF:	
\*----------------------------------------------------------------*/

#define _PLL_CLKMD_VCOONOFF_SHIFT		(0x000bu)
#define _PLL_CLKMD_VCOONOFF_MK(n)		(((Uint16)(n) & 0x0001u) << _PLL_CLKMD_VCOONOFF_SHIFT)
#define _PLL_CLKMD_VCOONOFF_MASK		(_PLL_CLKMD_VCOONOFF_MK(0x0001u))
#define _PLL_CLKMD_VCOONOFF_CLR		(~(_PLL_CLKMD_VCOONOFF_MASK))

/*==========================================================================*\
* _PLL_CLKMD 	- Config
\*--------------------------------------------------------------------------*/
#define _PLL_CLKMD_CFG(vcoonoff,pllmult,plldiv,pllenable)  \
	_PREG_SET(_PLL_CLKMD_ADDR,							\
    		(Uint16) (	_PLL_CLKMD_VCOONOFF_MK(vcoonoff) 			|	\
				_PLL_CLKMD_PLLMULT_MK(pllmult) 		|	\
				_PLL_CLKMD_PLLDIV_MK(plldiv) 			|	\
				_PLL_CLKMD_PLLENABLE_MK(pllenable) 			\
	             ))

#endif

#else
   #ifndef _PLL_MOD_
     #error CLKMD Hal Module Not Supported on Specified Target
   #endif
#endif
#endif    


csl_pwr.h/      1065792244  0     0     0       8154      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PWR
* FILENAME...... csl_pwr.h
* DATE CREATED.. Thu 11/11/1999
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       11/11/1999 Created
*   MODIFIED:      12/01/1999 Modified for TMS320C54xx
*                  04/16/2001 updated FILENAME and other header comments
*   			   08/21/2003 Added #if (CHIP_5502)
*	LAST MODIFIED: 09/23/2003 PWR_powerDown function name typo error fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the PWR module)
*
*
*
\******************************************************************************/
#ifndef _PWR_H_
#define _PWR_H_

#include <_csl.h>
#include <csl_pwrhal.h>

#if (_PWR_SUPPORT)
/****************************************\
* PWR scope and inline control macros
\****************************************/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _PWR_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/****************************************\
* PWR global macro declarations
\****************************************/
#define PWR_ERR_MAJOR         (ERR_BASE_PWR)
#define PWR_ERR_INVALID_MODE   (0x00000000)


#ifdef _MCRTE_DEBUG
  #define PWR_ASSERT_MODE(mode)\
   if((mode <1) || (mode >3)) {\
     ERR_submit(PWR_ERR_MAJOR, PWR_ERR_INVALID_MODE);\
     mode;\
   }
#else
  #define PWR_ASSERT_MODE(mode)
#endif
/*******************************************\
* PWR global macro definition : ROMABILITY
\*******************************************/
/* Reserved ROM Area for PWR Data */

#if (CHIP_5502)

#else
/*===========================================================================*\
* PWR ICR    - Idle Configuration Register Macros
*
* Fields:
*  (RW) EMIFI
*  (RW) CLKGENI
*  (RW) PERI
*  (RW) CACHEI
*  (RW) DMAI
*  (RW) CPUI
*
\*==========================================================================*/

#define PWR_ICR_EMIFI_EMIF_ACTIVE               (0u)
#define PWR_ICR_EMIFI_EMIF_DISABLED             (1u)
#define PWR_ICR_EMIFI_DEFAULT                   PWR_ICR_EMIFI_EMIF_ACTIVE

#define PWR_ICR_CLKGENI_CLKGEN_RUNNING          (0u)
#define PWR_ICR_CLKGENI_CLKGEN_OFF              (1u)
#define PWR_ICR_CLKGENI_DEFAULT                 PWR_ICR_CLKGENI_CLKGEN_RUNNING

#define PWR_ICR_PERI_ALL_ACTIVE                 (0u)
#define PWR_ICR_PERI_IDLE_ENABLE_BIT            (1u)
#define PWR_ICR_PERI_DEFAULT                    PWR_ICR_PERI_ALL_ACTIVE

#define PWR_ICR_CACHEI_CACHE_ACTIVE             (0u)
#define PWR_ICR_CACHEI_CACHE_DISABLED           (1u)
#define PWR_ICR_CACHEI_DEFAULT                  PWR_ICR_CACHEI_CACHE_ACTIVE

#define PWR_ICR_DMAI_DMA_ACTIVE                 (0u)
#define PWR_ICR_DMAI_DMA_DISABLED               (1u)
#define PWR_ICR_DMAI_DEFAULT                    PWR_ICR_DMAI_DMA_ACTIVE

#define PWR_ICR_CPUI_CPU_ACTIVE                 (0u)
#define PWR_ICR_CPUI_CPU_DISABLED               (1u)
#define PWR_ICR_CPUI_DEFAULT                    PWR_ICR_CPUI_CPU_ACTIVE


/*---------------------------------------*\
* PWR_ICR_MK Macro
\*---------------------------------------*/

#define PWR_ICR_RMK(emifi, clkgeni, peri, cachei, dmai,cpui)\
  (Uint16) ( PWR_FMK(ICR,EMIFI,emifi)|\
             PWR_FMK(ICR,CLKGENI,clkgeni)|\
             PWR_FMK(ICR,PERI,peri)|\
             PWR_FMK(ICR,CACHEI,cachei)|\
             PWR_FMK(ICR,DMAI,dmai)|\
             PWR_FMK(ICR,CPUI,cpui)\
             )

#define PWR_ICR_RMKS(emifi_s, clkgeni_s, peri_s, cachei_s, dmai_s, cpui_s)\
  (Uint16) ( PWR_FMKS(ICR,EMIFI,emifi_s)|\
             PWR_FMKS(ICR,CLKGENI,clkgeni_s)|\
             PWR_FMKS(ICR,PERI,peri_s)|\
             PWR_FMKS(ICR,CACHEI,cachei_s)|\
             PWR_FMKS(ICR,DMAI,dmai_s)|\
             PWR_FMKS(ICR,CPUI,cpui_s)\
             )



/*===========================================================================*\
*  PWR ISTR    - Idle Status Register
*
* Fields:
*  (R) EMIFIS
*  (R) CLKGENIS
*  (R) PERIS
*  (R) CACHEIS
*  (R) DMAIS
*  (R) CPUIS
*
\*==========================================================================*/

#define PWR_ISTR_EMIFIS_EMIF_ACTIVE               (0u)
#define PWR_ISTR_EMIFIS_EMIF_DISABLED             (1u)
#define PWR_ISTR_EMIFIS_DEFAULT                   PWR_ISTR_EMIFIS_EMIF_ACTIVE

#define PWR_ISTR_CLKGENIS_CLKGEN_RUNNING          (0u)
#define PWR_ISTR_CLKGENIS_CLKGEN_OFF              (1u)
#define PWR_ISTR_CLKGENIS_DEFAULT                 PWR_ISTR_CLKGENIS_CLKGEN_RUNNING

#define PWR_ISTR_PERIS_ALL_ACTIVE                 (0u)
#define PWR_ISTR_PERIS_IDLE_ENABLE_BIT            (1u)
#define PWR_ISTR_PERIS_DEFAULT                    PWR_ISTR_PERIS_ALL_ACTIVE

#define PWR_ISTR_CACHEIS_CACHE_ACTIVE             (0u)
#define PWR_ISTR_CACHEIS_CACHE_DISABLED           (1u)
#define PWR_ISTR_CACHEIS_DEFAULT                  PWR_ISTR_CACHEIS_CACHE_ACTIVE

#define PWR_ISTR_DMAIS_DMA_ACTIVE                 (0u)
#define PWR_ISTR_DMAIS_DMA_DISABLED               (1u)
#define PWR_ISTR_DMAIS_DEFAULT                    PWR_ISTR_DMAIS_DMA_ACTIVE

#define PWR_ISTR_CPUIS_CPU_ACTIVE                 (0u)
#define PWR_ISTR_CPUIS_CPU_DISABLED               (1u)
#define PWR_ISTR_CPUIS_DEFAULT                    PWR_ISTR_CPUIS_CPU_ACTIVE

/*---------------------------------------*\
* PWR_ISTR_MK Macro
\*---------------------------------------*/

#define PWR_ISTR_RMK(emifis, clkgenis, peris, cacheis, dmais,cpuis)\
(Uint16) ( PWR_FMK(ISTR,EMIFIS,emifis)|\
           PWR_FMK(ISTR,CLKGENIS,clkgenis)|\
           PWR_FMK(ISTR,PERIS,peris)|\
           PWR_FMK(ISTR,CACHEIS,cacheis)|\
           PWR_FMK(ISTR,DMAIS,dmais)|\
           PWR_FMK(ISTR,CPUIS,cpuis)\
)

#define PWR_ISTR_RMKS(emifis_s, clkgenis_s, peris_s, cacheis_s, dmais_s, cpuis_s)\
(Uint16) ( PWR_FMKS(ISTR,EMIFIS,emifis_s)|\
           PWR_FMKS(ISTR,CLKGENIS,clkgenis_s)|\
           PWR_FMKS(ISTR,PERIS,peris_s)|\
           PWR_FMKS(ISTR,CACHEIS,cacheis_s)|\
           PWR_FMKS(ISTR,DMAIS,dmais_s)|\
           PWR_FMKS(ISTR,CPUIS,cpuis_s)\
)



#define PWR_WAKEUP_MI                (1u)
#define PWR_WAKEUP_NMI               (0u)

/****************************************\
* PWR global typedef declarations
\****************************************/

/****************************************\
* PWR global variable declarations
\****************************************/

/****************************************\
* PWR global function declarations
\****************************************/

/****************************************\
* PWR inline function declarations
\****************************************/
IDECL void PWR_powerDown(Uint16 wakeUpMode);

/****************************************\
* PWR inline function definitions
\****************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void PWR_powerDown(Uint16 wakeUpMode){
  if (wakeUpMode) {
    IRQ_globalEnable();
  }
  else {
    IRQ_globalDisable();
  }

  asm("\t IDLE   ;=====>NOTE: Automatic Cdoe Generated by CSL");
}

#endif /* USEDEFS */

#endif /* !CHIP_5502 */

#endif /* PWR_SUPPORT */
#endif /* _PWR_H_ */
/******************************************************************************\
* End of pwr.h
\******************************************************************************/

csl_pwrdat.h/   1051539332  0     0     0       1349      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PWR
* FILENAME...... csl_pwrdata.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  03/30/2000
*   MODIFIED: 04/16/2001  updated FILENAME and other header comments
*   MODIFIED: 06/28/2001  updated for new CSL initialization model
*   MODIFIED: 10 Apr 2003 added reference for CSL_PwrData for .csldata size fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the PWR module)
*       Reserved ROM Area for PWR Data 
*
*
\******************************************************************************/
#ifndef _PWR_DATA_H_
#define _PWR_DATA_H_ 

  #include <csl_std.h>

  #define CSL_PWRDATAINIT\
  { 0x0000u } 

  typedef struct {
    Uint16 PwrReserved;
  } CSL_PwrDataObj;

extern CSL_PwrDataObj CSL_PwrData;

#define CSL_PWR_DATA  CSL_PwrData;

#endif

csl_pwrhal.h/   1065792252  0     0     0       47082     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... PWR
* FILENAME...... csl_pwrhal.h
* DATE CREATED.. Thu 11/11/1999
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL HAL
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       11/11/1999 Created
*   MODIFIED:      11/29/1999 modified for TMS320C54xx
*                  07/18/2000 modified for TMS320C55xx
*                  04/16/2001 updated header comments
*   			   08/21/2003 -Corrected SHIFT macros for ICR,ISTR
*                             -Corrected HPREG* and HPFIELD* macros to _PREG*
*                              and _PFILED*
*                             -Corrected 5502 field names as per data manual
*	LAST MODIFIED: 09/23/2003 -Renamed MISTR->MISR
*							  -Corrected PISTR register field names as per data
*							   manual
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the PWR module)
*
* Registers Covered:
*   (RW) _PWR_ICR  -  Idle configuration register
*
\******************************************************************************/
#ifndef _PWRHAL_H_
#define _PWRHAL_H_

#include <csl_chiphal.h>

#if (_PWR_SUPPORT)

/****************************************\
* _PWR scope and inline control macros
\****************************************/
#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#define IDECL static inline
#define USEDEFS
#define IDEF  static inline


 #define _PWR_IDLE_PERIPHERALS_ACTIVE	(0x0001u)
 #define _PWR_IDLE_PERIPHERALS_INACTIVE   (0x0002u)
 #define _PWR_IDLE_PLL_DISABLED           (0x0003u)


/*============================================================================*\
* _PWR_ICR:  Idle Configuration Register
\*============================================================================*/
#define _PWR_ICR_ADDR			       (0x0001u)
#define _PWR_ICR                           PREG16(_PWR_ICR_ADDR)
#define _ICR                               _PWR_ICR

#define _PWR_ISTR_ADDR			      (0x0002u)
#define _PWR_ISTR	                         PREG16(_PWR_ISTR_ADDR)
#define _ISTR                              _PWR_ISTR

#if (CHIP_5502)

  #define _PWR_PICR_ADDR                     (0x9400)
  #define _PWR_PICR                          PREG16(_PWR_PICR_ADDR)
  #define _PICR                              _PWR_PICR

  #define _PWR_PISTR_ADDR                     (0x9401)
  #define _PWR_PISTR                          PREG16(_PWR_PISTR_ADDR)
  #define _PISTR                              _PWR_PISTR


  #define _PWR_MICR_ADDR                     (0x9402)
  #define _PWR_MICR                          PREG16(_PWR_MICR_ADDR)
  #define _MICR                              _PWR_MICR

  #define _PWR_MISR_ADDR                     (0x9403)
  #define _PWR_MISR                          PREG16(_PWR_MISR_ADDR)
  #define _MISR                              _PWR_MISR

#endif


/*============================================================================*\
* Generic PWR register/field get/set macros
\*============================================================================*/
#define PWR_ADDR(Reg)              _PWR_##Reg##_ADDR
#define PWR_RGET(Reg)              _PREG_GET(PWR_ADDR(##Reg))
#define PWR_RSET(Reg,Val)          _PREG_SET(PWR_ADDR(##Reg),Val)
#define PWR_RAOI(Reg,AND,OR,INV)   _PREG_AOI(PWR_ADDR(##Reg),AND,OR,INV)
#define PWR_FGET(Reg,Field)        _PFIELD_GET(PWR_ADDR(##Reg),_PWR_##Reg##_##Field)
#define PWR_FSET(Reg,Field,Val)    _PFIELD_SET(PWR_ADDR(##Reg),_PWR_##Reg##_##Field,Val)
#define PWR_FSETS(Reg,Field,Sym)   PWR_FSET(##Reg,##Field,PWR_##Reg##_##Field##_##Sym)
#define PWR_FMK(Reg,Field,Val)     _PWR_##Reg##_##Field##_MK(Val)
#define PWR_FMKS(Reg,Field,Sym)    PWR_FMK(##Reg,##Field,PWR_##Reg##_##Field##_##Sym)

#define PWR_FAOI(Reg,Field,AND,OR,INV)\
  _PFIELD_AOI(PWR_ADDR(##Reg),_PWR_##Reg##_##Field,AND,OR,INV)

/*============================================================================*\
* _PWR_ICR_GET and _PWR_ICR_SET
\*============================================================================*/
#define _PWR_ICR_GET(RegAddr)		      _PREG_GET(RegAddr)
#define _PWR_ICR_SET(RegAddr,Val)		_PREG_SET(RegAddr, Val)

/*============================================================================*\
* _PWR_ISTR_GET
\*============================================================================*/
#define _PWR_ISTR_GET(RegAddr)            _PREG_GET(RegAddr)

#if (CHIP_5502)
/*============================================================================*\
* _PWR_PICR_GET and _PWR_PICR_SET
\*============================================================================*/
#define _PWR_PICR_GET(RegAddr)		      _PREG_GET(RegAddr)
#define _PWR_PICR_SET(RegAddr,Val)		      _PREG_SET(RegAddr, Val)

/*============================================================================*\
* _PWR_PISTR_GET
\*============================================================================*/
#define _PWR_PISTR_GET(RegAddr)            _PREG_GET(RegAddr)

/*============================================================================*\
* _PWR_MICR_GET and _PWR_MICR_SET
\*============================================================================*/
#define _PWR_MICR_GET(RegAddr)		      _PREG_GET(RegAddr)
#define _PWR_MICR_SET(RegAddr,Val)		_PREG_SET(RegAddr, Val)

/*============================================================================*\
* _PWR_ISTR_GET
\*============================================================================*/
#define _PWR_MISR_GET(RegAddr)            _PREG_GET(RegAddr)

#endif

#if (CHIP_5502)

/*===========================================================================*\
* _PWR_ICR    - Idle Configuration Register
*
* Fields:
*  (RW) _PWR_ICR_IPORTI
*  (RW) _PWR_ICR_MPORTI
*  (RW) _PWR_ICR_XPORTI
*  (RW) _PWR_ICR_EMIFI
*  (RW) _PWR_ICR_CLKI
*  (RW) _PWR_ICR_PERI
*  (RW) _PWR_ICR_ICACHEI
*  (RW) _PWR_ICR_MPI
*  (RW) _PWR_ICR_CPUI
*
\*==========================================================================*/

/*==========================================================================*\
* (RW) _PWR_ICR_IPORTI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_IPORTI_SHIFT		  (0x0008)
#define _PWR_ICR_IPORTI_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ICR_IPORTI_SHIFT)
#define _PWR_ICR_IPORTI_MASK            (_PWR_ICR_IPORTI_MK(1))
#define _PWR_ICR_IPORTI_CLR             (~(_PWR_ICR_IPORTI_MK(1)))

#define _PWR_ICR_IPORTI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_IPORTI)

#define _PWR_ICR_IPORTI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_IPORTI,Val)

/*==========================================================================*\
* (RW) _PWR_ICR_MPORTI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_MPORTI_SHIFT		  (0x0007)
#define _PWR_ICR_MPORTI_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ICR_MPORTI_SHIFT)
#define _PWR_ICR_MPORTI_MASK            (_PWR_ICR_MPORTI_MK(1))
#define _PWR_ICR_MPORTI_CLR             (~(_PWR_ICR_MPORTI_MK(1)))

#define _PWR_ICR_MPORTI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_MPORTI)

#define _PWR_ICR_MPORTI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_MPORTI,Val)

/*==========================================================================*\
* (RW) _PWR_ICR_XPORTI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_XPORTI_SHIFT		  (0x0006)
#define _PWR_ICR_XPORTI_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ICR_XPORTI_SHIFT)
#define _PWR_ICR_XPORTI_MASK            (_PWR_ICR_XPORTI_MK(1))
#define _PWR_ICR_XPORTI_CLR             (~(_PWR_ICR_XPORTI_MK(1)))

#define _PWR_ICR_XPORTI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_XPORTI)

#define _PWR_ICR_XPORTI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_XPORTI,Val)

/*==========================================================================*\
* (RW) _PWR_ICR_EMIFI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_EMIFI_SHIFT		  (0x0005)
#define _PWR_ICR_EMIFI_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ICR_EMIFI_SHIFT)
#define _PWR_ICR_EMIFI_MASK            (_PWR_ICR_EMIFI_MK(1))
#define _PWR_ICR_EMIFI_CLR             (~(_PWR_ICR_EMIFI_MK(1)))

#define _PWR_ICR_EMIFI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_EMIFI)

#define _PWR_ICR_EMIFI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_EMIFI,Val)

/*==========================================================================*\
* (RW) _PWR_ICR_CLKI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_CLKI_SHIFT		  (0x0004)
#define _PWR_ICR_CLKI_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ICR_CLKI_SHIFT)
#define _PWR_ICR_CLKI_MASK            (_PWR_ICR_CLKI_MK(1))
#define _PWR_ICR_CLKI_CLR             (~(_PWR_ICR_CLKI_MK(1)))

#define _PWR_ICR_CLKI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_CLKI)

#define _PWR_ICR_CLKI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_CLKI,Val)

/*==========================================================================*\
* (RW) _PWR_ICR_PERI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_PERI_SHIFT		  (0x0003)
#define _PWR_ICR_PERI_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ICR_PERI_SHIFT)
#define _PWR_ICR_PERI_MASK            (_PWR_ICR_PERI_MK(1))
#define _PWR_ICR_PERI_CLR             (~(_PWR_ICR_PERI_MK(1)))

#define _PWR_ICR_PERI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_PERI)

#define _PWR_ICR_PERI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_PERI,Val)

/*==========================================================================*\
* (RW) _PWR_ICR_ICACHEI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_ICACHEI_SHIFT		  (0x0002)
#define _PWR_ICR_ICACHEI_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ICR_ICACHEI_SHIFT)
#define _PWR_ICR_ICACHEI_MASK            (_PWR_ICR_ICACHEI_MK(1))
#define _PWR_ICR_ICACHEI_CLR             (~(_PWR_ICR_ICACHEI_MK(1)))

#define _PWR_ICR_ICACHEI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_ICACHEI)

#define _PWR_ICR_ICACHEI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_ICACHEI,Val)


/*==========================================================================*\
* (RW) _PWR_ICR_MPI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_MPI_SHIFT		  (0x0001)
#define _PWR_ICR_MPI_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ICR_MPI_SHIFT)
#define _PWR_ICR_MPI_MASK            (_PWR_ICR_MPI_MK(1))
#define _PWR_ICR_MPI_CLR             (~(_PWR_ICR_MPI_MK(1)))

#define _PWR_ICR_MPI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_MPI)

#define _PWR_ICR_MPI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_MPI,Val)

/*==========================================================================*\
* (RW) _PWR_ICR_CPUI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_CPUI_SHIFT		  (0x0000)
#define _PWR_ICR_CPUI_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ICR_CPUI_SHIFT)
#define _PWR_ICR_CPUI_MASK            (_PWR_ICR_CPUI_MK(1))
#define _PWR_ICR_CPUI_CLR             (~(_PWR_ICR_CPUI_MK(1)))

#define _PWR_ICR_CPUI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_CPUI)

#define _PWR_ICR_CPUI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_CPUI,Val)


/*===========================================================================*\
* _PWR_ISTR    - Idle Status Register
*
* Fields:
*  (RW) _PWR_ISTR_IPORTIS
*  (RW) _PWR_ISTR_MPORTIS
*  (RW) _PWR_ISTR_XPORTIS
*  (RW) _PWR_ISTR_EMIFIS
*  (RW) _PWR_ISTR_CLKIS
*  (RW) _PWR_ISTR_PERIS
*  (RW) _PWR_ISTR_ICACHEIS
*  (RW) _PWR_ISTR_MPIS
*  (RW) _PWR_ISTR_CPUIS
*
\*==========================================================================*/

/*==========================================================================*\
* (RW) _PWR_ISTR_IPORTIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_IPORTIS_SHIFT		  (0x0008)
#define _PWR_ISTR_IPORTIS_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ISTR_IPORTIS_SHIFT)
#define _PWR_ISTR_IPORTIS_MASK            (_PWR_ISTR_IPORTIS_MK(1))
#define _PWR_ISTR_IPORTIS_CLR             (~(_PWR_ISTR_IPORTIS_MK(1)))

#define _PWR_ISTR_IPORTIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_IPORTIS)

#define _PWR_ISTR_IPORTIS_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ISTR_IPORTIS,Val)

/*==========================================================================*\
* (RW) _PWR_ISTR_MPORTIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_MPORTIS_SHIFT		  (0x0007)
#define _PWR_ISTR_MPORTIS_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ISTR_MPORTIS_SHIFT)
#define _PWR_ISTR_MPORTIS_MASK            (_PWR_ISTR_MPORTIS_MK(1))
#define _PWR_ISTR_MPORTIS_CLR             (~(_PWR_ISTR_MPORTIS_MK(1)))

#define _PWR_ISTR_MPORTIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_MPORTIS)

#define _PWR_ISTR_MPORTIS_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ISTR_MPORTIS,Val)

/*==========================================================================*\
* (RW) _PWR_ISTR_XPORTIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_XPORTIS_SHIFT		  (0x0006)
#define _PWR_ISTR_XPORTIS_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ISTR_XPORTIS_SHIFT)
#define _PWR_ISTR_XPORTIS_MASK            (_PWR_ISTR_XPORTIS_MK(1))
#define _PWR_ISTR_XPORTIS_CLR             (~(_PWR_ISTR_XPORTIS_MK(1)))

#define _PWR_ISTR_XPORTIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_XPORTIS)

#define _PWR_ISTR_XPORTIS_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ISTR_XPORTIS,Val)

/*==========================================================================*\
* (RW) _PWR_ISTR_EMIFIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_EMIFIS_SHIFT		  (0x0005)
#define _PWR_ISTR_EMIFIS_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ISTR_EMIFIS_SHIFT)
#define _PWR_ISTR_EMIFIS_MASK            (_PWR_ISTR_EMIFIS_MK(1))
#define _PWR_ISTR_EMIFIS_CLR             (~(_PWR_ISTR_EMIFIS_MK(1)))

#define _PWR_ISTR_EMIFIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_EMIFIS)

#define _PWR_ISTR_EMIFIS_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ISTR_EMIFIS,Val)

/*==========================================================================*\
* (RW) _PWR_ISTR_CLKIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_CLKIS_SHIFT		  (0x0004)
#define _PWR_ISTR_CLKIS_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ISTR_CLKIS_SHIFT)
#define _PWR_ISTR_CLKIS_MASK            (_PWR_ISTR_CLKIS_MK(1))
#define _PWR_ISTR_CLKIS_CLR             (~(_PWR_ISTR_CLKIS_MK(1)))

#define _PWR_ISTR_CLKIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_CLKIS)

#define _PWR_ISTR_CLKIS_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ISTR_CLKIS,Val)

/*==========================================================================*\
* (RW) _PWR_ISTR_PERIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_PERIS_SHIFT		  (0x0003)
#define _PWR_ISTR_PERIS_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ISTR_PERIS_SHIFT)
#define _PWR_ISTR_PERIS_MASK            (_PWR_ISTR_PERIS_MK(1))
#define _PWR_ISTR_PERIS_CLR             (~(_PWR_ISTR_PERIS_MK(1)))

#define _PWR_ISTR_PERIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_PERIS)

#define _PWR_ISTR_PERIS_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ISTR_PERIS,Val)

/*==========================================================================*\
* (RW) _PWR_ISTR_ICACHEIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_ICACHEIS_SHIFT		  (0x0002)
#define _PWR_ISTR_ICACHEIS_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ISTR_ICACHEIS_SHIFT)
#define _PWR_ISTR_ICACHEIS_MASK            (_PWR_ISTR_ICACHEIS_MK(1))
#define _PWR_ISTR_ICACHEIS_CLR             (~(_PWR_ISTR_ICACHEIS_MK(1)))

#define _PWR_ISTR_ICACHEIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_ICACHEIS)

#define _PWR_ISTR_ICACHEIS_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ISTR_ICACHEIS,Val)


/*==========================================================================*\
* (RW) _PWR_ISTR_MPI
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_MPIS_SHIFT		  (0x0001)
#define _PWR_ISTR_MPIS_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ISTR_MPIS_SHIFT)
#define _PWR_ISTR_MPIS_MASK            (_PWR_ISTR_MPIS_MK(1))
#define _PWR_ISTR_MPIS_CLR             (~(_PWR_ISTR_MPIS_MK(1)))

#define _PWR_ISTR_MPIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_MPIS)

#define _PWR_ISTR_MPIS_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ISTR_MPIS,Val)

/*==========================================================================*\
* (RW) _PWR_ISTR_CPUI
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_CPUIS_SHIFT		  (0x0000)
#define _PWR_ISTR_CPUIS_MK(n)          (((Uint16)(n) & 0x0001u) << _PWR_ISTR_CPUIS_SHIFT)
#define _PWR_ISTR_CPUIS_MASK            (_PWR_ISTR_CPUIS_MK(1))
#define _PWR_ISTR_CPUIS_CLR             (~(_PWR_ISTR_CPUIS_MK(1)))

#define _PWR_ISTR_CPUIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_CPUIS)

#define _PWR_ISTR_CPUIS_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ISTR_CPUIS,Val)


#else
/*===========================================================================*\
* _PWR_ICR    - Idle Configuration Register
*
* Fields:
*  (RW) _PWR_ICR_EMIFI
*  (RW) _PWR_ICR_CLKGENI
*  (RW) _PWR_ICR_PERI
*  (RW) _PWR_ICR_CACHEI
*  (RW) _PWR_ICR_DMAI
*  (RW) _PWR_ICR_CPUI
*
\*==========================================================================*/

/*==========================================================================*\
* (RW) _PWR_ICR_EMIFI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_EMIFI_SHIFT		  (0x0005)
#define _PWR_ICR_EMIFI_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ICR_EMIFI_SHIFT)
#define _PWR_ICR_EMIFI_MASK            (_PWR_ICR_EMIFI_MK(1))
#define _PWR_ICR_EMIFI_CLR             (~(_PWR_ICR_EMIFI_MK(1)))

#define _PWR_ICR_EMIFI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_EMIFI)

#define _PWR_ICR_EMIFI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_EMIFI,Val)


/*==========================================================================*\
* (RW) _PWR_ICR_CLKGENI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_CLKGENI_SHIFT		  (0x0004)
#define _PWR_ICR_CLKGENI_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ICR_CLKGENI_SHIFT)
#define _PWR_ICR_CLKGENI_MASK            (_PWR_ICR_CLKGENI_MK(1))
#define _PWR_ICR_CLKGENI_CLR             (~(_PWR_ICR_CLKGENI_MK(1)))

#define _PWR_ICR_CLKGENI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_CLKGENI)

#define _PWR_ICR_CLKGENI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_CLKGENI,Val)


/*==========================================================================*\
* (RW)
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_PERI_SHIFT		  (0x0003)
#define _PWR_ICR_PERI_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ICR_PERI_SHIFT)
#define _PWR_ICR_PERI_MASK            (_PWR_ICR_PERI_MK(1))
#define _PWR_ICR_PERI_CLR             (~(_PWR_ICR_PERI_MK(1)))

#define _PWR_ICR_PERI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_PERI)

#define _PWR_ICR_PERI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_PERI,Val)


/*==========================================================================*\
* (RW) _PWR_ICR_CACHEI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_CACHEI_SHIFT		  (0x0002)
#define _PWR_ICR_CACHEI_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ICR_CACHEI_SHIFT)
#define _PWR_ICR_CACHEI_MASK            (_PWR_ICR_CACHEI_MK(1))
#define _PWR_ICR_CACHEI_CLR             (~(_PWR_ICR_CACHEI_MK(1)))

#define _PWR_ICR_CACHEI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_CACHEI)

#define _PWR_ICR_CACHEI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_CACHEI,Val)

/*==========================================================================*\
* (RW) _PWR_ICR_DMAI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_DMAI_SHIFT		  (0x0001)
#define _PWR_ICR_DMAI_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ICR_DMAI_SHIFT)
#define _PWR_ICR_DMAI_MASK            (_PWR_ICR_DMAI_MK(1))
#define _PWR_ICR_DMAI_CLR             (~(_PWR_ICR_DMAI_MK(1)))

#define _PWR_ICR_DMAI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_DMAI)

#define _PWR_ICR_DMAI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_DMAI,Val)


/*==========================================================================*\
* (RW) _PWR_ICR_CPUI
\*--------------------------------------------------------------------------*/
#define _PWR_ICR_CPUI_SHIFT		  (0x0000)
#define _PWR_ICR_CPUI_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ICR_CPUI_SHIFT)
#define _PWR_ICR_CPUI_MASK            (_PWR_ICR_CPUI_MK(1))
#define _PWR_ICR_CPUI_CLR             (~(_PWR_ICR_CPUI_MK(1)))

#define _PWR_ICR_CPUI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ICR_CPUI)

#define _PWR_ICR_CPUI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_ICR_CPUI,Val)


/*===========================================================================*\
* _PWR_ISTR    - Idle Status Register
*
* Fields:
*  (R) _PWR_ISTR_EMIFIS
*  (R) _PWR_ISTR_CLKGENIS
*  (R) _PWR_ISTR_PERIS
*  (R) _PWR_ISTR_CACHEIS
*  (R) _PWR_ISTR_DMAIS
*  (R) _PWR_ISTR_CPUIS
*
\*==========================================================================*/


/*==========================================================================*\
* (R) _PWR_ISTR_EMIFIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_EMIFIS_SHIFT		  (0x0005)
#define _PWR_ISTR_EMIFIS_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ISTR_EMIFIS_SHIFT)
#define _PWR_ISTR_EMIFIS_MASK            (_PWR_ISTR_EMIFIS_MK(1))
#define _PWR_ISTR_EMIFIS_CLR             (~(_PWR_ISTR_EMIFIS_MK(1)))

#define _PWR_ISTR_EMIFIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_EMIFIS)


/*==========================================================================*\
* (R) _PWR_ISTR_CLKGENIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_CLKGENIS_SHIFT		  (0x0004)
#define _PWR_ISTR_CLKGENIS_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ISTR_CLKGENIS_SHIFT)
#define _PWR_ISTR_CLKGENIS_MASK            (_PWR_ISTR_CLKGENIS_MK(1))
#define _PWR_ISTR_CLKGENIS_CLR             (~(_PWR_ISTR_CLKGENIS_MK(1)))

#define _PWR_ISTR_CLKGENIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_CLKGENIS)


/*==========================================================================*\
* (R)  _PWR_ISTR_PERIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_PERIS_SHIFT		  (0x0003)
#define _PWR_ISTR_PERIS_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ISTR_PERIS_SHIFT)
#define _PWR_ISTR_PERIS_MASK            (_PWR_ISTR_PERIS_MK(1))
#define _PWR_ISTR_PERIS_CLR             (~(_PWR_ISTR_PERIS_MK(1)))

#define _PWR_ISTR_PERIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_PERIS)


/*==========================================================================*\
* (R) _PWR_ISTR_CACHEIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_CACHEIS_SHIFT		  (0x0002)
#define _PWR_ISTR_CACHEIS_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ISTR_CACHEIS_SHIFT)
#define _PWR_ISTR_CACHEIS_MASK            (_PWR_ISTR_CACHEIS_MK(1))
#define _PWR_ISTR_CACHEIS_CLR             (~(_PWR_ISTR_CACHEIS_MK(1)))

#define _PWR_ISTR_CACHEIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_CACHEIS)


/*==========================================================================*\
* (R) _PWR_ISTR_DMAIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_DMAIS_SHIFT		  (0x0001)
#define _PWR_ISTR_DMAIS_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ISTR_DMAIS_SHIFT)
#define _PWR_ISTR_DMAIS_MASK            (_PWR_ISTR_DMAIS_MK(1))
#define _PWR_ISTR_DMAIS_CLR             (~(_PWR_ISTR_DMAIS_MK(1)))

#define _PWR_ISTR_DMAIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_DMAIS)


/*==========================================================================*\
* (RW) _PWR_ISTR_CPUIS
\*--------------------------------------------------------------------------*/
#define _PWR_ISTR_CPUIS_SHIFT		  (0x0000)
#define _PWR_ISTR_CPUIS_MK(n)           (((Uint16)(n) & 0x0001u) << _PWR_ISTR_CPUIS_SHIFT)
#define _PWR_ISTR_CPUIS_MASK            (_PWR_ISTR_CPUIS_MK(1))
#define _PWR_ISTR_CPUIS_CLR             (~(_PWR_ISTR_CPUIS_MK(1)))

#define _PWR_ISTR_CPUIS_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_ISTR_CPUIS)

#endif

#if (CHIP_5502)

/*===========================================================================*\
* _PWR_PICR    - Peripheral Idle Control Register
*
* Fields:
*  (RW) _PWR_PICR_TIM0
*  (RW) _PWR_PICR_TIM1
*  (RW) _PWR_PICR_SP0
*  (RW) _PWR_PICR_SP1
*  (RW) _PWR_PICR_SP2
*  (RW) _PWR_PICR_IO
*  (RW) _PWR_PICR_ID
*  (RW) _PWR_PICR_I2C
*  (RW) _PWR_PICR_URT
*  (RW) _PWR_PICR_PIO
*  (RW) _PWR_PICR_WDT
*  (RW) _PWR_PICR_BIOST
*  (RW) _PWR_PICR_EMIF
*  (RW) _PWR_PICR_MISC
\*==========================================================================*/

/*==========================================================================*\
* (RW) _PWR_PICR_TIM0
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_TIM0_SHIFT		  (0x0000)
#define _PWR_PICR_TIM0_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_TIM0_SHIFT)
#define _PWR_PICR_TIM0_MASK          (_PWR_PICR_TIM0_MK(1))
#define _PWR_PICR_TIM0_CLR           (~(_PWR_PICR_TIM0_MK(1)))

#define _PWR_PICR_TIM0_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_TIM0)

#define _PWR_PICR_TIM0_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_TIM0,Val)

/*==========================================================================*\
* (RW) _PWR_PICR_TIM1
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_TIM1_SHIFT		  (0x0001)
#define _PWR_PICR_TIM1_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_TIM1_SHIFT)
#define _PWR_PICR_TIM1_MASK          (_PWR_PICR_TIM1_MK(1))
#define _PWR_PICR_TIM1_CLR           (~(_PWR_PICR_TIM1_MK(1)))

#define _PWR_PICR_TIM1_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_TIM1)

#define _PWR_PICR_TIM1_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_TIM1,Val)

/*==========================================================================*\
* (RW) _PWR_PICR_SP0
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_SP0_SHIFT		  (0x0002)
#define _PWR_PICR_SP0_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_SP0_SHIFT)
#define _PWR_PICR_SP0_MASK          (_PWR_PICR_SP0_MK(1))
#define _PWR_PICR_SP0_CLR           (~(_PWR_PICR_SP0_MK(1)))

#define _PWR_PICR_SP0_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_SP0)

#define _PWR_PICR_SP0_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_SP0,Val)

/*==========================================================================*\
* (RW) _PWR_PICR_SP1
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_SP1_SHIFT		  (0x0003)
#define _PWR_PICR_SP1_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_SP1_SHIFT)
#define _PWR_PICR_SP1_MASK          (_PWR_PICR_SP1_MK(1))
#define _PWR_PICR_SP1_CLR           (~(_PWR_PICR_SP1_MK(1)))

#define _PWR_PICR_SP1_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_SP1)

#define _PWR_PICR_SP1_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_SP1,Val)


/*==========================================================================*\
* (RW) _PWR_PICR_SP2
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_SP2_SHIFT		  (0x0004)
#define _PWR_PICR_SP2_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_SP2_SHIFT)
#define _PWR_PICR_SP2_MASK          (_PWR_PICR_SP2_MK(1))
#define _PWR_PICR_SP2_CLR           (~(_PWR_PICR_SP2_MK(1)))

#define _PWR_PICR_SP2_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_SP2)

#define _PWR_PICR_SP2_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_SP2,Val)

/*==========================================================================*\
* (RW) _PWR_PICR_IO
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_IO_SHIFT		  (0x0005)
#define _PWR_PICR_IO_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_IO_SHIFT)
#define _PWR_PICR_IO_MASK          (_PWR_PICR_IO_MK(1))
#define _PWR_PICR_IO_CLR           (~(_PWR_PICR_IO_MK(1)))

#define _PWR_PICR_IO_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_IO)

#define _PWR_PICR_IO_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_IO,Val)

/*==========================================================================*\
* (RW) _PWR_PICR_ID
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_ID_SHIFT		  (0x0006)
#define _PWR_PICR_ID_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_ID_SHIFT)
#define _PWR_PICR_ID_MASK          (_PWR_PICR_ID_MK(1))
#define _PWR_PICR_ID_CLR           (~(_PWR_PICR_ID_MK(1)))

#define _PWR_PICR_ID_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_ID)

#define _PWR_PICR_ID_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_ID,Val)

/*==========================================================================*\
* (RW) _PWR_PICR_I2C
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_I2C_SHIFT		  (0x0007)
#define _PWR_PICR_I2C_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_I2C_SHIFT)
#define _PWR_PICR_I2C_MASK          (_PWR_PICR_I2C_MK(1))
#define _PWR_PICR_I2C_CLR           (~(_PWR_PICR_I2C_MK(1)))

#define _PWR_PICR_I2C_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_I2C)

#define _PWR_PICR_I2C_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_I2C,Val)

/*==========================================================================*\
* (RW) _PWR_PICR_URT
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_URT_SHIFT		  (0x0008)
#define _PWR_PICR_URT_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_URT_SHIFT)
#define _PWR_PICR_URT_MASK          (_PWR_PICR_URT_MK(1))
#define _PWR_PICR_URT_CLR           (~(_PWR_PICR_URT_MK(1)))

#define _PWR_PICR_URT_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_URT)

#define _PWR_PICR_URT_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_URT,Val)

/*==========================================================================*\
* (RW) _PWR_PICR_PIO
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_PIO_SHIFT		  (0x0009)
#define _PWR_PICR_PIO_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_PIO_SHIFT)
#define _PWR_PICR_PIO_MASK          (_PWR_PICR_PIO_MK(1))
#define _PWR_PICR_PIO_CLR           (~(_PWR_PICR_PIO_MK(1)))

#define _PWR_PICR_PIO_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_PIO)

#define _PWR_PICR_PIO_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_PIO,Val)

/*==========================================================================*\
* (RW) _PWR_PICR_WDT
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_WDT_SHIFT		  (0x000A)
#define _PWR_PICR_WDT_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_WDT_SHIFT)
#define _PWR_PICR_WDT_MASK          (_PWR_PICR_WDT_MK(1))
#define _PWR_PICR_WDT_CLR           (~(_PWR_PICR_WDT_MK(1)))

#define _PWR_PICR_WDT_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_WDT)

#define _PWR_PICR_WDT_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_WDT,Val)

/*==========================================================================*\
* (RW) _PWR_PICR_BIOST
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_BIOST_SHIFT		  (0x000B)
#define _PWR_PICR_BIOST_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_BIOST_SHIFT)
#define _PWR_PICR_BIOST_MASK          (_PWR_PICR_BIOST_MK(1))
#define _PWR_PICR_BIOST_CLR           (~(_PWR_PICR_BIOST_MK(1)))

#define _PWR_PICR_BIOST_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_BIOST)

#define _PWR_PICR_BIOST_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_BIOST,Val)


/*==========================================================================*\
* (RW) _PWR_PICR_EMIF
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_EMIF_SHIFT		  (0x000C)
#define _PWR_PICR_EMIF_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_EMIF_SHIFT)
#define _PWR_PICR_EMIF_MASK          (_PWR_PICR_EMIF_MK(1))
#define _PWR_PICR_EMIF_CLR           (~(_PWR_PICR_EMIF_MK(1)))

#define _PWR_PICR_EMIF_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_EMIF)

#define _PWR_PICR_EMIF_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_EMIF,Val)

/*==========================================================================*\
* (RW) _PWR_PICR_MISC
\*--------------------------------------------------------------------------*/
#define _PWR_PICR_MISC_SHIFT		  (0x000D)
#define _PWR_PICR_MISC_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PICR_MISC_SHIFT)
#define _PWR_PICR_MISC_MASK          (_PWR_PICR_MISC_MK(1))
#define _PWR_PICR_MISC_CLR           (~(_PWR_PICR_MISC_MK(1)))

#define _PWR_PICR_MISC_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PICR_MISC)

#define _PWR_PICR_MISC_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PICR_MISC,Val)

/*===========================================================================*\
* _PWR_PISTR    - Peripheral Idle Status Register
*
* Fields:
*  (R) _PWR_PISTR_TIM0
*  (R) _PWR_PISTR_TIM1
*  (R) _PWR_PISTR_SP0
*  (R) _PWR_PISTR_SP1
*  (R) _PWR_PISTR_SP2
*  (R) _PWR_PISTR_IO
*  (R) _PWR_PISTR_ID
*  (R) _PWR_PISTR_I2C
*  (R) _PWR_PISTR_URT
*  (R) _PWR_PISTR_PIO
*  (R) _PWR_PISTR_WDT
*  (R) _PWR_PISTR_BIOST
*  (R) _PWR_PISTR_EMIF
*  (R) _PWR_PISTR_MISC
*
\*==========================================================================*/

/*==========================================================================*\
* (R) _PWR_PISTR_TIM0
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_TIM0_SHIFT		  (0x0000)
#define _PWR_PISTR_TIM0_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_TIM0_SHIFT)
#define _PWR_PISTR_TIM0_MASK          (_PWR_PISTR_TIM0_MK(1))
#define _PWR_PISTR_TIM0_CLR           (~(_PWR_PISTR_TIM0_MK(1)))

#define _PWR_PISTR_TIM0_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_TIM0)

#define _PWR_PISTR_TIM0_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_TIM0,Val)

/*==========================================================================*\
* (R) _PWR_PISTR_TIM1
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_TIM1_SHIFT		  (0x0001)
#define _PWR_PISTR_TIM1_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_TIM1_SHIFT)
#define _PWR_PISTR_TIM1_MASK          (_PWR_PISTR_TIM1_MK(1))
#define _PWR_PISTR_TIM1_CLR           (~(_PWR_PISTR_TIM1_MK(1)))

#define _PWR_PISTR_TIM1_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_TIM1)

#define _PWR_PISTR_TIM1_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_TIM1,Val)

/*==========================================================================*\
* (R) _PWR_PISTR_SP0
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_SP0_SHIFT		  (0x0002)
#define _PWR_PISTR_SP0_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_SP0_SHIFT)
#define _PWR_PISTR_SP0_MASK          (_PWR_PISTR_SP0_MK(1))
#define _PWR_PISTR_SP0_CLR           (~(_PWR_PISTR_SP0_MK(1)))

#define _PWR_PISTR_SP0_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_SP0)

#define _PWR_PISTR_SP0_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_SP0,Val)

/*==========================================================================*\
* (R) _PWR_PISTR_SP1
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_SP1_SHIFT		  (0x0003)
#define _PWR_PISTR_SP1_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_SP1_SHIFT)
#define _PWR_PISTR_SP1_MASK          (_PWR_PISTR_SP1_MK(1))
#define _PWR_PISTR_SP1_CLR           (~(_PWR_PISTR_SP1_MK(1)))

#define _PWR_PISTR_SP1_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_SP1)

#define _PWR_PISTR_SP1_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_SP1,Val)


/*==========================================================================*\
* (R) _PWR_PISTR_SP2
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_SP2_SHIFT		  (0x0004)
#define _PWR_PISTR_SP2_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_SP2_SHIFT)
#define _PWR_PISTR_SP2_MASK          (_PWR_PISTR_SP2_MK(1))
#define _PWR_PISTR_SP2_CLR           (~(_PWR_PISTR_SP2_MK(1)))

#define _PWR_PISTR_SP2_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_SP2)

#define _PWR_PISTR_SP2_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_SP2,Val)

/*==========================================================================*\
* (R) _PWR_PISTR_IO
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_IO_SHIFT		  (0x0005)
#define _PWR_PISTR_IO_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_IO_SHIFT)
#define _PWR_PISTR_IO_MASK          (_PWR_PISTR_IO_MK(1))
#define _PWR_PISTR_IO_CLR           (~(_PWR_PISTR_IO_MK(1)))

#define _PWR_PISTR_IO_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_IO)

#define _PWR_PISTR_IO_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_IO,Val)

/*==========================================================================*\
* (R) _PWR_PISTR_ID
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_ID_SHIFT		  (0x0006)
#define _PWR_PISTR_ID_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_ID_SHIFT)
#define _PWR_PISTR_ID_MASK          (_PWR_PISTR_ID_MK(1))
#define _PWR_PISTR_ID_CLR           (~(_PWR_PISTR_ID_MK(1)))

#define _PWR_PISTR_ID_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_ID)

#define _PWR_PISTR_ID_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_ID,Val)

/*==========================================================================*\
* (R) _PWR_PISTR_I2C
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_I2C_SHIFT		  (0x0007)
#define _PWR_PISTR_I2C_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_I2C_SHIFT)
#define _PWR_PISTR_I2C_MASK          (_PWR_PISTR_I2C_MK(1))
#define _PWR_PISTR_I2C_CLR           (~(_PWR_PISTR_I2C_MK(1)))

#define _PWR_PISTR_I2C_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_I2C)

#define _PWR_PISTR_I2C_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_I2C,Val)

/*==========================================================================*\
* (R) _PWR_PISTR_URT
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_URT_SHIFT		  (0x0008)
#define _PWR_PISTR_URT_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_URT_SHIFT)
#define _PWR_PISTR_URT_MASK          (_PWR_PISTR_URT_MK(1))
#define _PWR_PISTR_URT_CLR           (~(_PWR_PISTR_URT_MK(1)))

#define _PWR_PISTR_URT_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_URT)

#define _PWR_PISTR_URT_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_URT,Val)

/*==========================================================================*\
* (R) _PWR_PISTR_PIO
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_PIO_SHIFT		  (0x0009)
#define _PWR_PISTR_PIO_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_PIO_SHIFT)
#define _PWR_PISTR_PIO_MASK          (_PWR_PISTR_PIO_MK(1))
#define _PWR_PISTR_PIO_CLR           (~(_PWR_PISTR_PIO_MK(1)))

#define _PWR_PISTR_PIO_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_PIO)

#define _PWR_PISTR_PIO_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_PIO,Val)

/*==========================================================================*\
* (R) _PWR_PISTR_WDT
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_WDT_SHIFT		  (0x000A)
#define _PWR_PISTR_WDT_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_WDT_SHIFT)
#define _PWR_PISTR_WDT_MASK          (_PWR_PISTR_WDT_MK(1))
#define _PWR_PISTR_WDT_CLR           (~(_PWR_PISTR_WDT_MK(1)))

#define _PWR_PISTR_WDT_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_WDT)

#define _PWR_PISTR_WDT_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_WDT,Val)

/*==========================================================================*\
* (R) _PWR_PISTR_BIOST
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_BIOST_SHIFT		  (0x000B)
#define _PWR_PISTR_BIOST_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_BIOST_SHIFT)
#define _PWR_PISTR_BIOST_MASK          (_PWR_PISTR_BIOST_MK(1))
#define _PWR_PISTR_BIOST_CLR           (~(_PWR_PISTR_BIOST_MK(1)))

#define _PWR_PISTR_BIOST_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_BIOST)

#define _PWR_PISTR_BIOST_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_BIOST,Val)

/*==========================================================================*\
* (RW) _PWR_PISTR_EMIF
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_EMIF_SHIFT		  (0x000C)
#define _PWR_PISTR_EMIF_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_EMIF_SHIFT)
#define _PWR_PISTR_EMIF_MASK          (_PWR_PISTR_EMIF_MK(1))
#define _PWR_PISTR_EMIF_CLR           (~(_PWR_PISTR_EMIF_MK(1)))

#define _PWR_PISTR_EMIF_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_EMIF)

#define _PWR_PISTR_EMIF_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_EMIF,Val)

/*==========================================================================*\
* (RW) _PWR_PISTR_MISC
\*--------------------------------------------------------------------------*/
#define _PWR_PISTR_MISC_SHIFT		  (0x000D)
#define _PWR_PISTR_MISC_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_PISTR_MISC_SHIFT)
#define _PWR_PISTR_MISC_MASK          (_PWR_PISTR_MISC_MK(1))
#define _PWR_PISTR_MISC_CLR           (~(_PWR_PISTR_MISC_MK(1)))

#define _PWR_PISTR_MISC_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_PISTR_MISC)

#define _PWR_PISTR_MISC_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_PISTR_MISC,Val)

/*===========================================================================*\
* _PWR_MICR    - Master Idle Control Register
*
* Fields:
*  (RW) _PWR_MICR_DMA
*  (RW) _PWR_MICR_HPI
*
\*==========================================================================*/

/*==========================================================================*\
* (RW) _PWR_MICR_DMA
\*--------------------------------------------------------------------------*/
#define _PWR_MICR_DMA_SHIFT		  (0x0000)
#define _PWR_MICR_DMA_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_MICR_DMA_SHIFT)
#define _PWR_MICR_DMA_MASK          (_PWR_MICR_DMA_MK(1))
#define _PWR_MICR_DMA_CLR           (~(_PWR_MICR_DMA_MK(1)))

#define _PWR_MICR_DMA_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_MICR_DMA)

#define _PWR_MICR_DMA_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_MICR_DMA,Val)

/*==========================================================================*\
* (RW) _PWR_MICR_HPI
\*--------------------------------------------------------------------------*/
#define _PWR_MICR_HPI_SHIFT		  (0x0001)
#define _PWR_MICR_HPI_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_MICR_HPI_SHIFT)
#define _PWR_MICR_HPI_MASK          (_PWR_MICR_HPI_MK(1))
#define _PWR_MICR_HPI_CLR           (~(_PWR_MICR_HPI_MK(1)))

#define _PWR_MICR_HPI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_MICR_HPI)

#define _PWR_MICR_HPI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_MICR_HPI,Val)


/*===========================================================================*\
* _PWR_MISR    - Master Idle Status Register
*
* Fields:
*  (R) _PWR_MISR_DMA
*  (R) _PWR_MISR_HPI
*
\*==========================================================================*/

/*==========================================================================*\
* (R) _PWR_MISR_DMA
\*--------------------------------------------------------------------------*/
#define _PWR_MISR_DMA_SHIFT		  (0x0000)
#define _PWR_MISR_DMA_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_MISR_DMA_SHIFT)
#define _PWR_MISR_DMA_MASK          (_PWR_MISR_DMA_MK(1))
#define _PWR_MISR_DMA_CLR           (~(_PWR_MISR_DMA_MK(1)))

#define _PWR_MISR_DMA_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_MISR_DMA)

#define _PWR_MISR_DMA_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_MISR_DMA,Val)

/*==========================================================================*\
* (R) _PWR_MISR_UHPI
\*--------------------------------------------------------------------------*/
#define _PWR_MISR_HPI_SHIFT		  (0x0001)
#define _PWR_MISR_HPI_MK(n)         (((Uint16)(n) & 0x0001u) << _PWR_MISR_HPI_SHIFT)
#define _PWR_MISR_HPI_MASK          (_PWR_MISR_HPI_MK(1))
#define _PWR_MISR_HPI_CLR           (~(_PWR_MISR_HPI_MK(1)))

#define _PWR_MISR_HPI_GET(RegAddr) \
	_PFIELD_GET(RegAddr,_PWR_MISR_HPI)

#define _PWR_MISR_HPI_SET(RegAddr,Val) \
	_PFIELD_SET(RegAddr,_PWR_MISR_HPI,Val)

#endif   //CHIP_5502
/*----------------------------------------------------------------------------*/

#endif /* PWR_SUPPORT */
#endif /* _PWRHAL_H_ */
/******************************************************************************\
* End of pwrhal.h
\******************************************************************************/

csl_rtc.h/      1070367896  0     0     0       19033     `
/****************************************************************************\
*           Copyright (C) 1999-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... RTC
* FILENAME...... csl_rtc.h
* DATE CREATED.. Thu Feb  1 10:52:13 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS..
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:	Thu Feb  1 10:52:13 2001 (Automatic generation)
*	 3/30/2001	Modified to fix midnight bug (IM)
*	 Modified:  4/11/2001 (IM) Changed to reflect the changes in the RTC documentation version 2.8
*	 Modified:	7/20/2001 (IM) changed some names
*	 Modified:	7/20/2001 (IM) Removed 2nd and 3rd argument from setCallback function
*    Modified:	7/20/2001 (IM) Added RTC_stop() function
*    Modified:  7/03/2003  Renamed the variable names from 'new' to 'val' to
*                            avoid C++ compile time erros.
*    Modified:  9/17/2003  Modified RTC_decToBcd() and RTC_bcdToDec()
*                            to avoid rts55 library calls.
*            : 12/02/2003  Added inline definitions for eventEnable and 
*                            eventDisable APIs for inlining, added underscore
*                            '_' prefix for private API
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the RTC module
*
\*************************************************************************/

#ifndef _CSL_RTC_H_
#define _CSL_RTC_H_

#include <_csl.h>
#include <csl_rtcdat.h>
#include <csl_rtchal.h>

#if (_RTC_SUPPORT) 

/*----------------------------------------------------------------*\
*	 RTC scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _RTC_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/****************************************\
* RTC global macro declarations
\****************************************/

/* error codes */
#define RTC_ERR_MAJOR		   (ERR_BASE_RTC) 
#define RTC_ERR_ALLOC		   (0x00000000) 
#define RTC_ERR_INVALID_HANDLE  (0x00000001) 


/********************************************\
	Periodic interrupt Rates (Register A)
\********************************************/
#define RTC_RTCPINTR_UIP_NO       (0x00u)
#define RTC_RTCPINTR_UIP_YES      (0x01u)

#define RTC_RATE_NONE      0x0000
#define RTC_RATE_122us     0x0003
#define RTC_RATE_244us     0x0004
#define RTC_RATE_488us     0x0005
#define RTC_RATE_976us     0x0006
#define RTC_RATE_1_95ms    0x0007
#define RTC_RATE_3_9ms     0x0008
#define RTC_RATE_7_8125ms  0x0009
#define RTC_RATE_15_625ms  0x000A
#define RTC_RATE_31_25ms   0x000B
#define RTC_RATE_62_5ms    0x000C
#define RTC_RATE_125ms     0x000D
#define RTC_RATE_250ms     0x000E
#define RTC_RATE_500ms     0x000F
#define RTC_RATE_1min      0x001F

#define DONTCARE		   0xFF
/********************************************\
	RTC time of day (AM/PM bits in RTCHOUR and RTCHOURA registers)
\********************************************/
/*
#define AM		0
#define PM		1

*/

/* ============================================================== */
 /* Make RTCDAYW register values based on symbolic constants  */

#define RTC_RTCDAYW_RMK(dar,daen,day)\
 ((Uint16) ( \
  ( RTC_FMK(RTCDAYW,DAR,dar))|\
  ( RTC_FMK(RTCDAYW,DAEN,daen))|\
  ( RTC_FMK(RTCDAYW,DAY,day))\
)\
 )

#define RTC_RTCDAYW_RMKS(dar_sym,daen_sym,day_sym)\
 ((Uint16) ( \
  ( RTC_FMKS(RTCDAYW,DAR,dar_sym))|\
  ( RTC_FMKS(RTCDAYW,DAEN,daen_sym))|\
  ( RTC_FMKS(RTCDAYW,DAY,day_sym))\
)\
 )

/*  Default RTCDAYW register value  */

/*  RTCDAYW field values  */

#define RTC_RTCDAYW_DAY_OF(x)         ((Uint16)(x))
#define RTC_RTCDAYW_DAR_OF(x)         ((Uint16)(x))
#define RTC_RTCDAYW_DAEN_ENABLE       (0x01u)
#define RTC_RTCDAYW_DAEN_DISABLE      (0x00u)


/* ============================================================== */
 /* Make RTCHOUR register values based on symbolic constants  */

#define RTC_RTCHOUR_RMK(ampm,hr)\
 ((Uint16) ( \
  ( RTC_FMK(RTCHOUR,AMPM,ampm))|\
  ( RTC_FMK(RTCHOUR,HR,hr))\
)\
 )

#define RTC_RTCHOUR_RMKS(ampm_sym,hr_sym)\
 ((Uint16) ( \
  ( RTC_FMKS(RTCHOUR,AMPM,ampm_sym))|\
  ( RTC_FMKS(RTCHOUR,HR,hr_sym))\
)\
 )

/*  Default RTCHOUR register value  */

/*  RTCHOUR field values  */

#define RTC_RTCHOUR_AMPM_AM           (0x00u)
#define RTC_RTCHOUR_AMPM_PM           (0x01u)
#define RTC_RTCHOUR_HR_OF(x)          ((Uint16)(x))

/* ============================================================== */
 /* Make RTCHOURA register values based on symbolic constants  */

#define RTC_RTCHOURA_RMK(ampm,har)\
 ((Uint16) ( \
  ( RTC_FMK(RTCHOURA,AMPM,ampm))|\
  ( RTC_FMK(RTCHOURA,HAR,har))\
)\
 )

#define RTC_RTCHOURA_RMKS(ampm_sym,har_sym)\
 ((Uint16) ( \
  ( RTC_FMKS(RTCHOURA,AMPM,ampm_sym))|\
  ( RTC_FMKS(RTCHOURA,HAR,har_sym))\
)\
 )

/*  Default RTCHOURA register value  */

/*  RTCHOURA field values  */

#define RTC_RTCHOURA_AMPM_AM           (0x00u)
#define RTC_RTCHOURA_AMPM_PM           (0x01u)
#define RTC_RTCHOURA_HAR_OF(x)         ((Uint16)(x))

/* ============================================================== */
 /* Make RTCINTEN register values based on symbolic constants  */

#define RTC_RTCINTEN_RMK(set,pie,aie,uie,tm)\
 ((Uint16) ( \
  ( RTC_FMK(RTCINTEN,SET,set))|\
  ( RTC_FMK(RTCINTEN,PIE,pie))|\
  ( RTC_FMK(RTCINTEN,AIE,aie))|\
  ( RTC_FMK(RTCINTEN,UIE,uie))|\
  ( RTC_FMK(RTCINTEN,TM,tm))\
)\
 )

#define RTC_RTCINTEN_RMKS(set_sym,pie_sym,aie_sym,uie_sym,tm_sym)\
 ((Uint16) ( \
  ( RTC_FMKS(RTCINTEN,SET,set_sym))|\
  ( RTC_FMKS(RTCINTEN,PIE,pie_sym))|\
  ( RTC_FMKS(RTCINTEN,AIE,aie_sym))|\
  ( RTC_FMKS(RTCINTEN,UIE,uie_sym))|\
  ( RTC_FMKS(RTCINTEN,TM,tm_sym))\
)\
 )

/*  Default RTCINTEN register value  */

/*  RTCINTEN field values  */

#define RTC_RTCINTEN_SET_OFF			(0x00u)
#define RTC_RTCINTEN_SET_ON			(0x01u)
#define RTC_RTCINTEN_PIE_DISABLE		(0x00u)
#define RTC_RTCINTEN_PIE_ENABLE		(0x01u)
#define RTC_RTCINTEN_AIE_DISABLE		(0x00u)
#define RTC_RTCINTEN_AIE_ENABLE		(0x01u)
#define RTC_RTCINTEN_UIE_DISABLE		(0x00u)
#define RTC_RTCINTEN_UIE_ENABLE		(0x01u)
#define RTC_RTCINTEN_TM_12HMODE		(0x00u)
#define RTC_RTCINTEN_TM_24HMODE		(0x01u)
#define RTC_RTCINTEN_TM_DEFAULT		RTC_RTCINTEN_TM_24HMODE

/* ============================================================== */
 /* Make RTCINTFL register values based on symbolic constants  */

#define RTC_RTCINTFL_RMK(pf,af,uf)\
 ((Uint16) ( \
  ( RTC_FMK(RTCINTFL,PF,pf))|\
  ( RTC_FMK(RTCINTFL,AF,af))|\
  ( RTC_FMK(RTCINTFL,UF,uf))\
)\
 )

#define RTC_RTCINTFL_RMKS(pf_sym,af_sym,uf_sym)\
 ((Uint16) ( \
  ( RTC_FMKS(RTCINTFL,PF,pf_sym))|\
  ( RTC_FMKS(RTCINTFL,AF,af_sym))|\
  ( RTC_FMKS(RTCINTFL,UF,uf_sym))\
)\
 )

/*  Default RTCINTFL register value  */

/*  RTCINTFL field values  */

#define RTC_RTCINTFL_IRQF_NO		(0x00u)
#define RTC_RTCINTFL_IRQF_YES		(0x01u)
#define RTC_RTCINTFL_PF_NO		(0x00u)
#define RTC_RTCINTFL_PF_YES		(0x01u)
#define RTC_RTCINTFL_AF_NO		(0x00u)
#define RTC_RTCINTFL_AF_YES		(0x01u)
#define RTC_RTCINTFL_UF_NO		(0x00u)
#define RTC_RTCINTFL_UF_YES		(0x01u)


/* ============================================================== */
	/* Macros for periodic alarms */

#define _SET_B		RTC_FSET(RTCINTEN,SET,1)		/* Set bit SET in Register B to 1 */  
#define _RESET_B		RTC_FSET(RTCINTEN,SET,0)		/* Set bit SET in Register B to 0 */  


/* ============================================================== */


/*************************************************\
 RTC global typedef declarations 
\*************************************************/

typedef struct {
	Uint16 rtcsec;
	Uint16 rtcseca;
	Uint16 rtcmin;
	Uint16 rtcmina;
	Uint16 rtchour;
	Uint16 rtchoura;
	Uint16 rtcdayw;
	Uint16 rtcdaym;
	Uint16 rtcmonth;
	Uint16 rtcyear;
	Uint16 rtcpintr;
	Uint16 rtcinten;
      Uint16 rtcintfl;
} RTC_Config;

typedef struct {
	Uint16 year;
	Uint16 month;
	Uint16 daym;
	Uint16 dayw;
} RTC_Date;

typedef struct {
	Uint16 hour;
	Uint16 minute;
	Uint16 second;
} RTC_Time;


typedef struct {
	Uint16 alhour;
	Uint16 alminute;
	Uint16 alsecond;
	Uint16 aldayw;
} RTC_Alarm;

/*************** Declarations for interrupt routines ******************/
typedef struct 
{ 
   void (*periodicAddr)(void);          // Periodic interrupt
   void (*alarmAddr)(void);         // Alarm interrupt
   void (*updateAddr)(void);         // update ended
} RTC_IsrAddr; 

#define    RTC_EVT_PERIODIC   (Uint16)0x40     // Periodic Interrupt Enable
#define    RTC_EVT_ALARM   	(Uint16)0x20     // Alarm Interrupt Enable
#define    RTC_EVT_UPDATE  	(Uint16)0x10     // Update Ended Interrupt

/*************** End Declarations for interrupt routines ******************/

/*************************************************\
* RTC global variable declarations
\*************************************************/


/*************************************************\
* RTC global function declarations
\*************************************************/

IDECL void RTC_config(RTC_Config *Config);

IDECL void RTC_configArgs(Uint16 rtcsec,Uint16 rtcseca,Uint16 rtcmin,Uint16 rtcmina,Uint16 rtchour,Uint16 rtchoura,Uint16 rtcdayw,
				   Uint16 rtcdaym,Uint16 rtcmonth,Uint16 rtcyear,Uint16 rtcpintr,Uint16 rtcinten);

IDECL void RTC_getConfig(RTC_Config *Config);

IDECL void RTC_setTime(RTC_Time *myTime);
IDECL void RTC_getTime(RTC_Time *myTime);
IDECL void RTC_setDate(RTC_Date *myDate);
IDECL void RTC_getDate(RTC_Date *myDate);

IDECL void RTC_setPeriodicInterval(Uint16 interval); /* Set periodic interrupt rate (see RS table) */
IDECL void RTC_setAlarm(RTC_Alarm *myAlarm);	/* Set alarm at a specific time: sec, min, hour, day of week */

IDECL int RTC_getEventId();
IDECL void RTC_eventEnable(Uint16 isrMask);
IDECL void RTC_eventDisable(Uint16 ierMask);
IDECL void RTC_start();
IDECL void RTC_stop();

IDECL int RTC_decToBcd(int dec_value);
IDECL int RTC_bcdToDec(int hex_value);

CSLAPI void RTC_setCallback(RTC_IsrAddr *isrAddr);
CSLAPI void RTC_reset();

/***** private function *****/
interrupt void _RTC_intrDispatch(void);

/*************************************************\
* RTC inline function declarations
\*************************************************/

#ifdef USEDEFS

IDEF void RTC_config(RTC_Config *Config) {
  int old_intm;

  old_intm = IRQ_globalDisable();  

  RTC_RSET(RTCINTFL,0x70);			/* Clear flags in Register C */
  _SET_B;			/* Set bit SET in Register B to 1 */  

/* Set Data registers */
  RTC_RSET(RTCSEC,Config->rtcsec);
  RTC_RSET(RTCSECA,Config->rtcseca);
  RTC_RSET(RTCMIN,Config->rtcmin);
  RTC_RSET(RTCMINA,Config->rtcmina);
  RTC_RSET(RTCHOUR,Config->rtchour);
  RTC_RSET(RTCHOURA,Config->rtchoura);
  RTC_RSET(RTCDAYW,Config->rtcdayw);
  RTC_RSET(RTCDAYM,Config->rtcdaym);
  RTC_RSET(RTCMONTH,Config->rtcmonth);
  RTC_RSET(RTCYEAR,Config->rtcyear);    
  
  RTC_RSET(RTCPINTR,Config->rtcpintr);	/* Set Register A */
  RTC_RSET(RTCINTEN,Config->rtcinten);	/* Set Register B */

  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/
 IDEF void RTC_getConfig(RTC_Config *Config) {
  int old_intm, old_set;
  old_intm = IRQ_globalDisable();  
  old_set = RTC_FGET(RTCINTEN, SET);

  while (RTC_FGET(RTCPINTR,UIP) != 0);

  _SET_B;		 /* Set bit SET in Register B to 1 */

  Config->rtcsec = RTC_RGET(RTCSEC);
  Config->rtcseca = RTC_RGET(RTCSECA);
  Config->rtcmin = RTC_RGET(RTCMIN);
  Config->rtcmina = RTC_RGET(RTCMINA);  
  Config->rtchour = RTC_RGET(RTCHOUR);
  Config->rtchoura = RTC_RGET(RTCHOURA);
  Config->rtcdayw = RTC_RGET(RTCDAYW);
  Config->rtcdaym = RTC_RGET(RTCDAYM);
  Config->rtcmonth = RTC_RGET(RTCMONTH);
  Config->rtcyear = RTC_RGET(RTCYEAR);
  Config->rtcpintr = RTC_RGET(RTCPINTR);
  Config->rtcinten = RTC_RGET(RTCINTEN);

  RTC_FSET(RTCINTEN, SET, old_set);

  IRQ_globalRestore(old_intm);   
}            

/*----------------------------------------------------------------------------------------------*/
IDEF void RTC_configArgs(Uint16 rtcsec,Uint16 rtcseca,Uint16 rtcmin,Uint16 rtcmina,Uint16 rtchour,Uint16 rtchoura,Uint16 rtcdayw,
				   Uint16 rtcdaym,Uint16 rtcmonth,Uint16 rtcyear,Uint16 rtcpintr,Uint16 rtcinten)
{
  int old_intm;

   old_intm = IRQ_globalDisable(); 
    
  RTC_RSET(RTCPINTR,rtcpintr);
  _SET_B; 		 /* Set bit SET in Register B to 1 */  

  RTC_RSET(RTCSEC,rtcsec);
  RTC_RSET(RTCSECA,rtcseca);
  RTC_RSET(RTCMIN,rtcmin);
  RTC_RSET(RTCMINA,rtcmina);
  RTC_RSET(RTCHOUR,rtchour);
  RTC_RSET(RTCHOURA,rtchoura);
  RTC_RSET(RTCDAYW,rtcdayw);
  RTC_RSET(RTCDAYM,rtcdaym);
  RTC_RSET(RTCMONTH,rtcmonth);
  RTC_RSET(RTCYEAR,rtcyear);    
  RTC_RSET(RTCINTEN,rtcinten);
  
  IRQ_globalRestore(old_intm);   
}

/*--------------------------------------------------------------------------------------------*/

IDEF void RTC_setTime(RTC_Time *myTime) {
  /* time is set for the default mode of 24-hour */

  int old_intm;
  old_intm = IRQ_globalDisable();  

  _SET_B; 		 /* Set bit SET in Register B to 1 */  

  RTC_FSET(RTCINTEN, TM, 1);		//Make sure we have time in 24-hour format
  RTC_RSET(RTCSEC,myTime->second); 
  RTC_RSET(RTCMIN,myTime->minute);
  RTC_FSET(RTCHOUR,HR,myTime->hour);
	
  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/

IDEF void RTC_getTime(RTC_Time *myTime) {
  int old_intm, old_set;

/* Only a 24-hour mode is supported */

  old_intm = IRQ_globalDisable();  
  old_set = RTC_FGET(RTCINTEN, SET);

  while (RTC_FGET(RTCPINTR,UIP) != 0);

  _SET_B;		 /* Set bit SET in Register B to 1 */

  myTime->second = RTC_RGET(RTCSEC);
  myTime->minute = RTC_RGET(RTCMIN);
  myTime->hour = RTC_FGET(RTCHOUR,HR); 
  
  RTC_FSET(RTCINTEN, SET, old_set);

  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/

IDEF void RTC_setDate(RTC_Date *myDate) {
  int old_intm;

  old_intm = IRQ_globalDisable();  

  _SET_B; 		 /* Set bit SET in Register B to 1 */  

  RTC_RSET(RTCYEAR,myDate->year);
  RTC_FSET(RTCMONTH,MONTH,myDate->month);
  RTC_FSET(RTCDAYM,DATE,myDate->daym);
  RTC_FSET(RTCDAYW,DAY,myDate->dayw);

  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/

IDEF void RTC_getDate(RTC_Date *myDate) {
  int old_intm, old_set;
  old_intm = IRQ_globalDisable();  
  old_set = RTC_FGET(RTCINTEN, SET);

  while (RTC_FGET(RTCPINTR,UIP) != 0);
  
  myDate->year = RTC_RGET(RTCYEAR);
  myDate->month = RTC_FGET(RTCMONTH,MONTH);
  myDate->daym = RTC_FGET(RTCDAYM,DATE);
  myDate->dayw = RTC_FGET(RTCDAYW,DAY);

  RTC_FSET(RTCINTEN, SET, old_set);

  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/

IDEF void RTC_setPeriodicInterval(Uint16 interval) { /* Set periodic interrupt rate (see RS table) */
  int old_intm;
  old_intm = IRQ_globalDisable();  

  RTC_FSET(RTCPINTR,RS,interval);

  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/

IDEF void RTC_setAlarm(RTC_Alarm *myAlarm) {
  int old_intm;
  old_intm = IRQ_globalDisable();  

/* Only a 24-hour mode is supported */

  _SET_B; 		 /* Set bit SET in Register B to 1 */  

 // RTC_RSET(RTCSECA,SAR,myAlarm->alsecond); 
 // RTC_RSET(RTCMINA,MAR,myAlarm->alminute);
  RTC_FSET(RTCSECA,SAR,myAlarm->alsecond); 
  RTC_FSET(RTCMINA,MAR,myAlarm->alminute);
  RTC_FSET(RTCHOURA,HAR,myAlarm->alhour);
  RTC_FSET(RTCDAYW,DAEN, 1);
  RTC_FSET(RTCDAYW,DAR,myAlarm->aldayw);

  IRQ_globalRestore(old_intm);   

}

/*----------------------------------------------------------------------------*/
IDEF int RTC_getEventId() {

	return IRQ_EVT_RTC;
}

IDEF void RTC_eventEnable(Uint16 isrMask)
{     Uint16 temp;
	temp = RTC_RGET(RTCINTEN)|(isrMask);
        RTC_RSET(RTCINTEN, temp); 
        IRQ_enable(IRQ_EVT_RTC);
}

IDEF void RTC_eventDisable(Uint16 ierMask)
{     
	Uint16 temp = RTC_RGET(RTCINTEN) & (~ierMask);
	RTC_RSET(RTCINTEN, temp);

        if ( !(RTC_RGET(RTCINTEN) & 0x70) )
            IRQ_disable(IRQ_EVT_RTC);
}


/*----------------------------------------------------------------------------*/
IDEF void RTC_start() {
  int oldgie;

  oldgie = IRQ_globalDisable(); 
    
  _RESET_B;		 /* Set bit SET in Register B to 0 */

  IRQ_globalRestore(oldgie);

}

/*----------------------------------------------------------------------------*/

IDEF void RTC_stop() {
  int oldgie;

  oldgie = IRQ_globalDisable(); 
    
  _SET_B;		 /* Set bit SET in Register B to 1 */

  IRQ_globalRestore(oldgie);

}

/*----------------------------------------------------------------------------*/

/* Changes decimal value to BCD value which is what RTC needs
 --------------------------------------------------*/
/*
RTC_decToBcd() => 16 * (dec_value / 10) + (dec_value % 10);
               => 6 * (dec_value / 10) + 10 * (dec_value / 10) + (dec_value % 10);
               => 6 * (dec_value / 10) + dec_value;
               Now (dec_value / 10) ~= (dec_value * A + B) >> C;
               For division by 10;
                  "(dec_value * 103) >> 10"  seems most optimal.
*/

IDEF int RTC_decToBcd(int dec_value)
{
    /* note: designed to work for 100 > dec_value >= 0; */
    return (dec_value + 6 * (dec_value * 103 >> 10));
}

/* RTC_bcdToDec() =>  (10 * hex_value/16) + (hex_value % 16)
                  =>  hex_value - (6* hex_value/16)
*/


IDEF int RTC_bcdToDec(int hex_value)
{
    /* note: designed to work for 0x100 > hex_value >= 0x00; */
   return (hex_value - 6 * (hex_value >> 4));

}

/*************************************************/


#endif /*USEDEFS */

#else
  #ifndef _RTC_MOD_
	#error RTC Hal Module Not Supported on Specified Target
  #endif
#endif  /* _RTC_SUPPORT  */

#endif  /* _CSL_RTCHAL_H  */

/******************************************************************************\
*
*      End of csl_rtc.h
*
\******************************************************************************/

csl_rtcdat.h/   1051539332  0     0     0       2274      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... RTC
* FILENAME...... csl_rtcdat.h
* DATE CREATED.. Thu 02/20/2001
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   MODIFIED: 10 April 2003 added reference for CSL_RtcData for .csldata size fix
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the RTC module)
*       Reserved ROM Area for RTC Data 
*
*
\******************************************************************************/
#ifndef _CSL_RTC_DATA_H_
#define _CSL_RTC_DATA_H_

  #include <csl_std.h>
  #include <csl_time.h>

  #define CSL_RTCDATAINIT\
  { "Sun","Mon","Tue","Wed","Thu","Fri","Sat",   /* day */\
    "Jan","Feb","Mar","Apr","May","Jun",         /* mon */\
    "Jul","Aug","Sep","Oct","Nov","Dec",\
     31,28,31,30,31,30,31,31,30,31,30,31,        /* mon_len */\
     0,31,59,90,120,151,181,212,243,273,304,334, /* mon_day */\
     "Sunday","Monday","Tuesday","Wednesday",    /* fday    */\
     "Thursday","Friday","Saturday",\
     "January","February","March","April","May", /* fmon    */\
     "June", "July","August","September",\
     "October","November", "December",\
     0,                                          /* daylight */\
     21600,                                      /* timezone */\
     "CST",                                      /* tzname   */\
     "DST",                                      /* dstname  */\
     0x00000000u,\
     0x00000000u,\
     0x00000000u,\
     0x00000000u,\
     0x00000000u\
  }

  

  typedef struct {
   char *day[7];
   char *mon[12];
   Uint16 mon_len[12];
   Uint16 mon_day[12];
   char *fday[7];
   char *fmon[12];
   TZ   _tz;
   Uint32 RTC_isrDispatchTable[5];
  } CSL_RtcDataObj;

extern CSL_RtcDataObj  CSL_RtcData;

#define CSL_RTC_DATA   CSL_RtcData

#endif
csl_rtchal.h/   1049976927  0     0     0       31008     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... RTC
* FILENAME...... csl_rtchal.h
* DATE CREATED.. Tue Apr 10 11:04:35 2001
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Tue Apr 10 11:04:35 2001 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION:	CSL HAL interface file for the RTC module 
*			Re-created to reflect the changes in the RTC documentation version 2.8
*
* Registers covered:
*
*	 RTCSEC		- Seconds
*	 RTCSECA		- Alarm Seconds
*	 RTCMIN		- Minutes
*	 RTCMINA		- Alarm Minutes
*	 RTCHOUR		- Hours
*	 RTCHOURA		- Alarm Hours
*	 RTCDAYW		- Day of the Week and Alarm Day of the Week
*	 RTCDAYM		- Day of month (date)
*	 RTCMONTH		- Month
*	 RTCYEAR		- Year
*	 RTCPINTR		- RTC Periodic Interrupt Selection
*	 RTCINTEN		- RTC Interrupt Enable
*	 RTCINTFL		- RTC Interrupt Flags
*
\*************************************************************************/

#ifndef _CSL_RTCHAL_H_
#define _CSL_RTCHAL_H_

#include <csl_chiphal.h>

#if (_RTC_SUPPORT) 

/*----------------------------------------------------------------*\
*	 RTC scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _RTC_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/*----------------------------------------------------------------*\
*		 Address Macros			
\*----------------------------------------------------------------*/

/*--------------------- Register: RTCSEC -----------------------*/
#define _RTC_RTCSEC_ADDR		(0x1800u)
#define _RTC_RTCSEC			PREG16(_RTC_RTCSEC_ADDR)
#define RTCSEC			_RTC_RTCSEC


/*--------------------- Register: RTCSECA -----------------------*/
#define _RTC_RTCSECA_ADDR		(0x1801u)
#define _RTC_RTCSECA			PREG16(_RTC_RTCSECA_ADDR)
#define RTCSECA			_RTC_RTCSECA


/*--------------------- Register: RTCMIN -----------------------*/
#define _RTC_RTCMIN_ADDR		(0x1802u)
#define _RTC_RTCMIN			PREG16(_RTC_RTCMIN_ADDR)
#define RTCMIN			_RTC_RTCMIN


/*--------------------- Register: RTCMINA -----------------------*/
#define _RTC_RTCMINA_ADDR		(0x1803u)
#define _RTC_RTCMINA			PREG16(_RTC_RTCMINA_ADDR)
#define RTCMINA			_RTC_RTCMINA


/*--------------------- Register: RTCHOUR -----------------------*/
#define _RTC_RTCHOUR_ADDR		(0x1804u)
#define _RTC_RTCHOUR			PREG16(_RTC_RTCHOUR_ADDR)
#define RTCHOUR			_RTC_RTCHOUR


/*--------------------- Register: RTCHOURA -----------------------*/
#define _RTC_RTCHOURA_ADDR		(0x1805u)
#define _RTC_RTCHOURA			PREG16(_RTC_RTCHOURA_ADDR)
#define RTCHOURA			_RTC_RTCHOURA


/*--------------------- Register: RTCDAYW -----------------------*/
#define _RTC_RTCDAYW_ADDR		(0x1806u)
#define _RTC_RTCDAYW			PREG16(_RTC_RTCDAYW_ADDR)
#define RTCDAYW			_RTC_RTCDAYW


/*--------------------- Register: RTCDAYM -----------------------*/
#define _RTC_RTCDAYM_ADDR		(0x1807u)
#define _RTC_RTCDAYM			PREG16(_RTC_RTCDAYM_ADDR)
#define RTCDAYM			_RTC_RTCDAYM


/*--------------------- Register: RTCMONTH -----------------------*/
#define _RTC_RTCMONTH_ADDR		(0x1808u)
#define _RTC_RTCMONTH			PREG16(_RTC_RTCMONTH_ADDR)
#define RTCMONTH			_RTC_RTCMONTH


/*--------------------- Register: RTCYEAR -----------------------*/
#define _RTC_RTCYEAR_ADDR		(0x1809u)
#define _RTC_RTCYEAR			PREG16(_RTC_RTCYEAR_ADDR)
#define RTCYEAR			_RTC_RTCYEAR


/*--------------------- Register: RTCPINTR -----------------------*/
#define _RTC_RTCPINTR_ADDR		(0x180au)
#define _RTC_RTCPINTR			PREG16(_RTC_RTCPINTR_ADDR)
#define RTCPINTR			_RTC_RTCPINTR


/*--------------------- Register: RTCINTEN -----------------------*/
#define _RTC_RTCINTEN_ADDR		(0x180bu)
#define _RTC_RTCINTEN			PREG16(_RTC_RTCINTEN_ADDR)
#define RTCINTEN			_RTC_RTCINTEN


/*--------------------- Register: RTCINTFL -----------------------*/
#define _RTC_RTCINTFL_ADDR		(0x180cu)
#define _RTC_RTCINTFL			PREG16(_RTC_RTCINTFL_ADDR)
#define RTCINTFL			_RTC_RTCINTFL



/*----------------------------------------------------------------*\
*		 Register Macros		
\*----------------------------------------------------------------*/

#define RTC_ADDR(Reg)		  _RTC_##Reg##_ADDR
#define RTC_RGET(Reg)		  _RTC_##Reg##_GET
#define RTC_RSET(Reg,Val)		  _RTC_##Reg##_SET(Val)
#define RTC_FGET(Reg,Field)		  _RTC_##Reg##_FGET(##Field)
#define RTC_FSET(Reg,Field,Val)		  _RTC_##Reg##_FSET(##Field, Val)
#define RTC_FMK(Reg,Field,Val)		  _RTC_##Reg##_##Field##_MK(Val)
#define RTC_RAOI(Reg,AND,OR,INV)		  _RTC_##Reg##_AOI(AND,OR,INV)
#define RTC_FAOI(Reg,Field,AND,OR,INV)	  _RTC_##Reg##_FAOI(##Field,AND,OR,INV)
#define RTC_FMKS(Reg,Field,Sym)\
	  _RTC_##Reg##_##Field##_MK(RTC_##Reg##_##Field##_##Sym)
#define RTC_FSETS(Reg,Field,Sym)\
	  _RTC_FSET(##Reg,##Field,RTC_##Reg##_##Field##_##Sym)

/*----------------------------------------------------------------*\
*		 Non-handle Registers Macros		
\*----------------------------------------------------------------*/


/*--------------------- Register: RTCSEC -----------------------*/
#define _RTC_RTCSEC_GET		  _PREG_GET(_RTC_RTCSEC_ADDR) 
#define _RTC_RTCSEC_SET(Val)		  _PREG_SET(_RTC_RTCSEC_ADDR,Val)
#define _RTC_RTCSEC_FGET(Field)	  _PFIELD_GET(_RTC_RTCSEC_ADDR, _RTC_RTCSEC_##Field)
#define _RTC_RTCSEC_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCSEC_ADDR, _RTC_RTCSEC_##Field, Val)
#define _RTC_RTCSEC_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCSEC_ADDR,AND,OR,INV)
#define _RTC_RTCSEC_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCSEC_ADDR, _RTC_RTCSEC_##Field,AND,OR,INV)


/*--------------------- Register: RTCSECA -----------------------*/
#define _RTC_RTCSECA_GET		  _PREG_GET(_RTC_RTCSECA_ADDR) 
#define _RTC_RTCSECA_SET(Val)		  _PREG_SET(_RTC_RTCSECA_ADDR,Val)
#define _RTC_RTCSECA_FGET(Field)	  _PFIELD_GET(_RTC_RTCSECA_ADDR, _RTC_RTCSECA_##Field)
#define _RTC_RTCSECA_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCSECA_ADDR, _RTC_RTCSECA_##Field, Val)
#define _RTC_RTCSECA_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCSECA_ADDR,AND,OR,INV)
#define _RTC_RTCSECA_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCSECA_ADDR, _RTC_RTCSECA_##Field,AND,OR,INV)


/*--------------------- Register: RTCMIN -----------------------*/
#define _RTC_RTCMIN_GET		  _PREG_GET(_RTC_RTCMIN_ADDR) 
#define _RTC_RTCMIN_SET(Val)		  _PREG_SET(_RTC_RTCMIN_ADDR,Val)
#define _RTC_RTCMIN_FGET(Field)	  _PFIELD_GET(_RTC_RTCMIN_ADDR, _RTC_RTCMIN_##Field)
#define _RTC_RTCMIN_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCMIN_ADDR, _RTC_RTCMIN_##Field, Val)
#define _RTC_RTCMIN_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCMIN_ADDR,AND,OR,INV)
#define _RTC_RTCMIN_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCMIN_ADDR, _RTC_RTCMIN_##Field,AND,OR,INV)


/*--------------------- Register: RTCMINA -----------------------*/
#define _RTC_RTCMINA_GET		  _PREG_GET(_RTC_RTCMINA_ADDR) 
#define _RTC_RTCMINA_SET(Val)		  _PREG_SET(_RTC_RTCMINA_ADDR,Val)
#define _RTC_RTCMINA_FGET(Field)	  _PFIELD_GET(_RTC_RTCMINA_ADDR, _RTC_RTCMINA_##Field)
#define _RTC_RTCMINA_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCMINA_ADDR, _RTC_RTCMINA_##Field, Val)
#define _RTC_RTCMINA_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCMINA_ADDR,AND,OR,INV)
#define _RTC_RTCMINA_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCMINA_ADDR, _RTC_RTCMINA_##Field,AND,OR,INV)


/*--------------------- Register: RTCHOUR -----------------------*/
#define _RTC_RTCHOUR_GET		  _PREG_GET(_RTC_RTCHOUR_ADDR) 
#define _RTC_RTCHOUR_SET(Val)		  _PREG_SET(_RTC_RTCHOUR_ADDR,Val)
#define _RTC_RTCHOUR_FGET(Field)	  _PFIELD_GET(_RTC_RTCHOUR_ADDR, _RTC_RTCHOUR_##Field)
#define _RTC_RTCHOUR_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCHOUR_ADDR, _RTC_RTCHOUR_##Field, Val)
#define _RTC_RTCHOUR_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCHOUR_ADDR,AND,OR,INV)
#define _RTC_RTCHOUR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCHOUR_ADDR, _RTC_RTCHOUR_##Field,AND,OR,INV)


/*--------------------- Register: RTCHOURA -----------------------*/
#define _RTC_RTCHOURA_GET		  _PREG_GET(_RTC_RTCHOURA_ADDR) 
#define _RTC_RTCHOURA_SET(Val)		  _PREG_SET(_RTC_RTCHOURA_ADDR,Val)
#define _RTC_RTCHOURA_FGET(Field)	  _PFIELD_GET(_RTC_RTCHOURA_ADDR, _RTC_RTCHOURA_##Field)
#define _RTC_RTCHOURA_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCHOURA_ADDR, _RTC_RTCHOURA_##Field, Val)
#define _RTC_RTCHOURA_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCHOURA_ADDR,AND,OR,INV)
#define _RTC_RTCHOURA_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCHOURA_ADDR, _RTC_RTCHOURA_##Field,AND,OR,INV)


/*--------------------- Register: RTCDAYW -----------------------*/
#define _RTC_RTCDAYW_GET		  _PREG_GET(_RTC_RTCDAYW_ADDR) 
#define _RTC_RTCDAYW_SET(Val)		  _PREG_SET(_RTC_RTCDAYW_ADDR,Val)
#define _RTC_RTCDAYW_FGET(Field)	  _PFIELD_GET(_RTC_RTCDAYW_ADDR, _RTC_RTCDAYW_##Field)
#define _RTC_RTCDAYW_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCDAYW_ADDR, _RTC_RTCDAYW_##Field, Val)
#define _RTC_RTCDAYW_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCDAYW_ADDR,AND,OR,INV)
#define _RTC_RTCDAYW_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCDAYW_ADDR, _RTC_RTCDAYW_##Field,AND,OR,INV)


/*--------------------- Register: RTCDAYM -----------------------*/
#define _RTC_RTCDAYM_GET		  _PREG_GET(_RTC_RTCDAYM_ADDR) 
#define _RTC_RTCDAYM_SET(Val)		  _PREG_SET(_RTC_RTCDAYM_ADDR,Val)
#define _RTC_RTCDAYM_FGET(Field)	  _PFIELD_GET(_RTC_RTCDAYM_ADDR, _RTC_RTCDAYM_##Field)
#define _RTC_RTCDAYM_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCDAYM_ADDR, _RTC_RTCDAYM_##Field, Val)
#define _RTC_RTCDAYM_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCDAYM_ADDR,AND,OR,INV)
#define _RTC_RTCDAYM_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCDAYM_ADDR, _RTC_RTCDAYM_##Field,AND,OR,INV)


/*--------------------- Register: RTCMONTH -----------------------*/
#define _RTC_RTCMONTH_GET		  _PREG_GET(_RTC_RTCMONTH_ADDR) 
#define _RTC_RTCMONTH_SET(Val)		  _PREG_SET(_RTC_RTCMONTH_ADDR,Val)
#define _RTC_RTCMONTH_FGET(Field)	  _PFIELD_GET(_RTC_RTCMONTH_ADDR, _RTC_RTCMONTH_##Field)
#define _RTC_RTCMONTH_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCMONTH_ADDR, _RTC_RTCMONTH_##Field, Val)
#define _RTC_RTCMONTH_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCMONTH_ADDR,AND,OR,INV)
#define _RTC_RTCMONTH_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCMONTH_ADDR, _RTC_RTCMONTH_##Field,AND,OR,INV)


/*--------------------- Register: RTCYEAR -----------------------*/
#define _RTC_RTCYEAR_GET		  _PREG_GET(_RTC_RTCYEAR_ADDR) 
#define _RTC_RTCYEAR_SET(Val)		  _PREG_SET(_RTC_RTCYEAR_ADDR,Val)
#define _RTC_RTCYEAR_FGET(Field)	  _PFIELD_GET(_RTC_RTCYEAR_ADDR, _RTC_RTCYEAR_##Field)
#define _RTC_RTCYEAR_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCYEAR_ADDR, _RTC_RTCYEAR_##Field, Val)
#define _RTC_RTCYEAR_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCYEAR_ADDR,AND,OR,INV)
#define _RTC_RTCYEAR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCYEAR_ADDR, _RTC_RTCYEAR_##Field,AND,OR,INV)


/*--------------------- Register: RTCPINTR -----------------------*/
#define _RTC_RTCPINTR_GET		  _PREG_GET(_RTC_RTCPINTR_ADDR) 
#define _RTC_RTCPINTR_SET(Val)		  _PREG_SET(_RTC_RTCPINTR_ADDR,Val)
#define _RTC_RTCPINTR_FGET(Field)	  _PFIELD_GET(_RTC_RTCPINTR_ADDR, _RTC_RTCPINTR_##Field)
#define _RTC_RTCPINTR_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCPINTR_ADDR, _RTC_RTCPINTR_##Field, Val)
#define _RTC_RTCPINTR_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCPINTR_ADDR,AND,OR,INV)
#define _RTC_RTCPINTR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCPINTR_ADDR, _RTC_RTCPINTR_##Field,AND,OR,INV)


/*--------------------- Register: RTCINTEN -----------------------*/
#define _RTC_RTCINTEN_GET		  _PREG_GET(_RTC_RTCINTEN_ADDR) 
#define _RTC_RTCINTEN_SET(Val)		  _PREG_SET(_RTC_RTCINTEN_ADDR,Val)
#define _RTC_RTCINTEN_FGET(Field)	  _PFIELD_GET(_RTC_RTCINTEN_ADDR, _RTC_RTCINTEN_##Field)
#define _RTC_RTCINTEN_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCINTEN_ADDR, _RTC_RTCINTEN_##Field, Val)
#define _RTC_RTCINTEN_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCINTEN_ADDR,AND,OR,INV)
#define _RTC_RTCINTEN_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCINTEN_ADDR, _RTC_RTCINTEN_##Field,AND,OR,INV)


/*--------------------- Register: RTCINTFL -----------------------*/
#define _RTC_RTCINTFL_GET		  _PREG_GET(_RTC_RTCINTFL_ADDR) 
#define _RTC_RTCINTFL_SET(Val)		  _PREG_SET(_RTC_RTCINTFL_ADDR,Val)
#define _RTC_RTCINTFL_FGET(Field)	  _PFIELD_GET(_RTC_RTCINTFL_ADDR, _RTC_RTCINTFL_##Field)
#define _RTC_RTCINTFL_FSET(Field,Val)	  _PFIELD_SET(_RTC_RTCINTFL_ADDR, _RTC_RTCINTFL_##Field, Val)
#define _RTC_RTCINTFL_AOI(AND,OR,INV)	  _PREG_AOI(_RTC_RTCINTFL_ADDR,AND,OR,INV)
#define _RTC_RTCINTFL_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_RTC_RTCINTFL_ADDR, _RTC_RTCINTFL_##Field,AND,OR,INV)



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCINTFL register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCINTFL	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCINTFL_UF	
*	(RW)   _RTC_RTCINTFL_AF	
*	(RW)   _RTC_RTCINTFL_PF	
*	(R)   _RTC_RTCINTFL_IRQF	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCINTFL_UF:	
\*----------------------------------------------------------------*/

#define _RTC_RTCINTFL_UF_SHIFT		(0x0004u)
#define _RTC_RTCINTFL_UF_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCINTFL_UF_SHIFT)
#define _RTC_RTCINTFL_UF_MASK		(_RTC_RTCINTFL_UF_MK(0x0001u))
#define _RTC_RTCINTFL_UF_CLR		(~(_RTC_RTCINTFL_UF_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCINTFL_AF:	
\*----------------------------------------------------------------*/

#define _RTC_RTCINTFL_AF_SHIFT		(0x0005u)
#define _RTC_RTCINTFL_AF_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCINTFL_AF_SHIFT)
#define _RTC_RTCINTFL_AF_MASK		(_RTC_RTCINTFL_AF_MK(0x0001u))
#define _RTC_RTCINTFL_AF_CLR		(~(_RTC_RTCINTFL_AF_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCINTFL_PF:	
\*----------------------------------------------------------------*/

#define _RTC_RTCINTFL_PF_SHIFT		(0x0006u)
#define _RTC_RTCINTFL_PF_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCINTFL_PF_SHIFT)
#define _RTC_RTCINTFL_PF_MASK		(_RTC_RTCINTFL_PF_MK(0x0001u))
#define _RTC_RTCINTFL_PF_CLR		(~(_RTC_RTCINTFL_PF_MASK))



/*----------------------------------------------------------------*\
*   (R)  _RTC_RTCINTFL_IRQF:	
\*----------------------------------------------------------------*/

#define _RTC_RTCINTFL_IRQF_SHIFT		(0x0007u)
#define _RTC_RTCINTFL_IRQF_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCINTFL_IRQF_SHIFT)
#define _RTC_RTCINTFL_IRQF_MASK		(_RTC_RTCINTFL_IRQF_MK(0x0001u))
#define _RTC_RTCINTFL_IRQF_CLR		(~(_RTC_RTCINTFL_IRQF_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCINTEN register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCINTEN	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCINTEN_TM	
*	(RW)   _RTC_RTCINTEN_UIE	
*	(RW)   _RTC_RTCINTEN_AIE	
*	(RW)   _RTC_RTCINTEN_PIE	
*	(RW)   _RTC_RTCINTEN_SET	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCINTEN_TM:	
\*----------------------------------------------------------------*/

#define _RTC_RTCINTEN_TM_SHIFT		(0x0001u)
#define _RTC_RTCINTEN_TM_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCINTEN_TM_SHIFT)
#define _RTC_RTCINTEN_TM_MASK		(_RTC_RTCINTEN_TM_MK(0x0001u))
#define _RTC_RTCINTEN_TM_CLR		(~(_RTC_RTCINTEN_TM_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCINTEN_UIE:	
\*----------------------------------------------------------------*/

#define _RTC_RTCINTEN_UIE_SHIFT		(0x0004u)
#define _RTC_RTCINTEN_UIE_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCINTEN_UIE_SHIFT)
#define _RTC_RTCINTEN_UIE_MASK		(_RTC_RTCINTEN_UIE_MK(0x0001u))
#define _RTC_RTCINTEN_UIE_CLR		(~(_RTC_RTCINTEN_UIE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCINTEN_AIE:	
\*----------------------------------------------------------------*/

#define _RTC_RTCINTEN_AIE_SHIFT		(0x0005u)
#define _RTC_RTCINTEN_AIE_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCINTEN_AIE_SHIFT)
#define _RTC_RTCINTEN_AIE_MASK		(_RTC_RTCINTEN_AIE_MK(0x0001u))
#define _RTC_RTCINTEN_AIE_CLR		(~(_RTC_RTCINTEN_AIE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCINTEN_PIE:	
\*----------------------------------------------------------------*/

#define _RTC_RTCINTEN_PIE_SHIFT		(0x0006u)
#define _RTC_RTCINTEN_PIE_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCINTEN_PIE_SHIFT)
#define _RTC_RTCINTEN_PIE_MASK		(_RTC_RTCINTEN_PIE_MK(0x0001u))
#define _RTC_RTCINTEN_PIE_CLR		(~(_RTC_RTCINTEN_PIE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCINTEN_SET:	
\*----------------------------------------------------------------*/

#define _RTC_RTCINTEN_SET_SHIFT		(0x0007u)
#define _RTC_RTCINTEN_SET_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCINTEN_SET_SHIFT)
#define _RTC_RTCINTEN_SET_MASK		(_RTC_RTCINTEN_SET_MK(0x0001u))
#define _RTC_RTCINTEN_SET_CLR		(~(_RTC_RTCINTEN_SET_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCDAYM register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCDAYM	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCDAYM_DATE	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCDAYM_DATE:	
\*----------------------------------------------------------------*/

#define _RTC_RTCDAYM_DATE_SHIFT		(000000u)
#define _RTC_RTCDAYM_DATE_MK(n)		(((Uint16)(n) & 0x003fu) << _RTC_RTCDAYM_DATE_SHIFT)
#define _RTC_RTCDAYM_DATE_MASK		(_RTC_RTCDAYM_DATE_MK(0x003fu))
#define _RTC_RTCDAYM_DATE_CLR		(~(_RTC_RTCDAYM_DATE_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCSECA register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCSECA	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCSECA_SAR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCSECA_SAR:	
\*----------------------------------------------------------------*/

#define _RTC_RTCSECA_SAR_SHIFT		(000000u)
#define _RTC_RTCSECA_SAR_MK(n)		(((Uint16)(n) & 0x00ffu) << _RTC_RTCSECA_SAR_SHIFT)
#define _RTC_RTCSECA_SAR_MASK		(_RTC_RTCSECA_SAR_MK(0x00ffu))
#define _RTC_RTCSECA_SAR_CLR		(~(_RTC_RTCSECA_SAR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCYEAR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCYEAR	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCYEAR_YEAR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCYEAR_YEAR:	
\*----------------------------------------------------------------*/

#define _RTC_RTCYEAR_YEAR_SHIFT		(000000u)
#define _RTC_RTCYEAR_YEAR_MK(n)		(((Uint16)(n) & 0x00ffu) << _RTC_RTCYEAR_YEAR_SHIFT)
#define _RTC_RTCYEAR_YEAR_MASK		(_RTC_RTCYEAR_YEAR_MK(0x00ffu))
#define _RTC_RTCYEAR_YEAR_CLR		(~(_RTC_RTCYEAR_YEAR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCHOUR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCHOUR	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCHOUR_HR	
*	(RW)   _RTC_RTCHOUR_AMPM	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCHOUR_HR:	
\*----------------------------------------------------------------*/

#define _RTC_RTCHOUR_HR_SHIFT		(000000u)
#define _RTC_RTCHOUR_HR_MK(n)		(((Uint16)(n) & 0x003fu) << _RTC_RTCHOUR_HR_SHIFT)
#define _RTC_RTCHOUR_HR_MASK		(_RTC_RTCHOUR_HR_MK(0x003fu))
#define _RTC_RTCHOUR_HR_CLR		(~(_RTC_RTCHOUR_HR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCHOUR_AMPM:	
\*----------------------------------------------------------------*/

#define _RTC_RTCHOUR_AMPM_SHIFT		(0x0007u)
#define _RTC_RTCHOUR_AMPM_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCHOUR_AMPM_SHIFT)
#define _RTC_RTCHOUR_AMPM_MASK		(_RTC_RTCHOUR_AMPM_MK(0x0001u))
#define _RTC_RTCHOUR_AMPM_CLR		(~(_RTC_RTCHOUR_AMPM_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCMINA register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCMINA	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCMINA_MAR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCMINA_MAR:	
\*----------------------------------------------------------------*/

#define _RTC_RTCMINA_MAR_SHIFT		(000000u)
#define _RTC_RTCMINA_MAR_MK(n)		(((Uint16)(n) & 0x00ffu) << _RTC_RTCMINA_MAR_SHIFT)
#define _RTC_RTCMINA_MAR_MASK		(_RTC_RTCMINA_MAR_MK(0x00ffu))
#define _RTC_RTCMINA_MAR_CLR		(~(_RTC_RTCMINA_MAR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCDAYW register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCDAYW	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCDAYW_DAY	
*	(RW)   _RTC_RTCDAYW_DAEN	
*	(RW)   _RTC_RTCDAYW_DAR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCDAYW_DAY:	
\*----------------------------------------------------------------*/

#define _RTC_RTCDAYW_DAY_SHIFT		(000000u)
#define _RTC_RTCDAYW_DAY_MK(n)		(((Uint16)(n) & 0x0007u) << _RTC_RTCDAYW_DAY_SHIFT)
#define _RTC_RTCDAYW_DAY_MASK		(_RTC_RTCDAYW_DAY_MK(0x0007u))
#define _RTC_RTCDAYW_DAY_CLR		(~(_RTC_RTCDAYW_DAY_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCDAYW_DAEN:	
\*----------------------------------------------------------------*/

#define _RTC_RTCDAYW_DAEN_SHIFT		(0x0003u)
#define _RTC_RTCDAYW_DAEN_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCDAYW_DAEN_SHIFT)
#define _RTC_RTCDAYW_DAEN_MASK		(_RTC_RTCDAYW_DAEN_MK(0x0001u))
#define _RTC_RTCDAYW_DAEN_CLR		(~(_RTC_RTCDAYW_DAEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCDAYW_DAR:	
\*----------------------------------------------------------------*/

#define _RTC_RTCDAYW_DAR_SHIFT		(0x0004u)
#define _RTC_RTCDAYW_DAR_MK(n)		(((Uint16)(n) & 0x000fu) << _RTC_RTCDAYW_DAR_SHIFT)
#define _RTC_RTCDAYW_DAR_MASK		(_RTC_RTCDAYW_DAR_MK(0x000fu))
#define _RTC_RTCDAYW_DAR_CLR		(~(_RTC_RTCDAYW_DAR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCSEC register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCSEC	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCSEC_SEC	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCSEC_SEC:	
\*----------------------------------------------------------------*/

#define _RTC_RTCSEC_SEC_SHIFT		(000000u)
#define _RTC_RTCSEC_SEC_MK(n)		(((Uint16)(n) & 0x007fu) << _RTC_RTCSEC_SEC_SHIFT)
#define _RTC_RTCSEC_SEC_MASK		(_RTC_RTCSEC_SEC_MK(0x007fu))
#define _RTC_RTCSEC_SEC_CLR		(~(_RTC_RTCSEC_SEC_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCMIN register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCMIN	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCMIN_MIN	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCMIN_MIN:	
\*----------------------------------------------------------------*/

#define _RTC_RTCMIN_MIN_SHIFT		(000000u)
#define _RTC_RTCMIN_MIN_MK(n)		(((Uint16)(n) & 0x007fu) << _RTC_RTCMIN_MIN_SHIFT)
#define _RTC_RTCMIN_MIN_MASK		(_RTC_RTCMIN_MIN_MK(0x007fu))
#define _RTC_RTCMIN_MIN_CLR		(~(_RTC_RTCMIN_MIN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCMONTH register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCMONTH	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCMONTH_MONTH	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCMONTH_MONTH:	
\*----------------------------------------------------------------*/

#define _RTC_RTCMONTH_MONTH_SHIFT		(000000u)
#define _RTC_RTCMONTH_MONTH_MK(n)		(((Uint16)(n) & 0x001fu) << _RTC_RTCMONTH_MONTH_SHIFT)
#define _RTC_RTCMONTH_MONTH_MASK		(_RTC_RTCMONTH_MONTH_MK(0x001fu))
#define _RTC_RTCMONTH_MONTH_CLR		(~(_RTC_RTCMONTH_MONTH_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCPINTR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCPINTR	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCPINTR_RS	
*	(R)   _RTC_RTCPINTR_UIP	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCPINTR_RS:	
\*----------------------------------------------------------------*/

#define _RTC_RTCPINTR_RS_SHIFT		(000000u)
#define _RTC_RTCPINTR_RS_MK(n)		(((Uint16)(n) & 0x001fu) << _RTC_RTCPINTR_RS_SHIFT)
#define _RTC_RTCPINTR_RS_MASK		(_RTC_RTCPINTR_RS_MK(0x001fu))
#define _RTC_RTCPINTR_RS_CLR		(~(_RTC_RTCPINTR_RS_MASK))



/*----------------------------------------------------------------*\
*   (R)  _RTC_RTCPINTR_UIP:	
\*----------------------------------------------------------------*/

#define _RTC_RTCPINTR_UIP_SHIFT		(0x0007u)
#define _RTC_RTCPINTR_UIP_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCPINTR_UIP_SHIFT)
#define _RTC_RTCPINTR_UIP_MASK		(_RTC_RTCPINTR_UIP_MK(0x0001u))
#define _RTC_RTCPINTR_UIP_CLR		(~(_RTC_RTCPINTR_UIP_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the RTCHOURA register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _RTC_RTCHOURA	 - Note: Add description here
*
* Fields:
*	(RW)   _RTC_RTCHOURA_HAR	
*	(RW)   _RTC_RTCHOURA_AMPM	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCHOURA_HAR:	
\*----------------------------------------------------------------*/

#define _RTC_RTCHOURA_HAR_SHIFT		(000000u)
#define _RTC_RTCHOURA_HAR_MK(n)		(((Uint16)(n) & 0x007fu) << _RTC_RTCHOURA_HAR_SHIFT)
#define _RTC_RTCHOURA_HAR_MASK		(_RTC_RTCHOURA_HAR_MK(0x007fu))
#define _RTC_RTCHOURA_HAR_CLR		(~(_RTC_RTCHOURA_HAR_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _RTC_RTCHOURA_AMPM:	
\*----------------------------------------------------------------*/

#define _RTC_RTCHOURA_AMPM_SHIFT		(0x0007u)
#define _RTC_RTCHOURA_AMPM_MK(n)		(((Uint16)(n) & 0x0001u) << _RTC_RTCHOURA_AMPM_SHIFT)
#define _RTC_RTCHOURA_AMPM_MASK		(_RTC_RTCHOURA_AMPM_MK(0x0001u))
#define _RTC_RTCHOURA_AMPM_CLR		(~(_RTC_RTCHOURA_AMPM_MASK))


#else
   #ifndef _RTC_MOD_
	#error RTC Hal Module Not Supported on Specified Target
   #endif
#endif  /* _RTC_SUPPORT  */

#endif  /* _CSL_RTCHAL_H  */

/******************************************************************************\
*     
*      End of csl_rtchal.h 
*
\******************************************************************************/
csl_std.h/      1049976928  0     0     0       5756      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE.NAME... HCFG - HAL configuration module
* FILENAME...... csl_std.h
* DATE CREATED.. 03/11/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* IMPORTS....... 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       03/11/1999 
*   MODIFIED:      05/04/1999 modified for c54x
*   MODIFIED:      06/19/2000
*   MODIFIED:      07/13/2000 modified for c5510
*   LAST MODIFIED: 03/23/2001 modified to redefine type that conflict with BIOS
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments
*------------------------------------------------------------------------------
* DESCRIPTION:  (CHIP memory mapped register definitions)
*
*
*
\******************************************************************************/


#ifndef _CSL_STDINC_H_
#define _CSL_STDINC_H_

/****************************************\
* STDINC macro declarations
\****************************************/

#ifndef TRUE
#define TRUE   ((CSLBool)(1))
#endif
#ifndef FALSE
#define FALSE  ((CSLBool)(0))
#endif
#define YES    ((CSLBool)(1))
#define NO     ((CSLBool)(0))

/* invalid pointer */
#define INV    ((void*)(-1))

/* useful macros for declaring peripheral registers */

#define REG16(addr)		(*(volatile Uint16*)(addr))

/****************************************\
* STDINC macrso for enabling/disabling   
* interrupts
\****************************************/

#define ENABLE_INTERRUPTS\
 { asm("\t BIT(ST1, #ST1_INTM) = #0 ;====> CODE AUTO-GENERATED by CSL");\
 }
#define DISABLE_INTERRUPTS\
 { asm("\t BIT(St1, #ST1_INTM) = #1 ;====> CODE AUTO-GENERATED by CSL");\
 }


/****************************************\
* STDINC typedef declarations
\****************************************/

typedef unsigned char	Uchar;
typedef unsigned short	Uint16;
typedef unsigned long 	Uint32;
typedef short		Int16;
typedef long		Int32;
typedef void *          Handle;

/* BIOS already has Def of Bool, Char, Int , Uint */

typedef unsigned short  CSLBool;
typedef int  CSLInt;
typedef char CSLChar;
typedef unsigned int CSLUint;






/****************************************\
* STDINC variable declarations
\****************************************/
// Note in Large Model CSL_DATA_PTR takes up location 7A & 7B

#define CSL_DATA_PTR		   (0x007au)

/****************************************\
* STDINC generic macro declarations
\****************************************/
  #define _CHIP_PERBASE_ADDR      (0x0000u)

 /*============================================================================*\
 * register bit manipulation macros
 \*============================================================================*/

  /* memory mapped register macros */
  #define _FIELD_GET(RegAddr,FIELD) (Uint16)( \
  (REG16(RegAddr)&##FIELD##_MASK)>>##FIELD##_SHIFT \
  ) 

  #define _FIELD_SET(RegAddr,FIELD,Val) REG16(RegAddr)=(Uint16)( \
  (REG16(RegAddr)&##FIELD##_CLR)| \
  ((Uint16)##FIELD##_MK(Val)) \
  )

  #define _FIELD_SHIFT(FIELD,Val) \
  ((Uint16)##FIELD##_MK(Val))

  #define _REG32_GET(RegAddr) \
  (Uint32)Reg32(RegAddr)

  #define _REG_GET(RegAddr) \
  (Uint16)REG16(RegAddr)

  #define _REG32_SET(RegAddr,Val) \
   Reg32(RegAddr)=(Uint32)(Val)
  
  #define _REG_SET(RegAddr,Val) \
   REG16(RegAddr)=(Uint16)(Val)

  /*============================================================================*\
  * Peripheral Register bit manipulation macros
  \*============================================================================*/
  #define _PFIELD_GET(PregAddr,FIELD) (Uint16)( \
  (PREG16(PregAddr)&##FIELD##_MASK)>>##FIELD##_SHIFT \
  ) 

  #define _PFIELD_SET(PregAddr,FIELD,Val) PREG16(PregAddr)=(Uint16)( \
  (PREG16(PregAddr)&##FIELD##_CLR)| \
  ((Uint16)##FIELD##_MK(Val)) \
  )

  #define _PFIELD_AOI(PregAddr,FIELD,AND,OR,INV) PREG16(PregAddr)=(Uint16)( \
  ((PREG16(PregAddr)& ##FIELD##_CLR)| ((((PREG16(PregAddr) & ##FIELD##_MASK) & AND) | OR) ^ INV))\
  )

  /*============================================================================*\
  * Peripheral register read/write macros
  \*============================================================================*/
  #define _PREG_SET(PregAddr, Val)               PREG16(PregAddr) = (Uint16)Val
  #define _PREG_AOI(PregAddr,AND,OR,INV)\
     PREG16(PregAddr) = (((PREG16(PregAddr) & AND) | OR ) ^ INV)

  #define _PREG_GET(PregAddr)                    PREG16(PregAddr)

  #define _PREG32_SET(PregAddr, Val)             PREG32(PregAddr) = (Uint32)Val
  #define _PREG32_AOI(PregAddr,AND,OR,INV)\
     PREG32(PregAddr) = (((PREG32(PregAddr) & AND) | OR ) ^ INV)

  #define _PREG32_GET(PregAddr)                    PREG32(PregAddr)


 /*===========================================================================*\
 * control register macros 
 \*===========================================================================*/

  #define _CRFIELD_GET(RegAddr,FIELD) (Uint16)( \
    (REG16(RegAddr)&##FIELD##_MASK)>>##FIELD##_SHIFT \
  )  

  #define _CRFIELD_SET(RegAddr,FIELD,Val) REG16(RegAddr)=(Uint16)( \
  (REG16(RegAddr)& ##FIELD##_CLR)| \
  (((Uint16) ##FIELD##_MK(Val)) \
  )


#endif
/******************************************************************************\
* End of csl_stdinc.h
\******************************************************************************/

csl_stdhal.h/   1049976930  0     0     0       3676      `
/******************************************************************************\ *           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------ 
* MODULE NAME... STDINC - standard include module
* FILENAME...... csl_stdhal.h
* DATE CREATED.. Thu 03/11/1999
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. none
*------------------------------------------------------------------------------ 
* HISTORY:
*   CREATED:       03/11/1999 Created
*   MODIFIED:      11/23/1999 Modified for TMS320C54xx
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the STDINC module)
*
*
*
\******************************************************************************/
#ifndef _STDINCHAL_H_
#define _STDINCHAL_H_

/****************************************\
* HSTDINC scope and inline control macros
\****************************************/
#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#define IDECL static inline
#define USEDEFS
#define IDEF  static inline

/****************************************\
* HSTDINC global macro declarations
\****************************************/
#define UNREFERENCED_PARAMETER(P)    ((P)=(P))


/*============================================================================*\
* register referencing macros
\*============================================================================*/


/*------------------------------------------------------------------------*\
 * PREG - peripheral control registers, These are alllocated in I/O space 
\*------------------------------------------------------------------------*/
#define PREG8(addr)  (*(volatile ioport Uint8*)(addr))
#define PREG16(addr) (*(volatile ioport Uint16*)(addr))
#define PREG32(addr) (*(volatile ioport Uint32*)(addr))
#define Preg16Ptr    (volatile ioport Uint16 *)

/*------------------------------------------------------------------------*\
 * Memory-mapped register, located in normal (data/program) space 
\*------------------------------------------------------------------------*/
#define REG8(addr)  (*(volatile Uint8*)(addr))
#define REG16(addr) (*(volatile Uint16*)(addr))
#define REG32(addr) (*(volatile Uint32*)(addr))
#define Reg16Ptr    (volatile Uint16 *)




/****************************************\
* HSTDINC global typedef declarations
\****************************************/

/****************************************\
* HSTDINC global variable declarations
\****************************************/

/****************************************\
* HSTDINC global function declarations
\****************************************/

/****************************************\
* HSTDINC inline function declarations
\****************************************/

/****************************************\
* HSTDINC inline function definitions
\****************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */

#endif /* _STDINCHAL_H_ */
/******************************************************************************\
* End of stdinchal.h
\******************************************************************************/

csl_timdat.h/   1051539331  0     0     0       2047      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... TIMER
* FILENAME...... csl_timdat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       03/30/2000
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments 
*   MODIFIED:      10 Apr 2003 Added CSL_TimerData reference for .csldata size fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the TIMER module)
*       Reserved Area for TIMER Data 
*
*
\******************************************************************************/
#ifndef _TIMER_DATA_H_
#define _TIMER_DATA_H_

#include <csl_std.h>

#define TIMER_DEVICE_CNT           2

#define CSL_TIMERDATAINIT\
{/*Timer #0 Handle Initialization Data*/\
  0x0000u,  /*TIMER0_Timer*/\
  0x0004u,  /*TIMER0_EventId*/\
  0x1002u,  /*TIMER0_TcrAddr*/\
  0x1001u,  /*TIMER0_PrdAddr*/\
  0x1000u,  /*TIMER0_TimAddr*/\
  0x1003u,  /*TIMER0_PrscAddr*/\
/* Timer #1 Handle Initialization Data*/\
  0x0001u,  /*TIMER1_Timer*/\
  0x0016u,  /*TIMER1_EventId*/\
  0x2402u,  /*TIMER1_TcrAddr*/\
  0x2401u,  /*TIMER1_PrdAddr*/\
  0x2400u,  /*TIMER1_TimAddr*/\
  0x2403u  /*TIMER1_PrscAddr*/\
}

/* private object, not to be used by application code */
typedef struct {
  Uint16  Timer;
  Uint16  EventId;
  Uint16  TcrAddr;
  Uint16  PrdAddr;
  Uint16  TimAddr;
  Uint16  PrscAddr;
} TIMER_PrivateObj;

typedef struct {
  TIMER_PrivateObj Timer[TIMER_DEVICE_CNT];
} CSL_TimerDataObj;

extern CSL_TimerDataObj  CSL_TimerData;

#define CSL_TIMER_DATA   CSL_TimerData

#endif

csl_time.h/     1049976933  0     0     0       3523      `
/****************************************************************************\
*           Copyright (C) 1999-2001 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... RTC
* FILENAME...... csl_time.h
* DATE CREATED.. Fri Mar 30 2001
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Fri Mar 30 2001 ()
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Time Functions for the RTC module 
*
\*************************************************************************/

#ifndef _CSL_TIME
#define _CSL_TIME

#include <linkage.h> 
 


#ifndef NULL
#define NULL      0
#endif

#ifdef __cplusplus
extern "C" namespace std {
#endif

typedef unsigned long time_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif /* ! _SIZE_T */

struct tm 
{
    int tm_sec;      /* seconds after the minute   - [0,59]  */
    int tm_min;      /* minutes after the hour     - [0,59]  */
    int tm_hour;     /* hours after the midnight   - [0,23]  */
    int tm_mday;     /* day of the month           - [1,31]  */
    int tm_mon;      /* months since January       - [0,11]  */
    int tm_year;     /* years since 1900                     */
    int tm_wday;     /* days since Sunday          - [0,6]   */
    int tm_yday;     /* days since Jan 1st         - [0,365] */
    int tm_isdst;    /* Daylight Savings Time flag           */
};

/*************************************************************************/
/* TIME ZONE STRUCTURE DEFINITION                                        */
/*************************************************************************/
typedef struct 
{
    short daylight;
    long  timezone;
    char  tzname[4];
    char  dstname[4];
} TZ;

extern _DATA_ACCESS TZ _tz;

/****************************************************************************/
/* FUNCTION DECLARATIONS.  (NOTE : clock AND time ARE SYSTEM SPECIFIC)      */
/****************************************************************************/
_CODE_ACCESS time_t     RTC_time(time_t *_timer);     
 
_CODE_ACCESS time_t     RTC_mktime(struct tm *_tptr);
_CODE_ACCESS double     RTC_difftime(time_t _time1, time_t _time0);
      _IDECL char      *RTC_ctime(const time_t *_timer);
_CODE_ACCESS char      *RTC_asctime(const struct tm *_timeptr);
_CODE_ACCESS struct tm *RTC_gmtime(const time_t *_timer);
_CODE_ACCESS struct tm *RTC_localtime(const time_t *_timer);
_CODE_ACCESS size_t     RTC_strftime(char *_out, size_t _maxsize, 
				 const char *_format,
				 const struct tm *_timeptr);

#if defined(_INLINE) || defined(_CTIME_)

_IDEFN char *RTC_ctime(const time_t *timer)
{
   return(RTC_asctime(RTC_localtime(timer)));
}

#endif /* _INLINE || _CTIME_ */

#ifdef __cplusplus
} /* extern "C" */

#ifndef _CPP_STYLE_HEADER
using std::time_t;
using std::size_t;
using std::tm;
using std::TZ;
using std::_tz;
using std::RTC_time;
using std::RTC_mktime;
using std::RTC_difftime;
using std::RTC_ctime;
using std::RTC_asctime;
using std::RTC_gmtime;
using std::RTC_localtime;
using std::RTC_strftime;
#endif /* ! _CPP_STYLE_HEADER */

#endif /* __cplusplus */
 
 
#endif /* _TIME */


csl_timer.h/    1049976934  0     0     0       18898     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... CSL_TIMER
* FILENAME...... csl_timer.h
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... service layer
* PREREQUISITE.. csl_timhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:  06/20/1999 Created for C6x.  
*   MODIFIED: 2/06/2000 Modification for C54x.
*   MODIFIED: 05/30/2000 C55x Version
*   MODIFIED: 07/13/2000 Final Version for C55x
*   MODIFIED: 04/16/2001 updated header comments
*   MODIFIED: 05/11/2001 updated for TIMER_getConfig()
*   MODIFIED: 06/28/2001 updated for new CSL initialization model
*   MODIFIED: 05/07/2002 Added TIMER_Private typedef to support
*                        C++ strict typing of TIMER_Handle
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the TIMER module)
\******************************************************************************/
#ifndef _CSL_TIMER_H_
#define _CSL_TIMER_H_

#include <csl.h>
#include <csl_timhal.h>


#if (_TIMER_SUPPORT)
/****************************************\
* TIMER scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _TIMER_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif
/****************************************\
* TIMER global macro declarations
\****************************************/ 

/* TIMER_Open() flags */
#define TIMER_OPEN_RESET           (0x0001)
#define TIMER_OPEN_BIOS            (0x8000)

/* error codes */
#define TIMER_ERR_MAJOR            (ERR_BASE_TIMER) 
#define TIMER_ERR_ALLOC            (0x00000000)
#define TIMER_ERR_INVALID_HANDLE   (0x00000001)

/* device identifiers for TIMER_Open() */
#define TIMER_DEV_ANY  (-1)
#define TIMER_DEV0    (0)
#define TIMER_DEV1    (1)  


/*******************************************\
* TIMER global macro definition : ROMABILITY
\*******************************************/ 
/* Reserved ROM Area for timerData.h */
/* Data definition */   

/* Predefined Device Handlers */
#define TIMER_hDev0   ((TIMER_Handle)(&(CSL_TIMER_DATA.Timer[0])))
#define TIMER_hDev1   ((TIMER_Handle)(&(CSL_TIMER_DATA.Timer[1])))
#define TIMER_hDev(n) ((TIMER_Handle)(&(CSL_TIMER_DATA.Timer[n])))


/*-----------------------------------------------------------------------*/
/* The following macros are used to construct peripheral register        */
/* values based on symbolic constants. They will be useful to initialize */
/* the TIMER_Config structure in a readable way.                         */
/*-----------------------------------------------------------------------*/

/*===========================================================================*\
* HTIMER_TIM0    - Timer Register, Timer #0
* HTIMER_TIM1    - Timer Register, Timer #1
*
* Fields:
*  (RW) TIM
\*===========================================================================*/

/*===========================================================================*\
* TIMER_TIM_DEFAULT Values
\*===========================================================================*/

/* default TIM register value */
#define TIMER_TIM_DEFAULT                 (0xFFFF)

/* TIM field values */
#define TIMER_TIM_TIM_OF(x)              ((Uint16)(x))

/*===========================================================================*\
* TIMER_TIM_MK
\*===========================================================================*/

/* make TIM register value based on symbolic constants */

#define TIMER_TIM_RMK(tim) \
 ((Uint16) (TIMER_FMK(TIM,TIM,tim))\
)  

#define TIMER_TIM_RMKS(tim_s) \
 ((Uint16) (TIMER_FMKS(TIM,TIM,tim_s))\
)  

/*===========================================================================*\
* HTIMER_PRD0    - Period Register, Timer #0
* HTIMER_PRD1    - Period Register, Timer #1
*
* Fields:
*  (RW) PRD
\*===========================================================================*/

/*===========================================================================*\
* TIMER_PRD_DEFAULT Values
\*===========================================================================*/

/* default PRD register value */
#define TIMER_PRD_DEFAULT                 (0xFFFF)

/* PRD field values */
#define TIMER_PRD_PRD_OF(x)              ((Uint16)(x))

/*===========================================================================*\
* TIMER_PRD_MK
\*===========================================================================*/

/* make PRD register value based on symbolic constants */

#define TIMER_PRD_RMK(prd) \
 ((Uint16) (TIMER_FMK(PRD,PRD,prd))\
) 

#define TIMER_PRD_RMKS(prd_s) \
 ((Uint16) (TIMER_FMK(PRD,PRD,prd_s))\
)  
 
/*===========================================================================*\
* HTIMER_TCR0    - Control Register, Timer #0
* HTIMER_TCR1    - Control Register, Timer #1
*
* Fields:
*  (RW) IDLEEN
*  (R)  INTEXT
*  (R)  ERRTIM
*  (RW) FUNC
*  (RW) TLB
*  (RW) SOFT
*  (RW) FREE
*  (RW) PWID
*  (RW) ARB
*  (RW) TSS
*  (RW) CP
*  (RW) POLAR
*  (RW) DATOUT
\*===========================================================================*/

/*===========================================================================*\
* TIMER_TCR_DEFAULT Values
\*===========================================================================*/

/* default TCR register value */
#define TIMER_TCR_DEFAULT                 (0x0010)

/* TCR field values */
#define TIMER_TCR_IDLEEN_ENABLE           (0x0001u)
#define TIMER_TCR_IDLEEN_DISABLE          (0x0000u)
#define TIMER_TCR_IDLEEN_DEFAULT          TIMER_TCR_IDLEEN_DISABLE

#define TIMER_TCR_FUNC_OF(x)              ((Uint16)(x))
#define TIMER_TCR_FUNC_DEFAULT            TIMER_TCR_FUNC_OF(0)

#define TIMER_TCR_TLB_RESET		      (0x0001)
#define TIMER_TCR_TLB_NORESET      		(0x0000)
#define TIMER_TCR_TLB_DEFAULT             TIMER_TCR_TLB_NORESET      


#define TIMER_TCR_SOFT_BRKPTNOW           (0x0000)
#define TIMER_TCR_SOFT_WAITZERO           (0x0001)
#define TIMER_TCR_SOFT_DEFAULT            TIMER_TCR_SOFT_BRKPTNOW     
      
#define TIMER_TCR_FREE_WITHSOFT           (0x0000)
#define TIMER_TCR_FREE_NOSOFT             (0x0001)
#define TIMER_TCR_FREE_DEFAULT            TIMER_TCR_FREE_WITHSOFT           

#define TIMER_TCR_PWID_OF(x)              ((Uint16)(x))
#define TIMER_TCR_PWID_DEFAULT            TIMER_TCR_PWID_OF(0)              

#define TIMER_TCR_ARB_RESET               (0x0001)
#define TIMER_TCR_ARB_NORESET             (0x0000)
#define TIMER_TCR_ARB_DEFAULT             TIMER_TCR_ARB_NORESET             

#define TIMER_TCR_TSS_START               (0x0000)
#define TIMER_TCR_TSS_STOP                (0x0001)
#define TIMER_TCR_TSS_DEFAULT             TIMER_TCR_TSS_STOP                (0x0001)

#define TIMER_TCR_CP_PULSE                (0x0000)
#define TIMER_TCR_CP_CLOCK                (0x0001)
#define TIMER_TCR_CP_DEFAULT              TIMER_TCR_CP_PULSE                

#define TIMER_TCR_POLAR_LOW               (0x0000)
#define TIMER_TCR_POLAR_HIGH              (0x0001)
#define TIMER_TCR_POLAR_DEFAULT           TIMER_TCR_POLAR_LOW               

#define TIMER_TCR_DATOUT_0                (0x0000)
#define TIMER_TCR_DATOUT_1                (0x0001)
#define TIMER_TCR_DATOUT_DEFAULT          TIMER_TCR_DATOUT_0                



/*===========================================================================*\
* TIMER_TCR_MK
\*===========================================================================*/

/* make TCR register value based on symbolic constants */

#define TIMER_TCR_RMK(idleen,func,tlb,soft,free,pwid,arb,tss,cp,polar,datout) \
 ((Uint16) ( \
  (TIMER_FMK(TCR,IDLEEN,idleen))|\
  (TIMER_FMK(TCR,FUNC,func))|\
  (TIMER_FMK(TCR,TLB,tlb))|\
  (TIMER_FMK(TCR,SOFT,soft))|\
  (TIMER_FMK(TCR,FREE,free))|\
  (TIMER_FMK(TCR,PWID,pwid))|\
  (TIMER_FMK(TCR,ARB,arb))|\
  (TIMER_FMK(TCR,TSS,tss))|\
  (TIMER_FMK(TCR,CP,cp))|\
  (TIMER_FMK(TCR,POLAR,polar))|\
  (TIMER_FMK(TCR,DATOUT,datout))\
  )\
) 

#define TIMER_TCR_RMKS(idleen_s,func_s,tlb_s,soft_s,free_s,pwid_s,arb_s,tss_s,\
  cp_s,polar_s,datout_s) \
 ((Uint16) ( \
  (TIMER_FMKS(TCR,IDLEEN,idleen_s))|\
  (TIMER_FMKS(TCR,FUNC,func_s))|\
  (TIMER_FMKS(TCR,TLB,tlb_s))|\
  (TIMER_FMKS(TCR,SOFT,soft_s))|\
  (TIMER_FMKS(TCR,FREE,free_s))|\
  (TIMER_FMKS(TCR,PWID,pwid_s))|\
  (TIMER_FMKS(TCR,ARB,arb_s))|\
  (TIMER_FMKS(TCR,TSS,tss_s))|\
  (TIMER_FMKS(TCR,CP,cp_s))|\
  (TIMER_FMKS(TCR,POLAR,polar_s))|\
  (TIMER_FMKS(TCR,DATOUT,datout_s))\
  )\
)  
 
/*===========================================================================*\
* HTIMER_PRSC0    - Prescaler Register, Timer #0
* HTIMER_PRSC1    - Prescaler Register, Timer #1
*
* Fields:
*  (RW) TDDR
*  (RW) PSC
\*===========================================================================*/

/*===========================================================================*\
* TIMER_PRSC_DEFAULT Values
\*===========================================================================*/

/* default PRSC register value */
#define TIMER_PRSC_DEFAULT                 (0x0000)

/* TCR field values */
#define TIMER_PRSC_PSC_OF(x)               ((Uint16)(x))
#define TIMER_PRSC_TDDR_0F(x)		       ((Uint16)(x))

/*===========================================================================*\
* TIMER_PRSC_MK
\*===========================================================================*/

/* make PRSC register value based on symbolic constants */

#define TIMER_PRSC_RMK(psc,tddr) \
 ((Uint16) ( \
  ( TIMER_FMK(PRSC,PSC,psc))|\
  ( TIMER_FMK(PRSC,TDDR,tddr))\
  )\
)  

#define TIMER_PRSC_RMKS(psc_s,tddr_s) \
 ((Uint16) ( \
  ( TIMER_FMKS(PRSC,PSC,psc_s))|\
  ( TIMER_FMKS(PRSC,TDDR,tddr_s))|\
  )\
)  

/*******************************************/
/* Define a debuging assertion macro */ 
/* for validating device handles */
#ifdef _MCRTE_DEBUG
  #define TIMER_ASSERT_HANDLE(hTimer,RetExp) \
    if (hTimer == INV) { \
      ERR_submit(TIMER_ERR_MAJOR, TIMER_ERR_INVALID_HANDLE); \
      RetExp; \
    }
#else
  #define TIMER_ASSERT_HANDLE(hTimer,RetExp)
#endif


/* make CLKMD register value based on symbolic constants */

#define TIMER_CLKMD_RMK(pllndiv, pllonoff, pllcount, plldiv, pllmul)\
  ((Uint16) (   TIMER_FMK(CLKMD,PLLNDIV,pllndiv)    |\
                TIMER_FMK(CLKMD,PLLONOFF,pllonoff)  |\
                TIMER_FMK(CLKMD,PLLDIV,plldiv)      |\
                TIMER_FMK(CLKMD,PLLMUL,pllmul)\
           )\
  )

#define TIMER_CLKMD_RMKS(pllndiv_s, pllonoff_s, pllcount_s, plldiv_s, pllmul_s)\
  ((Uint16) (   TIMER_FMKS(CLKMD,PLLNDIV,pllndiv_s)    |\
                TIMER_FMKS(CLKMD,PLLONOFF,pllonoff_s)  |\
                TIMER_FMKS(CLKMD,PLLDIV,plldiv_s)      |\
                TIMER_FMKS(CLKMD,PLLMUL,pllmul_s)\
           )\
  )

/* Default CLKMD register values                         */

#define TIMER_CLKMD_DEFAULT               (0x0000u)

#define TIMER_CLKMD_PLLNDIV_OFF           (0x0000u)
#define TIMER_CLKMD_PLLNDIV_ON            (0x0001u)

#define TIMER_CLKMD_PLLONOFF_OFF          (0x0000u)
#define TIMER_CLKMD_PLLONOFF_ON           (0x0001u)

#define TIMER_CLKMD_PLLCOUNT_OF(x)        ((Uint16)x)

#define TIMER_CLKMD_PLLDIV_OFF            (0x0000u)
#define TIMER_CLKMD_PLLDIV_ON             (0x0001u)

#define TIMER_CLKMD_PLLMUL_OF(x)          ((Uint16)x)



#define TIMER_getEventId(hTimer) (\
	(Uint16)(((TIMER_PrivateObj*)hTimer)->EventId)\
)


/****************************************\
* TIMER global typedef declarations
\****************************************/
/* device handle type */

typedef struct {
  Uint16 Private;
} TIMER_Private, *TIMER_Handle;

/* device configuration structure */
typedef struct {
  Uint16 tcr;
  Uint16 prd;
  Uint16 prsc;
} TIMER_Config;

/****************************************\
* TIMER global variable declarations
\****************************************/ 
IDECL  void TIMER_close(TIMER_Handle hTimer);
IDECL  void TIMER_config(TIMER_Handle hTimer, TIMER_Config *Config);
IDECL  void TIMER_getConfig(TIMER_Handle hTimer, TIMER_Config *Config);
IDECL  void TIMER_configArgs(TIMER_Handle hTimer, Uint16 tcr, Uint16 prd, Uint16 prsc);
IDECL  TIMER_Handle TIMER_open(int DevNum, Uint16 Flags);
IDECL  void TIMER_start(TIMER_Handle hTimer);
IDECL  void TIMER_stop(TIMER_Handle hTimer);
IDECL  void TIMER_tintoutCfg(TIMER_Handle hTimer, Uint16 idleen, Uint16 func, Uint16 pwid, Uint16 cp, Uint16 polar);

/****************************************\
* TIMER global function declarations
\****************************************/
CSLAPI  void TIMER_reset(TIMER_Handle hTimer);

/****************************************\
* Timer Inline Functions
\****************************************/
#ifdef  USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void TIMER_close(TIMER_Handle hTimer) {
  int oldgie;
  TIMER_ASSERT_HANDLE(hTimer,return);
    oldgie = IRQ_globalDisable(); 


  CSL_SYS_DATA.TimerAllocMask &= (~(1u<<((TIMER_PrivateObj*)hTimer)->Timer));   
  TIMER_reset(hTimer);
  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_config(TIMER_Handle hTimer, TIMER_Config *Config) {
  int oldgie;
  TIMER_ASSERT_HANDLE(hTimer,return);

    oldgie = IRQ_globalDisable();  
 
  PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr) = 0x0010;  
  PREG16(((TIMER_PrivateObj*)hTimer)->PrdAddr) = Config->prd;
  PREG16(((TIMER_PrivateObj*)hTimer)->PrscAddr)= Config->prsc;
  TIMER_FSETH(hTimer,TCR,TLB,1);
  PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr) = Config->tcr | 0x0010;
 /* TIMER_FSETH(hTimer,TCR,TLB,0); */
  
  
  IRQ_globalRestore(oldgie); 
 
}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_configArgs(TIMER_Handle hTimer, Uint16 tcr, Uint16 prd, Uint16 prsc) {
  int oldgie;
  TIMER_ASSERT_HANDLE(hTimer,return);
  oldgie = IRQ_globalDisable(); 
  

  PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr) = 0x0010;
  PREG16(((TIMER_PrivateObj*)hTimer)->PrdAddr) = prd;
  PREG16(((TIMER_PrivateObj*)hTimer)->PrscAddr) = prsc;
  TIMER_FSETH(hTimer,TCR,TLB,1);
  PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr) = tcr | 0x0010;   
  TIMER_FSETH(hTimer,TCR,TLB,0);
  
  IRQ_globalRestore(oldgie); 
}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_getConfig(TIMER_Handle hTimer, TIMER_Config *Config) {
  int oldgie;
  TIMER_ASSERT_HANDLE(hTimer,return);

    oldgie = IRQ_globalDisable();  
 
  Config->tcr = PREG16(((TIMER_PrivateObj*)hTimer)->TcrAddr);  
  Config->prd = PREG16(((TIMER_PrivateObj*)hTimer)->PrdAddr);
  Config->prsc = PREG16(((TIMER_PrivateObj*)hTimer)->PrscAddr);
 
  IRQ_globalRestore(oldgie); 
 
}
/*----------------------------------------------------------------------------*/
IDEF TIMER_Handle TIMER_open(int DevNum, Uint16 Flags) {

  TIMER_Handle hTimer = INV;
  Uint16 dev  = DevNum;
  Uint16 allocMask;
  int oldgie;

  oldgie = IRQ_globalDisable();  
 
  allocMask = CSL_SYS_DATA.TimerAllocMask;

  #ifdef _MCRTE_DEBUG
  if (!((DevNum == -1)||(DevNum>=0&&TIMER_DEVICE_CNT))) {
    ERR_submit(TIMER_ERR_MAJOR, TIMER_ERR_ALLOC);
     IRQ_globalRestore(oldgie);
    return (TIMER_Handle) INV;
  }
  #endif

  if (DevNum==-1) {
    for (dev=0; dev<TIMER_DEVICE_CNT; dev++) {
      if ((allocMask & (1u<<dev))==0){
        hTimer = TIMER_hDev(dev);
       break;
      }
    }
  } else if ((allocMask & (1u<<dev))==0){
    hTimer = TIMER_hDev(dev);
  }

  #ifdef _MCRTE_DEBUG
    if (hTimer == INV) {
      ERR_submit(TIMER_ERR_MAJOR, TIMER_ERR_INVALID_HANDLE);
      IRQ_restoreGie();
      return (TIMER_Handle)INV;
  }
  #endif

  if (hTimer != INV) {
     CSL_SYS_DATA.TimerAllocMask |= 1u<<dev;     
     if (Flags & TIMER_OPEN_RESET) {
       TIMER_reset(hTimer);
     }
  }

  IRQ_globalRestore(oldgie);
  return hTimer;
}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_start(TIMER_Handle hTimer) {
  int oldgie;
  Uint16 old_tcr;

  oldgie = IRQ_globalDisable(); 
    
      /* stop timer */  
  old_tcr = _PREG_GET(((TIMER_PrivateObj*)(hTimer))->TcrAddr);
  _PREG_SET(((TIMER_PrivateObj*)(hTimer))->TcrAddr, (old_tcr & (_TIMER_TCR_TLB_CLR & _TIMER_TCR_TSS_CLR)));
  IRQ_globalRestore(oldgie);

}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_stop(TIMER_Handle hTimer) {
  int oldgie;

  oldgie = IRQ_globalDisable(); 
    
      /* stop timer */  
  TIMER_FSETH(hTimer,TCR,TSS,1);

  IRQ_globalRestore(oldgie);

}

/*----------------------------------------------------------------------------*/
IDEF void TIMER_tintoutCfg(TIMER_Handle hTimer, Uint16 idleen, Uint16 func, Uint16 pwid, Uint16 cp, Uint16 polar) {

  Uint16 tcrMask = TIMER_TCR_RMK(
                     idleen,
                     func,
                     0,             /* TLB    */
                     0,             /* SOFT   */
                     0,             /* FREE   */
                     pwid,          /* PWID   */
                     0,             /* ARB    */
                     0,             /* TSS    */
                     cp,            /* CP     */
                     polar,         /* POLAR  */
                     0);            /* DATOUT */
 
  int oldgie;

  oldgie = IRQ_globalDisable();

     ((TIMER_PrivateObj*)hTimer)->TcrAddr |= 0x0010;
     ((TIMER_PrivateObj*)hTimer)->TcrAddr |= tcrMask;

  IRQ_globalRestore(oldgie);
      
}
/*****************************************************************************\
\*****************************************************************************/
#endif /* UseDefs */
/******************************************************************************\
* End of timer.h
\******************************************************************************/
#endif /*TIMER_SUPPORT */
#endif /* _TIMER_H_ */    

csl_timhal.h/   1049976936  0     0     0       24577     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... TIMER
* FILENAME...... csl_timhal.h
* DATE CREATED.. Tues 05/23/2000 
* PROJECT....... CSL - Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. stdinc.h, chip.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       05/23/2000 (AP) created  
*   MODIFIED:      07/20/2000 (NNS) modified
*   LAST MODIFIED: 04/16/2001 updated FILENAME and other header comments
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the TIMER module)
*
* Registers Covered:
*   (RW) _TIMER_TCR0  -  Timer 0 control register
*   (RW) _TIMER_TCR1  -  Timer 1 control register
*   (RW) _TIMER_PRD0  -  Timer 0 period register
*   (RW) _TIMER_PRD1  -  Timer 1 perid register
*   (RW) _TIMER_PRSC0 -  Timer 0 prescaler register
*   (RW) _TIMER_PRSC1 -  Timer 1 prescaler register
*   (RW) _TIMER_TIM0  -  Timer 0 count register
*   (RW) _TIMER_TIM1  -  Timer 1 count register
*
\******************************************************************************/
#ifndef _CSL_TIMERHAL_H_
#define _CSL_TIMERHAL_H_

#include <csl_chiphal.h>

#if (_TIMER_SUPPORT)

/****************************************\
* _TIMER scope and inline control macros
\****************************************/
#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#define IDECL static inline
#define USEDEFS
#define IDEF  static inline

/*============================================================================*\
* misc declarations
\*============================================================================*/

#define _TIMER_DEVICE_CNT			(2)

/*============================================================================*\
* Generic Timer register/field set/get macros
\*============================================================================*/

#define TIMER_ADDR(Reg)                  _TIMER_##Reg##_ADDR
#define TIMER_RGET(Reg)                  _PREG_GET(TIMER_ADDR(##Reg))
#define TIMER_RSET(Reg,Val)              _PREG_SET(TIMER_ADDR(##Reg),Val)
#define TIMER_RAOI(Reg,AND,OR,INV)       _PREG_AOI(TIMER_ADDR(##Reg),AND,OR,INV)

#define TIMER_FGET(Reg,Field)           _TIMER_##Reg##_FGET(##Field)
#define TIMER_FSET(Reg,Field,Val)       _TIMER_##Reg##_FSET(##Field,Val)

#define TIMER_FAOI(Reg,Field,AND,OR,INV) _TIMER_##Reg##_FAOI(##Field,AND,OR,INV)
#define TIMER_FMK(Reg,Field,Val)         _TIMER_##Reg##_##Field##_MK(Val)
#define TIMER_FMKS(Reg,Field,Sym)        TIMER_FMK(##Reg,##Field,TIMER_##Reg##_##Field##_##Sym)

#define TIMER_ADDRH(Handle,Reg)         _TIMER_##Reg##_ADDR(((TIMER_PrivateObj*)(Handle))->Timer)
#define TIMER_RGETH(Handle,Reg)         _PREG_GET(TIMER_ADDRH(Handle,##Reg))
#define TIMER_RSETH(Handle,Reg,Val)     _PREG_SET(TIMER_ADDRH(Handle,##Reg),Val)

#define TIMER_FSETS(Reg,Field,Sym)       _TIMER_##Reg##_FSETS(##Reg,##Field,Sym)

#define TIMER_RAOIH(Handle,Reg,AND,OR,INV)\
  _PREG_AOI(TIMER_ADDRH(Handle,##Reg),AND,OR,INV)

#define TIMER_FGETH(Handle,Reg,Field)\
   _TIMER_##Reg##_FGET(((TIMER_PrivateObj*)(Handle))->Timer,##Field)

#define TIMER_FSETH(Handle,Reg,Field,Val)\
   _TIMER_##Reg##_FSET(((TIMER_PrivateObj*)(Handle))->Timer,##Field,Val)

#define TIMER_FSETSH(Handle,Reg,Field,Sym)\
   TIMER_FSET(((TIMER_PrivateObj*)(Handle))->Timer,##Reg,##Field,TIMER_##Reg##_##Field##_##Sym)

#define TIMER_FAOIH(Handle,Reg,Field,AND,OR,INV)\
   _TIMER_##Reg##_FAOI(((TIMER_PrivateObj*)(Handle))->Timer,##Field,AND,OR,INV)

#define TIMER_ADDR_H(Handle,Reg)         _TIMER_##Reg##_ADDR(((TIMER_PrivateObj*)(Handle))->Timer)
#define TIMER_RGET_H(Handle,Reg)         _PREG_GET(TIMER_ADDRH(Handle,##Reg))
#define TIMER_RSET_H(Handle,Reg,Val)     _PREG_SET(TIMER_ADDRH(Handle,##Reg),Val)

#define TIMER_FSETS(Reg,Field,Sym)       _TIMER_##Reg##_FSETS(##Reg,##Field,Sym)

#define TIMER_RAOI_H(Handle,Reg,AND,OR,INV)\
  _PREG_AOI(TIMER_ADDRH(Handle,##Reg),AND,OR,INV)

#define TIMER_FGET_H(Handle,Reg,Field)\
   _TIMER_##Reg##_FGET(((TIMER_PrivateObj*)(Handle))->Timer,##Field)

#define TIMER_FSET_H(Handle,Reg,Field,Val)\
   _TIMER_##Reg##_FSET(((TIMER_PrivateObj*)(Handle))->Timer,##Field,Val)

#define TIMER_FSETS_H(Handle,Reg,Field,Sym)\
   TIMER_FSET(((TIMER_PrivateObj*)(Handle))->Timer,##Reg,##Field,TIMER_##Reg##_##Field##_##Sym)

#define TIMER_FAOI_H(Handle,Reg,Field,AND,OR,INV)\
   _TIMER_##Reg##_FAOI(((TIMER_PrivateObj*)(Handle))->Timer,##Field,AND,OR,INV)


/*============================================================================*\
* _TIMER_TCR0:  Timer Control Register for Timer #0
\*============================================================================*/
#define _TIMER_TCR0_ADDR			(0x1002u)
#define _TIMER_TCR0                       PREG16(_TIMER_TCR0_ADDR)
#define _TCR0                              _TIMER_TCR0

#define _TIMER_TCR1_ADDR			(0x2402u)
#define _TIMER_TCR1				PREG16(_TIMER_TCR1_ADDR)
#define _TCR1					_TIMER_TCR1

#define _TIMER_TCR_BASE                  (0x1002u)
#define _TIMER_TCR_ADDR(Timer)           ((Timer*0x1400) + _TIMER_TCR_BASE)

/*============================================================================*\
* _TIMER_PRD0:  Period Register, Timer #0
\*============================================================================*/
#define _TIMER_PRD0_ADDR                  (0x1001u)
#define _TIMER_PRD0                       PREG16(_TIMER_PRD0_ADDR)
#define _PRD0                              _TIMER_PRD0

/*============================================================================
* _TIMER_PRD1:  Period Register, TImer #1
\*============================================================================*/
#define _TIMER_PRD1_ADDR			(0x2401u)
#define _TIMER_PRD1				PREG16(_TIMER_PRD1_ADDR)
#define _PRD1					_TIMER_PRD1

#define _TIMER_PRD_BASE                   (0x1001u)
#define _TIMER_PRD_ADDR(Timer)            ((Timer*0x1400u)+_TIMER_PRD_BASE)

/*============================================================================*\
* _TIMER_PRSC0:  Timer Prescalar Register, Timer #0
\*============================================================================*/
#define _TIMER_PRSC0_ADDR			(0x1003u)
#define _TIMER_PRSC0				PREG16(_TIMER_PRSC0_ADDR)
#define _PRSC0                                   _TIMER_PRSC0

/*============================================================================*\
* _TIMER_PRSC1:  Timer Prescalar Register, Timer #1
\*============================================================================*/
#define _TIMER_PRSC1_ADDR			(0x2403u)
#define _TIMER_PRSC1				PREG16(_TIMER_PRSC1_ADDR)
#define _PRSC1                                   _TIMER_PRSC1

#define _TIMER_PRSC_BASE                  (0x1003u)
#define _TIMER_PRSC_ADDR(Timer)           ((Timer*0x1400u)+_TIMER_PRSC_BASE)

/*============================================================================*\
* _TIMER_TIM0:  Timer Count Register, Timer #0
\*============================================================================*/
#define _TIMER_TIM0_ADDR			(0x1000u)
#define _TIMER_TIM0				PREG16(_TIMER_TIM0_ADDR)
#define _TIM0					_TIMER_TIM0

#define _TIMER_TIM1_ADDR			(0x2400u)
#define _TIMER_TIM1				PREG16(_TIMER_TIM1_ADDR)
#define _TIM1					_TIMER_TIM1

#define _TIMER_TIM_BASE                  (0x1000u)
#define _TIMER_TIM_ADDR(Timer)           ((Timer*0x1400u)+_TIMER_TIM_BASE)
             
/*============================================================================
* _TIMER_TCR_GET and _TIMER_TCR_SET
*============================================================================*/
#define _TIMER_TCR_GET(Timer)           _PREG_GET(_TIMER_TCR_ADDR(Timer))
#define _TIMER_TCR_SET(Timer,Val)       _PREG_SET(_TIMER_TCR_ADDR(Timer),Val)

#define _TIMER_TCR_AOI(Timer,AND,OR,INV)\
  _PREG_AOI(_TIMER_TCR_ADDR(Timer),AND,OR,INV)

#define _TIMER_TCR_FGET(Timer,Field)\
   _PFIELD_GET(_TIMER_TCR_ADDR(Timer),_TIMER_TCR_##Field)

#define _TIMER_TCR_FSET(Timer,Field,Val)\
   _PFIELD_SET(_TIMER_TCR_ADDR(Timer),_TIMER_TCR_##Field,Val)

#define _TIMER_TCR_FAOI(Timer,Field,AND,OR,INV)\
   _PFIELD_AOI(_TIMER_TCR_ADDR(Timer),_TIMER_TCR_##Field,AND,OR,INV)

#define _TIMER_TCR0_FGET(Field)             _TIMER_TCR_FGET(0,##Field)
#define _TIMER_TCR0_FSET(Field,Val)         _TIMER_TCR_FSET(0,##Field,Val)
#define _TIMER_TCR0_FAOI(Field,AND,OR,INV)  _TIMER_TCR_FAOI(0,##Field,AND,OR,INV)


#define _TIMER_TCR1_FGET(Field)             _TIMER_TCR_FGET(0,##Field)
#define _TIMER_TCR1_FSET(Field,Val)         _TIMER_TCR_FSET(1,##Field,Val)
#define _TIMER_TCR1_FAOI(Field,AND,OR,INV)  _TIMER_TCR_FAOI(0,##Field,AND,OR,INV)


/*============================================================================
* _TIMER_PRD_GET and _TIMER_PRD_SET macros
\*============================================================================*/
#define _TIMER_PRD_GET(Timer)           _PREG_GET(_TIMER_PRD_ADDR(Timer))
#define _TIMER_PRD_SET(Timer,Val)       _PREG_SET(_TIMER_PRD_ADDR(Timer),Val)

#define _TIMER_PRD_AOI(Timer,AND,OR,INV)\
  _PREG_AOI(_TIMER_PRD_ADDR(Timer),AND,OR,INV)

#define _TIMER_PRD_FGET(Timer,Field)\
   _PFIELD_GET(_TIMER_PRD_ADDR(Timer),_TIMER_PRD_##Field)

#define _TIMER_PRD_FSET(Timer,Field,Val)\
   _PFIELD_SET(_TIMER_PRD_ADDR(Timer),_TIMER_PRD_##Field,Val)

#define _TIMER_PRD_FAOI(Timer,Field,AND,OR,INV)\
   _PFIELD_AOI(_TIMER_PRD_ADDR(Timer),_TIMER_PRD_##Field,AND,OR,INV)

#define _TIMER_PRD0_FGET(Field)             _TIMER_PRD_FGET(0,##Field)
#define _TIMER_PRD0_FSET(Field,Val)         _TIMER_PRD_FSET(1,##Field,Val)
#define _TIMER_PRD0_FAOI(Field,AND,OR,INV)  _TIMER_PRD_FAOI(0,##Field,AND,OR,INV)

#define _TIMER_PRD1_FGET(Field)             _TIMER_PRD_FGET(0,##Field)
#define _TIMER_PRD1_FSET(Field,Val)         _TIMER_PRD_FSET(1,##Field,Val)
#define _TIMER_PRD1_FAOI(Field,AND,OR,INV)  _TIMER_PRD_FAOI(0,##Field,AND,OR,INV)

/*============================================================================*\
* _TIMER_PRSC_GET and _TIMER_PRSC_SET
\*============================================================================*/
#define _TIMER_PRSC_GET(Timer)           _PREG_GET(_TIMER_PRSC_ADDR(Timer))
#define _TIMER_PRSC_SET(Timer,Val)       _PREG_SET(_TIMER_PRSC_ADDR(Timer),Val)

#define _TIMER_PRSC_AOI(Timer,AND,OR,INV)\
  _PREG_AOI(_TIMER_PRSC_ADDR(Timer),AND,OR,INV)

#define _TIMER_PRSC_FGET(Timer,Field)\
   _PFIELD_GET(_TIMER_PRSC_ADDR(Timer),_TIMER_PRSC_##Field)

#define _TIMER_PRSC_FSET(Timer,Field,Val)\
   _PFIELD_SET(_TIMER_PRSC_ADDR(Timer),_TIMER_PRSC_##Field,Val)

#define _TIMER_PRSC_FAOI(Timer,Field,AND,OR,INV)\
   _PFIELD_AOI(_TIMER_PRSC_ADDR(Timer),_TIMER_PRSC_##Field,AND,OR,INV)

#define _TIMER_PRSC0_FGET(Field)             _TIMER_PRSC_FGET(0,##Field)
#define _TIMER_PRSC0_FSET(Field,Val)         _TIMER_PRSC_FSET(1,##Field,Val)
#define _TIMER_PRSC0_FAOI(Field,AND,OR,INV)  _TIMER_PRSC_FAOI(0,##Field,AND,OR,INV)

#define _TIMER_PRSC1_FGET(Field)             _TIMER_PRSC_FGET(0,##Field)
#define _TIMER_PRSC1_FSET(Field,Val)         _TIMER_PRSC_FSET(1,##Field,Val)
#define _TIMER_PRSC1_FAOI(Field,AND,OR,INV)  _TIMER_PRSC_FAOI(0,##Field,AND,OR,INV)

/*============================================================================*\
* _TIMER_TIM_GET and _TIMER_TIM_SET
\*============================================================================*/
#define _TIMER_TIM_GET(Timer)           _PREG_GET(_TIMER_TIM_ADDR(Timer))
#define _TIMER_TIM_SET(Timer,Val)       _PREG_SET(_TIMER_TIM_ADDR(Timer),Val)

#define _TIMER_TIM_AOI(Timer,AND,OR,INV)\
  _PREG_AOI(_TIMER_TIM_ADDR(Timer),AND,OR,INV)

#define _TIMER_TIM_FGET(Timer,Field)\
   _PFIELD_GET(_TIMER_TIM_ADDR(Timer),_TIMER_TIM_##Field)

#define _TIMER_TIM_FSET(Timer,Field,Val)\
   _PFIELD_SET(_TIMER_TIM_ADDR(Timer),_TIMER_TIM_##Field,Val)

#define _TIMER_TIM_FAOI(Timer,Field,AND,OR,INV)\
   _PFIELD_AOI(_TIMER_TIM_ADDR(Timer),_TIMER_TIM_##Field,AND,OR,INV)

#define _TIMER_TIM0_FGET(Field)             _TIMER_TIM_FGET(0,##Field)
#define _TIMER_TIM0_FSET(Field,Val)         _TIMER_TIM_FSET(1,##Field,Val)
#define _TIMER_TIM0_FAOI(Field,AND,OR,INV)  _TIMER_TIM_FAOI(0,##Field,AND,OR,INV)

#define _TIMER_TIM1_FGET(Field)             _TIMER_TIM_FGET(0,##Field)
#define _TIMER_TIM1_FSET(Field,Val)         _TIMER_TIM_FSET(1,##Field,Val)
#define _TIMER_TIM1_FAOI(Field,AND,OR,INV)  _TIMER_TIM_FAOI(0,##Field,AND,OR,INV)


/*===========================================================================*\
* _TIMER_TCR0    - Control Register, Timer #0
* _TIMER_TCR1    - Control Register, Timer #1
*
* Fields:
*  (RW) _TIMER_TCR_IDLEEN
*  (R) _TIMER_TCR_INTEXT
*  (R) _TIMER_TCR_ERRTIM
*  (RW) _TIMER_TCR_FUNC
*  (RW) _TIMER_TCR_TLB
*  (RW) _TIMER_TCR_SOFT
*  (RW) _TIMER_TCR_FREE
*  (RW) _TIMER_TCR_PWID
*  (RW) _TIMER_TCR_ARB
*  (RW) _TIMER_TCR_TSS
*  (RW) _TIMER_TCR_CP
*  (RW) _TIMER_TCR_POLAR
*  (RW) _TIMER_TCR_DATOUT
\*==========================================================================*/

/*==========================================================================*\
* (RW) _TIMER_TCR_IDLEEN
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_IDLEEN_SHIFT		(0x000Fu)
#define _TIMER_TCR_IDLEEN_MK(n)           (((Uint16)(n) & 0x0001u) << _TIMER_TCR_IDLEEN_SHIFT)
#define _TIMER_TCR_IDLEEN_MASK            (_TIMER_TCR_IDLEEN_MK(1))
#define _TIMER_TCR_IDLEEN_CLR             (~(_TIMER_TCR_IDLEEN_MK(1)))

/*==========================================================================*\
* (RW) _TIMER_TCR_INTEXT
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_INTEXT_SHIFT		(0x000Eu)
#define _TIMER_TCR_INTEXT_MK(n)		(((Uint16)(n) & 0x0001u) << _TIMER_TCR_INTEXT_SHIFT)
#define _TIMER_TCR_INTEXT_MASK		(_TIMER_TCR_INTEXT_MK(1))
#define _TIMER_TCR_INTEXT_CLR			(~(_TIMER_TCR_INTEXT_MK(1)))

/*==========================================================================*\
* (RW) _TIMER_TCR_ERRTIM
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_ERRTIM_SHIFT		(0x000Du)
#define _TIMER_TCR_ERRTIM_MK(n)		(((Uint16)(n) & 0x0001u) << _TIMER_TCR_ERRTIM_SHIFT)
#define _TIMER_TCR_ERRTIM_MASK		(_TIMER_TCR_ERRTIM_MK(1))
#define _TIMER_TCR_ERRTIM_CLR			(~(_TIMER_TCR_ERRTIM_MK(1)))

/*==========================================================================*\
* (RW) _TIMER_TCR_FUNC
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_FUNC_SHIFT			(0x000Bu)
#define _TIMER_TCR_FUNC_MK(n)			(((Uint16)(n) & 0x0003u) << _TIMER_TCR_FUNC_SHIFT)
#define _TIMER_TCR_FUNC_MASK			(_TIMER_TCR_FUNC_MK(0x0003u))
#define _TIMER_TCR_FUNC_CLR			(~(_TIMER_TCR_FUNC_MK(0x0003u)))

/*==========================================================================*\
* (RW) _TIMER_TCR_TLB
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_TLB_SHIFT			(0x000Au)
#define _TIMER_TCR_TLB_MK(n)			(((Uint16)(n) & 0x0001u) << _TIMER_TCR_TLB_SHIFT)
#define _TIMER_TCR_TLB_MASK			(_TIMER_TCR_TLB_MK(1))
#define _TIMER_TCR_TLB_CLR			(~(_TIMER_TCR_TLB_MK(1)))

/*==========================================================================*\
* (RW) _TIMER_TCR_SOFT
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_SOFT_SHIFT			(0x0009u)
#define _TIMER_TCR_SOFT_MK(n)			(((Uint16)(n) & 0x0001u) << _TIMER_TCR_SOFT_SHIFT)
#define _TIMER_TCR_SOFT_MASK			(_TIMER_TCR_SOFT_MK(1))
#define _TIMER_TCR_SOFT_CLR			(~(_TIMER_TCR_SOFT_MK(1)))

/*==========================================================================*\
* (RW) _TIMER_TCR_FREE
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_FREE_SHIFT			(0x0008u)
#define _TIMER_TCR_FREE_MK(n)			(((Uint16)(n) & 0x0001u) << _TIMER_TCR_FREE_SHIFT)
#define _TIMER_TCR_FREE_MASK			(_TIMER_TCR_FREE_MK(1))
#define _TIMER_TCR_FREE_CLR			(~(_TIMER_TCR_FREE_MK(1)))

/*==========================================================================*\
* (RW) _TIMER_TCR_PWID
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_PWID_SHIFT			(0x0006u)
#define _TIMER_TCR_PWID_MK(n)			(((Uint16)(n) & 0x0003u) << _TIMER_TCR_PWID_SHIFT)
#define _TIMER_TCR_PWID_MASK			(_TIMER_TCR_PWID_MK(0x0003u))
#define _TIMER_TCR_PWID_CLR			(~(_TIMER_TCR_PWID_MK(0x0003u)))

/*==========================================================================*\
* (RW) _TIMER_TCR_ARB
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_ARB_SHIFT			(0x0005u)
#define _TIMER_TCR_ARB_MK(n)			(((Uint16)(n) & 0x0001u) << _TIMER_TCR_ARB_SHIFT)
#define _TIMER_TCR_ARB_MASK			(_TIMER_TCR_ARB_MK(1))
#define _TIMER_TCR_ARB_CLR			(~(_TIMER_TCR_ARB_MK(1)))

/*==========================================================================*\
* (RW) _TIMER_TCR_TSS
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_TSS_SHIFT			(0x0004u)
#define _TIMER_TCR_TSS_MK(n)			(((Uint16)(n) & 0x0001u) << _TIMER_TCR_TSS_SHIFT)
#define _TIMER_TCR_TSS_MASK			(_TIMER_TCR_TSS_MK(1))
#define _TIMER_TCR_TSS_CLR			(~(_TIMER_TCR_TSS_MK(1)))

/*==========================================================================*\
* (RW) _TIMER_TCR_CP
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_CP_SHIFT			(0x0003u)
#define _TIMER_TCR_CP_MK(n)			(((Uint16)(n) & 0x0001u) << _TIMER_TCR_CP_SHIFT)
#define _TIMER_TCR_CP_MASK			(_TIMER_TCR_CP_MK(1))
#define _TIMER_TCR_CP_CLR			(~(_TIMER_TCR_CP_MK(1)))

/*==========================================================================*\
* (RW) _TIMER_TCR_POLAR
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_POLAR_SHIFT		(0x0002u)
#define _TIMER_TCR_POLAR_MK(n)		(((Uint16)(n) & 0x0001u) << _TIMER_TCR_POLAR_SHIFT)
#define _TIMER_TCR_POLAR_MASK			(_TIMER_TCR_POLAR_MK(1))
#define _TIMER_TCR_POLAR_CLR			(~(_TIMER_TCR_POLAR_MK(1)))

/*==========================================================================*\
* (RW) _TIMER_TCR_DATOUT
\*--------------------------------------------------------------------------*/
#define _TIMER_TCR_DATOUT_SHIFT		(0x0001u)
#define _TIMER_TCR_DATOUT_MK(n)		(((Uint16)(n) & 0x0001u) << _TIMER_TCR_DATOUT_SHIFT)
#define _TIMER_TCR_DATOUT_MASK		(_TIMER_TCR_DATOUT_MK(1))
#define _TIMER_TCR_DATOUT_CLR			(~(_TIMER_TCR_DATOUT_MK(1)))

/*==========================================================================*\
* Timer Control #1 and Timer Control #2 Config
\*--------------------------------------------------------------------------*/

#define _TIMER_TCR0_CFG(idleen,intext,errtim,func,tlb,soft,free,pwid,arb,tss, \
		cp,polar,dataout) \
	_PREG_SET(_TIMER_TCR0_ADDR, \
    		(Uint16) (	_TIMER_TCR_IDLEEN_MK(idleen) 	|	\
            	    	_TIMER_TCR_INTEXT_MK(intext) 	|	\
			    	_TIMER_TCR_ERRTIM_MK(errtim) 	|	\
			    	_TIMER_TCR_FUNC_MK(func) 	|	\
			    	_TIMER_TCR_TLB_MK(tlb)		|	\
			    	_TIMER_TCR_SOFT_MK(soft) 	|	\
				_TIMER_TCR_FREE_MK(free) 	|	\
				_TIMER_TCR_PWID_MK(pwid) 	|	\
				_TIMER_TCR_ARB_MK(arb) 		|	\
				_TIMER_TCR_TSS_MK(tss)	 	|	\
				_TIMER_TCR_CP_MK(cp)	 	|	\
				_TIMER_TCR_POLAR_MK(polar) 	|	\
				_TIMER_TCR_DATOUT_MK(DATOUT) 		\
             ))

#define _TIMER_TCR1_CFG(idleen,intext,errtim,func,tlb,soft,free,pwid,arb,tss, \
		cp,polar,dataout) \
	_PREG_SET(_TIMER_TCR1_ADDR, \
    		(Uint16) (	_TIMER_TCR_IDLEEN_MK(idleen) 	|	\
            	    	_TIMER_TCR_INTEXT_MK(intext) 	|	\
			    	_TIMER_TCR_ERRTIM_MK(errtim) 	|	\
			    	_TIMER_TCR_FUNC_MK(func) 	|	\
			    	_TIMER_TCR_TLB_MK(tlb)		|	\
			    	_TIMER_TCR_SOFT_MK(soft) 	|	\
				_TIMER_TCR_FREE_MK(free) 	|	\
				_TIMER_TCR_PWID_MK(pwid) 	|	\
				_TIMER_TCR_ARB_MK(arb) 		|	\
				_TIMER_TCR_TSS_MK(tss)	 	|	\
				_TIMER_TCR_CP_MK(cp)	 	|	\
				_TIMER_TCR_POLAR_MK(polar) 	|	\
				_TIMER_TCR_DATOUT_MK(DATOUT) 		\
             ))


/*===========================================================================*\
* _TIMER_PRD0    - Timer Period Register, Timer #0
* _TIMER_PRD1    - Timer Period Register, Timer #1
*
* Fields:
*  (RW) _TIMER_PRD_PRD
\*==========================================================================*/


/*==========================================================================*\
* (RW) _TIMER_PRD_PRD
\*--------------------------------------------------------------------------*/
#define _TIMER_PRD_PRD_SHIFT		(0x0000u)
#define _TIMER_PRD_PRD_MK(n)		(((Uint16)(n) & 0xFFFFu) << _TIMER_PRD_PRD_SHIFT)
#define _TIMER_PRD_PRD_MASK		(_TIMER_PRD_PRD_MK(0xFFFFu))
#define _TIMER_PRD_PRD_CLR		(~(_TIMER_PRD_PRD_MK(0xFFFFu)))

/*==========================================================================*\
* PRD Config, Timer #1 and #2
\*--------------------------------------------------------------------------*/
#define _TIMER_PRD0_CFG(tim) \
	_PREG_SET(_TIMER_PRD0_ADDR,(Uint16)_TIMER_PRD_PRD_MK(n)(tim))

#define _TIMER_PRD1_CFG(tim) \
	_PREG_SET(_TIMER_PRD1_ADDR,(Uint16)_TIMER_PRD_PRD_MK(n)(tim))


/*===========================================================================*\
* _TIMER_TIM0    - Timer Register, Timer #0
* _TIMER_TIM1    - Timer Register, Timer #1
*
* Fields:
*  (RW) _TIMER_TIM_TIM
\*==========================================================================*/


/*==========================================================================*\
* (RW) _TIMER_TIM_TIM
\*--------------------------------------------------------------------------*/
#define _TIMER_TIM_TIM_SHIFT		(0x0000u)
#define _TIMER_TIM_TIM_MK(n)		(((Uint16)(n) & 0xFFFFu) << _TIMER_TIM_TIM_SHIFT)
#define _TIMER_TIM_TIM_MASK		(_TIMER_TIM_TIM_MK(0xFFFFu))
#define _TIMER_TIM_TIM_CLR		(~(_TIMER_TIM_TIM_MK(0xFFFFu)))

/*==========================================================================*\
* TIM Config, Timer #1 and #2
\*--------------------------------------------------------------------------*/
#define _TIMER_TIM0_CFG(tim) \
	_PREG_SET(_TIMER_TIM0_ADDR,(Uint16)_TIMER_TIM_TIM_MK(tim))

#define _TIMER_TIM1_CFG(tim) \
	_PREG_SET(_TIMER_TIM1_ADDR,(Uint16)_TIMER_TIM_TIM_MK(tim))


/*===========================================================================*\
* _TIMER_PRSC0    - Time Prescalar Register, Timer #0
* _TIMER_PRSC1    - Time Prescalar Register, Timer #1
*
* Fields:
*  (RW) _TIMER_PRSC_PSC
*  (RW) _TIMER_PRSC_TDDR
\*==========================================================================*/


/*==========================================================================*\
* (RW) _TIMER_PRSC_PSC
\*--------------------------------------------------------------------------*/
#define _TIMER_PRSC_PSC_SHIFT		(0x0006u)
#define _TIMER_PRSC_PSC_MK(n)		(((Uint16)(n) & 0x000Fu) << _TIMER_PRSC_PSC_SHIFT)
#define _TIMER_PRSC_PSC_MASK		(_TIMER_PRSC_PSC_MK(0x000Fu))
#define _TIMER_PRSC_PSC_CLR		(~(_TIMER_PRSC_PSC_MK(0x000Fu)))

/*==========================================================================*\
* (RW) _TIMER_PRSC_TDDR
\*--------------------------------------------------------------------------*/
#define _TIMER_PRSC_TDDR_SHIFT	(0x0000u)
#define _TIMER_PRSC_TDDR_MK(n)	(((Uint16)(n) & 0x000Fu) << _TIMER_PRSC_TDDR_SHIFT)
#define _TIMER_PRSC_TDDR_MASK		(_TIMER_PRSC_TDDR_MK(0x000Fu))
#define _TIMER_PRSC_TDDR_CLR		(~(_TIMER_PRSC_TDDR_MK(0x000Fu)))

/*==========================================================================*\
* Timer Prescalar Register #1 and #2 Config
\*--------------------------------------------------------------------------*/
#define _TIMER_PRSC0_CFG(psc,tddr) \
	_PREG_SET(_TIMER_PRSC0_ADDR, \
		(Uint16)	_TIMER_PRSC_PSC_MK(tim)		| 	\
				_TIMER_PRSC_TDDR_MK(tddr) 		\
		))
		
#define _TIMER_PRSC1_CFG(psc,tddr) \
	_PREG_SET(_TIMER_PRSC1_ADDR, \
		(Uint16)	_TIMER_PRSC_PSC_MK(tim)		| 	\
				_TIMER_PRSC_TDDR_MK(tddr) 		\
		))


#elif (!(_TIMER_MOD_))
	#error TIMER Hal Module Not Supported on Specified Target
#endif
#endif

csl_uart.h/     1074593835  0     0     0       25205     `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... UART
* FILENAME...... csl_uart.h
* DATE CREATED.. Thur 01/17/2002 
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       01/17/2001  Created for 5502.
*  MODIFIED:       12/19/2003  Updated baud rate - symbolic constants for 64MHz
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the UART module)
*
\******************************************************************************/
#ifndef _CSL_UART_H_
#define _CSL_UART_H_

#include <csl_std.h>
#include <csl.h>
#include <csl_chiphal.h>
#include <csl_csldat.h>
#include <csl_hpi.h>
#include <csl_hpihal.h>
#include <csl_irq.h>
#include <csl_uarthal.h>
#include <csl_uartdat.h>

#if (_UART_SUPPORT) 
/*----------------------------------------------------------------*\
*	 UART scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _UART_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/******************************************************************************\
* Register Field Values
\******************************************************************************/

/* LCR Register field values */
#define UART_URLCR_WLS_5bits               (0x0000u)         /* word length is 5 bits */
#define UART_URLCR_WLS_6bits               (0x0001u)         /* word length is 6 bits */
#define UART_URLCR_WLS_7bits               (0x0002u)         /* word length is 7 bits */
#define UART_URLCR_WLS_8bits               (0x0003u)         /* word length is 8 bits */

#define UART_URLCR_STB_ZERO                (0x0000u)         /* STB bit setup to 0 */
#define UART_URLCR_STB_ONE                 (0x0004u)         /* STB bit setup to 1 */

#define UART_URLCR_PEN_ENABLE              (0x0008u)         /* parity enabled */
#define UART_URLCR_PEN_DISABLE             (0x0000u)         /* parity disabled */

#define UART_URLCR_EPS_ENABLE              (0x0010u)         /* even parity check enabled */
#define UART_URLCR_EPS_DISABLE             (0x0000u)         /* even parity check disabled */

#define UART_URLCR_STPAR_ENABLE            (0x0020u)         /* stick parity check enabled */
#define UART_URLCR_STPAR_DISABLE           (0x0000u)         /* stick parity check disabled */

#define UART_URLCR_BC_ENABLE               (0x0040u)         /* break control enabled */
#define UART_URLCR_BC_DISABLE              (0x0000u)         /* break control disabled */

#define UART_URLCR_DLAB_ONE                (0x0080u)         /* DLAB set to 1 */
#define UART_URLCR_DLAB_ZERO               (0x0000u)         /* DLAB set to 0 */

#define UART_URLCR_RMK(wls, stb, pen, eps, stpar, bc, dlab)((Uint16)(\
    (UART_FMK(URLCR,WLS, wls))|\
    (UART_FMK(URLCR,STB, stb))|\
    (UART_FMK(URLCR,PEN, pen))|\
    (UART_FMK(URLCR,EPS, eps))|\
    (UART_FMK(URLCR,STPAR, stpar))|\
    (UART_FMK(URLCR,BC, bc))|\
    (UART_FMK(URLCR,DLAB, dlab))\
 )\
)

#define UART_URLCR_RMKS(wls_sym, stb_sym, pen_sym, eps_sym, stpar_sym, bc_sym, dlab_sym)((Uint16)(\
    (UART_FMKS(URLCR,WLS, wls_sym))|\
    (UART_FMKS(URLCR,STB, stb_sym))|\
    (UART_FMKS(URLCR,PEN, pen_sym))|\
    (UART_FMKS(URLCR,EPS, eps_sym))|\
    (UART_FMKS(URLCR,STPAR, stpar_sym))|\
    (UART_FMKS(URLCR,BC, bc_sym))|\
    (UART_FMKS(URLCR,DLAB, dlab_sym))\
 )\
)

/* URIER Register field values */
#define UART_URIER_ERBI_DISABLE            (0x0000u)         /* disable receive data availabe interrupt */
#define UART_URIER_ERBI_ENABLE             (0x0001u)         /* enable receive data availabe interrupt */

#define UART_URIER_ETBEI_DISABLE           (0x0000u)         /* disable transmitter holding register empty interrupt */
#define UART_URIER_ETBEI_ENABLE            (0x0002u)         /* enable transmitter holding register empty interrupt */

#define UART_URIER_ELSI_DISABLE            (0x0000u)         /* disable receive line status interrupt */
#define UART_URIER_ELSI_ENABLE             (0x0004u)         /* enable receive line status interrupt */
#define UART_URIER_EDSSI_DISABLE           (0x0000u)         /* disable modem line status interrupt */
#define UART_URIER_EDSSI_ENABLE            (0x0008u)         /* enable modem status interrupt */

#define UART_URIER_RMK(erbi, etbei, elsi, edssi)((Uint16)(\
    (UART_FMK(URIER,ERBI, erbi))|\
    (UART_FMK(URIER,ETBEI, etbei))|\
    (UART_FMK(URIER,ELSI, elsi))|\
    (UART_FMK(URIER,EDSSI, edssi))\
 )\
)

#define UART_URIER_RMKS(erbi_sym, etbei_sym, elsi_sym, edssi_sym)((Uint16)(\
    (UART_FMKS(URIER,ERBI, erbi_sym))|\
    (UART_FMKS(URIER,ETBEI, etbei_sym))|\
    (UART_FMKS(URIER,ELSI, elsi_sym))|\
    (UART_FMKS(URIER,EDSSI, edssi_sym))\
 )\
)

/* URFCR Register field values */
#define UART_URFCR_FIEN_DISABLE            (0x0000u)         /* FIFO disable */
#define UART_URFCR_FIEN_ENABLE             (0x0001u)         /* FIFO enable */
#define UART_URFCR_RFIRS_NORESET           (0x0000u)         /*  */
#define UART_URFCR_RFIRS_RESET             (0x0002u)         /* receive FIFO reset */
#define UART_URFCR_TFIRS_NORESET           (0x0000u)         /*  */
#define UART_URFCR_TFIRS_RESET             (0x0004u)         /* transmit FIFO reset */
#define UART_URFCR_RFITR_TRIG01            (0x0000u)         /* receive FIFO trigger level */
#define UART_URFCR_RFITR_TRIG04            (0x0040u)         /* receive FIFO trigger level */
#define UART_URFCR_RFITR_TRIG08            (0x0080u)         /* receive FIFO trigger level */
#define UART_URFCR_RFITR_TRIG014           (0x00C0u)         /* receive FIFO trigger level */


#define UART_URFCR_RMK(fien, rfirs, tfirs, rfitr)((Uint16)(\
    (UART_FMK(URFCR,FIEN, fien))|\
    (UART_FMK(URFCR,RFIRS, rfirs))|\
    (UART_FMK(URFCR,TFIRS, tfirs))|\
    (UART_FMK(URFCR,RFITR, rfitr))\
 )\
)

#define UART_URFCR_RMKS(fien_sym, rfirs_sym, tfirs_sym, rfitr_sym)((Uint16)(\
    (UART_FMKS(URFCR,FIEN, fien_sym))|\
    (UART_FMKS(URFCR,RFIRS, rfirs_sym))|\
    (UART_FMKS(URFCR,TFIRS, tfirs_sym))|\
    (UART_FMKS(URFCR,RFITR, rfitr_sym))\
 )\
)

/* URLSR Register field values */
#define UART_URLSR_DR_OFF                  (0x0000u)         /* data ready bit off */
#define UART_URLSR_DR_ON                   (0x0001u)         /* data ready bit on */
#define UART_URLSR_OE_OFF                  (0x0000u)         /* overrun error bit off */
#define UART_URLSR_OE_ON                   (0x0002u)         /* overrun bit on */
#define UART_URLSR_PE_OFF                  (0x0000u)         /* parity error bit off */
#define UART_URLSR_PE_ON                   (0x0004u)         /* parity error bit on */
#define UART_URLSR_FE_OFF                  (0x0000u)         /* frame error bit off */
#define UART_URLSR_FE_ON                   (0x0008u)         /* frame bit on */
#define UART_URLSR_BI_OFF                  (0x0000u)         /* break interrupt bit off */
#define UART_URLSR_BI_ON                   (0x0010u)         /* break interrupt bit on */
#define UART_URLSR_THRE_OFF                (0x0000u)         /* transmit holding register bit off */
#define UART_URLSR_THRE_ON                 (0x0020u)         /* transmit holding register bit bit on */
#define UART_URLSR_TEMT_OFF                (0x0000u)         /* transmitter empty bit off */
#define UART_URLSR_TEMT_ON                 (0x0040u)         /* transmitter empty bit on */
#define UART_URLSR_RFIER_OFF               (0x0000u)         /* error in RCVR FIFO bit off */
#define UART_URLSR_RFIER_ON                (0x0080u)         /* error in RCVR FIFO bit on */

#define UART_URLSR_RMK(dr, oe, pe, fe, bi, thre, temt, rfier)((Uint16)(\
    (UART_FMK(URLSR,DR, dr))|\
    (UART_FMK(URLSR,OE, oe))|\
    (UART_FMK(URLSR,PE, pe))|\
    (UART_FMK(URLSR,FE, fe))|\
    (UART_FMK(URLSR,BI, bi))|\
    (UART_FMK(URLSR,THRE, thre))|\
    (UART_FMK(URLSR,TEMT, temt))|\
    (UART_FMK(URLSR,RFIER, rfier))\
 )\
)

#define UART_URLSR_RMKS(dr_sym, oe_sym, pe_sym, fe_sym, bi_sym, thre_sym, temt_sym, rfier_sym)((Uint16)(\
    (UART_FMKS(URLSR,DR, dr_sym))|\
    (UART_FMKS(URLSR,OE, oe_sym))|\
    (UART_FMKS(URLSR,PE, pe_sym))|\
    (UART_FMKS(URLSR,FE, fe_sym))|\
    (UART_FMKS(URLSR,BI, bi_sym))|\
    (UART_FMKS(URLSR,THRE, thre_sym))|\
    (UART_FMKS(URLSR,TEMT, temt_sym))|\
    (UART_FMKS(URLSR,RFIER, rfier_sym))\
 )\
)

/* URIIR Register field values */
#define UART_URIIR_IP_ON                   (0x0001u)         /* interrupt pending bit on */
#define UART_URIIR_IP_OFF                  (0x0000u)         /* interrupt pending bit off */
#define UART_URIIR_IID_RCLINESTATUS        (0x0006u)         /* receive line status interrupt */
#define UART_URIIR_IID_RCDATA              (0x0004u)         /* receive line data interrupt */
#define UART_URIIR_IID_CHARTIMEOUT         (0x000Cu)         /* char time out interrupt */
#define UART_URIIR_IID_TXEMPTY             (0x0002u)         /* transmitter holding register empty interrupt */
#define UART_URIIR_FIENR_ON                (0x0080u)         /* FIFOs enabled bit on */
#define UART_URIIR_FIENR_OFF               (0x0000u)         /* FIFOs enabled bit off */


#define UART_URIIR_RMK(ip, iid, fienr)((Uint16)(\
    (UART_FMK(URIIR,IP, ip))|\
    (UART_FMK(URIIR,IID, iid))|\
    (UART_FMK(URIIR,FIENR, fienr))\
 )\
)

#define UART_URIIR_RMKS(ip_sym, iid_sym, fienr_sym)((Uint16)(\
    (UART_FMKS(URIIR,IP, ip_sym))|\
    (UART_FMKS(URIIR,IID, iid_sym))|\
    (UART_FMKS(URIIR,FIENR, fienr_sym))\
 )\
)

/* UAMSR Register field values */
#define UART_URMSR_DCTS_ONE            (0x0001u)         /* DCTS  bit is 1 */
#define UART_URMSR_DCTS_ZERO           (0x0000u)         /* DCTS  bit is 0 */
#define UART_URMSR_DDSR_ONE            (0x0002u)         /* DDSR  bit is 1 */
#define UART_URMSR_DDSR_ZERO           (0x0000u)         /* DDSR  bit is 0 */
#define UART_URMSR_TERI_ONE            (0x0004u)         /* TERI  bit is 1 */
#define UART_URMSR_TERI_ZERO           (0x0000u)         /* TERI  bit is 0 */
#define UART_URMSR_DCD_ONE             (0x0008u)         /* DCD  bit is 1 */
#define UART_URMSR_DCD_ZERO            (0x0000u)         /* DCD  bit is 0 */
#define UART_URMSR_CTS_ON              (0x0010u)         /* CTS  bit is 1 */
#define UART_URMSR_CTS_OFF             (0x0000u)         /* CTS  bit is 0 */
#define UART_URMSR_DSR_ON              (0x0020u)         /* DSR  bit is 1 */
#define UART_URMSR_DSR_OFF             (0x0000u)         /* DSR  bit is 0 */
#define UART_URMSR_RI_ON               (0x0040u)         /* RI  bit is 1 */
#define UART_URMSR_RI_OFF              (0x0000u)         /* RI  bit is 0 */
#define UART_URMSR_CD_ON               (0x0080u)         /* CD  bit is 1 */
#define UART_URMSR_CD_OFF              (0x0000u)         /* CD  bit is 0 */


#define UART_URMSR_RMK(dcts, ddsr, teri, dcd, cts, dsr, cd, ri)((Uint16)(\
    (UART_FMK(URMSR,DCTS, dcts))|\
    (UART_FMK(URMSR,DDSR, ddsr))|\
    (UART_FMK(URMSR,TERI, teri))|\
    (UART_FMK(URMSR,DCD, dcd))|\
    (UART_FMK(URMSR,CTS, cts))|\
    (UART_FMK(URMSR,DSR, dsr))|\
    (UART_FMK(URMSR,CD, cd))|\
    (UART_FMK(URMSR,RI, ri))\
 )\
)


#define UART_URMSR_RMKS(dcts_sym, ddsr_sym, teri_sym, dcd_sym, cts_sym, dsr_sym, cd_sym, ri_sym)((Uint16)(\
    (UART_FMKS(URMSR,DCTS, dcts_sym))|\
    (UART_FMKS(URMSR,DDSR, ddsr_sym))|\
    (UART_FMKS(URMSR,TERI, teri_sym))|\
    (UART_FMKS(URMSR,DCD, dcd_sym))|\
    (UART_FMKS(URMSR,CTS, cts_sym))|\
    (UART_FMKS(URMSR,DSR, dsr_sym))|\
    (UART_FMKS(URMSR,CD, cd_sym))|\
    (UART_FMKS(URMSR,RI, ri_sym))\
 )\
)

/* UAMCR Register field values */
#define UART_URMCR_DTR_ON              (0x0001u)         /* DTR  bit is 1 */
#define UART_URMCR_DTR_OFF             (0x0000u)         /* DTR  bit is 0 */
#define UART_URMCR_RTS_ON              (0x0002u)         /* RTS  bit is 1 */
#define UART_URMCR_RTS_OFF             (0x0000u)         /* RTS  bit is 0 */
#define UART_URMCR_OUT1_ON             (0x0004u)         /* OUT1  bit is 1 */
#define UART_URMCR_OUT1_OFF            (0x0000u)         /* OUT1  bit is 0 */
#define UART_URMCR_OUT2_ON             (0x0008u)         /* OUT2  bit is 1 */
#define UART_URMCR_OUT2_OFF            (0x0000u)         /* OUT2  bit is 0 */
#define UART_URMCR_LOOP_ON             (0x0010u)         /* LOOP  bit is 1 */
#define UART_URMCR_LOOP_OFF            (0x0000u)         /* LOOP  bit is 0 */
#define UART_URMCR_AFE_ON              (0x0020u)         /* autoflow control  bit is 1 */
#define UART_URMCR_AFE_OFF             (0x0000u)         /* autoflow control  bit is 0 */


#define UART_URMCR_RMK(dtr, rts, out1, out2, loop, afe)((Uint16)(\
    (UART_FMK(URMCR,DTR, dtr))|\
    (UART_FMK(URMCR,RTS, rts))|\
    (UART_FMK(URMCR,OUT1, out1))|\
    (UART_FMK(URMCR,OUT2, out2))|\
    (UART_FMK(URMCR,LOOP, loop))|\
    (UART_FMK(URMCR,AFE, afe))\
 )\
)

#define UART_URMCR_RMKS(dtr_sym, rts_sym, out1_sym, out2_sym, loop_sym, afe_sym)((Uint16)(\
    (UART_FMKS(URMCR,DTR, dtr_sym))|\
    (UART_FMKS(URMCR,RTS, rts_sym))|\
    (UART_FMKS(URMCR,OUT1, out1_sym))|\
    (UART_FMKS(URMCR,OUT2, out2_sym))|\
    (UART_FMKS(URMCR,LOOP, loop_sym))|\
    (UART_FMKS(URMCR,AFE, afe_sym))\
 )\
)

/****************************************\
* UART global typedef declarations
\****************************************/

/*****************************************************************************/
/* typedefs, enums and symbolic constants                                    */
/*****************************************************************************/

// TL16C550C UART interrupts
#define   UART_NOINT          0x00             // Disable all interrupts
#define   UART_RINT           0x01             // Enable rx data available interrupt
#define   UART_TINT           0x02             // Enable tx hold register empty interrupt
#define   UART_LSINT          0x04             // Enable rx line status interrupt
#define   UART_MSINT          0x08             // Enable modem status interrupt
#define   UART_ALLINT         0x0f             // Enable all interrupts

// TL16C550C UART autoBaud
#define   UART_AUTOBAUD            0x01           
#define   UART_NO_AUTOBAUD         0x00

// TL16C550C UART serial character word length
#define   UART_WORD5            0x00           // 5-bit 
#define   UART_WORD6            0x01           // 6-bit
#define   UART_WORD7            0x02           // 7-bit
#define   UART_WORD8            0x03            // 8-bit

// TL16C550C UART stop bits
#define   UART_STOP1                0x0             // 1 stop bit
#define   UART_STOP1_PLUS_HALF      0x4             // 1 1/2 stop bits
#define   UART_STOP2                0x4             // 2 stop bits

// TL16C550C UART flow control
#define   UART_NO_LOOPBACK    0x0
#define   UART_LOOPBACK       0x10

// TL16C550C UART parity select
/*  LCR		bit5 	bit4	bit3
 *  x		x		0		- No parity
 *  0		0		1		- odd parity
 *  0		1		1		- even parity
 *  1		0		1		- mark parity
 *  1		1		1		- space parity
 */
 
#define   UART_DISABLE_PARITY   0x0      //disable parity checking
#define   UART_ODD_PARITY       0x08   //enable odd parity
#define   UART_EVEN_PARITY      0x18   //enable even parity
#define   UART_MARK_PARITY      0x28   //enable mark parity
#define   UART_SPACE_PARITY     0x38   //enable space parity

#define   UART_PARITY_MASK      0x38   

// BaudRate for any other frequency is calculated using baudRates for 64MHz
// TL16C550C UART baud rates for clk = 64MHz
// divisor value = (64000000) / (16 x baud rate)

//        baud rate             divisor value
#define   UART_BAUD_150         26666
#define   UART_BAUD_300         13333
#define   UART_BAUD_600          6666
#define   UART_BAUD_1200         3333
#define   UART_BAUD_1800         2222
#define   UART_BAUD_2000         2000
#define   UART_BAUD_2400         1666
#define   UART_BAUD_3600         1111
#define   UART_BAUD_4800          833
#define   UART_BAUD_7200          555
#define   UART_BAUD_9600          416
#define   UART_BAUD_14400         277
#define   UART_BAUD_19200         208
#define   UART_BAUD_38400         104
#define   UART_BAUD_57600          69
#define   UART_BAUD_115200         34

// Following CLK_INPUT symbolic constants are provided so that user-code
//   already using them doesn't break
// UART clkInput (should not be greater than 150 MHz)
#define   UART_CLK_INPUT_20         20       // Input clock = 20MHz    
#define   UART_CLK_INPUT_40         40       // Input clock = 40MHz    
#define   UART_CLK_INPUT_60         60       // Input clock = 60MHz    
#define   UART_CLK_INPUT_80         80       // Input clock = 80MHz    
#define   UART_CLK_INPUT_100       100       // Input clock = 100MHz    
#define   UART_CLK_INPUT_120       120       // Input clock = 120MHz    
#define   UART_CLK_INPUT_140       140       // Input clock = 140MHz    

// TL16C550C UART FIFO control
#define   UART_FIFO_DISABLE       0x00
#define   UART_FIFO_DMA0_TRIG01   0x07    //DMA mode0 and trigger level 01
#define   UART_FIFO_DMA0_TRIG04   0x47    //DMA mode0 and trigger level 01
#define   UART_FIFO_DMA0_TRIG08   0x87    //DMA mode0 and trigger level 01
#define   UART_FIFO_DMA0_TRIG14   0xC7    //DMA mode0 and trigger level 01

#define   UART_FIFO_DMA1_TRIG01   0x0F    //DMA mode0 and trigger level 01
#define   UART_FIFO_DMA1_TRIG04   0x4F    //DMA mode0 and trigger level 01
#define   UART_FIFO_DMA1_TRIG08   0x8F    //DMA mode0 and trigger level 01
#define   UART_FIFO_DMA1_TRIG14   0xCF    //DMA mode0 and trigger level 01

//TL16C550C UART interrupt information as indicated
//by b0-b3 of UART_IIR_REG
#define   UART_NO_INTERRUPTPENDING  -1   //no interrupt pending
#define   UART_LSR_INTR             0x6  //rx line status - overrun error, parity error,  
                                         //framing error, or break interrupt. Read line  
                                         //status register to determine exact interrupt 
                                         //source.
#define   UART_RXRDY_INTR           0x4  //rx data available
#define   UART_CHAR_TIMEOUT         0xc  //character timeout
#define   UART_TXRDY_INTR           0x2  //tx holding register empty
#define   UART_MSR_INTR             0x0  //modem status - clear to send, data set ready,
                                         //ring indicator, or data carrier detect.
                                         //Read modem status register to exact interrupt 
                                         //source.

typedef struct
{
   Uint16              clkInput;
   Uint16              baud;
   Uint16              wordLength;
   Uint16              stopBits;
   Uint16              parity;
   Uint16              fifoControl;
   Uint16              loopBackEnable;
} UART_Setup;

typedef struct
{
   Uint16              dll;
   Uint16              dlm;
   Uint16              lcr;
   Uint16              fcr;
   Uint16              mcr;                //only for loopback
} UART_Config;

typedef struct
{
   void (*lsiAddr)(void);          // Receiver line status
   void (*rbfiAddr)(void);         // received data available
   void (*tbeiAddr)(void);         // transmiter holding register empty
   void (*dssiAddr)(void);         // modem status
   void (*ctoiAddr)(void);         // character time-out indication
} UART_IsrAddr;

#define    UART_EVT_LSI    0x03     // Receiver line status
#define    UART_EVT_RBFI   0x02     // received data available
#define    UART_EVT_CTOI   0x06     // character time-out indication
#define    UART_EVT_TBEI   0x01     // transmiter holding register empty
#define    UART_EVT_DSSI   0x00     // modem status

/* timeout error define in the polling functions */
#define TIMEOUT_ERROR      256

/****************************************\
* UART global function declarations
\****************************************/
CSLAPI void UART_setup(UART_Setup *Params);
CSLAPI void UART_config(UART_Config *Config);
CSLAPI void UART_getConfig(UART_Config *Config);
CSLAPI void UART_configArgs(Uint16 dll, Uint16 dlm, Uint16 lcr, Uint16 fcr, 
		            Uint16 mcr);
CSLAPI void UART_eventEnable(Uint16 ierMask);
CSLAPI void UART_eventDisable(Uint16 ierMask);
CSLAPI void UART_setCallback(UART_IsrAddr *isrAddr);
CSLAPI Uint16 UART_getEventId();
CSLAPI void UART_setupBaudRate(Uint16 clkInput, Uint16 baudRate);
CSLAPI CSLBool UART_read(char *pBuf, Uint16 length, Uint32 timeout);
CSLAPI CSLBool UART_write(char *pBuf, Uint16 length, Uint32 timeout);
CSLAPI CSLBool UART_fgetc(int *c, Uint32 timeout);
CSLAPI CSLBool UART_fputc(const int c, Uint32 timeout);
CSLAPI CSLBool UART_fgets(char* pBuf, Uint16 bufSize, Uint32 timeout);
CSLAPI CSLBool UART_fputs(const char* pBuf, Uint32 timeout);

/* private function */
interrupt void UART_intrDispatch(void);

/****************************************\
* UART global macro declarations
\****************************************/ 
#define UART_ctsOff            UART_FSET(URMSR,CTS,0)
#define UART_ctsOn             UART_FSET(URMSR,CTS,1)
#define UART_isCts             ((UART_FGET(URMSR,CTS)) ? 1 : 0)
 
#define UART_rtsOff            UART_FSET(URMCR,RTS,0)
#define UART_rtsOn             UART_FSET(URMCR,RTS,1)
#define UART_isRts             ((UART_FGET(URMCR,RTS)) ? 1 : 0)
 
#define UART_cdOff             UART_FSET(URMSR,CD,0)
#define UART_cdOn              UART_FSET(URMSR,CD,1)
#define UART_isCd              ((UART_FGET(URMSR,CD)) ? 1 : 0)
 
#define UART_riOff             UART_FSET(URMSR,RI,0)
#define UART_riOn              UART_FSET(URMSR,RI,1)
#define UART_isRi              ((UART_FGET(URMSR,RI)) ? 1 : 0)
 
#define UART_dsrOff            UART_FSET(URMSR,DSR,1)
#define UART_dsrOn             UART_FSET(URMSR,DSR,0)
#define UART_isDsr             ((UART_FGET(URMSR,DSR)) ? 1 : 0)
 
#define UART_dtrOff            UART_FSET(URMCR,DTR,0)
#define UART_dtrOn             UART_FSET(URMCR,DTR,1)
#define UART_isDtr             ((UART_FGET(URMCR,DTR)) ? 1 : 0)
 
 
/* configure HPIGPIO pins to UART control signals and configure the direction    */
/* of of those control signals as following:                                     */
/* HD0 - DTR - Input                                                             */
/* HD1 - RTS - Input                                                             */
/* HD2 - CTS - Output                                                            */
/* HD3 - DSR - Output                                                            */
/* HD4 - DCD - Output                                                            */
/* HD5 - RI - Output                                                             */
#define UART_flowCtrlInit0      {CHIP_FSET(XBSR,SP1,0); CHIP_FSET(XBSR,UART,1);\
  HPI_FSET(HGPIOEN,EN7,1);  HPI_RAOI(HGPIODIR,0xFFFC,0x0003,0x0000);}

/* configure HPIGPIO pins to UART control signals and configure the direction    */
/* of of those control signals as following:                                     */
/* HD0 - DTR - Output                                                            */
/* HD1 - RTS - Output                                                            */
/* HD2 - CTS - Input                                                             */
/* HD3 - DSR - Input                                                             */
/* HD4 - DCD - Input                                                             */
/* HD5 - RI - Input                                                              */
#define UART_flowCtrlInit1      {CHIP_FSET(XBSR,SP1,0); CHIP_FSET(XBSR,UART,1);\
 HPI_FSET(HGPIOEN,EN7,1); HPI_RAOI(HGPIODIR,0xFF03,0x00FC,0x0000);}
#define UART_reset()             UART_FSET(URPECR,URST,0)
#define UART_resetOff()          UART_FSET(URPECR,URST,1)


/****************************************\
* UART global variable declarations
\****************************************/ 

#elif (!(_UART_MOD))
	#error UART Hal Module Not Supported on Specified Target
#endif  /* _UART_SUPPORT  */

#endif /* _CSL_UART_H_ */                
/******************************************************************************\
* End of csl_uart.h
\******************************************************************************/


csl_uartdat.h/  1051539329  0     0     0       1399      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... UART
* FILENAME...... csl_UARTdat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... CSL  - Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       02/13/2002
*   MODIFIED:      10 Apri 2003 Added reference for CSL_UartData for .csldata size
*                               fix
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the UART module)
*       Reserved Area for UART Data 
*
*
\******************************************************************************/
#ifndef _UART_DATA_H_
#define _UART_DATA_H_

  #include <csl_std.h>

     #define CSL_UARTDATAINIT\
     { 0x0000u,\
       0x0000u,\
       0x0000u,\
       0x0000u,\
       0x0000u,\
       0x0000u,\
       0x0000u,\
    }
    typedef struct {
      Uint32 UART_isrDispatchTable[7];
    } CSL_UartDataObj;

extern CSL_UartDataObj CSL_UartData;

#define CSL_UART_DATA  CSL_UartData

#endif

csl_uarthal.h/  1049976940  0     0     0       40617     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... UART
* FILENAME...... csl_UARThal.h
* DATE CREATED.. Tue Jan 15 10:10:25 2002
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Tue Jan 15 10:10:25 2002 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL HAL interface file for the UART module 
*
* Registers covered:
*
*	 URRBR		- Receive Buffer Register
*	 URTHR		- Transmit Holding Register
*	 URIER		- Interrupt Enable Register
*	 URIIR		- Interrupt Identification Register
*	 URFCR		- FIFO Control Register
*	 URLCR		- Line Control Register
*	 URMCR		- Modem Control Register
*	 URLSR		- Line Status Register
*	 URMSR		- Modem Status Register
*	 URSCR		- Scratch Register
*	 URDLL		- Divisor Latch LSB Register
*	 URDLM		- Divisor Latch MSB Register
*	 URPIDL		- PID LSW
*	 URPIDH		- PID MSW
*	 URPECR		- Power and Emulation Control Register
*
\*************************************************************************/

#ifndef _CSL_UARTHAL_H_
#define _CSL_UARTHAL_H_

#include <csl_chiphal.h>

#if (_UART_SUPPORT) 

/*----------------------------------------------------------------*\
*	 UART scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _UART_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif


#define UART_HIGHBYTE_MASK         (0x00FFu)
#define UART_HIGHBYTE_SHIFT        (0x0008u)

/*----------------------------------------------------------------*\
*		 Address Macros			
\*----------------------------------------------------------------*/

/*--------------------- Register: URRBR -----------------------*/
#define _UART_URRBR_ADDR        (0x9c00u)
#define _UART_URRBR             PREG16(_UART_URRBR_ADDR)
#define URRBR                   _UART_URRBR


/*--------------------- Register: URTHR -----------------------*/
#define _UART_URTHR_ADDR        (0x9c00u)
#define _UART_URTHR             PREG16(_UART_URTHR_ADDR)
#define URTHR                   _UART_URTHR


/*--------------------- Register: URIER -----------------------*/
#define _UART_URIER_ADDR        (0x9c01u)
#define _UART_URIER	            PREG16(_UART_URIER_ADDR)
#define URIER                   _UART_URIER


/*--------------------- Register: URIIR -----------------------*/
#define _UART_URIIR_ADDR        (0x9c02u)
#define _UART_URIIR	            PREG16(_UART_URIIR_ADDR)
#define URIIR                   _UART_URIIR


/*--------------------- Register: URFCR -----------------------*/
#define _UART_URFCR_ADDR        (0x9c02u)
#define _UART_URFCR	            PREG16(_UART_URFCR_ADDR)
#define URFCR                   _UART_URFCR


/*--------------------- Register: URLCR -----------------------*/
#define _UART_URLCR_ADDR        (0x9c03u)
#define _UART_URLCR             PREG16(_UART_URLCR_ADDR)
#define URLCR                   _UART_URLCR


/*--------------------- Register: URMCR -----------------------*/
#define _UART_URMCR_ADDR        (0x9c04u)
#define _UART_URMCR             PREG16(_UART_URMCR_ADDR)
#define URMCR                   _UART_URMCR


/*--------------------- Register: URLSR -----------------------*/
#define _UART_URLSR_ADDR        (0x9c05u)
#define _UART_URLSR             PREG16(_UART_URLSR_ADDR)
#define URLSR                   _UART_URLSR


/*--------------------- Register: URMSR -----------------------*/
#define _UART_URMSR_ADDR        (0x9c06u)
#define _UART_URMSR	            PREG16(_UART_URMSR_ADDR)
#define URMSR                   _UART_URMSR


/*--------------------- Register: URSCR -----------------------*/
#define _UART_URSCR_ADDR        (0x9c07u)
#define _UART_URSCR             PREG16(_UART_URSCR_ADDR)
#define URSCR                   _UART_URSCR


/*--------------------- Register: URDLL -----------------------*/
//#define _UART_URDLL_ADDR		(0x9c08u)
#define _UART_URDLL_ADDR        (0x9c00u)
#define _UART_URDLL	            PREG16(_UART_URDLL_ADDR)
#define URDLL                   _UART_URDLL


/*--------------------- Register: URDLM -----------------------*/
//#define _UART_URDLM_ADDR		(0x9c09u)
#define _UART_URDLM_ADDR        (0x9c01u)
#define _UART_URDLM             PREG16(_UART_URDLM_ADDR)
#define URDLM                   _UART_URDLM


/*--------------------- Register: URPIDL -----------------------*/
#define _UART_URPIDL_ADDR       (0x9c0au)
#define _UART_URPIDL            PREG16(_UART_URPIDL_ADDR)
#define URPIDL                  _UART_URPIDL


/*--------------------- Register: URPIDH -----------------------*/
#define _UART_URPIDH_ADDR       (0x9c0bu)
#define _UART_URPIDH            PREG16(_UART_URPIDH_ADDR)
#define URPIDH                  _UART_URPIDH


/*--------------------- Register: URPECR -----------------------*/
#define _UART_URPECR_ADDR       (0x9c0cu)
#define _UART_URPECR            PREG16(_UART_URPECR_ADDR)
#define URPECR                  _UART_URPECR



/*----------------------------------------------------------------*\
*		 Register Macros		
\*----------------------------------------------------------------*/

#define UART_ADDR(Reg)                    _UART_##Reg##_ADDR
#define UART_RGET(Reg)                    _UART_##Reg##_GET
#define UART_RSET(Reg,Val)                _UART_##Reg##_SET(Val)
#define UART_FGET(Reg,Field)              _UART_##Reg##_FGET(Field)
#define UART_FSET(Reg,Field,Val)          _UART_##Reg##_FSET(Field, Val)
#define UART_FMK(Reg,Field,Val)           _UART_##Reg##_##Field##_MK(Val)
#define UART_RAOI(Reg,AND,OR,INV)		  _UART_##Reg##_AOI(AND,OR,INV)
#define UART_FAOI(Reg,Field,AND,OR,INV)	  _UART_##Reg##_FAOI(Field,AND,OR,INV)
#define UART_FMKS(Reg,Field,Sym)\
         _UART_##Reg##_##Field##_MK(UART_##Reg##_##Field##_##Sym)
#define UART_FSETS(Reg,Field,Sym)\
         _UART_##Reg##_FSET(Field,UART_##Reg##_##Field##_##Sym)


/*----------------------------------------------------------------*\
*		 UART HPIGPIO mapped Register Macros		
\*----------------------------------------------------------------*/
#define UART_HPIRGET(Reg)                _UART_##Reg##_GET
#define UART_HPIRSET(Reg,Val)            _UART_##Reg##_SET(Val)
#define UART_HPIFGET(Reg,Field)          _UART_##Reg##_FGET(Field)
#define UART_HPIFSET(Reg,Field,Val)      _UART_##Reg##_FSET(Field,Val)


/*----------------------------------------------------------------*\
*		 Non-handle Registers Macros		
\*----------------------------------------------------------------*/


/*--------------------- Register: URRBR -----------------------*/
#define _UART_URRBR_GET               _PREG_GET(_UART_URRBR_ADDR) 
#define _UART_URRBR_SET(Val)          _PREG_SET(_UART_URRBR_ADDR,Val)
#define _UART_URRBR_FGET(Field)       _PFIELD_GET(_UART_URRBR_ADDR, _UART_URRBR_##Field)
#define _UART_URRBR_FSET(Field,Val)	  _PFIELD_SET(_UART_URRBR_ADDR, _UART_URRBR_##Field, Val)
#define _UART_URRBR_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URRBR_ADDR,AND,OR,INV)
#define _UART_URRBR_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URRBR_ADDR, _UART_URRBR_##Field,AND,OR,INV)


/*--------------------- Register: URTHR -----------------------*/
#define _UART_URTHR_GET               _PREG_GET(_UART_URTHR_ADDR) 
#define _UART_URTHR_SET(Val)		  _PREG_SET(_UART_URTHR_ADDR,Val)
#define _UART_URTHR_FGET(Field)       _PFIELD_GET(_UART_URTHR_ADDR, _UART_URTHR_##Field)
#define _UART_URTHR_FSET(Field,Val)	  _PFIELD_SET(_UART_URTHR_ADDR, _UART_URTHR_##Field, Val)
#define _UART_URTHR_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URTHR_ADDR,AND,OR,INV)
#define _UART_URTHR_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URTHR_ADDR, _UART_URTHR_##Field,AND,OR,INV)


/*--------------------- Register: URIER -----------------------*/
#define _UART_URIER_GET               _PREG_GET(_UART_URIER_ADDR) 
#define _UART_URIER_SET(Val)          _PREG_SET(_UART_URIER_ADDR,Val)
#define _UART_URIER_FGET(Field)       _PFIELD_GET(_UART_URIER_ADDR, _UART_URIER_##Field)
#define _UART_URIER_FSET(Field,Val)	  _PFIELD_SET(_UART_URIER_ADDR, _UART_URIER_##Field, Val)
#define _UART_URIER_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URIER_ADDR,AND,OR,INV)
#define _UART_URIER_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URIER_ADDR, _UART_URIER_##Field,AND,OR,INV)


/*--------------------- Register: URIIR -----------------------*/
#define _UART_URIIR_GET               _PREG_GET(_UART_URIIR_ADDR) 
#define _UART_URIIR_FGET(Field)       _PFIELD_GET(_UART_URIIR_ADDR, _UART_URIIR_##Field)
//
// URIIR is a read only register so setting and mainipulation of this reg or the individual fields
// by these macros is not practical
//
//#define _UART_URIIR_SET(Val)          _PREG_SET(_UART_URIIR_ADDR,Val)
//#define _UART_URIIR_FSET(Field,Val)	  _PFIELD_SET(_UART_URIIR_ADDR, _UART_URIIR_##Field, Val)
//#define _UART_URIIR_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URIIR_ADDR,AND,OR,INV)
//#define _UART_URIIR_FAOI(Field,AND,OR,INV)\
//         _PFIELD_AOI(_UART_URIIR_ADDR, _UART_URIIR_##Field,AND,OR,INV)


/*--------------------- Register: URFCR -----------------------*/
#define _UART_URFCR_SET(Val)          _PREG_SET(_UART_URFCR_ADDR,Val)
//
// URFCR is a write only register so setting and mainipulation of individual fields
// by these macros is not practical
//
//#define _UART_URFCR_GET               _PREG_GET(_UART_URFCR_ADDR) 
//#define _UART_URFCR_FGET(Field)       _PFIELD_GET(_UART_URFCR_ADDR, _UART_URFCR_##Field)
//#define _UART_URFCR_FSET(Field,Val)	  _PFIELD_SET(_UART_URFCR_ADDR, _UART_URFCR_##Field, Val)
//#define _UART_URFCR_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URFCR_ADDR,AND,OR,INV)
//#define _UART_URFCR_FAOI(Field,AND,OR,INV)\
//         _PFIELD_AOI(_UART_URFCR_ADDR, _UART_URFCR_##Field,AND,OR,INV)


/*--------------------- Register: URLCR -----------------------*/
#define _UART_URLCR_GET               _PREG_GET(_UART_URLCR_ADDR) 
#define _UART_URLCR_SET(Val)          _PREG_SET(_UART_URLCR_ADDR,Val)
#define _UART_URLCR_FGET(Field)       _PFIELD_GET(_UART_URLCR_ADDR, _UART_URLCR_##Field)
#define _UART_URLCR_FSET(Field,Val)   _PFIELD_SET(_UART_URLCR_ADDR, _UART_URLCR_##Field, Val)
#define _UART_URLCR_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URLCR_ADDR,AND,OR,INV)
#define _UART_URLCR_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URLCR_ADDR, _UART_URLCR_##Field,AND,OR,INV)


/*--------------------- Register: URMCR -----------------------*/
#define _UART_URMCR_GET               _PREG_GET(_UART_URMCR_ADDR) 
#define _UART_URMCR_SET(Val)          _PREG_SET(_UART_URMCR_ADDR,Val)
#define _UART_URMCR_FGET(Field)       _PFIELD_GET(_UART_URMCR_ADDR, _UART_URMCR_##Field)
#define _UART_URMCR_FSET(Field,Val)   _PFIELD_SET(_UART_URMCR_ADDR, _UART_URMCR_##Field, Val)
#define _UART_URMCR_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URMCR_ADDR,AND,OR,INV)
#define _UART_URMCR_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URMCR_ADDR, _UART_URMCR_##Field,AND,OR,INV)


/*--------------------- Register: URLSR -----------------------*/
#define _UART_URLSR_GET               _PREG_GET(_UART_URLSR_ADDR) 
#define _UART_URLSR_SET(Val)          _PREG_SET(_UART_URLSR_ADDR,Val)
#define _UART_URLSR_FGET(Field)       _PFIELD_GET(_UART_URLSR_ADDR, _UART_URLSR_##Field)
#define _UART_URLSR_FSET(Field,Val)	  _PFIELD_SET(_UART_URLSR_ADDR, _UART_URLSR_##Field, Val)
#define _UART_URLSR_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URLSR_ADDR,AND,OR,INV)
#define _UART_URLSR_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URLSR_ADDR, _UART_URLSR_##Field,AND,OR,INV)


/*--------------------- Register: URMSR -----------------------*/
#define _UART_URMSR_GET               _PREG_GET(_UART_URMSR_ADDR) 
#define _UART_URMSR_SET(Val)          _PREG_SET(_UART_URMSR_ADDR,Val)
#define _UART_URMSR_FGET(Field)       _PFIELD_GET(_UART_URMSR_ADDR, _UART_URMSR_##Field)
#define _UART_URMSR_FSET(Field,Val)	  _PFIELD_SET(_UART_URMSR_ADDR, _UART_URMSR_##Field, Val)
#define _UART_URMSR_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URMSR_ADDR,AND,OR,INV)
#define _UART_URMSR_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URMSR_ADDR, _UART_URMSR_##Field,AND,OR,INV)


/*--------------------- Register: URSCR -----------------------*/
#define _UART_URSCR_GET               _PREG_GET(_UART_URSCR_ADDR) 
#define _UART_URSCR_SET(Val)          _PREG_SET(_UART_URSCR_ADDR,Val)
#define _UART_URSCR_FGET(Field)       _PFIELD_GET(_UART_URSCR_ADDR, _UART_URSCR_##Field)
#define _UART_URSCR_FSET(Field,Val)	  _PFIELD_SET(_UART_URSCR_ADDR, _UART_URSCR_##Field, Val)
#define _UART_URSCR_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URSCR_ADDR,AND,OR,INV)
#define _UART_URSCR_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URSCR_ADDR, _UART_URSCR_##Field,AND,OR,INV)


/*--------------------- Register: URDLL -----------------------*/
#define _UART_URDLL_GET               _PREG_GET(_UART_URDLL_ADDR) 
#define _UART_URDLL_SET(Val)          _PREG_SET(_UART_URDLL_ADDR,Val)
#define _UART_URDLL_FGET(Field)       _PFIELD_GET(_UART_URDLL_ADDR, _UART_URDLL_##Field)
#define _UART_URDLL_FSET(Field,Val)	  _PFIELD_SET(_UART_URDLL_ADDR, _UART_URDLL_##Field, Val)
#define _UART_URDLL_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URDLL_ADDR,AND,OR,INV)
#define _UART_URDLL_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URDLL_ADDR, _UART_URDLL_##Field,AND,OR,INV)


/*--------------------- Register: URDLM -----------------------*/
#define _UART_URDLM_GET               _PREG_GET(_UART_URDLM_ADDR) 
#define _UART_URDLM_SET(Val)          _PREG_SET(_UART_URDLM_ADDR,Val)
#define _UART_URDLM_FGET(Field)       _PFIELD_GET(_UART_URDLM_ADDR, _UART_URDLM_##Field)
#define _UART_URDLM_FSET(Field,Val)	  _PFIELD_SET(_UART_URDLM_ADDR, _UART_URDLM_##Field, Val)
#define _UART_URDLM_AOI(AND,OR,INV)	  _PREG_AOI(_UART_URDLM_ADDR,AND,OR,INV)
#define _UART_URDLM_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URDLM_ADDR, _UART_URDLM_##Field,AND,OR,INV)


/*--------------------- Register: URPIDL -----------------------*/
#define _UART_URPIDL_GET              _PREG_GET(_UART_URPIDL_ADDR) 
#define _UART_URPIDL_SET(Val)         _PREG_SET(_UART_URPIDL_ADDR,Val)
#define _UART_URPIDL_FGET(Field)      _PFIELD_GET(_UART_URPIDL_ADDR, _UART_URPIDL_##Field)
#define _UART_URPIDL_FSET(Field,Val)  _PFIELD_SET(_UART_URPIDL_ADDR, _UART_URPIDL_##Field, Val)
#define _UART_URPIDL_AOI(AND,OR,INV)  _PREG_AOI(_UART_URPIDL_ADDR,AND,OR,INV)
#define _UART_URPIDL_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URPIDL_ADDR, _UART_URPIDL_##Field,AND,OR,INV)


/*--------------------- Register: URPIDH -----------------------*/
#define _UART_URPIDH_GET              _PREG_GET(_UART_URPIDH_ADDR) 
#define _UART_URPIDH_SET(Val)         _PREG_SET(_UART_URPIDH_ADDR,Val)
#define _UART_URPIDH_FGET(Field)      _PFIELD_GET(_UART_URPIDH_ADDR, _UART_URPIDH_##Field)
#define _UART_URPIDH_FSET(Field,Val)  _PFIELD_SET(_UART_URPIDH_ADDR, _UART_URPIDH_##Field, Val)
#define _UART_URPIDH_AOI(AND,OR,INV)  _PREG_AOI(_UART_URPIDH_ADDR,AND,OR,INV)
#define _UART_URPIDH_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URPIDH_ADDR, _UART_URPIDH_##Field,AND,OR,INV)


/*--------------------- Register: URPECR -----------------------*/
#define _UART_URPECR_GET              _PREG_GET(_UART_URPECR_ADDR) 
#define _UART_URPECR_SET(Val)         _PREG_SET(_UART_URPECR_ADDR,Val)
#define _UART_URPECR_FGET(Field)      _PFIELD_GET(_UART_URPECR_ADDR, _UART_URPECR_##Field)
#define _UART_URPECR_FSET(Field,Val)  _PFIELD_SET(_UART_URPECR_ADDR, _UART_URPECR_##Field, Val)
#define _UART_URPECR_AOI(AND,OR,INV)  _PREG_AOI(_UART_URPECR_ADDR,AND,OR,INV)
#define _UART_URPECR_FAOI(Field,AND,OR,INV)\
         _PFIELD_AOI(_UART_URPECR_ADDR, _UART_URPECR_##Field,AND,OR,INV)


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the URMSR register			
\*----------------------------------------------------------------*/
/******************************************************************************\
* 
*
* Fields:
* (RW)   _UART_URMSR_DCTS 
* (RW)   _UART_URMSR_DDSR 
* (RW)   _UART_URMSR_TERI 
* (RW)   _UART_URMSR_DCD 
* (RW)   _UART_URMSR_CTS 
* (RW)   _UART_URMSR_DSR 
* (RW)   _UART_URMSR_RI 
* (RW)   _UART_URMSR_CD 
*
\******************************************************************************/
 
/*----------------------------------------------------------------*\
*   (RW)  _UART_URMSR_DCTS: 
\*----------------------------------------------------------------*/
 
#define _UART_URMSR_DCTS_SHIFT  (000000u)
#define _UART_URMSR_DCTS_MK(n)  (((Uint16)(n) & 0x0001u) << _UART_URMSR_DCTS_SHIFT)
#define _UART_URMSR_DCTS_MASK  (_UART_URMSR_DCTS_MK(0x0001u))
#define _UART_URMSR_DCTS_CLR  (~(_UART_URMSR_DCTS_MASK))
/*----------------------------------------------------------------*\
*   (RW)  _UART_URMSR_DDSR: 
\*----------------------------------------------------------------*/
 
#define _UART_URMSR_DDSR_SHIFT  (000001u)
#define _UART_URMSR_DDSR_MK(n)  (((Uint16)(n) & 0x0001u) << _UART_URMSR_DDSR_SHIFT)
#define _UART_URMSR_DDSR_MASK  (_UART_URMSR_DDSR_MK(0x0001u))
#define _UART_URMSR_DDSR_CLR  (~(_UART_URMSR_DDSR_MASK))
 
/*----------------------------------------------------------------*\
*   (RW)  _UART_URMSR_TERI: 
\*----------------------------------------------------------------*/
 
#define _UART_URMSR_TERI_SHIFT  (000002u)
#define _UART_URMSR_TERI_MK(n)  (((Uint16)(n) & 0x0001u) << _UART_URMSR_TERI_SHIFT)
#define _UART_URMSR_TERI_MASK  (_UART_URMSR_TERI_MK(0x0001u))
#define _UART_URMSR_TERI_CLR  (~(_UART_URMSR_TERI_MASK))
 
/*----------------------------------------------------------------*\
*   (RW)  _UART_URMSR_DCD: 
\*----------------------------------------------------------------*/
 
#define _UART_URMSR_DCD_SHIFT  (000003u)
#define _UART_URMSR_DCD_MK(n)  (((Uint16)(n) & 0x0001u) << _UART_URMSR_DCD_SHIFT)
#define _UART_URMSR_DCD_MASK  (_UART_URMSR_DCD_MK(0x0001u))
#define _UART_URMSR_DCD_CLR  (~(_UART_URMSR_DCD_MASK))
 
/*----------------------------------------------------------------*\
*   (RW)  _UART_URMSR_CTS: 
\*----------------------------------------------------------------*/
 
#define _UART_URMSR_CTS_SHIFT  (000004u)
#define _UART_URMSR_CTS_MK(n)  (((Uint16)(n) & 0x0001u) << _UART_URMSR_CTS_SHIFT)
#define _UART_URMSR_CTS_MASK  (_UART_URMSR_CTS_MK(0x0001u))
#define _UART_URMSR_CTS_CLR      (~(_UART_URMSR_CTS_MASK))
/*----------------------------------------------------------------*\
*   (RW)  _UART_URMSR_DSR: 
\*----------------------------------------------------------------*/
 
#define _UART_URMSR_DSR_SHIFT  (000005u)
#define _UART_URMSR_DSR_MK(n)  (((Uint16)(n) & 0x0001u) << _UART_URMSR_DSR_SHIFT)
#define _UART_URMSR_DSR_MASK  (_UART_URMSR_DSR_MK(0x0001u))
#define _UART_URMSR_DSR_CLR      (~(_UART_URMSR_DSR_MASK))
 
/*----------------------------------------------------------------*\
*   (RW)  _UART_URMSR_RI: 
\*----------------------------------------------------------------*/
 
#define _UART_URMSR_RI_SHIFT  (000006u)
#define _UART_URMSR_RI_MK(n)  (((Uint16)(n) & 0x0001u) << _UART_URMSR_RI_SHIFT)
#define _UART_URMSR_RI_MASK      (_UART_URMSR_RI_MK(0x0001u))
#define _UART_URMSR_RI_CLR      (~(_UART_URMSR_RI_MASK))
 
/*----------------------------------------------------------------*\
*   (RW)  _UART_URMSR_CD: 
\*----------------------------------------------------------------*/
 
#define _UART_URMSR_CD_SHIFT  (000007u)
#define _UART_URMSR_CD_MK(n)  (((Uint16)(n) & 0x0001u) << _UART_URMSR_CD_SHIFT)
#define _UART_URMSR_CD_MASK      (_UART_URMSR_CD_MK(0x0001u))
#define _UART_URMSR_CD_CLR      (~(_UART_URMSR_CD_MASK))

 
/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the URLSR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
*
* Fields:
*	(R)   _UART_URLSR_DR	
*	(R)   _UART_URLSR_OE	
*	(R)   _UART_URLSR_PE	
*	(R)   _UART_URLSR_FE	
*	(R)   _UART_URLSR_BI	
*	(R)   _UART_URLSR_THRE	
*	(R)   _UART_URLSR_TEMT	
*	(R)   _UART_URLSR_ERFI	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _UART_URLSR_DR:	
\*----------------------------------------------------------------*/

#define _UART_URLSR_DR_SHIFT		(000000u)
#define _UART_URLSR_DR_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLSR_DR_SHIFT)
#define _UART_URLSR_DR_MASK		(_UART_URLSR_DR_MK(0x0001u))
#define _UART_URLSR_DR_CLR		(~(_UART_URLSR_DR_MASK))



/*----------------------------------------------------------------*\
*   (R)  _UART_URLSR_OE:	
\*----------------------------------------------------------------*/

#define _UART_URLSR_OE_SHIFT		(0x0001u)
#define _UART_URLSR_OE_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLSR_OE_SHIFT)
#define _UART_URLSR_OE_MASK		(_UART_URLSR_OE_MK(0x0001u))
#define _UART_URLSR_OE_CLR		(~(_UART_URLSR_OE_MASK))



/*----------------------------------------------------------------*\
*   (R)  _UART_URLSR_PE:	
\*----------------------------------------------------------------*/

#define _UART_URLSR_PE_SHIFT		(0x0002u)
#define _UART_URLSR_PE_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLSR_PE_SHIFT)
#define _UART_URLSR_PE_MASK		(_UART_URLSR_PE_MK(0x0001u))
#define _UART_URLSR_PE_CLR		(~(_UART_URLSR_PE_MASK))



/*----------------------------------------------------------------*\
*   (R)  _UART_URLSR_FE:	
\*----------------------------------------------------------------*/

#define _UART_URLSR_FE_SHIFT		(0x0003u)
#define _UART_URLSR_FE_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLSR_FE_SHIFT)
#define _UART_URLSR_FE_MASK		(_UART_URLSR_FE_MK(0x0001u))
#define _UART_URLSR_FE_CLR		(~(_UART_URLSR_FE_MASK))



/*----------------------------------------------------------------*\
*   (R)  _UART_URLSR_BI:	
\*----------------------------------------------------------------*/

#define _UART_URLSR_BI_SHIFT		(0x0004u)
#define _UART_URLSR_BI_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLSR_BI_SHIFT)
#define _UART_URLSR_BI_MASK		(_UART_URLSR_BI_MK(0x0001u))
#define _UART_URLSR_BI_CLR		(~(_UART_URLSR_BI_MASK))



/*----------------------------------------------------------------*\
*   (R)  _UART_URLSR_THRE:	
\*----------------------------------------------------------------*/

#define _UART_URLSR_THRE_SHIFT		(0x0005u)
#define _UART_URLSR_THRE_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLSR_THRE_SHIFT)
#define _UART_URLSR_THRE_MASK		(_UART_URLSR_THRE_MK(0x0001u))
#define _UART_URLSR_THRE_CLR		(~(_UART_URLSR_THRE_MASK))



/*----------------------------------------------------------------*\
*   (R)  _UART_URLSR_TEMT:	
\*----------------------------------------------------------------*/

#define _UART_URLSR_TEMT_SHIFT		(0x0006u)
#define _UART_URLSR_TEMT_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLSR_TEMT_SHIFT)
#define _UART_URLSR_TEMT_MASK		(_UART_URLSR_TEMT_MK(0x0001u))
#define _UART_URLSR_TEMT_CLR		(~(_UART_URLSR_TEMT_MASK))



/*----------------------------------------------------------------*\
*   (R)  _UART_URLSR_ERFI:	
\*----------------------------------------------------------------*/

#define _UART_URLSR_ERFI_SHIFT		(0x0007u)
#define _UART_URLSR_ERFI_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLSR_ERFI_SHIFT)
#define _UART_URLSR_ERFI_MASK		(_UART_URLSR_ERFI_MK(0x0001u))
#define _UART_URLSR_ERFI_CLR		(~(_UART_URLSR_ERFI_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the URLCR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _UART_URLCR	 - Note: Add description here
*
* Fields:
*	(RW)   _UART_URLCR_WLS	
*	(RW)   _UART_URLCR_STB	
*	(RW)   _UART_URLCR_PEN	
*	(RW)   _UART_URLCR_EPS	
*	(RW)   _UART_URLCR_STPAR	
*	(RW)   _UART_URLCR_DLAB	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _UART_URLCR_WLS:	
\*----------------------------------------------------------------*/

#define _UART_URLCR_WLS_SHIFT		(000000u)
#define _UART_URLCR_WLS_MK(n)		(((Uint16)(n) & 0x0003u) << _UART_URLCR_WLS_SHIFT)
#define _UART_URLCR_WLS_MASK		(_UART_URLCR_WLS_MK(0x0003u))
#define _UART_URLCR_WLS_CLR		(~(_UART_URLCR_WLS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _UART_URLCR_STB:	
\*----------------------------------------------------------------*/

#define _UART_URLCR_STB_SHIFT		(0x0002u)
#define _UART_URLCR_STB_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLCR_STB_SHIFT)
#define _UART_URLCR_STB_MASK		(_UART_URLCR_STB_MK(0x0001u))
#define _UART_URLCR_STB_CLR		(~(_UART_URLCR_STB_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _UART_URLCR_PEN:	
\*----------------------------------------------------------------*/

#define _UART_URLCR_PEN_SHIFT		(0x0003u)
#define _UART_URLCR_PEN_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLCR_PEN_SHIFT)
#define _UART_URLCR_PEN_MASK		(_UART_URLCR_PEN_MK(0x0001u))
#define _UART_URLCR_PEN_CLR		(~(_UART_URLCR_PEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _UART_URLCR_EPS:	
\*----------------------------------------------------------------*/

#define _UART_URLCR_EPS_SHIFT		(0x0004u)
#define _UART_URLCR_EPS_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLCR_EPS_SHIFT)
#define _UART_URLCR_EPS_MASK		(_UART_URLCR_EPS_MK(0x0001u))
#define _UART_URLCR_EPS_CLR		(~(_UART_URLCR_EPS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _UART_URLCR_STPAR:	
\*----------------------------------------------------------------*/

#define _UART_URLCR_STPAR_SHIFT		(0x0005u)
#define _UART_URLCR_STPAR_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLCR_STPAR_SHIFT)
#define _UART_URLCR_STPAR_MASK		(_UART_URLCR_STPAR_MK(0x0001u))
#define _UART_URLCR_STPAR_CLR		(~(_UART_URLCR_STPAR_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _UART_URLCR_BC:	
\*----------------------------------------------------------------*/

#define _UART_URLCR_BC_SHIFT		(0x0006u)
#define _UART_URLCR_BC_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLCR_BC_SHIFT)
#define _UART_URLCR_BC_MASK		    (_UART_URLCR_BC_MK(0x0001u))
#define _UART_URLCR_BC_CLR		    (~(_UART_URLCR_BC_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _UART_URLCR_DLAB:	
\*----------------------------------------------------------------*/

#define _UART_URLCR_DLAB_SHIFT		(0x0007u)
#define _UART_URLCR_DLAB_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URLCR_DLAB_SHIFT)
#define _UART_URLCR_DLAB_MASK		(_UART_URLCR_DLAB_MK(0x0001u))
#define _UART_URLCR_DLAB_CLR		(~(_UART_URLCR_DLAB_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the URMCR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _UART_URMCR	 - Note: Add description here
*
* Fields:
*	(RW)   _UART_URMCR_DTR	
*	(RW)   _UART_URMCR_RTS	
*	(RW)   _UART_URMCR_OUT1	
*	(RW)   _UART_URMCR_OUT2	
*	(RW)   _UART_URMCR_LOOP	
*	(RW)   _UART_URMCR_AFE
*
\******************************************************************************/

/*----------------------------------------------------------------*\
*   (RW)  _UART_URMCR_DTR:	
\*----------------------------------------------------------------*/

#define _UART_URMCR_DTR_SHIFT		(0x0000u)
#define _UART_URMCR_DTR_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URMCR_DTR_SHIFT)
#define _UART_URMCR_DTR_MASK		(_UART_URMCR_DTR_MK(0x0001u))
#define _UART_URMCR_DTR_CLR		    (~(_UART_URMCR_DTR_MASK))
/*----------------------------------------------------------------*\
*   (RW)  _UART_URMCR_RTS:	
\*----------------------------------------------------------------*/

#define _UART_URMCR_RTS_SHIFT		(0x0001u)
#define _UART_URMCR_RTS_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URMCR_RTS_SHIFT)
#define _UART_URMCR_RTS_MASK		(_UART_URMCR_RTS_MK(0x0001u))
#define _UART_URMCR_RTS_CLR		    (~(_UART_URMCR_RTS_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _UART_URMCR_OUT1:	
\*----------------------------------------------------------------*/

#define _UART_URMCR_OUT1_SHIFT		(0x0002u)
#define _UART_URMCR_OUT1_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URMCR_OUT1_SHIFT)
#define _UART_URMCR_OUT1_MASK		(_UART_URMCR_OUT1_MK(0x0001u))
#define _UART_URMCR_OUT1_CLR		    (~(_UART_URMCR_OUT1_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _UART_URMCR_OUT2:	
\*----------------------------------------------------------------*/

#define _UART_URMCR_OUT2_SHIFT		(0x0003u)
#define _UART_URMCR_OUT2_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URMCR_OUT2_SHIFT)
#define _UART_URMCR_OUT2_MASK		(_UART_URMCR_OUT2_MK(0x0001u))
#define _UART_URMCR_OUT2_CLR		    (~(_UART_URMCR_OUT2_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _UART_URMCR_LOOP:	
\*----------------------------------------------------------------*/

#define _UART_URMCR_LOOP_SHIFT		(0x0004u)
#define _UART_URMCR_LOOP_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URMCR_LOOP_SHIFT)
#define _UART_URMCR_LOOP_MASK		(_UART_URMCR_LOOP_MK(0x0001u))
#define _UART_URMCR_LOOP_CLR		(~(_UART_URMCR_LOOP_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _UART_URMCR_AFE:	
\*----------------------------------------------------------------*/

#define _UART_URMCR_AFE_SHIFT		(0x0005u)
#define _UART_URMCR_AFE_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URMCR_AFE_SHIFT)
#define _UART_URMCR_AFE_MASK		(_UART_URMCR_AFE_MK(0x0001u))
#define _UART_URMCR_AFE_CLR		    (~(_UART_URMCR_AFE_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the URIIR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _UART_URIIR	 - Note: Add description here
*
* Fields:
*	(R)   _UART_URIIR_INTRP	
*	(R)   _UART_URIIR_INTRID1	
*	(R)   _UART_URIIR_INTRID2	
*	(R)   _UART_URIIR_INTRID3	
*	(R)   _UART_URIIR_FIENR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _UART_URIIR_INTRP:	
\*----------------------------------------------------------------*/

#define _UART_URIIR_INTRP_SHIFT		(000000u)
#define _UART_URIIR_INTRP_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URIIR_INTRP_SHIFT)
#define _UART_URIIR_INTRP_MASK		(_UART_URIIR_INTRP_MK(0x0001u))
#define _UART_URIIR_INTRP_CLR		(~(_UART_URIIR_INTRP_MASK))



/*----------------------------------------------------------------*\
*   (R)  _UART_URIIR_INTRID1:	
\*----------------------------------------------------------------*/

#define _UART_URIIR_INTRID1_SHIFT		(0x0001u)
#define _UART_URIIR_INTRID1_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URIIR_INTRID1_SHIFT)
#define _UART_URIIR_INTRID1_MASK		(_UART_URIIR_INTRID1_MK(0x0001u))
#define _UART_URIIR_INTRID1_CLR		(~(_UART_URIIR_INTRID1_MASK))



/*----------------------------------------------------------------*\
*   (R)  _UART_URIIR_INTRID2:	
\*----------------------------------------------------------------*/

#define _UART_URIIR_INTRID2_SHIFT		(0x0002u)
#define _UART_URIIR_INTRID2_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URIIR_INTRID2_SHIFT)
#define _UART_URIIR_INTRID2_MASK		(_UART_URIIR_INTRID2_MK(0x0001u))
#define _UART_URIIR_INTRID2_CLR		(~(_UART_URIIR_INTRID2_MASK))



/*----------------------------------------------------------------*\
*   (R)  _UART_URIIR_INTRID3:	
\*----------------------------------------------------------------*/

#define _UART_URIIR_INTRID3_SHIFT		(0x0003u)
#define _UART_URIIR_INTRID3_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URIIR_INTRID3_SHIFT)
#define _UART_URIIR_INTRID3_MASK		(_UART_URIIR_INTRID3_MK(0x0001u))
#define _UART_URIIR_INTRID3_CLR		(~(_UART_URIIR_INTRID3_MASK))



/*----------------------------------------------------------------*\
*   (R)  _UART_URIIR_FIENR:	
\*----------------------------------------------------------------*/

#define _UART_URIIR_FIENR_SHIFT		(0x0006u)
#define _UART_URIIR_FIENR_MK(n)		(((Uint16)(n) & 0x0003u) << _UART_URIIR_FIENR_SHIFT)
#define _UART_URIIR_FIENR_MASK		(_UART_URIIR_FIENR_MK(0x0003u))
#define _UART_URIIR_FIENR_CLR		(~(_UART_URIIR_FIENR_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the URIER register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _UART_URIER	 - Note: Add description here
*
* Fields:
*	(RW)   _UART_URIER_ERBI	
*	(RW)   _UART_URIER_ETBEI	
*	(RW)   _UART_URIER_ELSI	
*	(RW)   _UART_URIER_EDSSI	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _UART_URIER_ERBI:	
\*----------------------------------------------------------------*/

#define _UART_URIER_ERBI_SHIFT		(000000u)
#define _UART_URIER_ERBI_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URIER_ERBI_SHIFT)
#define _UART_URIER_ERBI_MASK		(_UART_URIER_ERBI_MK(0x0001u))
#define _UART_URIER_ERBI_CLR		(~(_UART_URIER_ERBI_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _UART_URIER_ETBEI:	
\*----------------------------------------------------------------*/

#define _UART_URIER_ETBEI_SHIFT		(0x0001u)
#define _UART_URIER_ETBEI_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URIER_ETBEI_SHIFT)
#define _UART_URIER_ETBEI_MASK		(_UART_URIER_ETBEI_MK(0x0001u))
#define _UART_URIER_ETBEI_CLR		(~(_UART_URIER_ETBEI_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _UART_URIER_ELSI:	
\*----------------------------------------------------------------*/

#define _UART_URIER_ELSI_SHIFT		(0x0002u)
#define _UART_URIER_ELSI_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URIER_ELSI_SHIFT)
#define _UART_URIER_ELSI_MASK		(_UART_URIER_ELSI_MK(0x0001u))
#define _UART_URIER_ELSI_CLR		(~(_UART_URIER_ELSI_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _UART_URIER_EDSSI:	
\*----------------------------------------------------------------*/

#define _UART_URIER_EDSSI_SHIFT		(0x0003u)
#define _UART_URIER_EDSSI_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URIER_EDSSI_SHIFT)
#define _UART_URIER_EDSSI_MASK		(_UART_URIER_EDSSI_MK(0x0001u))
#define _UART_URIER_EDSSI_CLR		(~(_UART_URIER_EDSSI_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the URFCR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _UART_URFCR	 - Note: Add description here
*
* Fields:
*	(W)   _UART_URFCR_FIEN	
*	(W)   _UART_URFCR_RFIRS	
*	(W)   _UART_URFCR_TFIRS	
*	(W)   _UART_URFCR_DMAMD	
*	(W)   _UART_URFCR_RFITR	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (W)  _UART_URFCR_FIEN:	
\*----------------------------------------------------------------*/

#define _UART_URFCR_FIEN_SHIFT		(000000u)
#define _UART_URFCR_FIEN_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URFCR_FIEN_SHIFT)
#define _UART_URFCR_FIEN_MASK		(_UART_URFCR_FIEN_MK(0x0001u))
#define _UART_URFCR_FIEN_CLR		(~(_UART_URFCR_FIEN_MASK))



/*----------------------------------------------------------------*\
*   (W)  _UART_URFCR_RFIRS:	
\*----------------------------------------------------------------*/

#define _UART_URFCR_RFIRS_SHIFT		(0x0001u)
#define _UART_URFCR_RFIRS_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URFCR_RFIRS_SHIFT)
#define _UART_URFCR_RFIRS_MASK		(_UART_URFCR_RFIRS_MK(0x0001u))
#define _UART_URFCR_RFIRS_CLR		(~(_UART_URFCR_RFIRS_MASK))



/*----------------------------------------------------------------*\
*   (W)  _UART_URFCR_TFIRS:	
\*----------------------------------------------------------------*/

#define _UART_URFCR_TFIRS_SHIFT		(0x0002u)
#define _UART_URFCR_TFIRS_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URFCR_TFIRS_SHIFT)
#define _UART_URFCR_TFIRS_MASK		(_UART_URFCR_TFIRS_MK(0x0001u))
#define _UART_URFCR_TFIRS_CLR		(~(_UART_URFCR_TFIRS_MASK))



/*----------------------------------------------------------------*\
*   (W)  _UART_URFCR_DMAMD:	
\*----------------------------------------------------------------*/

#define _UART_URFCR_DMAMD_SHIFT		(0x0003u)
#define _UART_URFCR_DMAMD_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URFCR_DMAMD_SHIFT)
#define _UART_URFCR_DMAMD_MASK		(_UART_URFCR_DMAMD_MK(0x0001u))
#define _UART_URFCR_DMAMD_CLR		(~(_UART_URFCR_DMAMD_MASK))



/*----------------------------------------------------------------*\
*   (W)  _UART_URFCR_RFITR:	
\*----------------------------------------------------------------*/

#define _UART_URFCR_RFITR_SHIFT		(0x0006u)
#define _UART_URFCR_RFITR_MK(n)		(((Uint16)(n) & 0x0003u) << _UART_URFCR_RFITR_SHIFT)
#define _UART_URFCR_RFITR_MASK		(_UART_URFCR_RFITR_MK(0x0003u))
#define _UART_URFCR_RFITR_CLR		(~(_UART_URFCR_RFITR_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the URMCR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _UART_URPECR	 - Note: Add description here
*
* Fields:
*	(RW)   _UART_URPECR_URST	
*	(RW)   _UART_URPECR_SOFT	
*	(RW)   _UART_URPECR_FREE	
*
\******************************************************************************/

/*----------------------------------------------------------------*\
*   (RW)  _UART_URPECR_FREE:	
\*----------------------------------------------------------------*/
#define _UART_URPECR_FREE_SHIFT		(0x0000u)
#define _UART_URPECR_FREE_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URPECR_FREE_SHIFT)
#define _UART_URPECR_FREE_MASK		(_UART_URPECR_FREE_MK(0x0001u))
#define _UART_URPECR_FREE_CLR		(~(_UART_URPECR_FREE_MASK))

/*----------------------------------------------------------------*\
*   (RW)  _UART_URPECR_URST:	
\*----------------------------------------------------------------*/
#define _UART_URPECR_URST_SHIFT		(0x000Fu)
#define _UART_URPECR_URST_MK(n)		(((Uint16)(n) & 0x0001u) << _UART_URPECR_URST_SHIFT)
#define _UART_URPECR_URST_MASK		(_UART_URPECR_URST_MK(0x0001u))
#define _UART_URPECR_URST_CLR		(~(_UART_URPECR_URST_MASK))




#elif (!(_UART_MOD))
	#error UART Hal Module Not Supported on Specified Target
#endif  /* _UART_SUPPORT  */

#endif  /* _CSL_UARTHAL_H  */

/******************************************************************************\
*     
*      End of csl_UARThal.h 
*
\******************************************************************************/

csl_usb.h/      1049976946  0     0     0       109522    `
/******************************************************************************/
/* $Id: usb_api.h, 03 Dec 2000                                                */
/*                                                                            */
/* This is proprietary information, not to be published -- TI INTERNAL DATA   */
/* Copyright (C) 2001, Texas Instruments, Inc.  All Rights Reserved.          */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Author: MH                                                                 */
/*                                                                            */
/* Based on: usb.h by Jason Kridner(IA) and Venkat Raghavan (TI India)        */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/*                                                                            */
/*                DO NOT MAKE ANY CHANGE TO THIS FILE                         */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/*                                                                            */
/* Modified last: 15 Jan 2001                                                 */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
 
#ifndef _CSL_USB_H
#define _CSL_USB_H

#if (_USB_SUPPORT) 

/****************************************\
* USB scope and inline control macros
\****************************************/

#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _USB_MOD
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

#include <csl.h>
#include <csl_std.h>
#include <csl_usb_apimap.h>

/******************************************************************************/
/*                                                                            */
/*                                                                            */
/******************************************************************************/

#define USB_IOFLAGS             Uint16
#define USB_EVENT_MASK          Uint16
#define USB_BYTE_COUNT          Uint16


            /************************************************/
            /*                                              */
            /*           Symbolic Constants                 */
            /*                                              */
            /************************************************/
            
            

/******************************************************************************/
/*                                                                            */
/*                          define NULL                                       */
/*                                                                            */
/******************************************************************************/
 
#ifndef NULL
#define NULL 0
#endif

/******************************************************************************/
/*                                                                            */
/*                    USB Data Transfer Flags                                 */
/*                                                                            */
/******************************************************************************/
 
#define USB_IOFLAG_NONE          0x0000  /* use default value                 */
#define USB_IOFLAG_NOSHORT       0x0001  /* do not expect or insert a 0 byte  */
                                         /* packet after a full size packet   */
#define USB_IOFLAG_SWAP          0x0002  /* swap hi/lo bytes before data xmit */
                                         /* after data recv.                  */                                         
#define USB_IOFLAG_LNK           0x0004  /* xmit or recv data buffer passed   */
                                         /* is a linked list                  */
#define USB_IOFLAG_CAT           0x0008  /* concatenate multiple linked list  */
                                         /* to fill up the data buffer with   */
                                         /* to max packet size before sending */
                                         /* or receiving a data packet        */                                                                                  
#define USB_IOFLAG_EOLL          0x0010  /* ignore argument ByteCnt, transfer */
                                         /* ends when the end of the linked   */
                                         /* list reached                      */                                                                                                                         

/******************************************************************************/
/*   Symbolic constants for  USB interrupt Events                             */
/*                                                                            */
/*   USB_EVENT_EOT is not an actual hardware interrupt, this     */
/*   flag is set by the USB event dispatcher to indicate the completion       */
/*   of the last requested data transfer.                                     */
/*                                                                            */
/******************************************************************************/

/*-------------5/16/00 4:00PM---------------*/
#define USB_EVENT_NONE                  0x0000  /* No interrupt received      */ 
#define USB_EVENT_RESET                 0x0001  /* Bus Reset                  */
#define USB_EVENT_SOF                   0x0002  /* Start of Frame             */
#define USB_EVENT_SUSPEND               0x0004  /* Bus Suspend                */
#define USB_EVENT_RESUME                0x0008  /* Bus Resume                 */
#define USB_EVENT_SETUP                 0x0010  /* Setup Packet Received      */
#define USB_EVENT_EOT                   0x0020  /* End of posted transaction  */
/* -----------01/05/01 $MH$---------------- */
#define USB_EVENT_STPOW                 0x0040  /* Setup Packet Overwrite     */
#define USB_EVENT_PSOF                  0x0080  /* Pre Start of Frame         */
#define USB_EVENT_HINT                  0x0100  /* Host interrupt             */
#define USB_EVENT_HERR                  0x0200  /* Host Error                 */



            /************************************************/
            /*                                              */
            /*           Enumerated Data Types              */
            /*                                              */
            /************************************************/
            
            

/****************************11/24/00 $MH$*************************************/
/*                                                                            */
/*                           USB Endpoints                                    */
/*                                                                            */
/*  These values are use by the CSL GUI or the USB API to initialize the      */
/*  USB Endpoint Objects                                                      */
/*                                                                            */
/******************************************************************************/

typedef enum 
{                                  /*            OUT ENDPOINTS                */
  USB_OUT_EP0  = 0x00,             /* Out Endpoint 0  - Control Out Endpoint  */
  USB_OUT_EP1  = 0x01,             /* Out Endpoint 1                          */
  USB_OUT_EP2  = 0x02,             /* Out Endpoint 2                          */
  USB_OUT_EP3  = 0x03,             /* Out Endpoint 3                          */
  USB_OUT_EP4  = 0x04,             /* Out Endpoint 4                          */
  USB_OUT_EP5  = 0x05,             /* Out Endpoint 5                          */
  USB_OUT_EP6  = 0x06,             /* Out Endpoint 6                          */
  USB_OUT_EP7  = 0x07,             /* Out Endpoint 7                          */
  
                                   /*            IN ENDPOINTS                */
  USB_IN_EP0   = 0x08,             /* In Endpoint 0  - Control In Endpoint   */
  USB_IN_EP1   = 0x09,             /* In Endpoint 1                          */
  USB_IN_EP2   = 0x0A,             /* In Endpoint 2                          */
  USB_IN_EP3   = 0x0B,             /* In Endpoint 3                          */
  USB_IN_EP4   = 0x0C,             /* In Endpoint 4                          */
  USB_IN_EP5   = 0x0D,             /* In Endpoint 5                          */
  USB_IN_EP6   = 0x0E,             /* In Endpoint 6                          */
  USB_IN_EP7   = 0x0F              /* In Endpoint 7                          */
  
}USB_EpNum;


/****************************11/24/00 $MH$*************************************/
/*                                                                            */
/*                         USB Transfer Tytes                                 */
/*                                                                            */
/*  These values are use by the CSL GUI or the USB API to initialize the      */
/*  USB Endpoint Objects                                                      */
/*                                                                            */
/******************************************************************************/

typedef enum 
{
  USB_CTRL  = 0x00,          /* Endpoint functions as control endpint         */
  USB_BULK  = 0x01,          /* Endpoint functions as bulk endpint            */
  USB_INTR  = 0x02,          /* Endpoint functions as interrupt endpint       */
  USB_ISO   = 0x03,          /* Endpoint functions as isochronous endpint     */
  USB_HPORT = 0x04           /* Endpoint functions as Host Port - special     */      
                             /* feature - not a part USB spec                 */
}USB_XferType;


/****************************11/24/00 $MH$*************************************/
/*                                                                            */
/*      USB device number - only useful if multiple exists on the             */
/*      same DSP.  Currently only USB0 supported.  Used by Device Control,    */
/*      Status Query and Data Transfer APIs                                   */
/*                                                                            */
/******************************************************************************/

typedef enum 
{
  USB0 = 0x00,    /* 1st USB module  -                                        */
  USB1 = 0x01,    /* 2nd USB module  - if the DSP support 2 USB module        */
  USB2 = 0x02     /* 3rd USB module  - if the DSP support 3 USB module        */
  
}USB_DevNum;


/****************************01/15/01 $MH$*************************************/
/*                                                                            */
/*      USB EP0 data dir type enumeration, used for setting and clearing      */
/*      DIR bit of USB Control Register (USBCTL).Used by Device Control macro */
/*      USB_SET_EP0_DATA_DIR(DevNun, DataDir)                                 */
/*                                                                            */
/******************************************************************************/

typedef enum 
{
  EP0_DATA_OUT = 0x00,            /* Endpoint0 data dir: Host -> Target       */
  EP0_DATA_IN  = 0x01             /* Endpoint0 data dir: Target -> host       */
  
} USB_EP0DataDir;


/******************************************************************************/
/*                                                                            */
/*                             USB_BOOLEAN                                    */
/*                                                                            */
/******************************************************************************/

typedef enum
{
  USB_FALSE = 0,
  USB_TRUE
}USB_Boolean;


            /************************************************/
            /*                                              */
            /*           USB Data Structures                */
            /*                                              */
            /************************************************/
            
            
/****************************01/15/01 $MH$*************************************/
/*                                                                            */
/*      USB_SetupStruct                                                       */
/*      Data structure to hold USB setup packet.  Used by USB API             */
/*      USB_getSetupPacket(USB_DevNum DevNum, USB_SetupStruct *USB_Setup)     */
/*                                                                            */
/******************************************************************************/

typedef struct
{
  int New;              /* New = 1, structure holds new setup packet          */    
  Uint16 bmRequestType; /* Byte 0 of setup packet                             */
  Uint16 bRequest;      /* Byte 1 of setup packet                             */
  Uint16 wValue;        /* Byte 2 and 3 of setup packet                       */
  Uint16 wIndex;        /* Byte 4 and 5 setup packet                          */
  Uint16 wLength;       /* Byte 6 and 7 of setup packet                       */
  
}USB_SetupStruct;


/****************************01/15/01 $MH$*************************************/
/*                                                                            */
/*      USB_DataStruct                                                        */
/*      Structure used by the USB Data Transfer API to send and received      */
/*      USB data in linked list form. USB Descriptors should be created as a  */
/*      linked list of USB_DataStruct type                                    */
/*                                                                            */
/******************************************************************************/

typedef struct USB_DataStructDef
{
  Uint16                    Bytes;        /* Total number of bytes in the buf */
  Uint16                    *pBuffer;     /* pointer to the start of buffer   */
  struct USB_DataStructDef  *pNextBuffer; /* pointer to the next structure    */
  
}USB_DataStruct;

/******************************************************************************/
/*                                                                            */
/*      USB_EVENT_ISR                                                         */
/*      Type definition for USB Event ISR pointer                             */
/*                                                                            */
/******************************************************************************/

typedef void (*USB_EVENT_ISR)();

/******************************************************************************/
/*                                                                            */
/*      USB_EvISR_NONE                                                        */
/*      NULL pointer for USB Event ISR                                        */
/*                                                                            */
/******************************************************************************/

#define USB_EvISR_NONE  (USB_EVENT_ISR)0

/******************************02/08/01 $MH$***********************************/
/*                                                                            */
/*                 Data Structure for USB Enpoint Object                      */
/*  Every active USB endpoint is associated with an endpoint object which     */
/*  keeps track of the endpoint related initialization and runtime information*/
/*                                                                            */
/*  03/05/01 $MH$ added XferBytCnt to keep track of actual number of data     */
/*  bytes moved in (out) to (from) the data buffer.  The size of the          */
/*  data buffer has to be (N+1) words.  Where N = (#bytes of data)/2, the     */
/*  the extra word at the beginning of the data buffer is used to store the   */
/*  actual number of bytes moved in (out).                                    */
/*                                                                            */
/******************************************************************************/

typedef struct 
{
   USB_EpNum        EpNum;        /* USB endpoint number                      */
   USB_XferType     XferType;     /* USB xfer type supported by the EP        */
   Uint16           MaxPktSiz;    /* Max pkt size supported by the EP         */
   Uint16           EventMask;    /* ORed value of USB_EVENTS, the USB        */
                                  /* event dispatcher will call the event     */
                                  /* ISR if event matches with EventMask      */
   USB_EVENT_ISR    Fxn;          /* Pointer to USB event ISR                 */
   Uint16           DataFlags;    /* ORed combination of USB_DATA_INOUT_FLAGS */
   Uint16           Status;       /* Reserved for future use                  */
   Uint16           EDReg_SAddr;  /* Endpoint desc reg block start addr       */
                                  /* 2 regs for EP0, 6 regs for the rest      */
   Uint16           DMA_SAddr;    /* DMA reg block start addr                 */
                                  /* used only for EP1 - EP7                  */
   Uint16           TotBytCnt;    /* Total number of bytes to xfer            */
   Uint16           BytInThisSeg; /* # of bytes in the active node of         */
                                  /* the linked list                          */
   Uint16           *XferBytCnt;  /* Pointer to store the number of bytes     */
                                  /* moved in (out) - stored in the first of  */
                                  /* the buffer                               */
   Uint16           *pBuffer;     /* Active data buffer pointer               */
   USB_DataStruct   *pNextBuffer; /* Pointer to the next node of the          */
                                  /* linked list                              */ 
   Uint16           EventFlag;    /* Flag to indicate the event cuased        */
                                  /* USB interrupt                            */
}  USB_EpObj,*USB_EpHandle;

/******************************************************************************/
/*                                                                            */
/*                         USB_NULL_EpHandle                                  */
/*                                                                            */
/*  NULL pointer for USB Enpoint Handle. During the endpoint initialization   */
/*  NULL endpoint handles are assigned to unused endpoints                    */
/*                                                                            */
/******************************************************************************/

#define USB_NULL_EpHandle   (USB_EpHandle)0



/******************************************************************************/
/*                                                                            */
/*                           USB API Prototypes                               */
/*                                                                            */
/******************************************************************************/

/******************************************************************************/
/* Name     : USB_setAPIVectorAddress                                         */
/*                                                                            */
/* Catagory : Software Initialization                                         */
/*                                                                            */
/* Purpose  : Initialize API vector pointer                                   */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*============================================================================*/
/* Arguments:      None                                                       */
/*                                                                            */
/*============================================================================*/
/* Return Value:   None                                                       */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The user application access to the USB API via a relocate-able call        */
/* table.                                                                     */
/*                                                                            */
/* This relocateable table allows user applications to call the API           */
/* routines out of ROM or out of RAM by relocating the API Vector             */
/* Table to RAM and replacing any desired functions with new ones             */
/* while still being able to use ROM functions.  The initial API              */
/* Vector Table contained in this file is the ROM version which will          */
/* be used as the default table until or if a user application moves          */
/* the table to another location in ROM or more likely RAM.                   */
/*                                                                            */
/* This scheme is specially implemented to replace the USB API in the         */
/* ROM with the updated ones.                                                 */
/*                                                                            */
/* USB buffer RAM locations 0x667E and 0x667F are reserved to point to        */
/* the API Vector Table.  These are 8 bit locations and hold the              */
/* two bytes of a 24 bit address, the lower byte is assumed to be 0           */
/* thus forcing the table to be allocated on 256 byte boundaries.             */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    16 Jan 2001                                                    */
/*                                                                            */
/******************************************************************************/
CSLAPI void USB_setAPIVectorAddress();

/******************************************************************************/
/* Name     : USB_initPLL                                                     */
/*                                                                            */
/* Catagory : Device Control                                                  */
/*                                                                            */
/* Purpose  : Initailize USB PLL to generate clock for the USB module         */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : C55x PLL init routine                                           */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* inclk      : Input clock (supplied at CLKIN pin) frequency ( in MHz)       */
/*                                                                            */
/* outclk     : Desired clock frequency (in MHz) for the USB moduel, the      */
/*              outclk must be 48 MHz for the proper operation of the USB     */
/*              module.                                                       */
/*                                                                            */
/* plldiv     : Input clock (supplied at CLKIN pin) devide down value, used   */
/*              for USB PLL enable as well as USB PLL bypass mode             */
/*                                                                            */
/*============================================================================*/
/* Return Value:   None                                                       */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* pllmult = (outclk * (plldiv+1)) / inclk                                    */
/*                                                                            */
/* if pllmult > 1                                                             */
/*		outclk = (pllmult / (plldiv + 1)) * inclk                         */
/*                                                                            */
/* if pllmult < 1                                                             */
/*		outclk = (1 / (plldiv + 1)) * inclk                               */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    16 Jan 2001                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI void USB_initPLL(Uint16 inclk, Uint16 outclk, Uint16 plldiv);

/******************************************************************************/
/* Name     :  USB_connectDev                                                 */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Connect the USB module to upstream port (D+ pullup enabled)    */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI void USB_connectDev(USB_DevNum DevNum);

/******************************************************************************/
/* Name     :  USB_disconnectDev                                              */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Disconnect the USB module from the upstream port               */
/*             (D+ pullup disabled)                                           */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI void USB_disconnectDev(USB_DevNum DevNum);
        
        
/******************************************************************************/
/* Name     : USB_issueRemoteWakeup                                            */
/*                                                                            */
/* Catagory : Device Control                                                  */
/*                                                                            */
/* Purpose  : Issue a remote wakeup signal to the host.                       */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if successfull, else USB_FASLE (specailly if remote wakeup feature*/
/* is not set prior to calling this function)                                 */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The USB driver will generate a remote wakeup signal on the bus if and only */
/* if the remote wakeup is enabled.  User's application must enable the remote*/
/* wakeup feature by calling the USB_setRemoteWakeup( ) routine if a Set      */
/* Remote Wakeup request is received from the  host.                          */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI USB_Boolean USB_issueRemoteWakeup(USB_DevNum DevNum);

/******************************************************************************/
/* Name     : USB_setRemoteWakeup                                             */
/*                                                                            */
/* Catagory : Software Control                                                */
/*                                                                            */
/* Purpose  : Set or clear Remote Wakeup Feature                              */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* RmtWkpStat:  If USB_TRUE the driver will set remote wakeup feature         */
/*              and a subsequent call to USB_issueRemoteWakeup( ) will cause  */
/*              the driver to generate a remote signal on the bus             */
/*                                                                            */
/*              If USB_FALSE the driver will clear remote wakeup feature      */
/*              and a subsequent call to USB_issueRemoteWakeup( ) will not    */
/*              generate a remote signal on the bus                           */           
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Host must set the remote wake up feature first. An application must verify */
/* if the remote wake-up feature is set before generating a remote wake-up    */
/* signal.                                                                    */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    31 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI void USB_setRemoteWakeup(USB_DevNum DevNum, USB_Boolean RmtWkpStat);

/******************************************************************************/
/* Name     : USB_getRemoteWakeupStat                                         */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : get the status of the Remote Wakeup Feature (whether the        */
/*            the feature is set or clear in the software)                    */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the Remote Wakeup Feature is enabled in the software.          */
/* USB_FALSE if the Remote Wakeup Feature is disabled in the software.        */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* An application must verify if the remote wakeup feature is set by the host */
/* before calling USB_issueRemoteWakeup( )                                    */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    31 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI USB_Boolean USB_getRemoteWakeupStat(USB_DevNum DevNum);

/******************************************************************************/
/* Name     :  USB_resetDev                                                   */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Reset the USB module.                                          */
/*                                                                            */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum:    USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Once the module has been reset, all the control and status registers are   */
/* returned to powerup reset values and the USB module is diconnected from    */
/* the upstream port.                                                         */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI void USB_resetDev(USB_DevNum DevNum);
        
       
/******************************************************************************/
/* Name     :  USB_setDevAddr                                                 */
/*                                                                            */
/* Catagory :  Device Control                                                 */
/*                                                                            */
/* Purpose  :  Set USB device address                                         */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* addr     : 7-bit USB device address                                        */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI void USB_setDevAddr(USB_DevNum DevNum, Uchar addr);

 
/******************************************************************************/
/* Name     :  USB_getFrameNo                                                 */
/*                                                                            */
/* Catagory :  Status/Query                                                   */
/*                                                                            */
/* Purpose  :  Read current USB frame number                                  */
/*                                                                            */
/* Author   :  MH                                                             */
/*                                                                            */
/* Based on :                                                                 */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* Current USB Frame Number                                                   */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    30 Mar 2001                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI Uint16 USB_getFrameNo(USB_DevNum DevNum);

/******************************************************************************/
/* Name     : USB_getEvents                                                   */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : Read and clear all the pending USB_EVENTS associated with a     */
/*            particular USB endpoint                                         */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* ORed combination of all the pending USB_EVENTS associated with a particular*/
/* endpoint                                                                   */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Calling this routine also clears all the pending USB_ENENTS associated     */
/* a particular endpoint                                                      */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI USB_EVENT_MASK USB_getEvents(USB_EpHandle hEp);

/******************************************************************************/
/* Name     : USB_peekEvents                                                  */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : Read all the pending USB_EVENTS associated with a particular    */
/*            USB endpoint                                                    */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* ORed combination of all the pending USB_EVENTS associated with a           */
/* particular endpoint                                                        */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Calling this routine does not clear the pending USB_ENENTS associated      */
/* a particular endpoint                                                      */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI USB_EVENT_MASK USB_peekEvents(USB_EpHandle hEp);

/******************************************************************************/
/* Name     : USB_getSetupPacket                                              */
/*                                                                            */
/* Catagory : Data Transfer                                                   */
/*                                                                            */
/* Purpose  : Read the setup packet from the setup data buffer                */
/*                                                                            */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum     : USB device number, enumerated data type of USB_DevNum.        */
/*              Only USB0 is active currently                                 */
/*                                                                            */
/* *USB_Setup : Pointer to a structure of type USB_SetupStruct.               */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if successful else USB_FALSE. If successful successful USB_Setup  */
/* structure holds the new setup packet                                       */
/*                                                                            */
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/

CSLAPI USB_Boolean USB_getSetupPacket(USB_DevNum DevNum, USB_SetupStruct *USB_Setup);


/******************************************************************************/
/* Name     : USB_postTransaction                                             */
/*                                                                            */
/* Catagory : Data Transfer                                                   */
/*                                                                            */
/* Purpose  : Transmit and receive USB data through an endpoint               */
/*                                                                            */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/* ByteCnt  : Total number of bytes in the buffer pointed by *Data            */
/*            ByteCnt = 0 .. 65535                                            */
/*                                                                            */
/* Data    : A pointer to a data buffer or to a linked list of type           */
/*            USB_DataStruct                                                  */
/*                                                                            */
/* Flags    : ORed combination of USB Data Transfer Flags                     */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_FALSE, if the previously posted transfer is not completed. USB_TRUE    */
/* if the data transfer request was posted successfully.                      */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint data moving in or out of the   */
/* USB module. At the end of the data transfer the USB event dispatcher will  */
/* call the associated event handler routine if the USB_TRANSACTIN_DONE event */
/* mask is set and an event handler routine is supplied during the endpoint   */
/* object initialization                                                      */
/*                                                                            */
/*--------------------- 03/08/01 $MH$ KNOWN LIMITATIONS  ---------------------*/
/*                                                                            */
/*  This limitation apply only for Out Endpoints if and only if the           */
/*  the data buffer is a linked list and USB_IOFLAG_CAT is set.  In           */
/*  such condition if the host prematurely terminates the data transfer       */
/*  (with or without a short packet) the driver fills up the data buffer      */ 
/*  of the current node of the linked list and then waits for more data       */ 
/*  from host to fill up the data buffers of the rest of the linked list.     */      
/*  This means the posted transation is still in progress and a call to       */  
/*  the routine USB_isTransactionDone(..) will return USB_FALSE.              */
/*  If the current node happen to be the very last node of the linked         */
/*  list the driver will treat this as a termination of transfer and          */
/*  a call to the routine USB_isTransactionDone(..) will return USB_TRUE      */
/*                                                                            */
/*  Since the driver programs the DMA GO and RLD registers at the same time   */
/*  (whenever possible) in order to move data more efficiently, if is beyond  */
/*  the scope of the driver to anticipate an early termination of data        */
/*  transfer and not program the DMA RLD registers                            */
/*                                                                            */
/*  WORK AROUND:  If you have doubt that the host may prematurely termainate  */
/*  the transfer then do not use the USB_IOFLAG_CAT flag with a linked list   */
/*  for OUT transfers.                                                        */
/*                                                                            */ 
/*  AFFECTED ENDPOINTS:  OUT[1..7]                                            */
/*                                                                            */
/*  THIS DOES NOT EFFECT ENDPOINT 0 IN/OUT TRANSFERS,  since endpoint0        */
/*  trnasfer are not done by the USB dedicated DMA                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/
CSLAPI USB_Boolean USB_postTransaction(USB_EpHandle    hEp,
                                Uint16          ByteCnt,
                                void            *Data,
                                USB_IOFLAGS     Flags);

/******************************************************************************/
/* Name     : USB_isTransactionDone                                           */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : Returns  the status of the previously posted data transfer      */
/*            request                                                         */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE, if the previously posted transfer is completed, else USB_FLASE.  */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint data will pass through.        */
/* It is a good idea to call this function before posting a data transfer     */
/* request                                                                    */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/
CSLAPI USB_Boolean USB_isTransactionDone(USB_EpHandle hEp);

/******************************************************************************/
/* Name     : USB_bytesRemaining                                              */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : Find out number of bytes waiting to be transferred from the     */
/*            previously posted data transfer request                         */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* Number of bytes remaining to be transferred. Return value is 0xFFFF if     */
/* USB_IOFLAG_EOLL flag used while posting the transfer request       */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint data moves through.            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/
CSLAPI USB_BYTE_COUNT USB_bytesRemaining(USB_EpHandle hEp);

/******************************************************************************/
/* Name     : USB_abortTransaction                                            */
/*                                                                            */
/* Catagory : Data Transfer                                                   */
/*                                                                            */
/* Purpose  : Terminate the data transfer in progress and free up the endpoint*/
/*            to post a new data transfer request                             */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : None                                                            */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if successful, else USB_FALSE                                     */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint associated with the data       */
/* transfer in progress                                                       */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    21 Dec 2000                                                    */
/*                                                                            */
/* Modified:   02/20/01 $MH$                                                  */
/*                                                                            */
/* Renamed from  USB_killTransaction( ) to USB_abortTransaction( )            */           
/*                                                                            */
/******************************************************************************/
CSLAPI USB_Boolean USB_abortTransaction(USB_EpHandle hEp);


/******************************************************************************/
/* Name     : USB_abortAllTransaction                                          */
/*                                                                            */
/* Catagory : Software Control                                                */
/*                                                                            */
/* Purpose  : Terminate all the data transfer in progress and free up the     */
/*            the endpoints to post new data transfer requests                */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum     : USB device number, enumerated data type of USB_DevNum.        */
/*              Only USB0 is active currently                                 */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if successful, else USB_FALSE                                     */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    10 Jan 2001                                                    */
/*                                                                            */
/* Modified:   02/20/01 $MH$                                                  */
/*                                                                            */
/* Renamed from  USB_killAllTransaction( ) to USB_abortAllTransaction( )      */
/*                                                                            */
/******************************************************************************/
CSLAPI USB_Boolean USB_abortAllTransaction(USB_DevNum DevNum);

/******************************************************************************/
/* Name     : USB_stallEndpt                                                  */
/*                                                                            */
/* Catagory : Device Control                                                  */
/*                                                                            */
/* Purpose  : Stall an endpoint                                               */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint to stall                       */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/
CSLAPI void USB_stallEndpt(USB_EpHandle hEp);

/******************************************************************************/
/* Name     : USB_clearEndptStall                                             */
/*                                                                            */
/* Catagory : Device Control                                                  */
/*                                                                            */
/* Purpose  : Clear an endpoint stall                                         */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle determines the endpoint to bring out of stall          */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/
CSLAPI void USB_clearEndptStall(USB_EpHandle hEp);

/******************************************************************************/
/* Name     : USB_getEndptStall                                               */
/*                                                                            */
/* Catagory : Status / Query                                                  */
/*                                                                            */
/* Purpose  : Find out if an endpoint is stalled                              */
/*                                                                            */
/* Author   : MH (partially)                                                  */
/*                                                                            */
/* Based on : USB code by Jason Kridner(IA) and Venkat Raghavan (TI India)    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* hEp      : Handle to an initialized endpoint object                        */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the endpoint is stalled, otherwise USB_FALSE                   */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The endpoint handle selects the endpoint                                   */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    28 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/
CSLAPI USB_Boolean USB_getEndptStall(USB_EpHandle hEp);

/******************************************************************************/
/* Name     : USB_epNumToHandle                                               */
/*                                                                            */
/* Catagory : Misc                                                            */
/*                                                                            */
/* Purpose  : Retrieve an handle to an endpoint                               */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* Endpt    : 8-bit endpoint number as specified in the USB specification     */
/*            0x00 -> Endpt 0 Out, 0x01 -> Endpt 1 Out ....                   */
/*            0x80 -> Endpt 0 In,  0x81 -> Endpt 1 In  ....                   */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* An handle to the endpoint object if a valid endpoint object exists, else   */
/* a NULL handle                                                              */
/*                                                                            */  
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* This routine is helpful when the application does not have any prior       */
/* knowledge of the endpoint it is dealing with.  For example, if the host    */
/* requests to stall an endpoint the application can read the endpoint number */
/* from the setup packet, retrieve the handle to this endpoint by calling     */
/* USB_epNumToHandle(..), and call USB_stallEndpt(..) with the handle to      */
/* stall the ednpoint;                                                        */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    12 Dec 2000                                                    */
/*                                                                            */
/******************************************************************************/
CSLAPI USB_EpHandle USB_epNumToHandle(USB_DevNum DevNum, Uchar Endpt);


/******************************************************************************/
/* Name     : USB_initEndptObj                                                */
/*                                                                            */
/* Catagory : Initialization                                                  */
/*                                                                            */
/* Purpose  : Initialize an endpoint object                                   */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum   : USB device number, enumerated data type of USB_DevNum.          */
/*            Only USB0 is active currently                                   */
/*                                                                            */
/* hEp      : Handle to an endpoint object to be initialized                  */
/*                                                                            */
/* EpNum    : USB endpoint number of enumarated data type USB_EpNum           */
/*                                                                            */
/* XferType : Type of data transfer to be supported by the endpoint           */
/*                                                                            */
/* MaxPktSiz: Max data packet size supported by the endpoint                  */
/*                                                                            */
/* EvMsk    : ORed combination of USB Interrupt Events to be broadcasted      */
/*            to the associated event handler                                 */
/*                                                                            */
/* Fxn      : Associated event handler routine                                */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the initialization is successful, else USB_FLASE               */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* The event handler should be in void Fxn(void) form. Do no use the          */
/* INTERRUPT pragma . Once the program control branches to Fxn the user's     */
/* code is free to call other functions or even post DSP?BIOS SWI             */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    24 Nov 2000                                                    */
/*                                                                            */
/******************************************************************************/
CSLAPI USB_Boolean USB_initEndptObj(USB_DevNum     DevNum,
                             USB_EpHandle   hEp,
                             USB_EpNum      EpNum, 
                             USB_XferType   XferType,
                             Uint16         MaxPktSiz,
                             Uint16         EvMsk,
                             USB_EVENT_ISR  Fxn);
                              
/******************************************************************************/
/* Name     : USB_init                                                        */
/*                                                                            */
/* Catagory : Device Initialization                                           */
/*                                                                            */
/* Purpose  : Configure the USB module                                        */
/*                                                                            */
/*                                                                            */
/* Author   : MH                                                              */
/*                                                                            */
/* Based on : From scratch                                                    */
/*                                                                            */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* DevNum     : USB device number, enumerated data type of USB_DevNum.        */
/*              Only USB0 is active currently                                 */
/*                                                                            */
/* hEpObj[]   : Pointer to a NULL terminated array of handles of initialized  */
/*              endpoint objects.  Max number of handles in the array can not */
/*              be more than 16 (excluding the NULL handle)                   */
/*                                                                            */
/* PSofTmrCnt : 8-bit counter value for the pre SOF timer                     */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* USB_TRUE if the device configuration is successful, else USB_FALSE         */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Upon sucessful return from the function call the USB module is completely  */
/* for operation (all the regs are configured and unmasked interrupts         */
/* are enabled).  Once the USB module is configured the user's code needs to  */
/* unmask the USB interrupt mask bit in the IER0 reg of DSP and enable the    */
/* DSP global interrupt.  Finally the user's code should call the routine     */
/* USB_connectDev(USB0) to connect the usb module to the USB bus              */
/*                                                                            */
/*============================================================================*/
/* History:                                                                   */
/*                                                                            */
/* Created:    24 Nov 2000                                                    */
/*                                                                            */
/* 28 Feb 01 $MH$                                                             */
/* Changed name from USB_config( ) to USB_setParams( ) to comply with CSL     */
/* standard                                                                   */
/*                                                                            */
/* 18 Jul 01 $MH$                                                             */
/* Changed name from USB_setParams( ) to USB_init( ) to comply with CSL       */
/* standard                                                                   */
/*                                                                            */                      
/******************************************************************************/
CSLAPI USB_Boolean USB_init(USB_DevNum    DevNum, 
                     USB_EpHandle  hEpObj[], 
                     Uchar         PSofTmrCnt);
                          
/******************************************************************************/
/*  Name:  USB_evDispatch                                                     */
/*                                                                            */
/*  Catagory : USB Event Dispatcher                                           */
/*                                                                            */
/*  Purpose:                                                                  */
/*                                                                            */
/*  This is the USB task dispatcher. This function sets the event flags based */
/*  on the USB events occured and calls the event handler routines binded to  */
/*  to each active endpoint objects.  The event handler routines are binded   */
/*  to the endpoint objects during the endpoint object initialization         */
/*                                                                            */
/*  Author: MH                                                                */
/*  Date: 24 Nov 2000                                                         */
/*  Based on : Venkat Raghavan (TI India)                                     */
/*                                                                            */
/*============================================================================*/
/* Arguments:                                                                 */
/*                                                                            */
/* None                                                                       */
/*                                                                            */
/*============================================================================*/
/* Return Value:                                                              */
/*                                                                            */
/* None                                                                       */
/*                                                                            */ 
/*============================================================================*/
/* Comments:                                                                  */
/*                                                                            */
/* Any USB application build on CSL USB component must use this USB event     */
/* distacher function to hand the USB interrupts.  There are two ways users   */
/* can accomplish this.  The first method is interrupt polling , where  the   */
/* user's code polls the USB interrupt flag bit periodically and calls the    */
/* USB Event Dispatcher function every time the USB interrupt flag is set.    */
/* The second method is to encapsulate the USB Event Dispatcher function in   */
/* an ISR and set up the DSP interrupt vector table to service this ISR every */
/* time a USB event occurs.                                                   */
/*                                                                            */
/*============================================================================*/
/*                                                                            */
/* 28 Sep 2001 $MH$                                                           */
/*                                                                            */
/* Converted INTERRUPT USB_isr() to void USB_evDispatch(void), so the         */
/* module can be used with DSP/BIOS                                           */
/*                                                                            */
/******************************************************************************/

CSLAPI void USB_evDispatch(void);                          

#endif /* USB_SUPPORT */

#endif

csl_usb_apimap./1049976947  174   0     0       3576      `
/********************************************************************
** _cls_usb_apimap.h                                               **
**                                                                 **
** Copyright (c) 2003, Texas Instruments, Inc.                     **
** All rights reserved.                                            **
**                                                                 **
** TMS320VC5509 USB API map file                                   **
**                                                                 **
** Author: MH                                                      **
**                                                                 **
*********************************************************************/
#ifndef _CSL_USB_APIMAP_H
#define _CSL_USB_APIMAP_H

#define   USB_getEvents                 vUSB_getEvents              
#define   USB_peekEvents                vUSB_peekEvents                                              
#define   USB_getSetupPacket            vUSB_getSetupPacket                                                                     
#define   USB_postTransaction           vUSB_postTransaction                                                                    
#define   USB_isTransactionDone         vUSB_isTransactionDone                                                                   
#define   USB_bytesRemaining            vUSB_bytesRemaining                                                                     
#define   USB_stallEndpt                vUSB_stallEndpt                                                                         
#define   USB_clearEndptStall           vUSB_clearEndptStall                                                                    
#define   USB_getEndptStall             vUSB_getEndptStall                                                                      
#define   USB_initEndptObj              vUSB_initEndptObj
#define   USB_init                      vUSB_init
#define   USB_epNumToHandle             vUSB_epNumToHandle
#define   USB_abortTransaction          vUSB_abortTransaction                                                                      
#define   USB_abortAllTransaction       vUSB_abortAllTransaction
#define   USB_connectDev                vUSB_connectDev                                                                         
#define   USB_disconnectDev             vUSB_disconnectDev                                                                                                                                     
#define   USB_setRemoteWakeup           vUSB_setRemoteWakeup
#define   USB_getRemoteWakeupStat       vUSB_getRemoteWakeupStat
#define   USB_issueRemoteWakeup         vUSB_issueRemoteWakeup                                                                                                                         
#define   USB_resetDev                  vUSB_resetDev                                                   
#define   USB_setDevAddr                vUSB_setDevAddr                                                                                                                              
#define   USB_getFrameNo                vUSB_getFrameNo                                      
#define   USB_initPLL                   vUSB_initPLL 
#define   USB_evDispatch                vUSB_evDispatch   
                                                                        
#endif                                                                    
csl_usbhal.h/   1049976949  0     0     0       23931     `
/******************************************************************************/
/* $Id: csl_usbhal.h,v 1.1.1.1 2001/08/16 16:12:41 a0323633 Exp $          */
/*                                                                            */
/* This is proprietary information, not to be published -- TI INTERNAL DATA   */
/* Copyright (C) 2000, Texas Instruments, Inc.  All Rights Reserved.          */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* Author :   Jason Kridner                                                   */
/* Date   :   October 23, 2000                                                */
/* Updates:                                                                   */
/*                                                                            */
/* 05/17/01 $MH$                                                              */
/*                                                                            */
/* Fixed PSOFTMR address                                                      */ 
/*                                                                            */
/******************************************************************************/
/* Modified last: Ruchika Agarwal 6 May 2002                                  */
/* Change: Addition of USBALT resister                                        */
/******************************************************************************/


#ifndef _CSL_USBHAL_H
#define _CSL_USBHAL_H

#include <_csl.h>

#if (_USB_SUPPORT)


/* -----------------10/23/2000 2:50PM----------------
;
; Values for USBINTSRC Register
;
 --------------------------------------------------*/
//02/27/01 $MH$ replaced names with the new ones (customer doc)
 
#define USBINTSRC_NONE         0x00
#define USBINTSRC_OEP0         0x02
#define USBINTSRC_IEP0         0x04
#define USBINTSRC_RSTR         0x06
#define USBINTSRC_SUSR         0x08
#define USBINTSRC_RESR         0x0A
#define USBINTSRC_SETUP        0x0C
#define USBINTSRC_STPOW        0x0E
#define USBINTSRC_SOF          0x10    /* phase III only */
#define USBINTSRC_PRESOF       0x11    /* phase III only */
#define USBINTSRC_OEP1         0x12
#define USBINTSRC_OEP2         0x14
#define USBINTSRC_OEP3         0x16
#define USBINTSRC_OEP4         0x18
#define USBINTSRC_OEP5         0x1A
#define USBINTSRC_OEP6         0x1C
#define USBINTSRC_OEP7         0x1E
#define USBINTSRC_IEP1         0x22
#define USBINTSRC_IEP2         0x24
#define USBINTSRC_IEP3         0x26
#define USBINTSRC_IEP4         0x28
#define USBINTSRC_IEP5         0x2A
#define USBINTSRC_IEP6         0x2C
#define USBINTSRC_IEP7         0x2E
#define USBINTSRC_ODMARLD1     0x32
#define USBINTSRC_ODMAGO1      0x33
#define USBINTSRC_ODMARLD2     0x34
#define USBINTSRC_ODMAGO2      0x35
#define USBINTSRC_ODMARLD3     0x36
#define USBINTSRC_ODMAGO3      0x37
#define USBINTSRC_ODMARLD4     0x38
#define USBINTSRC_ODMAGO4      0x39
#define USBINTSRC_ODMARLD5     0x3A
#define USBINTSRC_ODMAGO5      0x3B
#define USBINTSRC_ODMARLD6     0x3C
#define USBINTSRC_ODMAGO6      0x3D
#define USBINTSRC_ODMARLD7     0x3E
#define USBINTSRC_ODMAGO7      0x3F
#define USBINTSRC_IDMARLD1     0x42
#define USBINTSRC_IDMAGO1      0x43
#define USBINTSRC_IDMARLD2     0x44
#define USBINTSRC_IDMAGO2      0x45
#define USBINTSRC_IDMARLD3     0x46
#define USBINTSRC_IDMAGO3      0x47
#define USBINTSRC_IDMARLD4     0x48
#define USBINTSRC_IDMAGO4      0x49
#define USBINTSRC_IDMARLD5     0x4A
#define USBINTSRC_IDMAGO5      0x4B
#define USBINTSRC_IDMARLD6     0x4C
#define USBINTSRC_IDMAGO6      0x4D
#define USBINTSRC_IDMARLD7     0x4E
#define USBINTSRC_IDMAGO7      0x4F
#define USBINTSRC_HINT         0x50      /* phase III only */
#define USBINTSRC_HERR         0x52      /* phase III only */


#define USBINTSRC_DMA_START    0x30
#define USBINTSRC_DMA_END      0x4F
/*
12/02/00 $MH$: to include host dma interrupt in the handler table
#define USB_INTV_DMA_END      0x50
*/

/* -----------------10/23/2000 2:52PM----------------
;
; Register locations
;
 --------------------------------------------------*/
// 02/27/01 $MH$ replace register name with the new ones (customer doc)
/*  
#define USB_REG_DMA_O1    0x5808
#define USB_REG_DMA_O2    0x5810
#define USB_REG_DMA_O3    0x5818
#define USB_REG_DMA_O4    0x5820
#define USB_REG_DMA_O5    0x5828
#define USB_REG_DMA_O6    0x5830
#define USB_REG_DMA_O7    0x5838
#define USB_REG_DMA_I1    0x5848
#define USB_REG_DMA_I2    0x5850
#define USB_REG_DMA_I3    0x5858
#define USB_REG_DMA_I4    0x5860
#define USB_REG_DMA_I5    0x5868
#define USB_REG_DMA_I6    0x5870
#define USB_REG_DMA_I7    0x5878
*/

#define USBALT_ADDR      0x5840  /* Added New Entry - Ruchika */

#define USBODMA1_BASE    0x5808
#define USBODMA2_BASE    0x5810
#define USBODMA3_BASE    0x5818
#define USBODMA4_BASE    0x5820
#define USBODMA5_BASE    0x5828
#define USBODMA6_BASE    0x5830
#define USBODMA7_BASE    0x5838
#define USBIDMA1_BASE    0x5848
#define USBIDMA2_BASE    0x5850
#define USBIDMA3_BASE    0x5858
#define USBIDMA4_BASE    0x5860
#define USBIDMA5_BASE    0x5868
#define USBIDMA6_BASE    0x5870
#define USBIDMA7_BASE    0x5878

// 02/27/01 $MH$ replace register name with the new ones (customer doc)
/*
#ifdef usb_phase3
#define USB_REG_OEB_0     0x6680   // OUT ENDPT0 buffer base addr
#define USB_REG_IEB_0     0x66C0   // IN ENDPT0 buffer base addr
#else  
#define USB_REG_OEB_0     0x66F8   // EP0 IN and OUT buffer orders are reversed
#define USB_REG_IEB_0     0x66F0   // in phase II and phase III design         
#endif
#define USB_REG_SUP_0     0x6700
*/

//#ifdef usb_phase3

#define USBOEP0_BUF     0x6680  // OUT ENDPT0 buffer base addr
#define USBIEP0_BUF     0x66C0  // IN ENDPT0 buffer base addr

//#else 
 
//#define USBOEP0_BUF     0x66F8   /* EP0 IN and OUT buffer orders are reversed  */
//#define USBIEP0_BUF     0x66F0   /* in phase II and phase III design           */

//#endif

#define USBSUP_BUF      0x6700   // SETUP packet receive buffer

// 02/27/01 $MH$ replace register name with the new ones (customer doc)
/*
#define USB_REG_OEDB_1    0x6708
#define USB_REG_OEDB_2    0x6710
#define USB_REG_OEDB_3    0x6718
#define USB_REG_OEDB_4    0x6720
#define USB_REG_OEDB_5    0x6728
#define USB_REG_OEDB_6    0x6730
#define USB_REG_OEDB_7    0x6738
#define USB_REG_IEDB_1    0x6748
#define USB_REG_IEDB_2    0x6750
#define USB_REG_IEDB_3    0x6758
#define USB_REG_IEDB_4    0x6760
#define USB_REG_IEDB_5    0x6768
#define USB_REG_IEDB_6    0x6770
#define USB_REG_IEDB_7    0x6778
*/

#define USBOEDB1_BASE    0x6708  // base addr - IN ENDPT1 descriptor block
#define USBOEDB2_BASE    0x6710
#define USBOEDB3_BASE    0x6718
#define USBOEDB4_BASE    0x6720
#define USBOEDB5_BASE    0x6728
#define USBOEDB6_BASE    0x6730
#define USBOEDB7_BASE    0x6738
#define USBIEDB1_BASE    0x6748
#define USBIEDB2_BASE    0x6750
#define USBIEDB3_BASE    0x6758
#define USBIEDB4_BASE    0x6760
#define USBIEDB5_BASE    0x6768
#define USBIEDB6_BASE    0x6770
#define USBIEDB7_BASE    0x6778

// 02/27/01 $MH$ replace register name with the new ones (customer doc)
/*
#define USB_REG_IEPCNF_0  0x6780
#define USB_REG_IEPBCNT_0 0x6781
#define USB_REG_OEPCNF_0  0x6782
#define USB_REG_OEPBCNT_0 0x6783
*/

#define USBICNF0_ADDR  0x6780  // IN ENDPT0 Config reg addr
#define USBICT0_ADDR   0x6781  // IN ENDPT0 byte cnt reg addr
#define USBOCNF0_ADDR  0x6782
#define USBOCT0_ADDR   0x6783

// 02/27/01 $MH$ replace register name with the new ones (customer doc)
/*
#define USB_REG_GLOBCTL   0x6791
#define USB_REG_VECINT    0x6792
#define USB_REG_IEPINT    0x6793
#define USB_REG_OEPINT    0x6794
#define USB_REG_IDMARINT  0x6795
#define USB_REG_ODMARINT  0x6796
#define USB_REG_IDMAGINT  0x6797
#define USB_REG_ODMAGINT  0x6798
#define USB_REG_IDMAMSK   0x6799
#define USB_REG_ODMAMSK   0x679A
#define USB_REG_IEDBMSK   0x679B
#define USB_REG_OEDBMSK   0x679C
*/

#define USBGCTL_ADDR    0x6791
#define USBINTSRC_ADDR  0x6792
#define USBIEPIF_ADDR   0x6793
#define USBOEPIF_ADDR   0x6794
#define USBIDRIF_ADDR   0x6795
#define USBODRIF_ADDR   0x6796
#define USBIDGIF_ADDR   0x6797
#define USBODGIF_ADDR   0x6798
#define USBIDIE_ADDR    0x6799
#define USBODIE_ADDR    0x679A
#define USBIEPIE_ADDR   0x679B
#define USBOEPIE_ADDR   0x679C

/*
12/06/00 $MH$
#define USB_REG_HOSTEN    0x67A0
#define USB_REG_HOSTEP    0x67A1
#define USB_REG_HOSTTIME  0x67A2

//02/27/01 $MH$ replace register name with the new ones (customer doc)
#define USB_REG_HOSTCTL   0x67A0
#define USB_REG_HOSTEP    0x67A1
#define USB_REG_HOSTSTAT  0x67A2
*/

#define USBHCTL_ADDR      0x67A0
#define USBHEPSEL_ADDR    0x67A1
#define USBHSTAT_ADDR     0x67A2

/*
12/06/00 $MH$
//02/27/01 $MH$ replace register name with the new ones (customer doc)

#define USB_REG_FNUML     0x67F8    // phase III only
#define USB_REG_FNUMH     0x67F9    // phase III only
#define USB_REG_PSOFTMR   0x67A2    // phase III only
*/

#define USBFNUML_ADDR     0x67F8    // phase III only
#define USBFNUMH_ADDR     0x67F9    // phase III only
//#define USBPSOFTMR_ADDR   0x67A2  // phase III only -- error
#define USBPSOFTMR_ADDR   0x67FA    // bug fix 05/17/01 $MH$


/*
//02/27/01 $MH$ replace register name with the new ones (customer doc)
#define USB_REG_USBCTL    0x67FC
#define USB_REG_USBMSK    0x67FD
#define USB_REG_USBSTA    0x67FE
#define USB_REG_FUNADR    0x67FF
*/

#define USBCTL_ADDR       0x67FC
#define USBIE_ADDR        0x67FD
#define USBIF_ADDR        0x67FE
#define USBADDR_ADDR      0x67FF

/*
#define USBRTC_REG_IDLE   0x7000   // why RTC check with JDK
#define USBRTC_REG_STAT   0x7001   // why RTC check with JDK
*/

// renaming the above regs
#define USBIDLCTL_ADDR    0x7000   // USB Idle Control Reg
#define USBIDLSTAT_ADDR   0x7001   // USB Idle Status Reg

/* #define USB_REG_X4PLL     0x1E00     USB clk gen pll reg */

/*
bit address for USB module in USB Idle Control Reg
*/
//#define USBRTC_IDLE_USBPLL_ACTIVE 0x0001
//#define USBRTC_IDLE_USBEN         0x0004

// 02/27/01 $MH$
#define USBIDLCTL_USBPLL_ACTIVE 0x0001
#define USBIDLCTL_USBEN         0x0004

/*
bit address for USB global reset in USB_REG_GLOBCTL
*/
// #define USB_GLOB_RESET 0x0001

#define USBGCTL_RST 0x0001

/* -----------------12/06/00 $MH$ ----------------
SRAM bytes reserved for USB driver use
--------------------------------------------------*/
 
 #define USB_SRAM_DRVR     0x0100  /* 256 bytes reserved for driver */

/* -----------------10/23/2000 3:00PM----------------
General locations of memory/register blocks
 --------------------------------------------------*/ 
#define USB_DMA_REG_START 0x5800
#define USB_DMA_REG_END   0x587F
#define USB_SRAM_START    0x5880
// #if usb_phase3
// #define USB_SRAM_END      0x667F - 256 (bytes reserved for driver)
// #define USB_SRAM_END      0x667F - USB_SRAM_DRVR
// #else 
// #define USB_SRAM_END      0x66EF - 256 (bytes reserved for driver)
// #define USB_SRAM_END      0x66EF - USB_SRAM_DRVR
// #endif
#define USB_SRAM_END      0x667F - USB_SRAM_DRVR

#define USB_EDB_START     0x6700
//#define USB_UBM_REG_START 0x6780
//#define USB_UBM_REG_END   0x67FF

/* -----------------10/23/2000 3:11PM----------------
USBMSK and USBSTA bit fields (interrupt mask and status)
 --------------------------------------------------*/
#define USB_INT_STPOW 0x0001
#define USB_INT_SETUP 0x0004
#define USB_INT_PSOF  0x0008
#define USB_INT_SOF   0x0010
#define USB_INT_RESR  0x0020
#define USB_INT_SUSR  0x0040
#define USB_INT_RSTR  0x0080

/* -----------------10/23/2000 3:01PM----------------
DMA Context (DMA) structure
 --------------------------------------------------*/
/*
12/20/00 $MH$: temporarily assigning register structure to data
data memory 0x5800 to 0x7000 for debugging with 5510 simulator

typedef struct
{
  Uint16 DMACTL;
  Uint16 DMASIZ;
  Uint16 DMADL;
  Uint16 DMADH;
  Uint16 DMACNT;
  Uint16 DMALSZ;
  Uint16 DMALAL;
  Uint16 DMALAH;
} USB_DMA_Context, USB_DMARegBlk;

*/
 
//02/27/01 $MH$ replaced names with the new ones (customer doc)

typedef ioport struct
{
  Uint16 DCTL;
  Uint16 DSIZ;
  Uint16 DADL;
  Uint16 DADH;
  Uint16 DCT;
  Uint16 DRSZ;
  Uint16 DRAL;
  Uint16 DRAH;
} USB_DMA_Context, USB_DMARegBlk;


/* -----------------10/23/2000 3:02PM----------------
USB DMA Control reg bit fields
 --------------------------------------------------*/
// 02/27/01 $MH$ replace register bit names with the new ones (customer doc)
 
#define USBDCTL_GO  0x0001
#define USBDCTL_STP 0x0002
#define USBDCTL_RLD 0x0004
#define USBDCTL_OVF 0x0008
#define USBDCTL_END 0x0010
#define USBDCTL_CAT 0x0020
#define USBDCTL_SHT 0x0040
/*
Phase3 control bits
*/
#define USBDCTL_EM 0x0080
#define USBDCTL_PM 0x0100

/* -----------------10/23/2000 3:01PM----------------
Endpoint Descriptor Block (EDB) structure
 --------------------------------------------------*/
 
   
/*12/06/00 $MH$
Need to redefine EDB structure for phase III 
*/

//#ifdef usb_phase3
/*12/06/00 $MH$
Need to redefine EDB structure for phase III 
*/

//02/27/01 $MH$ replaced names with the new ones (customer doc)
typedef ioport struct   // reg blk for bulk, intr, and hostport endpt
{
  Uint16 CNF;
  Uint16 BAX;
  Uint16 CTX;
  Uint16 unused1;
  Uint16 SIZ;
  Uint16 BAY;
  Uint16 CTY;
  Uint16 unused2;
  
} USB_EDRegBlk;

typedef ioport struct   // reg blk for iso in endpts
{
  Uint16 CNF;
  Uint16 BAX;
  Uint16 CTX;
  Uint16 SIZH;
  Uint16 SIZ;
  Uint16 BAY;
  Uint16 CTY;
  Uint16 unused2;
  
} USB_IsoInRegBlk;

typedef ioport struct   // reg blk for iso out endpts
{
  Uint16 CNF;
  Uint16 BAX;
  Uint16 CTX;
  Uint16 CTXH;
  Uint16 SIZ;
  Uint16 BAY;
  Uint16 CTY;
  Uint16 CTYH;
  
} USB_IsoOutRegBlk;

//#else
/* 
EDB struct for phase 2
*/

//typedef ioport struct
//{
//  Uint16 CNF;
//  Uint16 BAX;
//  Uint16 CTX;
//  Uint16 unused1;
//  Uint16 unused2;
//  Uint16 BAY;
//  Uint16 CTY;
//  Uint16 SIZ;
//} USB_EDRegBlk;
//
//#endif
/*
12/20/00 $MH$: temporarily assigning register structure to data
data memory 0x5800 to 0x7000 for debugging with 5510 simulator

typedef struct
{
  Uint16 EPCNF;
  Uint16 X_BASE;
  Uint16 X_EPBCNT;
#if 0
  Uint16 unused1;
  Uint16 unused2;
#else
  Uint16 Events;
  Uint16 unused;
#endif
  Uint16 Y_BASE;
  Uint16 Y_EPBCNT;
  Uint16 XY_SIZE;
} USB_Endpoint_Descriptor_Block, USB_EDRegBlk;
*/
/* ----------------- 11/27/00 $MH$ ----------------
Endpoint 0 register block structure
 --------------------------------------------------*/
/*
12/20/00 $MH$: temporarily assigning register structure to data
data memory 0x5800 to 0x7000 for debugging with 5510 simulator

typedef struct
{
  Uint16 EPCNF;
  Uint16 EPBCNT;

} USB_EP0_RegBlk, *pUSPB_EP0_RegBlk;
*/

//02/27/01 $MH$ replaced names with the new ones (customer doc)

typedef ioport struct
{
  Uint16 CNF;
  Uint16 CT;

} USB_EP0_RegBlk, *pUSPB_EP0_RegBlk;


/* -----------------10/23/2000 3:04PM----------------
EPCNF bit fields
 --------------------------------------------------*/
//02/27/01 $MH$ replaced names with the new ones (customer doc) 
#define USBEPCNF_USBIE  0x0004
#define USBEPCNF_STALL  0x0008
#define USBEPCNF_DBUF   0x0010
#define USBEPCNF_TOGGLE 0x0020
#define USBEPCNF_OVF    0x0020
#define USBEPCNF_ISO    0x0040
#define USBEPCNF_UBME   0x0080

/* -----------------10/23/2000 3:06PM----------------
EPBCNT bit fields
 --------------------------------------------------*/
//#define USB_EPBCNT_CNT 0x000F
#define USBEPCT_NAK 0x0080

/* -----------------10/23/2000 3:08PM----------------
USBCTL bit fields
 --------------------------------------------------*/
//02/27/01 $MH$ replaced names with the new ones (customer doc) 
#define USBCTL_DIR    0x01
#define USBCTL_SETUP  0x02
#define USBCTL_FRSTE  0x10
#define USBCTL_RWUP   0x20
#define USBCTL_FEN    0x40
#define USBCTL_CONN   0x80

/* USB Memory registers */
/*
12/20/00 $MH$: temporarily assigning register structure to data
data memory 0x5800 to 0x7000 for debugging with 5510 simulator

#define USB_IN_EP0_CONF         *(ioport Uint16 *)USB_REG_IEPCNF_0
#define USB_IN_EP0_BYTE_CNT     *(ioport Uint16 *)USB_REG_IEPBCNT_0
#define USB_OUT_EP0_CONF        *(ioport Uint16 *)USB_REG_OEPCNF_0
#define USB_OUT_EP0_BYTE_CNT    *(ioport Uint16 *)USB_REG_OEPBCNT_0
#define USB_VECTOR_ADDRESS      *(ioport Uint16 *)USB_REG_VECINT
#define USB_CTL                 *(ioport Uint16 *)USB_REG_USBCTL
#define USB_IMR                 *(ioport Uint16 *)USB_REG_USBMSK
#define USB_STATUS              *(ioport Uint16 *)USB_REG_USBSTA
#define USB_DEV_ADDR            *(ioport Uint16 *)USB_REG_FUNADR
#define USB_GLOB_CTL            *(ioport Uint16 *)USB_REG_GLOBCTL
*/

/*
#define USB_IN_EP0_CONF         *(Uint16 *)USB_REG_IEPCNF_0
#define USB_IN_EP0_BYTE_CNT     *(Uint16 *)USB_REG_IEPBCNT_0
#define USB_OUT_EP0_CONF        *(Uint16 *)USB_REG_OEPCNF_0
#define USB_OUT_EP0_BYTE_CNT    *(Uint16 *)USB_REG_OEPBCNT_0
#define USB_VECTOR_ADDRESS      *(Uint16 *)USB_REG_VECINT
#define USB_CTL                 *(Uint16 *)USB_REG_USBCTL
#define USB_IMR                 *(Uint16 *)USB_REG_USBMSK
#define USB_STATUS              *(Uint16 *)USB_REG_USBSTA
#define USB_DEV_ADDR            *(Uint16 *)USB_REG_FUNADR
#define USB_GLOB_CTL            *(Uint16 *)USB_REG_GLOBCTL
*/

#define USBALT       *(ioport Uint16 *)USBALT_ADDR /* Added Ruchika */

//02/27/01 $MH$ replace register name with the new ones (customer doc)
#define USBICNF0     *(ioport Uint16 *)USBICNF0_ADDR
#define USBICT0      *(ioport Uint16 *)USBICT0_ADDR
#define USBOCNF0     *(ioport Uint16 *)USBOCNF0_ADDR
#define USBOCT0      *(ioport Uint16 *)USBOCT0_ADDR
#define USBINTSRC    *(ioport Uint16 *)USBINTSRC_ADDR
#define USBCTL       *(ioport Uint16 *)USBCTL_ADDR
#define USBIE        *(ioport Uint16 *)USBIE_ADDR
#define USBIF        *(ioport Uint16 *)USBIF_ADDR
#define USBADDR      *(ioport Uint16 *)USBADDR_ADDR
#define USBGCTL      *(ioport Uint16 *)USBGCTL_ADDR

/*
12/08/00 $MH$
*/
/*
12/20/00 $MH$: temporarily assigning register structure to data
data memory 0x5800 to 0x7000 for debugging with 5510 simulator
*/
//02/27/01 $MH$ replace register name with the new ones (customer doc)
#define USBIEPIF     *(ioport Uint16 *)USBIEPIF_ADDR  
#define USBOEPIF     *(ioport Uint16 *)USBOEPIF_ADDR  
#define USBIDRIF     *(ioport Uint16 *)USBIDRIF_ADDR
#define USBODRIF     *(ioport Uint16 *)USBODRIF_ADDR
#define USBIDGIF     *(ioport Uint16 *)USBIDGIF_ADDR
#define USBODGIF     *(ioport Uint16 *)USBODGIF_ADDR
#define USBIDIE      *(ioport Uint16 *)USBIDIE_ADDR 
#define USBODIE      *(ioport Uint16 *)USBODIE_ADDR 
#define USBIEPIE     *(ioport Uint16 *)USBIEPIE_ADDR 
#define USBOEPIE     *(ioport Uint16 *)USBOEPIE_ADDR

/*
#define USB_IN_EP_INTR_FLAG            *(Uint16 *)USB_REG_IEPINT  
#define USB_OUT_EP_INTR_FLAG           *(Uint16 *)USB_REG_OEPINT  
#define USB_IN_EP_DMA_RLD_INTR_FLAG    *(Uint16 *)USB_REG_IDMARINT
#define USB_OUT_EP_DMA_RLD_INTR_FLAG   *(Uint16 *)USB_REG_ODMARINT
#define USB_IN_EP_DMA_G0_INTR_FLAG     *(Uint16 *)USB_REG_IDMAGINT
#define USB_OUT_EP_DMA_GO_INTR_FLAG    *(Uint16 *)USB_REG_ODMAGINT
#define USB_IN_EP_DMA_INTR_MASK        *(Uint16 *)USB_REG_IDMAMSK 
#define USB_OUT_EP_DMA_INTR_MASK       *(Uint16 *)USB_REG_ODMAMSK 
#define USB_IN_EP_INTR_MASK            *(Uint16 *)USB_REG_IEDBMSK 
#define USB_OUT_EP_INTR_MASK           *(Uint16 *)USBOEPIE_ADDR
*/

/*
12/08/00 $MH$
phase III only
*/
/*
12/20/00 $MH$: temporarily assigning register structure to data
data memory 0x5800 to 0x7000 for debugging with 5510 simulator
*/
//02/27/01 $MH$ replace register name with the new ones (customer doc)
#define USBFNUML        *(ioport Uint16 *)USBFNUML_ADDR   
#define USBFNUMH        *(ioport Uint16 *)USBFNUMH_ADDR   
#define USBPSOFTMR      *(ioport Uint16 *)USBPSOFTMR_ADDR

/*
#define USB_FRM_NUML        *(Uint16 *)USB_REG_FNUML   
#define USB_FRM_NUMH        *(Uint16 *)USB_REG_FNUMH   
#define USB_PSOF_TIMER      *(Uint16 *)USB_REG_PSOFTMR
*/

/*
12/08/00 $MH$
Host Control Registers - phase III only
*/
/*
12/20/00 $MH$: temporarily assigning register structure to data
memory 0x5800 to 0x7000 for debugging with 5510 simulator
*/
//02/27/01 $MH$ replace register name with the new ones (customer doc)
#define USBHCTL       *(ioport Uint16 *)USBHCTL_ADDR 
#define USBHEPSEL     *(ioport Uint16 *)USBHEPSEL_ADDR  
#define USBHSTAT       *(ioport Uint16 *)USBHSTAT_ADDR

/*
#define USB_HOST_CTRL       *(Uint16 *)USB_REG_HOSTCTL 
#define USB_HOST_EP_SEL     *(Uint16 *)USB_REG_HOSTEP  
#define USB_HOST_STAT       *(Uint16 *)USB_REG_HOSTSTAT
*/

//02/26/01 $MH$
//02/27/01 $MH$ replace register bit name with the new ones (customer doc)
#define USBHCTL_EN         0x01
#define USBHCTL_HIE        0x02
#define USBHCTL_HERRIE     0x04

#define USBHSTAT_DIS       0x01
#define USBHSTAT_HIF       0x02
#define USBHSTAT_HERRIF    0x04

/*
12/24/00 $MH$
USB Idle Control regs, USB PLL control reg.
temporarily assigning register structure to data memory
0x5800 to 0x7000 for debugging with 5510 simulator
*/
//02/27/01 $MH$ replace register name with the new ones (customer doc)
#define USBIDLCTL   *(ioport Uint16 *)USBIDLCTL_ADDR
#define USBIDLSTAT  *(ioport Uint16 *)USBIDLSTAT_ADDR                    
//#define USB_X4PLL   *(ioport Uint16 *)USB_REG_X4PLL

/*
#define USB_IDLE_CTL   *(Uint16 *)USBRTC_REG_IDLE
#define USB_IDLE_STAT  *(Uint16 *)USBRTC_REG_STAT                    
#define USB_X4PLL      *(Uint16 *)USB_REG_X4PLL
*/

/*
12/08/00 $MH$
USB ENDPT and DMA interrupt enable and flag register bit fields
*/ 
#define USB_INTR_EP0   0x01
#define USB_INTR_EP1   0x02
#define USB_INTR_EP2   0x04
#define USB_INTR_EP3   0x08
#define USB_INTR_EP4   0x10
#define USB_INTR_EP5   0x20
#define USB_INTR_EP6   0x40
#define USB_INTR_EP7   0x80

// 05/01/01 $MH$ usb pll reg and bit fields moved from usb_clk.h file
/*********************************************************************/
/* Data bitfields for USB Clock Mode Register (USB_CLKMD)            */
/*********************************************************************/
#define USB_PLL_IAI				14
#define USB_PLL_IOB				13
#define USB_PLL_MULT		     7
#define USB_PLL_DIV			     5
#define USB_PLL_ENABLE	 	     4
#define USB_PLL_BYPASS_DIV	 	 2
#define USB_PLL_BREAKLN 		 1
#define USB_PLL_LOCK	 		 0

/*********************************************************************/
/* Define bit fields for USB Clock Mode Register (CLKMD)             */
/*********************************************************************/
/*
#define USB_X4PLL_LOCK    0x0001
#define USB_X4PLL_EN      0x0010
#define USB_X4PLL_IOB     0x2000
#define USB_X4PLL_IAI     0x4000
*/
/*********************************************************************/
/* USB CLOCK MODE REGISTER ADDRESS                                   */
/* Defined for VC5509                                                */
/*********************************************************************/
#define USB_CLKMD_ADDR  0x1E00
#define USB_CLKMD       *(ioport volatile Uint16 *)USB_CLKMD_ADDR

#endif

#else /* _USB_SUPPORT */
   #ifndef _USB_MOD
      error USB Module Not Supported for Specified Target Device
   #endif
#endif

csl_version.h/  1049976953  0     0     0       2368      `
/*********************************************************
Adds a version string to an object file that can be
read with the "vers" CCS command-line program.

The string is placed in a new section named "VERSION",
so that it can easily be moved in memory or discarded.

usage:
	VERSION(id, rev, tag)
where
	id is a module variable name prefix
	rev is a string, a module revision number
	tag is a string, a revision control tag
*********************************************************/

#ifndef _VERSION
#define _VERSION

/*
VERSION(id, rev, tag)
 Initialize an int array named <id>_version with a character string
 in the following format:
	Id:<id> Rev:<rev> Tag:<tag> Built: <date> <time>

 The rev and tag arguments are constant character strings.

 e.g. if "file.c" contains:
	VERSION(MP3_TI, "1.01", "RELEASE1");

 then "vers version.obj" will produce, e.g.:
        Id:MP3_TI Rev:1.01 Tag:RELEASE1 Built:Dec 18 2001 18:47:34
*/
#ifndef _TMS320C5XX
/* for every platform except C54x */
#define VERSION(id, rev, tag) \
	const char id##_version[] = "@(#)Id:" #id " Rev:" rev " Tag:" tag " Built:" __DATE__ " " __TIME__

#else
/* for C54x only */
#define VERSION(id, rev, tag) \
	extern const char id##_version[];\
	asm(" version_string _" #id "_version, \"Id:" #id " Rev:" rev " Tag:" tag " Built:" __DATE__ " " __TIME__ "\"")

/*
coff_string for C54x
 An assembly macro to initialize a string in DSP memory in a
 format that appears as a byte-wide character string in the
 COFF file on disk.
*/
asm("coff_string .macro str");
asm("  .var i");
asm("  .asg 1,i");
asm("  .loop $symlen(\":str:\")/2");
asm("    .field ':str(i+1,1):',8");
asm("    .field ':str(i,1):',8");
asm("    .eval i+2,i");
asm("  .endloop");
asm("  .if (i=$symlen(\":str:\"))");
asm("    .field 0,8");
asm("    .field ':str(i,1):',8");
asm("  .else");
asm("    .field 0,8");
asm("  .endif");
asm(" .endm");

/*
version_string
 Initialized an array named "name" with the character string "str",
 so that it can be read using the "vers" CCS command-line program.
*/
asm("version_string .macro name,str");
asm("  .sect \".const:VERSION\"");
asm("  .global :name:");
asm(":name::");
asm("  .string \"@(#):str:\"");
asm("  .byte 0");
asm("  coff_string \"@(#):str:\"");
asm("  .text");
asm("  .endm");
#endif

#endif
csl_wdtim.h/    1049976954  0     0     0       1795      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... WATCHDOG TIMER
* FILENAME...... csl_wdtim.h
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:       06/20/1999 (BWC) Created for C6x.  
*   MODIFIED:      12/06/2000 (FSCA) Modification for C54x.
*   MODIFIED:      02/18/2000 (FSCA) C54x Romability.
*   MODIFIED: 	 06/19/2000 make #ifdefs consistent with new csl_ header names,
*                            cpluplus compatability
*   LAST MODIFIED: 12/22/2000 (IM) Modified for Amadeus.
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the WATCHDOG TIMER module)
*
*
*
\******************************************************************************/
#ifndef _CSL_WDTIM_H_
#define _CSL_WDTIM_H_


#include <_csl.h>
#include <csl_chiphal.h>

#if (_WDTIM_SUPPORT)
  #if (_WDTIMA_SUPPORT)
     #include <csl_wdtimA.h>
  #elif (_WDTIMB_SUPPORT)
     #include <csl_wdtimB.h>
  #endif
#else
  #ifndef _WDTIM_MOD_ /*TIMER_SUPPORT */
    #error Watchdog Timer Module Not Supported on Specified Target
  #endif
#endif /*WDTIM_SUPPORT */

#endif /* _CSL_WDTIM_H_ */                
/******************************************************************************\
* End of csl_wdtim.h
\******************************************************************************/


csl_wdtimA.h/   1070356722  0     0     0       9533      `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... WATCHDOG TIMER
* FILENAME...... csl_wdtim.h
* DATE CREATED.. Sun 06/20/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... service layer
* PREREQUISITS.. cslhal.h
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED : 06/20/1999 (BWC) Created for C6x.  
*   		: 12/06/2000 (FSCA) Modification for C54x.
*   		: 02/18/2000 (FSCA) C54x Romability.
*   		: 06/19/2000 make #ifdefs consistent with new csl_ header names,
*                        cpluplus compatability
*   		: 12/22/2000 (IM) Modified for Amadeus.
*   		: 12/02/2003 Removed 'wdtim' member from Config structure
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (interface file for the WATCHDOG TIMER module)
*
*
*
\******************************************************************************/
#ifndef _CSL_WDTIMA_H_
#define _CSL_WDTIMA_H_


#include <_csl.h>
#include <csl_wdtimAhal.h>

#if (_WDTIMA_SUPPORT)
/****************************************\
* WDTIMER scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C"  
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _WDTIM_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/****************************************\
* WDTIM global macro declarations
\****************************************/ 

/* error codes */
#define WDTIM_ERR_MAJOR            (ERR_BASE_WDTIM) 
#define WDTIM_ERR_ALLOC            (0x00000000)
#define WDTIM_ERR_INVALID_HANDLE   (0x00000001)



/*******************************************\
* WDTIM global macro definition : ROMABILITY
\*******************************************/ 
/* Reserved ROM Area for timerData.h */
/* Data definition */   
#define WdTimer_Initialized              WDTIM_SYM(0)


/*-----------------------------------------------------------------------*/
/* The following macros are used to construct peripheral register        */
/* values based on symbolic constants. They will be useful to initialize */
/* the WDTIM_Config structure in a readable way.                         */
/*-----------------------------------------------------------------------*/

/* make TCR register value based on symbolic constants */

#define WDTIM_WDTCR_RMK(wdout,soft,free,tddr) \
 ((Uint16) ( \
  ( WDTIM_FMK(WDTCR,WDOUT,wdout))|\
  ( WDTIM_FMK(WDTCR,SOFT,soft))|\
  ( WDTIM_FMK(WDTCR,FREE,free))|\
  ( WDTIM_FMK(WDTCR,TDDR,tddr))\
  )\
)  

#define WDTIM_WDTCR_RMKS(wdout_sym,soft_sym,free_sym,tddr_sym) \
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTCR,WDOUT,wdout_sym))|\
  ( WDTIM_FMKS(WDTCR,SOFT,soft_sym))|\
  ( WDTIM_FMKS(WDTCR,FREE,free_sym))|\
  ( WDTIM_FMKS(WDTCR,TDDR,tddr_sym))\
  )\
)  

/* default WDTCR register value */
#define WDTIM_WDTCR_DEFAULT                 (0x0000)

/* WDTCR field values */
#define WDTIM_WDTCR_WDOUT_WDTINT		  (0x0000)
#define WDTIM_WDTCR_WDOUT_NMI			  (0x0001)
#define WDTIM_WDTCR_WDOUT_RESET		  (0x0002)
#define WDTIM_WDTCR_WDOUT_NOCONNECT		  (0x0003)
#define WDTIM_WDTCR_WDOUT_DEFAULT		  WDTIM_WDTCR_WDOUT_NOCONNECT

#define WDTIM_WDTCR_SOFT_BRKPTNOW           (0x0000)
#define WDTIM_WDTCR_SOFT_WAITZERO           (0x0001)
#define WDTIM_WDTCR_SOFT_DEFAULT            WDTIM_WDTCR_SOFT_BRKPTNOW

#define WDTIM_WDTCR_FREE_WITHSOFT           (0x0000)
#define WDTIM_WDTCR_FREE_NOSOFT             (0x0001)
#define WDTIM_WDTCR_FREE_DEFAULT            WDTIM_WDTCR_FREE_WITHSOFT

#define WDTIM_WDTCR_TDDR_OF(x)              ((Uint16)x)


/* WDTCR2 register */

#define WDTIM_WDTCR2_RMK(wdflag,wden,premd,wdkey) \
 ((Uint16) ( \
  ( WDTIM_FMK(WDTCR2,WDFLAG,wdflag))|\
  ( WDTIM_FMK(WDTCR2,WDEN,wden))|\
  ( WDTIM_FMK(WDTCR2,PREMD,premd))|\
  ( WDTIM_FMK(WDTCR2,WDKEY,wdkey))\
  )\
)  

#define WDTIM_WDTCR2_RMKS(wdflag_s,wden_s,premd_s,wdkey_s) \
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTCR2,WDFLAG,wdflag_s))|\
  ( WDTIM_FMKS(WDTCR2,WDEN,wden_s))|\
  ( WDTIM_FMKS(WDTCR2,PREMD,premd_s))|\
  ( WDTIM_FMKS(WDTCR2,WDKEY,wdkey_s))\
  )\
)  

/* WDTCR2 field values */

#define WDTIM_WDTCR2_WDFLAG_TIMEOUT         (0x0001u)
#define WDTIM_WDTCR2_WDFLAG_NOTIMEOUT       (0x0000u)
#define WDTIM_WDTCR2_WDFLAG_DEFAULT         WDTIM_WDTCR2_WDFLAG_NOTIMEOUT

#define WDTIM_WDTCR2_WDEN_ENABLE            (0x0001u)
#define WDTIM_WDTCR2_WDEN_DISABLE           (0x0000u)
#define WDTIM_WDTCR2_WDEN_DEFAULT           WDTIM_WDTCR2_WDEN_DISABLE

#define WDTIM_WDTCR2_PREMD_DIRECT           (0x0000u)
#define WDTIM_WDTCR2_PREMD_INDIRECT         (0x0001u)
#define WDTIM_WDTCR2_PREMD_DEFAULT          WDTIM_WDTCR2_PREMD_DIRECT

#define WDTIM_WDTCR2_WDKEY_PREACTIVE        (0x05C6u)
#define WDTIM_WDTCR2_WDKEY_ACTIVE           (0x0A7Eu)
#define WDTIM_WDTCR2_WDKEY_DEFAULT          (0x0000u)


/* WDPRD register */

#define WDTIM_WDPRD_RMK(prd) \
 ((Uint16)(WDTIM_FMK(WDPRD,PRD,prd)))  

#define WDTIM_WDPRD_RMKS(prd_s) \
 ((Uint16)(WDTIM_FMK(WDPRD,PRD,prd_s)))  


#define WDTIM_WDPRD_PRD_OF(x)               ((Uint16)(x))
#define WDTIM_WDPRD_DEFAULT                 (0xFFFFu)


/* WDTIM register */

#define WDTIM_WDTIM_RMK(tim) \
 ((Uint16)(WDTIM_FMK(WDTIM,TIM,tim)))  

#define WDTIM_WDTIM_RMKS(tim_s) \
 ((Uint16)(WDTIM_FMK(WDTIM,PRD,tim_s)))  


#define WDTIM_WDTIM_TIM_OF(x)               ((Uint16)(x))
#define WDTIM_WDTIM_DEFAULT                 (0xFFFFu)


/****************************************\
* WDTIMER global typedef declarations
\****************************************/


/* device configuration structure */
typedef struct {
  Uint16 wdprd;
  Uint16 wdtcr;
  Uint16 wdtcr2;
} WDTIM_Config;

/****************************************\
* WDTIMER global variable declarations
\****************************************/ 


/****************************************\
* WDTIMER global function declarations
\****************************************/

/****************************************\
* WDTIMER inline function declarations
\****************************************/

IDECL void WDTIM_config(WDTIM_Config *Config);
IDECL void WDTIM_configArgs(Uint16 wdtcr, Uint16 wdtcr2, Uint16 wdprd);
IDECL void WDTIM_getConfig(WDTIM_Config *Config);

IDECL void WDTIM_service();
IDECL void WDTIM_start();

/****************************************\
* WDTIMER inline function definitions
\****************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void WDTIM_config(WDTIM_Config *Config) {
  int old_intm;
  Uint16 tcr2_val = Config->wdtcr2 & (_WDTIM_WDTCR2_WDKEY_CLR & _WDTIM_WDTCR2_WDEN_CLR);

  old_intm = IRQ_globalDisable();  
  WDTIM_RSET(WDTCR,Config->wdtcr);
  WDTIM_RSET(WDPRD,Config->wdprd);
  WDTIM_RSET(WDTCR2,tcr2_val);
  IRQ_globalRestore(old_intm);   

}
/*----------------------------------------------------------------------------*/
IDEF void WDTIM_getConfig(WDTIM_Config *Config) {
  int old_intm;
  old_intm = IRQ_globalDisable();  
  Config->wdtcr2 = WDTIM_RGET(WDTCR2);
  Config->wdprd = WDTIM_RGET(WDPRD);
  Config->wdtcr = WDTIM_RGET(WDTCR);
  Config->wdtim = WDTIM_RGET(WDTIM);   
  IRQ_globalRestore(old_intm);   
}

/*----------------------------------------------------------------------------*/
IDEF void WDTIM_configArgs(Uint16 wdtcr, Uint16 wdtcr2, Uint16 wdprd) {
  int old_intm;
  Uint16 tcr2_val = wdtcr2 & (_WDTIM_WDTCR2_WDEN_CLR & _WDTIM_WDTCR2_WDKEY_CLR);

   old_intm = IRQ_globalDisable(); 
    
   WDTIM_RSET(WDPRD,wdprd);
   WDTIM_RSET(WDTCR,wdtcr); 
   WDTIM_RSET(WDTCR2,tcr2_val);
  
  IRQ_globalRestore(old_intm);   
}

/*----------------------------------------------------------------------------*/
IDEF void WDTIM_service() {
 Uint16 old_wdtcr2;
 int old_intm;

  old_intm = IRQ_globalDisable();

  old_wdtcr2 = WDTIM_RGET(WDTCR2);

   WDTIM_FSET(WDTCR2,WDKEY,WDTIM_WDTCR2_WDKEY_PREACTIVE); 
      
    ((old_wdtcr2 & _WDTIM_WDTCR2_WDKEY_CLR) | _WDTIM_WDTCR2_WDEN_MK(WDTIM_WDTCR2_WDEN_ENABLE) | 
      _WDTIM_WDTCR2_WDKEY_MK(WDTIM_WDTCR2_WDKEY_ACTIVE)));

  IRQ_globalRestore(old_intm);
}

/*----------------------------------------------------------------------------*/
IDEF void WDTIM_start() {
 Uint16 old_wdtcr2;
 int old_intm;

  old_intm = IRQ_globalDisable();

  old_wdtcr2 = WDTIM_RGET(WDTCR2);

  WDTIM_FSETS(WDTCR2,WDKEY,PREACTIVE);
  WDTIM_RSET(WDTCR2,
    ((old_wdtcr2 & _WDTIM_WDTCR2_WDKEY_CLR) | WDTIM_WDTCR2_WDEN_ENABLE | WDTIM_WDTCR2_WDKEY_ACTIVE));


  IRQ_globalRestore(old_intm);

}


#endif /*USEDEFS */
#else
  #ifndef _WDTIM_MOD_ 
    #error Watchdog Timer Module Not Supported on Specified Target
  #endif
#endif /*_WDTIMA_SUPPORT */

#endif /* _CSL_WDTIMA_H_ */                
/******************************************************************************\
* End of csl_wdtimA.h
\******************************************************************************/


csl_wdtimAhal.h/1049976958  0     0     0       13262     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... WDTIM
* FILENAME...... csl_wdtimhal.h
* DATE CREATED.. Tues 10/26/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:      	07/28/2000 
*   LAST MODIFIED:	12/22/2000 (IM) Modified for Amadeus
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the Watch Dog TIMER module)
*
* Registers Covered:
*   (RW) _WDTIM_WDTCR - watchdog timer control register
*   (RW) _WDTIM_WDTCR2 - watchdog timer control register 2
*   (RW) _WDTIM_WDPRD - watchdog timer period register
*   (RW) _WDTIM_WDTIM - watchdog timer count register
*
\******************************************************************************/
#ifndef _CSL_WDTIMAHAL_H_
#define _CSL_WDTIMAHAL_H_


#include <csl_chiphal.h>

#if (_WDTIMA_SUPPORT)
/****************************************\
* TIMER scope and inline control macros
\****************************************/

/*----------------------------------------------------------------------------*\
* Register Macros:
\*----------------------------------------------------------------------------*/
#define WDTIM_ADDR(Reg)               _WDTIM_##Reg##_ADDR
#define WDTIM_RGET(Reg)               _WDTIM_##Reg##_GET
#define WDTIM_RSET(Reg,Val)           _WDTIM_##Reg##_SET(Val)
#define WDTIM_RAOI(Reg,AND,OR,INV)    _WDTIM_##Reg##_AOI(AND,OR,INV)
#define WDTIM_FGET(Reg,Field)         _WDTIM_##Reg##_FGET(##Field)
#define WDTIM_FSET(Reg,Field,Val)     _WDTIM_##Reg##_FSET(##Field,Val)
#define WDTIM_FSETS(Reg,Field,Sym)    WDTIM_FSET(Reg,Field,WDTIM_##Reg##_##Field##_##Sym)
#define WDTIM_FAOI(Reg,Field,AND,OR,INV)\
  _WDTIM_##Reg##_FAOI(Field,AND,OR,INV)
#define WDTIM_FMK(Reg,Field,Val)      _WDTIM_##Reg##_##Field##_MK(Val)
#define WDTIM_FMKS(Reg,Field,Sym)     WDTIM_FMK(##Reg,##Field,WDTIM_##Reg##_##Field##_##Sym)


/******************************************************************************\
* _WDTIM_WDTIM - Watch Dog Timer Timer/Count register
*
* Fields:
*   (RW) TIM
*
\******************************************************************************/


#define _WDTIM_DEVICE_CNT        	  1

#define _WDTIM_WDTIM_ADDR             (0x4000u)
#define _WDTIM_WDTIM                  PREG16(_WDTIM_WDTIM_ADDR)
#define _WDTIM                         _WDTIM_WDTIM


/*----------------------------------------------------------------------------*\
* (RW) _WDTIM_WDTIM_TIM
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTIM_TIM_SHIFT       (0x0000u)
#define _WDTIM_WDTIM_TIM_MK(n)       (((Uint16)(n) & 0xffffu)<< _WDTIM_WDTIM_TIM_SHIFT)
#define _WDTIM_WDTIM_TIM_MASK        (_WDTIM_WDTIM_TIM_MK(0xffffu))
#define _WDTIM_WDTIM_TIM_CLR         (~(_WDTIM_WDTIM_TIM_MASK))

/*----------------------------------------------------------------------------*\
* Register Macros:
\*----------------------------------------------------------------------------*/


#define _WDTIM_WDTIM_GET              _PREG_GET(_WDTIM_WDTIM_ADDR)
#define _WDTIM_WDTIM_SET(Val)         _PREG_SET(_WDTIM_WDTIM_ADDR,Val)
#define _WDTIM_WDTIM_AOI(AND,OR,INV)  _PREG_AOI(_WDTIM_WDTIM_ADDR,AND,OR,INV)
#define _WDTIM_WDTIM_FGET(Field)      _PFIELD_GET(_WDTIM_WDTIM_ADDR,_WDTIM_WDTIM_##Field)
#define _WDTIM_WDTIM_FSET(Field,Val)  _PFIELD_SET(_WDTIM_WDTIM_ADDR,_WDTIM_WDTIM_##Field,Val)
#define _WDTIM_WDTIM_FSETS(Field,Sym) _WDTIM_WDPRD_FSETS(##Field,WDTIM_WDTIM_##Field##_##Sym)
#define _WDTIM_WDTIM_FAOI(Field,AND,OR,INV)\
   _PFIELD_FAOI(_WDTIM_WDPRD_ADDR,_WDTIM_WDPRD_##Field,AND,OR,INV)


/******************************************************************************\
* _WDTIM_WDPRD - Watch Dog Timer Period Register
*
* Fields:
*   (RW) PRD
*
\******************************************************************************/

#define _WDTIM_WDPRD_ADDR             (0x4001u)
#define _WDTIM_WDPRD                  PREG16(_WDTIM_WDPRD_ADDR)
#define _WDPRD                         _WDTIM_WDPRD

/*----------------------------------------------------------------------------*\
* (RW) WDTIM_WDPRD_PRD
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDPRD_PRD_SHIFT       (0x0000u)
#define _WDTIM_WDPRD_PRD_MK(n)       (((Uint16)(n) & 0xffffu)<< _WDTIM_WDPRD_PRD_SHIFT)
#define _WDTIM_WDPRD_PRD_MASK        (_WDTIM_WDPRD_PRD_MK(0xffffu))
#define _WDTIM_WDPRD_PRD_CLR         (~(_WDTIM_WDPRD_PRD_MASK))

/*----------------------------------------------------------------------------*\
* Register Macros:
\*----------------------------------------------------------------------------*/


#define _WDTIM_WDPRD_GET              _PREG_GET(_WDTIM_WDPRD_ADDR)
#define _WDTIM_WDPRD_SET(Val)         _PREG_SET(_WDTIM_WDPRD_ADDR,Val)
#define _WDTIM_WDPRD_AOI(AND,OR,INV)  _PREG_AOI(_WDTIM_WDPRD_ADDR,AND,OR,INV)
#define _WDTIM_WDPRD_FGET(Field)      _PFIELD_GET(_WDTIM_WDPRD_ADDR,_WDTIM_WDPRD_##Field)
#define _WDTIM_WDPRD_FSET(Field,Val)  _PFIELD_SET(_WDTIM_WDPRD_ADDR,_WDTIM_WDPRD_##Field,Val)
#define _WDTIM_WDPRD_FSETS(Field,Sym) _WDTIM_WDPRD_FSETS(##Field,WDTIM_WDPRD_##Field##_##Sym)
#define _WDTIM_WDPRD_FAOI(Field,AND,OR,INV)\
   _PFIELD_FAOI(_WDTIM_WDPRD_ADDR,_WDTIM_WDPRD_##Field,AND,OR,INV)

/******************************************************************************\
* _WDTIM_TCR 
*
* Fields:
*   (RW) _WDTIM_WDTCR_WDOUT
*   (RW) _WDTIM_WDTCR_SOFT
*   (RW) _WDTIM_WDTCR_FREE
*   (R)  _WDTIM_WDTCR_PSC
*   (RW) _WDTIM_WDTCR_TDDR
*
\******************************************************************************/

#define _WDTIM_WDTCR_ADDR             (0x4002u)
#define _WDTIM_WDTCR                  PREG16(_WDTIM_WDTCR_ADDR)
#define _WDTCR                         _WDTIM_WDTCR

/*----------------------------------------------------------------------------*\
* Watch Dog Timer Control Register (WDTCR) bit/field definitions
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
* (RW) WDTIM_WDTCR_WDOUT
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR_WDOUT_SHIFT       (0x000cu)
#define _WDTIM_WDTCR_WDOUT_MK(n)       (((Uint16)(n) & 0x0003u)<< _WDTIM_WDTCR_WDOUT_SHIFT)
#define _WDTIM_WDTCR_WDOUT_MASK        (_WDTIM_WDTCR_WDOUT_MK(3))
#define _WDTIM_WDTCR_WDOUT_CLR         (~(_WDTIM_WDTCR_WDOUT_MASK))

/*----------------------------------------------------------------------------*\
* (RW) WDTIM_WDTCR_SOFT
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR_SOFT_SHIFT       (0x000bu)
#define _WDTIM_WDTCR_SOFT_MK(n)       (((Uint16)(n) & 0x0001u)<< _WDTIM_WDTCR_SOFT_SHIFT)
#define _WDTIM_WDTCR_SOFT_MASK        (_WDTIM_WDTCR_SOFT_MK(1))
#define _WDTIM_WDTCR_SOFT_CLR         (~(_WDTIM_WDTCR_SOFT_MASK))

/*----------------------------------------------------------------------------*\
* (RW) WDTIM_WDTCR_FREE
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR_FREE_SHIFT       (0x000au)
#define _WDTIM_WDTCR_FREE_MK(n)       (((Uint16)(n) &0x0001u) << _WDTIM_WDTCR_FREE_SHIFT)
#define _WDTIM_WDTCR_FREE_MASK        (_WDTIM_WDTCR_FREE_MK(1))
#define _WDTIM_WDTCR_FREE_CLR         (~(_WDTIM_WDTCR_FREE_MASK))

/*----------------------------------------------------------------------------*\
* (R) WDTIM_WDTCR_PSC
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR_PSC_SHIFT        (0x0006u)
#define _WDTIM_WDTCR_PSC_MK(n)     	(((Uint16)(n) & 0x000fu) << 6)
#define _WDTIM_WDTCR_PSC_MASK     	(_WDTIM_WDTCR_PSC_MK(0x000fu))
#define _WDTIM_WDTCR_PSC_CLR     	(~_WDTIM_WDTCR_PSC_MK(0x000fu))

/*----------------------------------------------------------------------------*\
* (RW) WDTIM_WDTCR_TDDR
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR_TDDR_SHIFT       (0x0000u)
#define _WDTIM_WDTCR_TDDR_MK(n)       (((Uint16)(n) & 0x000fu)<< _WDTIM_WDTCR_TDDR_SHIFT)
#define _WDTIM_WDTCR_TDDR_MASK	  (_WDTIM_WDTCR_TDDR_MK(0x000fu))
#define _WDTIM_WDTCR_TDDR_CLR	 	  (~(_WDTIM_WDTCR_TDDR_MASK))

/*----------------------------------------------------------------------------*\
* Register Macros:
\*----------------------------------------------------------------------------*/

#define _WDTIM_WDTCR_SET(Val)         _PREG_SET(_WDTIM_WDTCR_ADDR,Val)
#define _WDTIM_WDTCR_GET              _PREG_GET(_WDTIM_WDTCR_ADDR)
#define _WDTIM_WDTCR_AOI(AND,OR,INV)  _PREG_AOI(_WDTIM_WDTCR_ADDR,AND,OR,INV)
#define _WDTIM_WDTCR_FGET(Field)      _PFIELD_GET(_WDTIM_WDTCR_ADDR,_WDTIM_WDTCR_##Field)
#define _WDTIM_WDTCR_FSET(Field,Val)  _PFIELD_SET(_WDTIM_WDTCR_ADDR,_WDTIM_WDTCR_##Field,Val)
#define _WDTIM_WDTCR_FSETS(Field,Sym) _WDTIM_WDTCR_FSETS(##Field,WDTIM_WDTCR_##Field##_##Sym)
#define _WDTIM_WDTCR_FAOI(Field,AND,OR,INV)\
   _PFIELD_FAOI(_WDTIM_WDTCR_ADDR,_WDTIM_WDTCR_##Field,AND,OR,INV)

/******************************************************************************\
* _WDTIM_WDTCR2 - Watch Dog Timer Secondary Control Register
*
* Fields:
*   (RW) WDTCR2_WDFLAG
*   (RW) WDTCR2_WDEN
*   (RW) WDTCR2_PREMD
*   (RW) WDTCR2_WDKEY
*
\******************************************************************************/


#define _WDTIM_WDTCR2_ADDR            (0x4003u)
#define _WDTIM_WDTCR2                 PREG16(_WDTIM_WDTCR2_ADDR)
#define _WDTCR2                        _WDTIM_WDTCR2


/*----------------------------------------------------------------------------*\
* (RW) HWDTCR2_WDFLAG - Watch Dog Timeout flag
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR2_WDFLAG_SHIFT      (0x000fu)
#define _WDTIM_WDTCR2_WDFLAG_MK(n)      (((Uint16)(n) & 0x0001u)<< _WDTIM_WDTCR2_WDFLAG_SHIFT)
#define _WDTIM_WDTCR2_WDFLAG_MASK       (_WDTIM_WDTCR2_WDFLAG_MK(0x0001u))
#define _WDTIM_WDTCR2_WDFLAG_CLR        (~(_WDTIM_WDTCR2_WDFLAG_MASK))

/*----------------------------------------------------------------------------*\
* (RW) HWDTCR2_WDEN - Watch Dog Timer Enable Bit
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR2_WDEN_SHIFT       (0x000eu)
#define _WDTIM_WDTCR2_WDEN_MK(n)       (((Uint16)(n) & 0x0001u)<< _WDTIM_WDTCR2_WDEN_SHIFT)
#define _WDTIM_WDTCR2_WDEN_MASK        (_WDTIM_WDTCR2_WDEN_MK(0x0001u))
#define _WDTIM_WDTCR2_WDEN_CLR         (~(_WDTIM_WDTCR2_WDEN_MASK))

/*----------------------------------------------------------------------------*\
* (RW) HWDTCR2_PREMD - Watch Dog Timer Pre-scaler Mode Bit
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR2_PREMD_SHIFT      (0x000cu)
#define _WDTIM_WDTCR2_PREMD_MK(n)      (((Uint16)(n) & 0x0001u)<< _WDTIM_WDTCR2_PREMD_SHIFT)
#define _WDTIM_WDTCR2_PREMD_MASK       (_WDTIM_WDTCR2_PREMD_MK(0x0001u))
#define _WDTIM_WDTCR2_PREMD_CLR        (~(_WDTIM_WDTCR2_PREMD_MASK))

/*----------------------------------------------------------------------------*\
* (RW) HWDTCR2_WDKEY - Watch Dog Timer Pre-scaler Mode Bit
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR2_WDKEY_SHIFT      (0x0000u)
#define _WDTIM_WDTCR2_WDKEY_MK(n)      (((Uint16)(n) & 0xFFFu)<< _WDTIM_WDTCR2_WDKEY_SHIFT)
#define _WDTIM_WDTCR2_WDKEY_MASK       (_WDTIM_WDTCR2_WDKEY_MK(0xFFFu))
#define _WDTIM_WDTCR2_WDKEY_CLR        (~(_WDTIM_WDTCR2_WDKEY_MASK))

/*----------------------------------------------------------------------------*\
* Register Macros:
\*----------------------------------------------------------------------------*/

#define _WDTIM_WDTCR2_GET              _PREG_GET(_WDTIM_WDTCR2_ADDR)
#define _WDTIM_WDTCR2_SET(Val)         _PREG_SET(_WDTIM_WDTCR2_ADDR,Val)
#define _WDTIM_WDTCR2_AOI(AND,OR,INV)  _PREG_AOI(_WDTIM_WDTCR2_ADDR,AND,OR,INV)
#define _WDTIM_WDTCR2_FGET(Field)      _PFIELD_GET(_WDTIM_WDTCR2_ADDR,_WDTIM_WDTCR2_##Field)
#define _WDTIM_WDTCR2_FSET(Field,Val)  _PFIELD_SET(_WDTIM_WDTCR2_ADDR,_WDTIM_WDTCR2_##Field,Val)
#define _WDTIM_WDTCR2_FSETS(Field,Sym) _WDTIM_WDTCR2_FSETS(##Field,WDTIM_WDTCR2_##Field##_##Sym)
#define _WDTIM_WDTCR2_FAOI(Field,AND,OR,INV)\
   _PFIELD_FAOI(_WDTIM_WDTCR2_ADDR,_WDTIM_WDTCR2_##Field,AND,OR,INV)


#else
  #ifndef _WDTIM_MOD_ /* _WDTIMHAL_H_ */
     #error WatchDog Timer HAL Module Not Supported on Specified Target
  #endif
#endif  
#endif /* _CSL_WDTIMHAL_H_ */
/******************************************************************************\
* End of csl_wdtimhal.h
\******************************************************************************/
csl_wdtimB.h/   1070358977  0     0     0       24492     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... WDTIM
* FILENAME...... csl_wdtim.h
* DATE CREATED.. Wed Feb 13 11:06:40 2002
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created: Wed Feb 13 11:06:40 2002 (Automatic generation)
*	 	: 10/28/2003 Fixed few typos, corrected the sequence to start
*                            watchdog timer, added WDTIM_start
*		: 12/02/2003 Removed APIs for dual 32-bit mode
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL Service Layer interface for the WDTIM module 
*
\*************************************************************************/

#ifndef _CSL_WDTIMB_H_
#define _CSL_WDTIMB_H_

#include <_csl.h>
#include <csl_chiphal.h>

#if (_WDTIMB_SUPPORT) 

#include <csl_wdtimBhal.h>
#include <csl_gpt.h>

/*----------------------------------------------------------------*\
*	 WDTIM scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _WDTIM_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/****************************************\
* WDTIM global macro declarations
\****************************************/

/* error codes */
#define WDTIM_ERR_MAJOR		   (ERR_BASE_WDTIM) 
#define WDTIM_ERR_ALLOC		   (0x00000000) 
#define WDTIM_ERR_INVALID_HANDLE  (0x00000001) 


#define WDTIM_getEventId           (11)

/* ============================================================== */
 /* Make WDTCLK register values based on symbolic constants  */

/*  WDTCLK field values  */

	#define WDTIM_WDTCLK_CLKDIV_DIV0	       (0x0000u) 
	#define WDTIM_WDTCLK_CLKDIV_DIV1	       (0x0001u) 
	#define WDTIM_WDTCLK_CLKDIV_DIV2	       (0x0002u) 
	#define WDTIM_WDTCLK_CLKDIV_DIV4	       (0x0004u) 
	#define WDTIM_WDTCLK_CLKDIV_DIV8	       (0x0008u)
	#define WDTIM_WDTCLK_CLKDIV_DEFAULT      WDTIM_WDTCLK_CLKDIV_DIV0


/*  Default WDTCLK register value  */

/* ============================================================== */
 /* Make WDTCNT1  register values based on symbolic constants  */

/*  WDTCNT1  field values  */

	#define WDTIM_WDTCNT1_CNT_OF(x)	      ((Uint16)(x))
	#define WDTIM_WDTCNT1_CNT_DEFAULT		WDTIM_WDTCNT1_CNT_OF(0x0000u)


#define WDTIM_WDTCNT1_RMK(cnt)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTCNT1 ,CNT,cnt))\
)\
 )

#define WDTIM_WDTCNT1_RMKS(cnt_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTCNT1 ,CNT,cnt_sym))\
)\
 )

/*  Default WDTCNT1  register value  */

/* ============================================================== */
 /* Make WDTCNT2  register values based on symbolic constants  */

/*  WDTCNT2  field values  */

	#define WDTIM_WDTCNT2_CNT_OF(x)	      ((Uint16)(x))
	#define WDTIM_WDTCNT2_CNT_DEFAULT		WDTIM_WDTCNT2_CNT_OF(0x0000u)


#define WDTIM_WDTCNT2_RMK(cnt)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTCNT2,CNT,cnt))\
)\
 )

#define WDTIM_WDTCNT2_RMKS(cnt_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTCNT2,CNT,cnt_sym))\
)\
 )

/*  Default WDTCNT2  register value  */

/* ============================================================== */
 /* Make WDTCNT3 register values based on symbolic constants  */

/*  WDTCNT3 field values  */

	#define WDTIM_WDTCNT3_CNT_OF(x)		((Uint16)(x))
	#define WDTIM_WDTCNT3_CNT_DEFAULT		WDTIM_WDTCNT3_CNT_OF(0x0000u)


#define WDTIM_WDTCNT3_RMK(cnt)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTCNT3,CNT,cnt))\
)\
 )

#define WDTIM_WDTCNT3_RMKS(cnt_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTCNT3,CNT,cnt_sym))\
)\
 )

/*  Default WDTCNT3 register value  */

/* ============================================================== */
 /* Make WDTCNT4 register values based on symbolic constants  */

/*  WDTCNT4 field values  */

	#define WDTIM_WDTCNT4_CNT_OF(x)	      ((Uint16)(x))
	#define WDTIM_WDTCNT4_CNT_DEFAULT		WDTIM_WDTCNT4_CNT_OF(0x0000u)


#define WDTIM_WDTCNT4_RMK(cnt)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTCNT4,CNT,cnt))\
)\
 )

#define WDTIM_WDTCNT4_RMKS(cnt_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTCNT4,CNT,cnt_sym))\
)\
 )

/*  Default WDTCNT4 register value  */

/* ============================================================== */
 /* Make WDTCTL1 register values based on symbolic constants  */

/*  WDTCTL1 field values  */

	#define WDTIM_WDTCTL1_TIEN_NOT_GATED			(000000u) 
	#define WDTIM_WDTCTL1_TIEN_GATED_BY_TINP			(0x0001u) 
	#define WDTIM_WDTCTL1_TIEN_DEFAULT		WDTIM_WDTCTL1_TIEN_NOT_GATED 

	#define WDTIM_WDTCTL1_CLKSRC_VBUS				(000000u) 
	#define WDTIM_WDTCTL1_CLKSRC_INPUT_PIN			(0x0001u) 
	#define WDTIM_WDTCTL1_CLKSRC_DEFAULT		WDTIM_WDTCTL1_CLKSRC_VBUS 

	#define WDTIM_WDTCTL1_ENAMODE_DISABLED			(000000u) 
	#define WDTIM_WDTCTL1_ENAMODE_ONCE			(0x0001u) 
	#define WDTIM_WDTCTL1_ENAMODE_CONTINUOUS			(0x0002u) 
	#define WDTIM_WDTCTL1_ENAMODE_DEFAULT		WDTIM_WDTCTL1_ENAMODE_DISABLED 

	#define WDTIM_WDTCTL1_PWID_INACTIVE_1CYCLE		(000000u) 
	#define WDTIM_WDTCTL1_PWID_INACTIVE_2CYCLES		(0x0001u) 
	#define WDTIM_WDTCTL1_PWID_INACTIVE_3CYCLES		(0x0002u) 
	#define WDTIM_WDTCTL1_PWID_INACTIVE_4CYCLES		(0x0003u) 
	#define WDTIM_WDTCTL1_PWID_DEFAULT		WDTIM_WDTCTL1_PWID_INACTIVE_1CYCLE 

	#define WDTIM_WDTCTL1_CP_CLOCK_MODE			(0x0001u) 
	#define WDTIM_WDTCTL1_CP_PULSE_MODE			(000000u) 
	#define WDTIM_WDTCTL1_CP_DEFAULT			WDTIM_WDTCTL1_CP_PULSE_MODE 

	#define WDTIM_WDTCTL1_INVIN_INVERT_OUTPUT			(0x0001u) 
	#define WDTIM_WDTCTL1_INVIN_DONT_INVERT_OUTPUT		(000000u) 
	#define WDTIM_WDTCTL1_INVIN_DEFAULT		WDTIM_WDTCTL1_INVIN_DONT_INVERT_OUTPUT 

	#define WDTIM_WDTCTL1_INVOUT_INVERT_OUTPUT		(0x0001u) 
	#define WDTIM_WDTCTL1_INVOUT_DONT_INVERT_OUTPUT		(000000u) 
	#define WDTIM_WDTCTL1_INVOUT_DEFAULT		WDTIM_WDTCTL1_INVOUT_DONT_INVERT_OUTPUT 

	#define WDTIM_WDTCTL1_TSTAT_HIGH				(0x0001u) 
	#define WDTIM_WDTCTL1_TSTAT_LOW				(000000u) 
 
#define WDTIM_WDTCTL1_RMK(tien,clksrc,enamode,pwid,cp,invin,invout)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTCTL1,TIEN,tien))|\
  ( WDTIM_FMK(WDTCTL1,CLKSRC,clksrc))|\
  ( WDTIM_FMK(WDTCTL1,ENAMODE,enamode))|\
  ( WDTIM_FMK(WDTCTL1,PWID,pwid))|\
  ( WDTIM_FMK(WDTCTL1,CP,cp))|\
  ( WDTIM_FMK(WDTCTL1,INVIN,invin))|\
  ( WDTIM_FMK(WDTCTL1,INVOUT,invout))\
)\
 ) 
 
#define WDTIM_WDTCTL1_RMKS(tien_sym,clksrc_sym,enamode_sym,pwid_sym,cp_sym,invin_sym,invout_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTCTL1,TIEN,tien_sym))|\
  ( WDTIM_FMKS(WDTCTL1,CLKSRC,clksrc_sym))|\
  ( WDTIM_FMKS(WDTCTL1,ENAMODE,enamode_sym))|\
  ( WDTIM_FMKS(WDTCTL1,PWID,pwid_sym))|\
  ( WDTIM_FMKS(WDTCTL1,CP,cp_sym))|\
  ( WDTIM_FMKS(WDTCTL1,INVIN,invin_sym))|\
  ( WDTIM_FMKS(WDTCTL1,INVOUT,invout_sym))\
)\
 ) 

/*  Default WDTCTL1 register value  */

/* ============================================================== */
 /* Make WDTCTL2 register values based on symbolic constants  */

/*  WDTCTL2 field values  */


	#define WDTIM_WDTCTL2_TIEN_NOT_GATED			(000000u) 
	#define WDTIM_WDTCTL2_TIEN_GATED_BY_TINP			(0x0001u) 
	#define WDTIM_WDTCTL2_TIEN_DEFAULT		WDTIM_WDTCTL2_TIEN_NOT_GATED 
 
	#define WDTIM_WDTCTL2_CLKSRC_VBUS				(000000u) 
	#define WDTIM_WDTCTL2_CLKSRC_INPUT_PIN			(0x0001u) 
	#define WDTIM_WDTCTL2_CLKSRC_DEFAULT		WDTIM_WDTCTL2_CLKSRC_VBUS 
 
	#define WDTIM_WDTCTL2_ENAMODE_DISABLED			(000000u) 
	#define WDTIM_WDTCTL2_ENAMODE_ONCE			(0x0001u) 
	#define WDTIM_WDTCTL2_ENAMODE_CONTINUOUS			(0x0002u) 
	#define WDTIM_WDTCTL2_ENAMODE_DEFAULT		WDTIM_WDTCTL2_ENAMODE_DISABLED 
 
	#define WDTIM_WDTCTL2_PWID_INACTIVE_1CYCLE		(000000u) 
	#define WDTIM_WDTCTL2_PWID_INACTIVE_2CYCLES		(0x0001u) 
	#define WDTIM_WDTCTL2_PWID_INACTIVE_3CYCLES		(0x0002u) 
	#define WDTIM_WDTCTL2_PWID_INACTIVE_4CYCLES		(0x0003u) 
	#define WDTIM_WDTCTL2_PWID_DEFAULT		WDTIM_WDTCTL2_PWID_INACTIVE_1CYCLE 
 
	#define WDTIM_WDTCTL2_CP_CLOCK_MODE			(0x0001u) 
	#define WDTIM_WDTCTL2_CP_PULSE_MODE			(000000u) 
	#define WDTIM_WDTCTL2_CP_DEFAULT			WDTIM_WDTCTL2_CP_PULSE_MODE 
 
	#define WDTIM_WDTCTL2_INVIN_INVERT_OUTPUT			(0x0001u) 
	#define WDTIM_WDTCTL2_INVIN_DONT_INVERT_OUTPUT		(000000u) 
	#define WDTIM_WDTCTL2_INVIN_DEFAULT		WDTIM_WDTCTL2_INVIN_DONT_INVERT_OUTPUT 
 
	#define WDTIM_WDTCTL2_INVOUT_INVERT_OUTPUT		(0x0001u) 
	#define WDTIM_WDTCTL2_INVOUT_DONT_INVERT_OUTPUT		(000000u) 
	#define WDTIM_WDTCTL2_INVOUT_DEFAULT		WDTIM_WDTCTL2_INVOUT_DONT_INVERT_OUTPUT 
 
	#define WDTIM_WDTCTL2_TSTAT_HIGH				(0x0001u) 
	#define WDTIM_WDTCTL2_TSTAT_LOW				(000000u) 
 
 
#define WDTIM_WDTCTL2_RMK(tien,clksrc,enamode,pwid,cp,invin,invout)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTCTL2,TIEN,tien))|\
  ( WDTIM_FMK(WDTCTL2,CLKSRC,clksrc))|\
  ( WDTIM_FMK(WDTCTL2,ENAMODE,enamode))|\
  ( WDTIM_FMK(WDTCTL2,PWID,pwid))|\
  ( WDTIM_FMK(WDTCTL2,CP,cp))|\
  ( WDTIM_FMK(WDTCTL2,INVIN,invin))|\
  ( WDTIM_FMK(WDTCTL2,INVOUT,invout))\
)\
 ) 
 
#define WDTIM_WDTCTL2_RMKS(tien_sym,clksrc_sym,enamode_sym,pwid_sym,cp_sym,invin_sym,invout_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTCTL2,TIEN,tien_sym))|\
  ( WDTIM_FMKS(WDTCTL2,CLKSRC,clksrc_sym))|\
  ( WDTIM_FMKS(WDTCTL2,ENAMODE,enamode_sym))|\
  ( WDTIM_FMKS(WDTCTL2,PWID,pwid_sym))|\
  ( WDTIM_FMKS(WDTCTL2,CP,cp_sym))|\
  ( WDTIM_FMKS(WDTCTL2,INVIN,invin_sym))|\
  ( WDTIM_FMKS(WDTCTL2,INVOUT,invout_sym))\
)\
 ) 


/*  Default WDTCTL2 register value  */

/* ============================================================== */
 /* Make WDTEMU register values based on symbolic constants  */

/*  WDTEMU field values  */

	#define WDTIM_WDTEMU_FREE_ON  		(000000u) 
	#define WDTIM_WDTEMU_FREE_OFF			(000001u) 
    #define WDTIM_WDTEMU_FREE_DEFAULT     WDTIM_WDTEMU_FREE_ON 
          
    #define WDTIM_WDTEMU_SOFT_ON  		(000000u) 
	#define WDTIM_WDTEMU_SOFT_OFF			(000001u) 
    #define WDTIM_WDTEMU_SOFT_DEFAULT     WDTIM_WDTEMU_SOFT_ON 
         

/*  Default WDTEMU register value  */



/* ============================================================== */
 /* Make WDTGPEN register values based on symbolic constants  */

/*  WDTGPEN field values  */

	#define WDTIM_WDTGPEN_TOUT1EN_TIMER_OUTPUT		(000000u) 
	#define WDTIM_WDTGPEN_TOUT1EN_GPIO_PIN			(0x0001u) 
	#define WDTIM_WDTGPEN_TOUT1EN_DEFAULT		    WDTIM_WDTGPEN_TOUT1EN_TIMER_OUTPUT 
 
	#define WDTIM_WDTGPEN_TIN1EN_TIMER_INPUT			(000000u) 
	#define WDTIM_WDTGPEN_TIN1EN_GPIO_PIN			    (0x0001u) 
	#define WDTIM_WDTGPEN_TIN1EN_DEFAULT		    WDTIM_WDTGPEN_TIN1EN_TIMER_INPUT 
 
 
#define WDTIM_WDTGPEN_RMK(tout1en,tin1en)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTGPEN,TOUT1EN,tout1en))|\
  ( WDTIM_FMK(WDTGPEN,TIN1EN,tin1en))\
)\
 ) 
 
#define WDTIM_WDTGPEN_RMKS(tout1en_sym,tin1en_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTGPEN,TOUT1EN,tout1en_sym))|\
  ( WDTIM_FMKS(WDTGPEN,TIN1EN,tin1en_sym))\
)\
 ) 


/*  Default WDTGPEN register value  */

/* ============================================================== */
 /* Make WDTGCTL1 register values based on symbolic constants  */

/*  WDTGCTL1 field values  */


	#define WDTIM_WDTGCTL1_TDDR34_OF(x)		      ((Uint16)(x))
	#define WDTIM_WDTGCTL1_TDDR34_DEFAULT		WDTIM_WDTGCTL1_TDDR34_OF(0x0000u)

	#define WDTIM_WDTGCTL1_PSC34_OF(x)			((Uint16)(x))
	#define WDTIM_WDTGCTL1_PSC34_DEFAULT		WDTIM_WDTGCTL1_PSC34_OF(0x0000u)

	#define WDTIM_WDTGCTL1_TIMMODE_64BIT_GPTIM	      (0x0000u)
	#define WDTIM_WDTGCTL1_TIMMODE_64BIT_WDTIM		(0x0002u)
	#define WDTIM_WDTGCTL1_TIMMODE_32BIT_DUAL			(0x0001u)
	#define WDTIM_WDTGCTL1_TIMMODE_32BIT_CHAINED		(0x0003u)
	#define WDTIM_WDTGCTL1_TIMMODE_DEFAULT		WDTIM_WDTGCTL1_TIMMODE_64BIT_GPTIM

	#define WDTIM_WDTGCTL1_TIM34RS_IN_RESET			(000000u)
	#define WDTIM_WDTGCTL1_TIM34RS_NOT_IN_RESET			(0x0001u)
	#define WDTIM_WDTGCTL1_TIM34RS_DEFAULT		WDTIM_WDTGCTL1_TIM34RS_IN_RESET

	#define WDTIM_WDTGCTL1_TIM12RS_IN_RESET			(000000u)
	#define WDTIM_WDTGCTL1_TIM12RS_NOT_IN_RESET			(0x0001u)
	#define WDTIM_WDTGCTL1_TIM12RS_DEFAULT		WDTIM_WDTGCTL1_TIM12RS_IN_RESET


#define WDTIM_WDTGCTL1_RMK(tddr34,psc34,timmode,tim34rs,tim12rs)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTGCTL1,TDDR34,tddr34))|\
  ( WDTIM_FMK(WDTGCTL1,PSC34,psc34))|\
  ( WDTIM_FMK(WDTGCTL1,TIMMODE,timmode))|\
  ( WDTIM_FMK(WDTGCTL1,TIM34RS,tim34rs))|\
  ( WDTIM_FMK(WDTGCTL1,TIM12RS,tim12rs))\
)\
 )

#define WDTIM_WDTGCTL1_RMKS(tddr34_sym,psc34_sym,timmode_sym,tim34rs_sym,tim12rs_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTGCTL1,TDDR34,tddr34_sym))|\
  ( WDTIM_FMKS(WDTGCTL1,PSC34,psc34_sym))|\
  ( WDTIM_FMKS(WDTGCTL1,TIMMODE,timmode_sym))|\
  ( WDTIM_FMKS(WDTGCTL1,TIM34RS,tim34rs_sym))|\
  ( WDTIM_FMKS(WDTGCTL1,TIM12RS,tim12rs_sym))\
)\
 )

/*  Default WDTGCTL1 register value  */

/* ============================================================== */
 /* Make WDTGPDAT register values based on symbolic constants  */

/*  WDTGPDAT field values  */

	#define WDTIM_WDTGPDAT_TOUT1DAT_HIGH			(0x0001u) 
	#define WDTIM_WDTGPDAT_TOUT1DAT_LOW			(000000u) 
	#define WDTIM_WDTGPDAT_TOUT1DAT_DEFAULT		WDTIM_WDTGPDAT_TOUT1DAT_LOW 
 
	#define WDTIM_WDTGPDAT_TIN1DAT_HIGH			(0x0001u) 
	#define WDTIM_WDTGPDAT_TIN1DAT_LOW			(000000u) 
	#define WDTIM_WDTGPDAT_TIN1DAT_DEFAULT		WDTIM_WDTGPDAT_TIN1DAT_LOW 
 
#define WDTIM_WDTGPDAT_RMK(tout1dat,tin1dat)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTGPDAT,TOUT1DAT,tout1dat))|\
  ( WDTIM_FMK(WDTGPDAT,TIN1DAT,tin1dat))\
)\
 ) 
 
#define WDTIM_WDTGPDAT_RMKS(tout1dat_sym,tin1dat_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTGPDAT,TOUT1DAT,tout1dat_sym))|\
  ( WDTIM_FMKS(WDTGPDAT,TIN1DAT,tin1dat_sym))\
)\
 ) 


/*  Default WDTGPDAT register value  */

/* ============================================================== */
 /* Make WDTGPDIR register values based on symbolic constants  */

/*  WDTGPDIR field values  */


	
	#define WDTIM_WDTGPDIR_TOUT1DIR_GPIO_INPUT			(000000u) 
	#define WDTIM_WDTGPDIR_TOUT1DIR_GPIO_OUTPUT			(0x0001u) 
	#define WDTIM_WDTGPDIR_TOUT1DIR_DEFAULT			WDTIM_WDTGPDIR_TOUT1DIR_GPIO_INPUT 
 
	#define WDTIM_WDTGPDIR_TIN1DIR_GPIO_INPUT				(000000u) 
	#define WDTIM_WDTGPDIR_TIN1DIR_GPIO_OUTPUT			(0x0001u) 
	#define WDTIM_WDTGPDIR_TIN1DIR_DEFAULT			WDTIM_WDTGPDIR_TIN1DIR_GPIO_INPUT 
 
#define WDTIM_WDTGPDIR_RMK(tout1dir,tin1dir)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTGPDIR,TOUT1DIR,tout1dir))|\
  ( WDTIM_FMK(WDTGPDIR,TIN1DIR,tin1dir))\
)\
 ) 
 
#define WDTIM_WDTGPDIR_RMKS(tout1dir_sym,tin1dir_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTGPDIR,TOUT1DIR,tout1dir_sym))|\
  ( WDTIM_FMKS(WDTGPDIR,TIN1DIR,tin1dir_sym))\
)\
 ) 


/*  Default WDTGPDIR register value  */

/* ============================================================== */
 /* Make WDTGPINT register values based on symbolic constants  */

/*  WDTGPINT field values  */

	
    #define WDTIM_WDTGPINT_TIN1INV_DISABLE		(0x0000u)  
	#define WDTIM_WDTGPINT_TIN1INV_ENABLE			(000001u) 
	#define WDTIM_WDTGPINT_TIN1INV_DEFAULT		WDTIM_WDTGPINT_TIN1INV_DISABLE
 
	#define WDTIM_WDTGPINT_TIN1INT_DISABLE		(0x0000u)  
	#define WDTIM_WDTGPINT_TIN1INT_ENABLE			(000001u) 
	#define WDTIM_WDTGPINT_TIN1INT_DEFAULT		WDTIM_WDTGPINT_TIN1INT_DISABLE
	
	
#define WDTIM_WDTGPINT_RMK(tin1inv,tin1int)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTGPINT,TIN1INV,tin1inv))|\
  ( WDTIM_FMK(WDTGPINT,TIN1INT,tin1int))\
)\
 ) 
 
#define WDTIM_WDTGPINT_RMKS(tin1inv_sym,tin1int_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTGPINT,TIN1INV,tin1inv_sym))|\
  ( WDTIM_FMKS(WDTGPINT,TIN1INT,tin1int_sym))\
)\
 ) 


/*  Default WDTGPINT register value  */

/* ============================================================== */
/* Make WDTPID1 register values based on symbolic constants  */

/*  WDTPID1 field values  */

	#define WDTIM_WDTPID1_CLASS_CLASS			(000000u)
	#define WDTIM_WDTPID1_CLASS_DEFAULT		WDTIM_WDTPID1_CLASS_CLASS

	#define WDTIM_WDTPID1_REVISION_REVISION			(000000u)
	#define WDTIM_WDTPID1_REVISION_DEFAULT		WDTIM_WDTPID1_REVISION_REVISION


/*  Default WDTPID1 register value  */

/* ============================================================== */
 /* Make WDTPID2 register values based on symbolic constants  */

/*  WDTPID2 field values  */

	#define WDTIM_WDTPID2_TYPE_TYPE			(000000u)
	#define WDTIM_WDTPID2_TYPE_DEFAULT		WDTIM_WDTPID2_TYPE_TYPE


/*  Default WDTPID2 register value  */

/* ============================================================== */
 /* Make WDTPRD1 register values based on symbolic constants  */

/*  WDTPRD1 field values  */

	#define WDTIM_WDTPRD1_PRD_OF(x)	      ((Uint16)(x))
	#define WDTIM_WDTPRD1_PRD_DEFAULT		WDTIM_WDTPRD1_PRD_OF(0x0000u)


#define WDTIM_WDTPRD1_RMK(prd)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTPRD1,PRD,prd))\
)\
 )

#define WDTIM_WDTPRD1_RMKS(prd_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTPRD1,PRD,prd_sym))\
)\
 )

/*  Default WDTPRD1 register value  */

/* ============================================================== */
 /* Make WDTPRD2 register values based on symbolic constants  */

/*  WDTPRD2 field values  */

	#define WDTIM_WDTPRD2_PRD_OF(x)		((Uint16)(x))
	#define WDTIM_WDTPRD2_PRD_DEFAULT		WDTIM_WDTPRD2_PRD_OF(0x0000u)


#define WDTIM_WDTPRD2_RMK(prd)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTPRD2,PRD,prd))\
)\
 )

#define WDTIM_WDTPRD2_RMKS(prd_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTPRD2,PRD,prd_sym))\
)\
 )

/*  Default WDTPRD2 register value  */

/* ============================================================== */
 /* Make WDTPRD3 register values based on symbolic constants  */

/*  WDTPRD3 field values  */

	#define WDTIM_WDTPRD3_PRD_OF(x)		((Uint16)(x))
	#define WDTIM_WDTPRD3_PRD_DEFAULT		WDTIM_WDTPRD3_PRD_OF(0x0000u)


#define WDTIM_WDTPRD3_RMK(prd)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTPRD3,PRD,prd))\
)\
 )

#define WDTIM_WDTPRD3_RMKS(prd_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTPRD3,PRD,prd_sym))\
)\
 )

/*  Default WDTPRD3 register value  */

/* ============================================================== */
 /* Make WDTPRD4 register values based on symbolic constants  */

/*  WDTPRD4 field values  */

	#define WDTIM_WDTPRD4_PRD_OF(x)		((Uint16)(x))
	#define WDTIM_WDTPRD4_PRD_DEFAULT		WDTIM_WDTPRD4_PRD_OF(0x0000u)


#define WDTIM_WDTPRD4_RMK(prd)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTPRD4,PRD,prd))\
)\
 )

#define WDTIM_WDTPRD4_RMKS(prd_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTPRD4,PRD,prd_sym))\
)\
 )

/*  Default WDTPRD4 register value  */

/* ============================================================== */
 /* Make WDTWCTL1 register values based on symbolic constants  */

/*  WDTWCTL1 field values  */

	#define WDTIM_WDTWCTL1_WDFLAG_TIMEOUT			(0x0001u)
	#define WDTIM_WDTWCTL1_WDFLAG_NO_TIMEOUT		(000000u)
	#define WDTIM_WDTWCTL1_WDFLAG_DEFAULT			WDTIM_WDTWCTL1_WDFLAG_NO_TIMEOUT

	#define WDTIM_WDTWCTL1_WDEN_ENABLE			(0x0001u)
	#define WDTIM_WDTWCTL1_WDEN_DISABLE			(000000u)
	#define WDTIM_WDTWCTL1_WDEN_DEFAULT			WDTIM_WDTWCTL1_WDEN_DISABLE

	#define WDTIM_WDTWCTL1_WDIKEY_NO_IDLE			(0x0000u)
	#define WDTIM_WDTWCTL1_WDIKEY_GO_IDLE_START		(000001u)
	#define WDTIM_WDTWCTL1_WDIKEY_GO_IDLE			(0x0002u)
	#define WDTIM_WDTWCTL1_WDIKEY_DEFAULT			WDTIM_WDTWCTL1_WDIKEY_GO_IDLE_START


#define WDTIM_WDTWCTL1_RMK(wdflag,wden,wdikey)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTWCTL1,WDFLAG,wdflag))|\
  ( WDTIM_FMK(WDTWCTL1,WDEN,wden))|\
  ( WDTIM_FMK(WDTWCTL1,WDIKEY,wdikey))\
)\
 )

#define WDTIM_WDTWCTL1_RMKS(wdflag_sym,wden_sym,wdikey_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTWCTL1,WDFLAG,wdflag_sym))|\
  ( WDTIM_FMKS(WDTWCTL1,WDEN,wden_sym))|\
  ( WDTIM_FMKS(WDTWCTL1,WDIKEY,wdikey_sym))\
)\
 )

/*  Default WDTWCTL1 register value  */

/* ============================================================== */
 /* Make WDTWCTL2 register values based on symbolic constants  */

/*  WDTWCTL2 field values  */

	#define WDTIM_WDTWCTL2_WDKEY_PREACTIVE          (0xA5C6u)
	#define WDTIM_WDTWCTL2_WDKEY_ACTIVE             (0xDA7Eu)
	#define WDTIM_WDTWCTL2_WDKEY_DEFAULT		(0x0000u)


#define WDTIM_WDTWCTL2_RMK(wdkey)\
 ((Uint16) ( \
  ( WDTIM_FMK(WDTWCTL2,WDKEY,wdkey))\
)\
 )

#define WDTIM_WDTWCTL2_RMKS(wdkey_sym)\
 ((Uint16) ( \
  ( WDTIM_FMKS(WDTWCTL2,WDKEY,wdkey_sym))\
)\
 )

/*  Default WDTWCTL2 register value  */
/*************************************************\
 WDTIM global typedef declarations 
\*************************************************/

typedef struct {
	Uint16 wdtemu;
	Uint16 wdtgpint;
	Uint16 wdtgpen;
	Uint16 wdtgpdir;
	Uint16 wdtgpdat;
	Uint16 wdtprd1;
	Uint16 wdtprd2;
	Uint16 wdtprd3;
	Uint16 wdtprd4;
	Uint16 wdtctl1;
	Uint16 wdtctl2;
	Uint16 wdtgctl1;
	Uint16 wdtwctl1;
	Uint16 wdtwctl2;
} WDTIM_Config;


typedef struct {
       Uint16 private;
} *WDTIM_Handle;

/*************************************************\
* WDTIM global variable declarations
\*************************************************/
#define _WDT_Obj        (&(CSL_WDTIM_DATA))

/*************************************************\
* WDTIM global function declarations
\*************************************************/

#define WDTIM_init64(h,gptgctl,dt12ctl,prdHigh,prdLow)\
  GPT_init64((GPT_Handle)(h),gptgctl,dt12ctl,prdHigh,prdLow)

#define WDTIM_getPID(h,type,class,revision)\
  GPT_getPID((GPT_Handle)(h), (Uint16 *)(type), (Uint16 *)(class),\
             (Uint16 *)(revision))

#define WDTIM_getCnt(h,hi32, lo32)\
  GPT_getCnt((GPT_Handle)(h),(Uint32*) hi32, (Uint32*) lo32)

#define WDTIM_start(h)\
  GPT_start((GPT_Handle)(h));

#define WDTIM_stop(h)\
  GPT_stop((GPT_Handle)(h));

CSLAPI void WDTIM_config(WDTIM_Handle hWdt, WDTIM_Config *myConfig);
CSLAPI void WDTIM_configArgs(WDTIM_Handle hWdt,Uint16 wdtemu,Uint16 wdtprd1,Uint16 wdtprd2,
        Uint16 wdtprd3,Uint16 wdtprd4,Uint16 wdtgpint,Uint16 wdtgpen,Uint16 wdtgpdir,Uint16
        wdtgpdat,Uint16 wdtctl1,Uint16 wdtctl2,Uint16 wdtgctl1,Uint16 wdtwctl1,Uint16 wdtwctl2);

/*************************************************\
* WDTIM inline function declarations
\*************************************************/

IDECL WDTIM_Handle WDTIM_open(void);
IDECL void WDTIM_close(WDTIM_Handle h);
IDECL void WDTIM_wdStart(WDTIM_Handle hWdt);
IDECL void WDTIM_service(WDTIM_Handle hWdt);


#ifdef USEDEFS


/*----------------------------------------------------------------------------*/
IDEF WDTIM_Handle WDTIM_open(void) {
  CSL_SYS_DATA.WdtAllocMask = 0x0001u;
  return (WDTIM_Handle)(&(CSL_WDTIM_DATA));
}
/*----------------------------------------------------------------------------*/
IDEF void WDTIM_close(WDTIM_Handle h) {
  CSL_SYS_DATA.WdtAllocMask = 0x0000u;
}
/*----------------------------------------------------------------------------*/
IDEF void WDTIM_wdStart(WDTIM_Handle hWdt) {
 int old_intm;
  ioport WDTIM_RegObj *regPtr =((CSL_WdtimDataObj *)(hWdt))->regs;

  old_intm = IRQ_globalDisable();

  regPtr->wdtwctl1 |= _WDTIM_WDTWCTL1_WDEN_MK(1);
  regPtr->wdtwctl2 = WDTIM_WDTWCTL2_WDKEY_PREACTIVE;
  regPtr->wdtwctl2 = WDTIM_WDTWCTL2_WDKEY_ACTIVE;  
  IRQ_globalRestore(old_intm);
}
/*----------------------------------------------------------------------------*/
IDEF void WDTIM_service(WDTIM_Handle hWdt) {
 int old_intm;
  ioport WDTIM_RegObj *regPtr =((CSL_WdtimDataObj *)(hWdt))->regs;

  old_intm = IRQ_globalDisable();

 
  regPtr->wdtwctl2 = WDTIM_WDTWCTL2_WDKEY_PREACTIVE;
  regPtr->wdtwctl2 = WDTIM_WDTWCTL2_WDKEY_ACTIVE;  
  IRQ_globalRestore(old_intm);
}
/*----------------------------------------------------------------------------*/

#endif /*USEDEFS */

#elif (!(_WDTIM_MOD))
	#error WDTIM Hal Module Not Supported on Specified Target
#endif  /* _WDTIMB_SUPPORT  */

#endif  /* _CSL_WDTIMB_H_  */

/******************************************************************************\
*     
*      End of csl_wdtimB.h 
*
\******************************************************************************/
csl_wdtimBhal.h/1049976961  0     0     0       54852     `
/****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... WDTIM
* FILENAME...... csl_wdtimBhal.h
* DATE CREATED.. Wed Feb 13 11:06:40 2002
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
*
* HISTORY:
*	 Created:		Wed Feb 13 11:06:40 2002 (Automatic generation)
*	 Last Modified:	
*
*------------------------------------------------------------------------------
* DESCRIPTION: CSL HAL interface file for the WDTIM module 
*
* Registers covered:
*              WDTPID1		- 
*	           WDTPID2		- 
*	           WDTEMU		- Emulation management register
*	           WDTCLK		- Timer clock speed register
*	           WDTCNT1		- Timer count register 1
*	           WDTCNT2		- Timer count register 2
*	           WDTCNT3		- Timer count register 3
*	           WDTCNT4		- Timer count register 4
*	           WDTPRD1		- Timer period register 1
*	           WDTPRD2		- Timer period register 2
*	           WDTPRD3		- Timer period register 3
*	           WDTPRD4		- Timer period register 4
*	           WDTGPINT		- GPIO interrupt control register
*	           WDTGPEN		- GPIO enable register
*	           WDTGPDIR		- GPIO direction register
*	           WDTGPDAT		- GPIO data register
*	           WDTCTL1		- Timer control register 1
*	           WDTCTL2		- Timer control register 2
*	           WDTGCTL1		- Global timer control register
*              WDTWCTL1     - Watch dog timer control register 1    
*              WDTWCTL2     - Watch dog timer control register 2
*
\*************************************************************************/

#ifndef _CSL_WDTIMBHAL_H_
#define _CSL_WDTIMBHAL_H_

#include <csl_chiphal.h>

#if (_WDTIMB_SUPPORT) 

/*----------------------------------------------------------------*\
*	 WDTIM scope and inline control macros 			
\*----------------------------------------------------------------*/

#ifdef __cplusplus
#define CSLAPI extern "C"
#else
#define CSLAPI extern 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _WDTIM_MOD_
  #define IDECL CSLAPI
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
 #endif
#endif

/*----------------------------------------------------------------*\
*		 Address Macros			
\*----------------------------------------------------------------*/

/*--------------------- Register: WDTPID1 -----------------------*/
#define _WDTIM_WDTPID1_ADDR		(0x4000u)
#define _WDTIM_WDTPID1			PREG16(_WDTIM_WDTPID1_ADDR)
#define WDTPID1			_WDTIM_WDTPID1


/*--------------------- Register: WDTPID2 -----------------------*/
#define _WDTIM_WDTPID2_ADDR		(0x4001u)
#define _WDTIM_WDTPID2			PREG16(_WDTIM_WDTPID2_ADDR)
#define WDTPID2			_WDTIM_WDTPID2


/*--------------------- Register: WDTEMU -----------------------*/
#define _WDTIM_WDTEMU_ADDR		(0x4002u)
#define _WDTIM_WDTEMU			PREG16(_WDTIM_WDTEMU_ADDR)
#define WDTEMU			_WDTIM_WDTEMU


/*--------------------- Register: WDTCLK -----------------------*/
#define _WDTIM_WDTCLK_ADDR		(0x4003u)
#define _WDTIM_WDTCLK			PREG16(_WDTIM_WDTCLK_ADDR)
#define WDTCLK			_WDTIM_WDTCLK


/*--------------------- Register: WDTCNT1  -----------------------*/
#define _WDTIM_WDTCNT1_ADDR		(0x4008u)
#define _WDTIM_WDTCNT1 			PREG16(_WDTIM_WDTCNT1_ADDR)
#define WDTCNT1 			_WDTIM_WDTCNT1 


/*--------------------- Register: WDTCNT2  -----------------------*/
#define _WDTIM_WDTCNT2_ADDR		(0x4009u)
#define _WDTIM_WDTCNT2 			PREG16(_WDTIM_WDTCNT2_ADDR)
#define WDTCNT2 			_WDTIM_WDTCNT2 


/*--------------------- Register: WDTCNT3 -----------------------*/
#define _WDTIM_WDTCNT3_ADDR		(0x400Au)
#define _WDTIM_WDTCNT3			PREG16(_WDTIM_WDTCNT3_ADDR)
#define WDTCNT3			_WDTIM_WDTCNT3


/*--------------------- Register: WDTCNT4 -----------------------*/
#define _WDTIM_WDTCNT4_ADDR		(0x400Bu)
#define _WDTIM_WDTCNT4			PREG16(_WDTIM_WDTCNT4_ADDR)
#define WDTCNT4			_WDTIM_WDTCNT4


/*--------------------- Register: WDTPRD1 -----------------------*/
#define _WDTIM_WDTPRD1_ADDR		(0x400Cu)
#define _WDTIM_WDTPRD1			PREG16(_WDTIM_WDTPRD1_ADDR)
#define WDTPRD1			_WDTIM_WDTPRD1


/*--------------------- Register: WDTPRD2 -----------------------*/
#define _WDTIM_WDTPRD2_ADDR		(0x400Du)
#define _WDTIM_WDTPRD2			PREG16(_WDTIM_WDTPRD2_ADDR)
#define WDTPRD2			_WDTIM_WDTPRD2


/*--------------------- Register: WDTPRD3 -----------------------*/
#define _WDTIM_WDTPRD3_ADDR		(0x400Eu)
#define _WDTIM_WDTPRD3			PREG16(_WDTIM_WDTPRD3_ADDR)
#define WDTPRD3			_WDTIM_WDTPRD3


/*--------------------- Register: WDTPRD4 -----------------------*/
#define _WDTIM_WDTPRD4_ADDR		(0x400Fu)
#define _WDTIM_WDTPRD4			PREG16(_WDTIM_WDTPRD4_ADDR)
#define WDTPRD4			_WDTIM_WDTPRD4


/*--------------------- Register: WDTGPINT -----------------------*/
#define _WDTIM_WDTGPINT_ADDR		(0x4004u)
#define _WDTIM_WDTGPINT			PREG16(_WDTIM_WDTGPINT_ADDR)
#define WDTGPINT			_WDTIM_WDTGPINT


/*--------------------- Register: WDTGPEN -----------------------*/
#define _WDTIM_WDTGPEN_ADDR		(0x4005u)
#define _WDTIM_WDTGPEN			PREG16(_WDTIM_WDTGPEN_ADDR)
#define WDTGPEN			_WDTIM_WDTGPEN


/*--------------------- Register: WDTGPDIR -----------------------*/
#define _WDTIM_WDTGPDIR_ADDR		(0x4007u)
#define _WDTIM_WDTGPDIR			PREG16(_WDTIM_WDTGPDIR_ADDR)
#define WDTGPDIR			_WDTIM_WDTGPDIR


/*--------------------- Register: WDTGPDAT -----------------------*/
#define _WDTIM_WDTGPDAT_ADDR		(0x4006u)
#define _WDTIM_WDTGPDAT			PREG16(_WDTIM_WDTGPDAT_ADDR)
#define WDTGPDAT			_WDTIM_WDTGPDAT


/*--------------------- Register: WDTCTL1  -----------------------*/
#define _WDTIM_WDTCTL1_ADDR		(0x4010u)
#define _WDTIM_WDTCTL1			PREG16(_WDTIM_WDTCTL1_ADDR)
#define WDTCTL1			        _WDTIM_WDTCTL1


/*--------------------- Register: WDTCTL2 -----------------------*/
#define _WDTIM_WDTCTL2_ADDR		(0x4011u)
#define _WDTIM_WDTCTL2			PREG16(_WDTIM_WDTCTL2_ADDR)
#define WDTCTL2			        _WDTIM_WDTCTL2


/*--------------------- Register: WDTGCTL1 -----------------------*/
#define _WDTIM_WDTGCTL1_ADDR		(0x4012u)
#define _WDTIM_WDTGCTL1			PREG16(_WDTIM_WDTGCTL1_ADDR)
#define WDTGCTL1			_WDTIM_WDTGCTL1


/*--------------------- Register: WDTWCTL1 -----------------------*/
#define _WDTIM_WDTWCTL1_ADDR		(0x4014u)
#define _WDTIM_WDTWCTL1			PREG16(_WDTIM_WDTWCTL1_ADDR)
#define WDTWCTL1			_WDTIM_WDTWCTL1


/*--------------------- Register: WDTWCTL2 -----------------------*/
#define _WDTIM_WDTWCTL2_ADDR		(0x4015u)
#define _WDTIM_WDTWCTL2			PREG16(_WDTIM_WDTWCTL2_ADDR)
#define WDTWCTL2			_WDTIM_WDTWCTL2



/*----------------------------------------------------------------*\
*		 Register Macros		
\*----------------------------------------------------------------*/

#define WDTIM_ADDR(Reg)		  _WDTIM_##Reg##_ADDR
#define WDTIM_RGET(Reg)		  _WDTIM_##Reg##_GET
#define WDTIM_RSET(Reg,Val)		  _WDTIM_##Reg##_SET(Val)
#define WDTIM_FGET(Reg,Field)		  _WDTIM_##Reg##_FGET(Field)
#define WDTIM_FSET(Reg,Field,Val)		  _WDTIM_##Reg##_FSET(Field, Val)
#define WDTIM_FMK(Reg,Field,Val)		  _WDTIM_##Reg##_##Field##_MK(Val)
#define WDTIM_RAOI(Reg,AND,OR,INV)		  _WDTIM_##Reg##_AOI(AND,OR,INV)
#define WDTIM_FAOI(Reg,Field,AND,OR,INV)	  _WDTIM_##Reg##_FAOI(Field,AND,OR,INV)
#define WDTIM_FMKS(Reg,Field,Sym)\
	  _WDTIM_##Reg##_##Field##_MK(WDTIM_##Reg##_##Field##_##Sym)
#define WDTIM_FSETS(Reg,Field,Sym)\
        _WDTIM_##Reg##_FSET(Field,WDTIM_##Reg##_##Field##_##Sym)

#define WDTIM_ADDRH(h,Reg)		  _WDTIM_##Reg##_ADDR
#define WDTIM_RGETH(h,Reg)		  _WDTIM_##Reg##_GET
#define WDTIM_RSETH(h,Reg,Val)		  _WDTIM_##Reg##_SET(Val)
#define WDTIM_FGETH(h,Reg,Field)		  _WDTIM_##Reg##_FGET(Field)
#define WDTIM_FSETH(h,Reg,Field,Val)		  _WDTIM_##Reg##_FSET(Field, Val)
#define WDTIM_FMKH(h,Reg,Field,Val)		  _WDTIM_##Reg##_##Field##_MK(Val)
#define WDTIM_RAOIH(h,Reg,AND,OR,INV)		  _WDTIM_##Reg##_AOI(AND,OR,INV)
#define WDTIM_FAOIH(h,Reg,Field,AND,OR,INV)	  _WDTIM_##Reg##_FAOI(Field,AND,OR,INV)
#define WDTIM_FMKSH(h,Reg,Field,Sym)\
	  _WDTIM_##Reg##_##Field##_MK(WDTIM_##Reg##_##Field##_##Sym)
#define WDTIM_FSETSH(h,Reg,Field,Sym)\
        _WDTIM_##Reg##_FSET(Field,WDTIM_##Reg##_##Field##_##Sym)

/*----------------------------------------------------------------*\
*		 Non-handle Registers Macros		
\*----------------------------------------------------------------*/


/*--------------------- Register: WDTPID1 -----------------------*/
#define _WDTIM_WDTPID1_GET		  _PREG_GET(_WDTIM_WDTPID1_ADDR) 
#define _WDTIM_WDTPID1_SET(Val)		  _PREG_SET(_WDTIM_WDTPID1_ADDR,Val)
#define _WDTIM_WDTPID1_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTPID1_ADDR, _WDTIM_WDTPID1_##Field)
#define _WDTIM_WDTPID1_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTPID1_ADDR, _WDTIM_WDTPID1_##Field, Val)
#define _WDTIM_WDTPID1_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTPID1_ADDR,AND,OR,INV)
#define _WDTIM_WDTPID1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTPID1_ADDR, _WDTIM_WDTPID1_##Field,AND,OR,INV)


/*--------------------- Register: WDTPID2 -----------------------*/
#define _WDTIM_WDTPID2_GET		  _PREG_GET(_WDTIM_WDTPID2_ADDR) 
#define _WDTIM_WDTPID2_SET(Val)		  _PREG_SET(_WDTIM_WDTPID2_ADDR,Val)
#define _WDTIM_WDTPID2_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTPID2_ADDR, _WDTIM_WDTPID2_##Field)
#define _WDTIM_WDTPID2_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTPID2_ADDR, _WDTIM_WDTPID2_##Field, Val)
#define _WDTIM_WDTPID2_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTPID2_ADDR,AND,OR,INV)
#define _WDTIM_WDTPID2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTPID2_ADDR, _WDTIM_WDTPID2_##Field,AND,OR,INV)


/*--------------------- Register: WDTEMU -----------------------*/
#define _WDTIM_WDTEMU_GET		  _PREG_GET(_WDTIM_WDTEMU_ADDR) 
#define _WDTIM_WDTEMU_SET(Val)		  _PREG_SET(_WDTIM_WDTEMU_ADDR,Val)
#define _WDTIM_WDTEMU_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTEMU_ADDR, _WDTIM_WDTEMU_##Field)
#define _WDTIM_WDTEMU_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTEMU_ADDR, _WDTIM_WDTEMU_##Field, Val)
#define _WDTIM_WDTEMU_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTEMU_ADDR,AND,OR,INV)
#define _WDTIM_WDTEMU_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTEMU_ADDR, _WDTIM_WDTEMU_##Field,AND,OR,INV)


/*--------------------- Register: WDTCLK -----------------------*/
#define _WDTIM_WDTCLK_GET		  _PREG_GET(_WDTIM_WDTCLK_ADDR) 
#define _WDTIM_WDTCLK_SET(Val)		  _PREG_SET(_WDTIM_WDTCLK_ADDR,Val)
#define _WDTIM_WDTCLK_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTCLK_ADDR, _WDTIM_WDTCLK_##Field)
#define _WDTIM_WDTCLK_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTCLK_ADDR, _WDTIM_WDTCLK_##Field, Val)
#define _WDTIM_WDTCLK_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTCLK_ADDR,AND,OR,INV)
#define _WDTIM_WDTCLK_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTCLK_ADDR, _WDTIM_WDTCLK_##Field,AND,OR,INV)


/*--------------------- Register: WDTCNT1  -----------------------*/
#define _WDTIM_WDTCNT1_GET		  _PREG_GET(_WDTIM_WDTCNT1_ADDR) 
#define _WDTIM_WDTCNT1_SET(Val)		  _PREG_SET(_WDTIM_WDTCNT1_ADDR,Val)
#define _WDTIM_WDTCNT1_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTCNT1_ADDR, _WDTIM_WDTCNT1_##Field)
#define _WDTIM_WDTCNT1_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTCNT1_ADDR, _WDTIM_WDTCNT1_##Field, Val)
#define _WDTIM_WDTCNT1_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTCNT1_ADDR,AND,OR,INV)
#define _WDTIM_WDTCNT1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTCNT1_ADDR, _WDTIM_WDTCNT1_##Field,AND,OR,INV)


/*--------------------- Register: WDTCNT2  -----------------------*/
#define _WDTIM_WDTCNT2_GET		  _PREG_GET(_WDTIM_WDTCNT2_ADDR) 
#define _WDTIM_WDTCNT2_SET(Val)		  _PREG_SET(_WDTIM_WDTCNT2_ADDR,Val)
#define _WDTIM_WDTCNT2_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTCNT2_ADDR, _WDTIM_WDTCNT2_##Field)
#define _WDTIM_WDTCNT2_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTCNT2_ADDR, _WDTIM_WDTCNT2_##Field, Val)
#define _WDTIM_WDTCNT2_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTCNT2_ADDR,AND,OR,INV)
#define _WDTIM_WDTCNT2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTCNT2_ADDR, _WDTIM_WDTCNT2_##Field,AND,OR,INV)


/*--------------------- Register: WDTCNT3 -----------------------*/
#define _WDTIM_WDTCNT3_GET		  _PREG_GET(_WDTIM_WDTCNT3_ADDR) 
#define _WDTIM_WDTCNT3_SET(Val)		  _PREG_SET(_WDTIM_WDTCNT3_ADDR,Val)
#define _WDTIM_WDTCNT3_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTCNT3_ADDR, _WDTIM_WDTCNT3_##Field)
#define _WDTIM_WDTCNT3_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTCNT3_ADDR, _WDTIM_WDTCNT3_##Field, Val)
#define _WDTIM_WDTCNT3_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTCNT3_ADDR,AND,OR,INV)
#define _WDTIM_WDTCNT3_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTCNT3_ADDR, _WDTIM_WDTCNT3_##Field,AND,OR,INV)


/*--------------------- Register: WDTCNT4 -----------------------*/
#define _WDTIM_WDTCNT4_GET		  _PREG_GET(_WDTIM_WDTCNT4_ADDR) 
#define _WDTIM_WDTCNT4_SET(Val)		  _PREG_SET(_WDTIM_WDTCNT4_ADDR,Val)
#define _WDTIM_WDTCNT4_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTCNT4_ADDR, _WDTIM_WDTCNT4_##Field)
#define _WDTIM_WDTCNT4_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTCNT4_ADDR, _WDTIM_WDTCNT4_##Field, Val)
#define _WDTIM_WDTCNT4_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTCNT4_ADDR,AND,OR,INV)
#define _WDTIM_WDTCNT4_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTCNT4_ADDR, _WDTIM_WDTCNT4_##Field,AND,OR,INV)


/*--------------------- Register: WDTPRD1 -----------------------*/
#define _WDTIM_WDTPRD1_GET		  _PREG_GET(_WDTIM_WDTPRD1_ADDR) 
#define _WDTIM_WDTPRD1_SET(Val)		  _PREG_SET(_WDTIM_WDTPRD1_ADDR,Val)
#define _WDTIM_WDTPRD1_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTPRD1_ADDR, _WDTIM_WDTPRD1_##Field)
#define _WDTIM_WDTPRD1_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTPRD1_ADDR, _WDTIM_WDTPRD1_##Field, Val)
#define _WDTIM_WDTPRD1_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTPRD1_ADDR,AND,OR,INV)
#define _WDTIM_WDTPRD1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTPRD1_ADDR, _WDTIM_WDTPRD1_##Field,AND,OR,INV)


/*--------------------- Register: WDTPRD2 -----------------------*/
#define _WDTIM_WDTPRD2_GET		  _PREG_GET(_WDTIM_WDTPRD2_ADDR) 
#define _WDTIM_WDTPRD2_SET(Val)		  _PREG_SET(_WDTIM_WDTPRD2_ADDR,Val)
#define _WDTIM_WDTPRD2_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTPRD2_ADDR, _WDTIM_WDTPRD2_##Field)
#define _WDTIM_WDTPRD2_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTPRD2_ADDR, _WDTIM_WDTPRD2_##Field, Val)
#define _WDTIM_WDTPRD2_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTPRD2_ADDR,AND,OR,INV)
#define _WDTIM_WDTPRD2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTPRD2_ADDR, _WDTIM_WDTPRD2_##Field,AND,OR,INV)


/*--------------------- Register: WDTPRD3 -----------------------*/
#define _WDTIM_WDTPRD3_GET		  _PREG_GET(_WDTIM_WDTPRD3_ADDR) 
#define _WDTIM_WDTPRD3_SET(Val)		  _PREG_SET(_WDTIM_WDTPRD3_ADDR,Val)
#define _WDTIM_WDTPRD3_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTPRD3_ADDR, _WDTIM_WDTPRD3_##Field)
#define _WDTIM_WDTPRD3_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTPRD3_ADDR, _WDTIM_WDTPRD3_##Field, Val)
#define _WDTIM_WDTPRD3_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTPRD3_ADDR,AND,OR,INV)
#define _WDTIM_WDTPRD3_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTPRD3_ADDR, _WDTIM_WDTPRD3_##Field,AND,OR,INV)


/*--------------------- Register: WDTPRD4 -----------------------*/
#define _WDTIM_WDTPRD4_GET		  _PREG_GET(_WDTIM_WDTPRD4_ADDR) 
#define _WDTIM_WDTPRD4_SET(Val)		  _PREG_SET(_WDTIM_WDTPRD4_ADDR,Val)
#define _WDTIM_WDTPRD4_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTPRD4_ADDR, _WDTIM_WDTPRD4_##Field)
#define _WDTIM_WDTPRD4_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTPRD4_ADDR, _WDTIM_WDTPRD4_##Field, Val)
#define _WDTIM_WDTPRD4_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTPRD4_ADDR,AND,OR,INV)
#define _WDTIM_WDTPRD4_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTPRD4_ADDR, _WDTIM_WDTPRD4_##Field,AND,OR,INV)


/*--------------------- Register: WDTGPINT -----------------------*/
#define _WDTIM_WDTGPINT_GET		  _PREG_GET(_WDTIM_WDTGPINT_ADDR) 
#define _WDTIM_WDTGPINT_SET(Val)		  _PREG_SET(_WDTIM_WDTGPINT_ADDR,Val)
#define _WDTIM_WDTGPINT_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTGPINT_ADDR, _WDTIM_WDTGPINT_##Field)
#define _WDTIM_WDTGPINT_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTGPINT_ADDR, _WDTIM_WDTGPINT_##Field, Val)
#define _WDTIM_WDTGPINT_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTGPINT_ADDR,AND,OR,INV)
#define _WDTIM_WDTGPINT_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTGPINT_ADDR, _WDTIM_WDTGPINT_##Field,AND,OR,INV)


/*--------------------- Register: WDTGPEN -----------------------*/
#define _WDTIM_WDTGPEN_GET		  _PREG_GET(_WDTIM_WDTGPEN_ADDR) 
#define _WDTIM_WDTGPEN_SET(Val)		  _PREG_SET(_WDTIM_WDTGPEN_ADDR,Val)
#define _WDTIM_WDTGPEN_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTGPEN_ADDR, _WDTIM_WDTGPEN_##Field)
#define _WDTIM_WDTGPEN_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTGPEN_ADDR, _WDTIM_WDTGPEN_##Field, Val)
#define _WDTIM_WDTGPEN_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTGPEN_ADDR,AND,OR,INV)
#define _WDTIM_WDTGPEN_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTGPEN_ADDR, _WDTIM_WDTGPEN_##Field,AND,OR,INV)


/*--------------------- Register: WDTGPDIR -----------------------*/
#define _WDTIM_WDTGPDIR_GET		  _PREG_GET(_WDTIM_WDTGPDIR_ADDR) 
#define _WDTIM_WDTGPDIR_SET(Val)		  _PREG_SET(_WDTIM_WDTGPDIR_ADDR,Val)
#define _WDTIM_WDTGPDIR_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTGPDIR_ADDR, _WDTIM_WDTGPDIR_##Field)
#define _WDTIM_WDTGPDIR_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTGPDIR_ADDR, _WDTIM_WDTGPDIR_##Field, Val)
#define _WDTIM_WDTGPDIR_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTGPDIR_ADDR,AND,OR,INV)
#define _WDTIM_WDTGPDIR_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTGPDIR_ADDR, _WDTIM_WDTGPDIR_##Field,AND,OR,INV)


/*--------------------- Register: WDTGPDAT -----------------------*/
#define _WDTIM_WDTGPDAT_GET		  _PREG_GET(_WDTIM_WDTGPDAT_ADDR) 
#define _WDTIM_WDTGPDAT_SET(Val)		  _PREG_SET(_WDTIM_WDTGPDAT_ADDR,Val)
#define _WDTIM_WDTGPDAT_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTGPDAT_ADDR, _WDTIM_WDTGPDAT_##Field)
#define _WDTIM_WDTGPDAT_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTGPDAT_ADDR, _WDTIM_WDTGPDAT_##Field, Val)
#define _WDTIM_WDTGPDAT_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTGPDAT_ADDR,AND,OR,INV)
#define _WDTIM_WDTGPDAT_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTGPDAT_ADDR, _WDTIM_WDTGPDAT_##Field,AND,OR,INV)


/*--------------------- Register: WDTCTL1 -----------------------*/
#define _WDTIM_WDTCTL1_GET		  _PREG_GET(_WDTIM_WDTCTL1_ADDR) 
#define _WDTIM_WDTCTL1_SET(Val)		  _PREG_SET(_WDTIM_WDTCTL1_ADDR,Val)
#define _WDTIM_WDTCTL1_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTCTL1_ADDR, _WDTIM_WDTCTL1_##Field)
#define _WDTIM_WDTCTL1_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTCTL1_ADDR, _WDTIM_WDTCTL1_##Field, Val)
#define _WDTIM_WDTCTL1_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTCTL1_ADDR,AND,OR,INV)
#define _WDTIM_WDTCTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTCTL1_ADDR, _WDTIM_WDTCTL1_##Field,AND,OR,INV)


/*--------------------- Register: WDTCTL2 -----------------------*/
#define _WDTIM_WDTCTL2_GET		  _PREG_GET(_WDTIM_WDTCTL2_ADDR) 
#define _WDTIM_WDTCTL2_SET(Val)		  _PREG_SET(_WDTIM_WDTCTL2_ADDR,Val)
#define _WDTIM_WDTCTL2_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTCTL2_ADDR, _WDTIM_WDTCTL2_##Field)
#define _WDTIM_WDTCTL2_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTCTL2_ADDR, _WDTIM_WDTCTL2_##Field, Val)
#define _WDTIM_WDTCTL2_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTCTL2_ADDR,AND,OR,INV)
#define _WDTIM_WDTCTL2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTCTL2_ADDR, _WDTIM_WDTCTL2_##Field,AND,OR,INV)


/*--------------------- Register: WDTGCTL1 -----------------------*/
#define _WDTIM_WDTGCTL1_GET		  _PREG_GET(_WDTIM_WDTGCTL1_ADDR) 
#define _WDTIM_WDTGCTL1_SET(Val)		  _PREG_SET(_WDTIM_WDTGCTL1_ADDR,Val)
#define _WDTIM_WDTGCTL1_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTGCTL1_ADDR, _WDTIM_WDTGCTL1_##Field)
#define _WDTIM_WDTGCTL1_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTGCTL1_ADDR, _WDTIM_WDTGCTL1_##Field, Val)
#define _WDTIM_WDTGCTL1_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTGCTL1_ADDR,AND,OR,INV)
#define _WDTIM_WDTGCTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTGCTL1_ADDR, _WDTIM_WDTGCTL1_##Field,AND,OR,INV)


/*--------------------- Register: WDTWCTL1 -----------------------*/
#define _WDTIM_WDTWCTL1_GET		  _PREG_GET(_WDTIM_WDTWCTL1_ADDR) 
#define _WDTIM_WDTWCTL1_SET(Val)		  _PREG_SET(_WDTIM_WDTWCTL1_ADDR,Val)
#define _WDTIM_WDTWCTL1_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTWCTL1_ADDR, _WDTIM_WDTWCTL1_##Field)
#define _WDTIM_WDTWCTL1_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTWCTL1_ADDR, _WDTIM_WDTWCTL1_##Field, Val)
#define _WDTIM_WDTWCTL1_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTWCTL1_ADDR,AND,OR,INV)
#define _WDTIM_WDTWCTL1_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTWCTL1_ADDR, _WDTIM_WDTWCTL1_##Field,AND,OR,INV)


/*--------------------- Register: WDTWCTL2 -----------------------*/
#define _WDTIM_WDTWCTL2_GET		  _PREG_GET(_WDTIM_WDTWCTL2_ADDR) 
#define _WDTIM_WDTWCTL2_SET(Val)		  _PREG_SET(_WDTIM_WDTWCTL2_ADDR,Val)
#define _WDTIM_WDTWCTL2_FGET(Field)	  _PFIELD_GET(_WDTIM_WDTWCTL2_ADDR, _WDTIM_WDTWCTL2_##Field)
#define _WDTIM_WDTWCTL2_FSET(Field,Val)	  _PFIELD_SET(_WDTIM_WDTWCTL2_ADDR, _WDTIM_WDTWCTL2_##Field, Val)
#define _WDTIM_WDTWCTL2_AOI(AND,OR,INV)	  _PREG_AOI(_WDTIM_WDTWCTL2_ADDR,AND,OR,INV)
#define _WDTIM_WDTWCTL2_FAOI(Field,AND,OR,INV)\
	_PFIELD_AOI(_WDTIM_WDTWCTL2_ADDR, _WDTIM_WDTWCTL2_##Field,AND,OR,INV)



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTPID1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTPID1	 - Note: Add description here
*
* Fields:
*	(R)   _WDTIM_WDTPID1_REVISION	
*	(R)   _WDTIM_WDTPID1_CLASS	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _WDTIM_WDTPID1_REVISION:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTPID1_REVISION_SHIFT		(000000u)
#define _WDTIM_WDTPID1_REVISION_MK(n)		(((Uint16)(n) & 0x00ffu) << _WDTIM_WDTPID1_REVISION_SHIFT)
#define _WDTIM_WDTPID1_REVISION_MASK		(_WDTIM_WDTPID1_REVISION_MK(0x00ffu))
#define _WDTIM_WDTPID1_REVISION_CLR		(~(_WDTIM_WDTPID1_REVISION_MASK))



/*----------------------------------------------------------------*\
*   (R)  _WDTIM_WDTPID1_CLASS:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTPID1_CLASS_SHIFT		(0x0008u)
#define _WDTIM_WDTPID1_CLASS_MK(n)		(((Uint16)(n) & 0x00ffu) << _WDTIM_WDTPID1_CLASS_SHIFT)
#define _WDTIM_WDTPID1_CLASS_MASK		(_WDTIM_WDTPID1_CLASS_MK(0x00ffu))
#define _WDTIM_WDTPID1_CLASS_CLR		(~(_WDTIM_WDTPID1_CLASS_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTPID2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTPID2	 - Note: Add description here
*
* Fields:
*	(R)   _WDTIM_WDTPID2_TYPE	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _WDTIM_WDTPID2_TYPE:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTPID2_TYPE_SHIFT		(000000u)
#define _WDTIM_WDTPID2_TYPE_MK(n)		(((Uint16)(n) & 0x007fu) << _WDTIM_WDTPID2_TYPE_SHIFT)
#define _WDTIM_WDTPID2_TYPE_MASK		(_WDTIM_WDTPID2_TYPE_MK(0x007fu))
#define _WDTIM_WDTPID2_TYPE_CLR		(~(_WDTIM_WDTPID2_TYPE_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTWCTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTWCTL1	 - Note: Add description here
*
* Fields:
*	(RW)   _WDTIM_WDTWCTL1_WDIKEY	
*	(RW)   _WDTIM_WDTWCTL1_WDEN	
*	(RW)   _WDTIM_WDTWCTL1_WDFLAG	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTWCTL1_WDIKEY:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTWCTL1_WDIKEY_SHIFT		(0x000cu)
#define _WDTIM_WDTWCTL1_WDIKEY_MK(n)		(((Uint16)(n) & 0x0003u) << _WDTIM_WDTWCTL1_WDIKEY_SHIFT)
#define _WDTIM_WDTWCTL1_WDIKEY_MASK		(_WDTIM_WDTWCTL1_WDIKEY_MK(0x0003u))
#define _WDTIM_WDTWCTL1_WDIKEY_CLR		(~(_WDTIM_WDTWCTL1_WDIKEY_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTWCTL1_WDEN:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTWCTL1_WDEN_SHIFT		(0x000eu)
#define _WDTIM_WDTWCTL1_WDEN_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTWCTL1_WDEN_SHIFT)
#define _WDTIM_WDTWCTL1_WDEN_MASK		(_WDTIM_WDTWCTL1_WDEN_MK(0x0001u))
#define _WDTIM_WDTWCTL1_WDEN_CLR		(~(_WDTIM_WDTWCTL1_WDEN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTWCTL1_WDFLAG:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTWCTL1_WDFLAG_SHIFT		(0x000fu)
#define _WDTIM_WDTWCTL1_WDFLAG_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTWCTL1_WDFLAG_SHIFT)
#define _WDTIM_WDTWCTL1_WDFLAG_MASK		(_WDTIM_WDTWCTL1_WDFLAG_MK(0x0001u))
#define _WDTIM_WDTWCTL1_WDFLAG_CLR		(~(_WDTIM_WDTWCTL1_WDFLAG_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTGCTL1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTGCTL1	 - Note: Add description here
*
* Fields:
*	(RW)   _WDTIM_WDTGCTL1_TIM12RS	
*	(RW)   _WDTIM_WDTGCTL1_TIM34RS	
*	(RW)   _WDTIM_WDTGCTL1_TIMMODE	
*	(RW)   _WDTIM_WDTGCTL1_PSC34	
*	(R)   _WDTIM_WDTGCTL1_TDDR34	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGCTL1_TIM12RS:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGCTL1_TIM12RS_SHIFT		(000000u)
#define _WDTIM_WDTGCTL1_TIM12RS_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTGCTL1_TIM12RS_SHIFT)
#define _WDTIM_WDTGCTL1_TIM12RS_MASK		(_WDTIM_WDTGCTL1_TIM12RS_MK(0x0001u))
#define _WDTIM_WDTGCTL1_TIM12RS_CLR		(~(_WDTIM_WDTGCTL1_TIM12RS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGCTL1_TIM34RS:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGCTL1_TIM34RS_SHIFT		(0x0001u)
#define _WDTIM_WDTGCTL1_TIM34RS_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTGCTL1_TIM34RS_SHIFT)
#define _WDTIM_WDTGCTL1_TIM34RS_MASK		(_WDTIM_WDTGCTL1_TIM34RS_MK(0x0001u))
#define _WDTIM_WDTGCTL1_TIM34RS_CLR		(~(_WDTIM_WDTGCTL1_TIM34RS_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGCTL1_TIMMODE:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGCTL1_TIMMODE_SHIFT		(0x0002u)
#define _WDTIM_WDTGCTL1_TIMMODE_MK(n)		(((Uint16)(n) & 0x0003u) << _WDTIM_WDTGCTL1_TIMMODE_SHIFT)
#define _WDTIM_WDTGCTL1_TIMMODE_MASK		(_WDTIM_WDTGCTL1_TIMMODE_MK(0x0003u))
#define _WDTIM_WDTGCTL1_TIMMODE_CLR		(~(_WDTIM_WDTGCTL1_TIMMODE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGCTL1_PSC34:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGCTL1_PSC34_SHIFT		(0x0008u)
#define _WDTIM_WDTGCTL1_PSC34_MK(n)		(((Uint16)(n) & 0x000fu) << _WDTIM_WDTGCTL1_PSC34_SHIFT)
#define _WDTIM_WDTGCTL1_PSC34_MASK		(_WDTIM_WDTGCTL1_PSC34_MK(0x000fu))
#define _WDTIM_WDTGCTL1_PSC34_CLR		(~(_WDTIM_WDTGCTL1_PSC34_MASK))



/*----------------------------------------------------------------*\
*   (R)  _WDTIM_WDTGCTL1_TDDR34:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGCTL1_TDDR34_SHIFT		(0x000cu)
#define _WDTIM_WDTGCTL1_TDDR34_MK(n)		(((Uint16)(n) & 0x000fu) << _WDTIM_WDTGCTL1_TDDR34_SHIFT)
#define _WDTIM_WDTGCTL1_TDDR34_MASK		(_WDTIM_WDTGCTL1_TDDR34_MK(0x000fu))
#define _WDTIM_WDTGCTL1_TDDR34_CLR		(~(_WDTIM_WDTGCTL1_TDDR34_MASK))





/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTGPDIR register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTGPDIR	 - GPIO direction register
*
* Fields:
*	(RW)   _WDTIM_WDTGPDIR_TIN1DIR
*	(RW)   _WDTIM_WDTGPDIR_TOUT1DIR	

\******************************************************************************/


/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGPDIR_TIN1DIR:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGPDIR_TIN1DIR_SHIFT		(000000u)
#define _WDTIM_WDTGPDIR_TIN1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTGPDIR_TIN1DIR_SHIFT)
#define _WDTIM_WDTGPDIR_TIN1DIR_MASK		(_WDTIM_WDTGPDIR_TIN1DIR_MK(0x0001u))
#define _WDTIM_WDTGPDIR_TIN1DIR_CLR		(~(_WDTIM_WDTGPDIR_TIN1DIR_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGPDIR_TOUT1DIR:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGPDIR_TOUT1DIR_SHIFT		(000001u)
#define _WDTIM_WDTGPDIR_TOUT1DIR_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTGPDIR_TOUT1DIR_SHIFT)
#define _WDTIM_WDTGPDIR_TOUT1DIR_MASK		(_WDTIM_WDTGPDIR_TOUT1DIR_MK(0x0001u))
#define _WDTIM_WDTGPDIR_TOUT1DIR_CLR		(~(_WDTIM_WDTGPDIR_TOUT1DIR_MASK))




/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTCNT1  register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTCNT1 	 - Note: Add description here
*
* Fields:
*	(RW)   _WDTIM_WDTCNT1_CNT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCNT1_CNT:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCNT1_CNT_SHIFT		(000000u)
#define _WDTIM_WDTCNT1_CNT_MK(n)		(((Uint16)(n) & 0xffffu) << _WDTIM_WDTCNT1_CNT_SHIFT)
#define _WDTIM_WDTCNT1_CNT_MASK		(_WDTIM_WDTCNT1_CNT_MK(0xffffu))
#define _WDTIM_WDTCNT1_CNT_CLR		(~(_WDTIM_WDTCNT1_CNT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTWCTL2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTWCTL2	 - Note: Add description here
*
* Fields:
*	(RW)   _WDTIM_WDTWCTL2_WDKEY	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTWCTL2_WDKEY:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTWCTL2_WDKEY_SHIFT		(000000u)
#define _WDTIM_WDTWCTL2_WDKEY_MK(n)		(((Uint16)(n) & 0xffffu) << _WDTIM_WDTWCTL2_WDKEY_SHIFT)
#define _WDTIM_WDTWCTL2_WDKEY_MASK		(_WDTIM_WDTWCTL2_WDKEY_MK(0xffffu))
#define _WDTIM_WDTWCTL2_WDKEY_CLR		(~(_WDTIM_WDTWCTL2_WDKEY_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTGPDAT register			
\*----------------------------------------------------------------*/



/******************************************************************************\
* 
* _WDTIM_WDTGPDAT	 - GPIO data register
*
* Fields:
*	(RW)   _WDTIM_WDTGPDAT_TIN1DAT	
*	(RW)   _WDTIM_WDTGPDAT_TOUT1DAT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGPDAT_TIN1DAT:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGPDAT_TIN1DAT_SHIFT		(000000u)
#define _WDTIM_WDTGPDAT_TIN1DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTGPDAT_TIN1DAT_SHIFT)
#define _WDTIM_WDTGPDAT_TIN1DAT_MASK		(_WDTIM_WDTGPDAT_TIN1DAT_MK(0x0001u))
#define _WDTIM_WDTGPDAT_TIN1DAT_CLR		(~(_WDTIM_WDTGPDAT_TIN1DAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGPDAT_TOUT1DAT:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGPDAT_TOUT1DAT_SHIFT		(000001u)
#define _WDTIM_WDTGPDAT_TOUT1DAT_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTGPDAT_TOUT1DAT_SHIFT)
#define _WDTIM_WDTGPDAT_TOUT1DAT_MASK		(_WDTIM_WDTGPDAT_TOUT1DAT_MK(0x0001u))
#define _WDTIM_WDTGPDAT_TOUT1DAT_CLR		(~(_WDTIM_WDTGPDAT_TOUT1DAT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTGPEN register			
\*----------------------------------------------------------------*/




/******************************************************************************\
* 
* _WDTIM_WDTGPEN	 - GPIO enable register
*
* Fields:
*       (RW)   _WDTIM_WDTGPEN_TIN1EN
*       (RW)   _WDTIM_WDTGPEN_TOUT1EN

\******************************************************************************/

/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGPEN_TIN12EN:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGPEN_TIN1EN_SHIFT		(000000u)
#define _WDTIM_WDTGPEN_TIN1EN_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTGPEN_TIN1EN_SHIFT)
#define _WDTIM_WDTGPEN_TIN1EN_MASK		(_WDTIM_WDTGPEN_TIN1EN_MK(0x0001u))
#define _WDTIM_WDTGPEN_TIN1EN_CLR		        (~(_WDTIM_WDTGPEN_TIN1EN_MASK))


/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGPEN_TOUT1EN:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGPEN_TOUT1EN_SHIFT		(000001u)
#define _WDTIM_WDTGPEN_TOUT1EN_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTGPEN_TOUT1EN_SHIFT)
#define _WDTIM_WDTGPEN_TOUT1EN_MASK		(_WDTIM_WDTGPEN_TOUT1EN_MK(0x0001u))
#define _WDTIM_WDTGPEN_TOUT1EN_CLR		(~(_WDTIM_WDTGPEN_TOUT1EN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTCTL1 register			
\*----------------------------------------------------------------*/



/******************************************************************************\
* 
* _WDTIM_WDTCTL1	 - Timer control register 1
*
* Fields:
*	(R)   _WDTIM_WDTCTL1_TSTAT	
*	(RW)   _WDTIM_WDTCTL1_INVOUT	
*	(RW)   _WDTIM_WDTCTL1_INVIN	
*	(RW)   _WDTIM_WDTCTL1_CP	
*	(RW)   _WDTIM_WDTCTL1_PWID	
*	(RW)   _WDTIM_WDTCTL1_ENAMODE	
*	(RW)   _WDTIM_WDTCTL1_CLKSRC	
*	(RW)   _WDTIM_WDTCTL1_TIEN	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _WDTIM_WDTCTL1_TSTAT:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL1_TSTAT_SHIFT		(000000u)
#define _WDTIM_WDTCTL1_TSTAT_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL1_TSTAT_SHIFT)
#define _WDTIM_WDTCTL1_TSTAT_MASK		        (_WDTIM_WDTCTL1_TSTAT_MK(0x0001u))
#define _WDTIM_WDTCTL1_TSTAT_CLR		        (~(_WDTIM_WDTCTL1_TSTAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL1_INVOUT:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL1_INVOUT_SHIFT		(0x0001u)
#define _WDTIM_WDTCTL1_INVOUT_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL1_INVOUT_SHIFT)
#define _WDTIM_WDTCTL1_INVOUT_MASK		(_WDTIM_WDTCTL1_INVOUT_MK(0x0001u))
#define _WDTIM_WDTCTL1_INVOUT_CLR		        (~(_WDTIM_WDTCTL1_INVOUT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL1_INVIN:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL1_INVIN_SHIFT		(0x0002u)
#define _WDTIM_WDTCTL1_INVIN_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL1_INVIN_SHIFT)
#define _WDTIM_WDTCTL1_INVIN_MASK			(_WDTIM_WDTCTL1_INVIN_MK(0x0001u))
#define _WDTIM_WDTCTL1_INVIN_CLR			(~(_WDTIM_WDTCTL1_INVIN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL1_CP:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL1_CP_SHIFT			(0x0003u)
#define _WDTIM_WDTCTL1_CP_MK(n)			(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL1_CP_SHIFT)
#define _WDTIM_WDTCTL1_CP_MASK			(_WDTIM_WDTCTL1_CP_MK(0x0001u))
#define _WDTIM_WDTCTL1_CP_CLR			(~(_WDTIM_WDTCTL1_CP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL1_PWID:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL1_PWID_SHIFT			(0x0004u)
#define _WDTIM_WDTCTL1_PWID_MK(n)			(((Uint16)(n) & 0x0003u) << _WDTIM_WDTCTL1_PWID_SHIFT)
#define _WDTIM_WDTCTL1_PWID_MASK			(_WDTIM_WDTCTL1_PWID_MK(0x0003u))
#define _WDTIM_WDTCTL1_PWID_CLR			(~(_WDTIM_WDTCTL1_PWID_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL1_ENAMODE:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL1_ENAMODE_SHIFT		(0x0006u)
#define _WDTIM_WDTCTL1_ENAMODE_MK(n)		(((Uint16)(n) & 0x0003u) << _WDTIM_WDTCTL1_ENAMODE_SHIFT)
#define _WDTIM_WDTCTL1_ENAMODE_MASK		(_WDTIM_WDTCTL1_ENAMODE_MK(0x0003u))
#define _WDTIM_WDTCTL1_ENAMODE_CLR		(~(_WDTIM_WDTCTL1_ENAMODE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL1_CLKSRC:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL1_CLKSRC_SHIFT		(0x0008u)
#define _WDTIM_WDTCTL1_CLKSRC_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL1_CLKSRC_SHIFT)
#define _WDTIM_WDTCTL1_CLKSRC_MASK		(_WDTIM_WDTCTL1_CLKSRC_MK(0x0001u))
#define _WDTIM_WDTCTL1_CLKSRC_CLR 		(~(_WDTIM_WDTCTL1_CLKSRC_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL1_TIEN:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL1_TIEN_SHIFT			(0x0009u)
#define _WDTIM_WDTCTL1_TIEN_MK(n)			(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL1_TIEN_SHIFT)
#define _WDTIM_WDTCTL1_TIEN_MASK			(_WDTIM_WDTCTL1_TIEN_MK(0x0001u))
#define _WDTIM_WDTCTL1_TIEN_CLR			(~(_WDTIM_WDTCTL1_TIEN_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTCNT2  register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTCNT2 	 - Note: Add description here
*
* Fields:
*	(RW)   _WDTIM_WDTCNT2_CNT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCNT2_CNT:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCNT2_CNT_SHIFT		(000000u)
#define _WDTIM_WDTCNT2_CNT_MK(n)		(((Uint16)(n) & 0xffffu) << _WDTIM_WDTCNT2_CNT_SHIFT)
#define _WDTIM_WDTCNT2_CNT_MASK		(_WDTIM_WDTCNT2_CNT_MK(0xffffu))
#define _WDTIM_WDTCNT2_CNT_CLR		(~(_WDTIM_WDTCNT2_CNT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTCLK register			
\*----------------------------------------------------------------*/


/******************************************************************************\
* 
* _WDTIM_WDTCLK	 - Timer clock speed register
*
* Fields:
*	(R)   _WDTIM_WDTCLK_CLKDIV
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _WDTIM_WDTCLK_CLKDIV:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCLK_CLKDIV_SHIFT		(000000u)
#define _WDTIM_WDTCLK_CLKDIV_MK(n)		(((Uint16)(n) & 0x000fu) << _WDTIM_WDTCLK_CLKDIV_SHIFT)
#define _WDTIM_WDTCLK_CLKDIV_MASK		        (_WDTIM_WDTCLK_CLKDIV_MK(0x000fu))
#define _WDTIM_WDTCLK_CLKDIV_CLR		        (~(_WDTIM_WDTCLK_CLKDIV_MASK))


/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTCTL2 register			
\*----------------------------------------------------------------*/



/******************************************************************************\
* 
* _WDTIM_WDTCTL2	 - Timer control register 2
*
* Fields:
*	(R)    _WDTIM_WDTCTL2_TSTAT	
*	(RW)   _WDTIM_WDTCTL2_INVOUT	
*	(RW)   _WDTIM_WDTCTL2_INVIN	
*	(RW)   _WDTIM_WDTCTL2_CP	
*	(RW)   _WDTIM_WDTCTL2_PWID	
*	(RW)   _WDTIM_WDTCTL2_ENAMODE	
*	(RW)   _WDTIM_WDTCTL2_CLKSRC	
*	(RW)   _WDTIM_WDTCTL2_TIEN	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _WDTIM_WDTCTL2_TSTAT:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL2_TSTAT_SHIFT		(000000u)
#define _WDTIM_WDTCTL2_TSTAT_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL2_TSTAT_SHIFT)
#define _WDTIM_WDTCTL2_TSTAT_MASK		        (_WDTIM_WDTCTL2_TSTAT_MK(0x0001u))
#define _WDTIM_WDTCTL2_TSTAT_CLR		        (~(_WDTIM_WDTCTL2_TSTAT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL2_INVOUT:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL2_INVOUT_SHIFT		(0x0001u)
#define _WDTIM_WDTCTL2_INVOUT_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL2_INVOUT_SHIFT)
#define _WDTIM_WDTCTL2_INVOUT_MASK		(_WDTIM_WDTCTL2_INVOUT_MK(0x0001u))
#define _WDTIM_WDTCTL2_INVOUT_CLR		        (~(_WDTIM_WDTCTL2_INVOUT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL2_INVIN:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL2_INVIN_SHIFT		(0x0002u)
#define _WDTIM_WDTCTL2_INVIN_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL2_INVIN_SHIFT)
#define _WDTIM_WDTCTL2_INVIN_MASK			(_WDTIM_WDTCTL2_INVIN_MK(0x0001u))
#define _WDTIM_WDTCTL2_INVIN_CLR			(~(_WDTIM_WDTCTL2_INVIN_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL2_CP:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL2_CP_SHIFT			(0x0003u)
#define _WDTIM_WDTCTL2_CP_MK(n)			(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL2_CP_SHIFT)
#define _WDTIM_WDTCTL2_CP_MASK			(_WDTIM_WDTCTL2_CP_MK(0x0001u))
#define _WDTIM_WDTCTL2_CP_CLR			(~(_WDTIM_WDTCTL2_CP_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL2_PWID:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL2_PWID_SHIFT			(0x0004u)
#define _WDTIM_WDTCTL2_PWID_MK(n)			(((Uint16)(n) & 0x0003u) << _WDTIM_WDTCTL2_PWID_SHIFT)
#define _WDTIM_WDTCTL2_PWID_MASK			(_WDTIM_WDTCTL2_PWID_MK(0x0003u))
#define _WDTIM_WDTCTL2_PWID_CLR			(~(_WDTIM_WDTCTL2_PWID_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL2_ENAMODE:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL2_ENAMODE_SHIFT		(0x0006u)
#define _WDTIM_WDTCTL2_ENAMODE_MK(n)		(((Uint16)(n) & 0x0003u) << _WDTIM_WDTCTL2_ENAMODE_SHIFT)
#define _WDTIM_WDTCTL2_ENAMODE_MASK		(_WDTIM_WDTCTL2_ENAMODE_MK(0x0003u))
#define _WDTIM_WDTCTL2_ENAMODE_CLR		(~(_WDTIM_WDTCTL2_ENAMODE_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL2_CLKSRC:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL2_CLKSRC_SHIFT		(0x0008u)
#define _WDTIM_WDTCTL2_CLKSRC_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL2_CLKSRC_SHIFT)
#define _WDTIM_WDTCTL2_CLKSRC_MASK		(_WDTIM_WDTCTL2_CLKSRC_MK(0x0001u))
#define _WDTIM_WDTCTL2_CLKSRC_CLR 		(~(_WDTIM_WDTCTL2_CLKSRC_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCTL2_TIEN:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCTL2_TIEN_SHIFT			(0x0009u)
#define _WDTIM_WDTCTL2_TIEN_MK(n)			(((Uint16)(n) & 0x0001u) << _WDTIM_WDTCTL2_TIEN_SHIFT)
#define _WDTIM_WDTCTL2_TIEN_MASK			(_WDTIM_WDTCTL2_TIEN_MK(0x0001u))
#define _WDTIM_WDTCTL2_TIEN_CLR			(~(_WDTIM_WDTCTL2_TIEN_MASK))




/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTEMU register			
\*----------------------------------------------------------------*/


/******************************************************************************\
* 
* _WDTIM_WDTEMU	 - Emulation management register
*
* Fields:
*	(R)   _WDTIM_WDTEMU_FREE
*   (R)   _WDTIM_WDTEMU_SOFT 	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _WDTIM_WDTEMU_FREE:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTEMU_FREE_SHIFT		(000000u)
#define _WDTIM_WDTEMU_FREE_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTEMU_FREE_SHIFT)
#define _WDTIM_WDTEMU_FREE_MASK		(_WDTIM_WDTEMU_FREE_MK(0x0001u))
#define _WDTIM_WDTEMU_FREE_CLR		(~(_WDTIM_WDTEMU_FREE_MASK))

/*----------------------------------------------------------------*\
*   (R)  _WDTIM_WDTEMU_SOFT:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTEMU_SOFT_SHIFT		(000001u)
#define _WDTIM_WDTEMU_SOFT_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTEMU_SOFT_SHIFT)
#define _WDTIM_WDTEMU_SOFT_MASK		(_WDTIM_WDTEMU_SOFT_MK(0x0001u))
#define _WDTIM_WDTEMU_SOFT_CLR		(~(_WDTIM_WDTEMU_SOFT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTPRD1 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTPRD1	 - Note: Add description here
*
* Fields:
*	(RW)   _WDTIM_WDTPRD1_PRD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTPRD1_PRD:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTPRD1_PRD_SHIFT		(000000u)
#define _WDTIM_WDTPRD1_PRD_MK(n)		(((Uint16)(n) & 0xffffu) << _WDTIM_WDTPRD1_PRD_SHIFT)
#define _WDTIM_WDTPRD1_PRD_MASK		(_WDTIM_WDTPRD1_PRD_MK(0xffffu))
#define _WDTIM_WDTPRD1_PRD_CLR		(~(_WDTIM_WDTPRD1_PRD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTGPINT register			
\*----------------------------------------------------------------*/



/******************************************************************************\
* 
* _WDTIM_WDTGPINT	 - GPIO interrupt control register
*
* Fields:
*       (RW)   _WDTIM_WDTGPINT_TIN1INT	  
*       (RW)   _WDTIM_WDTGPINT_TIN1INV	  

\******************************************************************************/


/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGPINT_TIN1INT:
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGPINT_TIN1INT_SHIFT		(000000u)
#define _WDTIM_WDTGPINT_TIN1INT_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTGPINT_TIN1INT_SHIFT)
#define _WDTIM_WDTGPINT_TIN1INT_MASK		(_WDTIM_WDTGPINT_TIN1INT_MK(0x0001u))
#define _WDTIM_WDTGPINT_TIN1INT_CLR		(~(_WDTIM_WDTGPINT_TIN1INT_MASK))



/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTGPINT_TIN1INV:
\*----------------------------------------------------------------*/

#define _WDTIM_WDTGPINT_TIN1INV_SHIFT		(000004u)
#define _WDTIM_WDTGPINT_TIN1INV_MK(n)		(((Uint16)(n) & 0x0001u) << _WDTIM_WDTGPINT_TIN1INV_SHIFT)
#define _WDTIM_WDTGPINT_TIN1INV_MASK		(_WDTIM_WDTGPINT_TIN1INV_MK(0x0001u))
#define _WDTIM_WDTGPINT_TIN1INV_CLR		(~(_WDTIM_WDTGPINT_TIN1INV_MASK))




/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTPRD2 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTPRD2	 - Note: Add description here
*
* Fields:
*	(RW)   _WDTIM_WDTPRD2_PRD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTPRD2_PRD:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTPRD2_PRD_SHIFT		(000000u)
#define _WDTIM_WDTPRD2_PRD_MK(n)		(((Uint16)(n) & 0xffffu) << _WDTIM_WDTPRD2_PRD_SHIFT)
#define _WDTIM_WDTPRD2_PRD_MASK		(_WDTIM_WDTPRD2_PRD_MK(0xffffu))
#define _WDTIM_WDTPRD2_PRD_CLR		(~(_WDTIM_WDTPRD2_PRD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTPRD3 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTPRD3	 - Note: Add description here
*
* Fields:
*	(RW)   _WDTIM_WDTPRD3_PRD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTPRD3_PRD:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTPRD3_PRD_SHIFT		(000000u)
#define _WDTIM_WDTPRD3_PRD_MK(n)		(((Uint16)(n) & 0xffffu) << _WDTIM_WDTPRD3_PRD_SHIFT)
#define _WDTIM_WDTPRD3_PRD_MASK		(_WDTIM_WDTPRD3_PRD_MK(0xffffu))
#define _WDTIM_WDTPRD3_PRD_CLR		(~(_WDTIM_WDTPRD3_PRD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTCNT3 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTCNT3	 - Note: Add description here
*
* Fields:
*	(RW)   _WDTIM_WDTCNT3_CNT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTCNT3_CNT:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCNT3_CNT_SHIFT		(000000u)
#define _WDTIM_WDTCNT3_CNT_MK(n)		(((Uint16)(n) & 0xffffu) << _WDTIM_WDTCNT3_CNT_SHIFT)
#define _WDTIM_WDTCNT3_CNT_MASK		(_WDTIM_WDTCNT3_CNT_MK(0xffffu))
#define _WDTIM_WDTCNT3_CNT_CLR		(~(_WDTIM_WDTCNT3_CNT_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTPRD4 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTPRD4	 - Note: Add description here
*
* Fields:
*	(RW)   _WDTIM_WDTPRD4_PRD	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (RW)  _WDTIM_WDTPRD4_PRD:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTPRD4_PRD_SHIFT		(000000u)
#define _WDTIM_WDTPRD4_PRD_MK(n)		(((Uint16)(n) & 0xffffu) << _WDTIM_WDTPRD4_PRD_SHIFT)
#define _WDTIM_WDTPRD4_PRD_MASK		(_WDTIM_WDTPRD4_PRD_MK(0xffffu))
#define _WDTIM_WDTPRD4_PRD_CLR		(~(_WDTIM_WDTPRD4_PRD_MASK))



/*----------------------------------------------------------------*\
* Macros to SET/GET and Configure globally the WDTCNT4 register			
\*----------------------------------------------------------------*/

/******************************************************************************\
* 
* _WDTIM_WDTCNT4	 - Note: Add description here
*
* Fields:
*	(R)   _WDTIM_WDTCNT4_CNT	
*
\******************************************************************************/




/*----------------------------------------------------------------*\
*   (R)  _WDTIM_WDTCNT4_CNT:	
\*----------------------------------------------------------------*/

#define _WDTIM_WDTCNT4_CNT_SHIFT		(000000u)
#define _WDTIM_WDTCNT4_CNT_MK(n)		(((Uint16)(n) & 0xffffu) << _WDTIM_WDTCNT4_CNT_SHIFT)
#define _WDTIM_WDTCNT4_CNT_MASK		(_WDTIM_WDTCNT4_CNT_MK(0xffffu))
#define _WDTIM_WDTCNT4_CNT_CLR		(~(_WDTIM_WDTCNT4_CNT_MASK))


#elif (!(_WDTIM_MOD))
	#error WDTIM Hal Module Not Supported on Specified Target
#endif  /* _WDTIM_SUPPORT  */

#endif  /* _CSL_WDTIMHAL_H  */

/******************************************************************************\
*     
*      End of csl_wdtimhal.h 
*
\******************************************************************************/
csl_wdtimdat.h/ 1051539327  0     0     0       2303      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... TIMER
* FILENAME...... csl_wdtimdat.h
* DATE CREATED.. Thu 03/30/2000 
* PROJECT....... Chip Support Library
* COMPONENT..... CSL service layer
* PREREQUISITS..
*------------------------------------------------------------------------------
* HISTORY:
*   MODIFIED: 06/19/2000
*   LAST MODIFIED: (IM) 12/27/2000 modified for Amadeus
*   MODIFIED: 10 April 2003 added refrence CSL_WdtimData for .csldata size fix
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (service layer interface file for the PWR module)
*       Reserved ROM Area for TIMER Data 
*
*
\******************************************************************************/
#ifndef _CSL_WDTIM_DATA_H_
#define _CSL_WDTIM_DATA_H_

#include <csl_std.h>
#include <csl_chiphal.h>

#if (_WDTIMB_SUPPORT)    /* 5502 */
   typedef struct {
 	volatile Uint16 wdtpid1;
	volatile Uint16 wdtpid2;
	volatile Uint16 wdtemu;
	volatile Uint16 wdtclk;
	volatile Uint16 wdtgpint;
	volatile Uint16 wdtgpen;
	volatile Uint16 wdtgpdir;
	volatile Uint16 wdtgpdat;
	volatile Uint16 wdtcnt1;
	volatile Uint16 wdtcnt2;
	volatile Uint16 wdtcnt3;
	volatile Uint16 wdtcnt4;
	volatile Uint16 wdtprd1;
	volatile Uint16 wdtprd2;
	volatile Uint16 wdtprd3;
	volatile Uint16 wdtprd4;
	volatile Uint16 wdtctl1;
	volatile Uint16 wdtctl2;
	volatile Uint16 wdtgctl1;
    volatile Uint16 wdtgctl2;
    volatile Uint16 wdtwctl1;
    volatile Uint16 wdtwctl2;
  } WDTIM_RegObj, *WDTIM_RegPtr;

  #define CSL_WDTIMDATAINIT\
   { 0x0000u, 0x000Bu, (WDTIM_RegPtr)0x4000u }   /* Start of Wtchdog Regs */

  typedef struct {
    Uint16 devNum;
    Uint16 EventId;
    WDTIM_RegPtr regs;
  }CSL_WdtimDataObj;
#else
  #define CSL_WDTIMDATAINIT\
   { 0x000Bu  }  /* WDTIM EventId */

  typedef struct {
    Uint16 WDTIM_reserved;
  }CSL_WdtimDataObj;
 
#endif  /* WDTIM_SUPPORT */

  extern CSL_WdtimDataObj CSL_WdtimData;

  #define CSL_WDTIM_DATA  CSL_WdtimData
#endif

csl_wdtimhal.h/ 1049976964  0     0     0       13259     `
/******************************************************************************\
*           Copyright (C) 1999 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* MODULE NAME... WDTIM
* FILENAME...... csl_wdtimhal.h
* DATE CREATED.. Tues 10/26/1999 
* PROJECT....... Chip Support Library
* COMPONENT..... HAL
* PREREQUISITS.. 
*------------------------------------------------------------------------------
* HISTORY:
*   CREATED:      	07/28/2000 
*   LAST MODIFIED:	12/22/2000 (IM) Modified for Amadeus
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the Watch Dog TIMER module)
*
* Registers Covered:
*   (RW) _WDTIM_WDTCR - watchdog timer control register
*   (RW) _WDTIM_WDTCR2 - watchdog timer control register 2
*   (RW) _WDTIM_WDPRD - watchdog timer period register
*   (RW) _WDTIM_WDTIM - watchdog timer count register
*
\******************************************************************************/
#ifndef _CSL_WDTIMHAL_H_
#define _CSL_WDTIMHAL_H_


#include <csl_chiphal.h>

#if (_WDTIM_SUPPORT)
/****************************************\
* TIMER scope and inline control macros
\****************************************/

/*----------------------------------------------------------------------------*\
* Register Macros:
\*----------------------------------------------------------------------------*/
#define WDTIM_ADDR(Reg)               _WDTIM_##Reg##_ADDR
#define WDTIM_RGET(Reg)               _WDTIM_##Reg##_GET
#define WDTIM_RSET(Reg,Val)           _WDTIM_##Reg##_SET(Val)
#define WDTIM_RAOI(Reg,AND,OR,INV)    _WDTIM_##Reg##_AOI(AND,OR,INV)
#define WDTIM_FGET(Reg,Field)         _WDTIM_##Reg##_FGET(##Field)
#define WDTIM_FSET(Reg,Field,Val)     _WDTIM_##Reg##_FSET(##Field,Val)
#define WDTIM_FSETS(Reg,Field,Sym)    WDTIM_FSET(Reg,Field,WDTIM_##Reg##_##Field##_##Sym)
#define WDTIM_FAOI(Reg,Field,AND,OR,INV)\
  _WDTIM_##Reg##_FAOI(Field,AND,OR,INV)
#define WDTIM_FMK(Reg,Field,Val)      _WDTIM_##Reg##_##Field##_MK(Val)
#define WDTIM_FMKS(Reg,Field,Sym)     WDTIM_FMK(##Reg,##Field,WDTIM_##Reg##_##Field##_##Sym)


/******************************************************************************\
* _WDTIM_WDTIM - Watch Dog Timer Timer/Count register
*
* Fields:
*   (RW) TIM
*
\******************************************************************************/


#define _WDTIM_DEVICE_CNT        	  1

#define _WDTIM_WDTIM_ADDR             (0x4000u)
#define _WDTIM_WDTIM                  PREG16(_WDTIM_WDTIM_ADDR)
#define _WDTIM                         _WDTIM_WDTIM


/*----------------------------------------------------------------------------*\
* (RW) _WDTIM_WDTIM_TIM
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTIM_TIM_SHIFT       (0x0000u)
#define _WDTIM_WDTIM_TIM_MK(n)       (((Uint16)(n) & 0xffffu)<< _WDTIM_WDTIM_TIM_SHIFT)
#define _WDTIM_WDTIM_TIM_MASK        (_WDTIM_WDTIM_TIM_MK(0xffffu))
#define _WDTIM_WDTIM_TIM_CLR         (~(_WDTIM_WDTIM_TIM_MASK))

/*----------------------------------------------------------------------------*\
* Register Macros:
\*----------------------------------------------------------------------------*/


#define _WDTIM_WDTIM_GET              _PREG_GET(_WDTIM_WDTIM_ADDR)
#define _WDTIM_WDTIM_SET(Val)         _PREG_SET(_WDTIM_WDTIM_ADDR,Val)
#define _WDTIM_WDTIM_AOI(AND,OR,INV)  _PREG_AOI(_WDTIM_WDTIM_ADDR,AND,OR,INV)
#define _WDTIM_WDTIM_FGET(Field)      _PFIELD_GET(_WDTIM_WDTIM_ADDR,_WDTIM_WDTIM_##Field)
#define _WDTIM_WDTIM_FSET(Field,Val)  _PFIELD_SET(_WDTIM_WDTIM_ADDR,_WDTIM_WDTIM_##Field,Val)
#define _WDTIM_WDTIM_FSETS(Field,Sym) _WDTIM_WDPRD_FSETS(##Field,WDTIM_WDTIM_##Field##_##Sym)
#define _WDTIM_WDTIM_FAOI(Field,AND,OR,INV)\
   _PFIELD_FAOI(_WDTIM_WDPRD_ADDR,_WDTIM_WDPRD_##Field,AND,OR,INV)


/******************************************************************************\
* _WDTIM_WDPRD - Watch Dog Timer Period Register
*
* Fields:
*   (RW) PRD
*
\******************************************************************************/

#define _WDTIM_WDPRD_ADDR             (0x4001u)
#define _WDTIM_WDPRD                  PREG16(_WDTIM_WDPRD_ADDR)
#define _WDPRD                         _WDTIM_WDPRD

/*----------------------------------------------------------------------------*\
* (RW) WDTIM_WDPRD_PRD
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDPRD_PRD_SHIFT       (0x0000u)
#define _WDTIM_WDPRD_PRD_MK(n)       (((Uint16)(n) & 0xffffu)<< _WDTIM_WDPRD_PRD_SHIFT)
#define _WDTIM_WDPRD_PRD_MASK        (_WDTIM_WDPRD_PRD_MK(0xffffu))
#define _WDTIM_WDPRD_PRD_CLR         (~(_WDTIM_WDPRD_PRD_MASK))

/*----------------------------------------------------------------------------*\
* Register Macros:
\*----------------------------------------------------------------------------*/


#define _WDTIM_WDPRD_GET              _PREG_GET(_WDTIM_WDPRD_ADDR)
#define _WDTIM_WDPRD_SET(Val)         _PREG_SET(_WDTIM_WDPRD_ADDR,Val)
#define _WDTIM_WDPRD_AOI(AND,OR,INV)  _PREG_AOI(_WDTIM_WDPRD_ADDR,AND,OR,INV)
#define _WDTIM_WDPRD_FGET(Field)      _PFIELD_GET(_WDTIM_WDPRD_ADDR,_WDTIM_WDPRD_##Field)
#define _WDTIM_WDPRD_FSET(Field,Val)  _PFIELD_SET(_WDTIM_WDPRD_ADDR,_WDTIM_WDPRD_##Field,Val)
#define _WDTIM_WDPRD_FSETS(Field,Sym) _WDTIM_WDPRD_FSETS(##Field,WDTIM_WDPRD_##Field##_##Sym)
#define _WDTIM_WDPRD_FAOI(Field,AND,OR,INV)\
   _PFIELD_FAOI(_WDTIM_WDPRD_ADDR,_WDTIM_WDPRD_##Field,AND,OR,INV)

/******************************************************************************\
* _WDTIM_TCR 
*
* Fields:
*   (RW) _WDTIM_WDTCR_WDOUT
*   (RW) _WDTIM_WDTCR_SOFT
*   (RW) _WDTIM_WDTCR_FREE
*   (R)  _WDTIM_WDTCR_PSC
*   (RW) _WDTIM_WDTCR_TDDR
*
\******************************************************************************/

#define _WDTIM_WDTCR_ADDR             (0x4002u)
#define _WDTIM_WDTCR                  PREG16(_WDTIM_WDTCR_ADDR)
#define _WDTCR                         _WDTIM_WDTCR

/*----------------------------------------------------------------------------*\
* Watch Dog Timer Control Register (WDTCR) bit/field definitions
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
* (RW) WDTIM_WDTCR_WDOUT
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR_WDOUT_SHIFT       (0x000cu)
#define _WDTIM_WDTCR_WDOUT_MK(n)       (((Uint16)(n) & 0x0003u)<< _WDTIM_WDTCR_WDOUT_SHIFT)
#define _WDTIM_WDTCR_WDOUT_MASK        (_WDTIM_WDTCR_WDOUT_MK(3))
#define _WDTIM_WDTCR_WDOUT_CLR         (~(_WDTIM_WDTCR_WDOUT_MASK))

/*----------------------------------------------------------------------------*\
* (RW) WDTIM_WDTCR_SOFT
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR_SOFT_SHIFT       (0x000bu)
#define _WDTIM_WDTCR_SOFT_MK(n)       (((Uint16)(n) & 0x0001u)<< _WDTIM_WDTCR_SOFT_SHIFT)
#define _WDTIM_WDTCR_SOFT_MASK        (_WDTIM_WDTCR_SOFT_MK(1))
#define _WDTIM_WDTCR_SOFT_CLR         (~(_WDTIM_WDTCR_SOFT_MASK))

/*----------------------------------------------------------------------------*\
* (RW) WDTIM_WDTCR_FREE
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR_FREE_SHIFT       (0x000au)
#define _WDTIM_WDTCR_FREE_MK(n)       (((Uint16)(n) &0x0001u) << _WDTIM_WDTCR_FREE_SHIFT)
#define _WDTIM_WDTCR_FREE_MASK        (_WDTIM_WDTCR_FREE_MK(1))
#define _WDTIM_WDTCR_FREE_CLR         (~(_WDTIM_WDTCR_FREE_MASK))

/*----------------------------------------------------------------------------*\
* (R) WDTIM_WDTCR_PSC
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR_PSC_SHIFT        (0x0006u)
#define _WDTIM_WDTCR_PSC_MK(n)     	(((Uint16)(n) & 0x000fu) << 6)
#define _WDTIM_WDTCR_PSC_MASK     	(_WDTIM_WDTCR_PSC_MK(0x000fu))
#define _WDTIM_WDTCR_PSC_CLR     	(~_WDTIM_WDTCR_PSC_MK(0x000fu))

/*----------------------------------------------------------------------------*\
* (RW) WDTIM_WDTCR_TDDR
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR_TDDR_SHIFT       (0x0000u)
#define _WDTIM_WDTCR_TDDR_MK(n)       (((Uint16)(n) & 0x000fu)<< _WDTIM_WDTCR_TDDR_SHIFT)
#define _WDTIM_WDTCR_TDDR_MASK	  (_WDTIM_WDTCR_TDDR_MK(0x000fu))
#define _WDTIM_WDTCR_TDDR_CLR	 	  (~(_WDTIM_WDTCR_TDDR_MASK))

/*----------------------------------------------------------------------------*\
* Register Macros:
\*----------------------------------------------------------------------------*/

#define _WDTIM_WDTCR_SET(Val)         _PREG_SET(_WDTIM_WDTCR_ADDR,Val)
#define _WDTIM_WDTCR_GET              _PREG_GET(_WDTIM_WDTCR_ADDR)
#define _WDTIM_WDTCR_AOI(AND,OR,INV)  _PREG_AOI(_WDTIM_WDTCR_ADDR,AND,OR,INV)
#define _WDTIM_WDTCR_FGET(Field)      _PFIELD_GET(_WDTIM_WDTCR_ADDR,_WDTIM_WDTCR_##Field)
#define _WDTIM_WDTCR_FSET(Field,Val)  _PFIELD_SET(_WDTIM_WDTCR_ADDR,_WDTIM_WDTCR_##Field,Val)
#define _WDTIM_WDTCR_FSETS(Field,Sym) _WDTIM_WDTCR_FSETS(##Field,WDTIM_WDTCR_##Field##_##Sym)
#define _WDTIM_WDTCR_FAOI(Field,AND,OR,INV)\
   _PFIELD_FAOI(_WDTIM_WDTCR_ADDR,_WDTIM_WDTCR_##Field,AND,OR,INV)

/******************************************************************************\
* _WDTIM_WDTCR2 - Watch Dog Timer Secondary Control Register
*
* Fields:
*   (RW) WDTCR2_WDFLAG
*   (RW) WDTCR2_WDEN
*   (RW) WDTCR2_PREMD
*   (RW) WDTCR2_WDKEY
*
\******************************************************************************/


#define _WDTIM_WDTCR2_ADDR            (0x4003u)
#define _WDTIM_WDTCR2                 PREG16(_WDTIM_WDTCR2_ADDR)
#define _WDTCR2                        _WDTIM_WDTCR2


/*----------------------------------------------------------------------------*\
* (RW) HWDTCR2_WDFLAG - Watch Dog Timeout flag
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR2_WDFLAG_SHIFT      (0x000fu)
#define _WDTIM_WDTCR2_WDFLAG_MK(n)      (((Uint16)(n) & 0x0001u)<< _WDTIM_WDTCR2_WDFLAG_SHIFT)
#define _WDTIM_WDTCR2_WDFLAG_MASK       (_WDTIM_WDTCR2_WDFLAG_MK(0x0001u))
#define _WDTIM_WDTCR2_WDFLAG_CLR        (~(_WDTIM_WDTCR2_WDFLAG_MASK))

/*----------------------------------------------------------------------------*\
* (RW) HWDTCR2_WDEN - Watch Dog Timer Enable Bit
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR2_WDEN_SHIFT       (0x000eu)
#define _WDTIM_WDTCR2_WDEN_MK(n)       (((Uint16)(n) & 0x0001u)<< _WDTIM_WDTCR2_WDEN_SHIFT)
#define _WDTIM_WDTCR2_WDEN_MASK        (_WDTIM_WDTCR2_WDEN_MK(0x0001u))
#define _WDTIM_WDTCR2_WDEN_CLR         (~(_WDTIM_WDTCR2_WDEN_MASK))

/*----------------------------------------------------------------------------*\
* (RW) HWDTCR2_PREMD - Watch Dog Timer Pre-scaler Mode Bit
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR2_PREMD_SHIFT      (0x000cu)
#define _WDTIM_WDTCR2_PREMD_MK(n)      (((Uint16)(n) & 0x0001u)<< _WDTIM_WDTCR2_PREMD_SHIFT)
#define _WDTIM_WDTCR2_PREMD_MASK       (_WDTIM_WDTCR2_PREMD_MK(0x0001u))
#define _WDTIM_WDTCR2_PREMD_CLR        (~(_WDTIM_WDTCR2_PREMD_MASK))

/*----------------------------------------------------------------------------*\
* (RW) HWDTCR2_WDKEY - Watch Dog Timer Pre-scaler Mode Bit
\*----------------------------------------------------------------------------*/
#define _WDTIM_WDTCR2_WDKEY_SHIFT      (0x0000u)
#define _WDTIM_WDTCR2_WDKEY_MK(n)      (((Uint16)(n) & 0xFFFu)<< _WDTIM_WDTCR2_WDKEY_SHIFT)
#define _WDTIM_WDTCR2_WDKEY_MASK       (_WDTIM_WDTCR2_WDKEY_MK(0xFFFu))
#define _WDTIM_WDTCR2_WDKEY_CLR        (~(_WDTIM_WDTCR2_WDKEY_MASK))

/*----------------------------------------------------------------------------*\
* Register Macros:
\*----------------------------------------------------------------------------*/

#define _WDTIM_WDTCR2_GET              _PREG_GET(_WDTIM_WDTCR2_ADDR)
#define _WDTIM_WDTCR2_SET(Val)         _PREG_SET(_WDTIM_WDTCR2_ADDR,Val)
#define _WDTIM_WDTCR2_AOI(AND,OR,INV)  _PREG_AOI(_WDTIM_WDTCR2_ADDR,AND,OR,INV)
#define _WDTIM_WDTCR2_FGET(Field)      _PFIELD_GET(_WDTIM_WDTCR2_ADDR,_WDTIM_WDTCR2_##Field)
#define _WDTIM_WDTCR2_FSET(Field,Val)  _PFIELD_SET(_WDTIM_WDTCR2_ADDR,_WDTIM_WDTCR2_##Field,Val)
#define _WDTIM_WDTCR2_FSETS(Field,Sym) _WDTIM_WDTCR2_FSETS(##Field,WDTIM_WDTCR2_##Field##_##Sym)
#define _WDTIM_WDTCR2_FAOI(Field,AND,OR,INV)\
   _PFIELD_FAOI(_WDTIM_WDTCR2_ADDR,_WDTIM_WDTCR2_##Field,AND,OR,INV)


#else
  #ifndef _WDTIM_MOD_ /* _WDTIMHAL_H_ */
     #error WatchDog Timer HAL Module Not Supported on Specified Target
  #endif
#endif  
#endif /* _CSL_WDTIMHAL_H_ */
/******************************************************************************\
* End of csl_wdtimhal.h
\******************************************************************************/

irq_pluga.asm/  1070367897  0     0     0       4789      `
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
; Module: IRQ
; Function: IRQ_PLUG
; File: csl_irqplug.asm
;*! History:
;*!   01/17/2002 Fixed extended memory page problem with 
;*!              XAR2,XAR3
;*!   11/13/2002 Fixed potential problem caused by not writing
;*!              valid instruction in vector slot following the
;*!              vector address.
;--------------------------------------------------------
; Description:
;   This function writes the address of the given ISR into
; the correct location in the interrupt vector table.
;
; Arguments:
;     T0 - contains EventId of associated vector
;     AC0 - contains address of ISR
;
; Local Function Variables:
;     SP(#0)   - location in vector table where ISR address
;                needs to be placed
;     SP(#2)   - ISR function address
;     SP(#4)   - IVPD pointer value
;     SP(#5)   - Bit in IER corresponding to event
;     SP(#6)   - Mask used to clear event in IFR
;     SP(#7)   - EventId
;     SP(#8)   - old_intm, old value of INTM bit
;////////////////////////////////////////////////////////
	.asg 123, CSL_DATA_PTR
	.asg 05E80h, NOP16_Operator
	.asg 0, VecLoc
	.asg 2, IsrAddr
	.asg 4, Iptr
	.asg 5, EventBit
	.asg 6, EventMask
	.asg 7, EventId
	.asg 8, Old_INTM
	.asg 9, LocalFrameSz
	.asg 12, BiosPresentFlag
      .asg 049h, IVPD_ADDR
      .asg 04Ah, IVPH_ADDR
      .asg 001h, IFR0_ADDR
      .asg 046h, IFR1_ADDR

	.mmregs

	.def _IRQ_plug

	.ref _IRQ_globalDisable
	.ref _IRQ_globalRestore
      .cpl_on
_IRQ_plug:
      PSHBOTH(XAR3)
      PSHBOTH(XAR2)
      SP = SP - #LocalFrameSz          ; Reserve local space
      dbl(*SP(#IsrAddr)) = AC0         ; Store ISR function address
      *SP(#EventId) = T0               ; Store EventId
      AC0 = #0                         ; Clear XAR2/XAR3
      XAR2 = AC0                       ;
      XAR3 = AC0	                   ;

      CALL _IRQ_globalDisable          ; Disable Interrupts
      *SP(#Old_INTM) = T0              ; Save OLD VALUE of INTM
      NOP
      NOP
      NOP
      NOP
      NOP
      XAR2 = #IVPD_ADDR                ; Get IVPD value
      NOP
      NOP
      NOP
      NOP
      NOP
      AC1 = *SP(#EventId)              ; EventId Gets placed in AC1

      AC3  = AC1 & #018h               ; Check for ISRs 16-23
      AC3 = AC3 - #16                  ; If ISR is 16-23 then use
      if (AC3 == 0) execute (AD_UNIT)  ; IVPH value for determining
      XAR2 = #IVPH_ADDR                ; vector address

      AC1 = AC1 << #3                  ; Multiply EventId by 8 to get Vector Offset          
      AC0 = *AR2                       ; AC0 should now have IVPD value
      AC0 = AC0 <<  #8                 ; Shift up to get Vector Base Address
      AC0 = AC0 | AC1                  ; AC0 now has Vector Address
      AC0 = AC0 << #-1                 ; Shift to get word address
      dbl(*SP(#VecLoc)) = AC0          ; Store Vector Address
      AC0 = dbl(*SP(#IsrAddr))         ; AC0 now has ISR address
      XAR3 = dbl(*SP(#VecLoc))         ; XAR3 has Vector Address
      AR1 = *SP(#EventId)              ; AR1 gets EventId
      AR2 = AR1 & #15                  ; Get only lower bits
      dbl(*AR3) = AC0                  ; Store ISR address at Vector Location
      AC3 = NOP16_Operator             ; Load NOP instruction into AC3
      AR3 += 2                         ; Set byte address to next location
      *AR3 = AC3                       ; Plug remaining part of vector with nop
      AR3 += 1                         ; Increment to next part of vector location
      *AR3 = AC3                       ; Plug remaining part of vector with nop
      T0 = AR2                         ; Use lower Bits as shift value
      AR1 = AR1 & #16                  ; Check to see if event is flagged in IFR1
      AC0 = #1                         ; Set AC0 = 1
      AC0 = AC0 <<< T0                 ; Shift AC0 by Bit value
      AC3 = AC0                        ; This is mask for IFR

      if (AR1 != #0) goto LIFR1        ; IF AR1 != 0, mask IFR1
      AR2 = #IFR0_ADDR                 ; Point AR2 to IFR0
      *AR2 = AC3                       ; Mask IFR0
      goto RESTORE_INTM
LIFR1:
      AR2 = #IFR1_ADDR                 ; Point AR2 to IFR1
      *AR2 = AC3                       ; Mask IFR1
RESTORE_INTM:
      T0 = *SP(#Old_INTM)              ; Set T0 to old INTM Value
      CALL _IRQ_globalRestore          ; Call IRQ function to restore old_intm
EPILOGUE:
      SP = SP + #LocalFrameSz          ; Restore Stack Pointer
      XAR2 = POPBOTH()                 ; POP XAR regs
      XAR3 = POPBOTH()
      RETURN
usb_vect.asm/   1049977363  0     0     0       15500     `
*********************************************************************
** api_vect.s55                                                    **
**                                                                 **
** Copyright (c) 2001, Texas Instruments, Inc.                     **
** All rights reserved.                                            **
**                                                                 **
** TMS320C55x code for VC5509 ROM API Call Table                   **
**                                                                 **
** Author: MH(partial)                                             **
**                                                                 **
** Based On:  API Call Vector table and the API Look Up Table      **
**            for security routines or media drivers developed by  **
**            Bill Wrightson for IA group                          **
**                                                                 **
** Date: 01 Mar 2001                                               **
**                                                                 **
** 18 Jul 2001 $MH$                                                **
** Replaced USB_setParams with USB_init                            **
**                                                                 **
*********************************************************************

*********************************************************************
* This file includes the API Call Vector table and the API Look Up  *
* Table which are combined to implement a relocate-able call table  *
* for the USB API routines                                          *
*                                                                   *
* This relocateable table allows user applications to call these    *
* routines out of ROM or out of RAM by relocating the API Vector    *
* Table to RAM and replacing any desired functions with new ones    *
* while still being able to use ROM functions.  The initial API     *
* Vector Table contained in this file is the ROM version which will *
* be used as the default table until or if a user application moves *
* the table to another location in ROM or more likely RAM.          *
*                                                                   *
* This scheme is specially helpful to replace the buggy USB API in  *
* ROM with a bug free one                                           *
*                                                                   *
* USB Memory locations 0x667E and 0x667F are reserved to point to   *
* the API Vector Table.  These are 8 bit locations and hold the     *
* two bytes of a 24 bit address, the lower byte is assumed to be 0  *
* thus forcing the table to be allocated on 256 byte boundaries.    *
*                                                                   *
*********************************************************************
* Revision 0.0                                                      *
*********************************************************************


*********************************************************************
*                      Constants                                    *
*********************************************************************
USBIDLCTL        .set 7000h    ; USB Idle Control Register address
USBIDLCTL_USBEN  .set 0004h    ; USB enable bit mask

USB_API_PTR      .set 667Eh    ; USB RAM pointer to API Vector Table


*********************************************************************
*                      Global Symbols                               *
*********************************************************************
                .def  _USB_setAPIVectorAddress


*********************************************************************
* API Vector Table - This is a table of call vectors for VC5509     *
*                    USB API routines .  This table can be          *
*                    copied to RAM and used if the USB RAM pointers *
*                    are changed to the new location.  The symbols  *
*                    defined in this table are used for calculating *
*                    the index of each function within the table.   *
*                    This index is used in the API LUT to call the  *
*                    proper function for use while in ROM.  If this *
*                    table is copied to RAM the symbols can be      *
*                    replaced with the actual function call symbols *
*                    from the API LUT such that the API LUT code    *
*                    can be skipped for this new table. Functions   *
*                    in ROM will still have to go through the API   *
*                    LUT process so that they will use the new API  *
*                    Vector Table.                                  *
*********************************************************************

                .sect   "api_vect"

VecMacro .macro base, target
        .ref    _:target:
r:base: goto    _:target:
        .endm

                .align  256
                .def    _ROM_API_TABLE
_ROM_API_TABLE
        VecMacro USB_getEvents                 , vUSB_getEvents              
        VecMacro USB_peekEvents                , vUSB_peekEvents                                              
        VecMacro USB_getSetupPacket            , vUSB_getSetupPacket                                                                     
        VecMacro USB_postTransaction           , vUSB_postTransaction                                                                    
        VecMacro USB_isTransactionDone         , vUSB_isTransactionDone                                                                   
        VecMacro USB_bytesRemaining            , vUSB_bytesRemaining                                                                     
        VecMacro USB_stallEndpt                , vUSB_stallEndpt                                                                         
        VecMacro USB_clearEndptStall           , vUSB_clearEndptStall                                                                    
        VecMacro USB_getEndptStall             , vUSB_getEndptStall                                                                      
        VecMacro USB_initEndptObj              , vUSB_initEndptObj                                                                        
        VecMacro _USB_configEndpt              , _vUSB_configEndpt                                                                                 
        VecMacro USB_init                      , vUSB_init                                                                               
        VecMacro _USB_addInterface             , _vUSB_addInterface                                                                           
        VecMacro USB_epNumToHandle             , vUSB_epNumToHandle                                                                         
        VecMacro _USB_resetFirmwareEnv         , _vUSB_resetFirmwareEnv                                                                       
        VecMacro USB_abortTransaction          , vUSB_abortTransaction                                                                      
        VecMacro USB_abortAllTransaction       , vUSB_abortAllTransaction                                                                     
        VecMacro _USB_enableEpIntrpt           , _vUSB_enableEpIntrpt                                                                        
        VecMacro _USB_disableEpIntrpt          , _vUSB_disableEpIntrpt                                                                        
        VecMacro _USB_enableDmaIntrpt          , _vUSB_enableDmaIntrpt                                                                  
        VecMacro _USB_disableDmaIntrpt         , _vUSB_disableDmaIntrpt
        
        VecMacro USB_connectDev                , vUSB_connectDev                                                                         
        VecMacro USB_disconnectDev             , vUSB_disconnectDev                                                                                                                                     
        VecMacro USB_setRemoteWakeup           , vUSB_setRemoteWakeup
        VecMacro USB_getRemoteWakeupStat       , vUSB_getRemoteWakeupStat
        VecMacro USB_issueRemoteWakeup         , vUSB_issueRemoteWakeup                                                                                                                         
        VecMacro USB_resetDev                  , vUSB_resetDev                                                   
        VecMacro USB_setDevAddr                , vUSB_setDevAddr                                                                                                                              
        VecMacro USB_getFrameNo                , vUSB_getFrameNo                                      
                                                                                                                                         
        VecMacro USB_initPLL                   , vUSB_initPLL                                                                                  
        VecMacro _USB_procCtrlOutTransaction   , _vUSB_procCtrlOutTransaction                                                                               
        VecMacro _USB_procCtrlInTransaction    , _vUSB_procCtrlInTransaction                                                                        
        VecMacro _USB_procDmaTransaction       , _vUSB_procDmaTransaction
        VecMacro _USB_gotoNextList             , _vUSB_gotoNextList                                                                               
        VecMacro USB_evDispatch                , vUSB_evDispatch                                                                                           
                                                                        
; reserve some space for future entries... total of 63 entries

                .space     28*32                   

*********************************************************************
* API Look Up Table - This is a table of individual look up table   *
*                     routines which are used to call a function    *
*                     in the API Vector Table while using a global  *
*                     memory pointer to indicate which API Vector   *
*                     table needs to be used at run-time.  This     *
*                     table implements the relocation capability of *
*                     the call table system.
*********************************************************************

                .sect   "api_lut"
_GetApiLutStart
        push(AR5)                        ; save AR5 for the C env.
        dbl(push(AC0))                   ; save AC0 for the C env.
     || AR5 = #USB_API_PTR               ; get ptr to API Vect table
        AC0 = *AR5+ << #16 || readport() ; read A23-A16 of API Table
        AC3 = *AR5  << #8  || readport() ; read A15-A8 of API Table
        AC3 = AC3 + AC0                  ; combine A23-A16 and A15-A8
     || AC0 = dbl(pop())                 ; restore AC0
        AR5 = pop()                      ; restore AR5
        return

*********************************************************************
* API Function indexes - These are indexes used in the API LUT code.*
*                        These indexes indicate the offset for each *
*                        vector in the API Call Vector table.       *
*********************************************************************
LutMacro .macro base
i:base: .set (r:base: - _ROM_API_TABLE)
        .def    _:base:

_:base:
        call _GetApiLutStart
        AC3 = AC3 + #i:base:             ; add API offset to base addr
        goto AC3                         ; call API vector
        .endm

        LutMacro USB_getEvents           ; total 26 entries
        LutMacro USB_peekEvents
        LutMacro USB_getSetupPacket
        LutMacro USB_postTransaction
        LutMacro USB_isTransactionDone
        LutMacro USB_bytesRemaining
        LutMacro USB_stallEndpt
        LutMacro USB_clearEndptStall
        LutMacro USB_getEndptStall
        LutMacro USB_initEndptObj
        LutMacro _USB_configEndpt
        LutMacro USB_init
        LutMacro _USB_addInterface
        LutMacro USB_epNumToHandle
        LutMacro _USB_resetFirmwareEnv
        LutMacro USB_abortTransaction
        LutMacro USB_abortAllTransaction
        LutMacro _USB_enableEpIntrpt
        LutMacro _USB_disableEpIntrpt
        LutMacro _USB_enableDmaIntrpt       
        LutMacro _USB_disableDmaIntrpt 
        LutMacro USB_connectDev       
        LutMacro USB_disconnectDev
        LutMacro USB_setRemoteWakeup
        LutMacro USB_getRemoteWakeupStat    
        LutMacro USB_issueRemoteWakeup
        LutMacro USB_resetDev     
        LutMacro USB_setDevAddr       
        LutMacro USB_getFrameNo              
        LutMacro USB_initPLL       
        LutMacro _USB_procCtrlOutTransaction
        LutMacro _USB_procCtrlInTransaction
        LutMacro _USB_procDmaTransaction
        LutMacro _USB_gotoNextList       
        LutMacro USB_evDispatch       

                .sect   ".text"              

********************************************************************************
** Name     : _USB_setAPIVectorAddress                                        **
**                                                                            **
** Purpose  : Initialize the USB API vector pointer with the address of the   **
**            address of the USB API lookup table.  The default address of    **
**            the USB API lookup table is in the ROM.                         **
**                                                                            **
** Author   : MH                                                              **
**                                                                            **
********************************************************************************
_USB_setAPIVectorAddress:

        push(AR5)                         ; save AR5 for the C env.
        dbl(push(AC0))                    ; save AC0 for the C env.
        
        AR5  = #USBIDLCTL                 ; get ptr to API Vect table
        AC0  = *AR5 || readport()         ; read USB idle ctrl reg
        AC0  = AC0 | #USBIDLCTL_USBEN     ; set USB enable bit
        *AR5 = AC0 || writeport()         ; read USB idle ctrl reg
        
        AR5 = #USB_API_PTR                ; get ptr to API Vect table
        AC0 = #(_ROM_API_TABLE >> 8)      ; read A23-A8 of API Table 
               
        AC3 = AC0 << #-8                  ; move A23-A16 of API Table to AC3
        *AR5+ = AC3 || writeport()        ; write A23-A16 of API Table
        
        AC3  = AC0 & #00FFh               ; A15-A8 of API Table to AC3
        *AR5  = AC3 || writeport()        ; write A15-A8 of API Table
        
        AC0 = dbl(pop())                  ; restore AC0
        AR5 = pop()                       ; restore AR5
        return
        
        .end

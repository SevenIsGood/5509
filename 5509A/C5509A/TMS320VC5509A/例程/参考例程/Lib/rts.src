!<arch>
_bufread.c/     1148595152  0     0     0       3584      `
/*****************************************************************************/

/*  _BUFREAD.C v3.3.2                                                        */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/

 

/*****************************************************************************/

/* Functions:                                                                */

/*    _BUFF_READ  -  Fill a stream's buffer from its file                    */

/*****************************************************************************/

#include <stdio.h>

#include <_lock.h>

#include "file.h"



extern _DATA_ACCESS int  _ft_end;

extern int  _doflush(FILE *_fp);

extern void _buff_read(FILE *_fp);





/*****************************************************************************/

/* _BUFF_READ  -   Fill a stream's buffer from its file                      */

/*                                                                           */

/*    This function fills stream _FP's buffer with the contents of the file  */

/*    it is associated with.  It returns nothing, but sets flags in the      */

/*    stream if any I/O errors occur.                                        */

/*                                                                           */

/*****************************************************************************/

void _buff_read(FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   int   errchk,

         j,

         buffer_size    = _fp->bufend - _fp->buf;



   /*------------------------------------------------------------------------*/

   /* If this is a line buffered stream, flush all line buffered streams.    */

   /*------------------------------------------------------------------------*/

   if(_BUFFMODE(_fp) == _IOLBF)

   {

       /*--------------------------------------------------------------------*/

       /* This is a critical section because it depends on the global	     */

       /* variable _ft_end.						     */

       /*--------------------------------------------------------------------*/

       _lock();

       for(j=0; j < _ft_end; j++)

	   if(_BUFFMODE(&_ftable[j]) == _IOLBF)

	       _doflush(&_ftable[j]);

       _unlock();

   }



   /*------------------------------------------------------------------------*/

   /* Read in the next characters from the file.                             */

   /*------------------------------------------------------------------------*/

   errchk = read(_fp->fd, (char *)_fp->buf, buffer_size);



   /*------------------------------------------------------------------------*/

   /* Adjust the buffer pointers.                                            */

   /*------------------------------------------------------------------------*/

   _fp->buff_stop = _fp->buf + errchk;

   _fp->pos = _fp->buf;



   /*------------------------------------------------------------------------*/

   /* Set any error flags if necessary.                                      */

   /*------------------------------------------------------------------------*/

   switch(errchk)

   {

      case -1 : _SET(_fp, _STATERR);

                break;

 

      case 0  : _SET(_fp, _STATEOF);

                break;

   }



   return;

 

}

 

_io_perm.c/     1148595152  0     0     0       5956      `
/*****************************************************************************/

/*  _IO_PERM.C v3.3.2                                                        */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    _RD_OK   -  Check to make sure that the stream is readable             */

/*    _WRT_OK  -  Check to make sure that the stream is writeable            */

/*****************************************************************************/

#include <stdio.h>



extern int _rd_ok(FILE *_fp);

extern int _wrt_ok(FILE *_fp);





/*****************************************************************************/

/* _RD_OK   -  Check to make sure that the stream is readable.               */

/*                                                                           */

/*    This function checks to make sure that the stream _FP has been opened  */

/*    for reading, and allocates a buffer for the stream if one hasn't been  */

/*    already.  The function returns a 1 if it is alright to write to this   */

/*    stream, otherwise it returns a 0.                                      */

/*                                                                           */

/*****************************************************************************/

int _rd_ok(FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   int   result   =  0;



   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if(_fp->fd == -1) return (0);



   /*------------------------------------------------------------------------*/

   /* If this stream is currently being written to, return a 0.              */

   /*------------------------------------------------------------------------*/

   if(_STCHK(_fp, _MODEW)) return (0);

 

   /*------------------------------------------------------------------------*/

   /* If this stream was opened in update mode, and is able to either read   */

   /* or write currently, put it in read mode.                               */

   /*------------------------------------------------------------------------*/

   if(!_STCHK(_fp, _MODER) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODER);

 

   /*------------------------------------------------------------------------*/

   /* Allocate a buffer for the stream if needed, and none exist.            */

   /*------------------------------------------------------------------------*/

   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))

      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);

 

   return (! result);

 

}





/*****************************************************************************/

/* _WRT_OK()   -  Check to make sure that a stream is writeable              */

/*                                                                           */

/*    This function takes the FILE pointer _FP, and makes sure that it is ok */

/*    to write to it.  It also allocates a buffer if one is needed.  The     */

/*    function returns a 1 if it is ok to write to this stream, otherwise it */

/*    returns a 0.                                                           */

/*                                                                           */

/*****************************************************************************/

int _wrt_ok(FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   int   result   = 0;

 

   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if(_fp->fd == -1) return (0);



   /*------------------------------------------------------------------------*/

   /* If this stream is currently being read return a 0.                     */

   /*------------------------------------------------------------------------*/

   if (_STCHK(_fp, _MODER)) return (0);

 

   /*------------------------------------------------------------------------*/

   /* If the stream is in append mode, move the file pointer to the end of   */

   /* the file.                                                              */

   /*------------------------------------------------------------------------*/

   if(_STCHK(_fp, _MODEA)) fseek(_fp, 0L, SEEK_END);

 

   /*------------------------------------------------------------------------*/

   /* If this stream was opened in update mode, and is able to either read   */

   /* or write currently, put it in write mode.                              */

   /*------------------------------------------------------------------------*/

   if(!_STCHK(_fp, _MODEW) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODEW);

 

   /*------------------------------------------------------------------------*/

   /* Allocate a buffer for the stream if needed, and none exist.            */

   /*------------------------------------------------------------------------*/

   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))

      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);

 

   return (! result);

}



_isfuncdcl.h/   1148595152  0     0     0       402       `
#include <linkage.h>

_IDECL int isalnum(int _c);

_IDECL int isalpha(int _c);

_IDECL int iscntrl(int _c);

_IDECL int isdigit(int _c);

_IDECL int isgraph(int _c);

_IDECL int islower(int _c);

_IDECL int isprint(int _c);

_IDECL int ispunct(int _c);

_IDECL int isspace(int _c);

_IDECL int isupper(int _c);

_IDECL int isxdigit(int _c);

_IDECL int isascii(int _c);

_IDECL int toascii(int _c);



_isfuncdef.h/   1148595152  0     0     0       806       `
static __inline int isalnum(int c)  { return(_isalnum(c)); }

static __inline int isalpha(int c)  { return(_isalpha(c)); }

static __inline int isascii(int c)  { return(_isascii(c)); }

static __inline int iscntrl(int c)  { return(_iscntrl(c)); }

static __inline int isdigit(int c)  { return(_isdigit(c)); }

static __inline int isgraph(int c)  { return(_isgraph(c)); }

static __inline int islower(int c)  { return(_islower(c)); }

static __inline int isprint(int c)  { return(_isprint(c)); }

static __inline int ispunct(int c)  { return(_ispunct(c)); }

static __inline int isspace(int c)  { return(_isspace(c)); }

static __inline int isupper(int c)  { return(_isupper(c)); }

static __inline int isxdigit(int c) { return(_isxdigit(c));}

static __inline int toascii(int c)  { return(_toascii(c)); }

_lock.c/        1148595152  0     0     0       639       `
/****************************************************************************/

/*  _lock v3.3.2                                                            */

/*  Copyright (c) 2000-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <_lock.h>



_CODE_ACCESS void _nop()

{

  /* Do nothing. */

}



_DATA_ACCESS void (*  _lock)() = _nop;

_DATA_ACCESS void (*_unlock)() = _nop;



_CODE_ACCESS void _register_lock(void (*lock)())

{

    _lock = lock;

}



_CODE_ACCESS void _register_unlock(void (*unlock)())

{

    _unlock = unlock;

}


_lock.h/        1148595152  0     0     0       756       `
/*****************************************************************************/

/*  _lock.h v3.3.2                                                           */

/*  Copyright (c) 2000-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



#ifndef __LOCK_H

#define __LOCK_H



#include <linkage.h>



#ifdef __cplusplus

extern "C" namespace std {

#endif



_CODE_ACCESS void _nop();



extern _DATA_ACCESS void (  *_lock)();

extern _DATA_ACCESS void (*_unlock)();



_CODE_ACCESS void _register_lock  (void (  *lock)());

_CODE_ACCESS void _register_unlock(void (*unlock)());



#ifdef __cplusplus

} /* extern "C" namespace std */

#endif



#endif /* __LOCK_H */

_printfi.c/     1148595152  0     0     0       56485     `
/*****************************************************************************/

/*  _PRINTFI.C v3.3.2                                                        */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/*    This file contains the main routines that all six variations of the    */

/*    printf function use.  The main function in the file is _printfi,       */

/*    and the other functions here are called by it.                         */

/*                                                                           */

/* FUNCTIONS:                                                                */

/*    _printfi       -  Perform the main printf routine                      */

/*    _pproc_fflags  -  Process the format flags for a conversion            */

/*    _pproc_fwp     -  Convert field width and precision into numbers       */

/*    _pproc_str     -  Process the string (%s) conversion                   */

/*    _setfield      -  Performs conversions when the '%' is encountered     */

/*    _pproc_fge     -  Process the conversion for f, g, G, e, and E         */

/*    _pconv_f       -  Perform the %f conversion                            */

/*    _pconv_e       -  Perform the %e conversion                            */

/*    _pconv_g       -  Perform the %g conversion                            */

/*    _fcpy          -  Copy the fraction part of a float to a string        */

/*    _ecpy          -  Copy the "E+xx" part of a float to a string          */

/*    _mcpy          -  Copy the whole number part of a float to a string    */

/*    _pproc_diouxp  -  Process the conversion for d, i, o, u, x, and p      */

/*    _getarg_diouxp -  Get the argument for d, i, o, u, x, or p conversion  */

/*    _ltostr        -  Convert an integer to a string of up to base 16      */

/*    _div           -  Divide two integers                                  */

/*                                                                           */

/* Note:  If NOFLOAT is defined at compile time, this file will be compiled  */

/*        without floating point support.                                    */

/*****************************************************************************/

#include <stdio.h>

#include <format.h>

#include <stdarg.h>

#include <stdlib.h>

#include <stdint.h>

#include <string.h>

#include <limits.h>

#include <math.h>



#define SIGNED_CONV (pfield->conv != 'u' && pfield->conv != 'o' && \

                     pfield->conv != 'x' && pfield->conv != 'X')



extern _CODE_ACCESS char *memccpy(char *dest, const char *src, int ch,

				  int count);



extern int _printfi(char **_format, va_list _ap, void *_op,

                    int (*_outc)(char, void *), int (*_outs)(char *, void *));





static void _pproc_fflags(_PFIELD *pfield, char **it);

static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap);

static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,

                       int (*_outc)(char, void *));

static char *_setfield(char *fld, _PFIELD *pfield, va_list *_ap);



#ifndef NOFLOAT

static char *fcvt(char *buf, long double value,int ndigit,int *decpt,int *sign);

static char *ecvt(char *buf, long double value,int ndigit,int *decpt,int *sign);

static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it,

                       va_list *_ap);

static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it);

static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it);

static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it);



static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision,

                   char **a_it);

static char *_ecpy(int exp, char letter, char **a_it);

static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it);

#endif



static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it,

                         va_list *_ap);

static uintmax_t _getarg_diouxp(_PFIELD *pfield, va_list *_ap);

static int _ltostr(uintmax_t cvt, int base, char conv, char **a_it);

static uintmax_t _div(uintmax_t cvt, int base);



/*****************************************************************************/

/* _PRINTFI -  Perform the main printf routine                               */

/*                                                                           */

/*    This function processes the format string.  It copies the format       */

/*    string into the result string until a '%' is encountered, where any    */

/*    flags, the field width, the precision, and the type of conversion are  */

/*    read in, stored in a structure called PFIELD, and passed to _SETFIELD, */

/*    where the actual conversion is processed.  This function returns       */

/*    the number of characters output.                                       */

/*                                                                           */

/*****************************************************************************/

int _printfi(char **_format, va_list _ap, void *_op, 

             int (*_outc)(char, void *), int (*_outs)(char *, void *))

{

   /*------------------------------------------------------------------------*/

   /* Local Variables                                                        */

   /*                                                                        */

   /*    *end     -  A pointer to the end of the format string               */

   /*    *pfield  -  A pointer to a structure _PFIELD, which stores all of   */

   /*                flags and parameters needed to perform a conversion.    */

   /*------------------------------------------------------------------------*/

   char     *end           =  *_format + strlen(*_format);

   int      count          =  0;

   _PFIELD  pfield;



   /*------------------------------------------------------------------------*/

   /* Iterate through the format string until the end of it is reached.      */

   /*------------------------------------------------------------------------*/

   while(*_format < end)

   {

      /*---------------------------------------------------------------------*/

      /* Initialize PFIELD.                                                  */

      /*---------------------------------------------------------------------*/

      pfield.flags     = 0;

      pfield.fwidth    = 0;

      pfield.precision = -1;

      pfield.conv      = 0;



      /*---------------------------------------------------------------------*/

      /* Copy the format string directly to the target string until a '%'    */

      /* is encountered.                                                     */

      /*---------------------------------------------------------------------*/

      for(; **_format != '%' && **_format != '\0'; 

          _outc(*((*_format)++), _op), count++);



      /*---------------------------------------------------------------------*/

      /* If the end of the format string has been reached, break out of the  */

      /* while loop.                                                         */

      /*---------------------------------------------------------------------*/

      if(! (**_format)) break;



      (*_format)++;                   /* Skip to the character after the '%' */



      /*---------------------------------------------------------------------*/

      /* Process the flags immediately after the '%'.                        */

      /*---------------------------------------------------------------------*/

      _pproc_fflags(&pfield, _format);



      /*---------------------------------------------------------------------*/

      /* Convert the field width and precision into numbers.                 */

      /*---------------------------------------------------------------------*/

      _pproc_fwp(&pfield, _format, &_ap);

 

      /*---------------------------------------------------------------------*/

      /* If the h, l, or L flag was specified, set the corresponding flag    */

      /* in pfield.                                                          */

      /*---------------------------------------------------------------------*/

      switch (**_format)

      {

	  case 'L': _SET(&pfield, _MFLD); (*_format)++; break;

	  case 'h': _SET(&pfield, _MFH);  (*_format)++; break;

	  case 'l':

	  {

	      (*_format)++; 

	      if (**_format == 'l') { _SET(&pfield, _MFLL); (*_format)++; }

	      else _SET(&pfield, _MFL);

	  }

      }



      /*---------------------------------------------------------------------*/

      /* Set the conversion character in pfield.                             */

      /*---------------------------------------------------------------------*/

      pfield.conv = *((*_format)++);



      /*---------------------------------------------------------------------*/

      /* If 'n' is the conversion specifier, process it in this function,    */

      /* since it is the only one that makes no conversions.  It just stores */

      /* the number of characters printed so far into the next argument.     */

      /* Otherwise, call _SETFIELD which performs the conversion.            */

      /*---------------------------------------------------------------------*/

      if(pfield.conv == 'n')

         switch (pfield.flags & (_MFLL | _MFL | _MFH))

         {

#ifdef LLONG_MAX

                           /* The 'll' flag was specified */

            case _MFLL  :  *(va_arg(_ap, long long*)) = (long long)count;

                           break;

#endif

                           /* The 'l' flag was specified */

            case _MFL   :  *(va_arg(_ap, long*)) = (long)count;

                           break;



                           /* The 'h' flag was specified */

            case _MFH   :  *(va_arg(_ap, short*)) = (short)count;

                           break;



            default     :  *(va_arg(_ap, int*)) = (int)count;

                           break;



         }

      else if(pfield.conv == 's') 

         _pproc_str(&pfield, _op, &_ap, &count, _outc);   

      else

      {

         /*------------------------------------------------------------------*/

         /* Append the converted string to the result string, and reposition */

         /* its iterator, it2.                                               */

         /*------------------------------------------------------------------*/

         char fld[FORMAT_CONVERSION_BUFSIZE];

         _setfield(fld, &pfield, &_ap);

         count += _outs(fld, _op);

      }

   }



   return (count);

}





/*****************************************************************************/

/* _PPROC_FFLAGS   -  Process the format flags for a conversion              */

/*                                                                           */

/*    This function takes the flags directly after the '%' and stores them   */

/*    in the _PFIELD structure PFIELD for later reference.                   */

/*                                                                           */

/*****************************************************************************/

static void _pproc_fflags(_PFIELD *pfield, char **it)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   int flags_done = 0;



   /*---------------------------------------------------------------------*/

   /* Read in all of the flags associated with this conversion, and set   */

   /* the corresponding flags in the PFIELD structure.                    */

   /*---------------------------------------------------------------------*/

   while(! flags_done)

      switch (**it)

      {

         case '-' :  _SET(pfield, _PFMINUS);

                     (*it)++;

                     break;   



         case '+' :  _SET(pfield, _PFPLUS);

                     (*it)++;

                     break;



         case ' ' :  _SET(pfield, _PFSPACE);

                     (*it)++;

                     break;



         case '#' :  _SET(pfield, _PFPOUND);

                     (*it)++;

                     break;



         case '0' :  _SET(pfield, _PFZERO);

                     (*it)++;

                     break;



         default  :  flags_done = 1;

      }



   return;

}





/*****************************************************************************/

/* _PPROC_FWP   -  Convert the field width and precision from the format     */

/*                 string into numbers.                                      */

/*                                                                           */

/*    This function reads the field and precision out of the format string   */

/*    and converts them into numbers that will be stored in the _PFIELD      */

/*    structure pointed to by PFIELD.  They will be needed for future        */

/*    reference.                                                             */

/*                                                                           */

/*****************************************************************************/

static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap)

{

   char tmpstr[10];

   char *tmpptr;



   /*------------------------------------------------------------------------*/

   /* If a '*' was given for the field width, use the next argument as       */

   /* the field width for the conversion.  Otherwise, copy the following     */

   /* numerical characters into a temporary string, and convert that         */

   /* string into an integer, which will be used for the field width.        */

   /*------------------------------------------------------------------------*/

   if(**it == '*')

   {

      pfield->fwidth = va_arg(*_ap, int);



      /*---------------------------------------------------------------------*/

      /* If the argument given for the field width is negative, treat it as  */

      /* if the '-' flag was used, and the field width was positive.         */

      /*---------------------------------------------------------------------*/

      if(pfield->fwidth < 0) 

      {

         pfield->fwidth = -(pfield->fwidth);

         _SET(pfield, _PFMINUS);

      }



      (*it)++;

   }

   else

   {

      /*---------------------------------------------------------------------*/

      /* Initialize the temporary string and iterator that will hold the     */

      /* field width temporarily.                                            */

      /*---------------------------------------------------------------------*/

      tmpptr = tmpstr;

      memset(tmpptr, '\0', 10);



      while((**it >= '0') && (**it <= '9')) *(tmpptr++) = *((*it)++);



      if(*tmpstr != '\0') pfield->fwidth = atoi(tmpstr);

   }



   /*------------------------------------------------------------------------*/

   /* If a '.' appears as the next character, process the following          */

   /* characters as a precision.                                             */

   /*------------------------------------------------------------------------*/

   if(**it == '.')

   {

      (*it)++;



      /*---------------------------------------------------------------------*/

      /* If a '*' was given for the precision, use the next argument as      */

      /* the precision for the conversion.  Otherwise, copy the following    */

      /* numerical characters into a temporary string, and convert that      */

      /* string into an integer, which will be used for the precision.       */

      /*---------------------------------------------------------------------*/

      if(**it == '*')

      {

         pfield->precision = va_arg(*_ap, int);

         (*it)++;

      }

      else

      {

         /*------------------------------------------------------------------*/

         /* Initialize the temporary string and iterator that will hold      */

         /* the field width temporarily.                                     */

         /*------------------------------------------------------------------*/

         tmpptr = tmpstr;

         memset(tmpptr, '\0', 10);



         while((**it >= '0') && (**it <= '9'))  *(tmpptr++) = *((*it)++);



         if(*tmpstr != '\0') pfield->precision = atoi(tmpstr);

         else                pfield->precision = 0;

      }

   }

   return;

}





/*****************************************************************************/

/* _PPROC_STR  -  Processes the string conversion (%s)                       */

/*                                                                           */

/*    This function places all or a portion of the input string into the     */

/*    the temporary string.  It returns a zero, unless the input string had  */

/*    a length of zero.  In this case, a one is returned.                    */

/*                                                                           */

/*****************************************************************************/

static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,

                       int (*_outc)(char, void *))

{

    /*------------------------------------------------------------------------*/

    /* Local variables                                                        */

    /*------------------------------------------------------------------------*/

    char *strbuf;

    int   len, buflen;

    int   i;



    /*------------------------------------------------------------------------*/

    /* Get the next argument.                                                 */

    /*------------------------------------------------------------------------*/

    strbuf = va_arg(*_ap, char*);



    /*------------------------------------------------------------------------*/

    /* Handle NULL strings.                                                   */

    /*------------------------------------------------------------------------*/

    if (strbuf == NULL)

    {

       _outc('\0', _op);

       return;

    }



    buflen = (pfield->precision >= 0 && pfield->precision < strlen(strbuf)) ?

    pfield->precision : strlen(strbuf);

    len = (pfield->fwidth > buflen) ? pfield->fwidth : buflen;

    *count += len;



    if (buflen < len && !_STCHK(pfield, _PFMINUS))

        for (i = 0; i < len - buflen; i++)

            _outc(' ', _op);



    for (i = 0; i < buflen; i++)

        _outc(*strbuf++, _op);   



    if (buflen < len && _STCHK(pfield, _PFMINUS))

        for (i = 0; i < len - buflen; i++)

            _outc(' ', _op);

}





/*****************************************************************************/

/* _SETFIELD   -  Performs conversions when the '%' is encountered           */

/*                                                                           */

/*    This function takes pfield, and calls the appropriate processing       */

/*    function for the conversion required in the _PFIELD structure.  It     */

/*    returns a pointer to the result string.                                */

/*                                                                           */

/*****************************************************************************/

static char *_setfield(char *fld, _PFIELD *pfield, va_list *_ap)

{

   /*------------------------------------------------------------------------*/

   /* Local variable declarations, and a description of their use            */

   /*                                                                        */

   /*    FLD is a temporary string that will hold the conversion.  F_START   */

   /*    will be a pointer to the beginning of the field, and if a           */

   /*    field width was specified, F_END will be a pointer to the end of    */

   /*    the field.  This designated field is located at the beginning of    */

   /*    the string FLD.   A_END is a pointer to the end of the string FLD,  */

   /*    and this is where the primary conversion will take place.  Using    */

   /*    A_IT, an iterator beginning at the end of FLD, the number will be   */

   /*    written one digit at a time starting with the rightmost digit.      */

   /*    Using the pointer WHERE, the number in string form will be moved    */

   /*    to its appropriate place within the field after making adjustments  */

   /*    called for by various flags in the format specification (a minus    */

   /*    sign, leading zeros, etc.).  The string FLD will then be returned.  */

   /*                                                                        */

   /*    MINUS_FLAG is exactly what it says ( = 1 if number is negative).    */

   /*                                                                        */

   /*------------------------------------------------------------------------*/

   char *f_start   =  (char *)fld;

   char *f_end     =  f_start + pfield->fwidth;

   char *a_end     =  f_start + FORMAT_CONVERSION_BUFSIZE -1; 

   char *a_it      =  a_end;

   char *where;

   int  minus_flag = 0;

   int  plus_flag  = 0;



   /*------------------------------------------------------------------------*/

   /* Initialize the temporary string.  Then, since we are working from      */

   /* right to left, begin with the NULL character.                          */

   /*------------------------------------------------------------------------*/

   memset(fld, ' ', FORMAT_CONVERSION_BUFSIZE);

   *(a_it--) = '\0'; 



   /*------------------------------------------------------------------------*/

   /* Call the appropriate processing function.                              */

   /*------------------------------------------------------------------------*/

   switch(pfield->conv)

   {

      case 'd' :

      case 'i' :

      case 'o' :

      case 'u' :

      case 'x' :

      case 'X' :  

      case 'p' :  _pproc_diouxp(pfield, &minus_flag, &a_it, _ap);

                  break;  



#ifndef NOFLOAT

      case 'g' :  

      case 'G' : 

      case 'e' :

      case 'E' :

      case 'f' :  _pproc_fge(pfield, &minus_flag, &a_it, _ap);

                  break;

#endif

  

      case 'c' :  *(a_it--) = va_arg(*_ap, int);

                  _UNSET(pfield, _PFPLUS);

                  break;



      case '%' :  strcpy(f_start, "%"); return((char *)fld);





   }



   plus_flag = (_STCHK(pfield, _PFPLUS) && SIGNED_CONV);



   /*------------------------------------------------------------------------*/

   /* If the number was negative, or the '+' flag was used, insert the sign. */

   /* Make sure unsigned conversions don't get a '+' sign.                   */

   /*------------------------------------------------------------------------*/

   if (minus_flag) *(a_it--) = '-';

   else if (plus_flag) *(a_it--) = '+';



   /*------------------------------------------------------------------------*/

   /* If the number was positive, the '+' flag was not used, and the ' '     */

   /* flag was used, insert a space.                                         */

   /*------------------------------------------------------------------------*/

   if(! minus_flag && ! plus_flag && _STCHK(pfield, _PFSPACE)) *(a_it--) = ' ';



   /*------------------------------------------------------------------------*/

   /* If the '-' flag was used or the resulting string is larger than the    */

   /* field, left justify the result in the array.  Otherwise right-justify  */

   /* it.                                                                    */

   /*------------------------------------------------------------------------*/

   where = (_STCHK(pfield, _PFMINUS) ||

           ((a_end - a_it) > pfield->fwidth)) ? f_start :

           (f_end - (a_end - a_it)+1);



   a_it = (char *)memccpy(where, a_it+1, '\0', FORMAT_CONVERSION_BUFSIZE);



   /*------------------------------------------------------------------------*/

   /* If a resulting left-justified string is smaller than the field width,  */

   /* move the terminating NULL character to the end of the field.           */

   /*------------------------------------------------------------------------*/

   if(a_it <= f_end)

   {

      memset(a_it - 1, ' ', f_end - a_it + 1);

      *f_end = '\0';

   }



   /*------------------------------------------------------------------------*/

   /* If the '0' flag was used, and the resulting string is right-justified, */

   /* fill in the leading zeros.                                             */

   /*------------------------------------------------------------------------*/

   if(_STCHK(pfield, _PFZERO))

   {

      memset(f_start, '0', (where - f_start));



      /*---------------------------------------------------------------------*/

      /* Make sure any sign or leading space is moved to the left side of    */

      /* any leading zeros.                                                  */

      /*---------------------------------------------------------------------*/

      if((minus_flag || plus_flag || _STCHK(pfield, _PFSPACE)) &&

          where != f_start)

      {

         *f_start = *where;

         *where = '0';

      }

   }

   else

      memset(f_start, ' ', (where - f_start));



   /*------------------------------------------------------------------------*/

   /* Return the result string.                                              */

   /*------------------------------------------------------------------------*/

   return ((char *)fld);                     

}





#ifndef NOFLOAT

/****************************************************************************/

/* THIS FUNCTION IS NON-STANDARD AND IS PROVIDED ONLY AS A BUILDING BLOCK   */

/* FOR PRINTF.                                                              */

/****************************************************************************/

static char *fcvt(char *out, long double value,int ndigit, int *decpt,int *sign)

{

    int   digits = 0;                  /* NUMBER OF DIGITS BEFORE .       */

    char *pos    = out + 1;     

    int   temp;



    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */

    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */



    /*--------------------------------------------------------------------*/

    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */

    /*--------------------------------------------------------------------*/

    if (*sign = (value < 0)) value = -value;

    while (value > 0x7FFFFFFF) { value /= 10; digits++; }

    while (value && value < 1) { value *= 10; digits--; }



    /*--------------------------------------------------------------------*/

    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */

    /*--------------------------------------------------------------------*/

    pos   += temp    = ltoa((long)value, pos);

    *decpt = digits + temp; 



    ndigit += digits;



    /*--------------------------------------------------------------------*/

    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */

    /*--------------------------------------------------------------------*/

    if (ndigit > 0) do

    {

         value -= (long)value;

         *pos++ = (int)(value *= 10.0) + '0';

    }

    while (--ndigit);



    /*--------------------------------------------------------------------*/

    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */

    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */

    /*--------------------------------------------------------------------*/

    if (*--pos >= '5')

    {

	char *ptr = pos;

	while ((*--ptr += 1) > '9') *ptr = '0';

	if (ptr == out) 

        {

	   if (pos > out) *pos   = 0;

	   else           out[1] = 0;



           *decpt += 1;

           return out;

        }

    }

	

    *pos = 0;

    return out + 1;

}





/****************************************************************************/

/* THIS FUNCTION IS NON-STANDARD AND IS PROVIDED ONLY AS A BUILDING BLOCK   */

/* FOR PRINTF.                                                              */

/****************************************************************************/

static char *ecvt(char *out, long double value, int ndigit,int *decpt,int *sign)

{

    int   digits = 0;                  /* NUMBER OF DIGITS BEFORE .       */

    char *pos    = out + 1;     

    int   temp;



    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */

    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */



    /*--------------------------------------------------------------------*/

    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */

    /*--------------------------------------------------------------------*/

    if (*sign = (value < 0)) value = -value;

    while (value > 0x7FFFFFFF) { value /= 10; digits++; }

    while (value && value < 1) { value *= 10; digits--; }



    /*--------------------------------------------------------------------*/

    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */

    /*--------------------------------------------------------------------*/

    pos    += temp = ltoa((long)value, pos);

    *decpt  = digits + temp;



    /*--------------------------------------------------------------------*/

    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */

    /*--------------------------------------------------------------------*/

    if (temp >= ndigit) 

	pos = out + ndigit + 1;

    else if ((ndigit -= temp) > 0) do

    {

        value -= (long)value;

        *pos++ = (int)(value *= 10.0) + '0';

    } 

    while (--ndigit);



    /*--------------------------------------------------------------------*/

    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */

    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */

    /*--------------------------------------------------------------------*/

    if (*--pos >= '5')

    {

	char *ptr = pos;

	while ((*--ptr += 1) > '9') *ptr = '0';

	if (ptr == out) { *--pos = 0; *decpt += 1; return out; }

    }

	

    *pos = 0;

    return out + 1;

}





/*****************************************************************************/

/* _PPPROC_FGE   -  Process the conversion for f, g, G, e, and E             */

/*                                                                           */

/*    This function takes the structure PFIELD, which contains all of the    */

/*    flags and parameters to process the conversion, and it does this       */

/*    conversion, and stores the result in the string pointed to by          */

/*    *A_IT.                                                                 */

/*****************************************************************************/

static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it, 

                       va_list *_ap)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   long double cvt =  0;



   /*------------------------------------------------------------------------*/

   /* Determine what kind of argument is coming next, and read it into CVT.  */

   /*------------------------------------------------------------------------*/

   switch(_STCHK(pfield, _MFLD))

   {

      case  0  :  cvt = (double)va_arg((*_ap), double);

                  break;



      default  :  cvt = va_arg((*_ap), long double);



   }



   /*------------------------------------------------------------------------*/

   /* If CVT is negative, set the MINUS_FLAG and reverse the sign of CVT.    */

   /*------------------------------------------------------------------------*/

   if((*minus_flag = (cvt < 0)) != 0) cvt = -cvt;



   /*------------------------------------------------------------------------*/

   /* Call the proper conversion function                                    */

   /*------------------------------------------------------------------------*/

   switch(pfield->conv)

   {

      case 'f' :  _pconv_f(cvt, pfield, a_it);

                  break;

      case 'e' :

      case 'E' :  _pconv_e(cvt, pfield, a_it);

                  break;

      case 'g' :

      case 'G' :  _pconv_g(cvt, pfield, a_it);

   }

}





/*****************************************************************************/

/* _PCONV_F -  Perform the %f conversion                                     */

/*****************************************************************************/

static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   char  tmpbuf[F_CONVERSION_BUFSIZE];

   char *result;

   char *frac_ptr;

   int   dpt, 

         sign, 

         putdec;



   /*------------------------------------------------------------------------*/

   /* If no precision was specified, set it to 6.                            */

   /*------------------------------------------------------------------------*/

   if(pfield->precision < 0) pfield->precision = 6;



   /*------------------------------------------------------------------------*/

   /* Call the FCVT float to string function, then copy the fractional part, */

   /* determine whether or not a decimal point should be placed, and copy    */

   /* whole number part.                                                     */

   /*------------------------------------------------------------------------*/

   frac_ptr = *a_it;

   result = fcvt(tmpbuf, cvt, pfield->precision, &dpt, &sign);

   _fcpy(result, dpt, 1, pfield->precision, a_it);



   /*------------------------------------------------------------------------*/

   /* If the output has no fractional part, don't write the decimal point.   */

   /* If # flag was specified, then we write the decimal point always.       */

   /*------------------------------------------------------------------------*/

   putdec = (frac_ptr != *a_it || _STCHK(pfield, _PFPOUND));

   _mcpy(result, dpt, putdec, a_it);

}





/*****************************************************************************/

/* _PCONV_E -  Perform the %e conversion                                     */

/*****************************************************************************/

static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   char  tmpbuf[FLOAT_VALUE_BUFSIZE];

   char *result;

   int   dpt, 

         sign, 

         putdec, 

         exp      = 0;



   /*------------------------------------------------------------------------*/

   /* If no precision was specified, set it to 6.                            */

   /*------------------------------------------------------------------------*/

   if(pfield->precision < 0) pfield->precision = 6;



   /*------------------------------------------------------------------------*/

   /* Check if CVT is within legal range -HUGE_VALL <= CVT <= HUGE_VALL      */

   /*------------------------------------------------------------------------*/

   if (cvt >= HUGE_VALL) cvt = HUGE_VALL;

   else if (cvt <= -HUGE_VALL) cvt = -HUGE_VALL;



   /*------------------------------------------------------------------------*/

   /* Convert CVT to x.xxxe+xx form, keeping the exponent in EXP.            */

   /*------------------------------------------------------------------------*/

   if(cvt)

   {

      for(;cvt < 1; cvt *= 10, exp--);

      for(;cvt >= 10; cvt /= 10, exp++);

   }



   /*------------------------------------------------------------------------*/

   /* Call the FCVT float to string function, copy the exponent part, the    */

   /* fractional part, then determine whether or not a decimal point should  */

   /* be placed, and copy the whole number part.                             */

   /*------------------------------------------------------------------------*/

   result = fcvt(tmpbuf, cvt, pfield->precision, &dpt, &sign);

   if(dpt==2) /* fcvt() might have rounded the number */

   {

       dpt--; exp++; result[strlen(result)-1] = 0;

   }

   _ecpy(exp, pfield->conv, a_it);

   _fcpy(result, dpt, 1, pfield->precision, a_it);

   putdec = (dpt != (int)strlen(result) || _STCHK(pfield, _PFPOUND)) ? 1 : 0;

   _mcpy(result, dpt, putdec, a_it);

}





/*****************************************************************************/

/* _PCONV_G -  Perform the %g conversion                                     */

/*****************************************************************************/

static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   char  tmpbuf[FLOAT_VALUE_BUFSIZE];

   char  *result;

   char  *check;

   int   dpt, 

         sign, 

         putdec, 

         exp         = 0, 

         change_test = 0;



   /*------------------------------------------------------------------------*/

   /* If the precision was given as 0, set it to one.                        */

   /*------------------------------------------------------------------------*/

   if(pfield->precision == 0) pfield->precision = 1;



   /*------------------------------------------------------------------------*/

   /* If no precision was specified, set it to 6.                            */

   /*------------------------------------------------------------------------*/

   if(pfield->precision < 0) pfield->precision = 6;



   result = ecvt(tmpbuf, cvt, pfield->precision, &dpt, &sign);



   /*------------------------------------------------------------------------*/

   /* If the exponent is less than -4, or greater than or equal to the       */

   /* precision, convert the number as a %e conversion.  Otherwise convert   */

   /* it as a %f conversion.                                                 */

   /*------------------------------------------------------------------------*/

   if(dpt < -3 || dpt > pfield->precision)

   {

      for(;dpt > 1; dpt--, exp++);

      for(;dpt < 1; dpt++, exp--);



      _ecpy(exp, pfield->conv-2, a_it);

   }



   /*------------------------------------------------------------------------*/

   /* Copy the fractional part of the number.  CHANGE_TEST will be set if    */

   /* there was a fractional part, otherwise it will remain a zero.          */

   /*------------------------------------------------------------------------*/

   check = *a_it;

   _fcpy(result, dpt, (_STCHK(pfield, _PFPOUND)) ? 1 : 0, pfield->precision,

         a_it);

   change_test = (check != *a_it);



   /*------------------------------------------------------------------------*/

   /* If the '#' flag was used, or there was a fractional part to the number */

   /* a decimal point will be placed.                                        */

   /*------------------------------------------------------------------------*/

   putdec = (_STCHK(pfield, _PFPOUND) || change_test) ? 1 : 0;



   _mcpy(result, dpt, putdec, a_it);

}





/*****************************************************************************/

/* _FCPY -  Copy the fraction part of a float to a string                    */

/*****************************************************************************/

static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision, 

                   char **a_it)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   int   i;

   char  *tmpptr = (char *)tmpbuf + strlen(tmpbuf) -1;



   /*------------------------------------------------------------------------*/

   /* Fill all unused precision spaces with zeros.                           */

   /*------------------------------------------------------------------------*/

   for(i = 0; i < precision && dpt > (int)strlen(tmpbuf) && trail; i++)

      *((*a_it)--) = '0';

 

   /*------------------------------------------------------------------------*/

   /* Copy the fractional part of the float into the string.                 */

   /*------------------------------------------------------------------------*/

   if(dpt < (int)strlen(tmpbuf) && dpt >= 0)

   {

      i = (int)strlen(tmpbuf) - dpt;



      /*---------------------------------------------------------------------*/

      /* Skip trailing zeros if TRAIL is not set.                            */

      /*---------------------------------------------------------------------*/

      if(! trail) for(; i > 0 && *tmpptr == '0'; tmpptr--, i--);



      for(; i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;



   }



 

   /*------------------------------------------------------------------------*/

   /* Place any leading fractional zeros if necessary.                       */

   /*------------------------------------------------------------------------*/

   if(dpt < 0)

   {

      if (-dpt < precision)

          for(i = strlen(tmpbuf); i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;

      if (-dpt > precision) dpt = -precision;

      for(i = -dpt; i > 0; i--) *((*a_it)--) = '0';

   }



   return (*a_it);

}





/*****************************************************************************/

/* _ECPY -  Copy the "e+xx" part of a float to a string                      */

/*****************************************************************************/

static char *_ecpy(int exp, char letter, char **a_it)

{

   _ltostr((exp > 0) ? exp : -exp, 10, 'd', a_it);

   if(exp < 10 && exp > -10) *((*a_it)--) = '0';

   *((*a_it)--) = (exp < 0) ? '-' : '+';

   *((*a_it)--) = letter;



   return (*a_it);

}





/*****************************************************************************/

/* _MCPY -  Copy the whole number part of a float to a string                */

/*****************************************************************************/

static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   int   i;

   char  *tmpptr = NULL;



   /*------------------------------------------------------------------------*/

   /* If the number has both a whole number part and a fractional part,      */

   /* position TMPPTR to the last character of the whole number.             */

   /*------------------------------------------------------------------------*/

   if(dpt > 0 && dpt <= (int)strlen(tmpbuf)) tmpptr = (char *)tmpbuf + dpt -1;



   /*------------------------------------------------------------------------*/

   /* Place a decimal point if PUTDEC is set.                                */

   /*------------------------------------------------------------------------*/

   if(putdec) *((*a_it)--) = '.';



   /*------------------------------------------------------------------------*/

   /* Place any whole number trailing zeros.                                 */

   /*------------------------------------------------------------------------*/

   for(i = dpt; i > (int)strlen(tmpbuf); i--) *((*a_it)--) = '0';



   /*------------------------------------------------------------------------*/

   /* Copy the rest of the whole number.                                     */

   /*------------------------------------------------------------------------*/

   if(i > 0) for(; tmpptr >= tmpbuf; tmpptr--) *((*a_it)--) = *tmpptr;

   else *((*a_it)--) = '0';



   return (*a_it);

}

#endif





/*****************************************************************************/

/* _PPROC_DIOUXP   -  Process the conversion for d, i, o, u, x, and p        */

/*                                                                           */

/*    This function takes the structure PFIELD, which contains all of the    */

/*    flags and parameters to process the conversion, and it does this       */

/*    conversion, and stores the result in the string pointed to by          */

/*    *A_IT.                                                                 */

/*                                                                           */

/*****************************************************************************/

static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it, 

                         va_list *_ap)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   int digits =  0;

   int base   = 10;

   uintmax_t cvt;



   /*------------------------------------------------------------------------*/

   /* If no precision was given, set it to 1.                                */

   /*------------------------------------------------------------------------*/

   if(pfield->precision < 0) pfield->precision = 1; 

   else                      _UNSET(pfield, _PFZERO);



   /*------------------------------------------------------------------------*/

   /* Set the base of the number by the type of conversion specified.        */

   /*------------------------------------------------------------------------*/

   switch(pfield->conv)

   {

      case 'p' :

      case 'x' :

      case 'X' :  base = 16;

                  break;



      case 'o' :  base = 8;

                  break;



      default  :

      case 'u' :

      case 'd' :

      case 'i' :  base = 10;

  	          break;

   }  



   /*------------------------------------------------------------------------*/

   /* Get the next argument.                                                 */

   /*------------------------------------------------------------------------*/

   cvt = _getarg_diouxp(pfield, _ap);



   /*------------------------------------------------------------------------*/

   /* If the precision is 0, and the number is 0, do nothing and return 1.   */

   /*------------------------------------------------------------------------*/

   if(pfield->precision == 0 && cvt == 0) return 1;



   /*------------------------------------------------------------------------*/

   /* If the number is signed and negative, set the minus sign flag, and     */

   /* negate the number.                                                     */

   /*------------------------------------------------------------------------*/

   if((pfield->conv == 'd' || pfield->conv == 'i')

      && ((intmax_t)cvt < 0))

   {

      *minus_flag = 1;

      cvt = -(intmax_t)cvt;

   }



   /*------------------------------------------------------------------------*/

   /* Call the function to convert the number to a string, and add the       */

   /* total number of digits assigned into DIGITS.                           */

   /*------------------------------------------------------------------------*/

   digits += _ltostr(cvt, base, pfield->conv, a_it);



   /*------------------------------------------------------------------------*/

   /* Fill in the remainder of the precision with zeros.                     */

   /*------------------------------------------------------------------------*/

   while(digits++ < pfield->precision) *((*a_it)--) = '0';





   /*------------------------------------------------------------------------*/

   /* If the "#" flag was used in the X or x conversion, prefix a "0x" or    */

   /* "0X" to the hexadecimal number.                                        */

   /*------------------------------------------------------------------------*/

   if((pfield->conv == 'x' || pfield->conv == 'X') && _STCHK(pfield, _PFPOUND))

   {

      *((*a_it)--) = pfield->conv;

      *((*a_it)--) = '0';

   }



   /*------------------------------------------------------------------------*/

   /* If the "#' flag was used in the o conversion, prefix a "0" to the      */

   /* octal number.                                                          */

   /*------------------------------------------------------------------------*/

   if(pfield->conv == 'o' && _STCHK(pfield, _PFPOUND)) *((*a_it)--) = '0';



   return (0);



}





/*****************************************************************************/

/* _GETARG_DIOUXP -  Get the argument for a d, i, o, u, x, or p conversion   */

/*                                                                           */

/*    This function takes the next argument off the argument list, after     */

/*    determining what kind of argument it is.  It decides this by checking  */

/*    to see if the 'h' or the 'l' flag was used.  It returns the next       */

/*    argument.                                                              */

/*****************************************************************************/

static uintmax_t _getarg_diouxp(_PFIELD *pfield, va_list *_ap)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   uintmax_t cvt = 0;



   if (pfield->conv == 'p') cvt = (uintmax_t)va_arg(*_ap, void *);

   else

   /*------------------------------------------------------------------------*/

   /* Get the number from the next argument.  Determine what kind of         */

   /* argument by checking for the h or l flag in the format specification.  */

   /*------------------------------------------------------------------------*/

   switch(_STCHK(pfield, (_MFH | _MFL | _MFLL)))

   {

      case _MFH   :  switch(pfield->conv)

                     {

                        case 'd' :

                        case 'i' : 

			    cvt = va_arg(*_ap, int);

			    break;

			    

                        case 'o' :

                        case 'u' :

                        case 'x' :

                        case 'X' : 

			    cvt = (unsigned short) va_arg(*_ap, unsigned int);

                     }

                     break;



      case _MFL   :  switch(pfield->conv)

                     {

                        case 'd' :

                        case 'i' : 

			    cvt = va_arg(*_ap, long int);

			    break;



                        case 'o' :

                        case 'u' :

                        case 'x' :

                        case 'X' : 

			    cvt = va_arg(*_ap, unsigned long int);

                     }

                     break;

#ifdef LLONG_MAX

      case _MFLL  :  switch(pfield->conv)

                     {

                        case 'd' :

                        case 'i' : 

			    cvt = va_arg(*_ap, long long int);

			    break;



                        case 'o' :

                        case 'u' :

                        case 'x' :

                        case 'X' : 

			    cvt = va_arg(*_ap, unsigned long long int);

                     }

                     break;

#endif   

      default     :  switch(pfield->conv)

                     {

                        case 'd' :

                        case 'i' : 

			    cvt = va_arg(*_ap, int);

			    break;

 

                        case 'o' :

                        case 'u' :

                        case 'x' :

                        case 'X' :

			    cvt = va_arg(*_ap, unsigned int);

                     }

   }



   return (cvt);

}





/*****************************************************************************/

/* _LTOSTR  -  Convert an integer to a string of up to base 16               */

/*                                                                           */

/*    This function takes an uintmax_t integer, converts it to a string      */

/*    which is pointed to by *A_IT.  The result will also be converted to    */

/*    a base corresponding to the variable base.                             */

/*                                                                           */

/*****************************************************************************/

static int _ltostr(uintmax_t cvt, int base, char conv, char **a_it)

{

   /*------------------------------------------------------------------------*/

   /* Local Variables                                                        */

   /*------------------------------------------------------------------------*/

   uintmax_t  quot,

              rem;

       char  *bnum = "0123456789abcdef0123456789ABCDEF";



   /*------------------------------------------------------------------------*/

   /* The number CVT will be converted to a string by taking the remainder   */

   /* of a division of it by its base, and converting it to a character.     */

   /* The number CVT is then set equal to itself divided by its base, and    */

   /* this continues until CVT is 0.                                         */

   /*------------------------------------------------------------------------*/



   if(! cvt) *((*a_it)--) = '0';



   while(cvt)

   {

      quot = _div(cvt, base);

      rem = cvt - (quot * base);



      if(conv == 'X') rem += 16;



      *((*a_it)--) = bnum[rem];

      cvt = quot;

   }



   return (strlen(*a_it) - 1);

}





/*****************************************************************************/

/* _DIV  -  Divide two integers                                              */

/*                                                                           */

/*    This function takes a uintmax_t, and divides it by an integer.         */

/*    Division must take place in unsigned arithmetic, because signed '/'    */

/*    can overflow.  This function is used by _LTOSTR when it is converting  */

/*    an unsigned int to a string.                                           */

/*                                                                           */

/*****************************************************************************/

static uintmax_t _div(uintmax_t cvt, int base)

{

    /*-----------------------------------------------------------------------*/

    /* Use shifts to optimize power-of-two bases                             */

    /*-----------------------------------------------------------------------*/

    switch(base)

    {

	case  8: return cvt >> 3;

	case 16: return cvt >> 4;

    }



    /*-----------------------------------------------------------------------*/

    /* Perform divide in narrowest arithmetic possible, for speed.	     */

    /*-----------------------------------------------------------------------*/

         if (cvt < UINT_MAX)  return (unsigned int)cvt / base;

    else if (cvt < ULONG_MAX) return (unsigned long)cvt / base;

    else return cvt / base;

}




_scanfi.c/      1148595152  0     0     0       35897     `
/*****************************************************************************/

/*  _SCANFI.C v3.3.2                                                         */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/*    This file contains the main routines that all three variations of the  */

/*    scanf function use.  The main function in the file is _scanfi, and     */

/*    the other functions here are called by it.                             */

/*                                                                           */

/* FUNCTIONS:                                                                */

/*    _scanfi        -  The main scanf handling routine                      */

/*    _sget_conv     -  Read the format flags into the _SFIELD pointer sfield*/

/*    _sget_scanset  -  Read in the scanset from the format statement        */

/*    _sproc_int     -  Read an integer string into a temporary string       */

/*    _sproc_float   -  Read a float string into a temporary string          */

/*    _sproc_str     -  Copy a string from the input source to a temporary   */

/*                      string                                               */

/*    _sproc_lb      -  Process the %[ conversion                            */

/*    _sset_arg      -  Assign the converted value to the next argument      */

/*****************************************************************************/

#include <stdio.h>

#include "format.h"

#include <stdarg.h>

#include <stdlib.h>

#include <ctype.h>

#include <string.h>

#include <limits.h>



#ifdef LLONG_MAX

_CODE_ACCESS long long strtoll(const char *_st, char **_endptr, int _base);

_CODE_ACCESS unsigned long long strtoull(const char *_st, char **_endptr,

					 int _base);

#endif



_CODE_ACCESS long double strtold(const char *st, char **endptr);



static int _sget_conv(char **_format, _SFIELD *sfield);

static int _sget_scanset(_SFIELD *sfield, char **_format);

static int _sproc_int(int w_counter, int (*_inpchar)(void **inp),

                       void (*_uninpchar)(void **inp, char outchar),

                       char *tmpptr, char conv, void **inp, int *num_read);

static int _sproc_float(int w_counter, int (*_inpchar)(void **inp),

                         void (*_uninpchar)(void **inp, char outchar),

                         char *tmpptr, char conv, void **inp, int *num_read);

static int _sproc_str(int w_counter, int (*_inpchar)(void **inp),

                       void (*_uninpchar)(void **inp, char outchar),

                       char *tmpptr, char conv, void **inp, int *num_read);

static int _sproc_lb(int (*_inpchar)(void **inp),

                      void (*_uninpchar)(void **inp, char outchar),

                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read);

static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf);



/*****************************************************************************/

/* _SCANFI  -  The main scanf handling routine                               */

/*                                                                           */

/*    This function parses all non-conversion characters in the format       */

/*    string, passes control to the appropriate function when a '%' is       */

/*    encountered, then calls _SSET_ARG, which assignes the result to the    */

/*    next argument.                                                         */

/*                                                                           */

/*****************************************************************************/

int _scanfi(void *inp, const char *_format, va_list _ap, 

            int (*_chkmbc)(void **inp, char **_format, int *num_read),

            int (*_inpchar)(void **inp), 

            void (*_uninpchar)(void **inp, char outchar))

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   _SFIELD  sfield;

   char     tmpbuf[256],

           *tmpptr,

           *f_ptr        = (char *)_format;

   int      num_assigned =  0,

            inchar,

            num_read     =  0,

            stat         =  0;



   /*------------------------------------------------------------------------*/

   /* If the first character in the format string is a white space character */

   /* parse the format string until a non-white space character is found.    */

   /* Do the same for the input, but put the first non-white space character */

   /* back onto the input stream when finished.                              */

   /*------------------------------------------------------------------------*/

   if (isspace(*f_ptr))

   {

      for(;isspace(*f_ptr);f_ptr++);



      inchar = _inpchar(&inp);

      if(inchar == EOF) return EOF;

      num_read++;



      for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);



      _uninpchar(&inp, inchar);

      num_read--;



      if(inchar == EOF) return EOF;

   }



   while(1)

   {

      /*---------------------------------------------------------------------*/

      /* Initialize sfield                                                   */

      /*---------------------------------------------------------------------*/

      memset(&sfield, 0, sizeof(_SFIELD));

      sfield.fwidth = -1;



      /*---------------------------------------------------------------------*/

      /* Call _chkmbc to compare the format string to the input.  If a       */

      /* mismatch occurs, return an EOF, if the end of the format string     */

      /* is reached, return the number of arguments assigned.  Otherwise     */

      /* a '%' has been encountered, so call _sget_conv to process it.       */

      /*---------------------------------------------------------------------*/

      switch(_chkmbc(&inp, &f_ptr, &num_read))

      {

         case  EOF   : return (EOF);

   

         case  0     : return (num_assigned);

   

         case  1     :  _sget_conv(&f_ptr, &sfield);

   

      }

   

      tmpptr = tmpbuf;



      /*---------------------------------------------------------------------*/

      /* Unless the conversion specifier is a [, c, or n, skip to the next   */

      /* non-white space character in the input.                             */

      /*---------------------------------------------------------------------*/

      if (sfield.conv != '[' && sfield.conv != 'c' && sfield.conv != 'n')

      {

         inchar = _inpchar(&inp);

         num_read++;

    

         for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);

    

         _uninpchar(&inp, inchar);

         num_read--;



         /*---------------------------------------------------------------*/

         /* If we've encountered the end of the stream AND we haven't     */

         /* matched anything yet, return EOF.                             */

         /*---------------------------------------------------------------*/

         if(inchar == EOF && num_read == 0) return EOF;

      }

      else

      {

         /*---------------------------------------------------------------*/

         /* If we've encountered the end of the stream AND we haven't     */

         /* matched anything yet, return EOF.                             */

         /*---------------------------------------------------------------*/

         inchar = _inpchar(&inp);

         _uninpchar(&inp, inchar);

         if(inchar == EOF && num_read == 0) return EOF;

      }



      /*---------------------------------------------------------------------*/

      /* The flags have been set in sfield, so process the conversion by     */

      /* calling the appropriate function.                                   */

      /*---------------------------------------------------------------------*/

      switch(sfield.conv)

      {

         case  'X'   :  sfield.conv = 'x';

         case  'i'   :

         case  'p'   :  

         case  'x'   :

         case  'u'   :

         case  'o'   :

         case  'd'   :  stat = _sproc_int(sfield.fwidth, _inpchar, _uninpchar, 

                                         tmpptr, sfield.conv, &inp, &num_read); 

                        break;

         case  'f'   :

         case  'e'   :

         case  'E'   :

         case  'g'   :

         case  'G'   :  stat = _sproc_float(sfield.fwidth, _inpchar, _uninpchar,

                                     tmpptr, sfield.conv, &inp, &num_read);

                        break;



         case  'c'   :  

         case  's'   : {

                          char *stptr = (sfield.flags & _SFSTAR) ?

                                         NULL : va_arg(_ap, char*);



                          stat = _sproc_str(sfield.fwidth, _inpchar, _uninpchar,

                                     stptr, sfield.conv, &inp, &num_read);

                       }

                       stat = (stat != EOF);

                       if (!(sfield.flags & _SFSTAR) && stat) num_assigned++;

                       break;



         case  '['   :  stat = _sproc_lb(_inpchar, _uninpchar, tmpptr, &sfield,

                                         &inp, &num_read);



      }



      stat = (stat != EOF);



      /*---------------------------------------------------------------------*/

      /* Now, call the function to handle the actual assignment, or if there */

      /* is no assignment to take place, process it here.                    */

      /*---------------------------------------------------------------------*/

      switch(sfield.conv)

      {

         case  'i'   :

         case  'd'   :  

         case  'x'   :

         case  'u'   :

         case  'o'   :  

         case  'p'   : 

         case  'e'   :

         case  'f'   :

         case  'g'   :

         case  'E'   :

         case  'G'   :  _sset_arg(&sfield, &_ap, tmpbuf);

                        if ((!(sfield.flags & _SFSTAR)) && stat) num_assigned++;

                        break;

 

         case  'n'   :  if (!(sfield.flags & _SFSTAR))

                           switch(sfield.flags & (_MFH | _MFHH | _MFL | _MFLL))

                           {

                              case  _MFH  :  *(va_arg(_ap, short int*)) =

                                             (short int)num_read;

                                             break;

 

                              case  _MFHH :  *(va_arg(_ap, char*)) =

                                             (char)num_read;

                                             break;

 

                              case _MFL   :  *(va_arg(_ap, long int*)) =

                                             (long int)num_read;

                                             break;

#ifdef LLONG_MAX

                              case _MFLL  :  *(va_arg(_ap, long long int*)) =

                                             (long long int)num_read;

                                             break;

#endif

                              default     :  *(va_arg(_ap, int*)) =

                                             num_read;

                                             break;

                           }

                        break;



         case  '%'   :  inchar = _inpchar(&inp);

                        if (inchar != '%') return (EOF);

                        else num_read++;

                        break;

                              

         case  '['   :  if ((!(sfield.flags & _SFSTAR)) && stat)

                        {

                           strcpy(va_arg(_ap, char *), tmpbuf);

                           num_assigned++;

                        }

      }

   }



}



/*****************************************************************************/

/* _SGET_CONV  -  Read the format flags into the _SFIELD pointer sfield      */

/*                                                                           */

/*    This function reads the characters directly after the '%' character,   */

/*    and stores them as flags in sfield, a pointer to a _SFIELD structure.  */

/*    These flags will later be used to process the conversion.              */

/*                                                                           */

/*****************************************************************************/

static int _sget_conv(char **_format, _SFIELD *sfield)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   char  tmpbuf[8],

         *tmpptr     =  tmpbuf,

         *strend     =  (*_format) + strlen(*_format);



   (*_format)++;                        /* Go to the character after the '%' */



   /*------------------------------------------------------------------------*/

   /* If the next character in the format statement is a '*', set the        */

   /* _SFSTAR flag in sfield                                                 */

   /*------------------------------------------------------------------------*/

   if (**_format == '*')

   {

      _SET(sfield, _SFSTAR);

      (*_format)++;

   }

 

   /*------------------------------------------------------------------------*/

   /* If numerical characters follow, read them into a temporary string,     */

   /* convert it into a number, and store it as the field width in sfield    */

   /*------------------------------------------------------------------------*/

   for(;**_format >= '0' && **_format <= '9'; *(tmpptr++) = *((*_format)++));

   *tmpptr = '\0';

 

   if (strlen(tmpbuf)) sfield->fwidth = atoi(tmpbuf);

 

   /*------------------------------------------------------------------------*/

   /* Set the h, l, or L flags if they were specified                        */

   /*------------------------------------------------------------------------*/

   switch(**_format)

   {

       case 'L': _SET(sfield, _MFLD); (*_format)++; break;

       case 'h':

       {

           (*_format)++;

           if (**_format == 'h') { _SET(sfield, _MFHH); (*_format)++; }

           else _SET(sfield, _MFH);

           break;

       }

       case 'l': 

       {

	   (*_format)++;

	   if (**_format == 'l') { _SET(sfield, _MFLL); (*_format)++; }

	   else _SET(sfield, _MFL);

       }

   }



   /*------------------------------------------------------------------------*/

   /* Read in the last character as the conversion specifier                 */

   /*------------------------------------------------------------------------*/

   sfield->conv = *((*_format)++);



   /*------------------------------------------------------------------------*/

   /* For the '[' conversion, read in the scanset.  Return an EOF if         */

   /* _SGET_SCANSET fails.                                                   */

   /*------------------------------------------------------------------------*/

   if ((sfield->conv == '[') && _sget_scanset(sfield, _format)) return (EOF);



   /*------------------------------------------------------------------------*/

   /* If we read past the end of the format string, return an error          */

   /*------------------------------------------------------------------------*/

   if (*_format > strend) return (EOF);

   else return (0);

}



/*****************************************************************************/

/* _SGET_SCANSET  -  Read in the scanset from the format statement           */

/*                                                                           */

/*    This function is called when the '[' conversion specifier has been     */

/*    encountered.  It reads in the scanset from the format statement,       */

/*    and stores it in sfield for later reference during the conversion.     */

/*                                                                           */

/*****************************************************************************/

static int _sget_scanset(_SFIELD *sfield, char **_format)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   char  *tmpptr  =  sfield->scanset;



   if (**_format == '^')

   {

      _SET(sfield, _SFCIRC);

      (*_format)++;

   }



   if (**_format == ']') *(tmpptr++) = *((*_format)++);



   while(**_format != ']' && **_format != '\0') *(tmpptr++) = *((*_format)++);



   *tmpptr = '\0';

   if (**_format == ']') (*_format)++;

   if (**_format == '\0') return (EOF);



   return(0);

}



/*****************************************************************************/

/* _SPROC_INT  -  Read an integer string into a temporary string             */

/*                                                                           */

/*    This function takes the next integer in character form from the        */

/*    current input source, and copies it into a temporary string, where     */

/*    it can later be converted into a numerical value.                      */

/*                                                                           */

/*****************************************************************************/

static int _sproc_int(int w_counter, int (*_inpchar)(void **inp), 

                       void (*_uninpchar)(void **inp, char outchar), 

                       char *tmpptr, char conv, void **inp, int *num_read) 

{

   /*------------------------------------------------------------------------*/

   /* Note: w_counter is a parameter that holds the field width.  When       */

   /*       the number of digits specified by w_counter has been read from   */

   /*       input, the function finishes.  w_counter is checked before each  */

   /*       read to make sure that it is not equal to zero, and it is        */

   /*       decremented after each read.  If no field width was specified,   */

   /*       w_counter will be equal to -1, in which case it will never       */

   /*       equal zero, and the function will read from input until it       */

   /*       encounters the first invalid character.                          */

   /*------------------------------------------------------------------------*/



   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   signed char inchar;

   int bnum_read = *num_read;



   /*------------------------------------------------------------------------*/

   /* Read in the next character                                             */

   /*------------------------------------------------------------------------*/

   inchar = _inpchar(inp);

   (*num_read)++;



   /*------------------------------------------------------------------------*/

   /* Accept the next character if it is a sign for the number               */

   /*------------------------------------------------------------------------*/

   if ((inchar == '+' || inchar == '-') && w_counter != 0)

   {

      *(tmpptr++) = inchar;

      inchar = _inpchar(inp);

      (*num_read)++;

      w_counter--;

   }





   /*------------------------------------------------------------------------*/

   /* Accept a leading '0' for an octal number, or a '0x' or '0X' for a      */

   /* hexadecimal number.                                                    */

   /*------------------------------------------------------------------------*/

   if ((conv == 'o' || conv == 'i' || conv =='x' || conv == 'p') && 

      w_counter != 0 && inchar == '0')

   {

      *(tmpptr++) = inchar;

      inchar = _inpchar(inp);

      (*num_read)++;

      w_counter--;

   }



   if ((conv == 'x' || conv == 'p' || conv == 'i') && w_counter != 0 &&

     (inchar == 'x' || inchar == 'X'))

   {

      *(tmpptr++) = inchar;

      inchar = _inpchar(inp);

      (*num_read)++;

      w_counter--;

   }



   /*------------------------------------------------------------------------*/

   /* Accept digits 0-9 for decimal numbers, or 0-F for hexadecimal numbers  */

   /*------------------------------------------------------------------------*/

   while(((inchar >= '0' && inchar <= '9') || 

          ((conv == 'x' || conv == 'p' || conv == 'i') &&

          ((inchar >= 'A' && inchar <= 'F') ||

          (inchar >= 'a' && inchar <= 'f')))) && w_counter != 0)

   {

      *(tmpptr++) = inchar;

      inchar = _inpchar(inp);

      (*num_read)++;

      w_counter--;

   }



   _uninpchar(inp, inchar);

   (*num_read)--;



   *tmpptr = '\0';



   if (bnum_read == *num_read) return(EOF);

   return(1);

}



/*****************************************************************************/

/* _SPROC_FLOAT   -  Read a float string into a temporary string             */

/*                                                                           */

/*    This function takes the next float in character form from the          */

/*    current input source, and copies it into a temporary string, where     */

/*    it can later be converted into a numerical value.                      */

/*                                                                           */

/*****************************************************************************/

static int _sproc_float(int w_counter, int (*_inpchar)(void **inp), 

                         void (*_uninpchar)(void **inp, char outchar), 

                         char *tmpptr, char conv, void **inp, int *num_read)

{

   /*------------------------------------------------------------------------*/

   /* Note: w_counter is a parameter that holds the field width.  When       */

   /*       the number of digits specified by w_counter has been read from   */

   /*       input, the function finishes.  w_counter is checked before each  */

   /*       read to make sure that it is not equal to zero, and it is        */

   /*       decremented after each read.  If no field width was specified,   */

   /*       w_counter will be equal to -1, in which case it will never       */

   /*       equal zero, and the function will read from input until it       */

   /*       encounters the first invalid character.                          */

   /*------------------------------------------------------------------------*/

 

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   signed char  inchar;

   int          invalid   = 0;

   int          bnum_read = *num_read;

   int          dec_flag  =  0;

   int          e_flag    =  0;



   /*------------------------------------------------------------------------*/

   /* Read in the next character                                             */

   /*------------------------------------------------------------------------*/

   inchar = _inpchar(inp);

   (*num_read)++;



   /*------------------------------------------------------------------------*/

   /* Accept the next character if it is a sign                              */

   /*------------------------------------------------------------------------*/

   if ((inchar == '+' || inchar == '-') && w_counter != 0)

   {

      *(tmpptr++) = inchar;

      inchar = _inpchar(inp);

      (*num_read)++;

      w_counter--;

   }

 

   /*------------------------------------------------------------------------*/

   /* Accept the next character if it is a numerical digit.                  */

   /* The characters '.', 'e', 'E', '+', and '-' are accepted under the      */

   /* following conditions:                                                  */

   /*                                                                        */

   /* '.'         :  a '.', an 'e', or an 'E' has not yet been encountered   */

   /* 'e' or 'E'  :  neither of these characters have been encounterd yet    */

   /* '+' or '-'  :  If the last character read was an 'E' or an 'e'         */

   /*------------------------------------------------------------------------*/

   while((inchar >= '0' && inchar <= '9') || inchar == '.' || inchar == 'e'

          || inchar == 'E' || inchar == '+' || inchar == '-')

   {



      switch(inchar)

      {

         case  '.'   :  if (dec_flag || e_flag) { invalid = 1; break; } 

                        else dec_flag = 1;

                        break;



         case  'e'   :

         case  'E'   :  if (e_flag) { invalid = 1; break; }

                        else e_flag = 1;

                        break;



         case  '+'   :  

         case  '-'   :  if (*(tmpptr-1) != 'E' && *(tmpptr-1) != 'e')

                        { invalid = 1; break; }

      }



      if (invalid) break;

      *(tmpptr++) = inchar;

      inchar = _inpchar(inp);

      if (inchar != EOF) (*num_read)++;

      w_counter--;

   }



   _uninpchar(inp, inchar);

   if (inchar != EOF) (*num_read)--;



   *tmpptr = '\0';



   if (bnum_read == *num_read) return(EOF);

   return(1);

}



/*****************************************************************************/

/* _SPROC_STR  -  Copy a string from the input source to a temporary string  */

/*                                                                           */

/*    This function takes a string from the input source, and copies it      */

/*    into a temporary string, to be later assigned to a scanf argument.     */

/*                                                                           */

/*****************************************************************************/

static int _sproc_str(int w_counter, int (*_inpchar)(void **inp), 

                       void (*_uninpchar)(void **inp, char outchar), 

                       char *tmpptr, char conv, void **inp, int *num_read)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   signed char inchar;

   int bnum_read = *num_read;



   /*------------------------------------------------------------------------*/

   /*	If no precision was given for the %c conversion, set it to one.        */

   /*------------------------------------------------------------------------*/

   if ((conv == 'c') && (w_counter < 0)) w_counter = 1;



   /*------------------------------------------------------------------------*/

   /* Read in the next character, then while that character is not a white   */

   /* space character, a null terminator, an EOF character, and the field    */

   /* width has not been exceeded, copy it to the temporary string, and      */

   /* get another character.                                                 */

   /*------------------------------------------------------------------------*/

   inchar = _inpchar(inp);

   (*num_read)++;



   while((conv == 'c' || !isspace(inchar)) && inchar != '\0' &&

         inchar != EOF && w_counter--)

   { 

      if (tmpptr) *(tmpptr++) = inchar;

      inchar = _inpchar(inp);

      (*num_read)++;

   }

   

   /*------------------------------------------------------------------------*/

   /* The %s conversion specifies that a null terminator be placed at the    */

   /* end of the conversion.                                                 */

   /*------------------------------------------------------------------------*/

   if (conv == 's' && tmpptr) *tmpptr = '\0';



   _uninpchar(inp, inchar);

   (*num_read)--;



   if (bnum_read == *num_read) return(EOF);

   return(1);

}



/*****************************************************************************/

/* _SPROC_LB   -  Process the %[ conversion                                  */

/*                                                                           */

/*    This function copies characters from the input stream into a           */

/*    temporary string until it satisfies the field width, or encounters a   */

/*    character that is not in the scanset.  The scanset is defined as the   */

/*    characters passed between the left and right brackets.  If a '^' is    */

/*    first character after the left bracket, then the scanset is every      */

/*    character that is not listed between the two brackets.                 */

/*                                                                           */

/*****************************************************************************/

static int _sproc_lb(int (*_inpchar)(void **inp), 

                      void (*_uninpchar)(void **inp, char outchar),

                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   signed char  inchar;

   int          bnum_read = *num_read;

   int          w_counter =  sfield->fwidth;

   int          test;



   inchar = _inpchar(inp);

   (*num_read)++;



   for (; w_counter != 0 && inchar != EOF; w_counter--)

   {

      test = (strrchr(sfield->scanset, inchar) != NULL);

      if (_STCHK(sfield, _SFCIRC)) test = !test;

             

      if (test)

      {

         *(tmpptr++) = inchar;

         inchar = _inpchar(inp);

         (*num_read)++;

      }

      else

      {

         _uninpchar(inp, inchar);

         (*num_read)--;

         break;

      }

   }



   *tmpptr = '\0';



   if (bnum_read == *num_read) return(EOF);

   return(1);

}



/*****************************************************************************/

/* _SSET_ARG   -  Assign the converted value to the next argument            */

/*                                                                           */

/*    This function takes a pointer to the result conversion string, and     */

/*    assigns it to the next argument.  The type of argument to be assigned  */

/*    is determined by the conversion specifier, and the h, l, or L flags    */

/*    if they were used.                                                     */

/*                                                                           */

/*****************************************************************************/

static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   int base;



   /*------------------------------------------------------------------------*/

   /* Do the assignment only if the result string has a length greater than  */

   /* zero, and the '*' flag was not used                                    */

   /*------------------------------------------------------------------------*/

   if (tmpbuf[0] != '\0' && !_STCHK(sfield, _SFSTAR))

      switch(sfield->conv)

      {

         case  'i'   :

         case  'd'   :  base = (sfield->conv == 'd') ? 10 : 0;

   

                        switch(_STCHK(sfield, (_MFH | _MFHH | _MFL | _MFLL)))

                        {

                           case  _MFH  :  *(va_arg(*_ap, short int*)) =

                                          (short int)strtol(tmpbuf, NULL,

                                          base);

                                          break;



                           case  _MFHH :  *(va_arg(*_ap, char*)) =

                                          (char)strtol(tmpbuf, NULL, base);

                                          break;



                           case _MFL   :  *(va_arg(*_ap, long int*)) =

                                          strtol(tmpbuf, NULL, base);

                                          break;

#ifdef LLONG_MAX

                           case _MFLL  :  *(va_arg(*_ap, long long int*)) =

                                          strtoll(tmpbuf, NULL, base);

                                          break;

#endif

                           default     :  *(va_arg(*_ap, int*)) =

                                          (int)strtol(tmpbuf, NULL, base);

                                          break;

                        }

                        break;



      /*---------------------------------------------------------------------*/

      /* Suppress "conversion from integer to smaller pointer" warning for   */

      /* the %p case.                                                        */

      /*---------------------------------------------------------------------*/

#pragma DIAGNOSTIC_SUPPRESS(1107)

      case  'p'   :  *(va_arg(*_ap, void **))=(void *)strtoul(tmpbuf, NULL, 16);

		     break;

#pragma DIAGNOSTIC_RESET(1107)



      case  'x'   :

      case  'u'   :

      case  'o'   :  base = (sfield->conv == 'u') ? 10 :

                            (sfield->conv == 'x') ? 16 : 8;



                     switch(_STCHK(sfield, (_MFH | _MFHH | _MFL | _MFLL)))

                     {

                        case _MFH : *(va_arg(*_ap, unsigned short int*))=

                                    (unsigned short int)strtoul(tmpbuf,

                                    NULL, base);

                                    break;



                        case _MFHH: *(va_arg(*_ap, unsigned char*))=

                                    (unsigned char)strtoul(tmpbuf, NULL, base);

                                    break;



                        case _MFL : *(va_arg(*_ap, unsigned long int*)) =

                                    strtoul(tmpbuf, NULL, base);

                                    break;

#ifdef LLONG_MAX

                        case _MFLL: *(va_arg(*_ap, unsigned long long int*)) =

                                    strtoull(tmpbuf, NULL, base);

                                    break;

#endif

                        default   : *(va_arg(*_ap, unsigned int*)) =

                                    (unsigned int)strtoul(tmpbuf, NULL,

                                    base);

                                    break;

                     }

                     break;



      case  'e'   :

      case  'f'   :

      case  'g'   :

      case  'E'   :

      case  'G'   :  switch(_STCHK(sfield, (_MFL | _MFLD)))

                     {

                        case _MFL : *(va_arg(*_ap, double*))=

                                    strtod(tmpbuf, NULL);

                                    break;



                        case _MFLD: *(va_arg(*_ap, long double*)) =

                                    strtold(tmpbuf, NULL);

                                    break;



                        default   : *(va_arg(*_ap, float*)) =

                                    (float)strtod(tmpbuf, NULL);

                                    break;

                     }

                     break;



   }

}


abs.c/          1148595152  0     0     0       633       `
/****************************************************************************/

/*  abs labs v3.3.2                                                         */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include "stdlib.h"

#include <limits.h>



_CODE_ACCESS int abs(int i)

{

    if (i < 0) i = -i;

    return i;

}



_CODE_ACCESS long labs(long i)

{

    if (i < 0) i = -i;

    return i;

}



#ifdef LLONG_MAX

_CODE_ACCESS long long llabs(long long i)

{

    if (i < 0) i = -i;

    return i;

}

#endif


absd.c/         1148595152  0     0     0       693       `
/****************************************************************************/

/*  absd.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:25 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



  REAL ABSF(REAL x)

{

#ifdef IEEE_Hardware 

   return (x < 0) ? -x : x;

#else 

   MSC(x) &= (char)(~(1<<(16 -1)));

   return x;

#endif 

} /* ABSF */


access.h/       1148595152  0     0     0       1431      `
/****************************************************************************/

/*  access.h         v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:59:26 CDT 2000 */

 

#ifndef __EXTERN



   #undef __EXTERN

   #undef __INLINE

   #undef __STATIC



   #if defined(_TMS320C6X)

      #include <linkage.h>

      #ifdef __cplusplus

         #define __EXTERN extern "C" _CODE_ACCESS

      #else

         #define __EXTERN extern _CODE_ACCESS

      #endif

      #define __INLINE _IDECL

      #define __STATIC static _DATA_ACCESS



   #else

      #undef _CODE_ACCESS

      #undef _DATA_ACCESS



      #if defined(_FAR_RTS)

         #define __EXTERN far extern

         #define __STATIC static far

         #define _CODE_ACCESS far

         #define _DATA_ACCESS far

 

      #else

         #ifdef __cplusplus

            #define __EXTERN extern "C"

         #else

            #define __EXTERN extern

         #endif

         #define __STATIC static

         #define _CODE_ACCESS

         #define _DATA_ACCESS

      #endif



      #if defined(_INLINE)

         #define __INLINE static __inline

      #else

         #define __INLINE __EXTERN

      #endif

   #endif

#endif




acos.c/         1148595152  0     0     0       1697      `
/****************************************************************************/

/*  acos.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:33 CDT 2000 */

 

#include "reald.h"



  REAL ACOSF(REAL x)

{



    {

    

       /* NOTE: this is the table for 2**-23 error. */

       /* The lost precision is very small.         */

       /* The 2**-24 table has one extra term.      */

       

       static  REAL asin_consts[4] = /* max of 23 mantissa bits */

         {KNST( 5.0505363E-02), 

          KNST( 3.9721134E-02), 

          KNST( 7.5464795E-02), 

          KNST( 1.6665163E-01)};



       REAL g, y, Result;



       ABSF2(y,x);



       if GTRF(y, HALF) 

       {

          if GTRF(y, ONE) { errno = EDOM; CPYF(y, ONE); }



          MPYF3(g, ADDF(SUBF(HALF,y), HALF), HALF);

          MPYF3(y, CNST(-2.0), SQRTF(g));



          POLYF(Result, g, asin_consts, 4 );



 	  ADDF3(Result, y,  MPYF(y, Result));

 	  if LEZF(x) 

             ADDF3(Result, ADDF(Pi_Over_Two, Result), Pi_Over_Two);

          else NEGF1(Result);



       } 

       else /* y < 0.5 */

       { 

          SQRF2(g,y);



          POLYF(Result, g, asin_consts, 4 );



          ADDF3(Result, y, MPYF(y, Result));

 	  if LEZF(x)

             ADDF3(Result, ADDF(Pi_Over_Four, Result), Pi_Over_Four);

          else

             ADDF3(Result, SUBF(Pi_Over_Four, Result), Pi_Over_Four);

       }

       return Result;

    }



} /*ACOSF*/


acosh.c/        1148595152  0     0     0       1611      `
/****************************************************************************/

/*  acosh.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:33 CDT 2000 */

 

#include "reald.h"



  REAL ACOSHF(REAL x)

{

   /* Taken from "Handbook of Mathematical Functions with Formulas, Graphs,  */

   /* and Mathematical Tables",                                              */

   /* Milton Abramowitz and Irene A. Stegun,                                 */

   /* National Bureau of Standards (Applied Mathematics Series 55),          */

   /* Washington D.C., 1964 (reprinted 1970). 4.6.21, page 87.               */



   if LSSF(x, ONE) { errno = EDOM; return ZERO; }



   /* Apply the identity: acosh(x) = log(x + sqrt(x*x - 1.0)).               */

   /* We need not compute sqrt(x*x - 1.0) if x*x is so big that the          */

   /* 1.0 term is lost.                                                      */

   /* The biggest positive number that can be held in REAL                   */

   /* that still has a 1's digit is RADIX**REAL_MANTISSA-1,                  */

   /* so the cut-off is about sqrt(2**REAL_MANTISSA) or                      */

   /* RADIX**(REAL_MANTISSA/2)                                               */

   if LSSF(x, CNST(4096.0) )

      return LOGF(ADDF(x,SQRTF(SUBF(SQRF(x),ONE))));



   return ADDF(LOGF(x), Ln_2);



} /* ACOSF */


acot.c/         1148595153  0     0     0       609       `
/****************************************************************************/

/*  acot.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:34 CDT 2000 */

 

#include "reald.h"



  REAL ACOTF(REAL x)

{

   REAL Result;

   if EQZF(x) return Pi_Over_Two;

   Result = ATANF(INVF(x));

   if LSZF(Result) return ADDF(Result, Pi);

   return Result; 

} /* ACOTF */


acot2.c/        1148595153  0     0     0       498       `
/****************************************************************************/

/*  acot2.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:34 CDT 2000 */

 

#include "reald.h"



  REAL ACOT2F(REAL x, REAL y)

{

   return ATAN2F(y, x);

} /* ACOT2F */

acoth.c/        1148595153  0     0     0       740       `
/****************************************************************************/

/*  acoth.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:37 CDT 2000 */

 

#ifndef _TI_ENHANCED_MATH_H

#define _TI_ENHANCED_MATH_H 1

#endif

#include "reald.h"



  REAL ACOTHF(REAL x)

{

   if LSSF(ABSF(x),ONE) 

   {

      errno = (LSSF(ABSF(x),ONE) ? EDOM : ERANGE);

      if LSZF(x) return CNST(-3.402823466E+38) ;

      return CNST( 3.402823466E+38) ;

   }

   return ATANHF(INVF(x));

} /* ACOTHF */

addd.c/         1148595153  0     0     0       8123      `
/****************************************************************************/

/*  addd.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Nov 19 14:26:11 CST 2003 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



 REAL ADDF(REAL left, REAL right)

/*---------------------------------------------------------------------------*/

/* IEEE floating add.  return left + right                                   */



/* Does *NOT* handle +/- INFINITY, NAN.                                      */



/* Does *NOT* handle denormalized numbers.                                   */



/*---------------------------------------------------------------------------*/

/* See also:								     */

/*                                                                           */

/* Knuth D., "The Art of Computer Programming", Volume 2, ch 4.2	     */

/* ("Floating Point Arithmetic")					     */

/*                                                                           */

/* Goldberg D., "What Every Computer Scientist Should Know About	     */

/* Floating-Point Arithmetic", ACM Computing Surveys, Vol 23, No 1, March    */

/* 1991									     */

/*                                                                           */

/* Goldberg D., "Computer arithmetic."  Appendix A in "Computer		     */

/* Architecture: A Quantitative Approach, Patterson and Hennessy.	     */

/*                                                                           */

/* IEEE-754 "IEEE Standard for Binary Floating-Point Arithmetic"             */

/*---------------------------------------------------------------------------*/

{

 #ifdef IEEE_Hardware

   return left + right;

 #else



   long lft , rgt ; /* int register versions of left,right REAL params   */

   long lfrc, rfrc; /* fraction of left/dest operand and right operand   */

   int lexp, rexp; /* exponent of left/dest operand and right operand   */

   long sign;

   int expdif;



   long guard_bit = 0, round_bit = 0, sticky_bit = 0;



   /*------------------------------------------------------------------------*/

   /* Transfer the left,right bits to lft,rgt.                               */

   /* REALasINT may force left and right to memory if dumb compiler.         */

   /* This is OK since they won't be needed again except for unusual cases.  */

   /* lft,rgt will hopefully wind up in integer registers.                   */

   /*------------------------------------------------------------------------*/

   REALasINT(lft,left);

   REALasINT(rgt,right);



   /*------------------------------------------------------------------------*/

   /* Unpack fraction and exponent, ignoring signs for now.                  */

   /* Reinsert hidden bit or re-normalize fraction as appropriate.           */

   /*------------------------------------------------------------------------*/



   if ((lfrc = lft & ~MINUS) == 0) { /* signed 0 + 0 rules */

      rfrc = rgt;

      if ((rfrc & ~MINUS) == 0) rfrc &= lft;

      return_INTasREAL(rfrc);

   }

   if ((rfrc = rgt & ~MINUS) == 0) return left;

   if (lexp = lfrc >> REAL_FRC_MSBs)

      lfrc = (lfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT; /*insert hidden bit*/

   else



      return right;



   if (rexp = rfrc >> REAL_FRC_MSBs)

      rfrc = (rfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT; /*insert hidden bit*/

   else



      return left;



   /*---------------------------------------------------------------------*/

   /* This algorithm relies on the fact that the left operand has	  */

   /* equal or large magnitude (exponent only).  Swap if necessary.	  */

   /*---------------------------------------------------------------------*/

   if (rexp > lexp)

   {

       long temp_frc = lfrc;

       int temp_exp = lexp;

       lfrc = rfrc;

       rfrc = temp_frc;

       lexp = rexp;

       rexp = temp_exp;

       sign = rgt & MINUS;

   }

   else sign = lft & MINUS;



   /*------------------------------------------------------------------------*/

   /* If the signs of the inputs differ, negate the right significand.	     */

   /*------------------------------------------------------------------------*/

   if ((lft ^ rgt) & MINUS) rfrc = -rfrc;



   /*------------------------------------------------------------------------*/

   /* Shift the rfrc to align radix point and add, keeping track of guard    */

   /* and rounding bits.						     */

   /*------------------------------------------------------------------------*/

   expdif = lexp - rexp;



   if (expdif < 23 +2)

   {

       lfrc += (rfrc >> expdif);



       if (expdif == 0) guard_bit = round_bit = sticky_bit = 0;

       else

       {

           guard_bit = (rfrc << (32 -expdif)) & MINUS;

           if (expdif == 1) round_bit = sticky_bit = 0;

           else

           {

               round_bit = (rfrc << (32 -expdif+1)) & MINUS;

               if (expdif == 2) sticky_bit = 0;

               else sticky_bit = (rfrc << (32 -expdif+2));

           }

       }

   }



   /*------------------------------------------------------------------------*/

   /* If the result is negative, negate the significand.  This will only     */

   /* happen if (lexp-rexp==0).						     */

   /*------------------------------------------------------------------------*/

   if (lfrc <= 0)

   {

      if (lfrc == 0) return_INTasREAL(lfrc);

      lfrc = -lfrc; sign ^= MINUS;

   }



   /*------------------------------------------------------------------------*/

   /* Round and normalize the result                                         */

   /*------------------------------------------------------------------------*/

   if (lfrc >= (REAL_HIDDEN_BIT << 1))

   {

       sticky_bit = guard_bit | round_bit | sticky_bit;

       round_bit = lfrc & 0x1;

       lfrc >>= 1;

       lexp++;

   }

   else if (lfrc < REAL_HIDDEN_BIT)

   {

       int count;

       for (count = 0; lfrc < REAL_HIDDEN_BIT; count++)

       {

           lfrc <<= 1;

           lexp--;

           if (count == 0) lfrc |= (guard_bit != 0);

           if (count == 1) round_bit = sticky_bit = 0;

       }

   }

   else

   {

       sticky_bit = round_bit | sticky_bit;

       round_bit = guard_bit;

   }



   /*------------------------------------------------------------------------*/

   /* Round to even.  If the rounding bits are exactly one-half, round	     */

   /* the final result bit to an even number (this may round down).	     */

   /*------------------------------------------------------------------------*/

   if (round_bit && ((lfrc & 0x1) || sticky_bit)) lfrc += 1;



   /*------------------------------------------------------------------------*/

   /* Re-normalize if necessary                                              */

   /*------------------------------------------------------------------------*/

   if (lfrc >= (REAL_HIDDEN_BIT << 1))

   {

       lfrc >>= 1;

       lexp++;

   }



   /*------------------------------------------------------------------------*/

   /* Check for overflow and underflow                                       */

   /*------------------------------------------------------------------------*/

   if (lexp <= 0) { /* underflow? */



      lfrc = 0; /* no significant bits remain */



      lexp = 0;

   }

   else if (lexp >= REAL_EXP_INFNAN) { /* overflow? */



      lexp = REAL_EXP_INFNAN; lfrc = 0;



   }



   /*------------------------------------------------------------------------*/

   /* Assemble result and return                                             */

   /*------------------------------------------------------------------------*/

   lfrc = (lfrc & REAL_FRC_MASK) + (((long)lexp) << REAL_FRC_MSBs) +sign;



   return_INTasREAL(lfrc);

 #endif

} /* ADDF */


args_main.c/    1148595153  0     0     0       1926      `
/******************************************************************************/

/* The ARGS data structure is defined according to a convention with linker.  */

/*                                                                            */

/* If the user want to pass arguments to loader, "--args=###" option has to   */

/* be used in linking to generate executable. With this option, the linker    */

/* will allocate a section starting with __c_args__, and with this "###" many */

/* bytes. The loader when parses the arguments, will dump the number of       */

/* arguments, argc as the 1st arguments at address __c_args__, all the actual */

/* arguments will be dumped after that. The total space for these arguments   */

/* will not exceed "###" bytes.                                               */

/*                                                                            */

/* if "--args="###" is not used as a linker option, linker will put -1 at     */

/* __c_args__ location.                                                       */ 

/*                                                                            */

/* Based on the above convention, the following code implements the access to */

/* these arguments when main is called.                                       */

/*                                                                            */

/* This function is called from boot.asm or boot.c.                           */

/******************************************************************************/



typedef struct { int argc; char *argv[1]; } ARGS;

extern ARGS __c_args__;



extern int main(int argc, char *argv[]);



int _args_main()

{

   register ARGS *pargs = &__c_args__;

   register int    argc = 0;

   register char **argv = 0;

   

   if (pargs != (ARGS *)-1) 

      { argc = pargs->argc; argv = pargs->argv; }

  

   return main(argc, argv);

}

arith.h/        1148595153  0     0     0       3184      `
/****************************************************************************/

/*  arith.h          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:59:27 CDT 2000 */

 

#ifndef __arith__

#define __arith__



#include <stdlib.h> /* contains ldiv_t and div_*/



#include "access.h"



/*************************************************/

/* signed and unsigned char arithmetic functions */

/*************************************************/



__EXTERN unsigned char _divb(unsigned char num, unsigned char den);

__EXTERN   signed char _divc(  signed char num,   signed char den);

__EXTERN unsigned char _remb(unsigned char num, unsigned char den);

__EXTERN   signed char _remc(  signed char num,   signed char den);



typedef struct { unsigned char quot, rem; } _bdiv_t;

typedef struct {   signed char quot, rem; } _cdiv_t;



__EXTERN _bdiv_t _bdiv(unsigned char num, unsigned char den);

__EXTERN _cdiv_t _cdiv(  signed char num,   signed char den);



/**************************************************/

/* signed and unsigned short arithmetic functions */

/**************************************************/



__EXTERN unsigned short _divus(unsigned short num, unsigned short den);

__EXTERN          short _divsi(         short num,          short den);

__EXTERN unsigned short _remus(unsigned short num, unsigned short den);

__EXTERN          short _remsi(         short num,          short den);



typedef struct { unsigned short quot, rem; } _usdiv_t;

typedef struct {          short quot, rem; } _sidiv_t;



__EXTERN _usdiv_t _usdiv(unsigned short num, unsigned short den);

__EXTERN _sidiv_t _sidiv(         short num,          short den);



/************************************************/

/* signed and unsigned int arithmetic functions */

/************************************************/



__EXTERN unsigned int _divu(unsigned int num, unsigned int den);

__EXTERN          int _divi(         int num,          int den);

__EXTERN unsigned int _remu(unsigned int num, unsigned int den);

__EXTERN          int _remi(         int num,          int den);



typedef struct { unsigned int quot, rem; } _udiv_t;



__EXTERN _udiv_t _udiv(unsigned int num, unsigned int den);

__EXTERN   div_t   div(         int num,          int den);



/*************************************************/

/* signed and unsigned long arithmetic functions */

/*************************************************/



__EXTERN unsigned long _divul(unsigned long num, unsigned long den);

__EXTERN          long _divli(         long num,          long den);

__EXTERN unsigned long _remul(unsigned long num, unsigned long den);

__EXTERN          long _remli(         long num,          long den);



typedef struct { unsigned long quot, rem; } _uldiv_t;



__EXTERN _uldiv_t _uldiv(unsigned long num, unsigned long den);

__EXTERN   ldiv_t   ldiv(         long num,          long den);



#include "unaccess.h"



#endif /* __arith_*/

array_del.cpp/  1148595153  0     0     0       1828      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ operator delete();



*/





#include "basics.h"

#include "runtime.h"



#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE



void operator delete[](void *ptr) THROW_NOTHING()

/*

Default array operator delete.  Just call the normal operator delete.

*/

{

  operator delete(ptr);

}  /* operator delete[] */



#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

array_new.cpp/  1148595153  0     0     0       1839      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ operator new[]();



*/





#include "basics.h"

#include "runtime.h"



#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE



void *operator new[](size_t size) THROW(STD_NAMESPACE::bad_alloc)

/*

Default array operator new.  Just call the normal operator new.

*/

{

  return operator new(size);

}  /* operator new[] */



#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/


array_nodel.cpp/1148595153  0     0     0       1936      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ operator delete();



*/





#include "basics.h"

#include "runtime.h"



#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE



void operator delete[](void				*ptr,

                       const STD_NAMESPACE::nothrow_t&	nothrow_arg)

THROW_NOTHING()

/*

Nothrow version of array operator delete.  Just call the normal nothrow

operator delete.

*/

{

  operator delete(ptr, nothrow_arg);

}  /* operator delete[] */



#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/



array_nonew.cpp/1148595153  0     0     0       1954      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Placement version of C++ operator new[]();



*/





#include "basics.h"

#include "runtime.h"



#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE



void *operator new[](size_t			     size,

                     const STD_NAMESPACE::nothrow_t& nothrow_arg)

THROW_NOTHING()

/*

Nothrow version of array operator new.  Just call the normal nothrow

operator new.

*/

{

  return operator new(size, nothrow_arg);

}  /* operator new[] */



#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/



array_pdel.cpp/ 1148595153  0     0     0       1890      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ operator delete[](size_t, void*);



*/



#include "basics.h"

#include "runtime.h"





#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE && ABI_CHANGES_FOR_PLACEMENT_DELETE



void operator delete[](void*, void*) THROW_NOTHING()

/*

Placement operator delete -- does nothing.

*/

{

}  /* operator delete[](void*, void*) */



#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE &&

          ABI_CHANGES_FOR_PLACEMENT_DELETE*/



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

array_pnew.cpp/ 1148595153  0     0     0       1912      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/



/*



C++ operator new[](size_t, void*) (placement array new).



*/





#include "basics.h"

#include "runtime.h"



#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE && DEFINE_PLACEMENT_NEW_ROUTINES



void *operator new[](size_t, void* ptr) THROW_NOTHING()

/*

Placement array operator new.

*/

{

  return ptr;

}  /* operator new[](size_t, void*) */



#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE &&

          DEFINE_PLACEMENT_NEW_ROUTINES*/



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/





asctime.c/      1148595153  0     0     0       1094      `
/****************************************************************************/

/*  asctime v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <time.h> 



extern _CODE_ACCESS int sprintf(char *_string, const char *_format, ...);



static _DATA_ACCESS const char *const day[7]  = {

		      "Sun","Mon","Tue","Wed","Thu","Fri","Sat" };

static _DATA_ACCESS const char *const mon[12] = {

		     "Jan","Feb","Mar","Apr","May","Jun", 

                     "Jul","Aug","Sep","Oct","Nov","Dec" };



_CODE_ACCESS char *asctime(const struct tm *timeptr)

{

    struct tm   tptr = *timeptr;

    static _DATA_ACCESS char result[26];



    mktime(&tptr);      /* MAKE SURE THIS A SANE TIME */



    sprintf(result, "%s %s%3d %02d:%02d:%02d %d\n",

		    day[tptr.tm_wday], mon[tptr.tm_mon], tptr.tm_mday, 

		    tptr.tm_hour, tptr.tm_min, tptr.tm_sec,

		    tptr.tm_year + 1900);



    return (result);

}

asin.c/         1148595153  0     0     0       1635      `
/****************************************************************************/

/*  asin.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:38 CDT 2000 */

 

#include "reald.h"



  REAL ASINF(REAL x)

{



    {

    

        /* NOTE: this is the table for 2**-23 error. */

        /* The lost precision is very small.         */

        /* The 2**-24 table has one extra term.      */

        

        static  REAL asin_consts[4] = /* max of 23 mantissa bits */

          {KNST( 5.0505363E-02), 

           KNST( 3.9721134E-02), 

           KNST( 7.5464795E-02), 

           KNST( 1.6665163E-01)};



        REAL g, y, Result;



        ABSF2(y,x);



        if GTRF(y, HALF) 

        {

           if GTRF(y, ONE) { errno = EDOM; CPYF(y, ONE); }



           MPYF3(g, ADDF(SUBF(HALF,y), HALF), HALF);

           MPYF3(y, CNST(-2.0), SQRTF(g));



           POLYF(Result, g, asin_consts, 4 );



           /* Result = (Pi_Over_Four + (y + y*Result)) + Pi_Over_Four; */

           ADDF3(Result,

                 ADDF(Pi_Over_Four,

                      ADDF(y,MPYF(y,Result))),

                 Pi_Over_Four);

       } 

       else  /* y < 0.5 */

       {

          SQRF2(g,y);

          POLYF(Result, g, asin_consts, 4 );



          ADDF3(Result, y, MPYF(y, Result));

       }

       if LSZF(x) NEGF1(Result);

       return Result;

    }



} /* ASINF */




asinh.c/        1148595153  0     0     0       1970      `
/****************************************************************************/

/*  asinh.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:38 CDT 2000 */

 

#include "reald.h"



  REAL ASINHF(REAL x)

{

   /* Taken from "Handbook of Mathematical Functions with Formulas, Graphs,  */

   /* and Mathematical Tables",                                              */

   /* Milton Abramowitz and Irene A. Stegun,                                 */

   /* National Bureau of Standards (Applied Mathematics Series 55),          */

   /* Washington D.C., 1964 (reprinted 1970). 4.6.20, page 87.               */



   static  REAL asinh_consts[4] = /* max of 25 mantissa bits */

     {KNST( 1.98887612E-02), 

      KNST(-4.25708399E-02), 

      KNST( 7.48242149E-02), 

      KNST(-1.66661337E-01)};



   REAL g, Result;



   ABSF2(g,x);

   if GTRF(g, HALF)

   {

      /* Apply the identity: asinh(x) = log(x + sqrt(x*x + 1.0)).         */

      /* We need not compute sqrt(x*x + 1.0) if x*x is so big that the    */

      /* 1.0 term is lost.                                                */

      /* The biggest positive number that can be held in REAL             */

      /* that still has a 1's digit is RADIX**REAL_MANTISSA -1,           */

      /* so the cut-off is about sqrt(RADIX**REAL_MANTISSA) or            */

      /* RADIX**(REAL_MANTISSA/2)                                         */



      if LSSF(g, CNST(4096.0) )

         CPYF(Result, LOGF(ADDF(g,SQRTF(ADDF(SQRF(x),ONE)))));

      else ADDF3(Result,LOGF(g),Ln_2);

      if LSZF(x) NEGF1(Result);

      return Result;

   }



   SQRF2(g, x);

   POLYF(Result, g, asinh_consts, 4 );



   return ADDF(x,MPYF(x,Result));

} /* ASINHF */

assert.c/       1148595153  0     0     0       1663      `
/****************************************************************************/

/*  assert   v3.3.2                                                         */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdio.h>

#include <assert.h>

#include <stdlib.h>



/****************************************************************************/

/* _ASSERT() - Implements the assert macro. Checks the argument. Aborts     */

/*             with a message if not true.                                  */

/****************************************************************************/

_CODE_ACCESS void _assert(int expr, const char *string)

{

    if (!expr) _abort_msg(string);

}



/****************************************************************************/

/* _NASSERT() - Special version of assert, which assumes the expression is  */

/*              true.                                                       */

/****************************************************************************/

_CODE_ACCESS void _nassert(int expr)

{

    return;

}



/****************************************************************************/

/* _ABORT_MSG() - Write out a string and never return.  Abort function for  */

/*                false assertions.                                         */

/****************************************************************************/

_CODE_ACCESS void _abort_msg(const char *string)

{

    fprintf(stderr,"%s",string);

    fflush(stderr); /* Always a good idea to flush */

    abort();

}


assert.h/       1148595153  0     0     0       2011      `
/*****************************************************************************/

/* assert.h   v3.3.2                                                         */

/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _ASSERT

#define _ASSERT



#include <linkage.h>



#ifdef __cplusplus

//----------------------------------------------------------------------------

// <cassert> IS RECOMMENDED OVER <assert.h>.  <assert.h> IS PROVIDED FOR

// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++

//----------------------------------------------------------------------------



#define _NAMESPACE_PREFIX std::



extern "C" namespace std

{

#else

#define _NAMESPACE_PREFIX

#endif



/* this #ifndef can go away when C2000 uses extern C builtins */

extern _CODE_ACCESS void _nassert(int);

extern _CODE_ACCESS void _assert(int, const char *);

extern _CODE_ACCESS void _abort_msg(const char *);



#define _STR(x)  __STR(x)

#define __STR(x) #x



#if defined(NDEBUG)

#define assert(_ignore) ((void)0)

#elif defined(NASSERT)

#define assert(_expr)   _NAMESPACE_PREFIX _nassert(_expr)

#else

#define assert(_expr)   _NAMESPACE_PREFIX _assert((_expr) != 0,          \

                   "Assertion failed, (" _STR(_expr) "), file " __FILE__ \

                   ", line " _STR(__LINE__) "\n")

#endif /* NDEBUG, NASSERT */



#ifdef __cplusplus

} /* extern "C" namespace std */



#ifndef _CPP_STYLE_HEADER

using std::_nassert;

#endif /* _CPP_STYLE_HEADER */



#if 0

extern _CODE_ACCESS void std::_nassert(int), _assert(int, const char *);

extern _CODE_ACCESS void std::_abort_msg(const char *);

#endif /* 0 */



#ifndef _CPP_STYLE_HEADER

using std::_nassert;

#endif  /* !_CPP_STYLE_HEADER */



#endif /* __cplusplus */



#else



#ifdef __cplusplus



#ifndef _CPP_STYLE_HEADER

using std::_nassert;

#endif /* _CPP_STYLE_HEADER */



#endif



#endif /* _ASSERT */


atan.c/         1148595153  0     0     0       1666      `
/****************************************************************************/

/*  atan.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:38 CDT 2000 */

 

#include "reald.h"



  REAL ATANF(REAL y)

{

    

    REAL f, g, Result;

    int n;



    ABSF2(f,y);



    {

       /* Adapted from "Software Manual for the Elementary Functions"   */

       /* Cody and Waite, Prentice Hall 1980. pages 150-163             */

       /* And from "Handbook of Mathematical Functions with Formulas,   */

       /* Graphs, and Mathematical Tables",                             */

       /* Milton Abramowitz and Irene A. Stegun,                        */

       /* National Bureau of Standards (Applied Mathematics Series 55), */

       /* Washington D.C., 1964 (reprinted 1970). 4.4.49, page 81       */



       static  REAL arctan_consts[8] =

         {KNST( 0.0028662257),

          KNST(-0.0161657367),

          KNST( 0.0429096138),

          KNST(-0.0752896400),

          KNST( 0.1065626393),

          KNST(-0.1420889944),

          KNST( 0.1999355085),

          KNST(-0.3333314528)};

    

       n = 0;

       if GTRF(f, ONE) { NEGF2(f, INVF(f)); n = 2; }



       SQRF2(g,f);



       POLYF(Result, g, arctan_consts, 8 );

       ADDF3(Result, f, MPYF(f, Result));



       if NEZF(n) ADDF2(Result, Pi_Over_Two);

       if LSZF(y) NEGF1(Result);

       return Result;

    }



} /* ATANF */

atan2.c/        1148595153  0     0     0       1194      `
/****************************************************************************/

/*  atan2.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:39 CDT 2000 */

 

#include "reald.h"



  REAL ATAN2F(REAL y, REAL x)

{

   REAL    Result;

   EXPONENT_TYPE yn, xn;



   if EQZF(x) 

   {

      if EQZF(y) { errno = EDOM; return ZERO; }

      else Result = Pi_Over_Two;

   }

   else 

   {

      /* Will the divide overflow?                 */

      /* Can be slightly conservative since        */

      /* atan(x) is about pi/2 for any x >= 2**big */

      FREXPF(y, &yn);

      FREXPF(x, &xn);



      /* max float is 2#.111..#Emax.  Use Emax-2 for safety */

      if ((yn - xn) > 128 -2) 

         CPYF(Result, Pi_Over_Two);

      else 

      {

         DIVF3(Result,y,x);

         CPYF(Result, ATANF(ABSF(Result)));

         if LSZF(x) RSBF2(Result, Pi);

      }

   }

   if LSZF(y) NEGF1(Result);

   return Result;

} /* ATAN2F */

atanh.c/        1148595153  0     0     0       1725      `
/****************************************************************************/

/*  atanh.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:39 CDT 2000 */

 

#include "reald.h"



  REAL ATANHF(REAL x)

{

   /* Taken from "Handbook of Mathematical Functions                        */

   /* with Formulas, Graphs and Mathematical Tables",                       */

   /* Milton Abramowitz and Irene A. Stegun,                                */

   /* National Bureau of Standards (Applied Mathematics Series 55),         */

   /* Washington D.C., 1964 (reprinted 1970). 4.6.22, page 87.              */



    static  REAL atanh_consts[5] = /* max of 25 mantissa bits */

      {KNST( 1.83766196E-01), 

       KNST( 8.10419885E-02), 

       KNST( 1.47040305E-01), 

       KNST( 1.99744113E-01), 

       KNST( 3.33338978E-01)};



   REAL g, Result, One_Plus_G, One_Minus_G;



   ABSF2(g,x);

   if GTRF(g,HALF) 

   {

      if GEQF(g,ONE)

      {

         errno = (EQLF(g,ONE) ? ERANGE : EDOM);

         if GEQF(x,ONE) return CNST( 3.402823466E+38) ;

         return CNST(-3.402823466E+38) ;

      } else CPYF(g,x);



      /* Apply the identity: atanh(x) = 0.5 * log((1.0 + x) / (1.0 - x)) */

      ADDF3(One_Minus_G, SUBF(HALF,g), HALF);

      ADDF3(One_Plus_G , ADDF(HALF,g), HALF);

      return MPYF(HALF,LOGF(DIVF(One_Plus_G,One_Minus_G)));

   }



   SQRF2(g,x);



   POLYF(Result,g,atanh_consts,5 );



   return ADDF(x,MPYF(x,Result));



} /* ATANHF */


atof.c/         1148595153  0     0     0       472       `
/****************************************************************************/

/*  atof v3.3.2                                                             */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#ifndef _STDLIB

#undef _INLINE

#endif



#include <stdlib.h>



_CODE_ACCESS double atof(const char *st)

{

    return strtod(st, (char **)0);

}

atoi.c/         1148595153  0     0     0       787       `
/****************************************************************************/

/*  atoi v3.3.2                                                             */

/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <stdlib.h>

#include <ctype.h>



_CODE_ACCESS int atoi(const char *st)

{

    int  result = 0;

    char cp;

    int  sign;



    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */



    if (sign = ((cp = *st) == '-')) cp = *++st;

    else if (cp == '+')             cp = *++st;



    while (_isdigit(cp))

    {

        result *= 10;

        result += cp - '0';

        cp = *++st;

    }



    if (sign) result *= -1;

    return result;

}




atol.c/         1148595153  0     0     0       788       `
/****************************************************************************/

/*  atol v3.3.2                                                             */

/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <stdlib.h>

#include <ctype.h>



_CODE_ACCESS long atol(const char *st)

{

    long result = 0;

    char cp;

    int  sign;



    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */



    if (sign = ((cp = *st) == '-')) cp = *++st;

    else if (cp == '+')             cp = *++st;



    while (_isdigit(cp))

    {

        result *= 10;

        result += cp - '0';

        cp = *++st;

    }



    if (sign) result *= -1;

    return result;

}



atoll.c/        1148595153  0     0     0       799       `
/****************************************************************************/

/*  atoll v3.3.2                                                            */

/*  Copyright (c) 2002-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <stdlib.h>

#include <ctype.h>



_CODE_ACCESS long long atoll(const char *st)

{

    long long result = 0;

    char cp;

    int  sign;



    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */



    if (sign = ((cp = *st) == '-')) cp = *++st;

    else if (cp == '+')             cp = *++st;



    while (_isdigit(cp))

    {

        result *= 10;

        result += cp - '0';

        cp = *++st;

    }



    if (sign) result *= -1;

    return result;

}




autoinit.asm/   1148595153  0     0     0       7236      `
;/****************************************************************************/

;/* AUTO_INIT()   v3.3.2 - Perform initialization of C variables.            */

;/* Copyright (c) 1996-2006  Texas Instruments Incorporated                  */

;/****************************************************************************/



	.include "c55xasm.i"

	.model  call=internal

	.mmregs

	.cpl_on

	.arms_on



; Symbols defined by the Linker

	.ref	cinit

	.ref	___bss__

	.ref	___pinit__



; Symbols defined here

	.def _auto_init



  .if .PHASE3

	.noremark 5572    ; safe with respect to Silicon Exception CPU_42

	.noremark 5573    ; safe with respect to Silicon Exception CPU_43

  .endif



;****************************************************************************/

; C VARIABLE INITIALIZATION TABLE FORMAT                                    */

;                                                                           */

;      .field <reserved>,                      2                            */

;      .field <length of init data in words>, 14                            */

;      .field <address of variable>,          24                            */

;      .field <address space indicator>,       8                            */

;      .word  <init data>                                                   */

;      .word  ...                                                           */

;                                                                           */

; The table is terminated with a record with data length zero.              */

;                                                                           */

; The first two bits of the word containing the data length are reserved,   */

; and must be 00. If you create your own cinit records and use other than   */

; your code may be incompatible with a future compiler.                     */

;                                                                           */

;****************************************************************************/





;*****************************************************************************

; auto_init() - C/C++ auto-initialization. Uses .cinit sections to 

;               initialize variables. Uses .pinit sections to call

;               static initialization functions

;*****************************************************************************

_auto_init:	.asmfunc



;----------------------------------------------------------------------

; Align stack pointer

;----------------------------------------------------------------------

  .if !__TMS320C55X_PLUS_BYTE__

	SP = SP - #1

  .endif



;----------------------------------------------------------------------

; Load address register with 23-bit address of cinit table

;----------------------------------------------------------------------

  .if .PHASE3 | __TMS320C55X_PLUS__

	XAR0  = #cinit

  .else

	MDP05 = #((cinit >> 16) & 0x7f)

	AR0   = #(cinit & 0xffff)

  .endif



;----------------------------------------------------------------------

;  If table pointer is -1 then exit

;----------------------------------------------------------------------

	AR7 = ~AR0

	if (AR7 == #0) goto PINIT



;----------------------------------------------------------------------

; Copy data from .cinit section to .bss section

;   AR2 = data length of current record (0 => finished)

;   AC0 = 23-bit variable address in .bss section

;   AC1 = Address space indicator (0 => DATA, 1 => IO)

;----------------------------------------------------------------------

LOOP:

        AR2 = *AR0+

        if (AR2 == #0) goto PINIT



        AC0 = uns(*AR0+) << #8

||	AR2 = AR2 - #1

	AC1 = uns(*AR0+)

||	CSR = AR2

	AC0 = AC0 | (AC1 <<< #-8)

	AC1 = AC1 & #0xff	



;----------------------------------------------------------------------

; Load extended address register with 23-bit address of variable

;----------------------------------------------------------------------

  .if .PHASE3 | __TMS320C55X_PLUS__

	XAR6  = AC0

  .else

	MDP67 = @AC0_H || mmap()

	AR6   = AC0

  .endif	



;----------------------------------------------------------------------

; Do the appropriate copy operation

;----------------------------------------------------------------------

	if (AC1 != #0) goto PORTMEMCOPY



DATAMEMCOPY:

  .if __TMS320C55X_PLUS_BYTE__

	repeat(CSR)

	    byte(*AR6+) = byte(*AR0+)

	AR0 = AR0 + #1       ;; do as mar(AR0+#1) || bit(AR0,@0)=#0

	bit(AR0, @0) = #0    ;; when asm and sim can handle it

  .else

	repeat(CSR)

	    *AR6+ = *AR0+

  .endif

	goto LOOP



PORTMEMCOPY:

  .if __TMS320C55X_PLUS_BYTE__

	AR2 = AR2 >> #1

	CSR = AR2

  .endif

	repeat(CSR)

            *AR6+ = *AR0+ || writeport()

	goto LOOP





PINIT:		

;----------------------------------------------------------------------

; Call initialization routines found in pinit table

;----------------------------------------------------------------------



;----------------------------------------------------------------------

; Reset address extension value

;----------------------------------------------------------------------

  .if (.PHASE3 | __TMS320C55X_PLUS__) & ! __LARGE_MODEL__ & ! __HUGE_MODEL__

	XAR0 = #___bss__

  .elseif ! __TMS320C55X_PLUS__

	MDP05 = #0

  .endif



;----------------------------------------------------------------------

; Load extended address register with 23-bit address of pinit table

;----------------------------------------------------------------------

  .if .PHASE3 | __TMS320C55X_PLUS__

	XAR6  = #___pinit__

  .else

	MDP67 = #(((___pinit__) >> 16) & 0x7f)

	AR6   = #((___pinit__) & 0xffff)

  .endif	



;----------------------------------------------------------------------

;  If table pointer is -1 then exit

;----------------------------------------------------------------------

	AR7 = ~AR6

	if (AR7 == #0) goto EXIT

		

LOOP2:	

;----------------------------------------------------------------------

; AC0 = address of initialization routine to call (0 => finished)

;----------------------------------------------------------------------

        AC0 = dbl(*AR6+)

        if (AC0 == #0) goto EXIT



;----------------------------------------------------------------------

; Call Initialization Function. Save/restore address extension values

; around the call to compiled code.   

;----------------------------------------------------------------------

	*SP(#0) = AR6



  .if (.PHASE3 | __TMS320C55X_PLUS__) & ! __LARGE_MODEL__ & ! __HUGE_MODEL__

	XAR6 = #___bss__

  .elseif ! __TMS320C55X_PLUS__

	MDP67 = #0

  .endif



        call AC0



  .if .PHASE3 | __TMS320C55X_PLUS__

	XAR6  = #___pinit__

  .else

	MDP67 = #(((___pinit__) >> 16) & 0x7f)

  .endif



	AR6 = *SP(#0)

	goto LOOP2	



EXIT:

;----------------------------------------------------------------------

; Reset address extension value

;----------------------------------------------------------------------

  .if (.PHASE3 | __TMS320C55X_PLUS__) & ! __LARGE_MODEL__ & ! __HUGE_MODEL__

	XAR6 = #___bss__

  .elseif ! __TMS320C55X_PLUS__

	MDP67 = #0

  .endif



  .if !__TMS320C55X_PLUS_BYTE__

	SP = SP + #1

  .endif

        return

	.endasmfunc



	.end

basics.h/       1148595153  0     0     0       3220      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Declarations for all runtime routines.



*/



#ifndef BASICS_H

#define BASICS_H 1



/*

Include the header file that supplies the default configuration

parameters for this version.

*/

#include "defines.h"

/*

EXTERN is defined usually as "extern"; in the translation unit that

actually defines storage for external variables, it is defined as an

empty string.  EXTERN is used on the declarations of external variables

in .h files.  This scheme makes it easy to define them in only one

place while using the same source in all places.  Likewise, 

VAR_INITIALIZERS is defined to cause inclusion of initializers for those

variables.

*/

#ifndef EXTERN

#define EXTERN extern

#endif /* ifndef EXTERN */

#ifndef VAR_INITIALIZERS

#define VAR_INITIALIZERS 0

#endif /* ifndef VAR_INITIALIZERS */



/* Macro used to provide an initial value for variables declared EXTERN. */

#if VAR_INITIALIZERS

#define initial_value(value) = value

#else /* VAR_INITIALIZERS */

#define initial_value(value) /* nothing */

#endif /* VAR_INITIALIZERS */



#ifndef CHECKING

/* Include consistency-checking code. */

#define CHECKING 1

#endif /* ifndef CHECKING */



/*

EXTERN_C is used to declare an external function with C linkage.  When

compiling with a C compiler this is just set to ``extern'', but when

compiling with a C++ compiler it is set to ``extern "C"''.

*/

#ifdef __cplusplus

#define EXTERN_C extern "C"

#else /* !defined(__cplusplus) */

#define EXTERN_C extern

#endif /* __cplusplus */



/*

Definition of a generic byte.  Always "unsigned char".

*/

typedef unsigned char a_byte;



/* Simple boolean type: */

typedef int	a_boolean;

typedef a_byte	a_byte_boolean;

#define FALSE 0

#define TRUE 1



#endif /* BASICS_H */





/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

boot.asm/       1148595153  0     0     0       7471      `
;*****************************************************************************

;* BOOT.ASM   v3.3.2 - Initialize the TMS320C55x C/C++ runtime environment

;* Copyright (c) 1993-2006  Texas Instruments Incorporated           

;*

;* The user can and often will create a system-specific initialization

;* routine, but must perform the various functions of this routine in order

;* for C/C++ code in the system to operate correctly.

;*****************************************************************************



	.include "c55xasm.i"

	.model  call=internal

	.mmregs



; Symbols from C/C++ Runtime

	.ref	__args_main

	.ref	_exit

	.ref	_auto_init



; Symbols defined by the Linker

	.ref	cinit

	.ref	___bss__

	.ref	__STACK_SIZE    ; can be set with -stack linker option

	.ref	__SYSSTACK_SIZE ; can be set with -systack linker option



; Symbols defined here (and have special meaning to the linker)

	.def	_c_int00

	.def	__stack

	.def	__sysstack



; Force inclusion of the reset vector

	.ref	_Reset



  .if .PHASE3

	.noremark 5572    ; safe with respect to Silicon Exception CPU_42

	.noremark 5573    ; safe with respect to Silicon Exception CPU_43

  .endif



  .if __TMS320C55X_PLUS_BYTE__

	.asg "ST1_55", ST1_L

	.asg "ST2",    ST2_L

  .endif





;************************************************************************

; Data Stack (size set by the Linker, not blocked, longword aligned)

;************************************************************************

__stack:    .usect  .stack, 0, 0, 1





;************************************************************************

; System Stack (size set by the Linker, not blocked, longword aligned)

;************************************************************************

__sysstack: .usect  .sysstack, 0, 0, 1





;************************************************************************

; c_int00() - C/C++ Environment Entry Point

;************************************************************************

_c_int00:	.asmfunc

   .if .PHASE2

	SP = SP + #0   ; avoid ECNs 372 and 438

   .endif



;------------------------------------------------------------------------

; Initialize the Stack Pointer

;   Note: SP must be aligned on doubleword boundary

;------------------------------------------------------------------------

  .if .PHASE3 | __TMS320C55X_PLUS_WORD__

	XSP = #((__stack + (__STACK_SIZE >> 1)) & 0x7FFFFE)

  .elseif __TMS320C55X_PLUS_BYTE__

	XSP = #((__stack + (__STACK_SIZE)) & 0xFFFFFC)

  .else

	SP  = #((__stack + (__STACK_SIZE >> 1)) & 0xFFFE)

  .endif



;------------------------------------------------------------------------

; Initialize the System Stack Pointer

;------------------------------------------------------------------------

  .if .PHASE3 | __TMS320C55X_PLUS_WORD__

	XSSP = #((__sysstack + (__SYSSTACK_SIZE >> 1)) & 0x7FFFFE)

  .elseif __TMS320C55X_PLUS_BYTE__

   	XSSP = #((__sysstack + (__SYSSTACK_SIZE)) & 0xFFFFFC)

  .else

 	SSP = #((__sysstack + (__SYSSTACK_SIZE >> 1)) & 0xFFFF)

  .endif



;------------------------------------------------------------------------

; Initialize the Status Registers

;

; Set the value of each status bit that compiled C/C++ code assumes has a

; particular value.  Other bits are not touched.

;------------------------------------------------------------------------

  .if .PHASE3 | __TMS320C55X_PLUS__



  ; Status Register ST1

  ;    BRAF  == don't care

  ;    CPL   == 1  Compiler mode on: direct addr via SP

  ;    XF    == don't care

  ;    HM    == don't care

  ;    INTM  == don't care

  ;    M40   == 0  32-bit mode (40-bit off)

  ;    SATD  == 0  D-unit saturation off

  ;    SXMD  == 1  Sign-extension on

  ;    C16   == 0  Disallow dual arithmetic in C54X mode

  ;    FRCT  == 0  Fractional mode off

  ;    C54CM == 0  C54X compatibility off

  ;    ASM   == don't care



ST1_ON  .equ (1<<ST1_CPL)|(1<<ST1_SXMD)

ST1_OFF .equ (1<<ST1_M40)|(1<<ST1_SATD)|(1<<ST1_C16)|(1<<ST1_FRCT)|(1<<ST1_C54CM)



  ; Status Register ST2

  ;    ARMS   == 1  AR Mode: allow short index modes

  ;    DBGM   == don't care

  ;    EALLOW == don't care

  ;    RDM    == 0  Round toward infinity

  ;    CDPLC  == 0  CDP linear (not circular) addressing

  ;    AR0LC  == 0  AR0 linear (not circular) addressing

  ;     ...

  ;    AR7LC  == 0  AR7 linear (not circular) addressing



ST2_03LC .equ (1<<ST2_AR0LC) | (1<<ST2_AR1LC) | (1<<ST2_AR2LC) | (1<<ST2_AR3LC)

ST2_47LC .equ (1<<ST2_AR4LC) | (1<<ST2_AR5LC) | (1<<ST2_AR6LC) | (1<<ST2_AR7LC)



ST2_ON   .equ (1<<ST2_ARMS)

ST2_OFF  .equ (1<<ST2_RDM) | (1<<ST2_CDPLC) | ST2_03LC | ST2_47LC



  ; Status Register ST3

  ;    SATA   == 0  A-unit saturation off

  ;    SMUL   == 1  Saturation on multiply off

  ;    others == don't care



  ; Change the bits

	@ST1_L = @ST1_L & #(~ST1_OFF) || mmap()

	@ST1_L = @ST1_L | #( ST1_ON ) || mmap()



  ; ATTENTION! If the runtime initialization sequence is modified by the user

  ; to execute with interrupts enabled at this point then the following

  ; two instructions are vulnerable to Silicon Exception CPU_75 and

  ; must be re-written.  

	.noremark 5601

	@ST2_L = @ST2_L & #(~ST2_OFF) || mmap()

	@ST2_L = @ST2_L | #( ST2_ON ) || mmap()

	.remark   5601



	bit(ST3, #ST3_SATA) = #0

	bit(ST3, #ST3_SMUL) = #1



	.C54CM_off

	.CPL_on

	.ARMS_on



  .else



  ; Same settings as above except some bits are in different locations

  ; and some have different names (SMUL => GSM, C54CM => LEAD)



ST1_ON  .equ (1<<ST1_ARMS)|(1<<ST1_CPL)|(1<<ST1_SXMD)|(1<<ST1_GSM)

ST1_OFF .equ (1<<ST1_LEAD)|(1<<ST1_SATA)|(1<<ST1_RDM)|(1<<ST1_FRCT)|(1<<ST1_M40)|(1<<ST1_SATD)



ST2_03LC .equ (1<<ST2_AR0LC) | (1<<ST2_AR1LC) | (1<<ST2_AR2LC) | (1<<ST2_AR3LC)

ST2_47LC .equ (1<<ST2_AR4LC) | (1<<ST2_AR5LC) | (1<<ST2_AR6LC) | (1<<ST2_AR7LC)



ST2_OFF  .equ (1<<ST2_CDPLC) | ST2_03LC | ST2_47LC



	@ST1_L = @ST1_L & #(~ST1_OFF) || mmap()

	@ST1_L = @ST1_L | #( ST1_ON ) || mmap()

	@ST2_L = @ST2_L & #(~ST2_OFF) || mmap()



	.LEAD_off

	.CPL_on

	.ARMS_on



   	bit (ST3, #1) = #0

$1:	TC1 = bit(@ST3_L, #1) || mmap()

	nop_16

	if (TC1) goto $1

	nop_16

	nop_16



	bit (ST3, #0) = #0

$2:	TC1 = bit(@ST3_L, #0) || mmap()

	nop_16

	if (TC1) goto $2

	nop_16

	nop_16

  .endif



;------------------------------------------------------------------------

; Initialize Extended Address Registers

;------------------------------------------------------------------------

  .if (.PHASE3 | __TMS320C55X_PLUS__) & ! __LARGE_MODEL__ & ! __HUGE_MODEL__

	XAR0 = #___bss__

	XAR1 = XAR0

	XAR2 = XAR0

	XAR3 = XAR0

	XAR4 = XAR0

	XAR5 = XAR0

	XAR6 = XAR0

	XAR7 = XAR0

	XCDP = XAR0

	XDP  = XAR0

  .elseif ! __TMS320C55X_PLUS__

	MDP   = #0

	MDP05 = #0

	MDP67 = #0

  .endif



;------------------------------------------------------------------------

; Perform autoinitialization.  Must be after other initialization since

; C++ static initializers may be called.

;------------------------------------------------------------------------

	call _auto_init



;------------------------------------------------------------------------

; Call the user's program

;------------------------------------------------------------------------

   	call __args_main



;------------------------------------------------------------------------

; Call exit

;------------------------------------------------------------------------

	AR1 = #1

	call _exit

	.endasmfunc



	.end


bsearch.c/      1148595153  0     0     0       1250      `
/****************************************************************************/

/*  bsearch v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdlib.h>



_CODE_ACCESS void *bsearch(

	      register const void *key,     /* ITEM TO SEARCH FOR           */

              register const void *base,    /* POINTER TO ARRAY OF ELEMENTS */

              size_t nmemb,                 /* NUMBER OF ELEMENTS TO SORT   */

              size_t size,                  /* SIZE IN BYTES OF EACH ITEM   */

              int (*compar)(const void *,const void *)) /* COMPARE FUNCTION */



{

   register int i       = 0;             /* left scan index  */

   register int j       = nmemb - 1;     /* right scan index */



   while( i <= j )

   {

      register int pivot = (j + i) / 2;            

      int result = (*compar) (key, (char *)base + (pivot * size));

      if (result == 0) return((char *)base + (pivot * size));

      if (result < 0) j = pivot - 1;

		 else i = pivot + 1;

   }



   return ((void *)0);   /* IF WE GET TO HERE, WE FAILED */

}





c55x.h/         1148595153  0     0     0       5849      `
/*****************************************************************************/

/*  C55X.H v3.3.2                                                            */

/*  Copyright (c) 2000-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



#ifndef _C55X

#define _C55X



#ifdef __cplusplus

extern "C"

{

#endif /* __cplusplus */



int        _sadd    (int, int);

int        _a_sadd  (int, int);

long       _lsadd   (long, long);

long       _a_lsadd (long, long);

long long  _llsadd  (long long, long long);

long long  _a_llsadd(long long, long long);



int        _ssub   (int, int);

long       _lssub  (long, long);

long long  _llssub (long long, long long);



int        _sneg   (int);

long       _lsneg  (long);

long long  _llsneg (long long);



int        _abss   (int);

long       _labss  (long);

long long  _llabss (long long);



int        _smpy     (int, int);

long       _lmpy     (int, int);

long       _lmpyu    (unsigned, unsigned);

long       _lmpysu   (int, unsigned);

long       _lsmpy    (int, int);

long       _lsmpyi   (int, int);

long       _lsmpyr   (int, int);

long       _lsmpyu   (unsigned, unsigned);

long       _lsmpyui  (unsigned, unsigned);

long       _lsmpysu  (int, unsigned);

long       _lsmpysui (int, unsigned);

long long  _llmpy    (int, int);

long long  _llsmpy   (int, int);

long long  _llsmpyi  (int, int);

long long  _llsmpyu  (unsigned, unsigned);

long long  _llsmpyui (unsigned, unsigned);

long long  _llsmpysu (int, unsigned);

long long  _llsmpysui(int, unsigned);



long       _smac     (long, int, int);

long       _a_smac   (long, int, int);

long       _smacr    (long, int, int);

long       _a_smacr  (long, int, int);

long       _smaci    (long, int, int);

long       _smacsu   (long, int, unsigned);

long       _smacsui  (long, int, unsigned);

long long  _llsmac   (long long, int, int);

long long  _llsmaci  (long long, int, int);

long long  _llsmacu  (long long, unsigned, unsigned);

long long  _llsmacui (long long, unsigned, unsigned);

long long  _llsmacsu (long long, int, unsigned);

long long  _llsmacsui(long long, int, unsigned);



long       _smas     (long, int, int);

long       _a_smas   (long, int, int);

long       _smasr    (long, int, int);

long       _a_smasr  (long, int, int);

long       _smasi    (long, int, int);

long       _smassu   (long, int, unsigned);

long       _smassui  (long, int, unsigned);

long long  _llsmas   (long long, int, int);

long long  _llsmasi  (long long, int, int);

long long  _llsmasu  (long long, unsigned, unsigned);

long long  _llsmasui (long long, unsigned, unsigned);

long long  _llsmassu (long long, int, unsigned);

long long  _llsmassui(long long, int, unsigned);



int        _shrs   (int, int);

long       _lshrs  (long, int);



int        _shl    (int, int);

long       _lshl   (long, int);

long long  _llshl  (long long, int);



int        _sshl   (int, int);

long       _lsshl  (long, int);

long long  _llsshl (long long, int);



void        _llsshlstore  (long long, int, int*);

void        _llshlstorer  (long long, int, int*);

void        _llsshlstorer (long long, int, int*);

void        _llshlstorern (long long, int, int*);

void        _llsshlstorern(long long, int, int*);



long       _round    (long);

long       _sround   (long);

long       _roundn   (long);

long       _sroundn  (long);

long long  _llround  (long long);

long long  _llsround (long long);

long long  _llroundn (long long);

long long  _llsroundn(long long);



int        _norm   (int);

int        _lnorm  (long);

int        _llnorm (long long);

long       _lsat   (long long);



int        _count  (unsigned long long, unsigned long long);



int        _max    (int, int);

long       _lmax   (long, long);

long long  _llmax  (long long, long long);

int        _min    (int, int);

long       _lmin   (long, long);

long long  _llmin  (long long, long long);



void         _enable_interrupts(void);

unsigned int _disable_interrupts(void);

void         _restore_interrupts(unsigned int);



    /* No C prototypes included for the following due to their */

    /* having "pass-by-reference" parameters.                  */



#ifdef __cplusplus

void       _firs           (int *, int *, int *, int&, long&);

void       _firsn          (int *, int *, int *, int&, long&);

void       _lms            (int *, int *, int&, long&);

void       _llslms         (int *, int *, long long&, long long&);

void       _llslmsi        (int *, int *, long long&, long long&);

void       _abdst          (int *, int *, int&, long&);

void       _sqdst          (int *, int *, int&, long&);

void       _max_diff_dbl   (long, long, long&, long&, unsigned int&);

void       _smax_diff_dbl  (long, long, long&, long&, unsigned int&);

void       _llmax_diff_dbl (long long,  long long,

			    long long&, long long&, unsigned int&);

void       _llsmax_diff_dbl(long long,  long long,

			    long long&, long long&, unsigned int&);

void       _min_diff_dbl   (long, long, long&, long&, unsigned int&);

void       _smin_diff_dbl  (long, long, long&, long&, unsigned int&);

void       _llmin_diff_dbl (long long,  long long,

			    long long&, long long&, unsigned int&);

void       _llsmin_diff_dbl(long long,  long long,

			    long long&, long long&, unsigned int&);

int        _exp_mant       (long, long&);

int        _llexp_mant     (long long, long long&);

void       _llsubc         (int, long long, long long&);

#endif /* __cplusplus */



    /* Deprecated names */



long       _rnd      (long);    /* old name for _sround */

long       _smpyr   (int, int); /* old name for _lsmpyr */



#ifdef __cplusplus

} /* extern "C" */

#endif /* __cplusplus */



#endif /* !_C55X */


c55xasm.i/      1148595153  0     0     0       3172      `
* ========================================================================= *

*                                                                           *

*   TEXAS INSTRUMENTS, INC.                                                 *

*                                                                           *

*   NAME                                                                    *

*       c55xasm.i -- compatibility bridge for pre-3.10 tools                *

*                                                                           *

*   USAGE                                                                   *

*       Just .include at top of your source file.  Alternately, use         *

*       the compiler flag -ahi or -ahc to force inclusion in the            *

*       source-file.                                                        *

*                                                                           *

*   DESCRIPTION                                                             *

*       This file provides a set of directives that are intended to be used *

*       to mark the boundaries of assembly-language functions.  The         *

*       point of the new directives is to allow the tools to provide more   *

*       precise information to the profiler as to which regions of code     *

*       were executed, as well as to give meaningful names to assembly      *

*       functions when debugging.                                           *

*                                                                           *

*   NOTES                                                                   *

*       This file is actually just a compatibility shim, intended to        *

*       provide forward compatibility between tool versions < 3.10          *

*       and tool versions >= 3.10.  The purpose of this file it purely      *

*       compatibility.  Tool versions >= 3.10 are required to gain the      *

*       features provided by these directives.                              *

* ------------------------------------------------------------------------- *

*             Copyright (c) 2004 Texas Instruments, Incorporated.           *

*                            All Rights Reserved.                           *

* ========================================================================= *



* ========================================================================= *

* Create "asmver" with current version of assembler. Value is 0 if assembler

* version predates the predefined symbol.

* ========================================================================= *

           .if $isdefed("__TI_ASSEMBLER_VERSION__")

           .asg    __TI_ASSEMBLER_VERSION__, asmver

           .else

           .asg    0, asmver

           .endif



* ========================================================================= *

* If the assembler version predates the new mnemonics and/or directives

* ========================================================================= *

           .if asmver < 310

           .asg ";", .asmfunc

           .asg ";", .endasmfunc

           .endif



cassert/        1148595153  0     0     0       880       `
/*****************************************************************************/

/* cassert   v3.3.2                                                          */

/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _CASSERT

#define _CASSERT



#include <linkage.h>



#define _CPP_STYLE_HEADER

#include <assert.h>

#undef _CPP_STYLE_HEADER



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif /* #ifndef _CASSERT */

cctype/         1148595153  0     0     0       1461      `
/*****************************************************************************/

/* cctype    v3.3.2                                                          */

/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



/************************************************************************/

/*                                                                      */

/*  CHARACTER TYPING FUNCTIONS AND MACROS                               */

/*                                                                      */

/*  Note that in this implementation, either macros or functions may    */

/*  be used.  Macros are prefixed with an underscore.                   */

/*                                                                      */

/************************************************************************/

#ifndef _CCTYPE

#define _CCTYPE



#define _CPP_STYLE_HEADER

#include <ctype.h>

#undef _CPP_STYLE_HEADER



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif  /* #ifndef _CCTYPE */


ceil.c/         1148595153  0     0     0       740       `
/****************************************************************************/

/*  ceil.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Thu Jul 10 18:28:33 CDT 2003 */

 

#undef _INLINE

#include "reald.h"



 REAL CEILF(REAL x)

{



   if LEZF(x) {

     if GEQF(x,CNST(-32768.0)) return FLTIF(FIXFI(x));

   }

   else if LSSF(x,CNST( 32768.0))

   {

      if EQLF(x,FLTIF(FIXFI(x))) return x;

      

   }



   {

      REAL y;

      return (GTZF(MODFF(x,&y)) ? ADDF(y,ONE) : y);

   }

} /* CEILF */

cerrno/         1148595153  0     0     0       830       `
/*****************************************************************************/

/*  CERRNO  v3.3.2                                                           */

/*  Copyright (c) 1999-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



#ifndef _CERRNO

#define _CERRNO



#define _CPP_STYLE_HEADER

#include <errno.h>

#undef _CPP_STYLE_HEADER



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif

cfloat/         1148595153  0     0     0       392       `
/*****************************************************************************/

/* cfloat    v3.3.2                                                          */

/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _CFLOAT

#define _CFLOAT



#include <float.h>



#endif

ciso646/        1148595153  0     0     0       567       `
/*****************************************************************************/

/* CISO646   v3.3.2                                                          */

/* Copyright (c) 2002-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/

/* The identifiers defined in iso646.h are keywords in C++.  That means this */

/* file must be empty.                                                       */

/*****************************************************************************/


clearerr.c/     1148595153  0     0     0       896       `
/*****************************************************************************/

/*  CLEARERR.C v3.3.2                                                        */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/

#include <stdio.h>





/*****************************************************************************/

/* CLEARERR -  Clear the I/O error flag (_STATERR)                           */

/*                                                                           */

/*    This function calls a macro defined in stdio.h                         */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS void clearerr(FILE *_fp) { _clearerr(_fp); }



climits/        1148595153  0     0     0       643       `
/*****************************************************************************/

/* limits.h   v3.3.2                                                         */

/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



//----------------------------------------------------------------------------

// <climits> IS RECOMMENDED OVER <limits.h>.  <limits.h> IS PROVIDED FOR 

// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++

//----------------------------------------------------------------------------

#include <limits.h>


clock.c/        1148595153  0     0     0       1093      `
/****************************************************************************/

/*  clock v3.3.2                                                            */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



/****************************************************************************/

/* OBVIOUSLY, THIS IS SIMPLY A STUB, WHICH BY DEFINITION RETURNS -1         */

/* IF THE SYSTEM TIME IS UNAVAILABLE.                                       */ 

/*--------------------------------------------------------------------------*/

/* OBVIOUSLY, THIS IS NO LONGER A STUB.  THIS WILL RETURN THE CLK REGISTER  */

/* FROM THE EMULATOR OR SIMULATOR.  THIS IS A CYCLE ACURATE COUNT OF THE    */ 

/* NUMBER OF CYCLES THAT HAVE ELAPSED SINCE THE START OF THE PROGRAM.       */ 

/****************************************************************************/

#include <time.h> 

extern clock_t HOSTclock();



_CODE_ACCESS clock_t clock(void)   

{

    return (clock_t)HOSTclock();

}


cmath/          1148595153  0     0     0       4693      `
/****************************************************************************/

/*  cmath  v3.3.2                                                           */

/*  Copyright (c) 1999-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#ifndef __cmath__

#define __cmath__



#include <linkage.h>



#ifndef EDOM

#define EDOM   1

#endif



#ifndef ERANGE

#define ERANGE 2

#endif



#include <float.h>

#define HUGE_VAL DBL_MAX



#include <access.h>



#ifndef __EXTERN

#define __EXTERN

#endif



extern "C" namespace std

{

   __EXTERN double sqrt (double x);

   __EXTERN double exp  (double x);

   __EXTERN double log  (double x);

   __EXTERN double log10(double x);

   __EXTERN double pow  (double x, double y);

   __EXTERN double sin  (double x);

   __EXTERN double cos  (double x);

   __EXTERN double tan  (double x);

   __EXTERN double asin (double x);

   __EXTERN double acos (double x);

   __EXTERN double atan (double x);

   __EXTERN double atan2(double y, double x);

   __EXTERN double sinh (double x);

   __EXTERN double cosh (double x);

   __EXTERN double tanh (double x);



   __INLINE double ceil (double x);

   __INLINE double floor(double x);



   __EXTERN double fabs (double x);



   __EXTERN double ldexp(double x, int n);

   __EXTERN double frexp(double x, int *exp);

   __EXTERN double modf (double x, double *ip);

   __EXTERN double fmod (double x, double y);



   /* An inline version of fmod that works for limited domain only */

   /* See comments in implementation below */

   static inline double _FMOD(double x, double y);



   /* these present in many linked images, so we'll tell you about them. */

   __EXTERN double _nround(double x); /* round-to-nearest */

   __EXTERN double _trunc(double x); /* truncate towards 0 */

}



/* the ANSI-optional *f and *l routines */

#include <cmathf>

#include <cmathl>



#include <access.h>



#ifdef _TI_ENHANCED_MATH_H

#if 0

   /* ------------------------------------------------- */

   /* Routines below are an addition to ANSI math.h     */

   /* Some (noted with "9x" in comment) will become ANSI*/

   /* once C9x is approved.                             */

   /* ------------------------------------------------- */

#endif



extern "C" namespace std

{

   __EXTERN double rsqrt(double x); /*   == 1/sqrt(x) but *MUCH* faster      */

   __EXTERN double exp2 (double x); /*9x mathematically equiv to pow(2.0 ,x) */

   __EXTERN double exp10(double x); /*   mathematically equiv to pow(10.0,x) */

   __EXTERN double log2 (double x); /*9x mathematically equiv to log(x)/log(2.0)*/



   __EXTERN double powi(double x, int i); /* equiv to pow(x,(double)i) */



   __EXTERN double cot  (double x);

   __EXTERN double acot (double x);

   __EXTERN double acot2(double x, double y);



   __EXTERN double coth (double x);



   __EXTERN double asinh(double x); /* 9x */

   __EXTERN double acosh(double x); /* 9x */

   __EXTERN double atanh(double x); /* 9x */

   __EXTERN double acoth(double x);



#define round(x) _nround(x) /* 9x round-to-nearest   */

#define trunc(x) _trunc(x) /* 9x truncate towards 0 */



} /* namespace */



#endif  /* _TI_ENHANCED_MATH_H */





#ifdef _INLINE

/****************************************************************************/

/*  Inline versions of floor, ceil, fmod                                    */

/****************************************************************************/



static __inline double std::floor(double x) 

{

   double y; 

   return (std::modf(x, &y) < 0 ? y - 1 : y);

}



static __inline double std::ceil(double x)

{

   double y; 

   return (std::modf(x, &y) > 0 ? y + 1 : y);

}



/* 

   The implementation below does not work correctly for all cases.

   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).

   The correct result is one of 0,1, or 2.

   But the implementation below will *always* return 0 

   because the quotient is only an approximation.

*/

static __inline double _FMOD(double x, double y)

{

   double d = std::fabs(x); 

   if (d - std::fabs(y) == d) return (0);

   std::modf(x/y, &d);  

   return (x - d * y);

}



#endif



#include <unaccess.h>



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif /* __math__ */




cmathf/         1148595153  0     0     0       5210      `
/****************************************************************************/

/*  cmathf  v3.3.2                                                          */

/*  Copyright (c) 1999-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#ifndef __cmathf__

#define __cmathf__



#ifndef EDOM

   #define EDOM   1

#endif



#ifndef ERANGE

   #define ERANGE 2

#endif



#include <float.h>



#if (FLT_DIG == DBL_DIG) /* float is not different than double */



#include <cmath>



#define sqrtf    sqrt

#define expf     exp

#define logf     log

#define log10f   log10

#define powf     pow

#define sinf     sin

#define cosf     cos

#define tanf     tan

#define asinf    asin

#define acosf    acos

#define atanf    atan

#define atan2f   atan2

#define sinhf    sinh

#define coshf    cosh

#define tanhf    tanh



#define ceilf    ceil

#define floorf   floor



#define fabsf    fabs



#define ldexpf   ldexp

#define frexpf   frexp

#define modff    modf

#define fmodf    fmod



#ifdef _TI_ENHANCED_MATH_H



#define HUGE_VALF FLT_MAX



#define rsqrtf   rsqrt

#define exp2f    exp2

#define exp10f   exp10

#define log2f    log2

#define powif    powi

#define cotf     cot

#define acotf    acot

#define acot2f   acot2

#define cothf    coth

#define asinhf   asinh

#define acoshf   acosh

#define atanhf   atanh

#define acothf   acoth

#define truncf   _trunc

#define roundf   _nround



#endif



#else /* float is different than double */



#include <access.h>



extern "C" namespace std

{

   __EXTERN float sqrtf (float x);

   __EXTERN float expf  (float x);

   __EXTERN float logf  (float x);

   __EXTERN float log10f(float x);

   __EXTERN float powf  (float x, float y);

   __EXTERN float sinf  (float x);

   __EXTERN float cosf  (float x);

   __EXTERN float tanf  (float x);

   __EXTERN float asinf (float x);

   __EXTERN float acosf (float x);

   __EXTERN float atanf (float x);

   __EXTERN float atan2f(float y, float x);

   __EXTERN float sinhf (float x);

   __EXTERN float coshf (float x);

   __EXTERN float tanhf (float x);



   __INLINE float ceilf (float x);

   __INLINE float floorf(float x);



   __EXTERN float fabsf (float x);



   __EXTERN float ldexpf(float x, int n);

   __EXTERN float frexpf(float x, int *exp);

   __EXTERN float modff (float x, float *ip);

   __EXTERN float fmodf (float x, float y);



   /* An inline version of fmodf that works for limited domain only */

   /* See comments in implementation below */

   static inline float _FMODF(float x, float y);



   /* these present in many linked images, so we'll tell you about them. */

   __EXTERN float _roundf(float x); /* round-to-nearest */

   __EXTERN float _truncf(float x); /* truncate towards 0 */

}



#ifdef _TI_ENHANCED_MATH_H

#if 0

   /* ------------------------------------------------- */

   /* Routines below are an addition to ANSI math.h     */

   /* Some (noted with "9x" in comment) will become ANSI*/

   /* once C9x is approved.                             */

   /* ------------------------------------------------- */

#endif



#define HUGE_VALF FLT_MAX /* 9x */



extern "C" namespace std

{

   __EXTERN float rsqrtf(float x); /*   == 1/sqrtf(x) but *MUCH* faster      */

   __EXTERN float exp2f (float x); /*9x mathematically equiv to powf(2.0 ,x) */

   __EXTERN float exp10f(float x); /*   mathematically equiv to powf(10.0,x) */

   __EXTERN float log2f (float x); /*9x mathematically equiv to logf(x)/logf(2.)*/



   __EXTERN float powif (float x, int i); /* equiv to powf(x,(float)i) */



   __EXTERN float cotf  (float x);

   __EXTERN float acotf (float x);

   __EXTERN float acot2f(float x, float y);



   __EXTERN float cothf (float x);



   __EXTERN float asinhf(float x); /* 9x */

   __EXTERN float acoshf(float x); /* 9x */

   __EXTERN float atanhf(float x); /* 9x */

   __EXTERN float acothf(float x);



#define roundf(x) _roundf(x) /* 9x round-to-nearest   */

#define truncf(x) _truncf(x) /* 9x truncate towards 0 */



} /* namespace */



#endif







#ifdef _INLINE

/****************************************************************************/

/*  Inline versions of floorf, ceilf, fmodf                                 */

/****************************************************************************/



static inline float std::floorf(float x) 

{

   float y; 

   return (std::modff(x, &y) < 0 ? y - 1 : y);

}



static inline float std::ceilf(float x)

{

   float y; 

   return (std::modff(x, &y) > 0 ? y + 1 : y);

}



/* 

   The implementation below does not work correctly for all cases.

   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).

   The correct result is one of 0,1, or 2.

   But the implementation below will *always* return 0 

   because the quotient is only an approximation.

*/

static inline float _FMODF(float x, float y)

{

   float d = std::fabsf(x); 

   if (d - std::fabsf(y) == d) return (0);

   std::modff(x/y, &d);  

   return (x - d * y);

}



#endif



#include <unaccess.h>



#endif /* float is/isnot different than double */



#endif /* __cmathf__ */

cmathl/         1148595153  0     0     0       5611      `
/****************************************************************************/

/*  cmathl  v3.3.2                                                          */

/*  Copyright (c) 1999-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



/* This source automatically generated on Fri Feb 12 13:24:25 EST 1999 */



#ifndef __cmathl__

#define __cmathl__



#ifndef EDOM

   #define EDOM   1

#endif



#ifndef ERANGE

   #define ERANGE 2

#endif



#include <float.h>



#if (LDBL_DIG == DBL_DIG) /* long double is not different than double */



#include <cmath>



#define sqrtl    sqrt

#define expl     exp

#define logl     log

#define log10l   log10

#define powl     pow

#define sinl     sin

#define cosl     cos

#define tanl     tan

#define asinl    asin

#define acosl    acos

#define atanl    atan

#define atan2l   atan2

#define sinhl    sinh

#define coshl    cosh

#define tanhl    tanh



#define ceill    ceil

#define floorl   floor



#define fabsl    fabs



#define ldexpl   ldexp

#define frexpl   frexp

#define modfl    modf

#define fmodl    fmod



#ifdef _TI_ENHANCED_MATH_H



#define HUGE_VALL LDBL_MAX



#define rsqrtl   rsqrt

#define exp2l    exp2

#define exp10l   exp10

#define log2l    log2

#define powil    powi

#define cotl     cot

#define acotl    acot

#define acot2l   acot2

#define cothl    coth

#define asinhl   asinh

#define acoshl   acosh

#define atanhl   atanh

#define acothl   acoth

#define truncl   _trunc

#define roundl   _nround



#endif



#else /* long double is different than double */



#include <access.h>



extern "C" namespace std

{

__EXTERN long double sqrtl (long double x);

__EXTERN long double expl  (long double x);

__EXTERN long double logl  (long double x);

__EXTERN long double log10l(long double x);

__EXTERN long double powl  (long double x, long double y);

__EXTERN long double sinl  (long double x);

__EXTERN long double cosl  (long double x);

__EXTERN long double tanl  (long double x);

__EXTERN long double asinl (long double x);

__EXTERN long double acosl (long double x);

__EXTERN long double atanl (long double x);

__EXTERN long double atan2l(long double y, long double x);

__EXTERN long double sinhl (long double x);

__EXTERN long double coshl (long double x);

__EXTERN long double tanhl (long double x);



__INLINE long double ceill (long double x);

__INLINE long double floorl(long double x);



__EXTERN long double fabsl (long double x);



__EXTERN long double ldexpl(long double x, int n);

__EXTERN long double frexpl(long double x, int *exp);

__EXTERN long double modfl (long double x, long double *ip);

__EXTERN long double fmodl (long double x, long double y);



/* An inline version of fmod that works for limited domain only */

/* See comments in implementation below */

static inline long double _FMODL(long double x, long double y);



__EXTERN long double _roundl(long double x); /* round-to-nearest */

__EXTERN long double _truncl(long double x); /* truncate towards 0 */



}



#ifdef _TI_ENHANCED_MATH_H

#if 0

/* ------------------------------------------------- */

/* Routines below are an addition to ANSI math.h     */

/* Some (noted with "9x" in comment) will become ANSI*/

/* once C9x is approved.                             */

/* ------------------------------------------------- */

#endif



#define HUGE_VALL LDBL_MAX /* ## */



extern "C" namespace std

{

__EXTERN long double rsqrtl(long double x); /*   1/sqrtl(x) but *MUCH* faster*/

__EXTERN long double exp2l (long double x); /*9x math equiv to powl(2.0 ,x)  */

__EXTERN long double exp10l(long double x); /*   math equiv to powl(10.0,x)  */

__EXTERN long double log2l (long double x);/*9x math equiv to logl(x)/logl(2)*/



__EXTERN long double powil (long double x, int i); /* == powl(x,(long double)i)*/



__EXTERN long double cotl  (long double x);

__EXTERN long double acotl (long double x);

__EXTERN long double acot2l(long double x, long double y);



__EXTERN long double cothl (long double x);



__EXTERN long double asinhl(long double x); /* 9x */

__EXTERN long double acoshl(long double x); /* 9x */

__EXTERN long double atanhl(long double x); /* 9x */

__EXTERN long double acothl(long double x);



#define roundl(x) _roundl(x) /* 9x round-to-nearest   */

#define truncl(x) _truncl(x) /* 9x truncate towards 0 */



} /* namespace */



#endif





#ifdef _INLINE

/****************************************************************************/

/*  Inline versions of floorl, ceill, fmodl                                 */

/****************************************************************************/



static inline long double std::floorl(long double x) 

{

   long double y; 

   return (std::modfl(x, &y) < 0 ? y - 1 : y);

}



static inline long double std::ceill(long double x)

{

   long double y; 

   return (std::modfl(x, &y) > 0 ? y + 1 : y);

}



/* 

   The implementation below does not work correctly for all cases.

   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).

   The correct result is one of 0,1, or 2.

   But the implementation below will *always* return 0 

   because the quotient is only an approximation.

*/

static inline long double std::_FMODL(long double x, long double y)

{

   long double d = std::fabsl(x); 

   if (d - std::fabsl(y) == d) return (0);

   std::modfl(x/y, &d);  

   return (x - d * y);

}



#endif



#include <unaccess.h>



#endif /* long double is/isnot different than double */



#endif /* __cmathl__ */


cmpd.c/         1148595153  0     0     0       9792      `
/****************************************************************************/

/*  cmpd.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:26 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



  int CMPF(REAL left, REAL right)

/*---------------------------------------------------------------------------*/

/* IEEE floating compare.                                                    */

/*                                                                           */



/* return <0 if left <  right                                                */

/* return  0 if left == right                                                */

/* return >0 if left >  right                                                */

/*                                                                           */

/* Handles denormalized numbers.                                             */

/* Handles +/- INFINITY.                                                     */

/*                                                                           */



/* Returns |NAN| > |INFINITY|                                                */



/*---------------------------------------------------------------------------*/

{ 

#ifdef IEEE_Hardware 

   return (left < right) ? -1 : ((left == right) ? 0 : 1);

#else 



   long  lft;

   long  rgt;

   REALasINT(lft, left);

   REALasINT(rgt, right);



   if ((lft^rgt) < 0) {                      /* different signs?             */

      if ((lft | rgt) == MINUS) return 0;    /* 0 == 0, ignoring signs       */



      lft |= 1;                              /* make sure lft != 0           */



   } else {                                  /* same signs                   */

      lft -= rgt;

      if (rgt < 0) lft = -lft;               /* deal with sign-magnitude     */

   }

 

   return ((lft < 0) ? (int)-1 : (int)(lft > 0));

 

#endif 

} /* CMPF */





int EQLF(REAL left, REAL right)

/*---------------------------------------------------------------------------*/

/* IEEE equals                                                               */

/* return (left == right)                                                    */

/*                                                                           */

/* Handles denormalized numbers.                                             */

/* Handles +/- INFINITY, NANs.                                               */

/*---------------------------------------------------------------------------*/

{ 

#ifdef IEEE_Hardware 

   return left == right;

#else 



   long  lft;

   long  rgt;

   REALasINT(lft, left);

   REALasINT(rgt,right);



   if ((lft^rgt) < 0)                        /* different signs?             */

      return ((lft | rgt) == MINUS);         /* 0 == 0, ignoring signs       */

   if (lft != rgt) return 0;                 /* not equal if bits not same   */

   return ((lft & ~MINUS) <= REAL_INFNAN);   /* NAN's are never equal.       */



#endif 

} /* EQLF */





int NEQF(REAL left, REAL right)

/*---------------------------------------------------------------------------*/

/* IEEE not equals                                                           */

/* return (left != right)                                                    */

/*                                                                           */

/* Handles denormalized numbers.                                             */

/* Handles +/- INFINITY, NANs.                                               */

/*---------------------------------------------------------------------------*/

{

#ifdef IEEE_Hardware 

   return left != right;

#else 



   long  lft;

   long  rgt;

   REALasINT(lft, left);

   REALasINT(rgt,right);



   if ((lft^rgt) < 0)                          /* different signs?           */

      return ((lft | rgt) != MINUS);           /* 0 == 0, ignoring signs     */

   if (lft != rgt) return 1;                   /* not equal if bits not same */

   return ((lft & ~MINUS) > REAL_INFNAN);      /* NAN's are never equal.     */



#endif 

} /* NEQF */





int LSSF(REAL left, REAL right)

/*---------------------------------------------------------------------------*/

/* IEEE less than                                                            */

/* return (left < right)                                                     */

/*                                                                           */

/* Handles denormalized numbers.                                             */

/* Handles +/- INFINITY, NANs.                                               */

/*---------------------------------------------------------------------------*/

{ 

#ifdef IEEE_Hardware 

   return left < right;

#else 



   long  lft;

   long  rgt;

   REALasINT(lft, left);

   REALasINT(rgt,right);



   if ((lft & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */

   if ((rgt & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */



   if ((lft^rgt) < 0) {                      /* different signs?             */

      if ((lft | rgt) == MINUS) return 0;    /* 0 == 0, ignoring signs       */

   } else {                                  /* same signs                   */

      lft -= rgt;

      if (rgt < 0) lft = -lft;               /* deal with sign-magnitude     */

   }

   return (lft < 0);



#endif 

} /* LSSF */





int GTRF(REAL left, REAL right)

/*---------------------------------------------------------------------------*/

/* IEEE greater than                                                         */

/* return (left > right)                                                     */

/*                                                                           */

/* Handles denormalized numbers.                                             */

/* Handles +/- INFINITY, NANs.                                               */

/*---------------------------------------------------------------------------*/

{ 

#ifdef IEEE_Hardware 

   return left > right;

#else 



   long  lft;

   long  rgt;

   REALasINT(lft, left);

   REALasINT(rgt,right);



   if ((lft & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */

   if ((rgt & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */



   if ((lft^rgt) < 0) {                      /* different signs?             */

      if ((lft | rgt) == MINUS) return 0;    /* 0 == 0, ignoring signs       */

      lft |= 1;                              /* make sure lft != 0           */

   } else {                                  /* same signs                   */

      lft -= rgt;

      if (rgt < 0) lft = -lft;               /* deal with sign-magnitude     */

   }

   return (lft > 0);



#endif 

} /* GTRF */





int LEQF(REAL left, REAL right)

/*---------------------------------------------------------------------------*/

/* IEEE less than or equals                                                  */

/* return (left <= right)                                                    */

/*                                                                           */

/* Handles denormalized numbers.                                             */

/* Handles +/- INFINITY, NANs.                                               */

/*---------------------------------------------------------------------------*/

{

#ifdef IEEE_Hardware 

   return left <= right;

#else 



   long  lft;

   long  rgt;

   REALasINT(lft, left);

   REALasINT(rgt,right);



   if ((lft & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */

   if ((rgt & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */



   if ((lft^rgt) < 0) {                      /* different signs?             */

      if ((lft | rgt) == MINUS) return 1;    /* 0 == 0, ignoring signs       */

      lft |= 1;                              /* make sure lft != 0           */

   } else {                                  /* same signs                   */

      lft -= rgt;

      if (rgt < 0) lft = -lft;               /* deal with sign-magnitude     */

   }

   return (lft <= 0);



#endif 

} /* LEQF */





int GEQF(REAL left, REAL right)

/*---------------------------------------------------------------------------*/

/* IEEE greater than or equal                                                */

/* return (left >= right)                                                    */

/*                                                                           */

/* Handles denormalized numbers.                                             */

/* Handles +/- INFINITY, NANs.                                               */

/*---------------------------------------------------------------------------*/

{ 

#ifdef IEEE_Hardware 

   return left >= right;

#else 



   long  lft;

   long  rgt;

   REALasINT(lft, left);

   REALasINT(rgt,right);



   if ((lft & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */

   if ((rgt & ~MINUS) > REAL_INFNAN) return 0; /*NAN's are unordered */



   if ((lft^rgt) < 0) {                      /* different signs?             */

      if ((lft | rgt) == MINUS) return 1;    /* 0 == 0, ignoring signs       */

   } else {                                  /* same signs                   */

      lft -= rgt;

      if (rgt < 0) lft = -lft;               /* deal with sign-magnitude     */

   }

   return (lft >= 0);



#endif 

} /* GEQF */



config.h/       1148595153  0     0     0       15330     `
/*****************************************************************************/

/* config.h v3.3.2                                                           */

/* Copyright (c) 1996-2006 Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Configuration parameters for the runtime.



*/



#ifndef CONFIG_H

#define CONFIG_H 1



/*

Flag used to retain ABI (Application Binary Interface, i.e., runtime layout

and calling sequence) compatibility with older versions.  The value is the

version number of the EDG C++ front end, e.g., 227 for version 2.27, for

which compatibility should be maintained.  ABI changes made after that

version will be suppressed.  Of course, that may suppress certain language

features that cannot be implemented without the corresponding ABI changes.

The default is 228, which results in the ABI being compatible with earlier

versions of the front end.



Beginning with version 2.29, the front end defines a preprocessing symbol

called __EDG_ABI_COMPATIBILITY_VERSION that defines the ABI level

being used by the front end.  This value is used, if it is defined.

*/

#ifndef ABI_COMPATIBILITY_VERSION

#ifdef __EDG_ABI_COMPATIBILITY_VERSION

#define ABI_COMPATIBILITY_VERSION __EDG_ABI_COMPATIBILITY_VERSION

#else /* ifndef __EDG_ABI_COMPATIBILITY_VERSION */

#define ABI_COMPATIBILITY_VERSION 228

#endif /* ifdef __EDG_ABI_COMPATIBILITY_VERSION */

#endif /* ifndef ABI_COMPATIBILITY_VERSION */



/*

This flag indicates that the runtime system may be called by cfront-generated

code, and consequently that it must behave as expected by the cfront code.

For example, cfront passes eight NULL pointers to constructors called

from vec_new.  The NULL pointers initialize parameters that point to

virtual base classes.  We only do this in cfront compatibility mode.

*/

#ifndef CFRONT_COMPATIBILITY_MODE

#ifdef __EDG_IA64_ABI

#define CFRONT_COMPATIBILITY_MODE FALSE

#else /* !defined(__EDG_IA64_ABI) */

#define CFRONT_COMPATIBILITY_MODE TRUE

#endif /* !defined(__EDG_IA64_ABI) */

#endif /* ifndef CFRONT_COMPATIBILITY_MODE */

#if CFRONT_COMPATIBILITY_MODE && defined(__EDG_IA64_ABI)

 #error -- CFRONT_COMPATIBILITY_MODE TRUE is incompatible with \

           __EDG_IA64_ABI

#endif /* CFRONT_COMPATBILITY_MODE && defined(__EDG_IA64_ABI) */



/*

The runtime uses one of several different mechanisms to invoke static

destructors upon completion of the program.  On Suns, on_exit is used.

For ANSI C environments, atexit is used.  Otherwise a version of

exit is supplied in our runtime library to replace the one normally

found in the C library (e.g., libc.a).  Using our exit may affect

usage that requires an alternate version of the exit function, such

as generating profiling information.



USE_ATEXIT indicates that the atexit function should be used.

*/

#ifndef USE_ATEXIT

#if defined(sun) && __EDG_BSD

#define USE_ATEXIT FALSE

#else /* !(defined(sun) && __EDG_BSD) */

#define USE_ATEXIT TRUE

#endif /* !(defined(sun) && __EDG_BSD) */

#endif /* ifndef USE_ATEXIT */



/*

Should the components of the runtime system that implement

exception handling be included.

*/



#ifdef __EXCEPTIONS 

#define EXCEPTION_HANDLING TRUE

#endif /* ifndef EXCEPTION_HANDLING */



/*

Should the EDG-supplied exception classes be used.  This flag may be

set to FALSE if a third party standard library is being used that includes

classes such as bad_alloc, etc.

*/

#ifndef USE_EDG_EXCEPTION_CLASSES

#define USE_EDG_EXCEPTION_CLASSES TRUE

#endif /* ifndef USE_EDG_EXCEPTION_CLASSES */



/*

Should the out-of-line copy of the placement new routines be defined?

This flag may be set to FALSE if a third party library defines these

routines inline.

*/

#ifndef DEFINE_PLACEMENT_NEW_ROUTINES

#define DEFINE_PLACEMENT_NEW_ROUTINES TRUE

#endif /* ifndef DEFINE_PLACEMENT_NEW_ROUTINES */







/*

Should the components of the runtime system that implement run-time

type identification be included.  Note that enabling ABI_CHANGES_FOR_RTTI

alters the structure of the a_type_info_impl that is shared by

ABI_CHANGES_FOR_RTTI and exception handling, consequently

ABI_CHANGES_FOR_RTTI cannot be enabled when preserving ABI compatibility

with versions up to 2.28.  When the --building_runtime option is specified,

the front end defines __EDG_ABI_CHANGES_FOR_RTTI as 0 or 1 to indicate

how it is configured.

*/

#ifndef ABI_CHANGES_FOR_RTTI

#ifdef __EDG_ABI_CHANGES_FOR_RTTI

#define ABI_CHANGES_FOR_RTTI __EDG_ABI_CHANGES_FOR_RTTI

#else /* !defined(__EDG_ABI_CHANGES_FOR_RTTI) */

#if ABI_COMPATIBILITY_VERSION <= 228

#define ABI_CHANGES_FOR_RTTI FALSE /* Versions up to 2.28. */

#else /* ABI_COMPATIBILITY_VERSION > 228 */

#define ABI_CHANGES_FOR_RTTI TRUE  /* Versions after 2.28. */

#endif /* ABI_COMPATIBILITY_VERSION <= 228 */

#endif /* ifdef __EDG_ABI_CHANGES_FOR_RTTI */

#endif /* ifndef ABI_CHANGES_FOR_RTTI */

#if ABI_CHANGES_FOR_RTTI && (ABI_COMPATIBILITY_VERSION <= 228)

 #error -- ABI_CHANGES_FOR_RTTI TRUE is incompatible with \

           ABI_COMPATIBILITY_VERSION <= 228

#endif /* ABI_CHANGES_FOR_RTTI && (ABI_COMPATIBILITY_VERSION <= 228) */



/*

This switch controls whether or not the ABI changes for array

new and delete are done.  New runtime routines are added.

The changes are upward-compatible (you can use old object code

with new object code and the new library).  If the switch is off,

compatibility with versions up to 2.28 is preserved, but the

array new and delete language features are turned off.

When the --building_runtime option is specified, the front end

defines __EDG_ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE as 0 or 1 to

indicate how it is configured.

*/

#ifndef ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE

#ifdef __EDG_ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE

#define ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE \

				__EDG_ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE

#else /* !defined(__EDG_ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE) */

#if ABI_COMPATIBILITY_VERSION <= 228

#define ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE FALSE /* Versions up to 2.28. */

#else /* ABI_COMPATIBILITY_VERSION > 228 */

#define ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE TRUE  /* Versions after 2.28. */

#endif /* ABI_COMPATIBILITY_VERSION <= 228 */

#endif /* ifdef __EDG_ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */

#endif /* ifndef ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */

#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE && (ABI_COMPATIBILITY_VERSION <= 228)

 #error -- ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE TRUE is incompatible with \

           ABI_COMPATIBILITY_VERSION <= 228

#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE && ... */





/*

This switch controls whether or not the ABI changes for placement

delete are done.  New runtime routines/variables are added.

The changes are upward-compatible (you can use old object code

with new object code and the new library).  If the switch is off,

compatibility with versions up to 2.33 is preserved, but the

placement delete language feature is turned off.  Allocating an

array with placement new and then using the delete operator on it

is also considered part of "placement delete" and is controlled by

this switch.

*/

#ifndef ABI_CHANGES_FOR_PLACEMENT_DELETE

/* If this value is not defined, use the value defined by the front end,

   if one is provided.  Otherwise, assume that the feature is not supported. */

#ifdef __EDG_ABI_CHANGES_FOR_PLACEMENT_DELETE

#define ABI_CHANGES_FOR_PLACEMENT_DELETE __EDG_ABI_CHANGES_FOR_PLACEMENT_DELETE

#else /* ifndef __EDG_ABI_CHANGES_FOR_PLACEMENT_DELETE */

#define ABI_CHANGES_FOR_PLACEMENT_DELETE FALSE

#endif /* ifndef __EDG_ABI_CHANGES_FOR_PLACEMENT_DELETE */

#endif /* ifndef ABI_CHANGES_FOR_PLACEMENT_DELETE */



/*

This switch controls how the runtime keeps track of information about the

size of arrays that have been allocated.  Through version 2.28 this

information was maintained using a separate data structure allocated

by vec_new.  Beginning with 2.29 this information is maintained in

header block that is part of the array memory allocated.  The new

mechanism can be used with older ABI versions.   The only consequences

of this are that the size of the memory blocks requested from operator

new will change because they now include the size of the prefix information,

and the behavior of programs that perform undefined operations (e.g.,

writing to memory that preceded the beginning of the array) may change.

*/

#ifndef USE_PREFIX_FOR_ARRAY_ALLOC_INFO

#if ABI_COMPATIBILITY_VERSION <= 228

#define USE_PREFIX_FOR_ARRAY_ALLOC_INFO FALSE /* Versions up to 2.28. */

#else /* ABI_COMPATIBILITY_VERSION > 228 */

#define USE_PREFIX_FOR_ARRAY_ALLOC_INFO TRUE  /* Versions after 2.28. */

#endif /* ABI_COMPATIBILITY_VERSION <= 228 */

#endif /* ifndef USE_PREFIX_FOR_ARRAY_ALLOC_INFO */

#if !USE_PREFIX_FOR_ARRAY_ALLOC_INFO && defined(__EDG_IA64_ABI)

 #error -- USE_PREFIX_FOR_ARRAY_ALLOC_INFO FALSE is not compatible with \

           __EDG_IA64_ABI

#endif /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO && ... */  



/*

This flag is used with the IA-64 ABI to specify that the underlying system

runtime includes certain of the IA-64 facilities (so this runtime does not

need to provide them).

*/

#ifndef SYSTEM_RUNTIME_HAS_IA64_SUPPORT



#ifdef __EDG_IA64_ABI



#ifdef __linux__

#define SYSTEM_RUNTIME_HAS_IA64_SUPPORT TRUE

#else /* ifndef __linux__ */

#define SYSTEM_RUNTIME_HAS_IA64_SUPPORT FALSE

#endif /* ifdef __linux__ */



#else /* ifndef __EDG_IA64_ABI */

#define SYSTEM_RUNTIME_HAS_IA64_SUPPORT FALSE

#endif /* ifdef __EDG_IA64_ABI */



#endif /* ifndef SYSTEM_RUNTIME_HAS_IA64_SUPPORT */



/*

Some systems have partial IA-64 support in their runtime, but lack the

__cxa_atexit function.  This flag (when TRUE) indicates that the system

runtime includes the __cxa_atexit function.

*/

#ifdef __EDG_IA64_ABI

#ifndef SYSTEM_RUNTIME_HAS_IA64_ATEXIT



#if SYSTEM_RUNTIME_HAS_IA64_SUPPORT

#ifdef __linux__

#define SYSTEM_RUNTIME_HAS_IA64_ATEXIT TRUE

#else /* ifndef __linux__ */

#define SYSTEM_RUNTIME_HAS_IA64_ATEXIT FALSE

#endif /* ifdef __linux__ */

#else /* !SYSTEM_RUNTIME_HAS_IA64_SUPPORT */

/* The system does not have IA-64 support, so it can't have atexit. */

#define SYSTEM_RUNTIME_HAS_IA64_ATEXIT FALSE

#endif /* SYSTEM_RUNTIME_HAS_IA64_SUPPORT */

#endif /* ifndef SYSTEM_RUNTIME_HAS_IA64_ATEXIT */



#else /* ifndef __EDG_IA64_ABI */

#define SYSTEM_RUNTIME_HAS_IA64_ATEXIT FALSE

#endif /* ifdef __EDG_IA64_ABI */



#if EXCEPTION_HANDLING

/*

The EH runtime allocates a static block of memory to be used for purposes

of tracking pending exceptions, making a copy of the thrown object, etc.

Additional space is allocated if needed.  This parameter specifies the

size of the initial block of memory allocated and the minimum size of

any additional blocks that are required.

*/

#ifndef EH_MEMORY_ALLOCATION_INCREMENT

#define EH_MEMORY_ALLOCATION_INCREMENT 128

#endif /* ifndef EH_MEMORY_ALLOCATION_INCREMENT */



/*

A type that, when used, will be aligned with the strictest alignment

requirements.

*/

#ifndef TYPE_WITH_MOST_STRICT_ALIGNMENT

#define TYPE_WITH_MOST_STRICT_ALIGNMENT double

#endif /* ifndef TYPE_WITH_MOST_STRICT_ALIGNMENT */



#if ABI_CHANGES_FOR_RTTI

/*

The mangled name of the unique ID for a void type.

*/

#ifndef MANGLED_NAME_OF_UNIQUE_ID_OF_VOID

#define MANGLED_NAME_OF_UNIQUE_ID_OF_VOID __TID_v

#endif /* ifndef MANGLED_NAME_OF_UNIQUE_ID_OF_VOID */

#else /* ! ABI_CHANGES_FOR_RTTI */

/*

The mangled name of the typeinfo record for a void type.

*/

#ifndef MANGLED_NAME_OF_VOID

#define MANGLED_NAME_OF_VOID __T_v

#endif /* ifndef MANGLED_NAME_OF_VOID */

#endif /* ! ABI_CHANGES_FOR_RTTI */



/*

Flag that is TRUE if the definition of jmp_buf from the setjmp.h header

file should be used instead of the element type and array size passed

by the front end.  This is useful on systems where the setjmp buffer

is a structure instead of an array.

*/

#ifndef USE_SYSTEM_JMP_BUF_DEFINITION

#if defined(__linux__) || defined(__hpux)

#define USE_SYSTEM_JMP_BUF_DEFINITION TRUE

#else /* if !(defined(__linux__) || defined(__hpux)) */

/*** START TI ADD ***/

#define USE_SYSTEM_JMP_BUF_DEFINITION TRUE

/*** END TI ADD ***/

/* #define USE_SYSTEM_JMP_BUF_DEFINITION FALSE */

#endif /* if defined(__linux__) || defined(__hpux) */

#endif /* ifndef USE_SYSTEM_JMP_BUF_DEFINITION */



/*

Flag that is TRUE if the stack should be unwound before terminate()

is called when an exception with no matching handler is thrown.

According to the Working Paper, it is unspecified whether or not the

stack is unwound in this case.

*/

#ifndef UNWIND_STACK_BEFORE_CALLING_TERMINATE

#define UNWIND_STACK_BEFORE_CALLING_TERMINATE TRUE

#endif /* ifndef UNWIND_STACK_BEFORE_CALLING_TERMINATE */



#endif /* EXCEPTION_HANDLING */



/*

Define macros that are used to define exception specifications.  The

macros are used so that the throw specifications can be discarded when

exception handling is not being used.

*/

#if EXCEPTION_HANDLING

#define THROW(throw_spec) throw(throw_spec)

#define THROW_NOTHING() throw()

#else /* !EXCEPTION_HANDLING */

#define THROW(throw_spec) /* Nothing. */

#define THROW_NOTHING() /* Nothing. */

#endif /* EXCEPTION_HANDLING */



/*

The strictest alignment required of any data type.  This should be

the alignment that malloc uses for memory that is allocated.

*/

#ifndef MOST_STRICT_ALIGNMENT

#define MOST_STRICT_ALIGNMENT 8

#endif /* ifndef MOST_STRICT_ALIGNMENT */



/*

Flag that is TRUE if a message containing the reason for a runtime

abort should be displayed.

*/

#ifndef DISPLAY_ABORT_DESCRIPTION

#define DISPLAY_ABORT_DESCRIPTION FALSE

#endif /* ifndef DISPLAY_ABORT_DESCRIPTION */







#endif /* CONFIG_H */





/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/



cos.c/          1148595153  0     0     0       2156      `
/****************************************************************************/

/*  cos.c            v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:41 CDT 2000 */

 

#include "reald.h"



  REAL COSF(REAL x)

{



/* Adapted from "Software Manual for the Elementary Functions" */

/* Cody and Waite, Prentice Hall 1980. pages 127-133           */



    static  REAL R[4] = 

       {KNST( 0.2601903036e-5),

        KNST(-0.1980741872e-3),

        KNST( 0.8333025139e-2),

        KNST(-0.1666665668e+0)};



    int n;

    REAL absx, y, xn, f, g, x1, Result;



    ABSF2(absx, x);

    if EQZF(absx) return ONE;

    if GEQF(absx, Pi) 

    {

       ADDF3(y, absx, Pi_Over_Two);

       MPYF3(xn, y, One_Over_Pi);



       if GEQF(y, CNST( 2147483648.0) )



       {

          REAL ip;

          CPYF(xn, ROUNDF(xn));

          n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */

          CPYF(x1,TRUNCF(absx));

       }

       else 

       { 

          FIXFI2(n, ADDF(xn,HALF)); /* round (xn > 0) */

          FLTIF2(xn, n);

          TNCF2(x1,absx);

       }

       SUBF2(xn, HALF); /* TO FORM COS INSTEAD OF SIN */



       /* f = ((x1 - xn * C1) + (absx - x1)) - xn * C2; */

       SUBF3(f, ADDF(SUBF(x1, 

                          MPYF(xn,CNST(3.140625) )), 

                     SUBF(absx,x1)), 

                MPYF(xn,CNST(9.67653589793e-4) ));



       /* protect against round-off and enhanced precision problems */

       if GTRF(ABSF(f), Pi_Over_Two)

          CPYF(f, (GTZF(f) ? Pi_Over_Two : NEGF(Pi_Over_Two)));



       if (n & 1) NEGF1(f);

    }

    else SUBF3(f,Pi_Over_Two,absx); /*fast code for -Pi..Pi*/



    SQRF2(g, f);



    POLYF(Result, g, R, 4 );



    ADDF3(Result, f, MPYF(f, Result));



    /* deal with round-off errors */

    if GTRF(ABSF(Result), ONE)

       Result = (GTRF(Result,ONE) ? ONE : CNST(-1.0));



    return Result;

} /* COSF */

cosh.c/         1148595153  0     0     0       1016      `
/****************************************************************************/

/*  cosh.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:42 CDT 2000 */

 

#include "reald.h"



  REAL COSHF(REAL x)

{

    

    REAL w, y, z;



    ABSF2(y,x);

    if LEQF(y, CNST( 88.72283382) ) 

    {

       CPYF(z,EXPF(y));

       MPYF3(z, ADDF(z,INVF(z)), HALF);

       if LSSF(z,ONE) CPYF(z,ONE);

       return z;

    }

    SUBF3(w, y, 0.69316101074218750000E+0 );

    if GTRF(w, ADDF(SUBF(CNST( 88.72283382) ,0.69316101074218750000E+0 ),0.69) )

    {

       errno = EDOM;

       if LSZF(x) return CNST(-3.402823466E+38) ;

       return CNST( 3.402823466E+38) ;

    }

    CPYF(z, EXPF(w));

    return ADDF(z, MPYF(0.13830277879601902638E-4 ,z));

} /* COSHF */



cot.c/          1148595153  0     0     0       2305      `
/****************************************************************************/

/*  cot.c            v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:42 CDT 2000 */

 

#include "reald.h"



  REAL COTF(REAL x)

{

/* Adapted from "Software Manual for the Elementary Functions" */

/* Cody and Waite, Prentice Hall 1980. pages 150-163           */



    static  REAL P[1] =

       {KNST(-0.958017723e-1)};



    static  REAL Q[2] =

       {KNST( 0.971685835e-2),

        KNST(-0.429135777e+0)};



    REAL y, xn, f, g, x1, xnum, xden;

    int n;



    ABSF2(y, x);



    MPYF3(xn, x, Two_Over_Pi);



    if GEQF(y, CNST( 2147483648.0) )



    {

       REAL ip;

       CPYF(xn,ROUNDF(xn));

       n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */

       CPYF(x1,TRUNCF(x));

    } 

    else 

    {

       if GEZF(xn) FIXFI2(n, ADDF(xn,HALF));

       else        FIXFI2(n, SUBF(xn,HALF));

       FLTIF2(xn, n);

       TNCF2(x1, x);

    }



    /* f  = ((x1 - xn * C1) + (x - x1)) - xn * C2; */

    SUBF3(f, ADDF(SUBF(x1,MPYF(xn,CNST(1.5703125) )), SUBF(x,x1)), MPYF(xn,CNST(4.83826794897e-4) ));



    /* protect against round-off and enhanced precision problems */

    if GTRF(ABSF(f), Pi_Over_Four)

       f = (GTZF(f) ? Pi_Over_Four : NEGF(Pi_Over_Four));



    SQRF2(g,f);



    /* xnum = ((                P1)*g*f + f); */

    /* xnum = (((       P2)*g + P1)*g*f + f); */

    /* xnum = (((P3*g + P2)*g + P1)*g*f + f); */

    POLYF(xnum, g, P, 1 )

    MPYF2(xnum,f);

    ADDF2(xnum,f);



    /* xden = ((((                Q2)*g + Q1)*g + 0.5) + 0.5); */

    /* xden = (((((       Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */

    /* xden = (((((Q4*g + Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */

    POLYF(xden, g, Q, 2 );

    ADDF2(xden,HALF);  /* do not compose these two adds! */

    ADDF2(xden,HALF);



    if (n & 1)    return NEGF(DIVF(xnum, xden));

    if NEZF(xnum) return      DIVF(xden, xnum);



    errno = ERANGE;

    if LSZF(xden) return CNST(-3.402823466E+38) ;

    return CNST( 3.402823466E+38) ;

} /* COTF */




coth.c/         1148595153  0     0     0       555       `
/****************************************************************************/

/*  coth.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:43 CDT 2000 */

 

#include "reald.h"



  REAL COTHF (REAL x)

{

   if EQZF(x) {errno = EDOM; return CNST( 3.402823466E+38) ; }

   return INVF(TANHF(x));

} /* COTHF */


cpy_tbl.c/      1148595153  0     0     0       4286      `
/*****************************************************************************/

/* cpy_tbl.c  v3.3.2                                                         */

/* Copyright (c) 2003-2006 Texas Instruments Incorporated                    */

/*                                                                           */

/* General purpose copy routine.  Given the address of a linker-generated    */

/* COPY_TABLE data structure, effect the copy of all object components       */

/* that are designated for copy via the corresponding LCF table() operator.  */

/*                                                                           */

/*****************************************************************************/

#include <cpy_tbl.h>



#define INT_COUNT(x) (((x) + (sizeof(int)-1))/sizeof(int))



/*****************************************************************************/

/* MEMCPY_II() - Copy data from one I/O location to another.                 */

/*****************************************************************************/

static __ioport void *memcpy_ii(__ioport void       *to, 

                                const __ioport void *from, 

			        size_t               n)

{

    __ioport int *rto   = (__ioport int *) to;

    __ioport int *rfrom = (__ioport int *) from;

    size_t rn;



    for (rn = 0; rn < INT_COUNT(n); rn++) *rto++ = *rfrom++;

    return (to);

}



/*****************************************************************************/

/* MEMCPY_IM() - Copy data from an I/O location to memory.                   */

/*****************************************************************************/

static __ioport void *memcpy_im(void                *to, 

                                const __ioport void *from, 

			        size_t               n)

{

    int          *rto   = (int *) to;

    __ioport int *rfrom = (__ioport int *) from;

    size_t rn;



    for (rn = 0; rn < INT_COUNT(n); rn++) *rto++ = *rfrom++;

    return (to);

}



/*****************************************************************************/

/* MEMCPY_MI() - Copy data from memory to an I/O location.                   */

/*****************************************************************************/

static __ioport void *memcpy_mi(__ioport void *to, 

                                const void    *from, 

			        size_t         n)

{

    __ioport int *rto   = (__ioport int *) to;

    int          *rfrom = (int *) from;

    size_t rn;



    for (rn = 0; rn < INT_COUNT(n); rn++) *rto++ = *rfrom++;

    return (to);

}



/*****************************************************************************/

/* _COPY_IN()                                                                 */

/*****************************************************************************/

void _copy_in(COPY_TABLE *tp)

{

   unsigned short i;

   for (i = 0; i < tp->num_recs; i++)

   {

      COPY_RECORD   *crp       = &tp->recs[i];

      int            load_pgid = (int)(crp->load_loc >> 24);

      unsigned char *load_addr = (unsigned char *)(crp->load_loc & 0x7fffff);

      int            run_pgid  = (int)(crp->run_loc >> 24);

      unsigned char *run_addr  = (unsigned char *)(crp->run_loc & 0x7fffff);

      unsigned int   cpy_type  = 0;



      /***********************************************************************/

      /* If page ID != 0, location is assumed to be in I/O memory.           */

      /***********************************************************************/

      if (load_pgid) cpy_type += 2;

      if (run_pgid)  cpy_type += 1;

      

      /***********************************************************************/

      /* Dispatch to appropriate copy routine based on whether or not load   */

      /* and/or run location is in I/O memory.                               */

      /***********************************************************************/

      switch (cpy_type)

      {

         case 3: memcpy_ii(load_addr, run_addr, crp->size); break;

         case 2: memcpy_im(load_addr, run_addr, crp->size); break;

         case 1: memcpy_mi(load_addr, run_addr, crp->size); break;



         case 0: memcpy(run_addr, load_addr, crp->size); break;

      }

   }            

}



cpy_tbl.h/      1148595153  0     0     0       1719      `
/*****************************************************************************/

/* cpy_tbl.h  v3.3.2                                                         */

/* Copyright (c) 2003-2006 Texas Instruments Incorporated                    */

/*                                                                           */

/* Specification of copy table data structures which can be automatically    */

/* generated by the linker (using the table() operator in the LCF).          */

/*****************************************************************************/

#ifndef _CPY_TBL

#define _CPY_TBL



#include <stdlib.h>



/*****************************************************************************/

/* Copy Record Data Structure                                                */

/*****************************************************************************/

typedef struct copy_record

{

   unsigned long load_loc;

   unsigned long run_loc;

   unsigned long size;

} COPY_RECORD;



/*****************************************************************************/

/* Copy Table Data Structure                                                 */

/*****************************************************************************/

typedef struct copy_table 

{

   unsigned short rec_size;

   unsigned short num_recs;

   COPY_RECORD    recs[1];

} COPY_TABLE;



/*****************************************************************************/

/* Prototype for general purpose copy routine.                               */

/*****************************************************************************/

extern void _copy_in(COPY_TABLE *tp);

#define copy_in(x)	(_copy_in(x))



#endif /* ! _CPY_TBL */


crshft.asm/     1148595153  0     0     0       2078      `
;/*****************************************************************************/

;/*  _crshft_r.asm v3.3.2                                                     */

;/*  Copyright (c) 1997-2006 Texas Instruments Incorporated                   */

;/*****************************************************************************/

	.include "c55xasm.i"

	.model  call=internal ; This function is recognized by name 

			      ; in the compiler.



	.noremark 5217	      ; The logical shifts used in this file

			      ; safely avoid P1 ECN 217



	.noremark 5673        ; The shifts in this file avoid SE CPU_89





; 16-bit signed saturating right shift, with rounding

;

; arg1:   value      : T0

; arg2:   shift count: T1

; return:            : T0

;



	.sect	".text"

	.global	_crshft_r

_crshft_r:	.asmfunc

        push(T2)



; Shortcut: If the shift count is larger than the word size, return 0.



        compare(T1 >= #16) goto L5



; Put the value in the high part of the accumulator, for

; saturation.



        HI(AC0) = T0



; Perform a saturating shift right.

; (This can saturate if the shift count argument was negative).

	

        T2 = -T1

        .if __TMS320C55X_PLUS__

        AC0 = ssat(AC0 << T2)

        .else

        bit(ST1, #ST1_SATD) = #1

        AC0 = AC0 << T2

        bit(ST1, #ST1_SATD) = #0

        .endif



        T1 = HI(AC0)



; The result is now in T1.  Check if we need to perform rounding.

; If the shift count was originally <= 0, don't need to round.



	T2 = -T2

        if (T2 <= #0) goto L6



; Round the result

;*** Rather than do it this way, we should probably use the Carry bit.



; Check the (T2-1)th bit of the orignal value.



        T2 = T2 - #1

        AC0 = #1

        AC0 = AC0 <<< T2

        AR3 = AC0

        AR3 = AR3 & T0



; If bit (T2-1) is set, add one to the result to accomplish rounding.



        if (AR3==#0) goto L6



        T0 = T1 + #1

        goto L7



L5:        

        T1 = #0

L6:        

        T0 = T1

L7:        

	T2 = pop()

        return

	.endasmfunc

csetjmp/        1148595153  0     0     0       848       `
/*****************************************************************************/

/* csetjmp   v3.3.2                                                          */

/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _CSETJMP

#define _CSETJMP



#define _CPP_STYLE_HEADER

#include <setjmp.h>

#undef _CPP_STYLE_HEADER



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif /* _CSETJMP */

cstdarg/        1148595153  0     0     0       849       `
/*****************************************************************************/

/* cstdarg   v3.3.2                                                          */

/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _CSTDARG

#define _CSTDARG



#define _CPP_STYLE_HEADER

#include <stdarg.h>

#undef _CPP_STYLE_HEADER



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif  /* _CSTDARG */


cstddef/        1148595153  0     0     0       848       `
/*****************************************************************************/

/* cstddef   v3.3.2                                                          */

/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _CSTDDEF

#define _CSTDDEF



#define _CPP_STYLE_HEADER

#include <stddef.h>

#undef _CPP_STYLE_HEADER



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif /* _CSTDDEF */

cstdio/         1148595154  0     0     0       852       `
/*****************************************************************************/

/* CSTDIO v3.3.2                                                             */

/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/

#ifndef _CSTDIO 

#define _CSTDIO



#define _CPP_STYLE_HEADER

#include <stdio.h>

#undef _CPP_STYLE_HEADER



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif  /* #ifndef _CSTDIO */

cstdlib/        1148595154  0     0     0       850       `
/*****************************************************************************/

/* cstdlib   v3.3.2                                                          */

/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _CSTDLIB

#define _CSTDLIB



#define _CPP_STYLE_HEADER

#include <stdlib.h>

#undef _CPP_STYLE_HEADER



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif /* ! _CSTDLIB */

cstring/        1148595154  0     0     0       849       `
/*****************************************************************************/

/* cstring   v3.3.2                                                          */

/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _CSTRING

#define _CSTRING



#define _CPP_STYLE_HEADER

#include <string.h>

#undef _CPP_STYLE_HEADER



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif  /* _CSTRING */


ctime/          1148595154  0     0     0       849       `
/*****************************************************************************/

/* ctime     v3.3.2                                                          */

/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _CTIME

#define _CTIME



#define _CPP_STYLE_HEADER

#include <time.h>

#undef _CPP_STYLE_HEADER



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif  /* #ifndef _CTIME */


ctime_.c/       1148595154  0     0     0       377       `
/****************************************************************************/

/*  ctime   v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _CTIME_



#include <time.h>


ctype.c/        1148595154  0     0     0       7661      `
/****************************************************************************/

/*  ctype.c v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <ctype.h>



/****************************************************************************/

/*  DECLARATION OF CHARACTER TYPING LOOKUP TABLE                            */

/****************************************************************************/

_DATA_ACCESS const unsigned char _ctypes_[] = {

                     /*  -1   EOF   */      0,

                     /* 0x00  NUL   */     _C_,

                     /* 0x01  SOH   */     _C_,

                     /* 0x02  STX   */     _C_,

                     /* 0x03  ETX   */     _C_,

                     /* 0x04  EOT   */     _C_,

                     /* 0x05  ENQ   */     _C_,

                     /* 0x06  ACK   */     _C_,

                     /* 0x07  BEL   */     _C_,

                     /* 0x08  BS    */     _C_,

                     /* 0x09  HT    */     _C_ | _S_,

                     /* 0x0A  LF    */     _C_ | _S_,

                     /* 0x0B  VT    */     _C_ | _S_,

                     /* 0x0C  FF    */     _C_ | _S_,

                     /* 0x0D  CR    */     _C_ | _S_,

                     /* 0x0E  SO    */     _C_,

                     /* 0x0F  SI    */     _C_,



                     /* 0x10  DLE   */     _C_,

                     /* 0x11  DC1   */     _C_,

                     /* 0x12  DC2   */     _C_,

                     /* 0x13  DC3   */     _C_,

                     /* 0x14  DC4   */     _C_,

                     /* 0x15  NAK   */     _C_,

                     /* 0x16  SYN   */     _C_,

                     /* 0x17  ETB   */     _C_,

                     /* 0x18  CAN   */     _C_,

                     /* 0x19  EM    */     _C_,

                     /* 0x1A  SUB   */     _C_,

                     /* 0x1B  ESC   */     _C_,

                     /* 0x1C  FS    */     _C_,

                     /* 0x1D  GS    */     _C_,

                     /* 0x1E  RS    */     _C_,

                     /* 0x1F  US    */     _C_,



                     /* 0x20  ' '   */     _S_ | _B_,

                     /* 0x21  '!'   */     _P_,

                     /* 0x22  '"'   */     _P_,

                     /* 0x23  '#'   */     _P_,

                     /* 0x24  '$'   */     _P_,

                     /* 0x25  '%'   */     _P_,

                     /* 0x26  '&'   */     _P_,

                     /* 0x27  '''   */     _P_,

                     /* 0x28  '('   */     _P_,

                     /* 0x29  ')'   */     _P_,

                     /* 0x2A  '*'   */     _P_,

                     /* 0x2B  '+'   */     _P_,

                     /* 0x2C  ','   */     _P_,

                     /* 0x2D  '-'   */     _P_,

                     /* 0x2E  '.'   */     _P_,

                     /* 0x2F  '/'   */     _P_,



                     /* 0x30  '0'   */     _N_ | _H_,

                     /* 0x31  '1'   */     _N_ | _H_,

                     /* 0x32  '2'   */     _N_ | _H_,

                     /* 0x33  '3'   */     _N_ | _H_,

                     /* 0x34  '4'   */     _N_ | _H_,

                     /* 0x35  '5'   */     _N_ | _H_,

                     /* 0x36  '6'   */     _N_ | _H_,

                     /* 0x37  '7'   */     _N_ | _H_,

                     /* 0x38  '8'   */     _N_ | _H_,

                     /* 0x39  '9'   */     _N_ | _H_,

                     /* 0x3A  ':'   */     _P_,

                     /* 0x3B  ';'   */     _P_,

                     /* 0x3C  '<'   */     _P_,

                     /* 0x3D  '='   */     _P_,

                     /* 0x3E  '>'   */     _P_,

                     /* 0x3F  '?'   */     _P_,



                     /* 0x40  '@'   */     _P_,

                     /* 0x41  'A'   */     _U_ | _H_,

                     /* 0x42  'B'   */     _U_ | _H_,

                     /* 0x43  'C'   */     _U_ | _H_,

                     /* 0x44  'D'   */     _U_ | _H_,

                     /* 0x45  'E'   */     _U_ | _H_,

                     /* 0x46  'F'   */     _U_ | _H_,

                     /* 0x47  'G'   */     _U_,

                     /* 0x48  'H'   */     _U_,

                     /* 0x49  'I'   */     _U_,

                     /* 0x4A  'J'   */     _U_,

                     /* 0x4B  'K'   */     _U_,

                     /* 0x4C  'L'   */     _U_,

                     /* 0x4D  'M'   */     _U_,

                     /* 0x4E  'N'   */     _U_,

                     /* 0x4F  'O'   */     _U_,



                     /* 0x50  'P'   */     _U_,

                     /* 0x51  'Q'   */     _U_,

                     /* 0x52  'R'   */     _U_,

                     /* 0x53  'S'   */     _U_,

                     /* 0x54  'T'   */     _U_,

                     /* 0x55  'U'   */     _U_,

                     /* 0x56  'V'   */     _U_,

                     /* 0x57  'W'   */     _U_,

                     /* 0x58  'X'   */     _U_,

                     /* 0x59  'Y'   */     _U_,

                     /* 0x5A  'Z'   */     _U_,

                     /* 0x5B  '['   */     _P_,

                     /* 0x5C  '\'   */     _P_,

                     /* 0x5D  ']'   */     _P_,

                     /* 0x5E  '^'   */     _P_,

                     /* 0x5F  '_'   */     _P_,



                     /* 0x60  '`'   */     _P_,

                     /* 0x61  'a'   */     _L_ | _H_,

                     /* 0x62  'b'   */     _L_ | _H_,

                     /* 0x63  'c'   */     _L_ | _H_,

                     /* 0x64  'd'   */     _L_ | _H_,

                     /* 0x65  'e'   */     _L_ | _H_,

                     /* 0x66  'f'   */     _L_ | _H_,

                     /* 0x67  'g'   */     _L_,

                     /* 0x68  'h'   */     _L_,

                     /* 0x69  'i'   */     _L_,

                     /* 0x6A  'j'   */     _L_,

                     /* 0x6B  'k'   */     _L_,

                     /* 0x6C  'l'   */     _L_,

                     /* 0x6D  'm'   */     _L_,

                     /* 0x6E  'n'   */     _L_,

                     /* 0x6F  'o'   */     _L_,



                     /* 0x70  'p'   */     _L_,

                     /* 0x71  'q'   */     _L_,

                     /* 0x72  'r'   */     _L_,

                     /* 0x73  's'   */     _L_,

                     /* 0x74  't'   */     _L_,

                     /* 0x75  'u'   */     _L_,

                     /* 0x76  'v'   */     _L_,

                     /* 0x77  'w'   */     _L_,

                     /* 0x78  'x'   */     _L_,

                     /* 0x79  'y'   */     _L_,

                     /* 0x7A  'z'   */     _L_,

                     /* 0x7B  '{'   */     _P_,

                     /* 0x7C  '|'   */     _P_,

                     /* 0x7D  '}'   */     _P_,

                     /* 0x7E  '~'   */     _P_,

                     /* 0x7F  DEL   */     _C_,



		     /* 0x80-0x8F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

		     /* 0x90-0x9F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

		     /* 0xA0-0xAF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

		     /* 0xB0-0xBF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

		     /* 0xC0-0xCF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

		     /* 0xD0-0xDF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

		     /* 0xE0-0xEF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

		     /* 0xF0-0xFF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

                  };


ctype.h/        1148595154  0     0     0       5356      `
/*****************************************************************************/

/* ctype.h    v3.3.2                                                         */

/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



/************************************************************************/

/*                                                                      */

/*  CHARACTER TYPING FUNCTIONS AND MACROS                               */

/*                                                                      */

/*  Note that in this implementation, either macros or functions may    */

/*  be used.  Macros are prefixed with an underscore.                   */

/*                                                                      */

/************************************************************************/

#ifndef _CTYPE

#define _CTYPE



#include <linkage.h>



#ifdef __cplusplus

//----------------------------------------------------------------------------

// <cctype> IS RECOMMENDED OVER <ctype.h>.  <ctype.h> IS PROVIDED FOR

// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++

//----------------------------------------------------------------------------

extern "C" namespace std

{

#endif /* __cplusplus */



extern _DATA_ACCESS const unsigned char _ctypes_[];



/************************************************************************/

/*   FUNCTION DECLARATIONS                                              */

/************************************************************************/

#include "_isfuncdcl.h"



_IDECL int toupper(int _c);

_IDECL int tolower(int _c);



#ifdef __cplusplus

} /* extern "C" namespace std */



#ifndef _CPP_STYLE_HEADER

using std::_ctypes_;

using std::isalnum;

using std::isalpha;

using std::iscntrl;

using std::isdigit;

using std::isgraph;

using std::islower;

using std::isprint;

using std::ispunct;

using std::isspace;

using std::isupper;

using std::isxdigit;

using std::isascii;

using std::toupper;

using std::tolower;

using std::toascii;

#endif /* ! _CPP_STYLE_HEADER */



#endif /* __cplusplus */



/************************************************************************/

/*  MACRO DEFINITIONS                                                   */

/************************************************************************/

#define _U_   0x01

#define _L_   0x02

#define _N_   0x04

#define _S_   0x08

#define _P_   0x10

#define _C_   0x20

#define _H_   0x40

#define _B_   0x80



#define _isalnum(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_))

#define _isalpha(a)  (_ctypes_[(a)+1] & (_U_ | _L_))

#define _iscntrl(a)  (_ctypes_[(a)+1] & _C_)

#define _isdigit(a)  (_ctypes_[(a)+1] & _N_)

#define _isgraph(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_ | _P_))

#define _islower(a)  (_ctypes_[(a)+1] & _L_)

#define _isprint(a)  (_ctypes_[(a)+1] & (_B_ | _U_ | _L_ | _N_ | _P_))

#define _ispunct(a)  (_ctypes_[(a)+1] & _P_)

#define _isspace(a)  (_ctypes_[(a)+1] & _S_)

#define _isupper(a)  (_ctypes_[(a)+1] & _U_)

#define _isxdigit(a) (_ctypes_[(a)+1] & _H_)

#define _isascii(a)  (((a) & ~0x7F) == 0)



#define _toupper(b)  ((_islower(b)) ? (b) - ('a' - 'A') : (b))

#define _tolower(b)  ((_isupper(b)) ? (b) + ('a' - 'A') : (b))

#define _toascii(a)  ((a) & 0x7F)



#ifdef _INLINE



#ifdef __cplusplus

using std::_ctypes_;

namespace std {

#endif /* __cplusplus */



#include "_isfuncdef.h"



/****************************************************************************/

/*  tolower                                                                 */

/****************************************************************************/

static __inline int tolower(int ch)

{

   /*

    This code depends on two assumptions: (1) all of the letters of the

    alphabet of a given case are contiguous, and (2) the lower and upper

    case forms of each letter are displaced from each other by the same

    constant value.

   */



   if ( (unsigned int)(ch - 'A') <= (unsigned int)('Z' - 'A')) ch += 'a' - 'A';

   return ch;

}



/****************************************************************************/

/*  toupper                                                                 */

/****************************************************************************/

static __inline int toupper(int ch)

{

   /*

    This code depends on two assumptions: (1) all of the letters of the

    alphabet of a given case are contiguous, and (2) the lower and upper

    case forms of each letter are displaced from each other by the same

    constant value.

   */



   if ( (unsigned int)(ch - 'a') <= (unsigned int)('z' - 'a')) ch -= 'a' - 'A';

   return ch;

}



#ifdef __cplusplus

}

#endif /* __cplusplus */



#endif /* _INLINE */



#else



#ifdef __cplusplus



#ifndef _CPP_STYLE_HEADER

using std::_ctypes_;

using std::isalnum;

using std::isalpha;

using std::iscntrl;

using std::isdigit;

using std::isgraph;

using std::islower;

using std::isprint;

using std::ispunct;

using std::isspace;

using std::isupper;

using std::isxdigit;

using std::isascii;

using std::toupper;

using std::tolower;

using std::toascii;

#endif /* ! _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#endif /* ! _CTYPE */

cvtdf.c/        1148595154  0     0     0       535       `
/****************************************************************************/

/*  cvtdf.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:26 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"




cvtfd.c/        1148595154  0     0     0       535       `
/****************************************************************************/

/*  cvtfd.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:27 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"




cxxabi.h/       1148595154  0     0     0       9355      `
/*****************************************************************************/

/* cxxabi.h v3.3.2                                                           */

/* Copyright (c) 1996-2006 Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*

cxxabi.h -- Include file for IA-64 ABI entry points.

*/



#ifndef __CXXABI_H

#define __CXXABI_H



#ifndef __STDDEF_H

#include <stddef.h>

#endif  /* ifndef __STDDEF_H */

#include <typeinfo>



#ifdef __EDG_RUNTIME_USES_NAMESPACES

namespace __cxxabiv1 {

  using namespace std;

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



  /* type_info implementation classes */



#pragma define_type_info

  class __fundamental_type_info : public type_info {

  public:

    virtual ~__fundamental_type_info();

  };



#pragma define_type_info

  class __array_type_info : public type_info {

  public:

    virtual ~__array_type_info();

  };



#pragma define_type_info

  class __function_type_info : public type_info {

  public:

    virtual ~__function_type_info();

  };



#pragma define_type_info

  class __enum_type_info : public type_info {

  public:

    virtual ~__enum_type_info();

  };



#pragma define_type_info

  class __class_type_info : public type_info {

  public:

    virtual ~__class_type_info();

  };



#pragma define_type_info

  class __si_class_type_info : public __class_type_info {

  public:

    virtual ~__si_class_type_info();

    const __class_type_info *__base_type;

  };



  struct __base_class_type_info {

    const __class_type_info *__base_type;

    long __offset_flags;



    enum __offset_flags_masks {

      __virtual_mask = 0x1,

      __public_mask = 0x2,

      __offset_shift = 8

    };

  };



#pragma define_type_info

  class __vmi_class_type_info : public __class_type_info {

  public:

    virtual ~__vmi_class_type_info();

    unsigned int __flags;

    unsigned int __base_count;

    __base_class_type_info __base_info[1];



    enum __flags_masks {

      __non_diamond_repeat_mask = 0x1,

      __diamond_shaped_mask = 0x2

    };

  };



#pragma define_type_info

  class __pbase_type_info : public type_info {

  public:

    virtual ~__pbase_type_info();

    unsigned int __flags;

    const type_info *__pointee;

    

    enum __masks {

      __const_mask = 0x1,

      __volatile_mask = 0x2,

      __restrict_mask = 0x4,

      __incomplete_mask = 0x8,

      __incomplete_class_mask = 0x10

    };

  }; 



#pragma define_type_info

  class __pointer_type_info : public __pbase_type_info {

    virtual ~__pointer_type_info();

  };



#pragma define_type_info

  class __pointer_to_member_type_info : public __pbase_type_info {

    virtual ~__pointer_to_member_type_info();

    const __class_type_info *__context;

  };



  extern "C" {

    /* Pure virtual function calls. */

    void __cxa_pure_virtual();

  

    /* Guard variables for the initialization of variables with static storage

       duration. */

#ifdef __eabi__

    /*------------------------------------------------------------------------*/

    /* ARM EABI specifies that guard variables are 4 bytes long               */

    /* Also, type of parameter passed to these functions is int*              */

    /* C++ ABI for the ARM Architecture, Section 3.1                          */

    /*------------------------------------------------------------------------*/

    int  __cxa_guard_acquire(int *);

    void __cxa_guard_release(int *);

    void __cxa_guard_abort  (int *);

#else

    int  __cxa_guard_acquire(unsigned long long *);

    void __cxa_guard_release(unsigned long long *);

    void __cxa_guard_abort  (unsigned long long *);

#endif



    /* Construction and destruction of arrays. */

#ifdef __eabi__

    /*------------------------------------------------------------------------*/

    /* ARM EABI specifies that ctors/dtors return "this", update function     */

    /* pointers to correspond                                                 */

    /* C++ ABI for the ARM Architecture, Section 3.1                          */

    /*------------------------------------------------------------------------*/

    void *__cxa_vec_new(size_t, size_t, size_t, void *(*)(void *),

                        void *(*)(void *));

    void *__cxa_vec_new2(size_t, size_t, size_t, void *(*)(void *),

                         void *(*)(void *), void *(*)(size_t),

                         void (*)(void *));

    void *__cxa_vec_new3(size_t, size_t, size_t, void *(*)(void *),

                         void *(*)(void *), void *(*)(size_t),

                         void (*)(void *, size_t));

    void *__cxa_vec_ctor(void *, size_t, size_t, void *(*)(void *),

                        void *(*)(void *));

    void __cxa_vec_dtor(void *, size_t, size_t, void *(*)(void *));

    void __cxa_vec_cleanup(void *, size_t, size_t, void *(*)(void *));

    void __cxa_vec_delete(void *, size_t, size_t, void *(*)(void *));

    void __cxa_vec_delete2(void *, size_t, size_t, void *(*)(void *),

                           void (*)(void *));

    void __cxa_vec_delete3(void *, size_t, size_t, void *(*)(void *),

                           void (*)(void *, size_t));

    void *__cxa_vec_cctor(void *, void *, size_t, size_t, 

                         void *(*)(void *, void *), void *(*)(void *));

#else

    void *__cxa_vec_new(size_t, size_t, size_t, void (*)(void *),

                        void (*)(void *));

    void *__cxa_vec_new2(size_t, size_t, size_t, void (*)(void *),

                         void (*)(void *), void *(*)(size_t),

                         void (*)(void *));

    void *__cxa_vec_new3(size_t, size_t, size_t, void (*)(void *),

                         void (*)(void *), void *(*)(size_t),

                         void (*)(void *, size_t));

    void __cxa_vec_ctor(void *, size_t, size_t, void (*)(void *),

                        void (*)(void *));

    void __cxa_vec_dtor(void *, size_t, size_t, void (*)(void *));

    void __cxa_vec_cleanup(void *, size_t, size_t, void (*)(void *));

    void __cxa_vec_delete(void *, size_t, size_t, void (*)(void *));

    void __cxa_vec_delete2(void *, size_t, size_t, void (*)(void *),

                           void (*)(void *));

    void __cxa_vec_delete3(void *, size_t, size_t, void (*)(void *),

                           void (*)(void *, size_t));

    void __cxa_vec_cctor(void *, void *, size_t, size_t, 

                         void (*)(void *, void *), void (*)(void *));

#endif

    /* Finalization. */

    int __cxa_atexit(void (*)(void *), void *, void *);

    void __cxa_finalize(void *);



/*** START TI ADD ***/

    void __cxa_ia64_exit(int status);

/*** END TI ADD ***/



    /* Exception-handling support. */

    void __cxa_bad_cast();

    void __cxa_bad_typeid();



    /* Demangling interface. */

    char *__cxa_demangle(const char* __mangled_name,

                         char        *__buf,

                         size_t      *__n,

                         int         *__status);



/*** START TI ADD ***/

    void *__dynamic_cast(void		                     *class_ptr,

                         const __cxxabiv1::__class_type_info *source_tiip,

                         const __cxxabiv1::__class_type_info *tiip,

                         std::ptrdiff_t                       hint);

/*** END TI ADD ***/

  }  /* extern "C" */

#ifdef __EDG_RUNTIME_USES_NAMESPACES

}  /* namespace __cxxabiv1 */



/* Create the "abi" namespace alias. */

namespace abi = __cxxabiv1;

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



#ifdef __eabi__

namespace __aeabiv1 {

/* EABI parameter order: object ptr, dtor ptr, dso handle */

int __aeabi_atexit(void *, void (*)(void *), void *);

}  /* namespace __aeabiv1 */

#endif



#endif /* ifndef __CXXABI_H */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/


defines.h/      1148595154  0     0     0       2691      `
/*****************************************************************************/

/* defines.h v3.3.2                                                          */

/* Copyright (c) 1996-2006 Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C Front End                            - | \^/ | -      *

*                                                               \   /         *

* Proprietary information of Edison Design Group Inc.         /  | |  \       *

* Copyright 1988-1995 Edison Design Group Inc.                   [_]          *

*                                                                             *

******************************************************************************/

/*



defines.h -- Defines configuration parameters for a given version of the

             runtime library.



*/



/*** START TI ADD ***/

/*---------------------------------------------------------------------------*/

/* Redefine the EDG names for vector new/delete RTS routines from the        */

/* EDG names to the TI names (generated by the parser)                       */

/*---------------------------------------------------------------------------*/

#define __vec_new              __anew 

#define __vec_new_eh           __anew_eh

#define __vec_delete           __adelete

#define __array_new            __canew

#define __placement_array_new  __pcanew

#define __array_delete         __cadelete

#define __vec_cctor            __acctor

#define __vec_cctor_eh         __acctor_eh



#ifndef __EDG_IA64_ABI

#ifndef __eabi__

#define TI_ARRAY_PREFIX 1

#endif

#endif

/*** END TI ADD ***/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C Front End                            - | \^/ | -      *

*                                                               \   /         *

* Proprietary information of Edison Design Group Inc.         /  | |  \       *

* Copyright 1988-1995 Edison Design Group Inc.                   [_]          *

*                                                                             *

******************************************************************************/


defs.c/         1148595154  0     0     0       1971      `
/*****************************************************************************/

/*  DEFS.C v3.3.2                                                            */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/*    This file defines some data structures declared in stdio.h.            */

/*****************************************************************************/

#include <stdio.h>



/*---------------------------------------------------------------------------*/

/* Define the streams for stdin, stdout, and stderr, and assign them as the  */

/* first three streams in _FTABLE upon its initialization.                   */

/* The other entries will be initialize if needed in _search_fp().           */

/*---------------------------------------------------------------------------*/

_DATA_ACCESS

FILE _ftable[_NFILE] = {{  0, NULL, NULL, NULL, NULL, (_MODER | _IOLBF) },

                        {  1, NULL, NULL, NULL, NULL, (_MODEW | _IOLBF) },

                        {  2, NULL, NULL, NULL, NULL, (_MODEW | _IONBF) } };



/*---------------------------------------------------------------------------*/

/* Allocate a table to store the filenames of temporary files, so they can   */

/* be deleted when they are closed.                                          */

/*---------------------------------------------------------------------------*/

_DATA_ACCESS char _tmpnams[_NFILE][L_tmpnam];



/*---------------------------------------------------------------------------*/

/* This global variable _FT_END is used to mark the end of used streams in   */

/* the file table.                                                           */

/*---------------------------------------------------------------------------*/

_DATA_ACCESS int _ft_end = 3; 


delete.cpp/     1148595154  0     0     0       1721      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ operator delete();



*/



#include "basics.h"

#include "runtime.h"





void operator delete(void *ptr) THROW_NOTHING()

/*

Free the memory pointed to by ptr.

*/

{

  if (ptr != NULL) {

    free(ptr);

  }  /* if */

}  /* operator delete */ 



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/


delnothrow.cpp/ 1148595154  0     0     0       1757      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/



/*



C++ operator delete();



*/



#include "basics.h"

#include "runtime.h"





void operator delete(void				*ptr,

                     const STD_NAMESPACE::nothrow_t&)

THROW_NOTHING()

/*

Nothrow version of operator delete.

*/

{

  operator delete(ptr);

}  /* operator delete */ 



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/




difftime.c/     1148595154  0     0     0       849       `
/****************************************************************************/

/*  difftime v3.3.2                                                         */

/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#undef _INLINE

#include <time.h> 



_CODE_ACCESS double difftime(time_t time1, time_t time0)

{

    /*----------------------------------------------------------------------*/

    /* THE FOLLOWING CONVERSION INSURES THAT ANY POSSIBLE DIFFERENCE IN THE */

    /* RANGE OF UNSIGNED LONG IS PROPERLY REPRESENTED IN THE RESULT.        */

    /*----------------------------------------------------------------------*/

    return ((time1 > time0) ?  (double)(time1 - time0)

	                    : -(double)(time0 - time1));

}


div.asm/        1148595154  0     0     0       3465      `
****************************************************************************

*  div  v3.3.2

*  Copyright (c) 1997-2006  Texas Instruments Incorporated

****************************************************************************

	.include "c55xasm.i"

	.mmregs

	.cpl_on

	.arms_on

	.sect	".text"

	.model  call=internal ; This function is recognized by name

			      ; in the compiler.



	.noremark 5217	      ; The logical shifts used in this file

			      ; safely avoid P1 ECN 217

	.noremark 5108        ; The FRAME instructions used in this file are

                              ; safe wrt the P2/P3 pipeline difference



******************************************************************************

* 16-BIT SIGNED DIVIDE AND MODULUS

*

* arg1 	 : dividend - T0  (U)

* arg2 	 : divisor  - T1  (V)

* return : div_t    - AR0 (Q == U / V), (R == U % V)

*

******************************************************************************



;

; Per ANSI, the div() function guarantees these things:

;

; 1) If the division is inexact, the resulting quotient is the integer

;    of lesser magnitude that is the nearest to the algebraic quotient.

;

; 2) Iff the result can be represented, quot * denom + rem == numer

;



	.global	_div

_div:	.asmfunc

******************************************************************************

* IF CALLER DISCARDS VALUE, DON'T BOTHER TO CALCULATE.

******************************************************************************

        .if __TMS320C55X_PLUS__ & (__LARGE_MODEL__ | __HUGE_MODEL__)

                if (XAR0 == #0) goto EXIT

 	.elseif .PHASE3 & (__LARGE_MODEL__ | __HUGE_MODEL__)

		AC0 = XAR0

		if (AC0 == #0) goto EXIT

	.else

		if (AR0 == #0) goto EXIT

	.endif



******************************************************************************

* DETERMINE SIGN OF RESULT

******************************************************************************

	SP = SP - #1			; allocate space on frame



	AR4 = T1	         	; sign extend D

||	AC0 = T0 		        ; sign extend Q



	AR4 = AR4 ^ T0

******************************************************************************

* TAKE ABSOLUTE VALUE OF OPERANDS

******************************************************************************

||	AC1 = |T1|             		; take absolute value of D



	*SP(#(0)) = AC1         	; save off

||	AC0 = |AC0|             	; take absolute value of Q



******************************************************************************

* PERFORM DIVIDE

******************************************************************************

	bit(ST1, #ST1_SXMD) = #0 	; turn off SXM mode

||	repeat(#15)             	; repeat 16 times

	subc(*SP(#(0)), AC0, AC0)       ; divide step



	bit(ST1, #ST1_SXMD) = #1 	; turn on SXM mode



******************************************************************************

* NOW, QUOTIENT IS IN AC0_L, REMAINDER IS IN AC0_H

******************************************************************************

        T1 = AC0			; get quotient  into T1

||	AC0 = AC0 <<< #-16      	; get remainder into AC0_L



	if (AR4 >= #0) goto SGN1	; if (dividend negative ^ 

	T1 = -T1 	             	;     divisor  negative) negate Q

SGN1:

	if (T0 >= #0) goto SGN2

	AC0 = -AC0              	; if (dividend negative) negate R

SGN2:



	*AR0+ = T1			; store div_t.quot

	*AR0+ = AC0			; store div_t.rem

||	SP = SP + #1		 	; deallocate frame

EXIT:

	return

	.endasmfunc


div.c/          1148595154  0     0     0       2374      `
/****************************************************************************/

/*  div.c            v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:59:29 CDT 2000 */

 

#include "arith.h"



div_t  div  (int   num, int   den)

{

   div_t  local;



   register unsigned int  nm = num;

   register unsigned int  dn = den;

   register unsigned int  t, md;

   register int q, i, sh;



   int sign;

   if (sign = (num < 0)) nm = -nm;

   if (den <= 0) { 

      if (den == 0) { /* division by 0? */

       

         if      (sign   ) dn = (int ) ((unsigned int )1<<(16  -1))   ;/*neg*/

         else if (nm != 0) dn = (int )(((unsigned int )1<<(16  -1))-1);/*pos*/

         else              dn = (int )0;

         local.quot = dn;

         local.rem = 0;

         return local;

       

      }

      dn = -dn;

    

   }



   sh = 0; 

 

   while ((unsigned int )nm > (unsigned int )dn) {dn <<= 1; sh++;}

 

   if ((int )dn < (int )0) {

 

      if (sh <= 0) goto aligned;

      if ((int )(t = nm - dn) >= 0) {q = 2; nm = t;}

      dn >>= 1; sh -= 1;  /* top bit of dn now 0 */

   }



   /* sh holds bits-1 of quotient */



   if (sh <= 0) { /* is nm < 2*dn ? */

   aligned:

      t = nm - dn;

    

      local.quot = ((den < 0) ^ sign) ? - ((int )t >= 0)  : ((int )t >= 0) ;

      local.rem = ((int )t >= 0)  ? (sign ? -t : t) : nm;

     

      return local;

    

   }



   if (q = ((int )(t = nm - dn) >= 0)) nm = t;

 

   dn -= 1;  /* the bit that is used to build quotient */

   md = -dn;



   /* resultant nm is >= 0 here but might be full size so must */

   /* unroll 1st iteration of loop to hard-wire test against 0 */

   nm <<= 1;

   nm += md;



   for (i = sh-1; i > 0; i--) {

      nm = (((int )nm < 0) ? dn : md) + (nm << 1);

   }

   if ((int )nm < 0) nm += dn; /* overshot by 1 */



   /* remainder in upper bits, quotient is bottom sh bits + q<<sh */



   dn = ((nm << (16  -sh)) >> (16  -sh)) | ((unsigned int )q << sh);

   nm >>= sh;

 

   if (sign)             nm = -nm;

   if ((den < 0) ^ sign) dn = -dn;

 

   local.rem  = nm;

   local.quot = dn;

   return local;



}



divd.c/         1148595154  0     0     0       4239      `
/****************************************************************************/

/*  divd.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:27 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



  REAL DIVF(REAL left, REAL right)

/*---------------------------------------------------------------------------*/

/* IEEE floating divide.  return left / right                                */



/* Does *NOT* handle +/- INFINITY, NAN.                                      */



/* Does *NOT* handle denormalized numbers.                                   */



/*---------------------------------------------------------------------------*/

{ 

/* if_IEEE_Hardware */

  /* Hardware never has divide.                                           */

  /* The fixed point algorithm below will work, but there are better ways */

  /* given a fast floating point multiply.  Someday...                    */

/* elsif_not_IEEE_Hardware */



   unsigned long  lfrc, rfrc, pfrc;     /* fraction of left, right and product */

   int    lexp, rexp, pexp;	/* exponent of left, right and product */

   unsigned long  sign;    



   /*------------------------------------------------------------------------*/

   /* Unpack fraction and exponent, ignoring signs for now.                  */

   /* Reinsert hidden bit or re-normalize fraction as appropriate.           */

   /*------------------------------------------------------------------------*/



   pfrc = 0;

   REALasUNS(lfrc,  left); sign =         lfrc         ; lfrc &= ~MINUS;

   REALasUNS(rfrc, right); sign = (sign ^ rfrc) & MINUS; rfrc &= ~MINUS;



   if (rexp = rfrc >> 23 ) { /* right not 0 or denorm */

      if (!(rfrc &= REAL_FRC_MASK)) {

         /* right is a power of two */

         if (!(lexp = lfrc >> 23 )) { /* left is 0 or denorm */

         

            goto resign;                       /* 0 / right */

         

	 } else pfrc = ((lfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT)<<1;

         pexp = lexp - rexp;

         goto insert_exponent;

      }

      rfrc += REAL_HIDDEN_BIT; /* insert hidden bit */

   }



   else {          /* 0 divisor */

   

      pfrc = REAL_NAN;                          /*    0 / 0 */

      if (lfrc != 0) pfrc = REAL_INFNAN;        /* left / 0 */

   

      goto resign;

   }



   if (lexp = lfrc >> 23 )

      lfrc = (lfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT; /*insert hidden bit*/



   else goto resign;                       /* 0 / right */



   /*------------------------------------------------------------------------*/

   /* Compute quotient exponent and fraction.                                */

   /* Round and normalize quotient if needed.                                */

   /*------------------------------------------------------------------------*/

   pfrc = FRCDIVF(lfrc, rfrc);



   pexp = lexp - rexp;



   pfrc += 1;     /* biased rounding */



   if (pfrc < (REAL_HIDDEN_BIT<<1)) { pfrc <<= 1; pexp -= 1; }



insert_exponent:

   /*------------------------------------------------------------------------*/

   /* check for overflow and underflow                                       */

   /*------------------------------------------------------------------------*/

   if ((pexp += 127 ) <= 0) {        /* underflow */

   

      pfrc = 0;      /* no significant bits remain */

   

      pexp = 0;

      }

   else if (pexp >= REAL_EXP_INFNAN) {    /* overflow */

   

      pexp = REAL_EXP_INFNAN; pfrc = 0;

   

   }



   /*------------------------------------------------------------------------*/

   /* assemble result and return                                             */

   /*------------------------------------------------------------------------*/

   pfrc = ((pfrc >> 1) & REAL_FRC_MASK) + (((long )pexp) << 23 );



resign:

   pfrc += sign;



   return_UNSasREAL(pfrc);



/* endif_IEEE_Hardware */

} /* DIVF */


divli.c/        1148595154  0     0     0       680       `
/****************************************************************************/

/*  divli.c          v3.3.2                                                 */

/*  Copyright (c) 2002-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <limits.h>

 

long _divli(long x1, long x2)

{

    int negative_quotient = (long)(x1 ^ x2) < 0;

    unsigned long t1, t2;

    long result;



    if (x2 == 0) return LONG_MAX;



    t1 = (x1 == LONG_MIN ? x1 : labs(x1));

    t2 = (x2 == LONG_MIN ? x2 : labs(x2));



    result = t1 / t2;



    return negative_quotient ? -result : result;

}

divs.asm/       1148595154  0     0     0       1568      `
;/****************************************************************************/

;/*  divs  v3.3.2                                                            */

;/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

;/****************************************************************************/

	.include "c55xasm.i"

	.model  call=internal ; This function is recognized by name 

			      ; in the compiler.



; fractional (Q15) 16-bit integer divide

;

; arg1:   ?: T0

; arg2:   ?: T1

; return: ?: T0 (Q15)

;



	.sect	".text"

	.global	_divs

_divs:	.asmfunc

        if (T0 == #0) return  ; note: return value is zero



  .if __TMS320C55X_PLUS__

	TC1 = (T0 == T1)

  .else

        TC1 = (T0 == T1)

||      nop             ; avoid Silicon Exception CPU_24

  .endif

        if (TC1) execute(D_Unit) || T0 = #32767 

	if (TC1) return



        AC0 = T0	; T0 last use as input

||	BRC0 = #14

        AC1 = T1

||      T0 = #0

  .if __TMS320C55X_PLUS__

	localrepeat {

           AC0 = AC0 << #1           ||  T0 = T0 << #1

           TC1 = (AC0 < AC1)	

           if (!TC1) execute(D_Unit) ||  AC0 = ssat(AC0 - AC1)

           if (!TC1) execute(D_Unit) ||  T0 = T0 + #1

	}

  .else

	localrepeat {

           AC0 = AC0 << #1            ||  T0 = T0 << #1

           TC1 = (AC0 < AC1)          ||  bit(ST1, #ST1_SATD) = #1

           if (!TC1) execute(D_Unit)  ||  AC0 = AC0 - AC1

           if (!TC1) execute(D_Unit)  ||  T0 = T0 + #1

           bit(ST1, #ST1_SATD) = #0

	}

  .endif

        return

	.endasmfunc

divul.c/        1148595154  0     0     0       1394      `
/****************************************************************************/

/*  divul.c          v3.3.2                                                 */

/*  Copyright (c) 2002-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

static __inline unsigned long _subcul(unsigned long src1, unsigned long src2)

{

    int test = (src1 >= src2);



    if (test) src1 -= src2;



    return src1 << 1 | test;	

}



unsigned long _divul (unsigned long x1, unsigned long x2)

{

    register int i;

    register unsigned long num;

    register unsigned long den;

    register int shift;

    unsigned long first_div = 0;

    unsigned long num32;

 

    shift = _llnorm(x2) - _llnorm(x1);

 

    if (x1 < x2) return 0;

    if (x1 == 0) return 0;

    if (x2 == 0) return (unsigned long) -1; /* saturation value */

 

    num = x1;

    den = x2 << shift;

 

    num32 = (_llnorm(x1) == -1);

 

    first_div = num32 << shift;

 

    if (den > num) first_div >>= 1;

 

    if (num32)

    {

        if(den > num) { den >>= 1; num -= den; }

        else          { num -= den; den >>= 1; }

    }

    else

        shift++;

 

    for (i = 0; i < shift; i++)

	num = _subcul(num, den);



    if (shift)

	return num << (32-shift) >> (32-shift) | first_div;

    else

	return first_div;

}

dtor_list.cpp/  1148595154  0     0     0       12537     `
/*****************************************************************************/

/* dtor_list.cpp v#####                                                      */

/* Copyright (c) 1996@%%%% Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

*                                                               \   /         *

* Proprietary information of Edison Design Group Inc.         /  | |  \       *

* Copyright 1992-1994 Edison Design Group Inc.                   [_]          *

*                                                                             *

******************************************************************************/

/*



dtor_list.c -- destruction list processing.



*/



#include "basics.h"

#include "runtime.h"

#pragma hdrstop

/*** START TI ADD ***/

/* TI implementation of RTS does not need the definition in static_init.h.

TI RTS only needs IA64_ABI part of this file. */

#if 0

/*** END TI ADD ***/ 

#include "static_init.h"

/*** START TI ADD ***/

#endif

/*** END TI ADD ***/ 

#include "dtor_list.h"



#if !defined(__EDG_IA64_ABI) || !SYSTEM_RUNTIME_HAS_IA64_SUPPORT || \

    !SYSTEM_RUNTIME_HAS_IA64_ATEXIT



/*

The list of static objects that require destruction.  An entry is

added to the front of this list each time a new destructible static

object is created.

*/

static a_needed_destruction_ptr

		needed_destruction_head /* = NULL*/;



#endif /* !defined(__EDG_IA64_ABI) || !SYSTEM_RUNTIME_HAS_IA64_SUPPORT

          !SYSTEM_RUNTIME_HAS_IA64_ATEXIT */





#ifndef __EDG_IA64_ABI



void __process_needed_destructions(void)

/*

Go through the needed destructions list and perform the required

destructions.

*/

{

  a_needed_destruction_ptr	ndp;

  while (needed_destruction_head != NULL) {

    void	*object_ptr;

    /* Note that the value of needed_destruction_head may change

       during the execution of the destructor.  Consequently, the

       current entry is removed from the list before the destructor

       routine is called. */

    ndp = needed_destruction_head;

    needed_destruction_head = needed_destruction_head->next;

    object_ptr = ndp->object;

    /* Choose between a simple and complex destruction based on whether

       or not the object pointer is NULL. */

    if (object_ptr != NULL) {

      a_destructor_ptr	dp;

      /* Destroy the object by calling a destructor.  The flag value of 2

         indicates the object should be destroyed, but operator delete

         should not be called. */

      dp = (a_destructor_ptr)ndp->destruction_routine;

      (dp)(object_ptr, 2);

    } else {

      /* Destroy the object by calling a special function that will do the

         destruction of this specific object. */

      (ndp->destruction_routine)();

    }  /* if */

  }  /* while */

}  /* __process_needed_destructions */





EXTERN_C void __already_marked_for_destruction()

/*

This routine is called when a needed destruction is recorded more than

once.  It simply calls abort.  The name is intended to describe the nature

of the problem to the user.

*/

{

  __abort_execution(ec_already_marked_for_destruction);

}





EXTERN_C void __record_needed_destruction(a_needed_destruction_ptr ndp)

/*

Called when a static object has been constructed to register a

destruction that must be done at program termination.  ndp points to

a needed destruction entry that is to be added to the front of the

list of needed destructions.

*/

{

  /* If the entry has already been put on the list, terminate the execution. */

  if (ndp->next != NULL ||

      ndp == needed_destruction_head) __already_marked_for_destruction();

  ndp->next = needed_destruction_head;

  needed_destruction_head = ndp;

}  /* __record_needed_destruction */





#if CFRONT_COMPATIBILITY_MODE

EXTERN_C void __std__needed_destruction_list(void)

/*

This routine is provided for use with a cfront runtime library, including

cfront startup and termination code.  This routine will be called by

the cfront static destruction routines and will ensure that any needed

destructions get done.  The sequence of the destructions will not

be standard conforming, but there is no way to get standard conforming

behavior when using the cfront termination routines.



This routine will only be used when munch is being used.  When patch

is being used, the link structure defined below will result in a call to

__process_needed_destructions.

*/

{

  __process_needed_destructions();

}  /* __std__needed_destruction_list */





/*

Define a link structure that will be used when patch is being used.

*/

struct a_link {

  a_link	*next;

  a_void_function_ptr

		ctor;

  a_void_function_ptr

		dtor;

};



static a_link __link = {(a_link*)NULL,

                        (a_void_function_ptr)NULL,

                        (a_void_function_ptr)__process_needed_destructions};





/*

This declaration is used to force the static definition of __link to be

put out (i.e., to make the compiler think that __link is actually used).

*/

a_link* __dummy_variable_used_to_force_definition_of__link = &__link;

#endif /* CFRONT_COMPATIBILITY_MODE */



#else /* defined(__EDG_IA64_ABI) */



#if !SYSTEM_RUNTIME_HAS_IA64_SUPPORT

/* Current versions of Linux already define these routines in the C runtime

   library, and if we attempt to redefine them here we end up with multiple

   versions of these symbols. */



/* The DSO handle.  Initialization to NULL indicates that this is the handle

   for the main program.  */

a_dso_handle __dso_handle;



#endif /* !SYSTEM_RUNTIME_HAS_IA64_SUPPORT */



#if !SYSTEM_RUNTIME_HAS_IA64_ATEXIT



void ABI_NAMESPACE::__cxa_finalize(a_dso_handle dso_handle)

/*

Go through the needed destructions list and perform the required

destructions for the DSO indicated by dso_handle, or all destructions if

dso_handle is NULL.

*/

{

  a_needed_destruction_ptr *ndpp, ndp, old_head;

  

  ndpp = &needed_destruction_head;

  while (*ndpp != NULL) {

    ndp = *ndpp;

    /* Skip destructions that do not apply to this DSO. */

    if (dso_handle != NULL && ndp->dso_handle != dso_handle) {

      ndpp = &ndp->next;

      continue;

    }  /* if */

    /* Note that the value of needed_destruction_head may change

       during the execution of the destructor.  Consequently, the

       current entry is removed from the list before the destructor

       routine is called. */

    *ndpp = ndp->next;

    old_head = needed_destruction_head;

    /* Call the routine. */

    (*ndp->destruction_routine)(ndp->object);

    /* Deallocate the entry. */

    free(ndp);

    /* If the head has changed, start at the beginning of the list 

       again so that we can process the newly added destruction. */

    if (needed_destruction_head != old_head) {

      ndpp = &needed_destruction_head;

    }  /* if */

  }  /* while */

}  /* __cxa_finalize */



/*** START TI ADD ***/

/******************************************************************************/

/* Renamed __cxa_atexit to __TI_atexit, __TI_atexit is invoked by both        */

/* __cxa_atexit and __aeabi_atexit (inline into both the functions)           */

/******************************************************************************/

/*** END TI ADD ***/



/******************************************************************************/

/* Register an action to be taken at program termination (or DSO unload) time.*/

/* The action is the calling of destruction_routine with the object parameter.*/

/* If dso_handle is non-NULL, the action will be taken when __cxa_finalize    */

/* is called for the specific dso_handle value, or when __cxa_finalize        */

/* is called to process all objects (i.e., the __cxa_finally dso_handle has   */

/* a NULL value).  If dso_handle is NULL, the action will be taken only when  */

/* __cxa_finalize is called to process all objects.                           */

/*                                                                            */

/* This version of __cxa_atexit is only intended to be used when the          */

/* system's runtime does not include its own version of __cxa_atexit.  When   */

/* the system's runtime includes such a function, the system is responsible   */

/* for seeing that __cxa_finalize is invoked at program termination.  When    */

/* using our own version of this rout, we need to ensure that __cxa_finalize  */

/* is invoked at program termination.  This is accomplished by calling        */

/* __register_finalization_routine on the first invocation of this function.  */

/* This function should return 0 if registration is successful, nonzero       */

/* otherwise								      */

/******************************************************************************/

static inline int __TI_atexit(a_cxa_dtor_ptr    destruction_routine,

                              void             *object,

                              a_dso_handle      dso_handle)

{

  int                      success = TRUE;

  a_needed_destruction_ptr ndp;



  ndp = (a_needed_destruction_ptr)malloc(sizeof(a_needed_destruction));

  if (ndp == NULL) {

    success = FALSE;

  }  else {

/*** START TI ADD ***/

  /* Here in IA64_ABI mode, we do not need to register the destructor in

  any other place. The ndp below record all the destructors and the 

  __cxa_finalize will walk through the list to call the destructors

  during exit.



  "__register_finalization_routine()" defined in static_init.c in

  EDGRTS release calls atexit() to record "__call_dtors" function.

  "__call_dtors" is a function in EDGRTS release corresponds to 

  "__call_ctors" which is also from EDGRTS release. As TI RTS does not

  use "__call_Ctors" to do static initialization, here it is also

  unnecessary to call "_call_dtors".



  For non IA64_ABI mode, we have our own way to record the destructors,

  details in __add_dtor() in sinit.c */

extern   void abort(void);

#if 0

/*** END TI ADD ***/

    if (needed_destruction_head == NULL)

	      __register_finalization_routine();

/*** START TI ADD ***/

#endif

/*** END TI ADD ***/

    ndp->object = object;

    ndp->destruction_routine = (a_destructor_ptr)destruction_routine;

    ndp->dso_handle = dso_handle;

    ndp->next = needed_destruction_head;

    needed_destruction_head = ndp;

  }  /* if */

  return success ? 0 : 1;

}  /* __TI_atexit */



/*** START TI REPLACE ***/

int ABI_NAMESPACE::__cxa_atexit(a_cxa_dtor_ptr    destruction_routine,

                                void             *object,

                                a_dso_handle      dso_handle)

{

    return __TI_atexit(destruction_routine, object, dso_handle);

}



#if __EDG_IA64_ABI

void ABI_NAMESPACE::__cxa_ia64_exit(int status)

{

    ABI_NAMESPACE::__cxa_finalize((a_dso_handle)NULL);

}

#endif /* defined(__EDG_IA64_ABI) */

/*** END TI REPLACE ***/



#endif /* !SYSTEM_RUNTIME_HAS_IA64_ATEXIT */



#endif /* defined(__EDG_IA64_ABI) */



#ifdef __eabi__

EXTERN_C int atexit(void (*fun)())

{



   ABI_NAMESPACE::__cxa_atexit((a_cxa_dtor_ptr)fun, NULL, NULL);

   return 0;

}





namespace __aeabiv1 

{

extern "C" int __aeabi_atexit(void *object, 

	                      void (*destroyer) (void *), 

			      void *dso_handle) 

{

    return __TI_atexit(destroyer, object, dso_handle);

}



} //namespace __aeabiv1



#endif /* __eabi__ */

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

*                                                               \   /         *

* Proprietary information of Edison Design Group Inc.         /  | |  \       *

* Copyright 1992-1994 Edison Design Group Inc.                   [_]          *

*                                                                             *

******************************************************************************/


dtor_list.h/    1148595154  0     0     0       3905      `
/*****************************************************************************/

/* dtor_list.h v3.3.2                                                        */

/* Copyright (c) 1996-2006 Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

*                                                               \   /         *

* Proprietary information of Edison Design Group Inc.         /  | |  \       *

* Copyright 1992-1994 Edison Design Group Inc.                   [_]          *

*                                                                             *

******************************************************************************/

/*



Declarations relating to dtor_list.c -- destruction list processing.



*/



#ifndef DTOR_LIST_H

#define DTOR_LIST_H 1

/*** START TI ADD ***/

/* TI implementation of RTS does not need the definition in main.h 

TI RTS only needs IA64_ABI part of this file. */

#if 0

/*** END TI ADD ***/ 

#ifndef MAIN_H

#include "main.h"

#endif /* ifndef MAIN_H */

/*** START TI ADD ***/

#endif

/*** END TI ADD ***/ 

/*

Data structure used to build a list of static object destructions

to be performed at the end of execution.  Entries are added to the

list each time a static object is created.  New objects are added

to the front of the list.

*/

typedef struct a_needed_destruction *a_needed_destruction_ptr;

typedef struct a_needed_destruction {

  a_needed_destruction_ptr

		next;

			/* Pointer to the next entry in the list. */

  void		*object;

			/* Pointer to the object to be destroyed if this

			   is a "simple" destruction, or a NULL pointer

		 	   if this is a "complex" destruction.  A simple

			   destruction is one that can be done with

			   a single call to the destructor passing an

			   object pointer and a destruction flag. */

#ifndef __EDG_IA64_ABI

  a_void_function_ptr

#else /* defined(__EDG_IA64_ABI) */

  a_destructor_ptr

#endif /* defined(__EDG_IA64_ABI) */

		destruction_routine;

			/* For a simple destruction, this points to the

			   destructor to be called. For a complex destruction,

                           this is a pointer to a function that when called,

                           will call the necessary destructors. */

#ifdef __EDG_IA64_ABI

  a_dso_handle  dso_handle;

                        /* The DSO handle associated with this destruction, or

                           NULL if this destruction is associated with the

                           main program. */

#endif /* ifdef EDG_IA64_ABI */

} a_needed_destruction;



#ifndef __EDG_IA64_ABI

extern void __process_needed_destructions(void);



EXTERN_C void __record_needed_destruction(a_needed_destruction_ptr ndp);

#endif /* ifndef __EDG_IA64_ABI */



#endif /* DTOR_LIST_H */





/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

*                                                               \   /         *

* Proprietary information of Edison Design Group Inc.         /  | |  \       *

* Copyright 1992-1994 Edison Design Group Inc.                   [_]          *

*                                                                             *

******************************************************************************/


ecvt.c/         1148595154  0     0     0       2952      `
/****************************************************************************/

/*  ecvt v3.3.2                                                             */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include "math.h"

extern int ltoa(long val, char *buffer);





#define MANTISSA_WORD 1

#define EXPONENT_WORD 0



char *ecvt(long double value, register int ndigit, int *decpt, int *sign)



{

    static char out[100]; 



    register int   digits = 0;         /* NUMBER OF DIGITS BEFORE .       */

    register char *pos    = out + 1;     

    register int   temp;



    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */

    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */



    /*--------------------------------------------------------------------*/

    /* IF TRYING TO CONVERT INFINITY, RETURN HUGE_VALL OF PROPER SIGN     */

    /*--------------------------------------------------------------------*/

    { 

       long *ptr = (long *)&value;



       if (((ptr[EXPONENT_WORD] >> 20) & 0x7ff) == 0x7ff) 

	  value = (ptr[EXPONENT_WORD] & 0x80000000) ? -HUGE_VALL : HUGE_VALL;

    }



    /*--------------------------------------------------------------------*/

    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */

    /*--------------------------------------------------------------------*/

    if (*sign = (value < 0)) value = -value;

    while (value > 0x7FFFFFFF) { value /= 10; digits++; }

    while (value && value < 1) { value *= 10; digits--; }



    /*--------------------------------------------------------------------*/

    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */

    /*--------------------------------------------------------------------*/

    pos    += temp    = ltoa((long)value, pos);

    *decpt  = digits + temp;



    /*--------------------------------------------------------------------*/

    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */

    /*--------------------------------------------------------------------*/

    if (temp >= ndigit) 

	 pos = out + ndigit + 1;

    else if ((ndigit -= temp) > 0) do

    {

         value -= (long)value;

	 *pos++ = (int)(value *= 10.0) + '0';

    }

    while (--ndigit);



    /*--------------------------------------------------------------------*/

    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */

    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */

    /*--------------------------------------------------------------------*/

    if (*--pos >= '5')

    {

	register char *ptr = pos;

	while ((*--ptr += 1) > '9') *ptr = '0';

	if (ptr == out) { *--pos = 0; *decpt += 1; return(out); }

    }

	

    *pos = 0;

    return(out + 1);

}



eh.h/           1148595154  0     0     0       16732     `
/*****************************************************************************/

/* eh.h v3.3.2                                                               */

/* Copyright (c) 1996-2006 Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Declarations for exception handling.



*/



#ifndef _EH_H

#define _EH_H 1



#include <stdlib.h>

#include "runtime.h"

#include <exception>

#include "rtti.h"

#include "vec_newdel.h"



/*** START TI REPLACE ***/

#if EXCEPTION_HANDLING && !defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

/*** END TI REPLACE ***/



#ifndef NULL

#define NULL (0)

#endif /* NULL */



#include <setjmp.h>



typedef long an_element_count;

			/* Type used to represent a count of the number of

			   elements in an array.  Must be signed because

			   -1 is used to represent an array whose size is

			   only known at run time. */



typedef int	a_conditional_flag;

			/* Type of a flag used for conditional region

			   entries. */



typedef __EDG_VAR_HANDLE_TYPE an_object_handle;

			/* An offset into the object address array. */



typedef void *an_object_ptr;

			/* An address of an object. */



typedef __EDG_REGION_NUMBER_TYPE a_region_number;

			/* Type used to represent a region number.

			   Must be an unsigned type. */



/* Definitions of the values in the flags field of the region description

   entry. */

typedef a_byte a_region_descr_flag_set;

#define RDF_NO_FLAGS		0x0

			/* Value used when no flags are set. */

#define RDF_INDIRECT		0x01

			/* TRUE if the address provided by handle

			   is a pointer to the object. */

#define RDF_CONDITIONAL_FLAG	0x02

			/* TRUE if the object is conditionally constructed.

			   When this flag is TRUE the next entry on the list

			   contains a handle that can be used to get the

			   address of the flag that indicates whether the

			   object has been constructed.  When this flag is

			   set the value of the conditional flag (pointed

			   to by the handle in the region entry) should be

			   tested before trying to make use of the handle

			   in the next region entry. */

#define RDF_NEW_ALLOCATION	0x04

			/* TRUE if the object was allocated by new and

			   is to be freed in the event of a throw. */

#define RDF_ARRAY		0x08

			/* TRUE if the complete object information can

			   be found in the array supplement.  This is used

			   for arrays and for new allocations that require

			   a two-argument operator delete call. */

#define RDF_THIS_PARAM_OFFSET	0x10

			/* TRUE if the object is at an address relative to

			   the "this" parameter of the current routine, i.e.,

			   it's a base class or member being handled in

			   a constructor or destructor.  Not used in the

			   portable scheme. */

#define RDF_SUBOBJECT_VTABLE		0x20

			/* When RDF_BASE_CLASS_SUBOBJECT is TRUE, this

			   flag indicates that a region entry following this

			   one gives the address of the subobject virtual

			   function table table to be used when calling the

			   destructor.  If there is also an extra entry for a

			   conditional flag, the subobject vtable entry

			   follows the flag entry.  Note that this uses the

			   same bit as RDF_LET_THIS. */



#if 0

/*

This flag is used by the Kuck & Associates inliner when not doing

full portable EH lowering.  This flag is not used by the EDG supplied

runtime.  Also, the DO_FULL_PORTABLE_EH_LOWERING and USING_KAI_INLINER

flags are defined in the front end, but are not defined in the runtime

config.h file.

*/

#if !DO_FULL_PORTABLE_EH_LOWERING && USING_KAI_INLINER

#define RDF_LET_THIS            0x20

                        /* TRUE if address computed should be used as a 

                           "formal this" parameter.  The region entry

                           following this one describes what to do

                           with the "formal this" pointer.  The

                           following entry will have the

                           RDF_THIS_PARAM_OFFSET flag set, and

                           possibly the RDF_LET_THIS flag set.

                           Chained RDF_LET_THIS entries allow object

                           addresses to be specified when multiple

                           (indirection+offset) operations are

                           necessary to reach the object from a

                           stack-local variable or the "actual this".

                           More detailed information on RDF_LET_THIS

                           is available from KAI.  Note that this uses

			   the same bit as RDF_SUBOBJECT_VTABLE. */

#endif /* !DO_FULL_PORTABLE_EH_LOWERING && USING_KAI_INLINER */

#endif /* 0 */



#define RDF_BASE_CLASS_SUBOBJECT	0x40

			/* TRUE if the object is a base class of some other

			   object and therefore is not a complete object. */

#define RDF_GUARD_VAR_FOR_LOCAL_STATIC	0x80

			/* TRUE if the object is the guard variable associated

			   with the initialization of a local static variable.

			   The cleanup action is to set the variable back to

			   zero. */



#define NULL_REGION_NUMBER ((a_region_number)__EDG_NULL_EH_REGION_NUMBER)

			/* The value used when there is no active EH

			   region.  Also the value used as the next

			   region number when there is no next region. */





/* Supplement to a region description entry for array entries and for

   entries for new allocations that must be deleted using the

   two-argument form of operator delete. */

typedef struct an_eh_array_supplement *an_eh_array_supplement_ptr;

typedef struct an_eh_array_supplement {

  an_object_handle

		handle;

			/* Offset in stack from or index into

			   the object address array. */

  a_sizeof_t	element_size;

			/* Size of each element in the array. */

  an_element_count	array_size;

			/* Number of elements in an array.  -1 if the

			   size is not known at compile time.  Zero for

			   objects that are not arrays but that must be

			   deleted using the two-argument operator

			   delete. */

} an_eh_array_supplement;





/* Structure that describes a single destructable object. */

typedef struct an_eh_region_descr *an_eh_region_descr_ptr;

typedef struct an_eh_region_descr {

  a_void_function_ptr

		destructor_or_delete_routine;

			/* When new_allocation is FALSE this points to

			   the destructor for the object.  When

			   new_allocation is TRUE this points to the

			   delete operator for the object. */

  an_object_handle

		handle;

			/* Offset in stack from or index into

			   the object address array. When RDF_ARRAY is

			   set the handle contains the index into the

			   array supplement.  When

			   RDF_THIS_PARAM_OFFSET is set the handle

			   contains an offset to be added to the this

			   parameter to get the address of a base

			   class. */

  a_region_number

	        index_of_next_region;

			/* Index of the region description of the

			   next region.  This region will be

			   processed after the processing for this

			   region has been completed. */

  a_region_descr_flag_set

		flags;

			/* A collection of bits that specify how the

			   region entry is to be used.  See the

			   descriptions of the RDF flags above. */

} an_eh_region_descr;





/* Definitions of the values in the flags field of the exception type

   specification entry. */

typedef a_byte an_ETS_flag_set;

#define ETS_NO_FLAGS		0x0

			/* Value used when no flags are set. */

#define ETS_IS_POINTER		0x01

			/* A pointer to an object of the type specified

			   by type_info is being caught. */

#define ETS_CONST		0x02

#define ETS_VOLATILE		0x04

			/* Indication of the type qualifiers on the type

			   pointed to, in the pointer case. */

#define ETS_IS_REFERENCE	0x08

			/* A reference to an object of the type specified

			   by type_info is being caught. */

#define ETS_IS_ELLIPSIS		0x10

			/* The catch clause contains an ellipsis. */

#define ETS_LAST		0x20

			/* TRUE if this is the last catch clause associated

			   with a given try block (i.e., there are no more

			   entries in the array.) */

/*** START TI ADD ***/

#define ETS_IS_FUNC_POINTER     0x40

                        /* TRUE if the catch clause is a pointer to 

			   function  */

/*** END TI ADD ***/

#define ETS_QUALIFIERS	(ETS_CONST | ETS_VOLATILE)

			/* The flags bits that comprise the type qualifiers

			   that must be checked to determine a match. */



/* Macros used for checking ETS flags. */

/* The pointer flags are not used prior to the 2.41 ABI. */

#if ABI_COMPATIBILITY_VERSION >= 241

#define is_pointer(flag, ptr_flags)  ((flag & ETS_IS_POINTER) != 0 ||	\

                                      ptr_flags != NULL)

/*** START TI ADD ***/ 

#define is_pointer_to_func(flag, ptr_flags)  ((flag & ETS_IS_FUNC_POINTER) != 0 ||	\

                                      ptr_flags != NULL)

/*** END TI ADD ***/

#else /* !(ABI_COMPATIBILITY_VERSION >= 241) */

#define is_pointer(flag, ptr_flags)  ((flag & ETS_IS_POINTER) != 0)

#endif /* ABI_COMPATIBILITY_VERSION >= 241 */



/* is_single_level_pointer returns TRUE only if the pointer bit is set in

   the primary flags field, and does not consider the ptr_flags. */

#define is_single_level_pointer(flag)					\

  is_pointer(flag, NULL)



#define is_const(flag)               ((flag & ETS_CONST) != 0)

#define is_volatile(flag)            ((flag & ETS_VOLATILE) != 0)

#define is_reference(flag)           ((flag & ETS_IS_REFERENCE) != 0)

#define is_ellipsis(flag)            ((flag & ETS_IS_ELLIPSIS) != 0)

#define is_last(flag)                ((flag & ETS_LAST) != 0)



/* Return the qualifiers from a flag entry. */

#define get_qualifiers(flag)         (flag & ETS_QUALIFIERS)





/* Exception type specifications are used to describe throw specifications

   for functions and are also used to describe the list of types used in

   the catch clauses associated with a given try block. */

typedef struct an_exception_type_specification

		*an_exception_type_specification_ptr;

typedef struct an_exception_type_specification {

  a_type_info_impl_ptr

		type_info;

			/* Pointer to the type information for the entry.

			   NULL if the entry has no associated type (for

			   ellipsis entries or for empty throw specification

			   lists). */

  an_ETS_flag_set

		flags;

			/* A collection of bits that specify how the

			   catch entry is to be used.  See the

			   descriptions of the ETS flags above. */

#if ABI_COMPATIBILITY_VERSION >= 241

  an_ETS_flag_set

		*ptr_flags;

			/* Present for types that have more than one level

			   of pointer.  Points to an array of flags, terminated

			   by an entry with the ETS_LAST bit set.  This

			   information is used to do qualification conversions

			   on multi-level pointers. */

#endif /* ABI_COMPATIBILITY_VERSION >= 241 */

} an_exception_type_specification;





/* The kinds of stack entries that may exist. */

enum an_eh_stack_entry_kind_tag {

  ehsek_try_block,

  ehsek_function,

  ehsek_throw_spec,

  ehsek_throw_processing_marker,

  ehsek_vec_new_or_delete

};



typedef a_byte an_eh_stack_entry_kind;



typedef struct an_eh_stack_entry *an_eh_stack_entry_ptr;

typedef struct an_eh_stack_entry {

  an_eh_stack_entry_ptr

		next;

			/* The next stack entry. */

  an_eh_stack_entry_kind

		kind;

			/* The kind of stack entry. */

  union {

    /* When kind == ehsek_try_block. */

    struct {

#if USE_SYSTEM_JMP_BUF_DEFINITION

      jmp_buf	setjmp_buffer;

			/* Buffer used by setjmp to save state information.

			   The jmp_buf type is defined in setjmp.h. */

#else /* !USE_SYSTEM_JMP_BUF_DEFINITION */

      __EDG_JMP_BUF_ELEMENT_TYPE

                setjmp_buffer[__EDG_JMP_BUF_NUM_ELEMENTS];

			/* Buffer used by setjmp to save state

			   information.  The element type and size are

			   passed from the front end using predefined

			   macros. */

#endif /* USE_SYSTEM_JMP_BUF_DEFINITION */

      an_exception_type_specification_ptr

		catch_entries;

			/* Pointer to an array of entries that describe the

			   types that can be caught. */

      void*	catch_info;

			/* Pointer to catch information maintained by the

			   runtime system.  Initialized to NULL by the

			   code generated by the compiler. */

      a_region_number

		region_number;

			/* EH region number upon entry to the try block.

			   Used to clean up objects declared in the try

			   block. */

    } try_block;



    /* When kind == ehsek_function. */

    struct {

      an_eh_region_descr

		*regions;

			/* Pointer to an array of region

			   descriptions. */

      an_object_ptr

		*object_address_table;

			/* Pointer to an array of object addresses. */

      an_eh_array_supplement

		*array_table;

			/* Pointer to an array of array description

			   entries. */

      a_region_number

		saved_region_number;

			/* Previous value of eh_curr_region saved on

			   entry to this function. */

    } function;

    /* When kind == ehsek_throw_spec. */

    an_exception_type_specification_ptr

		throw_specification;

			/* Pointer to an array of entries that specify the

			   types that can be thrown. */

    /* When kind == ehsek_vec_new_or_delete. */

    an_array_alloc_eh_info_ptr

		array_alloc_eh_info;

			/* Pointer to a structure used to handle exceptions

			   that occur while processing an array new or delete

			   operation. */

  } variant;

} an_eh_stack_entry;





EXTERN a_region_number

		__eh_curr_region initial_value(0);

			/* Number of the current region in topmost function

			   entry on the EH stack. */



EXTERN an_eh_stack_entry_ptr

		__curr_eh_stack_entry initial_value(NULL);

			/* The pointer to the top of the stack of EH

			   entries. */

EXTERN int	__catch_clause_number;

			/* Contains the sequence number of the catch clause

			   associated with a given try block. */



EXTERN void*	__caught_object_address;

			/* The address of the object to be used as the value

			   of the parameter in the catch clause. */



EXTERN_C void __call_terminate(void);

EXTERN_C void __default_terminate(void);



EXTERN a_void_function_ptr

		__default_terminate_routine

                       initial_value((a_void_function_ptr)__default_terminate);

			/* Pointer to the terminate routine to be used. */



EXTERN_C void __call_unexpected(void);



EXTERN a_void_function_ptr

		__default_unexpected_routine

                                       initial_value(STD_NAMESPACE::terminate);

			/* Pointer to the unexpected routine to be used. */



EXTERN_C void __cleanup_vec_new_or_delete(an_eh_stack_entry_ptr ehsep);



EXTERN_C void __eh_exit_processing(void);



EXTERN_C void __type_of_thrown_object(a_type_info_impl_ptr	*type,

				      an_ETS_flag_set		*flags,

				      an_ETS_flag_set		**ptr_flags);



EXTERN_C a_boolean __can_throw_type(a_type_info_impl_ptr	type,

				    an_ETS_flag_set		flags,

				    an_ETS_flag_set		*ptr_flags);





EXTERN_C an_eh_stack_entry_ptr __get_curr_eh_stack_entry(void);



/*** START TI REPLACE ***/

#endif /* EXCEPTION_HANDLING && !defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */

/*** END TI REPLACE ***/



#endif /* ifndef _EH_H */





/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

eh_util.cpp/    1148595154  0     0     0       6992      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ functions to support exception handling.



*/



#include "basics.h"

#include "runtime.h"

#include "eh.h"



#if EXCEPTION_HANDLING && !defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

static a_boolean

		terminate_called = FALSE;

			/* Set to TRUE when terminate() is called by the

			   EH runtime.  This is used by uncaught_exception()

			   to determine whether terminate() has been called. */



/*

If the runtime should be defined in the std namespace, open

the std namespace.

*/

#ifdef __EDG_RUNTIME_USES_NAMESPACES

namespace std {

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */





void terminate()

/*

The default terminate routine.

*/

{

  if (__default_terminate_routine != NULL) __default_terminate_routine();

  __abort_execution(ec_terminate_returned);

}  /* terminate */





EXTERN_C void __default_terminate(void)

/*

The default terminate routine, which is just a wrapup around abort().

*/

{

  __abort_execution(ec_terminate_called);

}  /* __default_terminate */





a_void_function_ptr set_terminate(a_void_function_ptr new_func) THROW_NOTHING()

/*

Set the terminate routine pointer to the value passed by the caller

and return the old value.

*/

{

  a_void_function_ptr	old_func = __default_terminate_routine;

  __default_terminate_routine = new_func;

  return old_func;

}  /* set_terminate */





void unexpected()

/*

The default unexpected routine.  This routine calls terminate.

*/

{

  if (__default_unexpected_routine != NULL) __default_unexpected_routine();

  terminate();

}  /* unexpected */





a_void_function_ptr set_unexpected(a_void_function_ptr new_func)

THROW_NOTHING()

/*

Set the unexpected routine pointer to the value passed by the caller

and return the old value.

*/

{

  a_void_function_ptr	old_func = __default_unexpected_routine;

  __default_unexpected_routine = new_func;

  return old_func;

}  /* set_unexpected */





__bool uncaught_exception()

/*

Return TRUE if an exception is in the process of being thrown.

*/

{

  an_eh_stack_entry_ptr	ehsep;

  __bool		result;



  /* This function is used instead of simply using __curr_eh_stack_entry

     because of a problem using this variable in code that also uses

     it via generated EH code. */

  ehsep = __get_curr_eh_stack_entry();

  /* TRUE should be returned if uncaught_exception() is called after

     terminate() has been called by the implementation. */

  result = terminate_called;

  for (; result == FALSE && ehsep != NULL; ehsep = ehsep->next) {

    if (ehsep->kind == ehsek_throw_processing_marker) {

      /* We are processing a throw.  An exception cannot be thrown here

         without resulting in a call to terminate().  Note that this is

         TRUE even if a try block is nested inside the throw processing

         marker. */

      result = TRUE;

    }  /* if */

  }  /* for */

  return result;

}  /* uncaught_exception */



/*

If the runtime should be defined in the std namespace, close

the std namespace.

*/

#ifdef __EDG_RUNTIME_USES_NAMESPACES

}  /* namespace std */

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */





EXTERN_C void __call_unexpected(void)

/*

Used by the EH runtime when unexpected() needs to be called.  When

unexpected() exits by throwing an exception the exception must not

violate the exception specification that caused unexpected() to be

called in the first place.  If it does violate that exception

specification, std::bad_exception is thrown provided it is permitted

by the violated exception specification.  If it is not permitted,

terminate() is called.



*/

{

#if ABI_CHANGES_FOR_RTTI

  try {

    STD_NAMESPACE::unexpected();

  }  /* try */

  catch (...) {

    a_type_info_impl_ptr	thrown_type;

    an_ETS_flag_set		thrown_flags;

    an_ETS_flag_set		*thrown_ptr_flags;

    __type_of_thrown_object(&thrown_type, &thrown_flags, &thrown_ptr_flags);

    if (__can_throw_type(thrown_type, thrown_flags, thrown_ptr_flags)) {

      /* If the thrown type is permitted, rethrow it so that it will be

         handled by an enclosing try block (if any). */

      throw;

    } else {

      a_type_info_impl_ptr	bad_exception_type;

      bad_exception_type =

                   (a_type_info_impl_ptr)&typeid(STD_NAMESPACE::bad_exception);

      if (__can_throw_type(bad_exception_type,

                           (an_ETS_flag_set)ETS_NO_FLAGS,

                           (an_ETS_flag_set*)NULL)) {

        /* The thrown type is not allowed, but bad_exception is.  Throw

           bad_exception. */

        throw STD_NAMESPACE::bad_exception();

      } else {

        /* Neither the originally thrown type not bad_exception is permitted.

           Call terminate. */

        __call_terminate();

      }  /* if */

    }  /* if */

  }  /* catch */

#else /* !ABI_CHANGES_FOR_RTTI */

 /* When RTTI is not used, the old semantics of unexpected() are used in

    which the type of an object thrown by unexpected is not checked against

    the violated exception specification. */

  STD_NAMESPACE::unexpected();

#endif /* ABI_CHANGES_FOR_RTTI */

  /* It should not be possible to get here. */

  abort();

}  /* __call_unexpected */





EXTERN_C void __call_terminate(void)

/*

Used by the EH runtime when terminate needs to be called.  Ensures

that terminate does not return.

*/

{

  terminate_called = TRUE;

  STD_NAMESPACE::terminate();

  /* It should not be possible to get here. */

  abort();

}  /* __call_terminate */





#endif /* EXCEPTION_HANDLING */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

errno.c/        1148595154  0     0     0       375       `
/*****************************************************************************/

/*  errno    v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                  */

/*****************************************************************************/

#include <errno.h>



_DATA_ACCESS int errno = 0;


errno.h/        1148595154  0     0     0       1225      `
/*****************************************************************************/

/*  ERRNO.H  v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



#ifndef _ERRNO

#define _ERRNO



#ifdef __cplusplus

//----------------------------------------------------------------------------

// <cerrno> IS RECOMMENDED OVER <errno.h>.  <errno.h> IS PROVIDED FOR

// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++

//----------------------------------------------------------------------------

extern "C" namespace std

{

#endif /* __cplusplus */



#include <linkage.h>



#define errno errno

extern _DATA_ACCESS int errno;



#define EDOM   1

#define ERANGE 2

#define ENOENT 3

#define EFPOS  5

#define EILSEQ 6



#ifdef __cplusplus

} /* extern "C" namespace std */



#ifndef _CPP_STYLE_HEADER

using std::errno;

#endif /* _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#else



#ifdef __cplusplus



#ifndef _CPP_STYLE_HEADER

using std::errno;

#endif /* _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#endif  /* _ERRNO */


error.cpp/      1148595154  0     0     0       3506      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



error.c - runtime error handling.



*/



#include "basics.h"

#include "runtime.h"

#pragma hdrstop



#if DISPLAY_ABORT_DESCRIPTION



static char *error_text(an_error_code	err_code)

/*

Return the string associated with the specified error code.

*/

{

  char	*s = NULL;



  switch (err_code) {

    case ec_abort_header:

      s = "C++ runtime abort";

      break;

    case ec_terminate_called:

      s = "terminate() called by the exception handling mechanism";

      break;

    case ec_terminate_returned:

      s = "returned from a user-defined terminate() routine";

      break;

    case ec_already_marked_for_destruction:

      s =

         "internal error: static object marked for destruction more than once";

      break;

    case ec_main_called_more_than_once:

      s = "main() called more than once";

      break;

    case ec_pure_virtual_called:

      s = "a pure virtual function was called";

      break;

    case ec_bad_cast:

      s = "invalid dynamic cast";

      break;

    case ec_bad_typeid:

      s = "invalid typeid operation";

      break;

    case ec_array_not_from_vec_new:

      s = "freeing array not allocated by an array new operation";

      break;

    default:

      unexpected_condition();

      break;

  }  /* switch */

  return s;

}  /* error_text */





static void display_abort_message(an_error_code	err_code)

/*

Display the reason that the runtime is aborting execution.

*/

{

  fprintf(stderr, "%s: %s\n", error_text(ec_abort_header),

          error_text(err_code));

}  /* display_abort_message */



#endif /* DISPLAY_ABORT_DESCRIPTION */



#if !DISPLAY_ABORT_DESCRIPTION

/*ARGSUSED*/ /* err_code is only used when displaying abort descriptions. */

#endif /* !DISPLAY_ABORT_DESCRIPTION */

EXTERN_C void __abort_execution(an_error_code	err_code)

/*

*/

{

#if DISPLAY_ABORT_DESCRIPTION

  /* Display the reason for the abort. */

  display_abort_message(err_code);

#endif /* DISPLAY_ABORT_DESCRIPTION */

  abort();

}  /* abort_execution */





/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

error.h/        1148595154  0     0     0       1966      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Declarations relating to error.c - runtime error handling.



*/



#ifndef ERROR_H

#define ERROR_H 1



typedef enum /* an_error_code */ {

  ec_none,

  ec_abort_header,

  ec_terminate_called,

  ec_terminate_returned,

  ec_already_marked_for_destruction,

  ec_main_called_more_than_once,

  ec_pure_virtual_called,

  ec_bad_cast,

  ec_bad_typeid,

  ec_array_not_from_vec_new,

  ec_last

} an_error_code;



EXTERN_C void __abort_execution(an_error_code err_code);



#endif /* ERROR_H */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

exception/      1148595154  0     0     0       2289      `
/*****************************************************************************/

/* exception  v3.3.2                                                         */

/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/

#if __EXCEPTIONS

#define THROW(throw_spec) throw(throw_spec)

#define THROW_NOTHING() throw()

#else /* !__EXCEPTIONS */

#define THROW(throw_spec) /* Nothing. */

#define THROW_NOTHING() /* Nothing. */

#endif /* __EXCEPTIONS */





#ifdef __EXCEPTIONS

#ifndef _EXCEPTION_STDH

#define _EXCEPTION_STDH



/* This lets users disable the EDG supplied exception classes. */

#ifndef __NO_EDG_EXCEPTION_CLASSES



#include <stdexcept.h>



#ifdef __EDG_RUNTIME_USES_NAMESPACES

namespace std {

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



  /*

  If bool is not supported, use a typedef for bool.

  */

  #ifdef _BOOL

  typedef bool __bool;

  #else /* ifndef _BOOL */

  typedef int __bool;

  #endif /* ifdef _BOOL */



  class bad_exception : public exception {

  public:

    bad_exception() throw();

    bad_exception(const bad_exception&) throw();

    bad_exception& operator=(const bad_exception& rhs) throw();

    virtual ~bad_exception() throw();

    virtual const char* what() const throw();

  };



  typedef void (*terminate_handler)();

  extern terminate_handler set_terminate(terminate_handler) THROW_NOTHING();



  typedef void (*unexpected_handler)();

  extern unexpected_handler set_unexpected(unexpected_handler) THROW_NOTHING();



  /* unexpected and terminate are in the WP definition of exception.h.

     It is not clear why. */

  void terminate();

  void unexpected();



  extern __bool uncaught_exception();



#ifdef __EDG_RUNTIME_USES_NAMESPACES

}  /* namespace */



#ifdef __EDG_IMPLICIT_USING_STD

/* Implicitly include a using directive for the STD namespace when this

   preprocessing flag is TRUE. */

using namespace std;

#endif /* ifdef __EDG_IMPLICIT_USING_STD */



#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */



#endif /* _EXCEPTION_STDH */

#else  /* __EXCEPTIONS */

#ifndef _EXCEPTION

#define _EXCEPTION

#endif

#endif /* __EXCEPTIONS */




exception.h/    1148595154  0     0     0       1730      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*

The exception header should be included as "#include <exception>".

This file is provided for compatibility with older programs that

use "#include <exception.h>".

*/

#ifndef _EXCEPTION_H

#define _EXCEPTION_H



#include <exception>



#endif /* _EXCEPTION_H */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

exception_.cpp/ 1148595154  0     0     0       4102      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

*                                                               \   /         *

* Proprietary information of Edison Design Group Inc.         /  | |  \       *

* Copyright 1995 Edison Design Group Inc.                        [_]          *

*                                                                             *

******************************************************************************/

/*



Functions that implement the "exception" and "bad_exception" classes (18.6).



*/



#include "basics.h"

#include "runtime.h"



/* The definition of the exception classes can be disabled. */

#if USE_EDG_EXCEPTION_CLASSES



#if EXCEPTION_HANDLING



#include <exception>



/*

If the runtime should be defined in the std namespace, open

the std namespace.

*/

#ifdef __EDG_RUNTIME_USES_NAMESPACES

namespace std {

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



#if !defined(DNKLIB)

exception::exception() THROW_NOTHING()

/*

Constructor for exception.

*/

{

}  /* exception::exception */





exception::exception(const exception&) THROW_NOTHING()

/*

Copy constructor for exception.

*/

{

}  /* exception::exception */





exception& exception::operator=(const exception&) THROW_NOTHING()

/*

Assignment operator for exception.  Currently does nothing.

*/

{

  return *this;

}  /* exception::operator= */





exception::~exception() THROW_NOTHING()

/*

Destructor for exception.

*/

{

}  /* exception::~exception */





const char* exception::what() const THROW_NOTHING()

/*

Return a string providing information about the exception.  Currently,

no additional information is available.

*/

{

  return "";

}  /* exception::~exception */

#endif /* !defined(DNKLIB) */



#if !defined(DNKLIB)

bad_exception::bad_exception() THROW_NOTHING()

/*

Constructor for bad_exception.

*/

{

}  /* bad_exception::bad_exception */

#endif /* defined(DNKLIB) */



bad_exception::bad_exception(const bad_exception& rhs)

THROW_NOTHING() : exception(rhs)

/*

Copy constructor for bad_exception.  Currently does nothing.

*/

{

}  /* bad_exception::bad_exception */





bad_exception& bad_exception::operator=(const bad_exception& rhs)

THROW_NOTHING()

/*

Assignment operator for bad_exception.  Currently does nothing.

*/

{

  /* Call the base class assignment operator. */

  exception::operator=(rhs);

  return *this;

}  /* bad_exception::operator= */





bad_exception::~bad_exception() THROW_NOTHING()

/*

Destructor for bad_exception.

*/

{

}  /* bad_exception::~bad_exception */





const char* bad_exception::what() const THROW_NOTHING()

/*

Return a string providing information about the exception.  Currently,

no additional information is available.

*/

{

  return "";

}  /* bad_exception::what */





/*

If the runtime should be defined in the std namespace, close

the std namespace.

*/

#ifdef __EDG_RUNTIME_USES_NAMESPACES

}  /* namespace std */

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



#endif /* EXCEPTION_HANDLING */



#endif /* USE_EDG_EXCEPTION_CLASSES */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

*                                                               \   /         *

* Proprietary information of Edison Design Group Inc.         /  | |  \       *

* Copyright 1995 Edison Design Group Inc.                        [_]          *

*                                                                             *

******************************************************************************/

exit.c/         1148595154  0     0     0       4485      `
/****************************************************************************/

/*  EXIT.C v3.3.2                                                           */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <stdlib.h>

#include <_lock.h>



/*****************************************************************************/

/* Allow the user the options of placing this code in RAM so the debugger    */

/* does not give errors about setting breakpoints when loading code into     */

/* non-writeable memory.                                                     */

/*****************************************************************************/

#pragma CODE_SECTION(abort, ".text:CIO_breakpoint")



#define MAX_FUN   32



static int    at_exit_count = 0;

static void (*at_exit_fun[MAX_FUN])();

void        (*_cleanup_ptr)(void) = NULL;

void   _DATA_ACCESS      (*_dtors_ptr)(void)   = NULL;



/****************************************************************************/

/* EXIT() - NORMAL PROGRAM TERMINATION.                                     */

/****************************************************************************/

void exit(int status)        

{

   int i;



   /*-------------------------------------------------------------------*/

   /* MUST LOCK WHEN ACCESSING at_exit_count AND at_exit_fun.           */

   /*-------------------------------------------------------------------*/

   _lock();

   i = at_exit_count;



   /*-------------------------------------------------------------------*/

   /* HANDLE FUNCTIONS REGISTERED THROUGH atexit().                     */

   /*-------------------------------------------------------------------*/

   while (i) (*at_exit_fun[--i])(); 



   /*-------------------------------------------------------------------*/

   /* IF THERE ARE STATIC DESTRUCTORS, CALL THEM.                       */

   /*-------------------------------------------------------------------*/

   if (_dtors_ptr)  (*_dtors_ptr)();



   /*-------------------------------------------------------------------*/

   /* IF FILES ARE POSSIBLY OPEN, _CLEANUP_PTR() WILL BE SETUP TO CLOSE */

   /* THEM.                                                             */

   /*-------------------------------------------------------------------*/

   if (_cleanup_ptr)  (*_cleanup_ptr)();

   _unlock();

   abort();

}



/****************************************************************************/

/* ATEXIT - ATTEMPT TO REGISTER A FUNCTION FOR CALLING AT PROGRAM END       */

/****************************************************************************/

int atexit(void (*fun)())

{

   /*-------------------------------------------------------------------*/

   /* MUST LOCK WHEN ACCESSING at_exit_count AND at_exit_fun.           */

   /*-------------------------------------------------------------------*/

   _lock();

   if (at_exit_count >= MAX_FUN) {

      _unlock();

      return 1;

   }

   at_exit_fun[at_exit_count++] = fun;

   _unlock();

   return 0;

}



/****************************************************************************/

/* ABORT - ABNORMAL PROGRAM TERMINATION.  CURRENTLY JUST HALTS EXECUTION.   */

/****************************************************************************/

void abort(void)

{

   /*-------------------------------------------------------------------*/

   /* PUSH THE BREAKPOINT ADDRESS AWAY FROM THE RETURN OF THE FUNCTION  */

   /* LINKED BELOW IT. ELSE IN 32-BIT SLOW RETURN STACK MODE SIMULATOR  */

   /* CAN SEE THE BREAKPOINT IN THE PIPELINE BEFORE THE RETURN HAPPENS. */

   /*-------------------------------------------------------------------*/

    __asm("	nop");

   /*-------------------------------------------------------------------*/

   /* SET C$$EXIT LABEL SO THE DEBUGGER KNOWS WHEN THE C++ PROGRAM HAS  */

   /* COMPLETED.  THIS CAN BE REMOVED IF THE DEBUGGER IS NOT USED.      */

   /*-------------------------------------------------------------------*/

   __asm("        .global C$$EXIT");

   __asm("C$$EXIT: nop");



   /*-------------------------------------------------------------------*/

   /* TELL ENVIRONMENTS WITHOUT "CIO" IMPLEMENTED THE PROGRAM'S DONE.   */

   /*-------------------------------------------------------------------*/

   __asm("         sim_trig");



   for (;;);   /* SPINS FOREVER */

}


exp.c/          1148595154  0     0     0       1899      `
/****************************************************************************/

/*  exp.c            v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:43 CDT 2000 */

 

#include "reald.h"



  REAL EXPF(REAL x)

{

   

   if GTRF(x, CNST( 88.72283382) )

   { 

      errno = ERANGE;

      return CNST( 3.402823466E+38) ;

   }

   if LSSF(x, CNST(-86.64339241) ) return ZERO;

   if LSSF(ABSF(x), CNST(1.1920928955E-7) ) return ONE;



   {

      /* Adapted from "Handbook of Mathematical Functions with Formulas,    */

      /* Graphs, and Mathematical Tables", Milton Abramowitz and            */

      /* Irene A. Stegun, National Bureau of Standards (Applied Mathematics */

      /* Series 55), Washington D.C., 1964 (reprinted 1970). 4.2.45, page 71*/



      REAL          xn, x1, f, g;

      EXPONENT_TYPE n;



      static  REAL exp_consts[7] =

         {KNST(0.0001413161),

          KNST(0.0013298820),

          KNST(0.0083013598),

          KNST(0.0416573475),

          KNST(0.1666653019),

          KNST(0.4999999206),

          KNST(0.9999999995)};

   

      x1 = MPYF(x, One_Over_Ln_2);

      n  = (EXPONENT_TYPE)FIXFI(FLRF(x1));

      n  += 1;

      FLTIF2(xn, n);

      FLRF2(x1, x);



      /* g  = ((x1 - xn * C1) + (x-x1)) - xn * C2; */

      SUBF3(g,

            ADDF(SUBF(x1,

                      MPYF(xn,CNST(0.693359375) )),

                 SUBF(x,x1)),

            MPYF(xn, CNST(-2.1219444005469058277E-4) ));

       

      /* -ln(2) =< g < 0 */



      POLYF(f, g, exp_consts, 7 );



      ADDF2(f, ONE);



      /* 1/2 <= F < 1  (exponent of F is -1) */

      return SCLF(f, n);

   }



} /* EXPF */


exp10.c/        1148595154  0     0     0       497       `
/****************************************************************************/

/*  exp10.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:44 CDT 2000 */

 

#include "reald.h"



  REAL EXP10F(REAL x)

{

    return EXPF(MPYF(x, Ln_10));

} /*EXP10F*/


exp2.c/         1148595154  0     0     0       494       `
/****************************************************************************/

/*  exp2.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:44 CDT 2000 */

 

#include "reald.h"



  REAL EXP2F(REAL x)

{

    return EXPF(MPYF(x, Ln_2));

} /*EXP2F*/

extaddr.asm/    1148595154  0     0     0       6004      `
;/****************************************************************************/

;/*    v3.3.2 - */

;/*  Copyright (c) 1996-2006  Texas Instruments Incorporated                 */

;/****************************************************************************/

  .if ! __TMS320C55X_PLUS__

	.include "c55xasm.i"

	.mmregs

	.cpl_on

	.arms_on

	.model  call=internal ; This function is recognized by name 

			      ; in the compiler.



	.noremark 5230	      ; The conditional returns used in this file

			      ; safely avoid P1 ECN 230



; Symbols defined here

	.def _far_peek

	.def _far_peek_l

	.def _far_poke

	.def _far_poke_l

	.def _far_memcpy

	.def _far_near_memcpy

	.def _near_far_memcpy



;/****************************************************************************/

;/* far_peek() - read 1 word of data from extended address                   */

;/****************************************************************************/

_far_peek:	.asmfunc

	AR4 = AC0 & #0FFFFh		;  Move page address to AR register

	AC0 = AC0 << #-16		;  Shift page # to bottom 16-bits



	MDP05 = @AC0_L || mmap()	;  Initialize MDP to correct page

	AC0   = uns(*AR4)		;  Read 1 word of data (unsigned)

	MDP05 = #0			;  Reset MDP to the data page

	return

	.endasmfunc



;/****************************************************************************/

;/* far_peek_l() - read 1 long word of data from extended address            */

;/****************************************************************************/

_far_peek_l:	.asmfunc

	AR4 = AC0 & #0FFFFh		;  Move page address to AR register

	AC0 = AC0 << #-16		;  Shift page # to bottom 16-bits



	MDP05 = @AC0_L || mmap()	;  Initialize MDP to correct page

	AC0   = dbl(*AR4)		;  Read 1 word of data (unsigned)

	MDP05 = #0			;  Reset MDP to the data page

	return

	.endasmfunc



;/****************************************************************************/

;/* far_poke() - write 1 word of data to extended address                    */

;/****************************************************************************/

_far_poke:	.asmfunc

	AR4 = AC0 & #0FFFFh		;  Move page address to AR register

	AC0 = AC0 << #-16		;  Shift page # to bottom 16-bits



	MDP05 = @AC0_L || mmap()	;  Initialize MDP to correct page

	*AR4  = AR2			;  Write 1 word of data

	MDP05 = #0			;  Reset MDP to the data page

	return

	.endasmfunc



;/****************************************************************************/

;/* far_poke_l() - write 1 long word of data to extended address             */

;/****************************************************************************/

_far_poke_l:	.asmfunc

	AR4 = AC0 & #0FFFFh		;  Move page address to AR register

	AC0 = AC0 << #-16		;  Shift page # to bottom 16-bits



	MDP05 = @AC0_L || mmap()	;  Initialize MDP to correct page

	dbl(*AR4)  = AC1		;  Write 1 word of data

	MDP05 = #0			;  Reset MDP to the data page

	return

	.endasmfunc



;/****************************************************************************/

;/* far_memcpy() - copy a block of data between extended addresses           */

;/****************************************************************************/

_far_memcpy:	.asmfunc

	if (AR3 == #0) return		;  if copy size == 0 return

	push(AR7)			;  SOE registers



	AR7 = AC0 & #0FFFFh		;  Move page address to "dst" to AR reg

	AR4 = AC1 & #0FFFFh		;  Move page address to "src" to AR reg



	AC0 = AC0 << #-16		;  Shift "dst" page # to bottom 16-bits

	MDP67 = @AC0_L || mmap()	;  Initialize MDP to correct page



	AC1 = AC1 << #-16		;  Shift "src" page # to bottom 16-bits

	MDP05 = @AC1_L || mmap()	;  Initialize MDP to correct page



	AR3 -= #1			;  Decrement counter value by 1

	CSR = AR3			;  Initialize CSR register

	repeat(CSR)			;  Perform block copy from 

	  *AR7+ = *AR4+			;  "dst" to "src"



	MDP67 = #0			;  Reset MDP to the data page

	MDP05 = #0			;  Reset MDP to the data page

||	AR7 = pop()			;  Restore SOE registers

	return

	.endasmfunc

	

;/****************************************************************************/

;/* far_near_memcpy() - copy a block of data between extended addresses      */

;/*                     and page 0.                                          */

;/****************************************************************************/

_far_near_memcpy:	.asmfunc

	if (AR3 == #0) return		;  if copy size == 0 return

	push(AR7)			;  Save SOE register



	AR7 = AC1 & #0FFFFh		;  Move page address to AR register



	AC1 = AC1 << #-16		;  Shift page # to bottom 16-bits

	MDP67 = @AC1_L || mmap()	;  Initialize MDP to correct page



	AR3 -= #1			;  Decrement counter value by 1

	CSR = AR3			;  Initialize CSR register

	repeat(CSR)			;  Perform block copy from 

	  *AR1+ = *AR7+			;  "dst" to "src".



	MDP67 = #0			;  Reset MDP to the data page

||	AR7 = pop()			;  Restore SOE register

	return

	.endasmfunc

	

;/****************************************************************************/

;/* near_far_memcpy()  - copy a block of data between page 0 and extended    */

;/*                      addresses.                                          */

;/****************************************************************************/

_near_far_memcpy:	.asmfunc

	if (AR3 == #0) return		;  if copy size == 0 return

	push(AR7)			;  Save SOE register



	AR7 = AC0 & #0FFFFh		;  Move page address to AR register



	AC0 = AC0 << #-16		;  Shift page # to bottom 16-bits

	MDP67 = @AC0_L || mmap()	;  Initialize MDP to correct page



	AR3 -= #1			;  Decrement counter value by 1

	CSR = AR3			;  Initialize CSR register

	repeat(CSR)			;  Perform block copy from 

	  *AR7+ = *AR2+			;  "dst" from "src".



	MDP67 = #0			;  Reset MDP to the data page

||	AR7 = pop()			;  Restore SOE register

	return

	.endasmfunc

	

	

	.global _far_peek

	.global _far_peek_l

	.global _far_poke

	.global _far_poke_l

	.global _far_memcpy

	.global _far_near_memcpy

	.global _near_far_memcpy

  .endif

	.end

extaddr.h/      1148595154  0     0     0       2021      `
/*****************************************************************************/

/* extaddr.h  v3.3.2                                                         */

/* Copyright (c) 1996-2006  Texas Instruments Incorporated                   */

/*****************************************************************************/



#ifndef _EXTADDR

#define _EXTADDR



/**************************************************************************/

/* Type of extended memory data address values                            */

/**************************************************************************/

typedef unsigned long FARPTR;



#ifdef __cplusplus

extern "C" {

#endif /* __cplusplus */



/**************************************************************************/

/* Prototypes for Extended Memory Data Support Functions                  */

/*                                                                        */

/* far_peek         Read an int from extended memory address              */

/* far_peek_l       Read a long from extended memory address              */

/* far_poke         Write an int to extended memory address               */

/* far_poke_l       Write a long to extended memory address               */

/* far_memcpy       Block copy between extended memory addresses          */

/* far_near_memcpy  Block copy from extended memory address to page 0     */

/* near_far_memcpy  Block copy from page 0 to extended memory address     */

/*                                                                        */

/**************************************************************************/

int           far_peek(FARPTR);

unsigned long far_peek_l(FARPTR);

void          far_poke(FARPTR, int);

void          far_poke_l(FARPTR, unsigned long);



void          far_memcpy(FARPTR, FARPTR,  int);

void          far_near_memcpy(void *, FARPTR,  int);

void          near_far_memcpy(FARPTR, void *,  int);



#ifdef __cplusplus

}

#endif /* __cplusplus */



#endif /* !_EXTADDR */


fabs.c/         1148595154  0     0     0       504       `
/****************************************************************************/

/*  fabs.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:44 CDT 2000 */

 

#include "reald.h"



  REAL FABSF(REAL x)

{

   return (LSSF(x,ZERO) ? NEGF(x) : x);

} /* FABSF */

fclose.c/       1148595154  0     0     0       3774      `
/*****************************************************************************/

/*  FCLOSE.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/*    Functions:                                                             */

/*       FCLOSE   -  Close a stream                                          */

/*****************************************************************************/

#include <stdio.h>

#include "file.h"

#include <string.h>

#include <stdlib.h>



extern int _doflush(FILE *_fp);





/*****************************************************************************/

/* FCLOSE   -  Close a stream                                                */

/*                                                                           */

/*    This function flushes the current stream, deallocates any buffers      */

/*    associated with the stream, and closes it.  This function returns a 0  */

/*    if the close was successful, or an EOF if an error occured.            */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int fclose(FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   int fd = _fp->fd;

   int errchk;

   int remove_flag = _STCHK(_fp, _TMPFILE);



   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if(_fp->fd == -1) return (EOF);



   /*------------------------------------------------------------------------*/

   /* Flush the buffer.                                                      */

   /*------------------------------------------------------------------------*/

   if(_doflush(_fp)) return (EOF);



   /*------------------------------------------------------------------------*/

   /* Free the buffer if there was one, and it was malloc'd by SETVBUF.      */

   /*------------------------------------------------------------------------*/

   if(_STCHK(_fp, _BUFFALOC))

   {

      free((_fp->buf)-1);

      _UNSET(_fp, _BUFFALOC);

   }



   /*------------------------------------------------------------------------*/

   /* Reset the buffer pointers in the stream.                               */

   /*------------------------------------------------------------------------*/

   _fp->buf = NULL;

   _fp->pos = NULL;

   _fp->bufend = NULL;



   /*------------------------------------------------------------------------*/

   /* Close the file, and give the FILE structure an invalid file descriptor */

   /* so it cannot be used until it is assigned to another stream.           */

   /*------------------------------------------------------------------------*/

   errchk = close(_fp->fd);

   _fp->fd = -1;



   /*------------------------------------------------------------------------*/

   /* If the FILE pointer was associated with a temporary file, look up that */

   /* temporary file's filename, and remove it.                              */

   /*------------------------------------------------------------------------*/

   if(remove_flag) remove(_tmpnams[fd]);  



   return (errchk);

}



fcvt.c/         1148595155  0     0     0       3044      `
/****************************************************************************/

/*  fcvt v3.3.2                                                             */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include "ctype.h"

#include "math.h"



extern int ltoa(long val, char *buffer);



#define MANTISSA_WORD 1

#define EXPONENT_WORD 0



char *fcvt(long double value, register int ndigit, int *decpt, int *sign)



{

    static char out[100]; 



    register int   digits = 0;         /* NUMBER OF DIGITS BEFORE .       */

    register char *pos    = out + 1;     

    register int   temp;



    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */

    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */



    /*--------------------------------------------------------------------*/

    /* IF TRYING TO CONVERT INFINITY, RETURN HUGE_VALL OF PROPER SIGN     */

    /*--------------------------------------------------------------------*/

    { 

       long *ptr = (long *)&value;



       if (((ptr[EXPONENT_WORD] >> 20) & 0x7ff) == 0x7ff) 

	  value = (ptr[EXPONENT_WORD] & 0x80000000) ? -HUGE_VALL : HUGE_VALL;

    }



    /*--------------------------------------------------------------------*/

    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */

    /*--------------------------------------------------------------------*/

    if (*sign = (value < 0)) value = -value;

    while (value > 0x7FFFFFFF) { value /= 10; digits++; }

    while (value && value < 1) { value *= 10; digits--; }



    /*--------------------------------------------------------------------*/

    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */

    /*--------------------------------------------------------------------*/

    pos   += temp    = ltoa((long)value, pos);

    *decpt = digits + temp; 



    /* if (digits < 0) */ ndigit += digits;



    /*--------------------------------------------------------------------*/

    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */

    /*--------------------------------------------------------------------*/

    if (ndigit > 0) do

    {

         value -= (long)value;

         *pos++ = (int)(value *= 10.0) + '0';

    }

    while (--ndigit);



    /*--------------------------------------------------------------------*/

    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */

    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */

    /*--------------------------------------------------------------------*/

    if (*--pos >= '5')

    {

	register char *ptr = pos;

	while ((*--ptr += 1) > '9') *ptr = '0';

	if (ptr == out) 

	   if (pos > out)   { *pos   = 0; *decpt += 1; return(out); }

	   else             { out[1] = 0;              return(out); }

    }

	

    *pos = 0;

    return(out + 1);

}



feof.c/         1148595155  0     0     0       829       `
/*****************************************************************************/

/*  FEOF.C v3.3.2                                                            */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/*    This file contains the function FEOF, which returns a 1 if an EOF      */

/*    has occured on that stream.  The function merely calls a macro         */

/*    that is defined in STDIO.H.                                            */

/*****************************************************************************/

#include <stdio.h>



_CODE_ACCESS int feof(FILE *_fp) { return (((_fp)->flags & _STATEOF)); }




ferror.c/       1148595155  0     0     0       827       `
/*****************************************************************************/

/*  FERROR.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/*    This file contains the function FERROR, which returns a 1 if an I/O    */

/*    error has occured on that stream.  The function merely calls a macro   */

/*    that is defined in STDIO.H.                                            */

/*****************************************************************************/

#include <stdio.h>



_CODE_ACCESS int ferror(FILE *_fp) { return (_STCHK(_fp, _STATERR)); }




fflush.c/       1148595155  0     0     0       5188      `
/*****************************************************************************/

/*  FFLUSH.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* FUNCTIONS:                                                                */

/*    fflush   -  Call _doflush for all streams that require flushing        */

/*    _doflush -  Flush one stream                                           */

/*****************************************************************************/

#include <stdio.h>

#include <_lock.h>

#include "file.h"



extern _DATA_ACCESS int _ft_end;



int _doflush(FILE *_fp);













/*****************************************************************************/

/* FFLUSH   -  Call _doflush for all streams that require flushing           */

/*                                                                           */

/*    This function returns a 0 upon success, and an EOF upon failure.       */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int fflush(register FILE *_fp)

{

   int result = 0;

 

   /*------------------------------------------------------------------------*/

   /* If _fp is not a NULL pointer, call _DOFLUSH for that stream.           */

   /* Otherwise, call _DOFLUSH for all file streams in the table that are    */

   /* active.                                                                */

   /*------------------------------------------------------------------------*/

   if (_fp) result = _doflush(_fp);

   else

   {

      int index;



      /*---------------------------------------------------------------------*/

      /* This is a critical section because it depends on the global	     */

      /* variable _ft_end.						     */

      /*---------------------------------------------------------------------*/

      _lock();

      for(index = 0; index < _ft_end; index++)

         if(_ftable[index].fd != -1) result |= _doflush(&_ftable[index]);

      _unlock();

   }

 

   return (result);

}













/*****************************************************************************/

/* _DOFLUSH -  Flush one stream                                              */

/*                                                                           */

/*    This function flushes the stream pointed to by _fp.  If the function   */

/*    is successful, it returns a 0.  If unsuccessful, it returns an EOF     */

/*                                                                           */

/*****************************************************************************/

int _doflush(FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*                                                                        */

   /*    num_write   -  The number of bytes to be written to the file        */

   /*    errchk      -  An indicator to see if WRITE was successful          */

   /*------------------------------------------------------------------------*/

   unsigned num_write = _fp->pos - _fp->buf;

   int errchk = 0;

 

   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if(_fp->fd == -1) return (EOF);



   /*------------------------------------------------------------------------*/

   /* If the stream is writable, and it has a buffer, call WRITE, and store  */

   /* its return value in errchk                                             */

   /*------------------------------------------------------------------------*/

   if(_STCHK(_fp, _MODEW)) errchk = write(_fp->fd, (char *)_fp->buf, num_write);

 

   /*------------------------------------------------------------------------*/

   /* If WRITE fails, set the error flag in the stream pointer, and return   */

   /* an EOF                                                                 */

   /*------------------------------------------------------------------------*/

   if(errchk < 0)

   {

      _SET(_fp, _STATERR);

      return (EOF);

   }

 

   /*------------------------------------------------------------------------*/

   /* Reset the buffer pointer, make files opened with the "+" flag          */

   /* available for wither reading or writing, and return a 0, indicating    */

   /* a success                                                              */

   /*------------------------------------------------------------------------*/

   _fp->pos          =  _fp->buf;

   _fp->buff_stop    =  NULL;

   if (_STCHK(_fp, _MODERW)) _UNSET(_fp, (_MODER | _MODEW));

   return 0;

 

}

 

fgetc.c/        1148595155  0     0     0       4142      `
/*****************************************************************************/

/*  FGETC.C v3.3.2                                                           */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    GETC     -  Get a character from a stream                              */

/*    GETCHAR  -  Get a character from stdin                                 */

/*    FGETC    -  Get a character from a stream                              */

/*****************************************************************************/

#include <stdio.h>

#include "file.h"



extern void _buff_read(FILE *_fp);

extern int  _rd_ok    (FILE *_fp);



extern _CODE_ACCESS int fgetc(register FILE *_fp);













/*****************************************************************************/

/* GETC  -  Get a character from a stream                                    */

/*                                                                           */

/*    This function is equivalent to FGETC.                                  */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int getc(FILE *_fp) { return (fgetc(_fp)); }













/*****************************************************************************/

/* GETCHAR  -  Get a character from stdin                                    */

/*                                                                           */

/*    This function calls a macro defined in STDIO.H, which calls FGETC with */

/*    stdin as its argument.                                                 */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int getchar(void) { return(_getchar()); }













/*****************************************************************************/

/* FGETC -  Get a character from a stream                                    */

/*****************************************************************************/

_CODE_ACCESS int fgetc(register FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* Make sure that it is OK to read from this stream.                      */

   /*------------------------------------------------------------------------*/

   if(! _rd_ok(_fp)) return (EOF);

   

   /*------------------------------------------------------------------------*/

   /* For non-buffered streams, call the lowlevel READ function.             */

   /*------------------------------------------------------------------------*/

   if(_BUFFMODE(_fp) == _IONBF)

   {

      int   errchk;

      char  result;



      errchk = read(_fp->fd, &result, 1);

      if(errchk <= 0)

      {

         _SET(_fp, (errchk == 0) ? _STATEOF : _STATERR);

         return (EOF);

      }



      return ((int)result);

   }



   /*------------------------------------------------------------------------*/

   /* If the buffer has been entirely read, or is empty, call _BUFF_READ to  */

   /* fill the buffer.                                                       */

   /*------------------------------------------------------------------------*/

   if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);

 

   /*------------------------------------------------------------------------*/

   /* If the buffer read was unsuccessful, return an EOF.  Otherwise, clear  */

   /* the _UNGETC flag in the stream, and return the next character.         */

   /*------------------------------------------------------------------------*/

   if(_STCHK(_fp, (_STATERR | _STATEOF))) return (EOF);

   _UNSET(_fp, _UNGETC);



   return ((int)*(_fp->pos++)); 

   

}



fgetpos.c/      1148595155  0     0     0       1018      `
/*****************************************************************************/

/*  FGETPOS.C v3.3.2                                                         */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/*    This function contains the function FGETPOS, which stores the current  */

/*    position in the file into the variable pointed to by _POS.  A 0 is     */

/*    returned upon success, and upon failure, ERRNO is set to 5, and a -1L  */

/*    is returned.                                                           */

/*****************************************************************************/

#include <stdio.h>

#include <errno.h>

#include "file.h"



_CODE_ACCESS int fgetpos(FILE *_fp, fpos_t *_pos)

{

   if((*_pos = ftell(_fp)) != -1L) return (0);

   else { errno = 5; return (-1);  }

}



fgets.c/        1148595155  0     0     0       7794      `
/*****************************************************************************/

/*  FGETS.C v3.3.2                                                           */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    FGETS    -  Get a string from a stream                                 */

/*    GETS     -  Get a string from stdin                                    */

/*    _DOFGETS -  Perform the main FGETS routine                             */

/*****************************************************************************/

#include <string.h>

#include <stdio.h>

#include "file.h"



extern int  _rd_ok(FILE *_fp);

extern void _buff_read(FILE *_fp);



static char *_dofgets(char *_ptr, register int _size, register FILE *_fp,

                      int _gets_flag);













/*****************************************************************************/

/* FGETS -  Get a string from a stream                                       */

/*                                                                           */

/*    This function calls _DOFGETS, with a 0 for the _GETS_FLAG argument.    */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS char *fgets(char *_ptr, register int _size, register FILE *_fp)

{

   return(_dofgets(_ptr, _size, _fp, 0));

}













/*****************************************************************************/

/* GETS  -  Get a string from stdin                                          */

/*                                                                           */

/*    This function calls FGETS with stdin as the stream argument.           */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS char *gets(char *_ptr) { return (_dofgets(_ptr, 1, stdin, 1)); }













/*****************************************************************************/

/* _DOFGETS -  Perform the main FGETS routine                                */

/*                                                                           */

/*    This function gets a string from the stream _FP.  It returns a pointer */

/*    to the string upon success, or NULL upon failure.                      */

/*                                                                           */

/*****************************************************************************/

static char *_dofgets(char *_ptr, register int _size, register FILE *_fp, 

                      int _gets_flag)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   unsigned    char     *next_nl    = NULL;

               char     *fpos       = _ptr;

               size_t   num_left    = _size -1,

                        num_to_read;

               int      skipped_nl  = 0;



   /*------------------------------------------------------------------------*/

   /* Make sure that the stream is readable.                                 */

   /*------------------------------------------------------------------------*/

   if(! _rd_ok(_fp) || _STCHK(_fp, _STATEOF) || (_size -1) < 0) return (NULL);



   /*------------------------------------------------------------------------*/

   /* If the stream is non buffered, read the string in one character at a   */

   /* time, using the lowlevel READ function.                                */

   /*------------------------------------------------------------------------*/

   if(_BUFFMODE(_fp) == _IONBF)

   {

      int errchk;

 

      while((errchk = read(_fp->fd, fpos, 1) > 0) && (*(fpos++) != '\n'));

 

      switch(errchk)

      {

         case  0 :

         case -1 : return (NULL);

      }

 

      *fpos = '\0';

 

      return (_ptr);

   }

 

   while((num_left > 0 || _gets_flag) && ! next_nl)

   {

      /*---------------------------------------------------------------------*/

      /* If the buffer is empty or completely read, fill it up.              */

      /*---------------------------------------------------------------------*/

      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);



      if (_STCHK(_fp, (_STATERR | _STATEOF)))

      {

          /*-----------------------------------------------------------------*/

          /* If we've read any characters, fall out of for loop, returning   */

          /* what we've read in.                                             */

          /*-----------------------------------------------------------------*/

          if (fpos != _ptr) break;

          /*-----------------------------------------------------------------*/

          /* Otherwise we have not read anything (some kind of error).       */

          /*-----------------------------------------------------------------*/

          return (NULL);

      }



      /*---------------------------------------------------------------------*/

      /* Determine the location of the next newline character (NEXT_NL).     */

      /*---------------------------------------------------------------------*/

      next_nl = (unsigned char *)memchr(_fp->pos, '\n', (_fp->buff_stop - 

                                        _fp->pos));



      /*---------------------------------------------------------------------*/

      /* Determine how many characters to read from the buffer.  If this     */

      /* function was called from GETS (_GETS_FLAG == 1), read until a       */

      /* newline character, EOF character, or the end of the buffer is       */

      /* encountered.  Do the same otherwise, but do not read any more       */

      /* characters than specified by NUM_LEFT.                              */

      /*---------------------------------------------------------------------*/

      num_to_read =  _fp->buff_stop - _fp->pos;

      num_to_read =  (next_nl) ? (next_nl - _fp->pos + 1) : num_to_read;

      num_to_read =  (_gets_flag) ? num_to_read :

                     (num_left < num_to_read) ? num_left : num_to_read;



      /*---------------------------------------------------------------------*/

      /* If this function was called from GETS (_GETS_FLAG == 1), do not     */

      /* retain a newline character if one is present                        */

      /*---------------------------------------------------------------------*/

      if(next_nl && _gets_flag)

      {

         num_to_read--;

         skipped_nl = 1;

      }



      /*---------------------------------------------------------------------*/

      /* Copy the characters, and update pointers and counters.              */

      /*---------------------------------------------------------------------*/

      memcpy(fpos, _fp->pos, num_to_read);

      _fp->pos += (skipped_nl + num_to_read);

      num_left -= num_to_read;

      fpos += num_to_read;

   }



   /*------------------------------------------------------------------------*/

   /* Tack on the NULL terminator, clear the _UNGETC flag and the _GETS_FLAG.*/

   /*------------------------------------------------------------------------*/

   *fpos = '\0';

   _UNSET(_fp, _UNGETC);

   _gets_flag = 0; 



   return(_ptr);

}



file.h/         1148595155  0     0     0       3327      `
/*****************************************************************************/

/*  FILE.H v3.3.2                                                            */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Macros and declarations used in lowlevel I/O functions.                   */

/*****************************************************************************/

#ifndef _FILE

#define _FILE



#include <linkage.h>



/*---------------------------------------------------------------------------*/

/* constants for file manipulations                                          */

/*---------------------------------------------------------------------------*/

#define  O_RDONLY    (0x0000) /* open for reading      */

#define  O_WRONLY    (0x0001) /* open for writing      */

#define  O_RDWR      (0x0002) /* open for read & write */

#define  O_APPEND    (0x0008) /* append on each write  */

#define  O_CREAT     (0x0200) /* open with file create */

#define  O_TRUNC     (0x0400) /* open with truncation  */

#define  O_BINARY    (0x8000) /* open in binary mode   */



/*---------------------------------------------------------------------------*/

/* lowlevel I/O declarations                                                 */

/*---------------------------------------------------------------------------*/

#ifdef __cplusplus

#define _DECL extern "C"

#else /* ! __cplusplus */

#define _DECL extern

#endif



#ifndef _OFF_T

#define _OFF_T

typedef long off_t;

#endif /* _OFF_T */



#ifndef SEEK_SET

#define SEEK_SET  (0x0000)

#endif /* SEEK_SET */

#ifndef SEEK_CUR

#define SEEK_CUR  (0x0001)

#endif /*SEEK_CUR */

#ifndef SEEK_END

#define SEEK_END  (0x0002)

#endif /* SEEK_END */



_DECL _CODE_ACCESS int   open(const char *path, unsigned flags, int mode);

_DECL _CODE_ACCESS int   read(int fildes, char *bufptr, unsigned cnt);

_DECL _CODE_ACCESS int   write(int fildes, const char *bufptr, unsigned cnt);

_DECL _CODE_ACCESS off_t lseek(int fildes, off_t offset, int origin);

_DECL _CODE_ACCESS int   close(int fildes);

_DECL _CODE_ACCESS int   unlink(const char *path);

_DECL _CODE_ACCESS int   rename(const char *old_name, const char *new_name);



_DECL _CODE_ACCESS int add_device(

    char     *name,			           

    unsigned  flags,

    int      (*dopen)(const char *path, unsigned flags, int llv_fd),

    int      (*dclose)(int dev_fd),

    int      (*dread)(int dev_fd, char *buf, unsigned count),

    int      (*dwrite)(int dev_fd, const char *buf, unsigned count),

    off_t    (*dlseek)(int dev_fd, off_t offset, int origin),

    int      (*dunlink)(const char *path),

    int      (*drename)(const char *old_name, const char *new_name));



#define _NSTREAM        10                   /* Size of stream table        */

#define _NDEVICE         3                   /* Size of device table        */



#define _SSA      (0x0000)             /* Single Stream allowed       */

#define _BUSY     (0x0001)             /* Device busy                 */

#define _MSA      (0x0002)             /* Multiple Streams Allowed    */



#undef _DECL



#endif /* _FILE */




fixdi.c/        1148595155  0     0     0       1206      `
/****************************************************************************/

/*  fixdi.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:29 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



  int  FIXFI (REAL x)

/*---------------------------------------------------------------------------*/

/* Convert REAL to integer, truncating towards zero.                         */

/* Produces saturated answers for out-of-range values.                       */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */

/* Handles denormalized numbers.                                             */

/*---------------------------------------------------------------------------*/

{ 



   long y = FIXFLI(x);

   if (y > (long)INT_MAX ) return INT_MAX ;

   if (y < (long)INT_MIN ) return INT_MIN ;

 

   return (int )y;



} /* FIXFx */



fixdli.c/       1148595155  0     0     0       1767      `
/****************************************************************************/

/*  fixdli.c         v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:29 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



     long  FIXFLI (REAL x)

/*---------------------------------------------------------------------------*/

/* Convert REAL to integer, truncating towards zero.                         */

/* Produces saturated answers for out-of-range values.                       */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */

/* Handles denormalized numbers.                                             */

/*---------------------------------------------------------------------------*/

{ 



   long  rslt; unsigned long  rfrc; int rexp;   /* frac and exp of result */



   REALasUNS(rfrc,x); rfrc &= ~MINUS;

   if ((rexp = (int)(rfrc >> 23 )) == 0) 

      return (long )0; /* denorm or 0 */



   rfrc = (rfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;    /* insert hidden bit */

   rexp = 127  + 32   -1 -rexp;

   if (rexp <= 0) {	/* overflow */

      rslt = LONG_MAX ;

      {unsigned long  u; REALasUNS(u,x); if (u & MINUS) rslt = LONG_MIN ;}

      return rslt;

   }

   if (rexp >= 32  ) return 0; /* underflow */

   rslt = rfrc;

   rslt = (unsigned long )(rslt << (32  - 23 -1)) >> rexp;

   {unsigned long  u; REALasUNS(u,x); if (u & MINUS) rslt = -rslt;}

   return rslt;



} /* FIXFx */




fixdlli.c/      1148595155  0     0     0       1778      `
/****************************************************************************/

/*  fixdlli.c         v3.3.2                                                */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* Generated by HAND, with hopes to generate automatically in the future */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



long long _fixdlli(float x)

/*---------------------------------------------------------------------------*/

/* Convert REAL to integer, truncating towards zero.                         */

/* Produces saturated answers for out-of-range values.                       */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */

/* Handles denormalized numbers.                                             */

/*---------------------------------------------------------------------------*/

{ 

   long long  rslt; unsigned long  rfrc; int rexp;   /* frac and exp of result */



   REALasUNS(rfrc,x); rfrc &= ~MINUS;

   if ((rexp = (int)(rfrc >> 23 )) == 0) 

      return (long )0; /* denorm or 0 */



   rfrc = (rfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;    /* insert hidden bit */

   rexp = 127  + 40   -1 -rexp;

   if (rexp <= 0) {	/* overflow */

      rslt = LLONG_MAX;

      {unsigned long  u; REALasUNS(u,x); if (u & MINUS) rslt = LLONG_MIN ;}

      return rslt;

   }

   if (rexp >= 40  ) return 0; /* underflow */

   rslt = rfrc;

   rslt = (unsigned long long)(rslt << (40  - 23 -1)) >> rexp;

   {unsigned long  u; REALasUNS(u,x); if (u & MINUS) rslt = -rslt;}

   return rslt;



} /* FIXFx */



fixdu.c/        1148595155  0     0     0       1269      `
/****************************************************************************/

/*  fixdu.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:30 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



unsigned  FIXFU (REAL x)

/*---------------------------------------------------------------------------*/

/* Convert REAL to unsigned, truncating towards zero.                        */

/* Produces saturated answers for out-of-range positive values.              */



/* Wrap-around behavior for negative values (returns all 1's for -1.0).      */



/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */

/* Handles denormalized numbers.                                             */

/*---------------------------------------------------------------------------*/

{ 



   unsigned long y = FIXFUL(x);

   if (y > (unsigned long)UINT_MAX ) return UINT_MAX ;

 

   return (int )y;



} /* FIXFy */




fixdul.c/       1148595155  0     0     0       1957      `
/****************************************************************************/

/*  fixdul.c         v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:31 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



unsigned long  FIXFUL (REAL x)

/*---------------------------------------------------------------------------*/

/* Convert REAL to unsigned, truncating towards zero.                        */

/* Produces saturated answers for out-of-range positive values.              */



/* Wrap-around behavior for negative values (returns all 1's for -1.0).      */



/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */

/* Handles denormalized numbers.                                             */

/*---------------------------------------------------------------------------*/

{ 



   unsigned long  rslt; unsigned long  rfrc; int rexp;   /* frac and exp of result */



   REALasUNS(rfrc,x);

 

   rfrc &= ~MINUS;

   if ((rexp = (int)(rfrc >> 23 )) == 0) 

      return (unsigned long )0; /* denorm or 0 */



   rfrc = (rfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;    /* insert hidden bit */

   rexp = 127  + 32   -1 -rexp;

   if (rexp < 0) { /* overflow  */



      {unsigned long  u; REALasUNS(u,x); if (u & MINUS) return (unsigned long )LONG_MIN ;}

   

      return ULONG_MAX ;

   }

   if (rexp >= 32  ) return (unsigned long )0; /* underflow */



   rslt = rfrc;

   rslt = (rslt << (32  - 23 -1)) >> rexp;

 

   {unsigned long  u;

    REALasUNS(u,x); 

    if (u & MINUS) 

	rslt = (((long )rslt) < 0) ? (unsigned long )LONG_MIN  : -rslt;}

 

   return rslt;



} /* FIXFy */




fixdull.c/      1148595155  0     0     0       1977      `
/****************************************************************************/

/*  fixdull.c         v3.3.2                                                */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



/* Generated by HAND, with hopes to generate automatically in the future */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



unsigned long long _fixdull (float x)

/*---------------------------------------------------------------------------*/

/* Convert REAL to unsigned, truncating towards zero.                        */

/* Produces saturated answers for out-of-range positive values.              */

/* Wrap-around behavior for negative values (returns all 1's for -1.0).      */

/* Handles +/- INFINITY, NAN (treated as out-of-range values).               */

/* Handles denormalized numbers.                                             */

/*---------------------------------------------------------------------------*/

{ 

   unsigned long long rslt; 

   unsigned long rfrc; int rexp; /* frac and exp of result */



   REALasUNS(rfrc,x);

 

   rfrc &= ~MINUS;

   if ((rexp = (int)(rfrc >> 23 )) == 0) 

      return (unsigned long long)0; /* denorm or 0 */



   rfrc = (rfrc & REAL_FRC_MASK) + REAL_HIDDEN_BIT;    /* insert hidden bit */

   rexp = 127  + 40   -1 -rexp;

   if (rexp < 0) { /* overflow  */



      {unsigned  u; REALasUNS(u,x); if (u & MINUS) return (unsigned long long)LLONG_MIN ;}

   

      return ULLONG_MAX ;

   }

   if (rexp >= 40  ) return (unsigned long long)0; /* underflow */



   rslt = rfrc;

   rslt = (rslt << (40  - 23 -1)) >> rexp;

 

   {unsigned  u;

    REALasUNS(u,x); 

    if (u & MINUS) 

	rslt = (((long long)rslt) < 0) ? (unsigned long long)LLONG_MIN : -rslt;}

 

   return rslt;



} /* FIXFy */




float.h/        1148595155  0     0     0       2845      `
/********************************************************************/

/* float.h  v3.3.2                                                  */

/* Copyright (c) 1996-2006 Texas Instruments Incorporated           */

/*    KEY:  FLT_     - APPLIES TO TYPE FLOAT                        */

/*          DBL_     - APPLIES TO TYPE DOUBLE                       */

/*          LDBL_    - APPLIES TO TYPE LONG DOUBLE                  */

/********************************************************************/

#ifndef _FLOAT

#define _FLOAT



#define FLT_RADIX                         2   /* RADIX OF EXPONENT         */

#define FLT_ROUNDS                        1   /* ROUND TO NEAREST          */



#define FLT_DIG                           6   /* DECIMAL PRECISION         */

#define FLT_MANT_DIG                     24   /* BITS IN MANTISSA          */

#define FLT_MIN_EXP                    -125   /* SMALLEST EXPONENT         */

#define FLT_MAX_EXP                     128   /* LARGEST EXPONENT          */

#define FLT_EPSILON        1.192092896E-07F   /* SMALLEST X WHERE 1+X != 1 */

#define FLT_MIN            1.175494351E-38F   /* SMALLEST POSITIVE VALUE   */

#define FLT_MAX            3.402823466E+38F   /* LARGEST POSITIVE VALUE    */

#define FLT_MIN_10_EXP                  -37   /* MIN POWER OF 10           */

#define FLT_MAX_10_EXP                   38   /* MAX POWER OF 10           */



#define DBL_DIG                           6   /* DECIMAL PRECISION         */

#define DBL_MANT_DIG                     24   /* BITS IN MANTISSA          */

#define DBL_MIN_EXP                    -125   /* SMALLEST EXPONENT         */

#define DBL_MAX_EXP                     128   /* LARGEST EXPONENT          */

#define DBL_EPSILON        1.192092896E-07F   /* SMALLEST X WHERE 1+X != 1 */

#define DBL_MIN            1.175494351E-38F   /* SMALLEST POSITIVE VALUE   */

#define DBL_MAX            3.402823466E+38F   /* LARGEST POSITIVE VALUE    */

#define DBL_MIN_10_EXP                  -37   /* MIN POWER OF 10           */

#define DBL_MAX_10_EXP                   38   /* MAX POWER OF 10           */



#define LDBL_DIG                          6   /* DECIMAL PRECISION         */

#define LDBL_MANT_DIG                    24   /* BITS IN MANTISSA          */

#define LDBL_MIN_EXP                   -125   /* SMALLEST EXPONENT         */

#define LDBL_MAX_EXP                    128   /* LARGEST EXPONENT          */

#define LDBL_EPSILON       1.192092896E-07F   /* SMALLEST X WHERE 1+X != 1 */

#define LDBL_MIN           1.175494351E-38F   /* SMALLEST POSITIVE VALUE   */

#define LDBL_MAX           3.402823466E+38F   /* LARGEST POSITIVE VALUE    */

#define LDBL_MIN_10_EXP                 -37   /* MIN POWER OF 10           */

#define LDBL_MAX_10_EXP                  38   /* MAX POWER OF 10           */



#endif


floor.c/        1148595155  0     0     0       838       `
/****************************************************************************/

/*  floor.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Thu Jul 10 18:28:34 CDT 2003 */

 

#undef _INLINE

#include "reald.h"



 REAL FLOORF(REAL x)

{



   if GEZF(x) {

     if LSSF(x,CNST( 32768.0)) return FLTIF(FIXFI(x));

   }

   else if GEQF(x,CNST(-32768.0))

   {

      if EQLF(x,FLTIF(FIXFI(x))) return x;

      else FLTIF(NEGF(FIXFI(ADDF(NEGF(x),ONE))));

   }



   {

      REAL y;

      REAL z = MODFF(x,&y); /* because LSZF macro wants &z */

      return (LSZF(z) ? SUBF(y,ONE) : y);

   }

} /* FLOORF */

fltid.c/        1148595155  0     0     0       908       `
/****************************************************************************/

/*  fltid.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:33 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



  REAL FLTIF (int  x)

/*---------------------------------------------------------------------------*/

/* Convert SIGNED (integer) to REAL (floating-pt).                           */

/*---------------------------------------------------------------------------*/



{



   return FLTLIF((long )x); /* grow and call FLTLIF routine to do real work */

 

} /* FLTxF */



fltlid.c/       1148595155  0     0     0       2188      `
/****************************************************************************/

/*  fltlid.c         v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:33 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



     REAL FLTLIF (long  x)

/*---------------------------------------------------------------------------*/

/* Convert SIGNED (integer) to REAL (floating-pt).                           */

/*---------------------------------------------------------------------------*/



{



   unsigned long  rfrc; int rexp; /* frc and exp of result */

   unsigned long  rslt;



   rfrc = x;

   if (rfrc == 0) return ZERO;

   if ((long )rfrc <= 0) rfrc = -rfrc;  /* *WANT* -most_neg == most_neg */



   rexp = 127  + 32   -2;

   if (rfrc < (((unsigned long )1)<<(32  /2))) {   /* halfword shift */

      rfrc <<= 32  /2; rexp -= 32  /2;

   }

   if (rfrc < (((unsigned long )1)<<(3* 32  /4))) { /* quarterword shift */

      rfrc <<= 32  /4; rexp -= 32  /4;

   }

   while (rfrc < (((unsigned long )1) << 32  -1)) { rfrc <<= 1; rexp -= 1; }

 

   /* align for mantissa field and round */

   #define  SHIFT_COUNT (32  - 23 -1)

   #if  (SHIFT_COUNT > 0)

      rslt = (unsigned long )(((rfrc >> (SHIFT_COUNT-1)) +1) >> 1);

   #else 

      rslt = (unsigned long )(rfrc << -SHIFT_COUNT);

   #endif 

   #undef  SHIFT_COUNT



   /*------------------------------------------------------------------------*/

   /* The exponent field in rfrc now holds 1 or maybe 2 if the fraction      */

   /* rounded up.  ADD in rexp to simultaneously combine exponent/fraction   */

   /* and also increment the exponent by the appropriate amount.             */

   /*------------------------------------------------------------------------*/

   rslt+= ((unsigned long )rexp) << 23 ;



   if (x < 0) rslt += MINUS;



   return_UNSasREAL(rslt);



} /* FLTxF */



fltllid.c/      1148595155  0     0     0       2185      `
/****************************************************************************/

/*  fltllid.c         v3.3.2                                                */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* Generated by HAND, with hopes to generate automatically in the future */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



float _fltllid(long long x)

/*---------------------------------------------------------------------------*/

/* Convert SIGNED (integer) to REAL (floating-pt).                           */

/*---------------------------------------------------------------------------*/

{

   unsigned long long rfrc; int rexp; /* frc and exp of result */

   unsigned long rslt;



   rfrc = x;

   if (rfrc == 0) return ZERO;

   if ((long long)rfrc <= 0) rfrc = -rfrc;  /* *WANT* -most_neg == most_neg */



   rexp = 127 + 40 -2;

   if (rfrc < (((unsigned long long)1)<<(40/2))) {   /* halfword shift */

      rfrc <<= 40/2; rexp -= 40/2;

   }

   if (rfrc < (((unsigned long long)1)<<(3*40/4))) { /* quarterword shift */

      rfrc <<= 40/4; rexp -= 40/4;

   }

   while (rfrc < (((unsigned long long)1) << 40-1)) { rfrc <<= 1; rexp -= 1; }

 

   /* align for mantissa field and round */

   #define  SHIFT_COUNT (40  - 23 -1)

   #if  (SHIFT_COUNT > 0)

      rslt = (unsigned long)(((rfrc >> (SHIFT_COUNT-1)) +1) >> 1);

   #else 

      rslt = (unsigned long)(rfrc << -SHIFT_COUNT);

   #endif 

   #undef  SHIFT_COUNT



   /*------------------------------------------------------------------------*/

   /* The exponent field in rfrc now holds 1 or maybe 2 if the fraction      */

   /* rounded up.  ADD in rexp to simultaneously combine exponent/fraction   */

   /* and also increment the exponent by the appropriate amount.             */

   /*------------------------------------------------------------------------*/

   rslt+= ((unsigned long)rexp) << 23 ;



   if (x < 0) rslt += MINUS;



   return_UNSasREAL(rslt);



} /* FLTxF */




fltud.c/        1148595155  0     0     0       922       `
/****************************************************************************/

/*  fltud.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:35 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



  REAL FLTUF (unsigned  x)

/*---------------------------------------------------------------------------*/

/* Convert UNSIGN (unsigned integer) to REAL (floating-pt).                  */

/*---------------------------------------------------------------------------*/



{



   return FLTULF((unsigned long )x); /* grow and call FLTULF routine to do real work */

 

} /* FLTyF */



fltuld.c/       1148595155  0     0     0       2098      `
/****************************************************************************/

/*  fltuld.c         v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:36 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



     REAL FLTULF (unsigned long  x)

/*---------------------------------------------------------------------------*/

/* Convert UNSIGN (unsigned integer) to REAL (floating-pt).                  */

/*---------------------------------------------------------------------------*/



{



   unsigned long  rfrc; int rexp; /* frc and exp of result */

   unsigned long  rslt;



   if ((rfrc = x) == (unsigned long )0) return ZERO;



   rexp = 127  + 32   -2;

   if (rfrc < (((unsigned long )1)<<(32  /2))) {  /* halfword shift */

      rfrc <<= 32  /2; rexp -= 32  /2;

   }

   if (rfrc < (((unsigned long )1)<<(3* 32  /4))) { /* quarterword shift */

      rfrc <<= 32  /4; rexp -= 32  /4;

   }

   while (rfrc < (((unsigned long )1) << 32  -1)) { rfrc <<= 1; rexp -= 1; }

 

   /* align for mantissa field and round */

   #define  SHIFT_COUNT (32  - 23 -1)

   #if  (SHIFT_COUNT >= 0)

      rslt = (unsigned long )(((rfrc >> (SHIFT_COUNT-1)) +1) >> 1);

   #else 

      rslt = (unsigned long )(rfrc << -SHIFT_COUNT);

   #endif 

   #undef  SHIFT_COUNT



   /*------------------------------------------------------------------------*/

   /* The exponent field in rfrc now holds 1 or maybe 2 if the fraction      */

   /* rounded up.  ADD in rexp to simultaneously combine exponent/fraction   */

   /* and also increment the exponent by the appropriate amount.             */

   /*------------------------------------------------------------------------*/

   rslt += ((unsigned long )rexp) << 23 ;



   return_UNSasREAL(rslt);



} /* FLTyF */



fltulld.c/      1148595155  0     0     0       2095      `
/****************************************************************************/

/*  fltulld.c         v3.3.2                                                */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* Generated by HAND, with hopes to generate automatically in the future */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



float _fltulld(unsigned long long x)

/*---------------------------------------------------------------------------*/

/* Convert UNSIGN (unsigned integer) to REAL (floating-pt).                  */

/*---------------------------------------------------------------------------*/

{

   unsigned long long rfrc; int rexp; /* frc and exp of result */

   unsigned long rslt;



   if ((rfrc = x) == (unsigned long long)0) return ZERO;



   rexp = 127 + 40 -2;

   if (rfrc < (((unsigned long long)1)<<(40/2))) {  /* halfword shift */

      rfrc <<= 40/2; rexp -= 40/2;

   }

   if (rfrc < (((unsigned long long)1)<<(3*40/4))) { /* quarterword shift */

      rfrc <<= 40/4; rexp -= 40/4;

   }

   while (rfrc < (((unsigned long long)1) << 40-1)) { rfrc <<= 1; rexp -= 1; }

 

   /* align for mantissa field and round */

   #define  SHIFT_COUNT (40  - 23 -1)

   #if  (SHIFT_COUNT >= 0)

      rslt = (unsigned long)(((rfrc >> (SHIFT_COUNT-1)) +1) >> 1);

   #else 

      rslt = (unsigned long)(rfrc << -SHIFT_COUNT);

   #endif 

   #undef  SHIFT_COUNT



   /*------------------------------------------------------------------------*/

   /* The exponent field in rfrc now holds 1 or maybe 2 if the fraction      */

   /* rounded up.  ADD in rexp to simultaneously combine exponent/fraction   */

   /* and also increment the exponent by the appropriate amount.             */

   /*------------------------------------------------------------------------*/

   rslt += ((unsigned long)rexp) << 23 ;



   return_UNSasREAL(rslt);



} /* FLTyF */




fmod.c/         1148595155  0     0     0       3992      `
/****************************************************************************/

/*  fmod.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:45 CDT 2000 */

 

#include "reald.h"



  REAL FMODF(REAL x, REAL y)

{

/*---------------------------------------------------------------------------*/

/* desired algorithm:                                                        */

/* {                                                                         */

/*    infinite_precision_float Xip, Yip, Q;                                  */

/*                                                                           */

/*    Xip = (infinite_precision_float)x;                                     */

/*    Yip = (infinite_precision_float)y;                                     */

/*    Q = Xip/Yip;                                                           */

/*    Q = Truncate_Towards_0(Q);                                             */

/*    return (REAL)(Xip - Yip*Q);                                            */

/* }                                                                         */

/*---------------------------------------------------------------------------*/

    EXPONENT_TYPE e;

    REAL f, Quo, Remaindr, absY;

    REAL X_Upper, X_Lower;

    REAL Y_Upper, Y_Lower;



    if EQZF(y) { errno = EDOM; return ZERO; }



    /* don't overflow doing abs!*/

    if NEQF(y, CNST(-3.402823466E+38) ) ABSF2(absY,y);



    if (EQLF(y, CNST(-3.402823466E+38) ) ||

        (NEQF(x, CNST(-3.402823466E+38) )) && (GEQF(absY, ABSF(x)))) {

       DIVF3(Quo, x, y);

       CPYF(Quo,TRUNCF(Quo));

       if EQLF(Quo, ZERO      ) return x;

       if EQLF(Quo, CNST(-1.0)) return ADDF(x, y);

       if EQLF(Quo, ONE       ) return SUBF(x, y);

       return x;

    }



    /*------------------------------------*/

    /* factor y into upper and lower bits */

    /*------------------------------------*/

    RIPF(y, f, e);

    {

       EXPONENT_TYPE x_e;

       int diff;

       FREXPF(x, &x_e);



       /* check for out-of-range quotient */

       if ((diff = (x_e - e) - (128 -1)) > 0) {

          REMF1(x, SCLF(y, diff));



       /* make sure that Y_Lower is expressable. */

       /* don't need to worry about X_Lower since x > y. */

       } else if ((diff = ((-125)  + 24  + 1) - e) > 0) {

          return SCLF(REMF(SCLF(x, diff), SCLF(y, diff)), -diff);

       }

    }

    Y_Upper = SCLF(ROUNDF(MPYF(f, CNST(4096.0) )),

                   e - (24 /2));

    SUBF3(Y_Lower, y,Y_Upper);



    /*----------------------------------------------------------------------*/

    /* Do long-hand division with factored pieces to avoid loosing ANY bits */

    /*----------------------------------------------------------------------*/

    CPYF(Remaindr,x);

    do {

       /*------------------------------------*/

       /* Get another batch of quotient bits */

       /*------------------------------------*/

       CPYF(Quo, TRUNCF(DIVF(Remaindr, y)));



       /*----------------------------------------------------*/

       /* Compute new Remaindr by forming:  Remaindr-(Quo*y) */

       /*----------------------------------------------------*/



       /* factor Remaindr into upper and lower bits*/

       RIPF(Remaindr, f, e);

       SCLF3(X_Upper,TRUNCF(MPYF(f,CNST(4096.0) )),

                     e-(24 /2));

       SUBF3(X_Lower, Remaindr, X_Upper);



       RIPF(Quo, f, e);

   

       SCLF3(Quo, TRUNCF(MPYF(f,CNST(1024.0) )),

                  e-((24 /2)-2));

       SUBF2(X_Upper, MPYF(Quo, Y_Upper));

       SUBF2(X_Lower, MPYF(Quo, Y_Lower));

       ADDF3(Remaindr, X_Upper, X_Lower);



    } while (GEQF(ABSF(Remaindr), absY));



    return Remaindr;

} /* FMODF */

fopen.c/        1148595155  0     0     0       10021     `
/*****************************************************************************/

/*  FOPEN.C v3.3.2                                                           */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* FUNCTIONS:                                                                */

/*    FOPEN       -  Open a file and return a pointer to it                  */

/*    FREOPEN     -  Switch a FILE pointer to a different stream             */

/*    _OPENFILE   -  Set file flags, and call lowlevel OPEN                  */

/*    _SEARCH_FP  -  Find an open slot in the file table                     */

/*****************************************************************************/

#include <stdlib.h>

#include <string.h>

#include <stdio.h>

#include <_lock.h>

#include "file.h"

 

extern _DATA_ACCESS int _ft_end;

extern _DATA_ACCESS void (*_cleanup_ptr)(void);



extern void   _cleanup(void);

 

static FILE *_search_fp(void);

static FILE *_openfile(const char *_fname, register FILE *_fp, const char

                       *_mode);





/*****************************************************************************/

/* FOPEN    -  Open a file and return a pointer to it                        */

/*                                                                           */

/*    This function calls _SEARCH_FP to locate an empty slot in the file     */

/*    table (_ftable), and calls _OPENFILE with it to open a stream to the   */

/*    file _FNAME.  It returns a pointer to the stream that was allocated,   */

/*    or NULL if it was not successful.                                      */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS FILE *fopen(const char *_fname, const char *_mode)

{

    FILE *f;



    /*-----------------------------------------------------------------------*/

    /* This is a critical section because search_fp looks for a new file     */

    /* slot in the global table _ftable.				     */

    /*-----------------------------------------------------------------------*/

    _lock();

    f = _openfile(_fname, _search_fp(), _mode);

    _unlock();

    return f;

}



 

/*****************************************************************************/

/* FREOPEN  -  Switch a FILE pointer to a different stream                   */

/*                                                                           */

/*    This function attempts to close any file associated with _FP, and then */

/*    reassigns _FP to the file _FNAME by calling _OPENFILE.  It returns a   */

/*    pointer to the stream if successful, or NULL if the function is not    */

/*    successful.                                                            */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS FILE *freopen(const char *_fname, const char *_mode, register FILE *_fp)

{

    FILE *f;



    /*-----------------------------------------------------------------------*/

    /* This is a critical section because it expects the same slot in the    */

    /* global table _ftable to be available.				     */

    /*-----------------------------------------------------------------------*/

    _lock();

    fclose(_fp); 

    f = _openfile(_fname, _fp, _mode);

    _unlock();

    return f;

}





/*****************************************************************************/

/* _SEARCH_FP  -  Find an open slot in the file table                        */

/*                                                                           */

/*    This function looks through the array _ftable, searching for a null    */

/*    pointer which indicates an empty slot.  It mallocs a stream for that   */

/*    slot, and assigns a pointer to it there, initializing it and returning */

/*    it to the calling function.                                            */

/*                                                                           */

/*****************************************************************************/

static FILE *_search_fp(void)

{

   static _DATA_ACCESS int init = 0;

   int index;



   /*-----------------------------------------------------------------------*/

   /* Initialize the file table to have 'empty' slots using -1.             */

   /*-----------------------------------------------------------------------*/

   if (!init)

       for (init = 1,index = 3; index < _NFILE; _ftable[index++].fd = -1);



   /*------------------------------------------------------------------------*/

   /* Search the file table for an empty slot.  Return a NULL is there       */

   /* aren't any available.                                                  */

   /*------------------------------------------------------------------------*/

   for(index = 0; (index < _ft_end) && _ftable[index].fd != -1; index++);

   if (index == _NFILE) return (NULL);

   if (index == _ft_end) _ft_end++;



   /*------------------------------------------------------------------------*/

   /* Initialize the new stream.                                             */

   /*------------------------------------------------------------------------*/

   memset(&_ftable[index], '\0', sizeof(FILE));



   return (&_ftable[index]);

}

 



/*****************************************************************************/

/* _OPENFILE   -  Set file flags, and call lowlevel OPEN                     */

/*                                                                           */

/*    This function sets FILE flags for reading or writing by the character  */

/*    string _MODE.  It then calls the lowlevel OPEN function to open the    */

/*    file, and assigns the file descriptor returned from that function into */

/*    the FD member of the stream.                                           */

/*                                                                           */

/*****************************************************************************/

static FILE *_openfile(const char *_fname, register FILE *_fp, const char 

                       *_mode)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   int         wr, 

               bin = 0, 

               plus = 0;

   unsigned    lflags = 0;



   if (! _fp) return (NULL);

 

   /*------------------------------------------------------------------------*/

   /* SETUP _CLEANUP_PTR SO THAT ALL OPENED FILES WILL BE CLOSED AT EXIT.    */

   /*------------------------------------------------------------------------*/

   _cleanup_ptr = _cleanup;

   

   /*------------------------------------------------------------------------*/

   /* Set the flags in the stream to reflect to I/O mode of the stream to be */

   /* opened.                                                                */

   /*------------------------------------------------------------------------*/

   wr    = _mode[0];

   if (_mode[1])

   {

      bin  = ((_mode[1] == 'b') || (_mode[2] == 'b'));

      plus = ((_mode[1] == '+') || (_mode[2] == '+'));

   }



   _fp->flags = 0;



   if(!plus)

      _SET(_fp, (wr == 'r') ? _MODER : 

                (wr == 'w' || wr == 'a') ? _MODEW : 0);



   _SET(_fp, (wr == 'a') ? _MODEA : 0);

   _SET(_fp, (bin)  ? _MODEBIN : 0);

   _SET(_fp, (plus) ? _MODERW  : 0);

 

   if(bin) lflags |= (O_BINARY);



   /*------------------------------------------------------------------------*/

   /* Set the flags in LFLAGS to reflect the flags that will be necessary to */

   /* call the lowlevel OPEN function properly for this stream.              */

   /*------------------------------------------------------------------------*/

   switch (wr)

   {

      case 'r' : lflags |= (plus) ? O_RDWR : O_RDONLY;

                 break;

 

      case 'a' : lflags |= (plus) ? O_RDWR : O_WRONLY;

                 lflags |= (O_APPEND | O_CREAT);

                 break;

 

      case 'w' : lflags |= (plus) ? O_RDWR : O_WRONLY;

                 lflags |= (O_TRUNC | O_CREAT);

                 break;

   }



   /*------------------------------------------------------------------------*/

   /* Call the lowlevel OPEN function, and store the returned file           */

   /* descriptor into the stream.  If the OPEN function fails, return NULL.  */

   /*------------------------------------------------------------------------*/

   if ((_fp->fd = open(_fname, lflags, 0666)) < 0) return (NULL);



   return (_fp);

}





/*****************************************************************************/

/* _CLEANUP   -  CLOSE ALL OPEN STREAMS.  THIS IS CALLED BY EXIT() IF A FILE */

/*               IS EVER OPENED OR A BUFFER IS EVER CREATED.                 */

/*****************************************************************************/

void _cleanup(void)

{

   int j;



   /*------------------------------------------------------------------------*/

   /* CLOSE ALL STREAMS THAT ARE CURRENTLY OPEN.                             */

   /*------------------------------------------------------------------------*/

   /* This is a critical section because it depends on the global variable   */

   /* _ft_end.								     */

   /*------------------------------------------------------------------------*/

   _lock();

   fclose(&_ftable[0]);

   for(j = 1; j < _ft_end; j++) 

       if (_ftable[j].fd > 0) fclose(&_ftable[j]); 

   _unlock();

}


format.h/       1148595155  0     0     0       2411      `
/*****************************************************************************/

/*  FORMAT.H v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Structures and macros used in printf and scanf                            */

/*****************************************************************************/

#ifndef __FORMAT_H

#define __FORMAT_H

#include <stdarg.h>







#define FORMAT_CONVERSION_BUFSIZE 400

#define F_CONVERSION_BUFSIZE      400

#define FLOAT_VALUE_BUFSIZE       100



#ifdef __cplusplus

extern "C" namespace std {

#else 

extern

#endif



  int _scanfi(void *inp, const char *_format, va_list _ap,

	      int (*_chkmbc)(void **inp, char **_format, int *num_read),

	      int (*_inpchar)(void **inp),

	      void (*_uninpchar)(void **inp, char outchar));

 

  /**************************************************************************/

  /* _FIELD STRUCTURE AND MACROS USED FOR PRINTF AND SCANF                  */

  /**************************************************************************/

  typedef struct {

    unsigned int flags;         /* Format flags */

    int          fwidth;        /* Field width */

    int          precision;     /* Field precision */

    char         conv;          /* Conversion specifier */

  } _PFIELD;

  

  typedef struct {

    unsigned int flags;         /* Format flags */

    int          fwidth;        /* Field width */

    int          precision;     /* Field precision */

    char         scanset[96];   /* Scanset used for '[' conversion */

    char         conv;          /* Conversion specifier */

  } _SFIELD;



#ifdef __cplusplus

}

#endif /* __cplusplus */



/****************/

/* PRINTF FLAGS */

/****************/



#define _PFMINUS  0x01

#define _PFPLUS   0x02

#define _PFSPACE  0x04

#define _PFPOUND  0x08

#define _PFZERO   0x10

 

/***************/

/* SCANF FLAGS */

/***************/



#define _SFSTAR   0x01

#define _SFCIRC   0x02



/****************/

/* MUTUAL FLAGS */

/****************/



#define _MFH      0x20

#define _MFL      0x40

#define _MFLD     0x80

#define _MFLL     0x100

#define _MFHH     0x200



#endif


formi32.h/      1148595155  0     0     0       6286      `
/****************************************************************************/

/*  formi32.h        v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:21 CDT 2000 */

 

#ifndef __formi32__

#define __formi32__



#if 0

/*---------------------------------------------------------------------------*/

/* Description of the IEEE 32-bit float format.                              */

/*                                                                           */

/* This file is used in conjunction with the c pre-processor to build        */

/* customized product sources.  It is carefully constructed so that comments */

/* are removed by the preprocessor and all expansions result in a minimum    */

/* disruption of surrounding code.                                           */

/*                                                                           */

/* All floating-point constants in this file must be expressed either        */

/* exactly or to *MORE* places than REAL_DIGITS (REAL_DIGITS+3 is suggested).*/

/*---------------------------------------------------------------------------*/

#endif



#if 0

/*---------------------------------------------------------------------------*/

/* REAL is described in terms of the canonical form:  +/- f * r**e           */

/* where: r is "radix",                                                      */

/*        e is "exponent" (an integer),                                      */

/*        f is fractional part (mantissa) and  1/r <= f < 1,                 */

/*---------------------------------------------------------------------------*/

#endif



#define REAL_RADIX     2  /* radix (r)                                       */

#define REAL_MANTISSA 24  /* radix digits in mantissa                        */

#define REAL_EMAX    128  /* max e for which +/- f has MANTISSA digits       */

#define REAL_EMIN  (-125) /* min e for which +/- f has MANTISSA digits       */

#define REAL_DIGITS    6  /* FLRF(REAL_MANTISSA-1)*Ln_RADIX/Ln_10)           */



#define Round_To_Even



#define IEEE /* don't define "IEEE" at all if not ieee format*/



#define if_IEEE_Hardware if (0) {

#define elsif_not_IEEE_Hardware } else {

#define endif_IEEE_Hardware }



#define REAL_EXP_BITS 8   /* bits in unsigned_exp_field                   */

#define REAL_FRC_BITS 23  /* bits in fraction_field                       */

#define REAL_EXP_BIAS 127 /* exponent = unsigned_exp_field - REAL_EXP_BIAS*/





#if BPLEAN==0 /* no next-smaller REAL?*/

   #undef LEAN_DIGITS

   #undef LEAN_EXP_BITS

   #undef LEAN_FRC_BITS

   #undef LEAN_EXP_BIAS

#else

   #error "LEAN_* not yet defined for this size LEAN"

#endif



#if 0

/*---------------------------------------------------------------------------*/

/* Absolute extremes of floating point range.                                */

/* f need not have full MANTISSA digits, but do not                          */

/* include consideration of NAN's, ZEROs, infinities.                        */

/* Express to *MORE* places than REAL_DIGITS.                                */

/*---------------------------------------------------------------------------*/

#endif

#define REAL_MOST_POS  CNST( 3.402823466E+38)

#define REAL_MOST_NEG  CNST(-3.402823466E+38)



#ifdef Support_DENORM

   #define REAL_LEAST_POS CNST( 1.401298464E-45)  

   #define REAL_LEAST_NEG CNST(-1.401298464E-45)  

   #define LEAST_POS_INVERTABLE_NOT_LEAST_POS 1

#else

   #define REAL_LEAST_POS CNST( 1.175494351e-38)

   #define REAL_LEAST_NEG CNST(-1.175494351e-38)

   #define LEAST_POS_INVERTABLE_NOT_LEAST_POS 0

#endif



#define REAL_LEAST_POS_INVERTABLE CNST(1.1754943508e-38)

/* usually (-EMIN<EMAX) ? RADIX**(EMIN-1) : 1/MOST_POS*/



#if 0

/*---------------------------------------------------------------------------*/

/* Constants derived from RADIX & MANTISSA needed for math.h routines.       */

/* Express to *MORE* places than REAL_DIGITS.                                */

/*---------------------------------------------------------------------------*/

#endif



#define RADIX                    CNST( 2.0) /* FLTIF(REAL_RADIX   */

#define MANTISSA                 CNST(24.0) /* FLTIF(REAL_MANTISSA*/



#define Ln_RADIX                 Ln_2   /* ln(RADIX) */

#define Sqrt_RADIX               Sqrt_2 /* sqrt(RADIX*/



#define RADIX_to(x)              SCLF(ONE,x) /* RADIX**x, x an integer      */



#define RADIX_to_Hlf_MANTISSA_M2 CNST(1024.0)     /*   RADIX**((MANTISSA/2)-2*/

#define RADIX_to_Hlf_MANTISSA_M1 CNST(2048.0) 	  /*   RADIX**((MANTISSA/2)-1*/

#define RADIX_to_Hlf_MANTISSA    CNST(4096.0) 	  /*    RADIX**( MANTISSA/2) */

#define RADIX_to_MANTISSA        CNST(16777216.0) /* RADIX**( MANTISSA    )  */



#define One_Over_RADIX          CNST(0.5)              /* RADIX**(-1         */

#define RADIX_to_M_Hlf_MANTISSA CNST(2.44140625e-4)   /* RADIX**(-MANTISSA/2)*/

#define RADIX_to_One_M_MANTISSA CNST(1.1920928955E-7)  /* RADIX**(1-MANTISSA)*/

#define RADIX_to_M_MANTISSA     CNST(5.9604644753E-8)  /* RADIX**( -MANTISSA)*/

#define RADIX_to_EMIN           CNST(2.35098870164E-38)	/* RADIX**(EMIN     )*/



#ifndef BPint

   #error "target props .h file must be included before REAL format .h file"

#endif



#define RND_GLITCH ((REAL_MANTISSA+1) <= BPint)

#define RND_P_GLITCH CNST( 16777216.0) /*\_RNDF glitch points. see fltsyntx.h*/

#define RND_M_GLITCH CNST(-16777215.0) /*/ if no round-to-even dont need thes*/



#define RSQRT_Sz_Newtons 3 /* (int)FLOOR(LOG2((MANTISSA-1)/5))+*/

#define SQRT_Sz_Newtons  2 /* (int)FLOOR(LOG2((MANTISSA-1)/5)) */

#define SQRT_CW_Newtons  3 /* (int)CEIL (LOG2( MANTISSA     ))-*/



#define EXP_Max CNST( 88.72283382) /* ln(MOST_POS   )*(1-RADIX**-MANTISSA)  */

#define EXP_Min CNST(-86.64339241) /* ln(RADIX**EMIN)*(1-RADIX**-MANTISSA)  */



#define POW_Ovfl CNST( 1418.0) /* FLOOR(16*ln(MOST_POS   )-1*/

#define POW_Unfl CNST(-1386.0) /* FLOOR(16*ln(RADIX**EMIN)+1*/



#define TANH_Max CNST(9.01091334725) /* (Ln_2+(MANTISSA+1)*Ln_RADIX)/2       */



#endif

fprintf.c/      1148595155  0     0     0       2879      `
/*****************************************************************************/

/*  FPRINTF.C v3.3.2                                                         */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    FPRINTF  -  Print formatted output to a stream                         */

/*    _OUTC    -  Put a character in a stream                                */

/*    _OUTS    -  Put a string in a stream                                   */

/*****************************************************************************/

#include <stdio.h>

#include "format.h"

#include <stdarg.h>

#include <string.h>

 

extern int _printfi(char **_format, va_list _ap, void *_op, 

                    int (*_outc)(char, void *), int (*_outs)(char *, void *));



static int _outc(char c, void *_op);

static int _outs(char *s, void *_op);





/*****************************************************************************/

/* FPRINTF  -  Print formatted output to a stream                            */

/*                                                                           */

/*    This function passes a the format string and an argument list to       */

/*    _PRINTFI, and writes the result string to the stream _FP.              */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int fprintf(FILE *_fp, const char *_format, ...)

{

   va_list  _ap;

   int rval;

   char *fptr = (char *)_format;

 

   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if(_fp->fd == -1) return (-1);



   va_start(_ap, _format);

   rval = _printfi(&fptr, _ap, (void *)_fp, _outc, _outs);

   va_end(_ap);

   return (rval);

}

 



/*****************************************************************************/

/* _OUTC -  Put a character in a stream                                      */

/*****************************************************************************/

static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }





/*****************************************************************************/

/* _OUTS -  Put a string in a stream                                         */

/*****************************************************************************/

static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }




fputc.c/        1148595155  0     0     0       4420      `
/*****************************************************************************/

/*  FPUTC.C v3.3.2                                                           */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    PUTC     -  Write a character to a stream                              */

/*    PUTCHAR  -  Write a character to stdout                                */

/*    FPUTC    -  Write a character to a stream                              */

/*****************************************************************************/

#include <stdio.h>

#include "file.h"



extern int _wrt_ok(FILE *_fp);

extern int _doflush(FILE *_fp);













/*****************************************************************************/

/* PUTC  -  Write a character to a stream                                    */

/*                                                                           */

/*    This function is equivalent to FPUTC.                                  */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int putc(int _x, FILE *_fp) { return(fputc(_x, _fp)); }













/*****************************************************************************/

/* PUTCHAR  -  Write a character to stdout                                   */

/*                                                                           */

/*    This function calls a macro defined in STDIO.H, which in turn calls    */

/*    FPUTC, with stdout as its stream argument.                             */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int putchar(int _x) { return(_putchar(_x)); }













/*****************************************************************************/

/* FPUTC -  Write a character to a stream                                    */

/*                                                                           */

/*    This function writes character _C into the stream specified by _FP.    */

/*    Upon success, it returns the character written.  Upon failure, it      */

/*    returns an EOF.                                                        */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int fputc(int _c, register FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* Make sure that the stream is writeable.                                */

   /*------------------------------------------------------------------------*/

   if(! _wrt_ok(_fp)) return (EOF);



   /*------------------------------------------------------------------------*/

   /* If the stream is non-buffered, call the lowlevel WRITE function.       */

   /*------------------------------------------------------------------------*/

   if(_BUFFMODE(_fp) == _IONBF)

   {

      char cbuf = (char)_c;



      if((write(_fp->fd, &cbuf, 1)) == -1)

      {

         _SET(_fp, _STATERR);

         return (EOF);

      }

      else return ((unsigned char)_c);

   }



   /*------------------------------------------------------------------------*/

   /* Put the character in the buffer.                                       */

   /*------------------------------------------------------------------------*/

   *(_fp->pos++) = (unsigned char)_c;



   /*------------------------------------------------------------------------*/

   /* If the buffer is full, or a line-buffered stream reached a newline     */

   /* character, flush it.                                                   */

   /*------------------------------------------------------------------------*/

   if((_fp->pos == _fp->bufend) || (_STCHK(_fp, _IOLBF) && _c == '\n'))

      if(_doflush(_fp))

      {

         _SET(_fp, _STATERR);

         return (EOF);

      }



   return((unsigned char)_c);

}



fputs.c/        1148595155  0     0     0       5194      `
/*****************************************************************************/

/*  FPUTS.C v3.3.2                                                           */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    PUTS  -  Write a string to stdout                                      */

/*    FPUTS -  Write a string to a stream                                    */

/*****************************************************************************/

#include <string.h>

#include <stdio.h>

#include "file.h"



extern int _wrt_ok(FILE *_fp);

extern int _doflush(FILE *_fp);













/*****************************************************************************/

/* PUTS  -  Write a string + newline to stdout.                              */

/*                                                                           */

/*    This function calls FPUTS, with stdout as the stream argument.         */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int puts(const char *_ptr) 

{ 

    int count = fputs(_ptr, stdout);

    count += fputs("\n", stdout); 

    return count;

}







/*****************************************************************************/

/* FPUTS -  Write a string to a stream                                       */

/*                                                                           */ 

/*    This function writes string _PTR to stream _FP, returning the number   */

/*    of characters written upon success, or an EOF upon failure.            */

/*                                                                           */ 

/*****************************************************************************/

_CODE_ACCESS int fputs(const char *_ptr, register FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   size_t   num_left, ptr_strlen;

   char     *fpos          = (char *)_ptr;

   int      room_left,

            flush_flag     = 0,

            num_to_write;



   /*------------------------------------------------------------------------*/

   /* Make sure that the stream is writeable.                                */

   /*------------------------------------------------------------------------*/

   if(! _wrt_ok(_fp)) return (EOF);

 

   room_left = (int)(_fp->bufend - _fp->pos);

   ptr_strlen = num_left = strlen(_ptr);



   /*------------------------------------------------------------------------*/

   /* If the stream is non-buffered, call the lowlevel WRITE function.       */

   /*------------------------------------------------------------------------*/

   if(_BUFFMODE(_fp) == _IONBF) 

   {

       int num_written = 0;



       while (num_left > 0)

       {

	   int write_return = write(_fp->fd, _ptr + num_written, num_left);

	   if (write_return < 0) 

	   { 

	       _SET(_fp, _STATERR); 

	       return (EOF);

	   }

	   else

	   {

	       num_written += write_return;

	       num_left    -= write_return;

	   }

       }



       return ptr_strlen;

   }

 

   /*------------------------------------------------------------------------*/

   /* Write the string into the buffer, flushing it when full.               */

   /*------------------------------------------------------------------------*/

   while(num_left > 0)

   {

      num_to_write = (num_left > room_left) ? room_left : num_left;

      if((_BUFFMODE(_fp) == _IOLBF) && memchr(fpos, '\n', num_to_write))

      { 

         num_to_write = (char *)memchr(fpos, '\n', num_to_write) - fpos + 1;

         flush_flag = 1;

      }

      memcpy(_fp->pos, fpos, num_to_write);



      /*---------------------------------------------------------------------*/

      /* Update pointers and counters.                                       */

      /*---------------------------------------------------------------------*/

      _fp->pos  += num_to_write;

      fpos      += num_to_write;

      num_left  -= num_to_write;

      room_left -= num_to_write;



      /*---------------------------------------------------------------------*/

      /* If the buffer is full, flush it.  Any I/O errors cause this         */

      /* function to exit, returning an EOF.                                 */

      /*---------------------------------------------------------------------*/

      if(room_left == 0 || flush_flag)

      {

         if(_doflush(_fp))

         {

            _SET(_fp, _STATERR);

            return (EOF);

         }

         room_left = (int)(_fp->bufend - _fp->pos);

         _SET(_fp, _MODEW);

         flush_flag = 0;

      }

   }

   return ptr_strlen;

}



frcaddd.c/      1148595155  0     0     0       580       `
/****************************************************************************/

/*  frcaddd.c        v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:37 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



/* use compiler support for bigint add */



frcaddd.h/      1148595155  0     0     0       767       `
/****************************************************************************/

/*  frcaddd.h        v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:16 CDT 2000 */

 

#ifndef __FRCADDF__

#define __FRCADDF__



#include "realdi.h"



#if (BPREAL == BPbigint) /* use compiler support for bigint add */



#elif (BPREAL == (BPbigint*2))

__EXTERN int FRCADDF(int lx, REAL_2UNS *lf, 

                     int rx, REAL_2UNS *rf);

#else

   #error "FRCADDF not yet implemented for this size REAL"

#endif



#endif /* __FRCADDF__ */




frcdivd.c/      1148595155  0     0     0       3178      `
/****************************************************************************/

/*  frcdivd.c        v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:37 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



unsigned long  FRCDIVF(unsigned long  l, unsigned long  r)

/*---------------------------------------------------------------------------*/

/* FRaCtional DIVide                                                         */

/* Forms the quotient of l/r (r is a fixed point                             */

/* operand in range 1..2-, with radix point at REAL_FRC_BITS).               */

/* Returns the quotient as a fixed point number in the range                 */

/* 0.5+..2-, with the radix point at REAL_FRC_BITS+1.                        */

/*---------------------------------------------------------------------------*/

{

   

   long  inv_div, rem, quo, t, rhi, rlo;



   /*------------------------------------------------------------------------*/

   /* Compute an approximate inverse of r, in the range 0.5..1.0,            */

   /* with radix point at IW bits                                            */

   /*------------------------------------------------------------------------*/

   rhi = r >> 23 - (32  /2-2) ; 

   /* linear approximation */

   inv_div = ((long )(( 1.411622 )*(((long )1)<<( (32  /2-2)  ))))  - ((((long )(( 0.470459 )*(((long )1)<<( (32  /2-2)  ))))  * rhi) >> (32  /2-2) );



   /* newton iteration */

   inv_div = ((((long )(( 2.0 )*(((long )1)<<( (32  /2-2)  ))))  - ((inv_div * rhi) >> (32  /2-2) )) * inv_div) >> (32  /2-2) ;

   inv_div = ((((long )(( 2.0 )*(((long )1)<<( (32  /2-2)  ))))  - ((inv_div * rhi) >> (32  /2-2) )) * inv_div) >> (32  /2-2) ;



   /*------------------------------------------------------------------------*/

   /* Long division.                                                         */

   /* Estimate the quotient in REAL_FRC_BITS * IW bits, keeping DW bits.     */

   /* Form the remainder in two steps to avoid intermediate overflow.        */

   /*------------------------------------------------------------------------*/

   rem = l; quo = 0; rlo = r & ((((long )1)<< 23 - (32  /2-2) )-1);

   do {

      t = ((rem >> (23 - (32  /2-2) ))* inv_div)>> (32  /2-2) *2- ((32  /2-2) -1) ;

      rem = (((rem << ((32  /2-2) -1) + (32  /2-2) - 23 )

             - rhi * t) << 23 - (32  /2-2) )

            - rlo * t;

      quo = (quo << ((32  /2-2) -1) ) + t;

   }

   while (quo < REAL_HIDDEN_BIT);



   /*------------------------------------------------------------------------*/

   /* Align radix point of result to REAL_FRC_BITS+1                         */

   /*------------------------------------------------------------------------*/



    quo >>= ((23 )/ ((32  /2-2) -1)  +1)* ((32  /2-2) -1)  - 23 -1;

    return quo;

} /* FRCDIVF */



frcdivd.h/      1148595155  0     0     0       740       `
/****************************************************************************/

/*  frcdivd.h        v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:17 CDT 2000 */

 

#ifndef __FRCDIVF__

#define __FRCDIVF__



#include "realdi.h"



#if (BPREAL == BPbigint)

__EXTERN biguns FRCDIVF(biguns l, biguns r);

#elif (BPREAL == (BPbigint*2))

__EXTERN int FRCDIVF(REAL_2UNS *p, REAL_2UNS *l, REAL_2UNS *r);



#else

   #error "FRCDIVF not yet implemented for this size REAL"

#endif



#endif /*__FRCDIVF__*/

frcmpyd.c/      1148595155  0     0     0       4220      `
/****************************************************************************/

/*  frcmpyd.c        v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Nov 19 14:26:14 CST 2003 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



 unsigned long FRCMPYF(unsigned long l, unsigned long r)

/*---------------------------------------------------------------------------*/

/* Fractional MultiPlY                                                       */

/* Forms the product (2*REAL_FRC_BITS bits) of l and r (each a fixed point   */

/* operand in range 1..2-, with radix point at REAL_FRC_BITS).               */

/* Returns uppermost bits as a fixed point number in the range               */

/* 1..4-, with the radix point at REAL_FRC_BITS+1.                           */

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

/* See also:								     */

/*                                                                           */

/* Knuth D., "The Art of Computer Programming", Volume 2, ch 4.2	     */

/* ("Floating Point Arithmetic")					     */

/*                                                                           */

/* Goldberg D., "What Every Computer Scientist Should Know About	     */

/* Floating-Point Arithmetic", ACM Computing Surveys, Vol 23, No 1, March    */

/* 1991									     */

/*                                                                           */

/* Goldberg D., "Computer arithmetic."  Appendix A in "Computer		     */

/* Architecture: A Quantitative Approach, Patterson and Hennessy.	     */

/*                                                                           */

/* IEEE-754 "IEEE Standard for Binary Floating-Point Arithmetic"             */

/*---------------------------------------------------------------------------*/

{

   /*------------------------------------------------------------------------*/

   /* Re-align the inputs, split them into halves,                           */

   /* form all the cross products and add 'em up.                            */

   /*------------------------------------------------------------------------*/



   unsigned long p, sticky;



   /*------------------------------------------------------------------------*/

   /* l and r come into this function as 24-bit float significands	     */

   /* (hidden bit, implied radix point, 23 fractional digits) in Q9.23	     */

   /* format.  (This assumes 32-bit float).				     */

   /*------------------------------------------------------------------------*/

   l <<= (32 -REAL_FRC_MSBs)/2 + 2; /* so hi word of product has one */

   r <<= (32 -REAL_FRC_MSBs)/2 + 2; /* rounding bit plus room f. sticky */



   /*------------------------------------------------------------------------*/

   /* l and r are now in Q3.29 format.  We do a Q3.29 * Q3.29 multiply to    */

   /* get a Q6.58 result.  We truncate this to the upper 32 bits, giving     */

   /* Q6.26, and shift right to finally get Q7.25 The truncated bits are     */

   /* stored in "sticky" and OR'd into the lowest bit for the rounding	     */

   /* which will happen in MPYF.c					     */

   /*------------------------------------------------------------------------*/

   {



      unsigned l0, l1, r0, r1;

      l1 = l & ((((unsigned long)1)<< (32/2))-1);

      r1 = r & ((((unsigned long)1)<< (32/2))-1);

      p = (unsigned long)l1 * r1 >> (32/2);

      sticky = (unsigned long)l1 * r1 << (32/2);



      l0 = l >> (32/2); p += (unsigned long)l0 * r1;

      r0 = r >> (32/2); p += (unsigned long)r0 * l1;



      sticky |= (unsigned long)l0 * r1 << (32/2);

      sticky |= (unsigned long)r0 * l1 << (32/2);



      p = (unsigned long)l0 * r0 + (p >> (32/2));



      sticky |= p & 0x1;



      return (p >> 1) | (sticky != 0);

   }



} /* FRCMPY */

frcmpyd.h/      1148595155  0     0     0       742       `
/****************************************************************************/

/*  frcmpyd.h        v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:18 CDT 2000 */

 

#ifndef __FRCMPYF__

#define __FRCMPYF__



#include "realdi.h"



#if (BPREAL == BPbigint)

__EXTERN biguns FRCMPYF(biguns l, biguns r);



#elif (BPREAL == (BPbigint*2))

__EXTERN int FRCMPYF(REAL_2UNS *p, REAL_2UNS *l, REAL_2UNS *r);



#else

   #error "FRCMPYF not yet implemented for this size REAL"

#endif



#endif /*__FRCMPYF__*/

fread.c/        1148595155  0     0     0       4825      `
/*****************************************************************************/

/*  FREAD.C v3.3.2                                                           */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    FREAD       -  Read a block of bytes from a stream                     */

/*****************************************************************************/

#include <string.h>

#include <stdio.h>

#include "file.h"

 

extern int  _rd_ok(FILE *_fp);

extern void _buff_read(FILE *_fp);











/*****************************************************************************/

/* FREAD -  Read a block of bytes from a stream                              */

/*                                                                           */

/*    This function reads _COUNT blocks of _SIZE size from stream _FP, and   */

/*    stores them in string _PTR.  The function returns the number of        */

/*    blocks read.                                                           */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS size_t fread(void *_ptr, size_t _size, size_t _count, FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   unsigned char     *fpos       = (unsigned char *)_ptr;

            size_t   num_left    = _size * _count,

                     num_read    = 0,

                     num_to_read = 0;

 

   /*------------------------------------------------------------------------*/

   /* Make sure that the file is readable.                                   */

   /*------------------------------------------------------------------------*/

   if(! _rd_ok(_fp) || _size == 0 || _count == 0) return (0);

 

   /*------------------------------------------------------------------------*/

   /* If the stream is non-buffered, call the lowlevel READ function.	     */

   /*------------------------------------------------------------------------*/

   if(_BUFFMODE(_fp) == _IONBF)

   {

       int num_read = 0;



       while (num_left > 0)

       {

	   int read_return = (size_t)(read(_fp->fd, 

					   (char *)fpos + num_read, num_left));

	   if (read_return < 0)

	   {

	       _SET(_fp, _STATERR);

	       return (num_read / _size);

	   }

	   else if (read_return == 0) 

	   {

	       _SET(_fp, _STATEOF);

	       return (num_read / _size);

	   }

	   else 

	   {

	       num_read += read_return;

	       num_left -= read_return;

	   }

       }



       return (num_read / _size);

   }

   

   while (num_left > 0)

   {

      /*---------------------------------------------------------------------*/

      /* If the buffer has been completely read, fill it up.  Exit the loop  */

      /* if an I/O error occurs, or the end of the file is reached.          */

      /*---------------------------------------------------------------------*/

      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop)  _buff_read(_fp);

      if(_STCHK(_fp, (_STATERR | _STATEOF))) break;



      /*---------------------------------------------------------------------*/

      /* Determine how many characters can fit in the buffer, and read them  */

      /* in.                                                                 */

      /*---------------------------------------------------------------------*/

      num_to_read = (num_left < (_fp->buff_stop - _fp->pos)) ?

                    num_left : (_fp->buff_stop - _fp->pos);

      memcpy(fpos, _fp->pos, num_to_read);



      /*---------------------------------------------------------------------*/

      /* Update pointers and counters.                                       */

      /*---------------------------------------------------------------------*/

      fpos += num_to_read;

      _fp->pos += num_to_read;

      num_read += num_to_read;

      num_left -= num_to_read; 

   }



   /*------------------------------------------------------------------------*/

   /* Clear the _UNGETC flag in the stream, and return the number of blocks  */

   /* read.                                                                  */

   /*------------------------------------------------------------------------*/

   _UNSET(_fp, _UNGETC);

 

   return (num_read / _size);

 

}

 


frexp.c/        1148595155  0     0     0       2195      `
/****************************************************************************/

/*  frexp.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:46 CDT 2000 */

 

#include "reald.h"



  REAL FREXPF(REAL x, int *exp)

/*---------------------------------------------------------------------------*/

/* Decompose x into f and e such that                                        */

/* x == f * RADIX**e and 1/RADIX <= abs(f) < 1                               */

/* Return e in *exp and f as function result.                                */

/*---------------------------------------------------------------------------*/

{



   {

   /* Deals properly with NAN, +/- INFINITY, +/- ZERO, denormalized numbers */

   

      REAL y;

      int uy, e;

    

      int *ptr;

      CPYF(y,x);

      ptr = (int *)(&y) + (((32 / 16 )-1)*(0 )) ;

      uy = *ptr;

   

      e = ((uy >> (16 - (8 +1) )) & ((1<< 8 )-1) ); /* maybe get compare to 0 free*/

   

      if (e == 0) /* +/- ZERO or denormalized? */

      {

         if EQZF(y) { *exp = 0; return x; } /* +/- ZERO */



         MPYF3(y,x,CNST(16777216.0) ); /* its not denormalized now! */

       

         uy = *ptr;

       

         e = ((uy >> (16 - (8 +1) )) & ((1<< 8 )-1) ) - 24 ;

      }

      else if (e == ((1<< 8 )-1) ) { /* infinities and NAN's */

         if      LSSF(y,CNST(-3.402823466E+38) ) { errno = EDOM; CPYF(y,CNST(-3.402823466E+38) );}

         else if GTRF(y,CNST( 3.402823466E+38) ) { errno = EDOM; CPYF(y,CNST( 3.402823466E+38) );}

         else                          { errno = EDOM; *exp = 0; return ZERO;}

         

      }

      e -= (127 -1) ;

   

      *exp = e;

    

     *ptr = (uy & ((1<<(16 -1))+(1<<(23 % 16 ))-1) ) | /* out with the old ...*/

             ((127 -1)  << (16 - (8 +1) ));       /* and in with the new */

      __asm(" ") ;/*make sure *ptr is written before trying to read y*/

    

      return y;

   }



} /* FREXPF */


fscanf.c/       1148595155  0     0     0       5663      `
/*****************************************************************************/

/*  FSCANF.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    FSCANF      -  Read formatted input from a stream                      */

/*    SCANF       -  Read formatted input from stdin                         */

/*    _INPCHAR    -  Get a character from the stream                         */

/*    _UNINPCHAR  -  Put a character back onto the stream                    */

/*    _CHKMBC     -  Check that the characters match the input               */

/*****************************************************************************/

#include <stdio.h>

#include "format.h"

#include <ctype.h>

#include <stdarg.h>

#include <stdlib.h>

#include <string.h>



static int _inpchar(void **inp);

static void _uninpchar(void **inp, char outchar);

static int _chkmbc(void **inp, char **_format, int *num_read);



/*****************************************************************************/

/* FSCANF   -  Read formatted input from a stream                            */

/*                                                                           */

/*    This function returns the number of arguments that were assigned a     */

/*    value.                                                                 */

/*                                                                           */ 

/*****************************************************************************/

_CODE_ACCESS int fscanf(FILE *_fp, const char *_fmt, ...)

{

   va_list _ap;

   va_start(_ap, _fmt);

 

   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if (_fp->fd == -1) return (EOF);



   return (_scanfi((void *)_fp, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));

   

}



/*****************************************************************************/

/* SCANF -  Read formatted input from stdin                                  */

/*                                                                           */ 

/*    This function returns the number of arguments that were assigned a     */

/*    value.                                                                 */

/*                                                                           */ 

/*****************************************************************************/ 

int scanf(const char *_fmt, ...)

{

   va_list _ap;

   va_start(_ap, _fmt);

 

   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if (stdin->fd == -1) return (EOF);



   return (_scanfi((void *)stdin, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));

 

}



/*****************************************************************************/

/* _INPCHAR -  Get a character from the stream                               */

/*****************************************************************************/

static int _inpchar(void **inp) { return (fgetc((FILE *)(*inp))); }



/*****************************************************************************/

/* _UNINPCHAR  -  Put a character back onto the stream                       */

/*****************************************************************************/

static void _uninpchar(void **inp, char outchar)

{ 

   ungetc(outchar, (FILE *)*inp);

}



/*****************************************************************************/

/* _CHKMBC  -  Check that the characters match the input                     */

/*                                                                           */

/*    Check that all characters in the format string that are not part of a  */

/*    conversion specification match the input, until the next '%' or the    */

/*    end of the format string is reached.  The function returns an EOF if   */

/*    the end of the file is reached prematurely, a 0 upon reaching the end  */

/*    of the format string, or a 1 if a '%' is encountered.                  */

/*                                                                           */

/*****************************************************************************/

static int _chkmbc(void **inp, char **_format, int *num_read)

{

   FILE        *_fp = (FILE *)*inp;

   signed char  c;



   /*------------------------------------------------------------------------*/

   /* If there is a white space character in the format statement, skip to   */

   /* the next non-white space character in the input.                       */

   /*------------------------------------------------------------------------*/

   while (isspace(**_format))

   {

      for(c = fgetc(_fp);isspace(c);c = fgetc(_fp)) (*num_read)++;

      ungetc(c, _fp);

      (*_format)++;

   }



   for(;(**_format != '%') && (**_format != '\0');)

      if (*((*_format)++) != (c = fgetc(_fp))) 

      {

         ungetc(c, _fp);

         return ((c == EOF) ? EOF : 0);

      }

      else (*num_read)++;



   if (**_format == '%') return 1;

   else return (0);

}




fseek.c/        1148595155  0     0     0       2342      `
/*****************************************************************************/

/*  FSEEK.C v3.3.2                                                           */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    FSEEK -  Reposition the file pointer of a stream                       */

/*****************************************************************************/

#include <stdio.h>

#include "file.h"



extern int _doflush(FILE *_fp);









/*****************************************************************************/ 

/* FSEEK -  Reposition the file pointer of a stream                          */

/*                                                                           */ 

/*    This funtion flushes stream _FP, clears the EOF and I/O Error flags,   */

/*    repositions the file pointer of the stream.  It returns a 0 upon       */

/*    success, and an EOF upon failure.                                      */

/*                                                                           */ 

/*****************************************************************************/ 

_CODE_ACCESS int fseek(register FILE *_fp, long _offset, int _ptrname)

{

   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if(_fp->fd == -1) return (EOF);



   /*------------------------------------------------------------------------*/

   /* When positioning to a location relative to the current location,       */

   /* adjust for the fact that there may be something in the buffer.         */

   /*------------------------------------------------------------------------*/

   if(_ptrname == SEEK_CUR && _STCHK(_fp, _MODER) && _fp->buff_stop)

      _offset -= (_fp->buff_stop - _fp->pos);



   _doflush(_fp);



   _UNSET(_fp, (_STATEOF | _UNGETC));

   

   if((lseek(_fp->fd, _offset, _ptrname)) == -1) return (EOF);

   

   return (0);

}

   

fsetpos.c/      1148595155  0     0     0       1044      `
/*****************************************************************************/

/*  FSETPOS.C v3.3.2                                                         */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    FSETPOS  -  Position the file indicator for stream _FP                 */

/*****************************************************************************/

#include <stdio.h>

#include "file.h"





/*****************************************************************************/

/* FSETPOS  -  Position the file indicator for stream _FP                    */

/*****************************************************************************/

_CODE_ACCESS int fsetpos(FILE *_fp, const fpos_t *_pos)

{

   return (fseek(_fp, *_pos, SEEK_SET));

}



ftell.c/        1148595155  0     0     0       3089      `
/*****************************************************************************/

/*  FTELL.C v3.3.2                                                           */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/

#include <errno.h>

#include <stdio.h>

#include "file.h"



/*****************************************************************************/

/* FTELL -  Get the location of the file pointer in a stream                 */

/*                                                                           */

/*    This function gets the current location of the file pointer for the    */

/*    given stream, and returns it after adjusting it for any inaccuracies   */

/*    that buffering might have caused.                                      */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS long ftell(FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   fpos_t  _pos;

   int   adjust   = 0;



   /*------------------------------------------------------------------------*/

   /* If the stream pointer given is not currently open, return a -1.        */

   /*------------------------------------------------------------------------*/

   if(_fp->fd == -1) { errno = 5; return (-1L);}



   /*------------------------------------------------------------------------*/

   /* For files in read mode, we must subtract the unread data in the buffer */

   /* from the location of the file pointer.  For files in write mode, we    */

   /* must add the data in the buffer that has not yet gone to disk.         */

   /*------------------------------------------------------------------------*/

   if(_STCHK(_fp, _MODER) && _fp->buff_stop > _fp->pos)

      adjust = -(_fp->buff_stop - _fp->pos);

   if(_STCHK(_fp, _MODEW)) adjust = (_fp->pos - _fp->buf); 

 

   /*------------------------------------------------------------------------*/

   /* Get the file pointer's position                                        */

   /*------------------------------------------------------------------------*/

   _pos = lseek(_fp->fd, 0L, SEEK_CUR);



   /*------------------------------------------------------------------------*/

   /* If the call to lseek was unsuccessful, return an -1                    */

   /*------------------------------------------------------------------------*/

   if(_pos < 0) { errno = 5; return (-1L);}



   /*------------------------------------------------------------------------*/

   /* Make the necessary adjustment, and return the value                    */

   /*------------------------------------------------------------------------*/

   _pos += adjust;

   return (_pos);

}




fwrite.c/       1148595155  0     0     0       7512      `
/*****************************************************************************/

/*  FWRITE.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    FWRITE   -  Write a block of bytes to a stream                         */

/*****************************************************************************/

#include <stdio.h>

#include "file.h"

#include <stdlib.h>

#include <string.h>

 

extern int _doflush(FILE *_fp);

extern int _wrt_ok(FILE *_fp);



 

/*****************************************************************************/

/* FWRITE   -  Write a block of bytes to a stream                            */

/*                                                                           */

/*    This function reads _COUNT blocks of size _SIZE from a buffer          */

/*    pointed to by _PTR, and writes them to stream _FP.  It returns the     */

/*    number of blocks successfully written.                                 */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS size_t fwrite(const void *_ptr, size_t _size, size_t _count,

                           register FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   unsigned char    *fpos       = (unsigned char *)_ptr;

   unsigned char    *nl_pos;

            size_t   buffer_size = (_fp->bufend - _fp->buf),

                     next_nl,

                     room_left;

            size_t   num_left    = _size * _count,

                     num_to_write,

                     num_written  = 0;



   /*------------------------------------------------------------------------*/

   /* Make sure that the stream is writeable.                                */

   /*------------------------------------------------------------------------*/

   if(! _wrt_ok(_fp) || _size == 0 || _count == 0) return (0);

 

   /*------------------------------------------------------------------------*/

   /* If the stream is non-buffered, call the lowlevel WRITE function.       */

   /*------------------------------------------------------------------------*/

   if(_BUFFMODE(_fp) == _IONBF) 

   {

       int num_written = 0;



       while (num_left > 0)

       {

	   int write_return = write(_fp->fd, 

				    (char *)fpos + num_written, num_left);

	   if (write_return <= 0) 

	   { 

	       _SET(_fp, _STATERR); 

	       return (num_written / _size);

	   }

	   else

	   {

	       num_written += write_return;

	       num_left    -= write_return;

	   }

       }



       return (num_written / _size);

   }

 

   room_left   = (_fp->bufend - _fp->pos);

   if (_STCHK(_fp, _IOLBF))

       next_nl = (char *)memchr(fpos, '\n', num_left) - (char *)fpos + 1;

 

   while (num_left > 0)

   {

      /*---------------------------------------------------------------------*/

      /* Determine how many characters should be written based on buffering  */

      /* mode.  For non-buffered streams, call the lowlevel WRITE function.  */

      /* For fully buffered streams, put as many characters in the buffer as */

      /* possible.  For line buffered streams, put characters into the       */

      /* util the buffer is full, the last character is reached, or a        */

      /* newline character is reached.                                       */

      /*---------------------------------------------------------------------*/

      switch (_BUFFMODE(_fp))

      {

         case _IOFBF : num_to_write = (room_left > num_left) ? 

                       num_left : room_left;

                       break;

 

         case _IOLBF : num_to_write = (room_left > next_nl) ? next_nl :

                       (room_left > num_left) ? num_left : room_left;

                       break;

 

         default     : return (0);

      }

 

      /*---------------------------------------------------------------------*/

      /* Write the data to the buffer, and update the buffer pointer and the */

      /* ROOM_LEFT coutner.                                                  */

      /*---------------------------------------------------------------------*/

      memcpy(_fp->pos, fpos, num_to_write);

      _fp->pos += num_to_write;

      room_left = (_fp->bufend - _fp->pos);



      /*---------------------------------------------------------------------*/

      /* If the buffer is full, or a newline character has been encountered  */

      /* on a line-buffered stream, flush it.                                */

      /*---------------------------------------------------------------------*/

      if (room_left == 0 || (_STCHK(_fp, _IOLBF) && num_to_write == next_nl))

      {

         if(_doflush(_fp))

         {

            _SET(_fp, _STATERR); 

            return (num_written / _size);

         }

         room_left = buffer_size;



         /*------------------------------------------------------------------*/

         /* The _DOFLUSH function clears the write flag on streams opened in */

         /* update mode.  Make sure that the write flag is still set here.   */

         /*------------------------------------------------------------------*/

         _SET(_fp, _MODEW);

      }



      /*---------------------------------------------------------------------*/

      /* Update pointers and counters.                                       */

      /*---------------------------------------------------------------------*/

      num_written += num_to_write;

      fpos += num_to_write;

      num_left -= num_to_write;

 

      /*---------------------------------------------------------------------*/

      /* For line-buffered streams, find the next occurance of a newline     */

      /* character.  If there are no more, and the remaining data will fit   */

      /* in the buffer, exit the loop where the remaining data will be moved */

      /* there.  Otherwise loop until this condition is true.                */

      /*---------------------------------------------------------------------*/

      if (_STCHK(_fp, _IOLBF))

      {

         nl_pos = (unsigned char *)memchr((fpos + 1), '\n', 

					  (num_left > 0) ? (num_left-1) : 0);

         if (! nl_pos)

         {

            if (num_left < room_left) break;

            else next_nl = buffer_size + 1;

         }

         else next_nl = (nl_pos - fpos) + 1;

      }

   }



   /*------------------------------------------------------------------------*/

   /* Copy the rest of the characters into the buffer for line-buffered      */

   /* streams.                                                               */

   /*------------------------------------------------------------------------*/

   if (_STCHK(_fp, _IOLBF))

   {

      memcpy(_fp->pos, fpos, num_left);

      num_written += num_left;

      _fp->pos += num_left;

   }

 

   return (num_written / _size);

}

 

gmtime.c/       1148595156  0     0     0       600       `
/****************************************************************************/

/*  gmtime v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <time.h>



_CODE_ACCESS struct tm *gmtime(const time_t *timer)

{

    time_t gtime = _tz.timezone; /* DIFFERENCE BETWEEN CURRENT TIME ZONE    */

				 /* AND GMT IN SECONDS                      */



    if (timer) gtime += *timer;

    return (localtime(&gtime));

}

gsm.h/          1148595156  0     0     0       5307      `
/****************************************************************************/

/*  gsm.h  v3.3.2                                                           */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#ifndef _GSMHDR

#define _GSMHDR

#include <linkage.h>



#define MAX_16 0x7fff

#define MIN_16 (-MAX_16-1)

#define MAX_32 0x7fffffff

#define MIN_32 (-MAX_32-1)



/*--------------------------------------------------------------------------*/

/* External variables used by ETSI basicop functions                        */

/*--------------------------------------------------------------------------*/

extern int Overflow;

extern int Carry;



/*--------------------------------------------------------------------------*/

/* Mappings for ETSI functions to built-in compiler intrinsics              */

/*--------------------------------------------------------------------------*/

#define L_add(a,b)     (_lsadd((a),(b)))

#define L_sub(a,b)     (_lssub((a),(b)))

#define L_negate(a)    (_lsneg(a))             

#define L_deposit_h(a) ((long)a<<16)        

#define L_deposit_l(a) ((long)a)

#define L_abs(a)       (_labss((a)))              

#define L_mult(a,b)    (_lsmpy((a),(b)))

#define L_mac(a,b,c)   (_smac((a),(b),(c)))   

#define L_macNs(a,b,c) (L_add_c((a),L_mult((b),(c))))

#define L_msu(a,b,c)   (_smas((a),(b),(c)))   

#define L_msuNs(a,b,c) (L_sub_c((a),L_mult((b),(c))))

#define L_shl(a,b)     (_lsshl((a),(b)))

#define L_shr(a,b)     (_lshrs((a),(b)))

#define L_shr_r(a,b)   (L_crshft_r((a),(b)))

#define L_shift_r(a,b) (L_shr_r(a,-(b)))



#define abs_s(a)       (_abss((a)))               

#define add(a,b)       (_sadd((a),(b)))   

#define sub(a,b)       (_ssub((a),(b)))   

#define extract_h(a)   ((unsigned)((a)>>16))  

#define extract_l(a)   ((int)a)               

#define	round(a)       (short)(_rnd(a)>>16)                  

#define mac_r(a,b,c)   ((short)(_smacr((a),(b),(c))>>16))

#define msu_r(a,b,c)   ((short)(_smasr((a),(b),(c))>>16))

#define mult_r(a,b)    ((short)(_smpyr((a),(b))>>16))

#define mult(a,b)      (_smpy((a),(b)))  

#define norm_l(a)      (_lnorm(a))

#define norm_s(a)      (_norm(a))                

#define negate(a)      (_sneg(a))                

#define shl(a,b)       (_sshl((a),(b)))

#define shr(a,b)       (_shrs((a),(b)))

#define shr_r(a,b)     (crshft_r((a),(b)))

#define shift_r(a,b)   (shr_r(a,-(b)))

#define div_s(a,b)     (divs(a,b))



/*--------------------------------------------------------------------------*/

/* Declarations for ETSI functions implemented as function calls (or        */

/* inline functions)                                                        */

/*--------------------------------------------------------------------------*/

#ifdef __cplusplus

extern "C"

{

#endif /* __cplusplus */



int          crshft_r(int x, int y);

long         L_crshft_r(long x, int y);

int          divs(int x, int y);

_IDECL long  L_add_c(long, long);

_IDECL long  L_sub_c(long, long);

_IDECL long  L_sat(long); 





/*--------------------------------------------------------------------------*/

/* Definitions of ETSI functions implemented as inline functions.           */

/*--------------------------------------------------------------------------*/



#ifdef _INLINE

/******************************************************************************/

/* Integer (32-bit) add with carry and overflow testing.                      */

/******************************************************************************/

static inline long L_add_c (long L_var1, long L_var2)

{   

    unsigned long     uv1   = L_var1;       

    unsigned long     uv2   = L_var2;

    int      cin            = Carry;

    unsigned long  result   = uv1 + uv2 + cin;

    

    Carry     = ((~result & (uv1 | uv2)) | (uv1 & uv2)) >> 31;

    Overflow  = ((~(uv1 ^ uv2)) & (uv1 ^ result)) >> 31;



    if (cin && result == 0x80000000) Overflow = 1;



    return (long)result;

}       



/******************************************************************************/

/* Integer (32-bit) subtract with carry and overflow testing.                 */

/******************************************************************************/

static inline long L_sub_c (long L_var1, long L_var2)

{

    unsigned long     uv1   = L_var1;       

    unsigned long     uv2   = L_var2;

    int      cin            = Carry;

    unsigned long  result   = uv1 + ~uv2 + cin;

    

    Carry     = ((~result & (uv1 | ~uv2)) | (uv1 & ~uv2)) >> 31;

    Overflow  = ((uv1 ^ uv2) & (uv1 ^ result)) >> 31;



    if (!cin && result == 0x7fffffff) Overflow = 1;



    return (long)result;

}



/******************************************************************************/

/* Saturate any result after L_addc or L_sub_c if overflow is set.            */

/******************************************************************************/

static inline long L_sat (long L_var1)

{

    int cin = Carry;



    return !Overflow ? L_var1 : (Carry = Overflow = 0, 0x7fffffff+cin);

}

#endif /* !_INLINE */



#ifdef __cplusplus

} /* extern "C" */

#endif /* __cplusplus */



#endif /* !_GSMHDR */




gsmfuncs.c/     1148595156  0     0     0       2134      `
/****************************************************************************/

/*  gsmfuncs v3.3.2                                                         */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <gsm.h>



/******************************************************************************/

/* Integer (32-bit) add with carry and overflow testing.                      */

/******************************************************************************/

_CODE_ACCESS long L_add_c (long L_var1, long L_var2)

{   

    unsigned long     uv1   = L_var1;       

    unsigned long     uv2   = L_var2;

    int      cin            = Carry;

    unsigned long  result   = uv1 + uv2 + cin;

    

    Carry     = ((~result & (uv1 | uv2)) | (uv1 & uv2)) >> 31;

    Overflow  = ((~(uv1 ^ uv2)) & (uv1 ^ result)) >> 31;



    if (cin && result == 0x80000000) Overflow = 1;



    return (long)result;

}       



/******************************************************************************/

/* Integer (32-bit) subtract with carry and overflow testing.                 */

/******************************************************************************/

_CODE_ACCESS long L_sub_c (long L_var1, long L_var2)

{

    unsigned long     uv1   = L_var1;       

    unsigned long     uv2   = L_var2;

    int      cin            = Carry;

    unsigned long  result   = uv1 + ~uv2 + cin;

    

    Carry     = ((~result & (uv1 | ~uv2)) | (uv1 & ~uv2)) >> 31;

    Overflow  = ((uv1 ^ uv2) & (uv1 ^ result)) >> 31;



    if (!cin && result == 0x7fffffff) Overflow = 1;



    return (long)result;

}

 

/******************************************************************************/

/* Saturate any result after L_addc or L_sub_c if overflow is set.            */

/******************************************************************************/

_CODE_ACCESS long L_sat (long L_var1)

{

    int cin = Carry;



    return !Overflow ? L_var1 : (Carry = Overflow = 0, 0x7fffffff+cin);

}

gsmvars.c/      1148595156  0     0     0       397       `
/****************************************************************************/

/*  gsmvars.c  v3.3.2                                                       */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <linkage.h>



_DATA_ACCESS int Overflow;

_DATA_ACCESS int Carry;


guard.cpp/      1148595156  0     0     0       3513      `
/*****************************************************************************/

/* guard.cpp v#####                                                          */

/* Copyright (c) 1996@%%%% Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ functions to for one-time initialization guard variables.



*/



#include "basics.h"

#include "runtime.h"



#ifdef __EDG_IA64_ABI



/*

These functions are used by the front end only if

IA64_ABI_USE_GUARD_ACQUIRE_RELEASE is TRUE.

*/



EXTERN_C int ABI_NAMESPACE::__cxa_guard_acquire(an_ia64_guard_ptr guard)

/*

If the guard variable indicates that the guarded variable has already

been initialized, return 0.  Otherwise, return 1.

*/

{

  int  initialize = FALSE;

#ifdef __eabi__

  /* EABI, check least significant bit of guard object == 0 */

  if ( ((*guard) & 0x1) == 0 ) {

#else

  char *first_byte = (char *)guard;

  if (*first_byte == 0) {

#endif

    initialize = TRUE;

  }  /* if */

  return initialize;

}  /* __cxa_guard_acquire */





EXTERN_C void ABI_NAMESPACE::__cxa_guard_release(an_ia64_guard_ptr guard)

/*

Called when the initialization of the guarded object is complete.

*/

{

#ifdef __eabi__

   /* EABI, Set least significant bit of the guard object */

   (*guard) |= 0x1;

#else

  /* Set the guard variable to indicate that the initialization is complete.

     A multi-threaded implementation would then release the lock. */

  char *first_byte = (char *)guard;

  *first_byte = 1;

#endif

}  /* __cxa_guard_release */





EXTERN_C void ABI_NAMESPACE::__cxa_guard_abort(an_ia64_guard_ptr guard)

/*

The initialization of the guarded object has been aborted due to an

exception being thrown.  Reset the guard so that the initialization 

will be tried again.

*/

{

   /* EABI, reset least significant bit */

#ifdef __eabi__

  *guard = ((*guard) >> 1) << 1;

#else

  *(char *)guard = 0;

#endif

}  /* __cxa_guard_abort */



#endif /* ifdef __EDG_IA64_ABI */





/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/


idiv.asm/       1148595156  0     0     0       3895      `
******************************************************************************

* idiv.asm  v3.3.2

* Copyright (c) 1997-2006 Texas Instruments Incorporated

******************************************************************************

	.include "c55xasm.i"

	.mmregs

	.cpl_on

	.arms_on

	.sect	".text"

	.model  call=internal ; This function is recognized by name 

			      ; in the compiler.

	.noremark 5108        ; The FRAME instructions used in this file are

                              ; safe wrt the P2/P3 pipeline difference



******************************************************************************

* 16-BIT SIGNED DIVIDE

*

* arg1 	 : dividend - T0  (U)

* arg2 	 : divisor  - T1  (V)

* return : quotient - T0  (Q == U / V)

*

*

* WARNING!  Changes to register defs in this function must be reflected in

* the constraint class DIVI_SET in ld3.md

******************************************************************************

	.global	I$$DIV

	.global __divi



I$$DIV:	.asmfunc

__divi:



******************************************************************************

* DETERMINE SIGN OF RESULT, TAKE ABSOLUTE VALUE OF OPERANDS

******************************************************************************

	SP = SP - #1			; allocate space



	AR4 = T1	         	; save D (for sign)

||	AC1 = |T1|             		; take absolute value of D



	AC0 = |T0|             		; take absolute value of Q

||	*SP(#0) = AC1         		; store D



******************************************************************************

* PERFORM DIVIDE

******************************************************************************

	bit(ST1, #ST1_SXMD) = #0 	; turn off SXM mode

||	repeat(#15)             	; repeat 16 times

	subc(*SP(#0), AC0, AC0)       	; divide step



	bit(ST1, #ST1_SXMD) = #1 	; turn on SXM mode



******************************************************************************

* QUOTIENT IS IN AC0_L, REMAINDER IS IN AC0_H

******************************************************************************

	AR4 = AR4 ^ T0			; determine sign of Q

        T0 = AC0			; discard remainder

	if (AR4 >= #0) goto RET1

	T0 = -T0              		; negate Q

RET1:

	SP = SP + #1		 	; deallocate frame



	return

	.endasmfunc



******************************************************************************

* 16-BIT SIGNED MODULUS

*

* arg1 	 : dividend  - T0  (U)

* arg2 	 : divisor   - T1  (V)

* return : remainder - T0  (Q == U % V)

*

*

* WARNING!  Changes to register defs in this function must be reflected in

* the constraint class REMI_SET in ld3.md

******************************************************************************

	.global	I$$MOD

	.global __remi



I$$MOD:	.asmfunc

__remi:

******************************************************************************

* DETERMINE SIGN OF RESULT, TAKE ABSOLUTE VALUE OF OPERANDS

******************************************************************************

	SP = SP - #1			; allocate frame

||	AC1 = |T1|



	AC0 = |T0|

||	*SP(#0) = AC1                   ; save off



******************************************************************************

* PERFORM DIVIDE

******************************************************************************

	bit(ST1, #ST1_SXMD) = #0 	; turn off SXM mode

||	repeat(#15)             	; repeat 16 times

	subc(*SP(#0), AC0, AC0)	        ; divide step



	bit(ST1, #ST1_SXMD) = #1 	; turn on SXM mode



******************************************************************************

* QUOTIENT IS IN ACO_L, REMAINDER IS IN AC0_H

******************************************************************************

	T1 = T0

	T0 = HI(AC0)		      	; extract remainder from AC0_H

	if (T1 >= #0) goto RET2

	T0 = -T0              		; negate Q

RET2:

	SP = SP + #1			; deallocate frame



	return                  	; return

	.endasmfunc

	.end






ieeed.h/        1148595156  0     0     0       2253      `
/****************************************************************************/

/*  ieeed.h          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:23 CDT 2000 */

 

#ifndef __ieeed__

#define __ieeed__



#include <limits.h>

#include "access.h"



__EXTERN double _absd(double x);

__EXTERN double _negd(double x);



__EXTERN double _addd(double left, double right);

__EXTERN double _subd(double left, double right);

__EXTERN double _mpyd(double left, double right);

__EXTERN double _divd(double left, double right);



__EXTERN int _cmpd(double left,

                 double right); /* <0 if LT, 0 if EQ, >0 if GT     */

                                /* no correct result if NaN source */



__EXTERN int _eqld(double left, double right);

__EXTERN int _neqd(double left, double right);

__EXTERN int _leqd(double left, double right);

__EXTERN int _geqd(double left, double right);

__EXTERN int _lssd(double left, double right);

__EXTERN int _gtrd(double left, double right);





/* char <-> double */

__EXTERN double        _fltcd(  signed char x);

__EXTERN double        _fltbd(unsigned char x);

__EXTERN   signed char _fixdc(double x);

__EXTERN unsigned char _fixdb(double x);



/* short <-> double */

__EXTERN double         _fltsid(         short x);

__EXTERN double         _fltusd(unsigned short x);

__EXTERN short          _fixdsi(double x);

__EXTERN unsigned short _fixdus(double x);



/* int <-> double */

__EXTERN double   _fltid(int      x);

__EXTERN double   _fltud(unsigned x);

__EXTERN int      _fixdi(double x);

__EXTERN unsigned _fixdu(double x);



/* long <-> double */

__EXTERN double        _fltlid(         long x);

__EXTERN double        _fltuld(unsigned long x);

__EXTERN long          _fixdli(double x);

__EXTERN unsigned long _fixdul(double x);





/* float <-> double */

__EXTERN float  _cvtdf(double x); /* slim from double to float  */

__EXTERN double _cvtfd(float  x); /* grow from float  to double */



#include "unaccess.h"



#endif /* __ieeed_*/


ieeemask.h/     1148595156  0     0     0       17693     `
/****************************************************************************/

/*  ieeemask.h       v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:19 CDT 2000 */

 

#ifndef __ieeemask__

#define __ieeemask__



#ifndef BPint

   #error "target properties .h file must be included before ieeemask.h"

#endif



#if defined(_TMS320C6x)

 #include <c6x.h>

#endif



#if 0

/*---------------------------------------------------------------------------*/

/* There are two ways to get at the bits associated with REAL:               */

/*                                                                           */

/* 1. Efficient size-specific casting:                                       */

/*    . for (BPREAL==   BPbigint) use {bigint crx; REALasINT(crx,x); ... etc}*/

/*    . for (BPREAL== 2*BPbigint) use {REAL_2UNS crx; crx.r=x; x.msh ...}    */

/*    These have also been size-abstracted as CREAL (pronounced "Cast REAL") */

/*      {CREAL crx; REALasCREAL(crx,x); ...etc}                              */

/*                                                                           */

/* 2. Slightly less efficient size-independent:                              */

/*       {bigint *pr = (bigint *)(&x)+MSBI_OFFSET;                           */

/*        msbi = *pr;   --fetch most significant bigint part                 */

/*        NEXT_MS(pr);  --advance ptr to next-most significant bigint part   */

/*    The macros MSI,LSI,MSBI,LSBI will allow access to the most/least       */

/*    significant int/bigint parts without having to declare pr.             */

/*                                                                           */

/* The pointer method is less efficient because most compilers cannot track  */

/* pointer usage sufficiently well to determine the variables changed when   */

/* writing through a pointer.  This causes many keep-it-in-a-register        */

/* opportunities to be lost around write sites.                              */

/* Furthermore, some compilers do not guarantee that reads and writes        */

/* through aliased pointer variables have *ANY* relationship with the        */

/* variables they alias and will optimize code such that desired data        */

/* dependencies are not maintained.  A sometimes-cure for this unfriendly    */

/* behavior is to insert an optmization fence before and after any use of a  */

/* pointer or a pointer cast.  ANSI specifies that char* is itself a fence   */

/* so if the REAL can be processed a char-at-a-time, use the MSC macros.     */

/*                                                                           */

/* Advantages of both models may be obtained by keeping REALs as CREALs      */

/* and using pointers to address of the CREAL version.                       */

/*---------------------------------------------------------------------------*/



/*---------------------------------------------------------------------------*/

/* CREAL casting type and associated operations.                          */

/*---------------------------------------------------------------------------*/

#endif

#if (BPREAL == BPbigint)

   union REAL_UNS_u {

      REAL r;

      biguns u;

   };

   typedef union REAL_UNS_u REAL_UNS;

   union REAL_INT_u {

      REAL r;

      bigint i;

   };

   typedef union REAL_INT_u REAL_INT;



 #ifdef Pointers_Might_Not_Work

  #if (defined(_TMS320C6x) && (BPbigint == BPint))

   #define REALasINT(I, R) (I)=(biguns)_ftoi(R)

   #define REALasUNS(U, R) (U)=_ftoi(R)

   #define INTasREAL(R, I) (R)=_itof((biguns)(I))

   #define UNSasREAL(R, U) (R)=_itof(U)



   #define return_REALasINT(R) return (biguns)_ftoi(R)

   #define return_REALasUNS(R) return _ftoi(R)

   #define return_INTasREAL(I) return _itof((biguns)(I))

   #define return_UNSasREAL(U) return _itof(U)



  #else

   #define REALasINT(I, R) do{REAL_INT XX; XX.r =(R); (I)= XX.i;}while(0)

   #define REALasUNS(U, R) do{REAL_UNS XX; XX.r =(R); (U)= XX.u;}while(0)

   #define INTasREAL(R, I) do{REAL_INT XX; XX.i =(I); (R)= XX.r;}while(0)

   #define UNSasREAL(R, U) do{REAL_UNS XX; XX.u =(U); (R)= XX.r;}while(0)



   #define return_REALasINT(R) do{REAL_INT XX; XX.r=(R); return XX.i;}while(0)

   #define return_REALasUNS(R) do{REAL_UNS XX; XX.r=(R); return XX.u;}while(0)

   #define return_INTasREAL(I) do{REAL_INT XX; XX.i=(I); return XX.r;}while(0)

   #define return_UNSasREAL(U) do{REAL_UNS XX; XX.u=(U); return XX.r;}while(0)

  #endif



 #else

   #define REALasINT(I, R) do{I= *(bigint *)&(R);}while (0)

   #define REALasUNS(U, R) do{U= *(biguns *)&(R);}while (0)

   #define INTasREAL(R, I) do{R= *(REAL *)&(I);}while (0)

   #define UNSasREAL(R, U) do{R= *(REAL *)&(U);}while (0)



   #define return_REALasINT(R) do{REAL mem_REAL=R;\

                                  return *(bigint *)&(mem_REAL);}while (0)

   #define return_REALasUNS(R) do{REAL mem_REAL=R;\

                                  return *(biguns *)&(mem_REAL);}while (0)

   #define return_INTasREAL(I) do{bigint mem_int=I;\

                                  return *(REAL *)&(mem_int);}while (0)

   #define return_UNSasREAL(U) do{biguns mem_uns=U;\

                                  return *(REAL *)&(mem_uns);}while (0)

 #endif



   #define CREAL REAL_UNS

   #define REALasCREAL(CR,R) CR.r=(R)

   #define CREALasREAL(R,CR) (R)=CR.r

   #define UNSasCREAL(CR,U) CR.u=(U)

   #define INTasCREAL(CR,I) CR.i=(I)

   #define CREAL_SAME(l, r) (l==r)



   #define CREAL_IS_NAN(CR) (CR.u>REAL_INFNAN)



#elif (BPREAL==(2*BPbigint))

   union REAL_2UNS_u {

      REAL r;

      struct {

      #if MSB_In_Hi_Addr

         biguns lsh;

         biguns msh;

      #else

         biguns msh;

         biguns lsh;

      #endif

      } u;

   };

   typedef union REAL_2UNS_u REAL_2UNS;

   union REAL_2INT_u {

      REAL r;

      struct {

      #if MSB_In_Hi_Addr

         bigint lsh;

         bigint msh;

      #else

         bigint msh;

         bigint lsh;

      #endif

      } u;

   };

   typedef union REAL_2INT_u REAL_2INT;



#if 0

   /* INTasREAL and UNSasREAL have no meaning unless I,U is *p++ */

#endif

   #if (MSB_In_Hi_Addr)

      #define INTasREAL(R,I) do{LSBI(R)= I; \

                                MSBI(R)= I;} while(0) /* I usually *p++ */

      #define UNSasREAL(R,U) do{LSBI(R)= U; \

                                MSBI(R)= U;} while(0) /* U usually *p++ */

   #else

      #define INTasREAL(R,I) do{MSBI(R)= I; \

                                LSBI(R)= I;} while(0) /* I usually *p++ */

      #define UNSasREAL(R,U) do{MSBI(R)= U; \

                                LSBI(R)= U;} while(0) /* U usually *p++ */

   #endif



   #define CREAL REAL_2UNS

   #define REALasCREAL(CR,R) CR.r=R

   #define CREALasREAL(R,CR) R=CR.r

   #if (MSB_In_Hi_Addr)

      #define UNSasCREAL(CR, U) CR.u.lsh=(U); CR.u.msh=(U)  /* u usually *p++*/

      #define INTasCREAL(CR, I) CR.u.lsh=(biguns)(I); CR.u.msh=(biguns)(I)

   #else

      #define UNSasCREAL(CR, U) CR.u.msh=(u); CR.u.lsh=(U)  /* u usually *p++*/

      #define INTasCREAL(CR, I) CR.u.msh=(biguns)(I); CR.u.lsh=(biguns)(I)

   #endif



   #define CREAL_SAME(l, r) (((l).u.msh == (r).u.msh) && \

                             ((l).u.lsh == (r).u.lsh))



   #define CREAL_IS_NAN(cr) ( ((cr).u.msh> REAL_INFNAN)|| \

                             (((cr).u.msh==REAL_INFNAN)&&((cr).u.lsh>0)))



   

   #define NEG2sCOMP(xx) xx.u.msh = ~xx.u.msh + ((xx.u.lsh = -xx.u.lsh) == 0)



   #define RIGHT_SHIFT(lll, nnn) do { \

      int sc = nnn; \

      if (sc >= BPbigint) {lll.u.lsh= lll.u.msh >> sc-BPbigint; lll.u.msh=0;} \

      else { lll.u.lsh = (lll.u.msh << BPbigint-sc) + (lll.u.lsh >> sc); \

             lll.u.msh >>= sc;}} while (0)



   #define LEFT_SHIFT(lll, nnn) do { \

      int sc = nnn; \

      if (sc >= BPbigint) {lll.u.msh= lll.u.lsh << sc-BPbigint; lll.u.lsh=0;} \

      else { lll.u.msh = (lll.u.lsh >> BPbigint-sc) + (lll.u.msh << sc); \

             lll.u.lsh <<= sc;}} while (0)



   #define RIGHT_SHIFT1(lll) do {\

      lll->u.lsh = (lll->u.lsh >> 1) + (lll->u.msh << BPbigint-1);\

      lll->u.msh >>=1;} while (0)



   #define LEFT_SHIFT1(lll) do {\

      lll->u.msh = (lll->u.msh << 1) + (lll->u.lsh >> BPbigint-1);\

      lll->u.lsh <<=1;} while (0)



   #define RSH1(msh,lsh) \

      do {lsh = (lsh >> 1) + (msh << BPbigint-1); msh >>=1;} while (0)



   #define LSH1(msh,lsh) \

      do {msh = (msh << 1) + (lsh >> BPbigint-1);  lsh <<=1;} while (0)



 #if 0 /* alternative implementations of interest */

   #define RSH1(msh,lsh) \

      do {lsh >>= 1; if (msh & 1) lsh += MINUS; msh >>=1;} while (0)

   #define LSH1(msh,lsh) \

      do {msh <<= 1; if ((int)lsh < 0) msh++; lsh <<=1;} while (0)

 #endif



#else

   #error "no casting type defined for this size REAL"

#endif





#if 0

/*---------------------------------------------------------------------------*/

/* For use with (int *) ptr to REAL, and (bigint *) ptr to REAL.             */

/*    MSC  is "Least Significant   char part"                                */

/*    MSI  is "Least Significant    int part"                                */

/*    MSBI is "Least Significant bigint part"                                */

/*    LSC  is "Least Significant   char part"                                */

/*    LSI  is "Least Significant    int part"                                */

/*    LSBI is "Least Significant bigint part"                                */

/*---------------------------------------------------------------------------*/

#endif



#if 0

/* The C6x compiler exhibits some rather unfriendly this week   */

/* in that it rearranges code with pointer casts such that      */

/* desired data dependencies are not forthcoming and code       */

/* function is unpredictable.  A fix for this is to isolate     */

/* reads and writes and place optimization blocks around them.  */

/* Probably this too will stop working some day.  Beware.       */

#endif

#define OPTIMIZATION_BLOCK asm(" ")



#if (MSB_In_Hi_Addr)

   #define MSC_OFFSET ((BPREAL/BPchar)-1) 

   #define LSC_OFFSET 0

   #define MSI_OFFSET ((BPREAL/BPint)-1) 

   #define LSI_OFFSET 0

   #define MSBI_OFFSET ((BPREAL/BPbigint)-1) 

   #define LSBI_OFFSET 0

   #define NEXT_MS_OFFSET (-1)

   #define CONSUME_MS(ptr) *ptr--

#else

   #define MSC_OFFSET 0

   #define LSC_OFFSET ((BPREAL/BPchar)-1)

   #define MSI_OFFSET 0

   #define LSI_OFFSET ((BPREAL/BPint)-1)

   #define MSBI_OFFSET 0

   #define LSBI_OFFSET ((BPREAL/BPbigint)-1) 

   #define NEXT_MS_OFFSET 1

   #define CONSUME_MS(ptr) *ptr++

#endif



#define LSC(right)  *((  char *)(&right)+ LSC_OFFSET)

#define LSI(right)  *((   int *)(&right)+ LSI_OFFSET)

#define LSBI(right) *((bigint *)(&right)+LSBI_OFFSET)



#define MSC(right)  *((  char *)(&right)+ MSC_OFFSET)

#define MSI(right)  *((   int *)(&right)+ MSI_OFFSET)

#define MSBI(right) *((bigint *)(&right)+MSBI_OFFSET)



#define NEXT_MS(ptr) ptr+=NEXT_MS_OFFSET;



#define SIGN_SET(right) (MSC(right) < 0)

#define MINUSC (((char)1)<<(BPchar-1))









#if 0

/*---------------------------------------------------------------------------*/

/* Masks and constants for the top BPbigint bits of the IEEE number.         */

/*---------------------------------------------------------------------------*/

#endif



#define MINUS (((biguns)1)<<(BPbigint-1))

#define UNORDERED (((int)1)<<(BPint-1)) /* return this for NAN input to CMPF */

#define MASK(bb) ((((bigint)1)<<(bb))-1) /*clear bits above the 2**(bb-1) bit*/



#define REAL_EXP_INFNAN ((((bigint)1)<<REAL_EXP_BITS)-1)

#define REAL_EXP_MASK   ((((bigint)1)<<REAL_EXP_BITS)-1)



#define REAL_FRC_MSBs (REAL_FRC_BITS % BPbigint) /*frc bits MS part*/

# if REAL_FRC_BITS > (BPbigint * 2)

#  error Sorry, this size float too large for this target.

# endif

#define REAL_FRC_MASK  ((((bigint)1)<< REAL_FRC_MSBs)-1)

#define REAL_HIDDEN_BIT (((bigint)1)<< REAL_FRC_MSBs)

#define REAL_INFNAN (((bigint)REAL_EXP_INFNAN) << REAL_FRC_MSBs)

#define REAL_NSNAN_BIT (((bigint)1)<<(REAL_FRC_MSBs-1)) /* MSB of fraction */

#define REAL_NAN    (REAL_INFNAN+1) /* signalling NAN */

#define REAL_NSNAN  (REAL_INFNAN+REAL_NSNAN_BIT) /*non-signl NAN*/



#define REAL_MOSTPOS (((REAL_EXP_INFNAN-1)<<REAL_FRC_MSBs)+REAL_FRC_MASK)

#define REAL_MOSTNEG (((REAL_EXP_INFNAN-1)<<REAL_FRC_MSBs)+REAL_FRC_MASK+MINUS)





#if 0

/*---------------------------------------------------------------------------*/

/* Similar constants as above,                                               */

/* but defined for LEAN, the next smallest floating point format.            */

/*---------------------------------------------------------------------------*/

#endif

   

#if !defined(LEAN) /* no smaller float size to provide conversion to/from */

   

#elif (BPLEAN == BPbigint)

   union LEAN_UNS_u {

      LEAN r;

      biguns u;

   };

   typedef union LEAN_UNS_u LEAN_UNS;

   union LEAN_INT_u {

      LEAN r;

      bigint i;

   };

   typedef union LEAN_INT_u LEAN_INT;



 #ifdef Pointers_Might_Not_Work

  #if (defined(_TMS320C6x) && (BPbigint == BPint))

   #define LEANasINT(I, R) (I)=(biguns)_ftoi(R)

   #define LEANasUNS(U, R) (U)=_ftoi(R)

   #define INTasLEAN(R, I) (R)=_itof((biguns)(I))

   #define UNSasLEAN(R, U) (R)=_itof(U)



   #define return_LEANasINT(R) return (biguns)_ftoi(R)

   #define return_LEANasUNS(R) return _ftoi(R)

   #define return_INTasLEAN(I) return _itof((biguns)(I))

   #define return_UNSasLEAN(U) return _itof(U)

  #else

   #define LEANasINT(I, R) do{LEAN_INT XX; XX.r =(R); (I)= XX.i;}while (0)

   #define LEANasUNS(U, R) do{LEAN_UNS XX; XX.r =(R); (U)= XX.u;}while (0)

   #define INTasLEAN(R, I) do{LEAN_INT XX; XX.i =(I); (R)= XX.r;}while (0)

   #define UNSasLEAN(R, U) do{LEAN_UNS XX; XX.u =(U); (R)= XX.r;}while (0)



   #define return_LEANasINT(R) do{LEAN_INT XX; XX.r=(R); return XX.i;}while (0)

   #define return_LEANasUNS(R) do{LEAN_UNS XX; XX.r=(R); return XX.u;}while (0)

   #define return_INTasLEAN(I) do{LEAN_INT XX; XX.i=(I); return XX.r;}while (0)

   #define return_UNSasLEAN(U) do{LEAN_UNS XX; XX.u=(U); return XX.r;}while (0)

  #endif

 #else

   #define LEANasINT(I, R) do{I= *(bigint *)&(R);}while (0)

   #define LEANasUNS(U, R) do{U= *(biguns *)&(R);}while (0)

   #define INTasLEAN(R, I) do{R= *(LEAN *)&(I);}while (0)

   #define UNSasLEAN(R, U) do{R= *(LEAN *)&(U);}while (0)



   #define return_LEANasINT(R) do{LEAN mem_LEAN=R;\

                                  return *(bigint *)&(mem_LEAN);}while (0)

   #define return_LEANasUNS(R) do{LEAN mem_LEAN=R;\

                                  return *(biguns *)&(mem_LEAN);}while (0)

   #define return_INTasLEAN(I) do{bigint mem_int=I;\

                                  return *(LEAN *)&(mem_int);}while (0)

   #define return_UNSasLEAN(U) do{biguns mem_uns=U;\

                                  return *(LEAN *)&(mem_uns);}while (0)

 #endif



   #define CLEAN LEAN_UNS

   #define LEANasCLEAN(CR,R) CR.r=(R)

   #define CLEANasLEAN(R,CR) (R)=CR.r

   #define UNSasCLEAN(CR,U) CR.u=(U)

   #define INTasCLEAN(CR,I) CR.i=(I)

   #define CLEAN_SAME(l, r) (l==r)



   #define LEAN_IS_NAN(CR) (CR.u>LEAN_INFNAN)



#elif (BPLEAN==(2*BPbigint))

   #define INTasLEAN(r,i) do{int j; bigint *q = &r; \  /* i usually *p++ */

                             for (j=1; j<=BPLEAN/BPbigint; j++)\

                                *q++ = i;}while(0)

   #define UNSasLEAN(r,u) do{int j; biguns *q = &r; \  /* u usually *p++ */

                             for (j=1; j<=BPLEAN/BPbigint; j++)\

                                *q++ = u;}while(0)



   union LEAN_2UNSs_u {

      LEAN r;

      struct {

      #if MSB_In_Hi_Addr

         biguns lsh;

         biguns msh;

      #else

         biguns msh;

         biguns lsh;

      #endif

      } u;

   };

   typedef union LEAN_2UNSs_u LEAN_2UNSs;



   #define CLEAN LEAN_2UNSs

   #define LEANasCLEAN(cr,R) cr.r=R

   #define CLEANasLEAN(R,cr) R=cr.r

   #if (MSB_In_Hi_Addr)

      #define UNSasCLEAN(cr, u) cr.u.lsh=(u); cr.u.msh=(u) /*u usually *p++*/

      #define INTasCLEAN(cr, i) cr.u.lsh=(biguns)(i); cr.u.msh=(biguns)(i)

   #else

      #define UNSasCLEAN(cr, u) cr.u.msh=(u); cr.u.lsh=(u) /*u usually *p++*/

      #define INTasCLEAN(cr, i) cr.u.msh=(biguns)(i); cr.u.lsh=(biguns)(i)

   #endif



   #define CLEAN_SAME(l, r) (((l).u.msh == (r).u.msh) && \

                             ((l).u.lsh == (r).u.lsh))



   #define CLEAN_IS_NAN(cr) ( ((cr).u.msh> LEAN_INFNAN)|| \

                             (((cr).u.msh==LEAN_INFNAN)&&((cr).u.lsh>0)))

#else

   #error "no casting type defined for this size LEAN format"

#endif





#define LEAN_EXP_INFNAN ((((bigint)1)<<LEAN_EXP_BITS)-1)

#define LEAN_EXP_MASK ((((bigint)1)<<LEAN_EXP_BITS)-1)



#define LEAN_EXP_INFNAN ((((bigint)1)<<LEAN_EXP_BITS)-1)

#define LEAN_EXP_MASK   ((((bigint)1)<<LEAN_EXP_BITS)-1)



#define LEAN_FRC_MSBs (LEAN_FRC_BITS % BPbigint) /*frc bits MS part*/

#define LEAN_FRC_MASK  ((((bigint)1)<< LEAN_FRC_MSBs)-1)

#define LEAN_HIDDEN_BIT (((bigint)1)<< LEAN_FRC_MSBs)

#define LEAN_INFNAN (((bigint)LEAN_EXP_INFNAN) << LEAN_FRC_MSBs)

#define LEAN_NSNAN_BIT (((bigint)1)<<(LEAN_FRC_MSBs-1)) /* MSB of fraction */

#define LEAN_NAN    (LEAN_INFNAN+1) /* signalling NAN */

#define LEAN_NSNAN  (LEAN_INFNAN+LEAN_NSNAN_BIT) /*non-signl NAN*/



#endif /* __ieeemask__ */


imaxabs.c/      1148595156  0     0     0       422       `
/*****************************************************************************/

/* imaxabs v3.3.2                                                            */

/* Copyright (c) 2003-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/

#include <stdint.h>



intmax_t imaxabs(intmax_t i)

{

    if (i < 0) i = -i;

    return i;

}

imaxdiv.c/      1148595156  0     0     0       505       `
/****************************************************************************/

/*  imaxdiv  v3.3.2                                                         */

/*  Copyright (c) 2003-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <inttypes.h>



imaxdiv_t imaxdiv(intmax_t num, intmax_t den)

{

    imaxdiv_t rv;

    

    rv.quot = num / den;

    rv.rem  = num - (rv.quot * den);



    return rv;

}


intrindefs.h/   1148595156  0     0     0       338       `
/****************************************************************************/

/*  intrindefs.h  v3.3.2                                                    */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <gsm.h>

inttypes.h/     1148595156  0     0     0       6811      `
/*****************************************************************************/

/* INTTYPES.H v3.3.2                                                         */

/* Copyright (c) 2002-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/

#ifndef _INTTYPES_H_

#define _INTTYPES_H_



#include <stdint.h>



/* 7.8 Format conversion of integer types */



typedef struct { intmax_t quot, rem; } imaxdiv_t;



/* 

   According to footnotes in the 1999 C standard, "C++ implementations

   should define these macros only when __STDC_FORMAT_MACROS is defined

   before <inttypes.h> is included." 

*/

#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS)



/* 7.8.1 Macros for format specifiers */



#if 0 || 0 || 0 || \

    defined(__TMS320C55X_PLUS_BYTE__)

#define PRId8 		"d"

#define PRIi8 		"i"

#define PRIo8 		"o"

#define PRIu8 		"u"

#define PRIx8 		"x"

#define PRIX8 		"X"

#define SCNd8 		"hhd"

#define SCNi8 		"hhi"

#define SCNo8 		"hho"

#define SCNu8 		"hhu"

#define SCNx8 		"hhx"

#endif



#define PRIdLEAST8     	"d"

#define PRIiLEAST8     	"i"

#define PRIoLEAST8     	"o"

#define PRIuLEAST8     	"u"

#define PRIxLEAST8     	"x"

#define PRIXLEAST8     	"X"

#define PRIdFAST8     	"d"

#define PRIiFAST8     	"i"

#define PRIoFAST8     	"o"

#define PRIuFAST8     	"u"

#define PRIxFAST8     	"x"

#define PRIXFAST8     	"X"

#define PRId16		"d"

#define PRIi16		"i"

#define PRIo16		"o"

#define PRIu16		"u"

#define PRIx16		"x"

#define PRIX16		"X"

#define PRIdLEAST16    	"d"

#define PRIiLEAST16    	"i"

#define PRIoLEAST16    	"o"

#define PRIuLEAST16    	"u"

#define PRIxLEAST16    	"x"

#define PRIXLEAST16    	"X"

#define PRIdFAST16    	"d"

#define PRIiFAST16    	"i"

#define PRIoFAST16    	"o"

#define PRIuFAST16    	"u"

#define PRIxFAST16    	"x"

#define PRIXFAST16    	"X"



#if defined(__TMS320C55X_PLUS_BYTE__)

#define SCNdLEAST8 	"hhd"

#define SCNiLEAST8 	"hhi"

#define SCNoLEAST8 	"hho"

#define SCNuLEAST8 	"hhu"

#define SCNxLEAST8 	"hhx"

#define SCNdFAST8 	"d"

#define SCNiFAST8 	"i"

#define SCNoFAST8 	"o"

#define SCNuFAST8 	"u"

#define SCNxFAST8 	"x"

#define SCNd16		"d"

#define SCNi16		"i"

#define SCNo16		"o"

#define SCNu16		"u"

#define SCNx16		"x"

#define SCNdLEAST16 	"d"

#define SCNiLEAST16 	"i"

#define SCNoLEAST16 	"o"

#define SCNuLEAST16 	"u"

#define SCNxLEAST16 	"x"

#define SCNdFAST16 	"d"

#define SCNiFAST16 	"i"

#define SCNoFAST16 	"o"

#define SCNuFAST16 	"u"

#define SCNxFAST16 	"x"

#elif defined(__TMS320C2000__) || defined(_TMS320C5XX) || defined(__TMS320C55X__)

#define SCNdLEAST8 	"d"

#define SCNiLEAST8 	"i"

#define SCNoLEAST8 	"o"

#define SCNuLEAST8 	"u"

#define SCNxLEAST8 	"x"

#define SCNdFAST8 	"d"

#define SCNiFAST8 	"i"

#define SCNoFAST8 	"o"

#define SCNuFAST8 	"u"

#define SCNxFAST8 	"x"

#define SCNd16		"d"

#define SCNi16		"i"

#define SCNo16		"o"

#define SCNu16		"u"

#define SCNx16		"x"

#define SCNdLEAST16 	"d"

#define SCNiLEAST16 	"i"

#define SCNoLEAST16 	"o"

#define SCNuLEAST16 	"u"

#define SCNxLEAST16 	"x"

#define SCNdFAST16 	"d"

#define SCNiFAST16 	"i"

#define SCNoFAST16 	"o"

#define SCNuFAST16 	"u"

#define SCNxFAST16 	"x"

#elif defined(_TMS320C6X) || defined(__TMS470__) || defined(__MSP430__)

#define SCNdLEAST8 	"hhd"

#define SCNiLEAST8 	"hhi"

#define SCNoLEAST8 	"hho"

#define SCNuLEAST8 	"hhu"

#define SCNxLEAST8 	"hhx"

#define SCNdFAST8 	"d"

#define SCNiFAST8 	"i"

#define SCNoFAST8 	"o"

#define SCNuFAST8 	"u"

#define SCNxFAST8 	"x"

#define SCNd16		"hd"

#define SCNi16		"hi"

#define SCNo16		"ho"

#define SCNu16		"hu"

#define SCNx16		"hx"

#define SCNdLEAST16 	"hd"

#define SCNiLEAST16 	"hi"

#define SCNoLEAST16 	"ho"

#define SCNuLEAST16 	"hu"

#define SCNxLEAST16 	"hx"

#define SCNdFAST16 	"d"

#define SCNiFAST16 	"i"

#define SCNoFAST16 	"o"

#define SCNuFAST16 	"u"

#define SCNxFAST16 	"x"

#endif



#define PRId32		"ld"

#define PRIi32		"li"

#define PRIo32		"lo"

#define PRIu32		"lu"

#define PRIx32		"lx"

#define PRIX32		"lX"

#define PRIdLEAST32    	"ld"

#define PRIiLEAST32    	"li"

#define PRIoLEAST32    	"lo"

#define PRIuLEAST32    	"lu"

#define PRIxLEAST32    	"lx"

#define PRIXLEAST32    	"lX"

#define PRIdFAST32    	"ld"

#define PRIiFAST32    	"li"

#define PRIoFAST32    	"lo"

#define PRIuFAST32    	"lu"

#define PRIxFAST32    	"lx"

#define PRIXFAST32    	"lX"

#define SCNd32		"ld"

#define SCNi32		"li"

#define SCNo32		"lo"

#define SCNu32		"lu"

#define SCNx32		"lx"

#define SCNdLEAST32    	"ld"

#define SCNiLEAST32    	"li"

#define SCNoLEAST32    	"lo"

#define SCNuLEAST32    	"lu"

#define SCNxLEAST32    	"lx"

#define SCNdFAST32    	"ld"

#define SCNiFAST32    	"li"

#define SCNoFAST32    	"lo"

#define SCNuFAST32    	"lu"

#define SCNxFAST32    	"lx"



#define PRId40		"lld"

#define PRIi40		"lli"

#define PRIo40		"llo"

#define PRIu40		"llu"

#define PRIx40		"llx"

#define PRIX40		"llX"

#define PRIdLEAST40    	"lld"

#define PRIiLEAST40    	"lli"

#define PRIoLEAST40    	"llo"

#define PRIuLEAST40    	"llu"

#define PRIxLEAST40    	"llx"

#define PRIXLEAST40    	"llX"

#define PRIdFAST40    	"lld"

#define PRIiFAST40    	"lli"

#define PRIoFAST40    	"llo"

#define PRIuFAST40    	"llu"

#define PRIxFAST40    	"llx"

#define PRIXFAST40    	"llX"

#define SCNd40		"lld"

#define SCNi40		"lli"

#define SCNo40		"llo"

#define SCNu40		"llu"

#define SCNx40		"llx"

#define SCNdLEAST40    	"lld"

#define SCNiLEAST40    	"lli"

#define SCNoLEAST40    	"llo"

#define SCNuLEAST40    	"llu"

#define SCNxLEAST40    	"llx"

#define SCNdFAST40    	"lld"

#define SCNiFAST40    	"lli"

#define SCNoFAST40    	"llo"

#define SCNuFAST40    	"llu"

#define SCNxFAST40    	"llx"





#define PRIdPTR		"ld"

#define PRIiPTR		"li"

#define PRIoPTR		"lo"

#define PRIuPTR		"lu"

#define PRIxPTR		"lx"

#define PRIXPTR		"lX"

#define SCNdPTR		"ld"

#define SCNiPTR		"li"

#define SCNoPTR		"lo"

#define SCNuPTR		"lu"

#define SCNxPTR		"lx"



#define PRIdMAX		"lld"

#define PRIiMAX		"lli"

#define PRIoMAX		"llo"

#define PRIuMAX		"llu"

#define PRIxMAX		"llx"

#define PRIXMAX		"llX"

#define SCNdMAX		"lld"

#define SCNiMAX		"lli"

#define SCNoMAX		"llo"

#define SCNuMAX		"llu"

#define SCNxMAX		"llx"



#endif /* !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) */



/* 7.8.2 Functions for greatest-width integer types */

#include <linkage.h>



_CODE_ACCESS intmax_t  imaxabs(intmax_t j);

_CODE_ACCESS imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);

_CODE_ACCESS intmax_t  strtoimax(const char * restrict nptr, 

		    char ** restrict endptr, int base);

_CODE_ACCESS uintmax_t strtoumax(const char * restrict nptr, 

		    char ** restrict endptr, int base);



#endif /* _INTTYPES_H_ */


isalnum.c/      1148595156  0     0     0       426       `
/****************************************************************************/

/*  isalnum v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int isalnum(int c)

{

    return(_isalnum(c));

}



isalpha.c/      1148595156  0     0     0       426       `
/****************************************************************************/

/*  isalpha v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int isalpha(int c)

{

    return(_isalpha(c));

}



isascii.c/      1148595156  0     0     0       426       `
/****************************************************************************/

/*  isascii v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int isascii(int c)

{

    return(_isascii(c));

}



iscntrl.c/      1148595156  0     0     0       426       `
/****************************************************************************/

/*  iscntrl v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int iscntrl(int c)

{

    return(_iscntrl(c));

}



isdigit.c/      1148595156  0     0     0       426       `
/****************************************************************************/

/*  isdigit v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int isdigit(int c)

{

    return(_isdigit(c));

}



isgraph.c/      1148595156  0     0     0       426       `
/****************************************************************************/

/*  isgraph v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int isgraph(int c)

{

    return(_isgraph(c));

}



islower.c/      1148595156  0     0     0       426       `
/****************************************************************************/

/*  islower v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int islower(int c)

{

    return(_islower(c));

}



iso646.h/       1148595156  0     0     0       528       `
/*****************************************************************************/

/* ISO646.H v3.3.2                                                           */

/* Copyright (c) 2000-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/

#define and    &&

#define and_eq &=

#define bitand &

#define bitor  |

#define compl  ~

#define not    !

#define not_eq !=

#define or     ||

#define or_eq  |=

#define xor    ^

#define xor_eq ^=

isprint.c/      1148595156  0     0     0       426       `
/****************************************************************************/

/*  isprint v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int isprint(int c)

{

    return(_isprint(c));

}



ispunct.c/      1148595156  0     0     0       426       `
/****************************************************************************/

/*  ispunct v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int ispunct(int c)

{

    return(_ispunct(c));

}



isspace.c/      1148595156  0     0     0       426       `
/****************************************************************************/

/*  isspace v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int isspace(int c)

{

    return(_isspace(c));

}



isupper.c/      1148595156  0     0     0       426       `
/****************************************************************************/

/*  isupper v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int isupper(int c)

{

    return(_isupper(c));

}



isxdigit.c/     1148595156  0     0     0       428       `
/****************************************************************************/

/*  isxdigit v3.3.2                                                         */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int isxdigit(int c)

{

    return(_isxdigit(c));

}



l_crshft.asm/   1148595156  0     0     0       1769      `
;/*****************************************************************************/

;/*  _L_crshft_r.asm v3.3.2                                                   */

;/*  Copyright (c) 1997-2006 Texas Instruments Incorporated                   */

;/*****************************************************************************/

	.include "c55xasm.i"

	.model  call=internal ; This function is recognized by name 

			      ; in the compiler.



	.noremark 5673        ; The shifts in this file avoid SE CPU_89



; 32-bit signed saturating right shift, with rounding

;

; arg1:   value      : AC0

; arg2:   shift count: T0

; return:            : AC0

;



	.sect	".text"

	.global	_L_crshft_r

_L_crshft_r:	.asmfunc

        SP = SP + #-1



; Shortcut: If the shift count is larger than the word size, return 0.



        compare(T0 >= #32) goto L5



; Perform a saturating shift right.

; (This can saturate if the shift count argument was negative).

	

        T1 = -T0

	.if __TMS320C55X_PLUS__

	AC2 = ssat(AC0 << T1)

	.else

        bit(ST1, #ST1_SATD) = #1

        AC2 = AC0 << T1

        bit(ST1, #ST1_SATD) = #0

	.endif



; The result is now in AC2.  Check if we need to perform rounding.

; If the shift count was originally <= 0, don't need to round.



        T1 = -T1

        if (T1 <= #0) goto L6



; Round the result



; Check the (T1-1)th bit of the orignal value.



        T1 = T1 - #1

        AC1 = #1

        AC1 = AC1 << T1

        AC0 = AC0 & AC1



; If bit (T1-1) is set, add one to the result to accomplish rounding.



        if (AC0==#0) goto L6



        AC0 = AC2 + #1

        goto L7



L5:        

        AC2 = #0

L6:        

        AC0 = AC2

L7:        

        SP = SP + #1

        return

	.endasmfunc




ld3_32.h/       1148595156  0     0     0       2653      `
/****************************************************************************/

/*  ld3_32.h         v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:24 CDT 2000 */

 

#ifndef __ld3_32__

#define __ld3_32__

#if 0

/*---------------------------------------------------------------------------*/

/* TMS320C55xx-specific 32-bit REAL (and other) behavior descriptions.       */

/*---------------------------------------------------------------------------*/

#endif



#define Adds_Per_Add  1  /* ratio of REAL add  to add  */

#define Adds_Per_Mult 10 /* ratio of REAL mult to add  */

#define Adds_Per_Div  50 /* ratio of REAL div  to add  */



#define FLT_FIX_Faster_Than_MODF 1 /* (float)((int(x))) faster than modf  */



#define Floating_Sub_Has_Guard_Digit 0 /* safe value is 0  */



#undef Support_DENORM     /* denormalized numbers */

#undef Support_INFNAN 	  /* INFINITY's and NAN's */             

#undef Support_SATURATION /* saturate overflows to MOST_POS,MOST_NEG */



#define INT_MOST_POS_P1 CNST( 32768.0) // most pos int +1 as REAL 

#define INT_MOST_NEG    CNST(-32768.0) // most neg int    as REAL 

#define INT_MOST_NEG_M1 CNST(-32769.0) // most neg int -1 as REAL 



#define BPAU 16   /* bits per Addressable Unit    */               

#define BPchar 16 /* bits per char            */                   

#define BPshrt 16 /* bits per short           */                   

#define BPint 16  /* bits per int             */                   

#define BPlong 32 /* bits per long (0 if not supported)    */      

#define BPREAL 32 /* bits per REAL when in MEMORY      */          

#define BPLEAN 0  /* bits per next smallest REAL when in MEMORY  */



#define MSB_In_Hi_Addr 0 /* ENDIANness. 0=big, 1=little  */



#if 0

/*---------------------------------------------------------------------------*/

/* Pick the integer size on top of which REAL is to be implemented.          */

/*---------------------------------------------------------------------------*/

#endif

#if (BPint==BPREAL)

   #define BPbigint BPint

   #define bigint int

   #define biguns unsigned

#elif (BPint >= BPlong)

   #define BPbigint BPint

   #define bigint int

   #define biguns unsigned

#elif (BPlong==BPREAL)

   #define BPbigint BPlong

   #define bigint long

   #define biguns unsigned long

#else

   #define BPbigint BPlong

   #define bigint long

   #define biguns unsigned long

#endif



#endif


ldexp.c/        1148595156  0     0     0       2535      `
/****************************************************************************/

/*  ldexp.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:47 CDT 2000 */

 

#include "reald.h"



  REAL LDEXPF(REAL x, int n)

/*---------------------------------------------------------------------------*/

/* return x * (REAL_RADIX ** n)                                              */

/*---------------------------------------------------------------------------*/

{



   { 

   /* Deals properly with NAN, +/- INFINITY, +/- ZERO, denormalized numbers */



      REAL y;

      int uy, e;



      int *ptr;

      CPYF(y,x);

      ptr = (int *)(&y) + (((32 / 16 )-1)*(0 )) ;

      uy = *ptr;

   

      e = ((uy >> (16 - (8 +1) )) & ((1<< 8 )-1) );



      if (e == 0) /* ZERO's and denormalized numbers */

      {

         if EQZF(x) return x; /* preserve signed ZERO's */



         MPYF3(y, x, CNST(16777216.0) );  /* its not denormalized now! */

       

         uy = *ptr;

       

         e = ((uy >> (16 - (8 +1) )) & ((1<< 8 )-1) ) - 24 ;

      }

      else if (e == ((1<< 8 )-1) ) return x; /* watch for infinity and NAN! */



      if (n > 128 + (127 -1) -e) /* overflow? */

      {

         errno = ERANGE; 

         CPYF(y,(GEZF(x) ? CNST( 3.402823466E+38)  : CNST(-3.402823466E+38) ));



         return y;

      }

      if (n < (-125) + (127 -1) -e) { /* underflow or denormalized? */

         if (n < (-125) -(24 -1)+ (127 -1) -e) /* underflow? */

            return ZERO;



         /* resulting number will be denormalized */

       

         *ptr= (uy & ((1<<(16 -1))+(1<<(23 % 16 ))-1) ) |                    /* out with the old...*/

              ((e+n+ 24 )<<(16 - (8 +1) ));/* in with (some) new.*/

         __asm(" ") ;/**ptr must be written before trying to read y*/

       

         return MPYF(y, CNST(5.9604644753E-8) );          /* then rest of new   */

         /* MPYF will underflow if target does not support denormalized nos. */

      }

    

      *ptr = (uy & ((1<<(16 -1))+(1<<(23 % 16 ))-1) ) |                 /* out with the old ...*/

             ((e+n) << (16 - (8 +1) ));        /* and in with the new */

      __asm(" ") ;/*make sure *ptr is written before trying to read y*/

    

      return y;

   }



} /* LDEXPF */


ldiv.c/         1148595156  0     0     0       474       `
/****************************************************************************/

/*  ldiv.c           v3.3.2                                                 */

/*  Copyright (c) 2002-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdlib.h>



ldiv_t ldiv(long num, long den)

{

    ldiv_t rv;



    rv.quot = num / den;

    rv.rem  = num % den;

    

    return rv;

}

limits.h/       1148595156  0     0     0       2696      `
/*****************************************************************************/

/* limits.h   v3.3.2                                                         */

/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



/*****************************************************************************/

/* TMS320C55xx machine limits                                                */

/*****************************************************************************/



#ifndef _LIMITS

#define _LIMITS



#if !defined(__TMS320C55X_PLUS_BYTE__)

#define CHAR_BIT                16    /* NUMBER OF BITS IN TYPE CHAR  	  */

#define SCHAR_MAX            32767    /* MAX VALUE FOR SIGNED CHAR    	  */

#define SCHAR_MIN   (-SCHAR_MAX-1)    /* MIN VALUE FOR SIGNED CHAR    	  */

#define UCHAR_MAX            65535U   /* MAX VALUE FOR UNSIGNED CHAR  	  */

#define CHAR_MAX         SCHAR_MAX    /* MAX VALUE FOR CHAR           	  */

#define CHAR_MIN         SCHAR_MIN    /* MIN VALUE FOR CHAR           	  */

#define MB_LEN_MAX               1    /* MAX # BYTES IN MULTI-BYTE    	  */

#else

#define CHAR_BIT                 8    /* NUMBER OF BITS IN TYPE CHAR  	  */

#define SCHAR_MAX              127    /* MAX VALUE FOR SIGNED CHAR    	  */

#define SCHAR_MIN   (-SCHAR_MAX-1)    /* MIN VALUE FOR SIGNED CHAR    	  */

#define UCHAR_MAX              255U   /* MAX VALUE FOR UNSIGNED CHAR  	  */

#define CHAR_MAX         SCHAR_MAX    /* MAX VALUE FOR CHAR           	  */

#define CHAR_MIN         SCHAR_MIN    /* MIN VALUE FOR CHAR           	  */

#define MB_LEN_MAX               2    /* MAX # BYTES IN MULTI-BYTE    	  */

#endif

     

#define SHRT_MAX             32767    /* MAX VALUE FOR SHORT          	  */

#define SHRT_MIN     (-SHRT_MAX-1)    /* MIN VALUE FOR SHORT          	  */

#define USHRT_MAX            65535U   /* MAX VALUE FOR UNSIGNED SHORT 	  */

    

#define INT_MAX              32767    /* MAX VALUE FOR INT            	  */

#define INT_MIN       (-INT_MAX-1)    /* MIN VALUE FOR INT            	  */

#define UINT_MAX             65535U   /* MAX VALUE FOR UNSIGNED INT   	  */

    

#define LONG_MAX        2147483647L   /* MAX VALUE FOR LONG           	  */

#define LONG_MIN     (-LONG_MAX-1)    /* MIN VALUE FOR LONG           	  */

#define ULONG_MAX       4294967295UL  /* MAX VALUE FOR UNSIGNED LONG  	  */



#define LLONG_MIN   (-LLONG_MAX-1)    /* MIN VALUE FOR LONG LONG      	  */

#define LLONG_MAX     549755813887    /* MAX VALUE FOR LONG LONG      	  */

#define ULLONG_MAX   1099511627775U   /* MAX VALUE FOR UNSIGNED LONG LONG */



#endif

linkage.h/      1148595156  0     0     0       891       `
/*****************************************************************************/

/* linkage.h   v3.3.2                                                        */

/* Copyright (c) 1998-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _LINKAGE

#define _LINKAGE



/* No modifiers are needed to access code or data */



#define _CODE_ACCESS

#define _DATA_ACCESS



/*--------------------------------------------------------------------------*/

/* Define _IDECL ==> how inline functions are declared                      */

/*--------------------------------------------------------------------------*/

#ifdef _INLINE

#define _IDECL static __inline

#define _IDEFN static __inline

#else

#define _IDECL _CODE_ACCESS

#define _IDEFN _CODE_ACCESS

#endif



#endif /* ifndef _LINKAGE */


lldiv.c/        1148595156  0     0     0       508       `
/****************************************************************************/

/*  lldiv.c          v3.3.2                                                 */

/*  Copyright (c) 2002-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdlib.h>

#include <limits.h>



lldiv_t lldiv(long long num, long long den)

{

    lldiv_t rv;

    

    rv.quot = num / den;

    rv.rem  = num % den;



    return rv;

}

llmpy.c/        1148595156  0     0     0       3503      `
/*****************************************************************************/

/*  llmpy.c v3.3.2                                                           */

/*  Copyright (c) 2000-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



typedef long long int40_t;

typedef unsigned long long uint40_t;



typedef unsigned int uint;

typedef unsigned long ulong;



int40_t _mpylli(register int40_t src1, register int40_t src2)

{

    register ulong low, mid, high;



    /*-----------------------------------------------------------------------*/

    /* These 16x16->32 multiplies must be unsigned if anything but the	     */

    /* lower 16 bits of the result is used in the answer.  This is only	     */

    /* true for the low part.  In theory, multiplications involving the	     */

    /* high parts (which contain the sign bits) should be done as mixed	     */

    /* signed/unsigned multiplies, but the bits which would differ are	     */

    /* ignored anyway.  Thus, doing everything in unsigned arithmetic is     */

    /* safe, and for the C55x compiler more efficient.			     */

    /*-----------------------------------------------------------------------*/

    low  = ((ulong)(uint)src1         * (uint)src2);

    mid  = ((ulong)(uint)(src1 >> 16) * (uint)src2 + 

	    (ulong)(uint)src1         * (uint)(src2 >> 16));

    high = ((ulong)(uint)(src1 >> 32) * (uint)src2 + 

	    (ulong)(uint)(src1 >> 16) * (uint)(src2 >> 16) +

	    (ulong)(uint)src1         * (uint)(src2 >> 32));



    return ((ulong)low + ((uint40_t)mid << 16) + ((uint40_t)high << 32));

}



/* the 80-bit divmod style is dangerous if bit(unsigned dividend, 39)==1. */



uint40_t _divull(register uint40_t a, register uint40_t b)

{

    register uint40_t _a  = a;

    register uint40_t _b  = b;

    register uint40_t lmb = 1ull << 39;

    register uint40_t q;



    register int      rshift, lshift;

 

    if (_b > _a || _b == 0) return 0;

 

    /*-----------------------------------------------------------------------*/

    /* COMPUTE DIFFERENCE IN POSITIONS OF MSBs, AND ALIGN THEM.              */

    /*-----------------------------------------------------------------------*/

    for (rshift = 0; (_a & lmb) == 0; ++rshift) lmb >>= 1;

    for (lshift = 0; (_b & lmb) == 0; ++lshift) _b  <<= 1;

 

    q = 0;



    /*-----------------------------------------------------------------------*/

    /* DIVIDE USING CONDITIONAL SUBTRACTION.                                 */

    /*-----------------------------------------------------------------------*/

    do

    {

	q <<= 1;

	if (_a >= _b) { _a -= _b; q |= 1; }

 

	if (rshift++ == 0) _b >>= 1;

	else               _a <<= 1;

 

    } while (lshift--);



    return q;

}



uint40_t _remull(register uint40_t a, register uint40_t b)

{

    return a - a / b * b;

}



int40_t _divlli(register int40_t a, register int40_t b)

{

    int    sign_a = a < 0;

    int    sign_b = b < 0;



    int40_t  res;



    uint40_t au = (sign_a) ? -a : a;

    uint40_t bu = (sign_b) ? -b : b;



    res = au / bu;



    return (sign_a ^ sign_b) ? -res : res;

}



int40_t _remlli(register int40_t a, register int40_t b)

{

    int    sign_a = a < 0;

    int    sign_b = b < 0;



    int40_t  res;



    uint40_t au = (sign_a) ? -a : a;

    uint40_t bu = (sign_b) ? -b : b;



    res = au % bu;



    return (sign_a) ? -res : res;

}


lmpy.asm/       1148595156  0     0     0       3353      `
******************************************************************************

* lmpy.asm  v3.3.2

* Copyright (c) 1997-2006 Texas Instruments Incorporated

******************************************************************************

	.include "c55xasm.i"

	.mmregs

	.cpl_on

	.arms_on

	.model  call=internal ; This function is recognized by name 

			      ; in the compiler.



	.noremark 5673        ; The shifts in this file avoid SE CPU_89





*****************************************************************************

* _LMPY() - Multiply two 32-bit longs into a long.

*

* WARNING!  Changes to register defs in this function must be reflected in

* the constraint class MPYLI_SET in ld3.md

*****************************************************************************

	.global	I$$LMPY

	.global	__mpyli

	.noremark 5108

		

; inputs in AC0 and AC1

; AC0 -> IHI ILO

; AC1 -> JHI JLO

; for the computation the inputs are:

; IHI -> AC0_H

; ILO -> T0

; JHI -> AC1_H

; JLO -> SP(#0)

;

; result in AC0

;

; also uses T0



I$$LMPY:	.asmfunc

__mpyli:

******************************************************************************

* ALLOCATE FRAME

******************************************************************************

	push(AC1)               ; Save off AC1_L (i.e. JLO) so it's available

	                        ; as an smem later on.  Note that this 

	                        ; also aligns the stack.



||      T0 = AC0		; ILO



******************************************************************************

* A 32X32 MULTIPLY WITH A 64-BIT RESULT WOULD BE CALCULATED: 

*                                                            

*                IHI ILO                                     

*             X  JHI JLO                                     

*             ----------                                     

*             ILO * JLO                                      

*       JLO * IHI                                            

*       ILO * JHI                                            

* IHI * JHI                                                  

* ----------------------                                     

*     64-bit result                                          

*                                                            

* BUT WE NEED ONLY THE LOWER 32-BITS OF THIS CALCULATION.  THEREFORE   

* THE IHI * JHI CALCULATION ISN'T DONE AT ALL AND THE UPPER HALF OF THE

* JLO * IHI AND ILO * JHI CALCULATIONS IS THROWN AWAY.  ALSO, THE      

* ILO * JLO MULTIPLY MUST BE UNSIGNED, BUT THE SIGNNESS OF THE OTHER   

* MULTIPLIES DOESN'T MATTER SINCE THE DIFFERENCE ALWAYS APPEARS IN THE 

* UPPER 16-BITS.                                                       

******************************************************************************

	AC0 = AC0 * *SP(#0)	     ; AC0 = IHI * JLO

	AC1 = (AC1 * T0) + AC0	     ; AC1 = (JLO * IHI) + (ILO * JHI)

	AC0 = uns(T0 * *SP(#0))	     ; AC0 = ILO * JLO

	AC0 = AC0 + (AC1 << #16)     ; final result  

		

******************************************************************************

* CLEAN UP STACK FRAME AND RETURN.                       

******************************************************************************



||	SP = SP + #1      	     ; deallocate frame



        return;

	.endasmfunc

        .end


localtim.c/     1148595156  0     0     0       3058      `
/****************************************************************************/

/*  localtime v3.3.2                                                        */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <time.h>

#include <limits.h>



#define SECS_IN_MIN (time_t)60

#define MINS_IN_HR  (time_t)60

#define HRS_IN_DAY  (time_t)24

#define SECS_IN_HR  (SECS_IN_MIN * MINS_IN_HR)

#define SECS_IN_DAY (SECS_IN_HR * HRS_IN_DAY)

 

#define LEAPYEAR(y) (    (y+1900) % 4   == 0                               \

			 && ((y+1900) % 100 != 0 || (y+1900) % 400 == 0))



#define DAYS_IN_YR(y) ((time_t)365 + LEAPYEAR(y))

 

_CODE_ACCESS struct tm *localtime(const time_t *timer)

{

    static _DATA_ACCESS struct tm local;

    time_t ltime  = timer ? *timer : 0;

 

    local.tm_sec  = 0;

    local.tm_min  = 0;

    local.tm_hour = 0;

    local.tm_mday = 1;

    local.tm_mon  = 0;

    local.tm_year = 0;

 

    if (timer == 0 || ltime == (time_t)-1) return &local;

 

#if INT_MAX <= 32767

    /*------------------------------------------------------------------*/

    /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */

    /* REPRESENTED IN SIGNED INTS.                                      */

    /*------------------------------------------------------------------*/

    local.tm_sec   =  ltime % SECS_IN_MIN;

    local.tm_min   = (ltime / SECS_IN_MIN) % MINS_IN_HR;

    local.tm_hour  = (ltime / SECS_IN_HR)  % HRS_IN_DAY;

 

    /*------------------------------------------------------------------*/

    /* CONVERT ltime TO NUMBER OF DAYS                                  */

    /*------------------------------------------------------------------*/

    ltime /= SECS_IN_DAY;

 

    /*------------------------------------------------------------------*/

    /* TO DETERMINE THE YEAR, INSTEAD OF DIVIDING BY 365, DO A SUBTRACT */

    /* LOOP THAT ACCOUNTS FOR LEAP YEARS.                               */

    /*------------------------------------------------------------------*/

    {

	int year = 0;

	while (ltime >= DAYS_IN_YR(year))

	{

	    ltime -= DAYS_IN_YR(year);

	    ++year;

	}

     

	local.tm_year  = year;

	local.tm_mday += ltime;

    }

 

#else

    /*------------------------------------------------------------------*/

    /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */

    /* REPRESENTED IN SIGNED INTS.                                      */

    /*------------------------------------------------------------------*/

    if ((int)ltime < 0)

    {

	local.tm_sec  = ltime % 60; 

	local.tm_min  = ltime / 60; 

    }

    else local.tm_sec = ltime;

#endif

 

    /*------------------------------------------------------------------*/

    /* MAKE VALUES IN local INTO A VALID TIME.                          */

    /*------------------------------------------------------------------*/

    mktime(&local);

    return &local;

}

log.c/          1148595156  0     0     0       1382      `
/****************************************************************************/

/*  log.c            v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:47 CDT 2000 */

 

#include "reald.h"



  REAL LOGF(REAL x)

{

    if LEZF(x)

    { 

       errno = (EQZF(x) ? ERANGE : EDOM); 

       return CNST(-3.402823466E+38) ;

    }



{



    REAL    result, f;

    EXPONENT_TYPE n;



    static  REAL log_consts[8] = /* max of 24 mantissa bits */

      {KNST( 8.7416954E-02), 

       KNST(-1.4376735E-01), 

       KNST( 1.4949567E-01), 

       KNST(-1.6560792E-01), 

       KNST( 1.9956945E-01), 

       KNST(-2.5002149E-01), 

       KNST( 3.3334184E-01), 

       KNST(-4.9999987E-01)};



    RIPF(x, f, n);



    if LEQF(f, One_Over_Sqrt_2) 

    {

       ADDF2(f, f);

       n -= 1;

    }



    SUBF3(f,SUBF(f,HALF),HALF); /* do it this way to avoid losing bits */



    /* abs(F) < .414213562... at this point */



    POLYF(result,f,log_consts,8 );



    ADDF3(result, f, MPYF(f, result)); /* result = f+f*result; */



    /* return result + (REAL)n * Ln_2; */

    return ADDF(result, MPYF(FLTIF(n), Ln_2));

}



} /*LOGF*/

log10.c/        1148595156  0     0     0       508       `
/****************************************************************************/

/*  log10.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:48 CDT 2000 */

 

#include "reald.h"



  REAL LOG10F(REAL x)

{

    return MPYF(LOGF(x), One_Over_Ln_10);

} /*LOG10F*/



log2.c/         1148595156  0     0     0       503       `
/****************************************************************************/

/*  log2.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:49 CDT 2000 */

 

#include "reald.h"



  REAL LOG2F(REAL x)

{

    return MPYF(LOGF(x), One_Over_Ln_2);

} /*LOG2F*/


lowlev.c/       1148595156  0     0     0       15184     `
/*****************************************************************************/

/*  LOWLEV.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Low level I/O routines                                                    */

/*                                                                           */

/* Functions:                                                                */

/*   getnexfildes()    - Allocate next entry in stream table.                */

/*   tabinit()         - Initialize the stream and device tables.            */

/*   finddevice()      - Search the device table for a device name.          */

/*   getdevice()       - Extract the device name and <find> it.              */

/*   add_device()      - Add a device record to the device table.            */

/*   removedevice()    - Remove the specified device record from the device  */

/*                              table.                                       */

/*   open()            - Open file/device and assign file descriptor.        */

/*   read()            - Read data from an open file/device.                 */

/*   write()           - Write to an open file/device.                       */

/*   lseek()           - Perform lseek on open file/device.                  */

/*   close()           - Close an open file/device.                          */

/*   unlink()          - Perform unlink on file/device.                      */

/*   rename()          - Rename file                                         */

/*****************************************************************************/

#include <stdio.h>

#include <string.h>

#include <_lock.h>

#include "file.h"



typedef struct {

   char           name[9];

   unsigned short flags;

   int 	  	  (*OPEN) (const char *path, unsigned flags, int llv_fd);

   int 	  	  (*CLOSE) (int dev_fd);

   int 	  	  (*READ) (int dev_fd, char *buf, unsigned count);

   int 	  	  (*WRITE) (int dev_fd, const char *buf, unsigned count);

   off_t 	  (*LSEEK) (int dev_fd, off_t offset, int origin);

   int 	  	  (*UNLINK) (const char *path);

   int 	  	  (*RENAME) (const char *old_name, const char *new_name);

} _DEVICE;



extern _CODE_ACCESS int HOSTopen(const char *path, unsigned flags, int llv_fd),

                        HOSTclose(int dev_fd),

                        HOSTread(int dev_fd, char *buf, unsigned count),

                        HOSTwrite(int dev_fd, const char *buf, unsigned count),

                        HOSTunlink(const char *path),

                        HOSTrename(const char *old_name, const char *new_name);

extern _CODE_ACCESS off_t HOSTlseek(int dev_fd, off_t offset, int origin);



static _CODE_ACCESS void tabinit(void);

static _CODE_ACCESS _DEVICE *finddevice(const char *devname);

static _CODE_ACCESS _DEVICE *getdevice (const char **path);



static _DEVICE  

_device[_NDEVICE] = { { "", _MSA, HOSTopen, HOSTclose, HOSTread,

			HOSTwrite, HOSTlseek, HOSTunlink, HOSTrename } };



#define stdevice (&_device[0]) /* Default device (host) */



static struct stream_info { _DEVICE *dev; int dfd; } 

_stream[_NSTREAM] =  { { stdevice, 0 },  

		       { stdevice, 1 }, 

		       { stdevice, 2 } };



/*****************************************************************************/

/*  TABINIT() - initialize the stream table and the device table             */

/*****************************************************************************/



static _CODE_ACCESS void tabinit(void)

{

   struct stream_info *st;

   _DEVICE            *dt;



   static _DATA_ACCESS int init = 0;



   _lock();



   if (!init)

   {

       /*--------------------------------------------------------------------*/

       /* STEP THROUGH THE TABLES SETTING NAME AND DEVICE ENTRIES TO NULL    */

       /* (SKIP PREDEFINED DEVICE AND STREAMS)				     */

       /*--------------------------------------------------------------------*/

       for (st = &_stream[3]; st != &_stream[_NSTREAM]; (st++)->dev = NULL);

       for (dt = &_device[1]; dt != &_device[_NDEVICE]; *(dt++)->name = '\0');

       init = 1;

   }



   _unlock();

}



/*****************************************************************************/

/*  FINDDEVICE() - find the device record that matches devname in the device */

/*                     table                                                 */

/*****************************************************************************/



static _CODE_ACCESS _DEVICE *finddevice(const char *devname)

{

   _DEVICE *dt;



   if (devname[0] == '\0') return NULL;



   /*------------------------------------------------------------------------*/

   /* SEARCH THE STREAM TABLE FOR THE DEVICE NAME - RETURN NULL IF NOT FOUND */

   /*------------------------------------------------------------------------*/

   for (dt = &_device[1]; dt != &_device[_NDEVICE]; ++dt)

       if (!strcmp(dt->name, devname)) return dt;



   return NULL;

}





/*****************************************************************************/

/*  GETDEVICE() - extract the device name and call finddevice                */

/*****************************************************************************/



static _CODE_ACCESS _DEVICE *getdevice (const char **path)

{

   char devname[9];

   char *colon = strchr(*path, ':');

   _DEVICE *dev;



   if (colon != NULL)

   {

       int devnamlen = colon - *path;

       if (devnamlen > 8) devnamlen = 8;



       strncpy(devname, *path, devnamlen);

       devname[devnamlen] = '\0';

       dev = finddevice(devname);



       if (dev) { *path = colon + 1; return dev; }

   }



   return stdevice; /* the "standard" device - host I/O */

}





/*****************************************************************************/

/*  ADDEVICE() - add a device record to the device table                     */

/*****************************************************************************/



_CODE_ACCESS

int add_device(char     *name,

               unsigned  flags,

               int     (*dopen)  (const char *path, unsigned flags, int llv_fd),

               int     (*dclose) (int dev_fd),

               int     (*dread)  (int dev_fd, char *buf, unsigned count),

               int     (*dwrite) (int dev_fd, const char *buf, unsigned count),

               off_t   (*dlseek) (int dev_fd, off_t offset, int origin),

               int     (*dunlink)(const char *path),

               int     (*drename)(const char *old_name, const char *new_name))

{

   _DEVICE *dt;



   tabinit();



   _lock();



   /*-------------------------------------------------------------------------*/

   /* SEARCH THE DEVICE TABLE FOR AN EMPTY SLOT, RETURN -1 IF NONE FOUND      */

   /*-------------------------------------------------------------------------*/

   for (dt = &_device[1]; dt != _device+_NDEVICE && dt->name[0] != '\0'; ++dt);

   if (dt == &_device[_NDEVICE]) { _unlock(); return -1; }



   strncpy(dt->name,name,8);

   dt->name[8] = '\0';

   dt->flags   = flags;

   dt->OPEN    = dopen;

   dt->CLOSE   = dclose;

   dt->READ    = dread;

   dt->WRITE   = dwrite;

   dt->LSEEK   = dlseek;

   dt->UNLINK  = dunlink;

   dt->RENAME  = drename;



   _unlock();



   return 0;

}



/******************************************************************************/

/*  REMOVEDEVICE() - remove the specified device record from the device table */

/******************************************************************************/



_CODE_ACCESS int remove_device(char *name)

{

   _DEVICE *ptr;



   _lock();



   /*------------------------------------------------------------------------*/

   /* FIND RECORD AND SET NAME TO NULL					     */

   /*------------------------------------------------------------------------*/

   if ( !(ptr = finddevice(name)) ) { _unlock(); return -1; }



   ptr->name[0] = '\0';



   _unlock();



   return 0;

}





/*****************************************************************************/

/*  OPEN() - open file/device specified by path and assign file descriptor   */

/*****************************************************************************/



_CODE_ACCESS int open(const char *path, unsigned flags, int mode)

{

   struct stream_info *ptr;

   _DEVICE    	      *dev;

   int        	      dev_fd;

   int        	      llv_fd;



   /*-------------------------------------------------------------------------*/

   /* INITIALIZE STREAM AND DEVICE TABLE FIRST TIME AROUND                    */

   /*-------------------------------------------------------------------------*/

   tabinit();



   _lock();



   /*-------------------------------------------------------------------------*/

   /* GET THE NEXT AVAILABLE FILE DESCRIPTOR - RETURN -1 IF NONE AVAILABLE    */

   /*-------------------------------------------------------------------------*/

   for (ptr = &_stream[3]; ptr != &_stream[_NSTREAM] && ptr->dev; ++ptr);

   if (ptr == &_stream[_NSTREAM]) { _unlock(); return -1; }

   llv_fd = ptr - &_stream[0];



   /*------------------------------------------------------------------------*/

   /* GET DEVICE AND PEFORM OPEN - SET STREAM TABLE ENTRY AND FLAGS          */

   /*------------------------------------------------------------------------*/

   dev    = getdevice(&path);

   dev_fd = (dev->flags & _BUSY) ? -1 : (*(dev->OPEN))(path,flags,llv_fd);



   if (dev_fd < 0) { _unlock(); return dev_fd; }

   

   _stream[llv_fd].dev = dev;

   _stream[llv_fd].dfd = dev_fd;

   if ( !(dev->flags & _MSA) ) dev->flags |= _BUSY;



   _unlock();



   return llv_fd;

}



/*****************************************************************************/

/*  READ() - read data from an open device/file                              */

/*****************************************************************************/



_CODE_ACCESS int read(int llv_fd, char *bufptr, unsigned cnt)

{

   int result;



   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;



   _lock();



   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }



   /*------------------------------------------------------------------------*/

   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM READ FOR THIS DEVICE/FILE   */

   /*------------------------------------------------------------------------*/

   result = (*(_stream[llv_fd].dev->READ)) (_stream[llv_fd].dfd,bufptr,cnt);



   _unlock();



   return result;

}



/*****************************************************************************/

/*  WRITE() - write data to an open device/file                              */

/*****************************************************************************/



_CODE_ACCESS int write(int llv_fd, const char *bufptr, unsigned cnt)

{

   int result;



   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;



   _lock();



   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }



   /*------------------------------------------------------------------------*/

   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM WRITE FOR THIS DEVICE/FILE  */

   /*------------------------------------------------------------------------*/

   result = (*(_stream[llv_fd].dev->WRITE)) (_stream[llv_fd].dfd,bufptr,cnt);



   _unlock();



   return result;

}



/*****************************************************************************/

/*  LSEEK() - lseek on an open device/file                                   */

/*****************************************************************************/



_CODE_ACCESS off_t lseek(int llv_fd, off_t offset, int origin)

{

   off_t result;



   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;



   _lock();



   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }



   /*------------------------------------------------------------------------*/

   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM LSEEK FOR THIS DEVICE/FILE  */

   /*------------------------------------------------------------------------*/

   result = (*(_stream[llv_fd].dev->LSEEK)) (_stream[llv_fd].dfd,offset,origin);



   _unlock();



   return result;

}



/*****************************************************************************/

/*  CLOSE() - close an open device/file                                      */

/*****************************************************************************/



_CODE_ACCESS int close(int llv_fd)

{

   int result;



   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;



   _lock();



   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }



   /*------------------------------------------------------------------------*/

   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM CLOSE FOR THIS DEVICE/FILE  */

   /* CLEAR STREAM TABLE ENTRY AND DEVICE FLAGS                              */

   /*------------------------------------------------------------------------*/

   if ( (result = (*(_stream[llv_fd].dev->CLOSE))(_stream[llv_fd].dfd)) != -1 )

   {

      _stream[llv_fd].dev->flags &= ~_BUSY;

      _stream[llv_fd].dev = NULL;

   }



   _unlock();



   return result;

}



/*****************************************************************************/

/*  UNLINK() - unlink an open device/file                                    */

/*****************************************************************************/



_CODE_ACCESS int unlink(const char *path)

{

   _DEVICE *dev;

   int      result;



   _lock();



   dev = getdevice(&path);



   /*------------------------------------------------------------------------*/

   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM UNLINK FOR THIS DEVICE/FILE */

   /*------------------------------------------------------------------------*/

   result = (*(dev->UNLINK)) (path);



   _unlock();



   return result;

}



/*****************************************************************************/

/*  RENAME() - rename a device/file                                          */

/*****************************************************************************/



_CODE_ACCESS int rename(const char *old_name, const char *new_name)

{

   _DEVICE *old_dev, *new_dev;

   int result;



   _lock();



   old_dev = getdevice(&old_name);

   new_dev = getdevice(&new_name);



   /*------------------------------------------------------------------------*/

   /* IF THE DEVICES ARE NOT THE SAME, RENAME WOULD REQUIRE A FILE COPY.     */

   /*------------------------------------------------------------------------*/

   if (old_dev != new_dev) { _unlock(); return -1; }



   /*------------------------------------------------------------------------*/

   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM RENAME FOR THIS DEVICE/FILE */

   /*------------------------------------------------------------------------*/

   result = (*(old_dev->RENAME)) (old_name, new_name);



   _unlock();

   

   return result;

}

ltoa.c/         1148595156  0     0     0       772       `
/****************************************************************************/

/*  ltoa v3.3.2								    */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <string.h>

#define BUFLEN 20



_CODE_ACCESS int ltoa(long val, char *buffer)

{

    char           tempc[BUFLEN];

    register char *bufptr;

    register int   neg = val < 0;

    register long  uval = neg ? -val : val;



    *(bufptr = &tempc[BUFLEN - 1]) = 0;



    do {*--bufptr = (uval % 10) + '0';}  while(uval /= 10);

    if (neg) *--bufptr = '-';



    memcpy(buffer,bufptr, uval = (tempc + BUFLEN) - bufptr);

    return uval - 1;    /* DON'T COUNT NULL TERMINATION */

}



math.h/         1148595156  0     0     0       4070      `
/****************************************************************************/

/*  math.h           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:25 CDT 2000 */

 

#ifndef __math__

#define __math__



#ifndef EDOM

#define EDOM   1

#endif



#ifndef ERANGE

#define ERANGE 2

#endif



#include <float.h>

#define HUGE_VAL  DBL_MAX

#define HUGE_VALL LDBL_MAX



#include <access.h>



__EXTERN double sqrt (double x);

__EXTERN double exp  (double x);

__EXTERN double log  (double x);

__EXTERN double log10(double x);

__EXTERN double pow  (double x, double y);

__EXTERN double sin  (double x);

__EXTERN double cos  (double x);

__EXTERN double tan  (double x);

__EXTERN double asin (double x);

__EXTERN double acos (double x);

__EXTERN double atan (double x);

__EXTERN double atan2(double y, double x);

__EXTERN double sinh (double x);

__EXTERN double cosh (double x);

__EXTERN double tanh (double x);



__INLINE double ceil (double x);

__INLINE double floor(double x);



__EXTERN double fabs (double x);



__EXTERN double ldexp(double x, int n);

__EXTERN double frexp(double x, int *exp);

__EXTERN double modf (double x, double *ip);

__EXTERN double fmod (double x, double y);



/* An inline version of fmod that works for limited domain only */

/* See comments in implementation below */

static __inline double _FMOD(double x, double y);



/* these present in many linked images, so we'll tell you about them. */

__EXTERN double _nround(double x); /* round-to-nearest */

__EXTERN double _trunc(double x); /* truncate towards 0 */



/* the ANSI-optional *f and *l routines */

#include <mathf.h>

#include <mathl.h>



#include <access.h>



#ifdef _TI_ENHANCED_MATH_H

#if 0

/* ------------------------------------------------- */

/* Routines below are an addition to ANSI math.h     */

/* Some (noted with "9x" in comment) will become ANSI*/

/* once C9x is approved.                             */

/* ------------------------------------------------- */

#endif



__EXTERN double rsqrt(double x); /*   == 1/sqrt(x) but *MUCH* faster         */

__EXTERN double exp2 (double x); /*9x mathematically equiv to pow(2.0 ,x)    */

__EXTERN double exp10(double x); /*   mathematically equiv to pow(10.0,x)    */

__EXTERN double log2 (double x); /*9x mathematically equiv to log(x)/log(2.0)*/



__EXTERN double powi(double x, int i); /* equiv to pow(x,(double)i) */



__EXTERN double cot  (double x);

__EXTERN double acot (double x);

__EXTERN double acot2(double x, double y);



__EXTERN double coth (double x);



__EXTERN double asinh(double x); /* 9x */

__EXTERN double acosh(double x); /* 9x */

__EXTERN double atanh(double x); /* 9x */

__EXTERN double acoth(double x);



#define round(x) _nround(x) // 9x round-to-nearest   

#define trunc(x) _trunc(x) // 9x truncate towards 0 



#endif





#ifdef _INLINE

/****************************************************************************/

/*  Inline versions of floor, ceil, fmod                                    */

/****************************************************************************/



static __inline double floor(double x) 

{

   double y; 

   return (modf(x, &y) < 0 ? y - 1 : y);

}



static __inline double ceil(double x)

{

   double y; 

   return (modf(x, &y) > 0 ? y + 1 : y);

}



/* 

   The implementation below does not work correctly for all cases.

   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).

   The correct result is one of 0,1, or 2.

   But the implementation below will *always* return 0 

   because the quotient is only an approximation.

*/

static __inline double _FMOD(double x, double y)

{

   double d = fabs(x); 

   if (d - fabs(y) == d) return (0);

   modf(x/y, &d);  

   return (x - d * y);

}



#endif



#include <unaccess.h>



#endif /* __math__*/



mathf.h/        1148595157  0     0     0       5057      `
/****************************************************************************/

/*  mathf.h          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:25 CDT 2000 */

 

#ifndef __mathf__

#define __mathf__



#ifndef EDOM

   #define EDOM   1

#endif



#ifndef ERANGE

   #define ERANGE 2

#endif



#include <float.h>



#if (FLT_DIG == DBL_DIG) /* float == double*/



#include <math.h>

#if !defined(DNKLIB)

#define sqrtf    sqrt

#define expf     exp

#define logf     log

#define log10f   log10

#define powf     pow

#define sinf     sin

#define cosf     cos

#define tanf     tan

#define asinf    asin

#define acosf    acos

#define atanf    atan

#define atan2f   atan2

#define sinhf    sinh

#define coshf    cosh

#define tanhf    tanh



#define ceilf    ceil

#define floorf   floor



#define fabsf    fabs



#define ldexpf   ldexp

#define frexpf   frexp

#define modff    modf

#define fmodf    fmod

#endif /* DNKLIB */

#ifdef _TI_ENHANCED_MATH_H



#define HUGE_VALF FLT_MAX



#if !defined(DNKLIB)

#define rsqrtf   rsqrt

#define exp2f    exp2

#define exp10f   exp10

#define log2f    log2

#define powif    powi

#define cotf     cot

#define acotf    acot

#define acot2f   acot2

#define cothf    coth

#define asinhf   asinh

#define acoshf   acosh

#define atanhf   atanh

#define acothf   acoth

#define truncf   _trunc

#define roundf   _nround

#endif /* DNKLIB */



#endif



#else /* float != double*/



#include <access.h>



__EXTERN float sqrtf (float x);

__EXTERN float expf  (float x);

__EXTERN float logf  (float x);

__EXTERN float log10f(float x);

__EXTERN float powf  (float x, float y);

__EXTERN float sinf  (float x);

__EXTERN float cosf  (float x);

__EXTERN float tanf  (float x);

__EXTERN float asinf (float x);

__EXTERN float acosf (float x);

__EXTERN float atanf (float x);

__EXTERN float atan2f(float y, float x);

__EXTERN float sinhf (float x);

__EXTERN float coshf (float x);

__EXTERN float tanhf (float x);



__INLINE float ceilf (float x);

__INLINE float floorf(float x);



__EXTERN float fabsf (float x);



__EXTERN float ldexpf(float x, int n);

__EXTERN float frexpf(float x, int *exp);

__EXTERN float modff (float x, float *ip);

__EXTERN float fmodf (float x, float y);



/* An inline version of fmodf that works for limited domain only */

/* See comments in implementation below */

static inline float _FMODF(float x, float y);



/* these present in many linked images, so we'll tell you about them. */

__EXTERN float _roundf(float x); /* round-to-nearest */

__EXTERN float _truncf(float x); /* truncate towards 0 */



#ifdef _TI_ENHANCED_MATH_H

#if 0

/* ------------------------------------------------- */

/* Routines below are an addition to ANSI math.h     */

/* Some (noted with "9x" in comment) will become ANSI*/

/* once C9x is approved.                             */

/* ------------------------------------------------- */

#endif



#define HUGE_VALF FLT_MAX /* 9x*/



__EXTERN float rsqrtf(float x); /*   == 1/sqrtf(x) but *MUCH* faster         */

__EXTERN float exp2f (float x); /*9x mathematically equiv to powf(2.0 ,x)    */

__EXTERN float exp10f(float x); /*   mathematically equiv to powf(10.0,x)    */

__EXTERN float log2f (float x); /*9x mathematically equiv to logf(x)/logf(2.)*/



__EXTERN float powif (float x, int i); /* equiv to powf(x,(float)i) */



__EXTERN float cotf  (float x);

__EXTERN float acotf (float x);

__EXTERN float acot2f(float x, float y);



__EXTERN float cothf (float x);



__EXTERN float asinhf(float x); /* 9x */

__EXTERN float acoshf(float x); /* 9x */

__EXTERN float atanhf(float x); /* 9x */

__EXTERN float acothf(float x);



#define roundf(x) _roundf(x) /* 9x round-to-nearest  */

#define truncf(x) _truncf(x) /* 9x truncate towards 0*/

#endif





#ifdef _INLINE

/****************************************************************************/

/*  Inline versions of floorf, ceilf, fmodf                                 */

/****************************************************************************/



static inline float floorf(float x) 

{

   float y; 

   return (modff(x, &y) < 0 ? y - 1 : y);

}



static inline float ceilf(float x)

{

   float y; 

   return (modff(x, &y) > 0 ? y + 1 : y);

}



/* 

   The implementation below does not work correctly for all cases.

   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).

   The correct result is one of 0,1, or 2.

   But the implementation below will *always* return 0 

   because the quotient is only an approximation.

*/

static inline float _FMODF(float x, float y)

{

   float d = fabsf(x); 

   if (d - fabsf(y) == d) return (0);

   modff(x/y, &d);  

   return (x - d * y);

}



#endif



#include <unaccess.h>



#endif /* float == double*/



#endif /* __mathf__*/


mathl.h/        1148595157  0     0     0       5425      `
/****************************************************************************/

/*  mathl.h          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:26 CDT 2000 */

 

#ifndef __mathl__

#define __mathl__



#ifndef EDOM

   #define EDOM   1

#endif



#ifndef ERANGE

   #define ERANGE 2

#endif



#include <float.h>



#if (LDBL_DIG == DBL_DIG) /* long double == doubl*/



#include <math.h>



#define sqrtl    sqrt

#define expl     exp

#define logl     log

#define log10l   log10

#define powl     pow

#define sinl     sin

#define cosl     cos

#define tanl     tan

#define asinl    asin

#define acosl    acos

#define atanl    atan

#define atan2l   atan2

#define sinhl    sinh

#define coshl    cosh

#define tanhl    tanh



#define ceill    ceil

#define floorl   floor



#define fabsl    fabs



#define ldexpl   ldexp

#define frexpl   frexp

#define modfl    modf

#define fmodl    fmod



#ifdef _TI_ENHANCED_MATH_H



#define HUGE_VALL LDBL_MAX



#define rsqrtl   rsqrt

#define exp2l    exp2

#define exp10l   exp10

#define log2l    log2

#define powil    powi

#define cotl     cot

#define acotl    acot

#define acot2l   acot2

#define cothl    coth

#define asinhl   asinh

#define acoshl   acosh

#define atanhl   atanh

#define acothl   acoth

#define truncl   _trunc

#define roundl   _nround



#endif



#else /* long double != double*/



#include <access.h>



__EXTERN long double sqrtl (long double x);

__EXTERN long double expl  (long double x);

__EXTERN long double logl  (long double x);

__EXTERN long double log10l(long double x);

__EXTERN long double powl  (long double x, long double y);

__EXTERN long double sinl  (long double x);

__EXTERN long double cosl  (long double x);

__EXTERN long double tanl  (long double x);

__EXTERN long double asinl (long double x);

__EXTERN long double acosl (long double x);

__EXTERN long double atanl (long double x);

__EXTERN long double atan2l(long double y, long double x);

__EXTERN long double sinhl (long double x);

__EXTERN long double coshl (long double x);

__EXTERN long double tanhl (long double x);



__INLINE long double ceill (long double x);

__INLINE long double floorl(long double x);



__EXTERN long double fabsl (long double x);



__EXTERN long double ldexpl(long double x, int n);

__EXTERN long double frexpl(long double x, int *exp);

__EXTERN long double modfl (long double x, long double *ip);

__EXTERN long double fmodl (long double x, long double y);



/* An inline version of fmod that works for limited domain only */

/* See comments in implementation below */

static inline long double _FMODL(long double x, long double y);



__EXTERN long double _roundl(long double x); /* round-to-nearest */

__EXTERN long double _truncl(long double x); /* truncate towards 0 */



#ifdef _TI_ENHANCED_MATH_H

#if 0

/* ------------------------------------------------- */

/* Routines below are an addition to ANSI math.h     */

/* Some (noted with "9x" in comment) will become ANSI*/

/* once C9x is approved.                             */

/* ------------------------------------------------- */

#endif



#define HUGE_VALL LDBL_MAX /* ##*/



__EXTERN long double rsqrtl(long double x); /*   1/sqrtl(x) but *MUCH* faster*/

__EXTERN long double exp2l (long double x); /*9x math equiv to powl(2.0 ,x)  */

__EXTERN long double exp10l(long double x); /*   math equiv to powl(10.0,x)  */

__EXTERN long double log2l (long double x);/*9x math equiv to logl(x)/logl(2)*/



__EXTERN long double powil (long double x, int i); /* == powl(x,(long double)i)*/



__EXTERN long double cotl  (long double x);

__EXTERN long double acotl (long double x);

__EXTERN long double acot2l(long double x, long double y);



__EXTERN long double cothl (long double x);



__EXTERN long double asinhl(long double x); /* 9x */

__EXTERN long double acoshl(long double x); /* 9x */

__EXTERN long double atanhl(long double x); /* 9x */

__EXTERN long double acothl(long double x);



#define roundl(x) _roundl(x) /* 9x round-to-nearest  */

#define truncl(x) _truncl(x) /* 9x truncate towards 0*/



#endif





#ifdef _INLINE

/****************************************************************************/

/*  Inline versions of floorl, ceill, fmodl                                 */

/****************************************************************************/



static inline long double floorl(long double x) 

{

   long double y; 

   return (modfl(x, &y) < 0 ? y - 1 : y);

}



static inline long double ceill(long double x)

{

   long double y; 

   return (modfl(x, &y) > 0 ? y + 1 : y);

}



/* 

   The implementation below does not work correctly for all cases.

   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).

   The correct result is one of 0,1, or 2.

   But the implementation below will *always* return 0 

   because the quotient is only an approximation.

*/

static inline long double _FMODL(long double x, long double y)

{

   long double d = fabsl(x); 

   if (d - fabsl(y) == d) return (0);

   modfl(x/y, &d);  

   return (x - d * y);

}



#endif



#include <unaccess.h>



#endif /* long double == double*/



#endif /* __mathl__*/


memccpy.c/      1148595157  0     0     0       964       `
/*****************************************************************************/

/*  MEMCCPY.C  v3.3.2                                                        */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/

#include "stdlib.h"



extern _CODE_ACCESS char *memccpy(char *dest, const char *src, int ch, int cnt);



/*--------------------------------------------------------------------------*/

/* PERFORM SAME OPERATION AS MEMCPY, ABORT IF "ch" is COPIED.               */

/* RETURN POINTER TO BYTE AFTER ch IS FOUND, OR NULL IF NOT FOUND           */

/*--------------------------------------------------------------------------*/

_CODE_ACCESS char *memccpy(char *dest, const char *src, int ch, int cnt)

{

   if (cnt <= 0) return NULL;

   do

      if ((*dest++ = *src++) == ch) return (dest);

   while (--cnt != 0);



   return NULL;

}

memchr.c/       1148595157  0     0     0       411       `
/****************************************************************************/

/*  memchr v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _MEMCHR



#include <string.h>


memcmp.c/       1148595157  0     0     0       363       `
/****************************************************************************/

/*  memcmp v3.3.2							    */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _MEMCMP



#include <string.h>


memcpy.c/       1148595157  0     0     0       586       `
/****************************************************************************/

/*  MEMCPY v3.3.2                                                           */

/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <string.h>



void *memcpy(void *to, const void *from, size_t n)

{

     register char *rto   = (char *) to;

     register char *rfrom = (char *) from;

     register size_t rn;



     for (rn = 0; rn < n; rn++) *rto++ = *rfrom++;

     return (to);

}

memmov.c/       1148595157  0     0     0       702       `
/****************************************************************************/

/*  memmov.c  v3.3.2                                                        */

/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <string.h>



void *memmove(void *s1, const void *s2, size_t n)

{

   if (s2 > s1)

      return memcpy(s1, s2, n);

   else

   {

      unsigned char *st1 = (unsigned char *)s1;

      unsigned char *st2 = (unsigned char *)s2;

      size_t         ln;

 

      st1 += n;

      st2 += n;

      for (ln = 0; ln < n; ln++) *--st1 = *--st2;

   }



   return s1;

}



memory.c/       1148595157  0     0     0       29654     `
/****************************************************************************/

/*  memory.c v3.3.2							    */

/*  Copyright (c) 1993-2006 Texas Instruments Incorporated		    */

/****************************************************************************/



/*****************************************************************************/

/*									     */

/*  This module contains the functions which implement the dynamic memory    */

/*  management routines.  The algorithms used are based on the algorithms    */

/*  described in Knuth's "The Art Of Computer Programming, Vol 1" on pages   */

/*  435-441. Algorithm 2.5A has been modified to improve the resistance to   */

/*  fragmentation.							     */

/*									     */

/*  Knuth gives two reasons for prefering "first fit" over "best fit".	     */

/*   1) The algorithm is significantly faster, since the whole of the free   */

/*	store does not have to be searched for each allocation		     */

/*	(or deallocation).						     */

/*   2) The first fit algorithm is more resistant to overflow during	     */

/*	repeated allocation and deallocation than is the best fit algorithm  */

/*	(See problems 36-43 on page 456).				     */

/*									     */

/*  The following assumptions/rules apply:				     */

/*									     */

/*   1) Packets are allocated a minimum of MINSIZE words	     	     */

/*   2) The heap can be reset at any time by calling the function	     */

/*	"minit"								     */

/*   3) The heap size must be declared in the linker command file using	     */

/*	the -heap option.						     */

/*									     */

/*  The following items are defined in this module :			     */

/*	 minit()    : Function to initialize dynamic memory management	     */

/*	 malloc()   : Function to allocate memory from mem mgmt system.	     */

/*	 calloc()   : Allocate and clear memory from mem mgmt system.	     */

/*	 realloc()  : Reallocate a packet				     */

/*	 free()	    : Function to free allocated memory.		     */

/*									     */

/*	_sys_memory : Array to contain all memory allocate by system.	     */

/*	 sys_free   : Pointer to free list				     */

/*									     */

/*	 free_memory() : Return total amount of available free memory.	     */

/*	 max_free() : Return largest single free memory block in heap.	     */

/*									     */

/*****************************************************************************/



/*****************************************************************************/

/*  DEBUG Support.							     */

/*  When the symbol DEBUG has been #defined, an extra WORD is added to the   */

/*  allocation header, and is set to the value 0xDEAD in every allocated and */

/*  free block of memory.  The integrety of the heap can then be checked by  */

/*  calling the function "void * chkheap()". This function returns zero if   */

/*  all the memory blocks have the correct signature.  Otherwise, it returns */

/*  the offset to the first location of an invalid value in a block header.  */

/*****************************************************************************/



#undef _INLINE				/* DISABLE INLINE EXPANSION	    */



#include <string.h>

#include <stdlib.h>

#include <stddef.h>

#include <_lock.h>



#ifdef DEBUG

#define GUARDWORD 0xDEAD

#endif



/*****************************************************************************/

/* Declare the memory pool as a .usect called .sysmem.	The size of the	     */

/* section .sysmem is determined by the linker via the -heap option	     */

/*****************************************************************************/

__asm("__sys_memory   .usect  \".sysmem\",0");

extern int _sys_memory[];



/*****************************************************************************/

/* "PACKET" is the template for a data packet.  "Packet_size" is the number  */

/* of words allocated for the user, excluding the size ("OVERHEAD") required */

/* for management of the packet.  The LSB of the size indicates whether the  */

/* packet is free.  When a packet is on the free list, the field "next_free" */

/* is a pointer to the next member of the freelist; when the packet is in    */

/* use (allocated), this field is invalid, overwritten by user data (the     */

/* address of this field is the address returned by malloc).		     */

/*****************************************************************************/

typedef struct fpack

{

    size_t packet_size; /* in addressable units */

#ifdef DEBUG

    int guard;

#endif

    struct fpack *next_free;

} PACKET;



#define LIMIT	((PACKET *) -1)



/*****************************************************************************/

/* OVERHEAD is the space in the packet required to store the packet size.    */

/* This macro is used for two purposes: to compute the size of the	     */

/* allocation, and to ensure the packet is aligned properly.		     */

/*****************************************************************************/

#define OVERHEAD offsetof(PACKET, next_free)



/*****************************************************************************/

/* MINSIZE is the smallest packet we will allocate.  It is required that     */

/* (MINSIZE + OVERHEAD >= sizeof(PACKET)), else the packet won't be large    */

/* enough to store the bookkeeping needed to be placed in the free list.     */

/* You can increase the value of MINSIZE to reduce fragmentation, but this   */

/* will introduce an extra bookkeeping overhead for very small allocations.  */

/*****************************************************************************/

#define MINSIZE (sizeof(PACKET))



/*****************************************************************************/

/* MAXALIGN is the number of chars of most strict alignment of any of the    */

/* builtin types.  Every return from malloc must be aligned to this number   */

/* of chars.  We use this to keep packets aligned.			     */

/*****************************************************************************/

typedef struct { 

    char dummy; 

    union u { 

	long l; long double ld; long long ll; 

	void *vp; void (*fp)(void); 

    } max_align_elt;

} max_align_struct;

#define MAXALIGN offsetof(max_align_struct, max_align_elt)



/*****************************************************************************/

/* How much do we need to add to round up a number to a certain alignment?   */

/* This will work for odd alignments, but will be more efficient with even   */

/* alignments.  All TI targets' type alignments are powers of two, and the   */

/* alignment is a compile-time constant, so the compiler should not generate */

/* an out-of-line call.							     */

/*****************************************************************************/

#define ROUNDUP_ADJUST(sz,aln) (((aln)-((sz)%(aln)))%(aln))



#define MAX(x,y) ((x)>(y)?(x):(y))



/*****************************************************************************/

/* These macros rely on the fact that for all C55x memory models, the	     */

/* maximum alignment is at least two, so all sizes stored in allocation	     */

/* packets will be even, so we can use the lowest bit to indicate freeness.  */

/*****************************************************************************/

#define SIZE_SET_FREE(x) ((x) & ~0x1)

#define SIZE_SET_USED(x) ((x) | 0x1)

#define SIZE_ACTUAL(x) ((x) & ~0x1)

#define SIZE_IS_USED(x) ((x) & 0x1)



/*****************************************************************************/

/* _SYSMEM_SIZE is the symbol that linker defines as the size of heap.	     */

/* Access of that value from 'C' is done by taking the address of this symbol*/

/* The C55x linker sets this symbol to the number of *bytes* in the heap, so */

/* we must convert thus number to words right away.                          */

/*****************************************************************************/

extern void _SYSMEM_SIZE(void);

#if __TMS320C55X_PLUS_BYTE__

#define MEMORY_SIZE ((size_t)&_SYSMEM_SIZE)

#else

#define MEMORY_SIZE ((size_t)((unsigned long)&_SYSMEM_SIZE >> 1))

#endif



/*****************************************************************************/

/* The list of free blocks						     */

/*****************************************************************************/

static PACKET *sys_free;



/*****************************************************************************/

/* The start of the heap						     */

/*****************************************************************************/

static PACKET *sys_base;



/*****************************************************************************/

/* The total size of the heap.						     */

/*****************************************************************************/

static size_t memsize;



/*****************************************************************************/

/* This flag tells malloc if the heap needs to be initialized	             */

/*****************************************************************************/

static int first_call = 1;



/*****************************************************************************/

/*									     */

/*  MINIT - This function performs the initial setup of the heap, and can    */

/*          be called by the user to completely reset the memory management  */

/*          system.				                             */

/*									     */

/*****************************************************************************/

void minit(void)

{

    /*-----------------------------------------------------------------------*/

    /* To initialize the memory system, set up the free list to point to     */

    /* the entire heap, and initialize heap to a single empty packet.	     */

    /*-----------------------------------------------------------------------*/

    /* We may need to adjust the start of the heap to ensure that the	     */

    /* address of the field "next_free" is strictly aligned.  Note that this */

    /* relies on the fact that we use only power-of-two alignment, and that  */

    /* there is no other field in "struct fpack" that is more strictly	     */

    /* aligned than "next_free."					     */

    /*-----------------------------------------------------------------------*/

    size_t adjust;

    _lock();



#pragma diag_suppress 770

#pragma diag_suppress 70

    adjust = ROUNDUP_ADJUST((size_t)_sys_memory + OVERHEAD, MAXALIGN);

#pragma diag_default  70

#pragma diag_default  770



    memsize = MEMORY_SIZE - (size_t)adjust;

    sys_free = (PACKET *) ((char*)_sys_memory + adjust);

    sys_free->packet_size = SIZE_SET_FREE(memsize);

    sys_free->next_free	  = LIMIT;

#ifdef DEBUG

    sys_free->guard = GUARDWORD;

#endif

    sys_base = sys_free;



    first_call = 0; /* CLEAR THE FLAG */

    _unlock();

}



/*****************************************************************************/

/*									     */

/*  MALLOC - Allocate a packet of a given size, and return pointer to it.    */

/*									     */

/*****************************************************************************/

void *malloc(size_t size)

{

    size_t allocsize = size;

    PACKET *current, *next, *prev;



    if (allocsize == 0) return 0;



    /*-----------------------------------------------------------------------*/

    /* Adjust requested size to include freelist bookkeeping overhead	     */

    /*-----------------------------------------------------------------------*/

    allocsize += OVERHEAD;



    /*-----------------------------------------------------------------------*/

    /* Reduce fragmentation by allocating at least a minimum size.  Free     */

    /* blocks originally allocated for very small requests will be available */

    /* for all requests under MINSIZE.					     */

    /*-----------------------------------------------------------------------*/

    allocsize = MAX(allocsize, MINSIZE);



    /*-----------------------------------------------------------------------*/

    /* We may need to adjust the size of the allocation request to ensure    */

    /* that the address of the field "next_free" remains strictly aligned in */

    /* all packets on the free list.  Once this adjustment is made, we no    */

    /* longer need to be concerned about alignment.			     */

    /*-----------------------------------------------------------------------*/

    allocsize += ROUNDUP_ADJUST(allocsize, MAXALIGN);



    _lock();



    if (first_call) minit();



    /*-----------------------------------------------------------------------*/

    /* Find the first block large enough to hold the requested allocation    */

    /*-----------------------------------------------------------------------*/

    current = sys_free;

    prev = 0;

    while (current != LIMIT && SIZE_ACTUAL(current->packet_size) < allocsize)

    {

	prev = current;

	current = current->next_free;

    }



    if (current == LIMIT)

    {

        /*-------------------------------------------------------------------*/

        /* No block large enough was found, so return NULL.		     */

        /*-------------------------------------------------------------------*/

	_unlock();

	return 0;

    }



    if (SIZE_ACTUAL(current->packet_size) > (allocsize + MINSIZE))

    {

        /*-------------------------------------------------------------------*/

        /* The packet is larger than needed; split the block and mark the    */

        /* smaller-addressed block as used.  The smaller-addressed block     */

        /* was chosen as a way to ensure that freed blocks get recycled	     */

        /* before allocations are made from the large original free block.   */

        /* However, this may tend to increase the length of the free list    */

        /* search for a large enough block.				     */

        /*-------------------------------------------------------------------*/

        /* Knuth's algorithm 2.5a instead allocates the larger-addressed     */

        /* block to the user.  This tends to leave the largest free blocks   */

        /* at the beginning of the free list.  Knuth's 2.5a' uses a "rover"  */

        /* pointer to prevent small free blocks from being concentrated in   */

        /* any part of the list.					     */

        /*-------------------------------------------------------------------*/



        /*-------------------------------------------------------------------*/

        /* Break off the new free block					     */

        /*-------------------------------------------------------------------*/

	size_t leftover = SIZE_ACTUAL(current->packet_size) - allocsize;

	next = (PACKET *)((char *)current + allocsize);

	next->packet_size = SIZE_SET_FREE(leftover);

	next->next_free = current->next_free;

#ifdef DEBUG

	next->guard = GUARDWORD;

#endif

	if (prev) prev->next_free = next;

	else      sys_free        = next;



        /*-------------------------------------------------------------------*/

        /* Adjust the size of the used block				     */

        /*-------------------------------------------------------------------*/

	current->packet_size = SIZE_SET_USED(allocsize);

    }

    else

    {

        /*-------------------------------------------------------------------*/

        /* Allocate the whole block and remove it from the free list.	     */

        /*-------------------------------------------------------------------*/

	if (prev) prev->next_free = current->next_free;

	else      sys_free        = current->next_free;



	current->packet_size = SIZE_SET_USED(current->packet_size);

    }



    _unlock();

    return &(current->next_free);

}



/*****************************************************************************/

/*									     */

/*  FREE - Return a packet allocated by malloc to free memory pool.	     */

/*									     */

/*****************************************************************************/

void free(void *userptr)

{

    PACKET *sysblock, *next, *prev;



    if (userptr == 0) return; /* HANDLE NULL POINTER */



    _lock();



    next = sys_free;

    prev = 0;

    sysblock = (PACKET *)((char *)userptr - OVERHEAD);

#if 0

#ifdef DEBUG

    /*-----------------------------------------------------------------------*/

    /* In the debug version, we can now check if the packet to be freed has  */

    /* the correct signature, but we must decide how to report the problem   */

    /* to the client code.						     */

    /*-----------------------------------------------------------------------*/

    if (sysblock->guard != GUARDWORD)

    {

	/* CODE TO REPORT THE ERROR */

    }

#endif

#endif



    /*-----------------------------------------------------------------------*/

    /* Search the free list for the *free* packets physically closest to     */

    /* the packet to be freed.  PREV is the closest free packet with a	     */

    /* smaller address, and NEXT is the closest free packet with a larger    */

    /* address.								     */

    /*-----------------------------------------------------------------------*/

    while (next < sysblock)

    {

	prev = next;

	next = next->next_free;

    }



    /*-----------------------------------------------------------------------*/

    /* Coallesce with next block if possible.				     */

    /*-----------------------------------------------------------------------*/

    if ((char *)sysblock + SIZE_ACTUAL(sysblock->packet_size) == (char *)next)

    {

	size_t combined = (SIZE_ACTUAL(sysblock->packet_size) + 

			   SIZE_ACTUAL(next->packet_size));

	

	sysblock->next_free = next->next_free;

	sysblock->packet_size = SIZE_SET_FREE(combined);

#ifdef DEBUG

	next->guard = 0;

#endif

    }

    else sysblock->next_free = next;	/* START TO PUT INTO LIST */



    if (prev)				/* ARE WE THE NEW HEAD OF THE LIST */

    {

        /*-------------------------------------------------------------------*/

        /* sysblock is not the head of the free list; try to coallesce with  */

        /* prev								     */

        /*-------------------------------------------------------------------*/

	if ((char *)prev + SIZE_ACTUAL(prev->packet_size) == (char *)sysblock)

	{

	    size_t combined = (SIZE_ACTUAL(sysblock->packet_size) + 

			       SIZE_ACTUAL(prev->packet_size));

	

	    prev->next_free = sysblock->next_free;

	    prev->packet_size = SIZE_SET_FREE(combined);

#ifdef DEBUG

	    sysblock->guard = 0;

#endif

	}

	else

	{

	    prev->next_free = sysblock;

	    sysblock->packet_size = SIZE_SET_FREE(sysblock->packet_size);

	}

    }

    else

    {

	sys_free = sysblock;

	sysblock->packet_size = SIZE_SET_FREE(sysblock->packet_size);

    }

    _unlock();

}



/*****************************************************************************/

/*									     */

/*  REALLOC - Reallocate a packet to a new size.			     */

/*									     */

/*****************************************************************************/

void *realloc(void *userptr, size_t size)

{

    PACKET *next, *prev, *sysblock;

    size_t newsize = size;



    /*-----------------------------------------------------------------------*/

    /* Handle special cases						     */

    /*-----------------------------------------------------------------------*/

    if (newsize == 0)

    {

	free(userptr);

	return 0;

    }



    if (userptr == 0) return malloc(newsize);



    /*-----------------------------------------------------------------------*/

    /* Adjust requested size to include freelist bookkeeping overhead	     */

    /*-----------------------------------------------------------------------*/

    newsize += OVERHEAD;



    /*-----------------------------------------------------------------------*/

    /* Reduce fragmentation by allocating at least a minimum size.  Free     */

    /* blocks originally allocated for very small requests will be available */

    /* for all requests under MINSIZE.					     */

    /*-----------------------------------------------------------------------*/

    newsize = MAX(newsize, MINSIZE);



    /*-----------------------------------------------------------------------*/

    /* We may need to adjust the size of the allocation request to ensure    */

    /* that the address of the field "next_free" remains strictly aligned in */

    /* all packets on the free list.  Once this adjustment is made, we no    */

    /* longer need to be concerned about alignment.			     */

    /*-----------------------------------------------------------------------*/

    newsize += ROUNDUP_ADJUST(newsize, MAXALIGN);



    /*-----------------------------------------------------------------------*/

    /* Find the start of the system block containing the old allocation.     */

    /*-----------------------------------------------------------------------*/

    sysblock = (PACKET *)((char *)userptr - OVERHEAD);



    /*-----------------------------------------------------------------------*/

    /* Find the system block physically after SYSBLOCK on the heap.	     */

    /*-----------------------------------------------------------------------*/

    next = (PACKET *)((char *)sysblock + SIZE_ACTUAL(sysblock->packet_size));



    /*-----------------------------------------------------------------------*/

    /* If we are growing the packet, check if we must revert to calling      */

    /* malloc and copying the data.  We must do so if:                       */

    /* 	   1) sysblock is the last block in the heap, or		     */

    /* 	   2) the next block is not free, or				     */

    /* 	   3) the next block is free but not big enough.		     */

    /*-----------------------------------------------------------------------*/

    _lock();

    if ((newsize > SIZE_ACTUAL(sysblock->packet_size)) && 

	(((char *)next >= (char *)sys_base + memsize) ||

	 SIZE_IS_USED(next->packet_size)              ||	

	 (newsize > (SIZE_ACTUAL(sysblock->packet_size) + 

		     SIZE_ACTUAL(next->packet_size)))))

    {

	void *ptr;

	_unlock();

	ptr = malloc(newsize);

	if (ptr)

	{

	    memcpy(ptr, userptr, SIZE_ACTUAL(sysblock->packet_size)-OVERHEAD);

	    free(userptr);

	}

	return ptr;

    }



    /*-----------------------------------------------------------------------*/

    /* Once we reach here, we know we can realloc in place.		     */

    /*-----------------------------------------------------------------------*/

    /* Search the free list for the *free* packets physically closest to     */

    /* the packet to be freed.  PREV is the closest free packet with a	     */

    /* smaller address, and NEXT is the closest free packet with a larger    */

    /* address.								     */

    /*-----------------------------------------------------------------------*/

    next = sys_free;

    prev = 0;



    while (next < sysblock)

    {

	prev = next;

	next = next->next_free;

    }



    if ((char *)next == (char *)sysblock + SIZE_ACTUAL(sysblock->packet_size))

    {

        /*-------------------------------------------------------------------*/

        /* The system block immediately following SYSBLOCK is free.	     */

        /* Coalesce with it, then try to free the unused portion.	     */

        /*-------------------------------------------------------------------*/

#ifdef DEBUG

	next->guard = 0;

#endif

        /*-------------------------------------------------------------------*/

	/* Be careful to avoid overflow here - MINSIZE is an unsigned type   */

        /*-------------------------------------------------------------------*/

	if (SIZE_ACTUAL(sysblock->packet_size) + 

	    SIZE_ACTUAL(next->packet_size) <= MINSIZE + newsize)

	{

            /*---------------------------------------------------------------*/

            /* The next block is completely absorbed.			     */

            /*---------------------------------------------------------------*/

	    size_t combined = (SIZE_ACTUAL(sysblock->packet_size) + 

			       SIZE_ACTUAL(next->packet_size));



	    if (prev) prev->next_free = next->next_free;

	    else      sys_free        = next->next_free;

	    sysblock->packet_size = SIZE_SET_USED(combined);

	}

	else

	{

            /*---------------------------------------------------------------*/

            /* The next block has enough space left over to break off a new  */

            /* block and add it to the free list.			     */

            /*---------------------------------------------------------------*/

	    size_t combined = (SIZE_ACTUAL(sysblock->packet_size) + 

			       SIZE_ACTUAL(next->packet_size));



	    PACKET *nextnext = next->next_free;



            /*---------------------------------------------------------------*/

            /* Break off the new free block				     */

            /*---------------------------------------------------------------*/

	    size_t nextsize = combined - newsize;

	    PACKET *newnext = (PACKET*)((char *)sysblock + newsize);

	    newnext->packet_size = SIZE_SET_FREE(nextsize);

	    newnext->next_free = nextnext;

#ifdef DEBUG

	    newnext->guard = GUARDWORD;

#endif

	    if (prev) prev->next_free = newnext;

	    else      sys_free        = newnext;



            /*---------------------------------------------------------------*/

            /* Adjust the size of the used block			     */

            /*---------------------------------------------------------------*/

	    sysblock->packet_size = SIZE_SET_USED(newsize);

	}

    }

    else

    {

        /*-------------------------------------------------------------------*/

        /* Shrink in place if there is enough extra to make a free block     */

        /*-------------------------------------------------------------------*/

	if (SIZE_ACTUAL(sysblock->packet_size) - newsize >= MINSIZE)

	{

            /*---------------------------------------------------------------*/

            /* Break off the new free block				     */

            /*---------------------------------------------------------------*/

	    size_t nextsize = SIZE_ACTUAL(sysblock->packet_size) - newsize;

	    PACKET *newnext = (PACKET*)((char *)sysblock + newsize);

	    newnext->packet_size = SIZE_SET_FREE(nextsize);

	    newnext->next_free = next;

#ifdef DEBUG

	    newnext->guard = GUARDWORD;

#endif

	    if (prev) prev->next_free = newnext;

	    else      sys_free        = newnext;



            /*---------------------------------------------------------------*/

            /* Adjust the size of the used block			     */

            /*---------------------------------------------------------------*/

	    sysblock->packet_size = SIZE_SET_USED(newsize);

	}

    }

    _unlock();

    return userptr;

}



/*****************************************************************************/

/*									     */

/*  CALLOC - Allocate a packet of a given size, set the data in the	     */

/*		 packet to nulls, and return a pointer to it.		     */

/*									     */

/*****************************************************************************/

void *calloc(size_t num, size_t size)

{

    size_t  i   = size * num;

    void   *ret = malloc(i);

    if (ret)

    {

	char *c = ret;

	while (i--) *c++ = 0;

    }

    return ret;

}





/*****************************************************************************/

/*									     */

/*  CHKHEAP - Check the integrety of the memory heap.  If the heap	     */

/*	      is corrupt, returns the address of the corrupt header, else    */

/*	      returns 0.  Always returns 0 in release version.		     */

/*									     */

/*****************************************************************************/

void *chkheap(void)

{

#ifdef DEBUG

    PACKET *pkt, *top;

    _lock();

    /* find the start of the heap */

    pkt = sys_base;

    top = (PACKET *)((char *)sys_base + memsize - sizeof(PACKET));



    while (pkt < top)

    {

	if (pkt->guard != GUARDWORD)

	{

	    _unlock();

	    return (void *) &pkt->guard;

	}



	pkt = (PACKET *)((char *)pkt + SIZE_ACTUAL(pkt->packet_size));

    }

    _unlock();

#endif



    return 0;

}



/*****************************************************************************/

/*									     */

/*  FREE_MEMORY - returns the total amount of free memory available for	     */

/*		  allocation.  The memory may be fragmented		     */

/*									     */

/*****************************************************************************/

size_t free_memory(void)

{

    struct fpack *ptr;

    size_t memsz = 0;



    _lock();

    ptr = sys_free;



    if (!first_call)	/* IF MEMORY IS INITIALIZED */

    {

	while (ptr != LIMIT)

	{

	    memsz += SIZE_ACTUAL(ptr->packet_size) - OVERHEAD;

	    ptr = ptr->next_free;

	}

    }

    _unlock();

    return memsz;

}



/*****************************************************************************/

/*									     */

/*  MAX_FREE - returns the size of the largest single block of memory	     */

/*	       available for allocation.				     */

/*									     */

/*****************************************************************************/

size_t max_free(void)

{

    struct fpack *ptr;

    size_t memsz = 0;



    _lock();

    ptr = sys_free;



    if (!first_call)	/* IF MEMORY IS INITIALIZED */

    {

	while (ptr != LIMIT)

	{

	    if (memsz < SIZE_ACTUAL(ptr->packet_size) - OVERHEAD)

		memsz = SIZE_ACTUAL(ptr->packet_size) - OVERHEAD;

	    ptr = ptr->next_free;

	}

    }

    _unlock();

    return memsz;

}

memset.c/       1148595157  0     0     0       411       `
/****************************************************************************/

/*  memset v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _MEMSET



#include <string.h>


memzero.cpp/    1148595157  0     0     0       2184      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Routine to clear a block of memory.  Used to initialize arrays that

do not have constructors.



*/



#include "basics.h"

#include "runtime.h"

#pragma hdrstop

#include <string.h>



#if __EDG_BSD

/*

Declare the bzero routine because some header files on BSD systems don't

provide a declaration.  Also, the minimal headers provided in the

release include directory don't declare bzero.

*/

EXTERN_C void bzero(void*, int);

#endif /* __EDG_BSD */



EXTERN_C void __memzero(void    *buffer,

                        size_t	size)

/*

Initialize a block of memory.

*/

{

#if __EDG_BSD

  bzero(buffer, size);

#else /* !__EDG_BSD */

  memset(buffer, 0, size);

#endif /* __EDG_BSD */

}  /* __memzero */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/



memzero.h/      1148595157  0     0     0       1680      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Declaration for __memzero.



*/



#ifndef MEMZERO_H

#define MEMZERO_H



#include "runtime.h"



EXTERN_C void __memzero(void    *buffer,

                        size_t	size);



#endif /* ifndef MEMZERO_H */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

mktime.c/       1148595157  0     0     0       4933      `
/****************************************************************************/

/*  mktime v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <time.h>

#include <limits.h>



static _DATA_ACCESS const unsigned int mon_len[] =

	{31,28,31,30,31,30,31,31,30,31,30,31 };

static _DATA_ACCESS const unsigned int mon_day[] =

	{0,31,59,90,120,151,181,212,243,273,304,334};



#define JAN11900    (time_t)1                   

#define DAYS_IN_YR  (time_t)365     

#define SECS_IN_MIN (time_t)60 

#define MINS_IN_HR  (time_t)60 

#define HRS_IN_DAY  (time_t)24 

#define SECS_IN_HR  (SECS_IN_MIN * MINS_IN_HR)

#define SECS_IN_DAY (SECS_IN_HR  * HRS_IN_DAY)

#define SECS_IN_YR  (DAYS_IN_YR  * SECS_IN_DAY)



/* THE FOLLOWING MACRO DETERINES IF ADDING k TO x CAUSES OVERFLOW */



#define OVERFLOW(x,k) (((x) > 0) == ((k) > 0) &&          \

                       ((unsigned)(x)       <= INT_MAX) != \

		       ((unsigned)((x)+(k)) <= INT_MAX))



#define LEAPYEAR(y)   ( ((y + 1900) % 4 == 0) &&      \

                       (((y + 1900) % 100 != 0) || ((y + 1900) % 400 == 0)) )



_CODE_ACCESS time_t mktime(register struct tm *tptr)

{

   time_t   result;

   time_t   daycount;

   int      mdays;

   int      adjust;

    

   /*-----------------------------------------------------------------*/

   /* HANDLE SECONDS.  IF TOO MANY OR TOO FEW, MODIFY MINUTES.        */

   /*-----------------------------------------------------------------*/

   adjust = (tptr->tm_sec < 0) ? -((unsigned)(-tptr->tm_sec + 59) / 60) 

			       : (tptr->tm_sec / 60);



   if (OVERFLOW(tptr->tm_min, adjust)) return((time_t) -1);

   tptr->tm_min += adjust;

   tptr->tm_sec -= adjust * 60;



   /*-----------------------------------------------------------------*/

   /* HANDLE MINUTES.  IF TOO MANY OR TOO FEW, MODIFY HOURS           */

   /*-----------------------------------------------------------------*/

   adjust = (tptr->tm_min < 0) ? -((unsigned)(-tptr->tm_min + 59) / 60) 

			       : (tptr->tm_min / 60);



   if (OVERFLOW(tptr->tm_hour, adjust)) return((time_t) -1);

   tptr->tm_hour += adjust;

   tptr->tm_min  -= adjust * 60;



   /*-----------------------------------------------------------------*/

   /* HANDLE HOURS.    IF TOO MANY OR TOO FEW, MODIFY DAYS            */

   /*-----------------------------------------------------------------*/

   adjust = (tptr->tm_hour < 0) ? -((unsigned)(-tptr->tm_hour + 23) / 24) 

			        : (tptr->tm_hour / 24);



   if (OVERFLOW(tptr->tm_mday, adjust)) return((time_t) -1);

   tptr->tm_mday += adjust;

   tptr->tm_hour -= adjust * 24;



   for (;;)

   {

      /*-----------------------------------------------------------------*/

      /* HANDLE MONTHS.   IF TOO MANY OR TOO FEW, MODIFY YEARS           */

      /*-----------------------------------------------------------------*/

      adjust = (tptr->tm_mon < 0) ? -((unsigned)(-tptr->tm_mon + 11) / 12) 

				  : (tptr->tm_mon / 12);



      if (OVERFLOW(tptr->tm_year, adjust)) return((time_t) -1);

      tptr->tm_year += adjust;

      tptr->tm_mon  -= adjust * 12;



      /*-----------------------------------------------------------------*/

      /* HANDLE DAYS.     IF TOO MANY OR TOO FEW, MODIFY MONTHS          */

      /*-----------------------------------------------------------------*/

      if (tptr->tm_mday <= 0)

      { 

	   tptr->tm_mon--;  

           tptr->tm_mday += mon_len[tptr->tm_mon < 0 ? 11 : tptr->tm_mon] + 

		        ((tptr->tm_mon == 1) && ((tptr->tm_year % 4) == 0));

	   continue;

      }



      /*-----------------------------------------------------------------*/

      /* CALCULATE NUMBER OF DAYS IN THIS MONTH.                         */

      /*-----------------------------------------------------------------*/

      mdays = mon_len[tptr->tm_mon] + 

		( (tptr->tm_mon == 1) && LEAPYEAR(tptr->tm_year) );



      if (tptr->tm_mday > mdays) 

	{ tptr->tm_mday -= mdays; tptr->tm_mon++; }

      else break;

   }



   /*--------------------------------------------------------------------*/

   /* WE CAN NOW BE SURE THAT ALL FIELDS IN THE TIME STRUCTURE ARE RIGHT */

   /*--------------------------------------------------------------------*/

   tptr->tm_yday = mon_day[tptr->tm_mon]  + tptr->tm_mday - 1 +

                   ( (tptr->tm_mon > 1) && LEAPYEAR(tptr->tm_year) );



   daycount      = tptr->tm_year * DAYS_IN_YR  + 

	           ((tptr->tm_year - 1) / 4)   + tptr->tm_yday;



   result        = daycount      * SECS_IN_DAY + 

	           tptr->tm_hour * SECS_IN_HR  +

	           tptr->tm_min  * SECS_IN_MIN + tptr->tm_sec;



   tptr->tm_wday  = (JAN11900 + daycount) % 7;

   tptr->tm_isdst = _tz.daylight;



   return result;

}




modf.c/         1148595157  0     0     0       2165      `
/****************************************************************************/

/*  modf.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Thu Jul 10 17:56:01 CDT 2003 */

 

#include "reald.h"



 REAL MODFF(REAL x, REAL *ip)

{

/*---------------------------------------------------------------------------*/

/* Decompose x into w and f such that                                        */

/* x == w + f, abs(f) < 1, floor(w) == w (w is whole number),                */

/* and signs of x, w, f are all same.                                        */

/* Return w in *ip and f as function result.                                 */

/*---------------------------------------------------------------------------*/

   REAL y;



   if (GEQF(x,CNST(-32768.0)) && LSSF(x,CNST( 32768.0))) FLTIF2(y,FIXFI(x));

   else



   {

   /* Deals properly with NAN, +/- INFINITY, +/- ZERO, denormalized numbers */



      int e, msbs;

      int *ptr;

      CPYF(y,x);

      ptr = (int *)(&y) + (((32/16)-1)*(0));

      msbs = *ptr;

      ptr += ((((32/16)-1)*(0^1))-(((32/16)-1)*(0))); /* point to LSBs of y, hope for auto increment */



      e = ((msbs >> (16 -(8 +1))) & ((1<<8)-1)) - (127 -1);



      if (e <= 0) { CPYF(*ip,ZERO); return x; } /* no integer part */

      /* above also covers ZERO's and denormalized numbers */



      if (e >= 24) {CPYF(*ip,x); return ZERO;}/*no fractional part*/

      /* above also covers INFINITY and NAN */



      /* truncate towards 0 by clearing (REAL_MANTISSA-e) mantissa LSBs */

      if (e <= (24 -16))

      {

         if (0) *ptr++ = 0; else *ptr-- = 0;

         *ptr = msbs & ~((1 << ((24 -16)-e))-1);

      }

      else *ptr &= ~((1 << (24 -e))-1);

   }



   __asm(" ");/* make sure *ptr is written before trying to read y */



   CPYF(*ip, y); /* return the integer part in *ip */

   return SUBF(x,y); /* get fractional part by subtracting integer part */

} /* MODFF */


mpyd.c/         1148595157  0     0     0       6323      `
/****************************************************************************/

/*  mpyd.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Nov 19 14:26:15 CST 2003 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



/* ----- WARNING WARNING WARNING WARNING ----- */



/* BLH modified this file 2003/11/18 to make FRCMPYF return a Q7.25

 * number when BPREAL == BPbigint.  When BPREAL == (BPbigint*2) (C6x

 * double), FRCMPYF still returns Q8.24 (I haven't updated it yet.) */



 REAL MPYF(REAL left, REAL right)

/*---------------------------------------------------------------------------*/

/* IEEE floating multiply.  return left * right                              */



/* Does *NOT* handle +/- INFINITY, NAN.                                      */



/* Does *NOT* handle denormalized numbers.                                   */



/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

/* See also:								     */

/*                                                                           */

/* Knuth D., "The Art of Computer Programming", Volume 2, ch 4.2	     */

/* ("Floating Point Arithmetic")					     */

/*                                                                           */

/* Goldberg D., "What Every Computer Scientist Should Know About	     */

/* Floating-Point Arithmetic", ACM Computing Surveys, Vol 23, No 1, March    */

/* 1991									     */

/*                                                                           */

/* Goldberg D., "Computer arithmetic."  Appendix A in "Computer		     */

/* Architecture: A Quantitative Approach, Patterson and Hennessy.	     */

/*                                                                           */

/* IEEE-754 "IEEE Standard for Binary Floating-Point Arithmetic"             */

/*---------------------------------------------------------------------------*/

{

 #ifdef IEEE_Hardware

   return left * right;

 #else



   unsigned long lfrc, rfrc, pfrc; /* fraction of left, right and product */

   int lexp, rexp, pexp; /* exponent of left, right and product */

   unsigned long sign;



   /*------------------------------------------------------------------------*/

   /* Unpack fraction and exponent, ignoring signs for now.                  */

   /* Reinsert hidden bit or re-normalize fraction as appropriate.           */

   /*------------------------------------------------------------------------*/

   pfrc = 0;

   REALasUNS(lfrc, left); sign = lfrc ; lfrc &= ~MINUS;

   REALasUNS(rfrc, right); sign = (sign ^ rfrc) & MINUS; rfrc &= ~MINUS;

   if (lexp = (int)(lfrc >> REAL_FRC_MSBs)) {

      if (!(lfrc &= REAL_FRC_MASK)) {

         /* left is a power of two */

         if (!(rexp = (rfrc >> REAL_FRC_MSBs))) {



            goto resign;



         } else pfrc = ((rfrc & REAL_FRC_MASK)+REAL_HIDDEN_BIT);

         pexp = lexp + rexp;

         goto insert_exponent;

      }

      lfrc += REAL_HIDDEN_BIT; /* insert hidden bit */

   }



   else goto resign;



   if (rexp = (int)(rfrc >> REAL_FRC_MSBs)) {

      if (!(rfrc &= REAL_FRC_MASK)) {

         /* right is a power of two */

         pexp = lexp + rexp;

         pfrc = lfrc;

         goto insert_exponent;

      }

      rfrc += REAL_HIDDEN_BIT; /*insert hidden bit*/

   }



   else goto resign;



   /*------------------------------------------------------------------------*/

   /* Compute product exponent and fraction.                                 */

   /* Round and normalize product if needed.                                 */

   /*------------------------------------------------------------------------*/

   pexp = lexp + rexp;



   pfrc = FRCMPYF(lfrc, rfrc);



   /*------------------------------------------------------------------------*/

   /* Assuming 32-bit float, pfrc is now in Q7.25 format, with two bits	     */

   /* for rounding.  First, normalize if the result is >= 2.xxxx	     */

   /*------------------------------------------------------------------------*/

   if (pfrc >= (REAL_HIDDEN_BIT<<3))

   { pfrc = (pfrc >> 1) | (pfrc & 1); pexp += 1; }



   /*------------------------------------------------------------------------*/

   /* Round to even.  If the rounding bits are exactly one half, round	     */

   /* the final result bit to the nearest even number (this may round down.) */

   /*------------------------------------------------------------------------*/

   if ((pfrc & 0x7) != 0x2) pfrc += 2;



   /*------------------------------------------------------------------------*/

   /* Discard the rounding bits.  pfrc is now in Q9.23 format.		     */

   /*------------------------------------------------------------------------*/

   pfrc >>= 2;



   /*------------------------------------------------------------------------*/

   /* If rounding rounded up past 2.xxx, renormalize.			     */

   /*------------------------------------------------------------------------*/

   if (pfrc >= (REAL_HIDDEN_BIT<<1)) { pfrc >>= 1; pexp += 1; }



insert_exponent:

   /*------------------------------------------------------------------------*/

   /* Check for overflow and underflow.                                      */

   /*------------------------------------------------------------------------*/

   if ((pexp -= 127) <= 0) { /* underflow */



      pfrc = 0; /* no significant bits remain */



      pexp = 0;

   }

   else if (pexp >= REAL_EXP_INFNAN) { /* overflow */



      pexp = REAL_EXP_INFNAN; pfrc = 0;



   }



   /*------------------------------------------------------------------------*/

   /* assemble result and return.                                            */

   /*------------------------------------------------------------------------*/

   pfrc = (pfrc & REAL_FRC_MASK) + (((long)pexp) << REAL_FRC_MSBs);



resign:;

   pfrc += sign;



   return_UNSasREAL(pfrc);

 #endif

} /* MPYF */


negd.c/         1148595157  0     0     0       676       `
/****************************************************************************/

/*  negd.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:39 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



  REAL NEGF(REAL x)

{

#ifdef IEEE_Hardware 

   return -x;

#else 

   MSC(x) ^= (char)(1<<(16 -1));

   return x;

#endif 

} /* NEGF */

new/            1148595157  0     0     0       2092      `
/*****************************************************************************/

/* new   v3.3.2                                                              */

/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _NEW

#define _NEW



#ifdef __EXCEPTIONS

#define THROW(throw_spec) throw(throw_spec)

#define THROW_NOTHING() throw()

#else /* !EXCEPTION_HANDLING */

#define THROW(throw_spec) /* Nothing. */

#define THROW_NOTHING() /* Nothing. */

#endif /* __EXCEPTIONS */



#include <cstdlib>      // for size_t

#include <exception>    // for exception



namespace std

{

   class bad_alloc {};

   struct nothrow_t {};

   extern const nothrow_t nothrow;

   typedef void (*new_handler)();

   new_handler set_new_handler(new_handler new_p) THROW_NOTHING();

}	



void *operator new(std::size_t size)  THROW(std::bad_alloc);

void *operator new(std::size_t size, const std::nothrow_t&)  THROW_NOTHING();

void  operator delete(void *ptr)  THROW_NOTHING();

void  operator delete(void *ptr, const std::nothrow_t&) THROW_NOTHING();

void *operator new[](std::size_t size)  THROW(std::bad_alloc);

void *operator new[](std::size_t size, const std::nothrow_t& nt_arg) THROW_NOTHING();

void  operator delete[](void *ptr) THROW_NOTHING();

void  operator delete[](void *ptr, const std::nothrow_t& nt_arg) THROW_NOTHING();

void *operator new  (std::size_t, void *ptr) THROW_NOTHING();

void *operator new[](std::size_t, void *ptr)  THROW_NOTHING();

void  operator delete  (void *ptr, void*)  THROW_NOTHING();

void  operator delete[](void *ptr, void*)  THROW_NOTHING();



#ifdef __embedded_cplusplus

//----------------------------------------------------------------------------

// We cannot expect the embedded C++ user to use std namespace. So we include

// the using directive when compiled under embedded C++.

//----------------------------------------------------------------------------

using namespace std;

#endif /* __embedded_cplusplus */



#endif

new_.cpp/       1148595157  0     0     0       3293      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ operator new();



*/



#include "basics.h"

#include "runtime.h"



/* Note that operator new is not in the std namespace. */





extern void *operator new(size_t size) THROW(STD_NAMESPACE::bad_alloc)

/*

Allocate the specified memory size from free store.  If the allocation fails,

call *_new_handler() if defined (non-NULL pointer), and try the allocation

again.  The new_handler is permitted to

	- cause more memory to be available,

	- throw an exception, or

	- call exit or abort.



If the size passed by the caller is zero, it is incremented to one

because the behavior of malloc is unspecified when size is zero.

In C++, a call of operator new(0) must return a value distinct from other

calls of operator new.

*/

{

  void *ptr;



  if (size == 0) size = 1;

  while ((ptr = (void *)malloc(size)) == NULL) {

    /* The allocation failed -- call the current new handler routine.  Use

       the routine pointed to by _new_handler.  If this value is NULL, use

       the default new handler. */

    STD_NAMESPACE::new_handler	new_handler;

    new_handler = _new_handler != NULL ? _new_handler : __default_new_handler;

    (*new_handler) ();

#if !EXCEPTION_HANDLING

    /* A new handler is supposed to make more memory available, or to exit

       via an exception or by calling abort() or exit().  In order to support

       implementations without exception handling, the older protocol of

       returning a NULL value is supported by the default new handler.

       If the default new handler is being used, and exceptions are not

       enabled, return a NULL pointer. */

    if (new_handler == (STD_NAMESPACE::new_handler)__default_new_handler) {

      return (void *)NULL;

    }  /* if */

#endif /* EXCEPTION_HANDLING */

  }  /* while */

  return ptr;

}  /* operator new */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/




newhandler.cpp/ 1148595157  0     0     0       2112      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ default new handler.



*/



#include "basics.h"

#include "runtime.h"



extern void __default_new_handler(void)

/*

The default new handler routine that is called when operator new cannot

allocate memory.  When exceptions are enabled, this routine simply throws

a bad_alloc exception.  When exceptions are not enabled, we simply return

to the caller, which detects that the default new handler is being used

and returns a NULL pointer to the caller.

*/

{

#if EXCEPTION_HANDLING

  throw STD_NAMESPACE::bad_alloc();

#else /* !EXCEPTION_HANDLING */

  return;

#endif /* EXCEPTION_HANDLING */

}  /* __default_new_handler */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/







newnothrow.cpp/ 1148595157  0     0     0       4632      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ operator new() that does not throw an exception.



*/



#include "basics.h"

#include "runtime.h"



/* 

 * Define std::nothrow. Dinkumware defines it in DINKUMLIB/source/nothrow.cpp

 * so, we require this definition only for the TI RTS. The definition here

 * is guarded by _C_IN_NS to prevent multiple definitions in the Dinkumware

 * library. _C_IN_NS is defined in DINKUMLIB/include/c/yvals.h. Despite the

 * name, the convention has been to check for _C_IN_NS to determine if

 * we are building the Dinkumware RTS versus the TI RTS

 */

#if !defined(_C_IN_NS)

namespace std

{

   const nothrow_t nothrow;

}

#endif



extern "C" STD_NAMESPACE::new_handler _new_handler;



/* Note that operator new is not in the std namespace. */



static a_boolean call_new_handler()

/*

Call the new handler routine.  If exception handling is supported, wrap

the call in a try block to see if the new handler throws a bad_alloc

exception.

*/

{

  a_boolean	done = FALSE;

  /* The allocation failed -- call the current new handler routine.  Use

     the routine pointed to by _new_handler.  If this value is NULL, use

     the default new handler. */

  STD_NAMESPACE::new_handler  new_handler;

  new_handler = _new_handler != NULL ? _new_handler : __default_new_handler;

#if EXCEPTION_HANDLING

  try {

    (*new_handler) ();

  }

  catch (STD_NAMESPACE::bad_alloc) {

    done = TRUE;

  }

#else /* !EXCEPTION_HANDLING */

  (*new_handler) ();

  /* A new handler is supposed to make more memory available, or to exit

     via an exception or by calling abort() or exit().  In order to support

     implementations without exception handling, the older protocol of

     returning a NULL value is supported by the default new handler.

     If the default new handler is being used, and exceptions are not

     enabled, return a NULL pointer. */

  if (new_handler == (STD_NAMESPACE::new_handler)__default_new_handler) {

    done = TRUE;

  }  /* if */

#endif /* EXCEPTION_HANDLING */

  return done;

}  /* call_new_handler */





void *operator new(size_t size, const STD_NAMESPACE::nothrow_t&)

THROW_NOTHING()

/*

Allocate the specified memory size from free store.  If the allocation fails,

call *_new_handler() if defined (non-NULL pointer), and try the allocation

again.  The new_handler is permitted to

	- cause more memory to be available,

	- throw an exception, or

	- call exit or abort.



If the size passed by the caller is zero, it is incremented to one

because the behavior of malloc is unspecified when size is zero.

In C++, a call of operator new(0) must return a value distinct from other

calls of operator new.

*/

{

  void *ptr;



  if (size == 0) size = 1;

  while ((ptr = (void *)malloc(size)) == NULL) {

    if (_new_handler != NULL) {

      /* Call the new handler.  The call_new_handler will return TRUE if

         a NULL pointer should be returned to the caller. */

      if (call_new_handler()) return (void*)NULL;

    } else {

      /* There is no new handler -- Just return a NULL. */

      return (void *)NULL;

    }  /* if */

  }  /* while */

  return ptr;

}  /* operator new */





/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

numconst.h/     1148595157  0     0     0       6273      `
/****************************************************************************/

/*  numconst.h       v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:28 CDT 2000 */

 

#ifndef __numconst__

#define __numconst__



#if 0

/*---------------------------------------------------------------------------*/

/* Numerical Constants                                                       */

/*---------------------------------------------------------------------------*/

/* Most of the following constants are taken from                            */

/* "Standard Mathematical Tables", (18th edition, 1970),                     */

/* Editor-In-Chief: Samuel M. Selby Ph.D. Sc.D.,                             */

/* The Chemical Rubber Co. 18901 Cranwood Parkway, Cleveland, Ohio 44128.    */

/* Page 6.                                                                   */

/*---------------------------------------------------------------------------*/

/* The following conventions are used:                                       */

/* Ln  = "log base e"                                                        */

/* Log = "log base 10"                                                       */

/*                                                                           */

/* compile-time division is avoided in favor of multiplication.              */

/*---------------------------------------------------------------------------*/







/*---------------------------------------------------------------------------*/

/* Common values.                                                            */

/*---------------------------------------------------------------------------*/

#endif



#define ZERO      CNST(0.0)

#define SIXTEENTH CNST(0.0625)

#define EIGHTH    CNST(0.125)

#define TENTH     CNST(0.1)

#define QUARTER   CNST(0.25)

#define THIRD     CNST(0.3333333333333333333333333333333333333333333333333)

#define HALF      CNST(0.5)

#define ONE       CNST(1.0)

#define TWO       CNST(2.0)

#define THREE     CNST(3.0)

#define FOUR      CNST(4.0)

#define SIX       CNST(6.0)

#define TEN       CNST(10.0)

#define SIXTEEN   CNST(16.0)



#define M_ONE     CNST(-1.0)

#define M_TWO     CNST(-2.0)





#if 0

/*---------------------------------------------------------------------------*/

/* PI constants                                                              */

/*---------------------------------------------------------------------------*/

#endif

#define Pi          CNST(3.14159265358979323846264338327950288419716939937510)

#define Two_Pi      (MPYF(Pi,TWO))

#define One_Over_Pi CNST(0.31830988618379067153776752674502872406891929148091)

#define Two_Over_Pi (MPYF(TWO,One_Over_Pi))



#define Pi_Over_Two   (MPYF(Pi,HALF))

#define Pi_Over_Three (DIVF(Pi,CNST(3.0)))

#define Pi_Over_Four  (MPYF(Pi,CNST(0.25)))

#define Pi_Over_Six   (MPYF(Pi_Over_Three,HALF))



#define Pi_Squared   CNST(9.86960440108935861883449099987615113531369940724079)

#define Ln_Pi        CNST(1.14472988584940017414342735135305871164729481291531)

#define Log_Pi       CNST(0.49714987269413385435126828829089887365167832438044)

#define Log_Sqrt_Two_Pi CNST(0.39908993417905752478250359150769595020993410292127)





#if 0

/*---------------------------------------------------------------------------*/

/* Constants Involving e                                                     */

/*---------------------------------------------------------------------------*/

#endif

#define Naperian_e CNST(2.71828182845904523536028747135266249775724709369995)

#define One_Over_e CNST(0.36787944117144232159552377016146086744581113103176)



#define e_Squared CNST(7.38905609893065022723042746057500781318031557055184)



#define Ln_10 CNST(2.30258509299404568401799145468436420760110148862877)

#define One_Over_Log_e Ln_10



#define One_Over_Ln_10 CNST(0.43429448190325182765112891891660508229439700580366)

#define Log_e One_Over_Ln_10





#if 0

/*---------------------------------------------------------------------------*/

/* Pi**e and e**Pi Constants                                                 */

/*---------------------------------------------------------------------------*/

#endif

#define Pi_To_e            CNST(22.4591577183610454734271522) 

#define e_To_Pi            CNST(23.1406926327792690057290864)

#define e_To_Minus_Pi      CNST( 0.0432139182637722497744177)

#define e_To_Hlf_Pi        CNST( 4.8104773809653516554730357)

#define e_To_Minus_Hlf_Pi  CNST( 0.2078795763507619085469556)





#if 0

/*---------------------------------------------------------------------------*/

/* Numerical Constants                                                       */

/*---------------------------------------------------------------------------*/

#endif

#define Sqrt_2       CNST(1.41421356237309504880168872420969807856967187537694)

#define Cube_Root_2  CNST(1.25992104989487316476721060727822835057025146470150)

#define One_Over_Sqrt_2 CNST(0.70710678118654752440)

#define Ln_2         CNST(0.69314718055994530941723212145817656807550013436025)

#define One_Over_Ln_2 CNST(1.44269504088896340735)

#define Log_2        CNST(0.30102999566398119521373889472449302676818988146210)

#define Sqrt_3       CNST(1.73205080756887729352744634150587236694280525381038)



#define Cube_Root_3  CNST(1.44224957030740838232163831078010958839186925349935)

#define Ln_3         CNST(1.09861228866810969139524523692252570464749055782274)

#define Log_3        CNST(0.47712125471966243729502790325511530920012886419069)





#if 0

/*---------------------------------------------------------------------------*/

/* Other Constants                                                           */

/*---------------------------------------------------------------------------*/

#endif

#define Gamma     CNST( 0.57721566490153286061) /* Euler's Constant*/

#define Ln_Gamma  CNST(-0.54953931298164482234)



#define Phi CNST(1.618033988749894848204586834365638117720309180)/*Gold Ratio*/



#endif /* __numconst_*/


perror.c/       1148595157  0     0     0       2043      `
/*****************************************************************************/

/*  PERROR.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    PERROR   -  Report any system errors to stderr                         */

/*****************************************************************************/

#include <stdio.h>

#include <errno.h>





/*****************************************************************************/

/* PERROR   -  Report any system errors to stderr                            */

/*****************************************************************************/

_CODE_ACCESS void perror(const char *_s)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   char *buf;



   /*------------------------------------------------------------------------*/

   /* If _s is not NULL, prepend it to any error message.                    */

   /*------------------------------------------------------------------------*/

   if (_s && *_s)

   {

      fputs(_s, stderr);

      fputs(": ", stderr);

   }



   switch(errno)

   {

      case 0      :  buf = "No error";                  break;

      case EDOM   :  buf = "Domain error";              break;

      case ERANGE :  buf = "Range error";               break;

      case ENOENT :  buf = "No such file or directory"; break;

      case EFPOS  :  buf = "File positioning error";    break;

      default     :  buf = "Unknown error";             break;

   }



   fputs(buf, stderr);

   fputc('\n', stderr);

}




placedel.cpp/   1148595157  0     0     0       1798      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/



/*



C++ operator delete(size_t, void*);



*/



#include "basics.h"

#include "runtime.h"



#if ABI_CHANGES_FOR_PLACEMENT_DELETE



void operator delete(void *, void *) THROW_NOTHING()

/*

Placement operator delete -- does nothing.

*/

{

}  /* operator delete (size_t, void*) */



#endif /* ABI_CHANGES_FOR_PLACEMENT_DELETE */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

placenew.cpp/   1148595157  0     0     0       1815      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ operator new(size_t, void*);



*/



#include "basics.h"

#include "runtime.h"



#if DEFINE_PLACEMENT_NEW_ROUTINES



void *operator new(size_t, void *ptr) THROW_NOTHING()

/*

Return the value of ptr as the address of the new object.

*/

{

  return ptr;

}  /* operator new (size_t, void*) */



#endif /* DEFINE_PLACEMENT_NEW_ROUTINES */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/


pow.c/          1148595157  0     0     0       4555      `
/****************************************************************************/

/*  pow.c            v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Thu Jul 10 17:56:01 CDT 2003 */

 

#include "reald.h"



 REAL POWF(REAL x, REAL y)

{

/* Adapted from "Software Manual for the Elementary Functions"               */

/* Cody and Waite, Prentice Hall 1980. pages 84-112.                         */

    static REAL A1[17] = /* 24 mantissa bits */

      {KNST( 1.0000000000000E+00),

       KNST( 9.5760327577590E-01),

       KNST( 9.1700404882431E-01),

       KNST( 8.7812608480453E-01),

       KNST( 8.4089642763137E-01),

       KNST( 8.0524516105651E-01),

       KNST( 7.7110540866851E-01),

       KNST( 7.3841309547424E-01),

       KNST( 7.0710676908493E-01),

       KNST( 6.7712777853012E-01),

       KNST( 6.4841979742050E-01),

       KNST( 6.2092888355255E-01),

       KNST( 5.9460353851318E-01),

       KNST( 5.6939429044723E-01),

       KNST( 5.4525387287139E-01),

       KNST( 5.2213686704635E-01),

       KNST( 5.0000000000000E-01)};



    static REAL A2[8] = /* 24 mantissa bits */

      {KNST( 4.9226642231081E-09),

       KNST(-4.6178851705532E-09),

       KNST( 4.9181085994022E-09),

       KNST(-2.2504493508369E-08),

       KNST(-5.0616744854603E-09),

       KNST( 2.2484190754765E-08),

       KNST( 2.6931110719430E-08),

       KNST( 2.4167350718989E-08)};

    static REAL P[1] =

       {KNST(0.83357541e-1)};

    static REAL Q[3] =

       {KNST(0.54360383e-1),

        KNST(0.24018510e+0),

        KNST(0.69314675e+0)};

    REAL g, z, v, r, u1, u2, w1, w2, w3, y1, y2, w, ip;

    EXPONENT_TYPE m;

    int p, iw1, i;



    if LEZF(x)

    {

       if LSZF(x)

       {

          if (NEQF(TRUNCF(y), y)) {errno = EDOM; return POWF(x,(ROUNDF(y)));}

          CPYF(z, POWF(ABSF(x),y));

          if (GEQF(y, CNST(-32768.0)) && LSSF(y, CNST( 32768.0))){

             if (FIXFI(y) & 1) NEGF1(z); /* odd */

          } else {

             if NEZF(MODFF(MPYF(y,HALF),&ip)) NEGF1(z);

          }

          return z;

      }

      if LSZF(y) { errno = EDOM; return CNST(-3.402823466E+38); }

      if EQZF(y) return ONE;

      return x; /* x holds 0 */

    }



    if EQLF(x, ONE) return x; /* pow(1.0,y) == 1.0 */

    if EQLF(y, ONE) return x; /* pow(x,1.0) == 1.0 */



    RIPF(x, g, m);



    /* fast more accurate path for (RADIX**(m-1))**y, y is whole number */

    if EQLF(g,CNST(0.5))

    {

       p = FIXFI(y); /* overflow OK here */

       if EQLF(FLTIF(p),y) /*EQZF(MODFF(y,&ip))*/

          return SCLF(ONE,(m-1)*p);

    }



    p = 1;

    if LEQF(g, A1[ (9-1)]) p = 9;

    if LEQF(g, A1[p+(4-1)]) p += 4;

    if LEQF(g, A1[p+(2-1)]) p += 2;



    CPYF(z,A1[p+(1-1)]);



    /* z = ((g - z) - A2[(p+(1-1))/2])/(g + z); */

    DIVF3(z, SUBF(SUBF(g,z),

                  A2[(p+1)/2-1]),

             ADDF(g, z));



    ADDF2(z,z);

    SQRF2(v,z);



    POLYF(r,v,P,1);

    MPYF2(r,z);



    ADDF2(r, MPYF(CNST(0.44269504088896340736),r));

    ADDF3(u2, ADDF(r, MPYF(z, CNST(0.44269504088896340736))), z);

    MPYF3(u1, FLTIF(m*16 - p), SIXTEENTH);

    if (GEQF(y, DIVF(CNST( 32768.0),SIXTEEN)) ||

        LSSF(y, DIVF(CNST(-32768.0) ,SIXTEEN)))

       MPYF3(y1, ROUNDF(SCLF(y,4)), SIXTEENTH);

    else

       MPYF3(y1, RNDF(MPYF(SIXTEEN, y)), SIXTEENTH);



    SUBF3(y2, y, y1);

    ADDF3(w, MPYF(u2,y), MPYF(u1,y2));

    if (GEQF(w, DIVF(CNST( 32768.0),SIXTEEN)) ||

        LSSF(w, DIVF(CNST(-32768.0) ,SIXTEEN)))

       MPYF3(w1, ROUNDF(SCLF(w,4)),SIXTEENTH);

    else

       MPYF3(w1, RNDF(MPYF(SIXTEEN,w)), SIXTEENTH);



    SUBF3(w2, w, w1);

    ADDF3(w, w1, MPYF(u1,y1));



    if GTRF(w, CNST( 1418.0))

    {

       errno = ERANGE; return CNST( 3.402823466E+38);

    }

    if LSSF(w, CNST(-1386.0)) return ZERO;



    MPYF3(w1, RNDF(MPYF(SIXTEEN,w)), SIXTEENTH);

    ADDF2(w2, SUBF(w, w1));

    MPYF3(w3, RNDF(MPYF(SIXTEEN,w2)), SIXTEENTH);

    FIXFI2(iw1, MPYF(SIXTEEN, ADDF(w1, w3)));

    SUBF2(w2, w3);



    if GTZF(w2)

    {

       SUBF2(w2, SIXTEENTH);

       iw1 += 1;

    }



    i = ((iw1 < 0) ? 0 : 1);

    m = (EXPONENT_TYPE)(i + iw1/16);

    p = 16*(int)(m) - iw1;



    POLYF(z,w2,Q,3);



    ADDF3(z, A1[p+(1-1)],

             MPYF(A1[p+(1-1)], z));



    return SCLF(z, m);

} /* POWF */


powi.c/         1148595157  0     0     0       1557      `
/****************************************************************************/

/*  powi.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:51 CDT 2000 */

 

#include "reald.h"



  REAL POWIF(REAL x, int i) /* return x ** i, i an integer */

{

   REAL r, s, rp, sp;

   int invert;

   int t;



   RIPF(x, r, t);

   if EQLF(r, CNST(0.5) ) return SCLF(ONE,(t-1)*i);



   invert = 0 ;

   t = i;

   if (t < 0) {

      invert = 1 ;

      if (t > INT_MIN) t = -t;

   }

   CPYF(s,x);

   if (t & 1) CPYF(r,s); else CPYF(r,ONE);

   if (t < 0) t = -(INT_MIN/2); else t = t >> 1;

   while ((t != 0) && NEZF(r)) {

      SQRF2(sp,s);

      if GEQF(sp,CNST( 3.402823466E+38) ) { /* overflow? */

         if (!invert) { errno = ERANGE; return CNST( 3.402823466E+38) ; };

         INVF1(s); INVF1(r);

         invert = 0 ;

         SQRF2(sp,s);         

      }

      if (t & 1) {

         MPYF3(rp,r,sp);

         if GEQF(rp,CNST( 3.402823466E+38) ) { /* overflow? */

            if (!invert) { errno = ERANGE; return CNST( 3.402823466E+38) ; };

            INVF1(s); INVF1(r);

            invert = 0 ;

            SQRF2(sp,s);

            MPYF3(rp,r,sp);

         }

	 CPYF(r,rp);

      }

      CPYF(s,sp); 

      t = t >> 1;

   }

   if (invert) return INVF(r);

   return r;

} /* POWIF */


printf.c/       1148595157  0     0     0       2875      `
/*****************************************************************************/

/*  PRINTF.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    PRINTF   -  Print formatted output to stdio                            */

/*    _OUTC    -  Put a character in a stream                                */

/*    _OUTS    -  Put a string in a stream                                   */

/*****************************************************************************/

#include <stdio.h>

#include "format.h"

#include <stdarg.h>

#include <string.h>

 

extern int _printfi(char **_format, va_list _ap, void *_op, 

                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

 

static int _outc(char c, void *_op);

static int _outs(char *s, void *_op);

 



/*****************************************************************************/

/* PRINTF   -  Print formatted output to stdio                               */

/*                                                                           */

/*    This function passes a the format string and an argument list to       */

/*    _PRINTFI, and writes the result string to the stream stdio.            */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int printf(const char *_format, ...)

{

   va_list _ap;

   int rval;

   char *fptr = (char *)_format;

 

   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if(stdout->fd == -1) return (-1);



   va_start(_ap, _format);

   rval = _printfi(&fptr, _ap, (void *)stdout, _outc, _outs);

   va_end(_ap);

   return (rval);

}

 



/*****************************************************************************/

/* _OUTC -  Put a character in a stream                                      */

/*****************************************************************************/

static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }

 



/*****************************************************************************/

/* _OUTS -  Put a string in a stream                                         */

/*****************************************************************************/

static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }




pure_virt.cpp/  1148595157  0     0     0       2154      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ runtime routine __pure_virtual_called() -- called when the user

calls a pure virtual function.  This function simply aborts the program.



*/



#include "basics.h"

#include "runtime.h"



#ifdef __EDG_IA64_ABI

#define PURE_VIRTUAL_FUNCTION_NAME __cxa_pure_virtual

#else /* !defined(__EDG_IA64_ABI) */

#define PURE_VIRTUAL_FUNCTION_NAME __pure_virtual_called

#endif /* !defined(__EDG_IA64_ABI) */



extern "C" {

	void PURE_VIRTUAL_FUNCTION_NAME(void);

}





void PURE_VIRTUAL_FUNCTION_NAME(void)

/*

Notify the user that a call to a pure virtual function has been made and

abort the program.

*/

{

  __abort_execution(ec_pure_virtual_called);

}  /* __pure_virtual */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

qsort.c/        1148595157  0     0     0       1830      `
/****************************************************************************/

/*  qsort v3.3.2                                                            */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdlib.h>



static void swap_item(register char *src, 

                      register char *dest, 

                      register size_t size);



_CODE_ACCESS void qsort(void *base, size_t nmemb, size_t size, 

			int (*compar)(const void *, const void *))

{

   register char     *basep  = base;         /* POINTER TO ARRAY OF ELEMENTS */

   register unsigned  i      = 0;            /* left scan index  */

   register unsigned  j      = nmemb - 1;    /* right scan index */

   register unsigned  pivot  = (nmemb / 2);

   register char     *pivp   = basep + (pivot * size);



   if (nmemb <= 1) return;



   while( i < j )

   {

      while( (*compar) (basep + (i * size), pivp) < 0 ) ++i;

      while( (*compar) (basep + (j * size), pivp) > 0 ) --j;

      if( i < j )

      {

	 swap_item(basep + (i * size), basep + (j * size), size);

	 if     ( pivot == i ) { pivot = j; pivp = basep + (pivot * size); }

	 else if( pivot == j ) { pivot = i; pivp = basep + (pivot * size); } 

	 ++i; --j;

      }

      else if ( i == j ) { ++i; --j;  break; }

   }



   if( j > 0)       qsort(basep, j + 1, size, compar);

   if( i < nmemb-1) qsort(basep + (i * size), nmemb - i, size, compar);

}





static void swap_item(register char *src, 

                      register char *dest, 

                      register size_t size)

{

    while (size--)

    {

        register int temp = *src;       

        *src++            = *dest;

        *dest++           = temp;

    }

}



rand.c/         1148595157  0     0     0       928       `
/****************************************************************************/

/*  rand.c v3.3.2							    */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdlib.h>

#include <_lock.h>



/***************************************************************/

/* THIS IS AN IMPLEMENTATION WHICH IS INTENDED TO BE PORTABLE, */

/* AS PER THE ANSI STANDARD C SPECIFICATION                    */

/***************************************************************/

static _DATA_ACCESS unsigned long next = 1;



_CODE_ACCESS int rand(void)

{

     int r;

     _lock();

     next = next * 1103515245 + 12345;

     r = (int)((next/65536) % ((unsigned long)RAND_MAX + 1));

     _unlock();

     return r;

}



_CODE_ACCESS void srand(unsigned seed)

{

     _lock();

     next = seed;

     _unlock();

}

reald.h/        1148595157  0     0     0       611       `
/****************************************************************************/

/*  reald.h          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:30 CDT 2000 */

 

#ifndef __reald__

#define __reald__



#include <limits.h>

#include <errno.h>

#include "ld3_32.h"

#include "formi32.h"

#include "syntd.h"

#include <math.h>

#include "access.h"



#endif /* __reald__ */


realdi.h/       1148595157  0     0     0       635       `
/****************************************************************************/

/*  realdi.h         v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:23 CDT 2000 */

 

#ifndef __realdi__

#define __realdi__



#include <limits.h>

#include <errno.h>

#include "ld3_32.h"

#include "formi32.h"

#include "syntdi.h"

#include "ieeed.h"

#include <math.h>

#include "access.h"



#endif /* __realdi__ */


remli.c/        1148595157  0     0     0       620       `
/****************************************************************************/

/*  remli.c          v3.3.2                                                 */

/*  Copyright (c) 2002-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <limits.h>



long _remli(long x1, long x2)

{

    unsigned long t1, t2;

    long result;



    if (x2 == 0) return LONG_MAX;



    t1 = (x1 == LONG_MIN ? x1 : labs(x1));

    t2 = (x2 == LONG_MIN ? x2 : labs(x2));



    result = t1 % t2;



    return (x1 < 0) ? -result : result;

}

remove.c/       1148595157  0     0     0       1012      `
/*****************************************************************************/

/*  REMOVE.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    REMOVE   -  Erase a file                                               */

/*****************************************************************************/

#include <stdio.h>

#include "file.h"





/*****************************************************************************/

/* REMOVE   -  Erase a file                                                  */

/*****************************************************************************/

_CODE_ACCESS int remove(const char *_file) { return (_remove(_file)); }



remul.c/        1148595157  0     0     0       1172      `
/****************************************************************************/

/*  remul.c          v3.3.2                                                 */

/*  Copyright (c) 2002-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

static __inline unsigned long _subcul(unsigned long src1, unsigned long src2)

{

    int test = (src1 >= src2);



    if (test) src1 -= src2;



    return src1 << 1 | test;	

}



unsigned long _remul (unsigned long x1, unsigned long x2)

{

    register int i;

    register unsigned long num;

    register unsigned long den;

    register int shift;

    unsigned long num32;

 

    shift = _llnorm(x2) - _llnorm(x1);

 

    if (x1 < x2) return x1;

    if (x1 == 0) return 0;

    if (x2 == 0) return 0;

 

    num = x1;

    den = x2 << shift;

 

    num32 = (_llnorm(x1) == -1);

 

    if (num32)

    {

        if(den > num) { den >>= 1; num -= den; }

        else          { num -= den; den >>= 1; }

    }

    else

        shift++;

 

    for (i = 0; i < shift; i++)

	num = _subcul(num, den);

 

    return num >> shift;

}

renormd.c/      1148595157  0     0     0       535       `
/****************************************************************************/

/*  renormd.c        v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:39 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"




renormd.h/      1148595157  0     0     0       2409      `
/****************************************************************************/

/*  renormd.h        v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:23 CDT 2000 */

 

#ifndef __RENORMF__

#define __RENORMF__



#include "realdi.h"



#if (BPREAL == BPbigint)

   /* #define COUNT_LZERO(nnn) DEFAULT_IS_UNDEFINED                          */

   /* If defined, must be macro that returns the count of the number of      */

   /* consecutive zero bits at the most significant end of nnn.              */

   /* If COUNT_LZERO is not defined, alternate implementations will be used. */





   /* int RENORMF(bigint ff, int ee)                                         */

   /* ff (0<ff<REAL_HIDDEN_BIT) is left shifted until ff >= REAL_HIDDEN_BIT. */

   /* At least one shift is required.                                        */

   /* ee is decremented by the number of shifts.                             */

   #ifdef Support_DENORM

      #ifdef COUNT_LZERO

         #define RENORMF(ff,ee) do {int tmp = \

                                   COUNT_LZERO(ff)-BPbigint+\

                                   (REAL_FRC_MSBs)+1;\

                                ff <<= tmp; ee -= tmp-1;} while(0)

      #else

         #define RENORMF(ff,ee) while ((ff <<= 1) < REAL_HIDDEN_BIT) ee -= 1

      #endif

   #endif



   /* int RENORM2F(bigint ff, int ee)                                        */

   /* ff (0<ff<REAL_HIDDEN_BIT*2) is left shifted until ff>=REAL_HIDDEN_BIT*2*/

   /* At least one shift is required.                                        */

   /* ee is decremented by the number of shifts.                             */

   #ifdef COUNT_LZERO

      #define RENORM2F(ff,ee) do {int tmp=\

                                COUNT_LZERO(ff)-BPbigint+\

                                (REAL_FRC_BITS%BPbigint)+2;\

                               ff <<= tmp; ee -= tmp;} while (0)

   #else

      #define RENORM2F(ff,ee) do ee -= 1; while ((ff <<= 1) < REAL_HIDDEN_BIT*2)

   #endif

#elif (BPREAL == (BPbigint*2))

   extern int RENORMF(REAL_2UNS *ff);

#else

   #error "RENORMF not yet implemented for this size REAL"

#endif



#endif /* __RENORMF__ */


rewind.c/       1148595157  0     0     0       1080      `
/*****************************************************************************/

/*  REWIND.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    REWIND   -  Position a stream's file pointer to the beginning of a     */

/*                file                                                       */

/*****************************************************************************/

#include <stdio.h>





/*****************************************************************************/

/* REWIND   -  Position a stream's file pointer to the beginning of a file   */

/*****************************************************************************/

_CODE_ACCESS void  rewind(register FILE *_fp) { fseek(_fp, 0L, SEEK_SET); }





round.c/        1148595157  0     0     0       1127      `
/****************************************************************************/

/*  round.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:52 CDT 2000 */

 

#include "reald.h"



  REAL ROUNDF(REAL x)

{



   /* unbiased rounding */

   REAL fp, ip;

   CPYF(fp, MODFF(x,&ip));

   if LSZF(fp) {

      if GTRF(fp, CNST(-0.5)) return ip;

      if EQLF(fp, CNST(-0.5)) { /* round towards even if exactly midway */

         REAL ip2;

         if EQLF(MODFF(LDEXPF(ip,-1),&ip2), CNST(-0.5)) return SUBF(ip,ONE);

         return ip;

      }

      return SUBF(ip,ONE);

   } else {

      if LSSF(fp, CNST( 0.5)) return ip;

      if EQLF(fp, CNST( 0.5)) { /* round towards even if exactly midway */

         REAL ip2;

         if EQLF(MODFF(LDEXPF(ip,-1),&ip2), CNST( 0.5)) return ADDF(ip,ONE);

         return ip;

      }

      return ADDF(ip,ONE);

   }



} /* ROUNDF */


rsqrt.c/        1148595157  0     0     0       3040      `
/****************************************************************************/

/*  rsqrt.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:53 CDT 2000 */

 

#include "reald.h"



  REAL RSQRTF(REAL x)

{

    

    EXPONENT_TYPE e;

    REAL    f, y;

    int           i;



    if LEZF(x) 

    {

       errno = EDOM;



       /* Assume that an argument of <= 0.0 got that way because of finite   */

       /* precision during preceeding calculations and that the ideal        */

       /* value is actually a number approaching 0.0 from the positive side. */

       return CNST( 3.402823466E+38) ;

    }



    RIPF(x, f, e);



    /* First form an estimate of the inverse-square-root.                */

    /* The accuracy of the estimate determines the number of required    */

    /* Newton iterations to compute the required n-bit mantissa result.  */

    /* Given a number expressed as x = f* 2**e, an estimate of 1/SQRT(x),*/

    /* may be computed as:                                               */

    /*   1/SQRT(x)                                                       */

    /* = 1/SQRT(f * 2**e)                                                */

    /* = 1/SQRT(f)      * 1/SQRT(2**e)                                   */

    /*~= (C1*f + C2)    * 1/SQRT(2**(e & 1)) * 1/SQRT(2**(e-(e & 1)))    */

    /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2))     */

    /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */

    /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */

    /* = 2*(C1*f + C2)  * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */

    /* =(2*C1*f + 2*C2) * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */

    /* =(2*C1*f + 2*C2) * {1 or 1/SQRT(2)}   * (2**-((e-(e & 1))/2)-1)   */



    /* .5 <= f < 1, we need 1 <= f < 2, so... */

    /* e = e - 1  ; -- moved below.  Maybe CPU has LSB test as byproduct. */

    /* f = f * 2.0; -- subsumed into calculation below */



    ADDF3(f, MPYF(CNST(-1.145508) ,f), CNST( 2.528320) );

    e -= 1;

    if (e & 1)

    {

       e -= 1;

       MPYF2(f, One_Over_Sqrt_2);

    }



    SCLF3(y, f, ~(e >> 1));  /* note: last use of "e" */



    /* Estimate of 1/sqrt in y now good to about 5 mantissa bits. */

    /* Refine estimate with Newton iterations.                    */

    /* Accuracy roughly doubles each time through the loop.       */

    /* Haven't determined actual accuracy vs. iterations yet.     */

    /* Thresholds on loop choices are thus overly conservative.   */

    /* Note: Cannot square y below for reasons of over/under-flow.*/

    for (i = 1; i <= (2 +1); i++)

       /* y = y+y*(0.5-((x*y)*0.5)*y); */

       ADDF2(y,MPYF(y,SUBF(HALF,MPYF(MPYF(MPYF(x,y),HALF),y))));



    return y;

} /* RSQRTF */

rtti.cpp/       1148595157  0     0     0       34449     `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Run-time type identification.



*/



#include "basics.h"

#include "runtime.h"

#pragma hdrstop

#include "rtti.h"



#if ABI_CHANGES_FOR_RTTI

#include <typeinfo>

#include "vtbl.h"

#endif /* ABI_CHANGES_FOR_RTTI */

#include "stdint.h"

/* Forward declaration. */

EXTERN_C void __db_type_info(const STD_NAMESPACE::type_info& info);



#ifdef __EDG_IA64_ABI



/*

Macro to extract the offset value from the combined offset/flags field.

*/

#define get_offset(bcsp) ((bcsp)->__offset_flags >>			\

                                  abi::__base_class_type_info::__offset_shift)



/*

Macros used to test for flags from the __vmi_class_tyupe_info.

*/

#define diamond_shaped(flags) \

  ((flags & abi::__vmi_class_type_info::__diamond_shaped_mask) != 0)

#define non_diamond_repeat(flags) \

  ((flags & abi::__vmi_class_type_info::__non_diamond_repeat_mask) != 0)





static a_boolean derived_to_base_conversion_r(

				void			*ptr,

				void			**p_new_ptr,

				a_type_info_impl_ptr	class_info,

				a_type_info_impl_ptr	base_info,

				unsigned int		vmi_flags,

				a_boolean		*p_is_ambiguous,

				a_boolean		is_accessible,

				a_boolean		*result_is_accessible)

/* 

Perform a derived to base conversion from ptr (the derived object, whose type

is given by class_info) to the base indicated by base_info.  If the base is

unambiguous, the address of the base is stored in *p_new_ptr, and TRUE is

returned.  On entry *p_new_ptr should be NULL, or the address of the base if

it has already been found.  is_accessible is TRUE if the current class is

accessible.  result_is_accessible is set to indicate whether the base class

that is found (if any) is accessible from the ultimately derived object.

If the base is ambiguous,  *p_is_ambiguous i set to TRUE, and FALSE is

returned.  If the base is unambiguous, but inaccessible, TRUE is returned but

result_is_accessible is set to FALSE.  vmi_flags is a bit set of flags that

are used to optimize the base class search.  These flags are passed by

the initial caller of this routine and are passed down when the routine

is called recursively.

*/

{

  a_boolean result = FALSE;



#if DEBUG

  if (__debug_level >= 4) {

    fprintf(__f_debug, "derived_to_base_conversion_r:\n");

    fprintf(__f_debug, "  conversion from:\n");

    __db_type_info(*class_info);

    fprintf(__f_debug, "  conversion to:\n");

    __db_type_info(*base_info);

  }  /* if */

#endif /* DEBUG */

  if (typeid(*class_info) == typeid(abi::__si_class_type_info)) {

    /* Single, non-virtual, public inheritance. */

    abi::__si_class_type_info *si_obj_info = 

                                       (abi::__si_class_type_info *)class_info;

    if (matching_type_info(si_obj_info->__base_type, base_info)) {

      if ((*p_new_ptr != NULL && *p_new_ptr != ptr) ||

          *p_is_ambiguous) {

        /* The base class is ambiguous. */

        *p_is_ambiguous = TRUE;

        *p_new_ptr = NULL;

        result = FALSE;

      } else {

        *result_is_accessible = is_accessible;

        *p_new_ptr = ptr;

        result = TRUE;

      }  /* if */

    } else if (derived_to_base_conversion_r(ptr, p_new_ptr,

                                            si_obj_info->__base_type,

                                            base_info, vmi_flags,

                                            p_is_ambiguous, is_accessible,

					    result_is_accessible) ||

               *p_is_ambiguous) {

      if ((*p_is_ambiguous)) {

        result = FALSE;

      } else {

        result = TRUE;

      }  /* if */

    }  /* if */

  } else if (typeid(*class_info) == typeid(abi::__vmi_class_type_info)) {

    /* Complex inheritance. */

    abi::__vmi_class_type_info *vmi_obj_info = 

                                      (abi::__vmi_class_type_info *)class_info;

    a_base_class_spec_ptr      bcsp;

    void                       *base_ptr;

    /* Loop over all of the base classes. */

    for (bcsp = vmi_obj_info->__base_info;

         bcsp < vmi_obj_info->__base_info + vmi_obj_info->__base_count;

         bcsp++) {

      a_boolean base_is_accessible;

      a_boolean	is_virtual = (bcsp->__offset_flags & BCS_VIRTUAL) != 0;

      if (ptr == NULL) {

        /* Don't try to add an offset to a NULL pointer. */

        base_ptr = NULL;

      } else if (is_virtual) {

        a_vtbl_entry_ptr vtbl, vbase_offset;

        vtbl = *((a_vtbl_entry_ptr *)ptr);

        vbase_offset = (a_vtbl_entry_ptr)(((char *)vtbl) + get_offset(bcsp));

        base_ptr = (void *)(((char *)ptr) + *vbase_offset);

      } else {

        base_ptr = (void *)(((char *)ptr) + get_offset(bcsp));

      }  /* if */

      base_is_accessible = is_accessible &&

                           (bcsp->__offset_flags & BCS_PUBLIC);

      if (matching_type_info(bcsp->__base_type, base_info)) {

        /* We found the base for which we were looking. */

        if ((*p_new_ptr != NULL && base_ptr != *p_new_ptr) || 

            *p_is_ambiguous) {

          /* The base class is ambiguous. */

          *p_is_ambiguous = TRUE;

          *p_new_ptr = NULL;

          result = FALSE;

          break;

        } else {

          /* The base class is unambiguous -- at least so far. */

          *result_is_accessible = base_is_accessible;

          *p_new_ptr = base_ptr;

          result = TRUE;

          /* We can stop searching if the vmi_flags indicate that this

             base class is known to be unique. */

          if (*result_is_accessible) {

            if (is_virtual ? !diamond_shaped(vmi_flags)

                           : !non_diamond_repeat(vmi_flags)) {

              break;

            }  /* if */

          }  /* if */

        }  /* if */

      } else if (derived_to_base_conversion_r(base_ptr, p_new_ptr,

                                              bcsp->__base_type,

                                              base_info, vmi_flags,

                                              p_is_ambiguous,

                                              base_is_accessible,

                                              result_is_accessible) ||

                 *p_is_ambiguous) {

        if ((*p_is_ambiguous)) {

          result = FALSE;

          break;

        } else {

          result = TRUE;

          /* We can stop searching if the vmi_flags indicate that this

             base class is known to be unique. */

          if (*result_is_accessible) {

            if (is_virtual ? !diamond_shaped(vmi_flags)

                           : !non_diamond_repeat(vmi_flags)) {

              break;

            }  /* if */

          }  /* if */

        } /* if */

      } /* if */

    }  /* for */

  }  /* if */

  return result;

}  /* derived_to_base_conversion_r */



#endif /* ifdef __EDG_IA64_ABI */



#ifdef __EDG_IA64_ABI

/*ARGSUSED*/ /* <-- access_flags and use_access_flags are unused in that

                    case. */

#endif /* ifdef __EDG_IA64_ABI */

EXTERN_C

a_boolean __derived_to_base_conversion(void**		     p_ptr,

		  		       void**                p_new_ptr,

				       a_type_info_impl_ptr  class_info,

				       a_type_info_impl_ptr  base_info,

				       an_access_flag_string *access_flags,

				       a_boolean             use_access_flags)

/*

Converts p_ptr from a pointer to a derived class (described by class_info)

to a pointer to a base class (described by base_info) and stores

the resulting pointer in p_new_ptr.  Returns TRUE if the base class was

found and the conversion was done; otherwise returns FALSE. 



p_ptr may be NULL when this routine is called simply to determine whether

the conversion is possible.  This is the case when exception specifications

are being tested.



The access_flags string contains one byte for each base class.  The

byte contains either "Y" (the base class is accessible) or "N" (the

base class is not accessible).  The base class may be inaccessible

either because of access protection or because the base class

is ambiguous.



use_access_flags indicates whether the access_flags string should be used

when checking for accessible (and unambiguous) bases.  If use_access_flags

is FALSE, the BCS_PUBLIC and BCS_AMBIGUOUS flags in the base class entry

are used.  These flags were added when RTTI was implemented in version 2.29.

The access_flags string was retained for backward compatibility.

*/

{

  a_boolean		result = FALSE;

  void                  *ptr;

  a_boolean		is_ambiguous = FALSE;

#ifdef __EDG_IA64_ABI

  a_boolean             result_is_accessible = TRUE;

#else /* !defined(__EDG_IA64_ABI) */

  a_base_class_spec_ptr	bcsp;

#endif /* !defined(__EDG_IA64_ABI) */

  /* Get the actual derived class pointer.  If no pointer was provided,

     use NULL. */

  ptr = p_ptr == NULL ? NULL : *p_ptr;

  *p_new_ptr = NULL;

#ifndef __EDG_IA64_ABI

  bcsp = class_info->base_class_entries;

  if (bcsp != NULL) {

    /* A base class list is present. */

    a_boolean	done = FALSE;

    /* Loop through the direct base classes and look for one that matches

       the specified base class.  We look through all of the direct bases

       first because the direct base list also includes any virtual bases.

       We want to make sure that we find the virtual base classes at

       the top level when possible. */

    do {

      void*		   new_ptr = NULL;

      a_type_info_impl_ptr test_info = bcsp->type_info;

      a_boolean            is_accessible;

      if (ptr != NULL) {

        /* Adjust the pointer by the offset provided in the base class

           specification. */

        new_ptr = (void*) (((char *) ptr) + bcsp->offset);

      }  /* if */

      if (use_access_flags) {

        /* See if this base class is accessible.  *access_flags either points

           to a string of characters associated with each base class in the

  	   tree, or is NULL if none of the base classes are accessible. */

        if (*access_flags != NULL) {

          is_accessible = **access_flags == BASE_ACCESSIBLE;

          (*access_flags)++;

        } else {

          is_accessible = FALSE;

        }  /* if */

      } else {

        /* The base is accessible if it is public and not ambiguous. */

        is_accessible = ((bcsp->flags & BCS_PUBLIC) != 0);

      }  /* if */

      if (matching_type_info(test_info, base_info)) {

        /* If the base class is ambiguous, stop the search but don't

           consider the conversion "successful".  The BCS_AMBIGUOUS flag is

           only used with ABI versions >= 2.29.  In previous versions of

           the ABI, ambiguous bases were indicated by marking all

           instances of the base as inaccessible in the access

           string. */

        is_ambiguous = ((bcsp->flags & BCS_AMBIGUOUS) != 0);

        if (!is_ambiguous && is_accessible) {

          result = TRUE;

          if (ptr != NULL) {

            if (bcsp->flags & BCS_VIRTUAL) {

              /* If this is a virtual base class then the offset provides the

                 location of a pointer to the base class.  Dereference the

                 pointer and return that value. */

              *p_new_ptr = *((void **)new_ptr);

            } else {

              /* A nonvirtual base class.  new_ptr has already been

                 adjusted to point to the start of the base class.

                 Return this value to the caller. */

              *p_new_ptr = new_ptr;

            }  /* if */

          }  /* if */

        }  /* if */

      }  /* if */

      /* The last entry in the array will have the BCS_LAST flag set. */

      done = bcsp->flags & BCS_LAST || result || is_ambiguous;

      /* Advance the pointer to the next element in the array of base

         class specifications. */

      bcsp++;

    } while (!done);

    if (!result && !is_ambiguous) {

      /* The specified base class is not one of the direct or virtual bases.

         Search the indirect base classes. */

      bcsp = class_info->base_class_entries;

      do {

        void*		     new_ptr = NULL;

        a_type_info_impl_ptr test_info = bcsp->type_info;

	a_boolean            is_accessible;

	if (ptr != NULL) {

	  /* Adjust the pointer by the offset provided in the base class

	     specification. */

	  new_ptr = (void*) (((char *) ptr) + bcsp->offset);

          if (bcsp->flags & BCS_VIRTUAL) {

            /* If this is a virtual base class then the offset provides the

               location of a pointer to the base class.  Dereference the

               pointer and use that value. */

            new_ptr = *((void **)new_ptr);

          }  /* if */

	}  /* if */

        /* This is not the base class we are looking for.  Look at the

           base classes of this base class. */

        if (use_access_flags) {

          /* When using access strings, a base class further up in the

             derivation tree may be accessible even if this class is not.

             Always call the derived_to_base_conversion routine and let

             it check the access flag.  This is done by setting the

	     is_accessible flag to TRUE at this level. */

          is_accessible = TRUE;

        } else {

          /* When using the newer access flags in the base class entry

             (instead of the access flag string) don't look into 

             inaccessible or ambiguous bases. */

          is_accessible = ((bcsp->flags & BCS_PUBLIC) != 0) &&

                          ((bcsp->flags & BCS_AMBIGUOUS) == 0);

        }  /* if */

        if (test_info->base_class_entries != NULL && is_accessible) {

          /* This base class has its own bases.  Call this routine

             recursively. */

	  void* local_new_ptr;

          if (__derived_to_base_conversion(&new_ptr, &local_new_ptr, test_info,

					   base_info, access_flags,

                                           use_access_flags)) {

	    if (ptr != NULL) {

	      /* We have found a match.  Update the pointer passed to us

		 to reflect the value found by the recursive call. */

	      *p_new_ptr = local_new_ptr;

	    }  /* if */

            result = TRUE;

            break;

          }  /* if */

        }  /* if */

        /* The last entry in the array will have the BCS_LAST flag set. */

        done = (bcsp->flags & BCS_LAST) != 0;

        /* Advance the pointer to the next element in the array of base

           class specifications. */

        bcsp++;

      } while (!done);

    }  /* if */

  }  /* if */

#else /* defined(__EDG_IA64_ABI) */

  {

    int	vmi_flags;

    /* If the type information is represented by the VMI form of type_info,

       get the flags that are used to optimize the base class search.

       Otherwise, use the safe value of having both flags set. */

    if (typeid(*class_info) == typeid(abi::__vmi_class_type_info)) {

      abi::__vmi_class_type_info *vmi_obj_info = 

                                      (abi::__vmi_class_type_info *)class_info;

      vmi_flags = vmi_obj_info->__flags;

    } else {

      vmi_flags = abi::__vmi_class_type_info::__non_diamond_repeat_mask |

                  abi::__vmi_class_type_info::__diamond_shaped_mask;

    }  /* if */

    if (derived_to_base_conversion_r(ptr, p_new_ptr, class_info, base_info,

                                     vmi_flags, &is_ambiguous,

                                     /*is_accessible=*/TRUE,

                                     &result_is_accessible) &&

        result_is_accessible) {

      result = TRUE;

    }  /* if */

  }

#endif /* defined(__EDG_IA64_ABI) */

  return result;

}  /* __derived_to_base_conversion */





static a_base_class_spec_ptr find_base_class_at_addr(

					void			*obj_ptr,

					void			*base_ptr,

					a_type_info_impl_ptr	obj_info,

					a_type_info_impl_ptr	base_info,

                                        a_boolean               *found)

/*

Find the base class specification entry that corresponds to the base

class pointed to by "base_ptr", whose type is specified by "base_info"

in the object pointed to by "obj_ptr".  The base class must be accessible,

but need not be unambiguous.  *found should be initialized to FALSE before

this function is called; it is set to TRUE If the base class is found.

*/

{

  a_base_class_spec_ptr	bcsp;

  void                  *ptr;

  void                  *new_ptr;

  a_base_class_spec_ptr	result = NULL;

#ifndef __EDG_IA64_ABI

  a_boolean		done;

#endif /* ifndef __EDG_IA64_ABI */



  ptr = obj_ptr;

#ifdef __EDG_IA64_ABI

#if DEBUG

  if (__debug_level >= 4) {

    fprintf(__f_debug, "find_base_class_at_addr:\n");

    fprintf(__f_debug, "  looking in:\n");

    __db_type_info(*obj_info);

    fprintf(__f_debug, "  for base class:\n");

    __db_type_info(*base_info);

  }  /* if */

#endif /* DEBUG */

  if (typeid(*obj_info) == typeid(abi::__si_class_type_info)) {

    abi::__si_class_type_info *si_obj_info = 

                                      (abi::__si_class_type_info *)obj_info;

    if (ptr == base_ptr && 

        matching_type_info(si_obj_info->__base_type, base_info)) {

      /* The current class is the one we are looking for. */

      *found = TRUE;

    } else {

      /* The current class is not the one we are looking for.  Check its

         base class. */

      result = find_base_class_at_addr(ptr, base_ptr,

                                       si_obj_info->__base_type,

                                       base_info, found);

    }  /* if */

  } else if (typeid(*obj_info) == typeid(abi::__vmi_class_type_info)) {

    abi::__vmi_class_type_info *vmi_obj_info = 

                                     (abi::__vmi_class_type_info *)obj_info;

    for (bcsp = vmi_obj_info->__base_info;

         bcsp < vmi_obj_info->__base_info + vmi_obj_info->__base_count;

         bcsp++) {

      if (bcsp->__offset_flags & BCS_VIRTUAL) {

        a_vtbl_entry_ptr vtbl, vbase_offset;

        vtbl = *((a_vtbl_entry_ptr *)ptr);

        vbase_offset = (a_vtbl_entry_ptr)(((char *)vtbl) + get_offset(bcsp));

        new_ptr = (void *)(((char *)ptr) + *vbase_offset);

      } else {

        new_ptr = (void *)(((char *)ptr) + get_offset(bcsp));

      }  /* if */

      if (new_ptr == base_ptr &&

          matching_type_info(bcsp->__base_type, base_info)) {

        /* We found a match.  Note that both the address and type must match

           because base classes can share an address. */

        result = bcsp;

        if (bcsp->__offset_flags & BCS_PUBLIC) *found = TRUE;

        break;

      }  /* if */

      if ((bcsp->__offset_flags & BCS_PUBLIC) != 0) {

        /* No match, check the base classes of this base class. */

        result = find_base_class_at_addr(new_ptr, base_ptr,

                                         bcsp->__base_type, base_info,

                                         found);

        /* Exit if the recursive call found a match. */

        if (*found) break;

      }  /* if */

    }  /* for */

  }  /* for */

#else /* !defined(__EDG_IA64_ABI) */

  for (done = FALSE, bcsp = obj_info->base_class_entries;

       bcsp != NULL && !done; done = (bcsp->flags & BCS_LAST) != 0, bcsp++) {

    /* Adjust the pointer by the offset provided in the base class

       specification. */

    new_ptr = (void*) (((char *) ptr) + bcsp->offset);

    if (bcsp->flags & BCS_VIRTUAL) {

      /* If this is a virtual base class then the offset provides the

         location of a pointer to the base class.  Dereference the

         pointer and use that value. */

      new_ptr = *((void **)new_ptr);

    }  /* if */

    if (new_ptr == base_ptr &&

        matching_type_info(bcsp->type_info, base_info)) {

      /* We found a match.  Note that both the address and type must match

         because base classes can share an address. */

      result = bcsp;

      if (bcsp->flags & BCS_PUBLIC) *found = TRUE;

      break;

    }  /* if */

    if ((bcsp->flags & BCS_PUBLIC) != 0) {

      /* No match, check the base classes of this base class. */

      result = find_base_class_at_addr(new_ptr, base_ptr,

                                       bcsp->type_info, base_info,

                                       found);

      /* Exit if the recursive call found a match. */

      if (result != NULL) break;

    }  /* if */

  }  /* for */

#endif /* !defined(__EDG_IA64_ABI) */

  return result;

}  /* find_base_class_at_addr */



#if ABI_CHANGES_FOR_RTTI





#ifdef __EDG_IA64_ABI

#define DYNAMIC_CAST_ROUTINE_NAME ABI_NAMESPACE::__dynamic_cast

#else /* !defined(__EDG_IA64_ABI) */

#define DYNAMIC_CAST_ROUTINE_NAME __dynamic_cast

#endif /* !defined(__EDG_IA64_ABI) */ 



#ifdef __EDG_IA64_ABI

/*ARGSUSED*/ /* <-- hint is not used in that case. */

#endif /* __EDG_IA64_ABI */

EXTERN_C void *DYNAMIC_CAST_ROUTINE_NAME (void		*class_ptr,

#ifndef __EDG_IA64_ABI

			      a_vtbl_entry_ptr		vtbl_ptr,

		              a_type_info_impl_ptr	tiip

#if ABI_COMPATIBILITY_VERSION >= 241

			    , void			*source_ptr,

			      a_type_info_impl_ptr	source_tiip

#endif /* ABI_COMPATIBILITY_VERSION >= 241 */

#else /* defined(__EDG_IA64_ABI) */

                              a_type_info_impl_ptr      source_tiip,

                              a_type_info_impl_ptr      tiip,

                              __EDG_DELTA_TYPE          hint

#endif /* defined(__EDG_IA64_ABI) */

                              )

/*

Runtime support for dynamic_cast operations.  This routine handles



  - casts of a polymorphic objects type to void*, which is defined as

    returning a pointer to the complete object type



  - polymorphic base to derived casts



  - polymorphic cross casts



class_ptr is the source operand of the cast.  If the source is

an object (and not a pointer) then a pointer to the source operand

is used.  vtbl_ptr is a pointer to the virtual function table from

the source operand.  tiip is a pointer to the type_info_impl

structure associated with the destination type.  If the source

operand is being cast to void*, tiip will be NULL.



source_ptr is the original pointer being cast.  It is different from

class_ptr if the original type did not have a virtual function table

associated with it.  source_tiip is the type info pointer for the static

type of the pointer being cast.  These parameters are used to check the

access of the base class associated with the pointer being cast.



The information about the dynamic type of the source object is obtained

from entry zero of the virtual function table.



Entry zero of the virtual function table is organized differently than the

other table entries.  The information in that entry is provided to support

the dynamic_cast and typeinfo operations.  Entry zero contains the

following information:



	delta:		The offset from the complete object pointer to

			class_ptr (i.e., the value to be subtracted from

			class_ptr to get the complete object pointer.



	index:		Unused.



	function:	Pointer to the typeinfo_impl structure that

		        for the dynamic type of class_ptr.

*/

{

  void			*complete_object_ptr;

#ifndef __EDG_IA64_ABI

  size_t		offset_to_complete_object;

#else /* defined(__EDG_IA64_ABI) */

  void                  *source_ptr = class_ptr;

#endif /* defined(__EDG_IA64_ABI) */

  a_type_info_impl_ptr	object_tiip;

  void			*result = NULL;



  /* Get a pointer to the complete object. */

#ifndef __EDG_IA64_ABI

  offset_to_complete_object = vtbl_ptr->delta;

  complete_object_ptr =

                     (void*)(((char *)class_ptr) - offset_to_complete_object);

#else /* defined(__EDG_IA64_ABI) */

  complete_object_ptr = 

    (void *)(((char *)class_ptr) + (*((a_vtbl_entry_ptr *)class_ptr))[-2]);

#endif /* defined(__EDG_IA64_ABI) */

#if DEBUG

  if (__debug_level >= 3) {

    fprintf(__f_debug, "dynamic_cast: orig ptr=%p, complete obj=%p\n",

            class_ptr, complete_object_ptr);

  }  /* if */

#endif /* DEBUG */

  /* Get the pointer to the type_info associated with the source object.  */

#ifndef __EDG_IA64_ABI

  /* This is stored in the function pointer field of the vtbl entry. */

#if 1

  object_tiip = (a_type_info_impl_ptr) (intptr_t) vtbl_ptr->func;

#else

  object_tiip = (a_type_info_impl_ptr) vtbl_ptr->function.type_info_impl;

#endif

#else /* defined(__EDG_IA64_ABI) */

   /* In the IA-64 ABI, this is stored in the -1 entry of the vtable. */

  object_tiip = (a_type_info_impl_ptr)((*((a_vtbl_entry_ptr *)class_ptr))[-1]);

#endif /* defined(__EDG_IA64_ABI) */

  if (tiip == NULL) {

    /* When tiip is NULL, the pointer is being cast to void*.  This

       means that class_ptr is to be converted to a pointer to the

       complete object type. */

    result = complete_object_ptr;

  } else {

    a_boolean	access_okay = TRUE;

#if ABI_COMPATIBILITY_VERSION >= 241

    /* Before doing the conversion, find the base class pointed to by the

       source pointer.  Make sure this points to an accessible base class.

       find_base_class_at_addr will return NULL if the base class is an

       indirect base class of a private base class.  It will return a pointer

       to the base class entry if it is a base class of an accessible

       base class (or if it is a direct base class).  Check the returned base

       class entry to make sure the base class is public.  The conversions

       that follow are done only if the source class is a public base class. */

    if (object_tiip == source_tiip) {

      /* The static type of the source is the same as the dynamic type. */

      access_okay = TRUE;

    } else {

      access_okay = FALSE;

      (void)find_base_class_at_addr(complete_object_ptr, source_ptr,

                                    object_tiip, source_tiip, &access_okay);

    }  /* if */

#endif /* ABI_COMPATIBILITY_VERSION >= 241 */

    if (access_okay) {

      if (matching_type_info(object_tiip, tiip)) {

        /* The object is being cast to the type it actually is.  For example,

           a Base* that actually points to a Derived is being cast to a

           Derived*.  Simply return the complete object pointer. */

        result = complete_object_ptr;

      } else {

        /* The object is being cast to one of its base classes. */

        a_boolean	conversion_done;

        void		*new_ptr = NULL;

        conversion_done = __derived_to_base_conversion(

                               &complete_object_ptr, &new_ptr,

			       object_tiip, tiip,

			       (an_access_flag_string*)NULL,

			       /*use_access_flags=*/FALSE);

        if (conversion_done) result = new_ptr;

      }  /* if */

    }  /* if */

  }  /* if */

  return result;

}  /* __dynamic_cast */



#ifdef __EDG_IA64_ABI

#define BAD_CAST_ROUTINE_NAME ABI_NAMESPACE::__cxa_bad_cast

#define BAD_CAST_ROUTINE_LINKAGE /*extern*/

#else /* !defined(__EDG_IA64_ABI) */

#define BAD_CAST_ROUTINE_NAME __throw_bad_cast

#define BAD_CAST_ROUTINE_LINKAGE static

#endif /* !defined(__EDG_IA64_ABI) */ 



BAD_CAST_ROUTINE_LINKAGE

void BAD_CAST_ROUTINE_NAME(void)

/*

Throw a bad cast exception.  If exception handling is not supported in

this version of the runtime, then simply abort.

*/

{

#if EXCEPTION_HANDLING

  throw STD_NAMESPACE::bad_cast();

#else /* !EXCEPTION_HANDLING */

  __abort_execution(ec_bad_cast);

#endif /* EXCEPTION_HANDLING */

}  /* BAD_CAST_ROUTINE_NAME */





#ifdef __EDG_IA64_ABI

#define BAD_TYPEID_ROUTINE_NAME ABI_NAMESPACE::__cxa_bad_typeid

#else /* !defined(__EDG_IA64_ABI) */

#define BAD_TYPEID_ROUTINE_NAME __throw_bad_typeid

#endif /* !defined(__EDG_IA64_ABI) */



EXTERN_C void BAD_TYPEID_ROUTINE_NAME(void)

/*

Throw a bad typeid exception.  If exception handling is not supported in

this version of the runtime, then simply abort.

*/

{

#if EXCEPTION_HANDLING

  throw STD_NAMESPACE::bad_typeid();

#else /* !EXCEPTION_HANDLING */

  __abort_execution(ec_bad_typeid);

#endif /* EXCEPTION_HANDLING */

}  /* BAD_TYPEID_ROUTINE_NAME */



#ifndef __EDG_IA64_ABI



EXTERN_C void *__dynamic_cast_ref(void                  *class_ptr,

			          a_vtbl_entry_ptr      vtbl_ptr,

			          a_type_info_impl_ptr  tiip

#if ABI_COMPATIBILITY_VERSION >= 241

			        , void			*source_ptr,

			          a_type_info_impl_ptr	source_tiip

#endif /* ABI_COMPATIBILITY_VERSION >= 241 */

                                  )

/*

Interface to __dynamic_cast used when casting references.  This calls

__dynamic_cast and throws an exception if the cast failed.

*/

{

  void*		result;



  result = __dynamic_cast(class_ptr, vtbl_ptr, tiip

#if ABI_COMPATIBILITY_VERSION >= 241

                          , source_ptr, source_tiip

#endif /* ABI_COMPATIBILITY_VERSION >= 241 */

                         );

  if (result == NULL) {

    __throw_bad_cast();

  }  /* if */

  return result;

}  /* __dynamic_cast_ref */





EXTERN_C void *__get_typeid(a_vtbl_entry_ptr	vtbl_ptr)

/*

Return the user type_info pointer from the specified virtual function

table.  If the pointer to the vtable is NULL, throw a bad_typeid

exception.

*/

{

  a_type_info_impl_ptr	tiip;



  if (vtbl_ptr == NULL) __throw_bad_typeid();

  /* Get the pointer to the type_info_impl associated with the source object. 

     This is stored in the function pointer field of the vtbl entry. */

#if 1

  tiip = (a_type_info_impl_ptr)(intptr_t)vtbl_ptr->func;

#else

  tiip = (a_type_info_impl_ptr)vtbl_ptr->function.type_info_impl;

#endif

  /* Return the address of the user type_info. */

  return (void*)&tiip->user_type_info;

}  /* __get_typeid */





#if DEBUG

EXTERN_C void __r_db_type_info(const STD_NAMESPACE::type_info&	info,

                               int				indent)

/*

Display debugging information about type information (non-IA-64 version).

*/

{

/* Define a macro used to indent the output lines. */

#define do_indent() fprintf(__f_debug, "%*s", indent, " ")

  /* Convert the user type_info pointer to a_info_impl_ptr. */

  a_type_info_impl_ptr	tiip = (a_type_info_impl_ptr)&info;

  if (indent != 0) fprintf(__f_debug, "\n");

  do_indent();

  fprintf(__f_debug, "Type information for: %s\n",

          tiip->name == NULL ? "<NULL>" : tiip->name);

  do_indent();

  fprintf(__f_debug, "  unique_id: %p\n", (void*)tiip->unique_id);

#if ABI_COMPATIBILITY_VERSION <= 237

  do_indent();

  fprintf(__f_debug, "  dtor addr: %p\n", (void*)tiip->destructor);

#endif /* ABI_COMPATIBILITY_VERSION <= 237 */

  if (tiip->base_class_entries != NULL) {

    a_base_class_spec_ptr	bcsp;

    do_indent();

    fprintf(__f_debug, "  base classes:\n");

    for (bcsp = tiip->base_class_entries;; bcsp++) {

      const char	*name = bcsp->type_info->name;

      do_indent();

      fprintf(__f_debug, "    name=%s\n", name == NULL ? "<NULL>" : name);

      do_indent();

      fprintf(__f_debug, "    offset=%0ld\n", (long)bcsp->offset);

      do_indent();

      fprintf(__f_debug, "    flags:");

      if (bcsp->flags & BCS_VIRTUAL) fprintf(__f_debug, " virtual");

      if (bcsp->flags & BCS_LAST) fprintf(__f_debug, " last");

      if (bcsp->flags & BCS_PUBLIC) fprintf(__f_debug, " public");

      if (bcsp->flags & BCS_AMBIGUOUS) fprintf(__f_debug, " ambiguous");

      if (bcsp->flags & BCS_DIRECT) fprintf(__f_debug, " direct");

      fprintf(__f_debug, "\n");

      if (bcsp->flags & BCS_LAST) break;

    }  /* for */

    /* Now display the full type information for the base classes. */

    for (bcsp = tiip->base_class_entries;; bcsp++) {

      __r_db_type_info(bcsp->type_info->user_type_info, indent + 2);

      if (bcsp->flags & BCS_LAST) break;

    }  /* for */

  }  /* if */

#undef do_indent

}  /* __r_db_type_info */





EXTERN_C void __db_type_info(const STD_NAMESPACE::type_info& info)

/*

Display debugging information about type information.  This routine

calls __r_db_type_info and supplies a zero indent value.

*/

{

  __r_db_type_info(info, 0);

  fprintf(__f_debug, "\n");

}  /* __db_type_info */

#endif /* DEBUG */



#else /* ifdef IA64_ABI */



#if DEBUG

EXTERN_C void __r_db_type_info(const STD_NAMESPACE::type_info&	info,

                               int				indent)

/*

Display debugging information about type information (IA-64 version).

*/

{

/* Define a macro used to indent the output lines. */

#define do_indent() fprintf(__f_debug, "%*s", indent, " ")

  if (indent != 0) fprintf(__f_debug, "\n");

  do_indent();

  fprintf(__f_debug, "Type information for: %s\n", info.name());

#undef do_indent

}  /* __r_db_type_info */





EXTERN_C void __db_type_info(const STD_NAMESPACE::type_info& info)

/*

Display debugging information about type information.  This routine

calls __r_db_type_info and supplies a zero indent value.

*/

{

  __r_db_type_info(info, 0);

  fprintf(__f_debug, "\n");

}  /* __db_type_info */

#endif /* DEBUG */



#endif /* ifndef IA64_ABI */



#endif /* ABI_CHANGES_FOR_RTTI */





/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/


rtti.h/         1148595157  0     0     0       8177      `
/*****************************************************************************/

/* rtti.h v3.3.2                                                             */

/* Copyright (c) 1996-2006 Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Declarations for run-time type identification used by RTTI and

exception handling.



*/



#ifndef _RTTI_H

#define _RTTI_H



#include <typeinfo>



#ifndef NULL

#define NULL (0)

#endif /* NULL */



typedef void (*a_function_ptr)();

			/* A pointer type that can be used to store a

                           pointer to a destructor or an operator delete

			   function. */



typedef a_byte a_unique_id;

			/* The thing pointed to by the unique ID in a

			   type_info record. */



typedef a_unique_id *a_unique_id_ptr;

			/* A pointer to a unique ID. */



typedef __EDG_DELTA_TYPE an_object_offset;

			/* Type used to store an offset into an object. */



/* Definitions of the values in the flags field of the base class

   specification entry. */

#ifndef __EDG_IA64_ABI

typedef a_byte a_base_class_spec_flag_set;

#else /* defined(__EDG_IA64_ABI) */

typedef unsigned int a_base_class_spec_flag_set;

#endif /* defined(__EDG_IA64_ABI) */



#define BCS_NO_FLAGS	0x00

			/* Value when no flags are set. */

#define BCS_VIRTUAL	0x01

			/* The offset provides the position of a pointer

			   to the base class.  Used for virtual base

			   classes. */

#ifndef __EDG_IA64_ABI

#define BCS_LAST	0x02

			/* TRUE if this is the last base class specifier

			   in the array. */

#endif /* ifndef __EDG_IA64_ABI */



#ifndef __EDG_IA64_ABI

#define BCS_PUBLIC      0x04

#else /* !defined(__EDG_IA64_ABI) */

#define BCS_PUBLIC      0x02

#endif /* !defined(__EDG_IA64_ABI) */

			/* TRUE if the base class is public.  For non-direct

			   base classes, TRUE if the cumulative access across

			   the all derivation steps gives public access. */



#ifndef __EDG_IA64_ABI

#define BCS_AMBIGUOUS	0x08

			/* TRUE if this base class is ambiguous. */



#define BCS_DIRECT	0x10

			/* TRUE if this is a direct base class.  Ambiguous

			   base classes are always put out at the top level.

			   This flag can be used to determine which ones

			   are really top level bases. */

#endif /* ifndef __EDG_IA64_ABI */



#ifndef __EDG_IA64_ABI



/* Forward declaration of a type_info pointer. */

typedef 

/*** START TI ADD ***/

const 

/*** END TI ADD ***/

struct a_type_info_impl *a_type_info_impl_ptr;



#else /* defined(__EDG_IA64_ABI) */



/* Declare a_type_info_impl_ptr -- even though there is no separate

   implementation type -- to make it possible to use the same code in various

   places in the library. */

typedef const

/*** START TI REPLACE ***/

#if __EDG_RUNTIME_USES_NAMESPACES

              __cxxabiv1::

#endif /* __EDG_RUNTIME_USES_NAMESPACES */

                   __class_type_info *a_type_info_impl_ptr;

/*** END TI REPLACE ***/ 

#endif /* defined(__EDG_IA64_ABI) */



#ifndef __EDG_IA64_ABI



/* Describes the base classes of a class.  Pointed to by the type_info

   of the class. */

typedef 

/*** START TI ADD ***/

const 

/*** END TI ADD ***/ 

struct a_base_class_spec *a_base_class_spec_ptr;



typedef struct a_base_class_spec {

  a_type_info_impl_ptr		 

                type_info;

			/* The type_info for the base class. */

  an_object_offset

		offset;

			/* The offset of the base class in the derived

			   class. */

  a_base_class_spec_flag_set

		flags;

			/* A collection of bits that specify how the

			   base class specification entry is to be used.

			   See the descriptions of the BCS flags above. */

} a_base_class_spec;



/* Type description information for objects that are thrown or

   caught. */

typedef struct a_type_info_impl {

#if ABI_CHANGES_FOR_RTTI

  STD_NAMESPACE::type_info

		user_type_info;

			/* This is the user visible type_info object,

			   a reference to which is returned by the

			   typeid runtime routine.  The runtime assumes

			   that this is the first field in a_type_info_impl. */

  const char

                *name;

                       /* Pointer to a null-terminated character string

			  containing the name of the type. */

#endif /* ABI_CHANGES_FOR_RTTI */

  a_unique_id_ptr

		unique_id;

			/* When this field is non-NULL two type_info

			   structures describe the same type if their

			   unique IDs are the same. */

/*** START TI ADD ***/

   unsigned int            flags;             /* Flags                     */

/*** END TI ADD ***/

#if ABI_COMPATIBILITY_VERSION <= 237

  a_destructor_ptr

		destructor;

			/* Pointer to the destructor for the object.  This is

			   only present in ABI versions up to and including

			   2.37. */

#endif /* ABI_COMPATIBILITY_VERSION <= 237 */

/*** START TI ADD ***/

  const struct 

/*** END TI ADD ***/

  a_base_class_spec

		*base_class_entries;

			/* Pointer to an array of type_info entries for

			   direct base classes of a class. */

} a_type_info_impl;







/* Determine whether two type_info entries refer to the same type.  They

   match if their pointers are the same or if the unique ID pointed to

   by the entries is the same (and nonzero). */

#define matching_type_info(type1, type2)				\

  ((type1) == (type2) || (((type1)->unique_id == (type2)->unique_id) &&  \

                          (type1)->unique_id != 0))



#else /* defined(__EDG_IA64_ABI) */



/* Determine whether two type_info entries refer to the same type.  They

   match if their name pointers are the same. */

#define matching_type_info(type1, type2)				\

  ((type1) == (type2) || ((type1)->name() == (type2)->name()))



typedef abi::__base_class_type_info *a_base_class_spec_ptr;



#endif /* defined(__EDG_IA64_ABI) */



typedef char*	an_access_flag_string;

			/* Type of the string used to specify the access

			   of base classes of the throw object. */



/*

Values used in an access string to specify whether a given base class

is accessible or not.

*/



#define BASE_ACCESSIBLE     'Y'

			/* Value in an access list if the class is

			   accessible. */

#define BASE_NOT_ACCESSIBLE 'N'

			/* Value in an access list if the class is

			   not accessible.  Could be caused by a base

                           being ambiguous. */



EXTERN_C

a_boolean __derived_to_base_conversion(void**		   p_ptr,

				       void**                p_new_ptr,

				       a_type_info_impl_ptr  class_info,

				       a_type_info_impl_ptr  base_info,

				       an_access_flag_string *access_flags,

				       a_boolean             use_access_flags);

#endif /* ifndef _RTTI_H */





/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/


runtime.h/      1148595157  0     0     0       9016      `
/*****************************************************************************/

/* runtime.h v3.3.2                                                          */

/* Copyright (c) 1996-2006 Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/



/*



Miscellaneous declarations for all runtime routines.



*/



#ifndef RUNTIME_H

#define RUNTIME_H 1



#include "config.h"

#include <stdlib.h>

#include <stdio.h>

#include <new>

#include "error.h"

#ifdef __EDG_IA64_ABI

#include "cxxabi.h"

#endif /* ifdef __EDG_IA64_ABI */



#ifdef __linux__

/* Linux improperly defined NULL as "(void*)0".  Undefine it if it has

   already been defined, and define it to the proper value. */

#ifdef NULL

#undef NULL

#endif /* ifdef NULL */

#define NULL 0

#endif /* ifdef __linux__ */



#ifndef DEBUG

/* Include debugging code. */

#define DEBUG 0

#endif /* ifndef DEBUG */

#if DEBUG

EXTERN int	__debug_level /* = 0 */;

			/* Debug level.  0 means no debug output, 1 - 5

                            means increasing amounts. */

#endif /* DEBUG */

#if DEBUG || CHECKING

#define __f_debug stderr

			/* Debug output file.  This is a macro and not a

			   variable because the initialization of a variable

			   with the value "stderr" cannot be done as a static

			   initialization on some systems. */

#endif /* DEBUG || CHECKING */



/*

Error routines.

*/

#if CHECKING

/* Macro to test an assertion and generate an internal error if

   the condition is not TRUE.  The macro expands to nothing when checking

   code is not being used. */

#define assert_msg() \

  {									\

    (void)fprintf(__f_debug, "Assertion failed in file \"%s\", line %d\n", \

                  __FILE__, __LINE__);				\

    abort();								\

  }



#define check_assertion(test)						\

  if (!(test)) {							\

    assert_msg()							\

  }

#define unexpected_condition()						\

  assert_msg()

#else /* !CHECKING */

#define check_assertion(test) /* Nothing */

#define unexpected_condition()    /* Nothing */

#endif /* CHECKING */



/*

Define the qualifier that should be used to access something defined

in the namespace of the runtime.  This is "std" if the runtime

uses namespaces or "" otherwise.

*/

#ifdef __EDG_RUNTIME_USES_NAMESPACES

#define STD_NAMESPACE std

#ifdef __EDG_IA64_ABI

#define ABI_NAMESPACE abi

#endif /* ifdef __EDG_IA64_ABI */

#else /* ifndef __EDG_RUNTIME_USES_NAMESPACES */

#define STD_NAMESPACE /* nothing */

#ifdef __EDG_IA64_ABI

#define ABI_NAMESPACE /* nothing */

#endif /* ifdef __EDG_IA64_ABI */

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



/*

a_size_of_t is used as a synonym for size_t by the runtime.

*/

#if 0

This should probably use some other kind of test.

#endif /* 0 */

#if __cplusplus

typedef size_t a_sizeof_t;

#else /* __cplusplus */

typedef unsigned int a_sizeof_t;

#endif /* __cplusplus */



/*

If bool is not supported, use a typedef for bool.

*/

#ifdef _BOOL

typedef bool __bool;

#else /* ifndef _BOOL */

typedef int __bool;

#endif /* ifdef _BOOL */



typedef void (*a_void_function_ptr)();

			/* Type used to store a generic function pointer. */



#ifndef __EDG_IA64_ABI

typedef void (*a_destructor_ptr)(void*, int);

#else /* defined(__EDG_IA64_ABI) */

/* Explicit "C" linkage is required for compatibility with the declaration in

   cxxabi.h. */

#ifdef __EDG_IA64_ABI_VARIANT_CTORS_AND_DTORS_RETURN_THIS

/* The variant form of destructor returns the this pointer. */

EXTERN_C typedef void* (*a_destructor_ptr)(void*);

#else /* ifndef __EDG_IA64_ABI_VARIANT_CTORS_AND_DTORS_RETURN_THIS */

EXTERN_C typedef void (*a_destructor_ptr)(void*);

#endif /* ifdef __EDG_IA64_ABI_VARIANT_CTORS_AND_DTORS_RETURN_THIS */

/* A special typedef is used for the destructor pointer passed to cxa_atexit

   as it must always have the expected type even when the variant form of

   destructor is being used. */

EXTERN_C typedef void  (*a_cxa_dtor_ptr)(void*);

#endif /* defined(__EDG_IA64_ABI) */

		/* Type used to store a pointer a destructor. */





typedef void (*a_destructor_with_vtable_param_ptr)(void*, void*);

			/* Type used for the kind of destructor that is used

			   to when information about the construction vtable

			   to be used must be provided. */



#ifdef __EDG_IA64_ABI

/* Explicit "C" linkage is required for compatibility with the declaration in

   cxxabi.h. */

EXTERN_C

#endif /* ifdef __EDG_IA64_ABI */

typedef void* (*a_new_ptr)(size_t);

			/* Type used to store a pointer to an operator new

			   routine. */



#ifdef __EDG_IA64_ABI

/* Explicit "C" linkage is required for compatibility with the declaration in

   cxxabi.h. */

EXTERN_C

#endif /* ifdef __EDG_IA64_ABI */

typedef void (*a_delete_ptr)(void*);

			/* Type used to store a pointer to an operator delete

			   routine. */



#ifdef __EDG_IA64_ABI

/* Explicit "C" linkage is required for compatibility with the declaration in

   cxxabi.h. */

EXTERN_C

#endif /* ifdef __EDG_IA64_ABI */

typedef void (*a_two_operand_delete_ptr)(void *, a_sizeof_t);

			/* Type used to store a pointer to a two operand

			   operator delete routine. */



#if CFRONT_COMPATIBILITY_MODE

typedef void (*a_cfront_constructor_ptr)(void*, void* b1, void* b2, void*b3,

                                         void* b4, void* b5, void* b6,

					 void* b7, void* b8);

			/* Type of a constructor called from vec_new in

			   cfront mode. */

#endif /* CFRONT_COMPATIBILITY_MODE */



/*

In the Cfront ABI, constructors return an object pointer.  In the

IA-64 ABI, they return void.

*/

#ifdef __EDG_IA64_ABI

#ifdef __EDG_IA64_ABI_VARIANT_CTORS_AND_DTORS_RETURN_THIS

typedef void *a_ctor_return_type;

#else /* ifndef __EDG_IA64_ABI_VARIANT_CTORS_AND_DTORS_RETURN_THIS */

typedef void a_ctor_return_type;

#endif /* ifdef __EDG_IA64_ABI_VARIANT_CTORS_AND_DTORS_RETURN_THIS */

#else /* ifndef __EDG_IA64_ABI */

typedef void *a_ctor_return_type;

#endif /* ifdef __EDG_IA64_ABI */



#ifdef __EDG_IA64_ABI

/* Explicit "C" linkage is required for compatibility with the declaration in

   cxxabi.h. */

EXTERN_C

#endif /* ifdef __EDG_IA64_ABI */

typedef a_ctor_return_type (*a_constructor_ptr)(void*);

			/* Type of a default constructor called from

			   vec_new. */

#ifdef __EDG_IA64_ABI

/* Explicit "C" linkage is required for compatibility with the declaration in

   cxxabi.h. */

EXTERN_C

#endif /* ifdef __EDG_IA64_ABI */

typedef a_ctor_return_type (*a_copy_constructor_ptr)(void*, void*);

			/* Type of a copy constructor called from

			   vec_cctor. */



extern void __default_new_handler(void);

			/* The default new handler routine. */



EXTERN_C STD_NAMESPACE::new_handler

		_new_handler

		  initial_value((a_void_function_ptr)NULL);

			/* Pointer to the new handler routine to be called. */



#ifdef __EDG_IA64_ABI

typedef void *a_dso_handle;

			/* Type of a DSO handle. */



/*

Guard variables are 64 bits in the IA-64 ABI but only 32 bits in the ARM EABI.

This definition must match the type selected in

lower_init.c:add_first_time_test.

*/

#ifdef __EDG_IA64_ABI_USE_INT_STATIC_INIT_GUARD

typedef int an_ia64_guard;

#else /* ifndef __EDG_IA64_ABI_USE_INT_STATIC_INIT_GUARD */

typedef unsigned long long an_ia64_guard;

#endif /* ifdef __EDG_IA64_ABI_USE_INT_STATIC_INIT_GUARD */

  

typedef an_ia64_guard *an_ia64_guard_ptr;

			/* A pointer to a guard variable. */





#endif /* defined(__EDG_IA64_ABI) */



#endif /* RUNTIME_H */







/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

set_new.cpp/    1148595158  0     0     0       2405      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



set_new_handler routine to allow the user to affect the behavior of the

default operator new() when memory cannot be allocated.



*/



#include "basics.h"

#include "runtime.h"

#pragma hdrstop



#ifndef NULL

#define NULL 0

#endif /* ifndef NULL */



/*

If the runtime should be defined in the std namespace, open

the std namespace.

*/

#ifdef __EDG_RUNTIME_USES_NAMESPACES

namespace std {

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



new_handler set_new_handler(new_handler handler) THROW_NOTHING()

/*

Set _new_handler to the new function pointer provided and return the

previous value of _new_handler.

*/

{

  new_handler rr = _new_handler;

  _new_handler = handler;

  return rr;

}  /* set_new_handler */



/*

If the runtime should be defined in the std namespace, close

the std namespace.

*/

#ifdef __EDG_RUNTIME_USES_NAMESPACES

}  /* namespace std */

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/


setbuf.c/       1148595158  0     0     0       1380      `
/*****************************************************************************/

/*  SETVBUF.C v3.3.2                                                         */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    SETBUF   -  Set the default buffering mode for a stream                */

/*****************************************************************************/

#include <stdio.h>

 



/*****************************************************************************/

/* SETBUF   -  Set the default buffering mode for a stream                   */

/*                                                                           */

/*    This function calls SETVBUF, and sets the buffering mode to non-       */

/*    buffered if _BUF is NULL, or fully-buffered if _BUF is not NULL.       */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS void setbuf(register FILE *_fp, char *_buf)

{

   setvbuf(_fp, _buf, _buf ? _IOFBF : _IONBF, BUFSIZ);

   return;

}

 



setjmp.asm/     1148595158  0     0     0       3287      `
;******************************************************************************

;* SETJMP  v3.3.2                                                             *

;* Copyright (c) 1996-2006  Texas Instruments Incorporated                    *

;******************************************************************************

 

	.include "c55xasm.i"

        .global  _setjmp, __setjmp, _longjmp



	.model   call=internal

	.cpl_on

 

;*---------------------------------------------------------------------------

;*   setjmp

;*

;*     C syntax  :   int setjmp(env)

;*                      jmp_buf *env;

;*

;*     Function  : Save caller's current environment for a subsequent

;*                 call to longjmp.  Return 0.

;*---------------------------------------------------------------------------

;*

;*  NOTE : ANSI specifies that "setjmp.h" declare "setjmp" as a macro.

;*         In our implementation, the setjmp macro calls a function "_setjmp".

;*         However, since the user may not include "setjmp.h", we provide

;*         two entry-points to this function.

;*

;*---------------------------------------------------------------------------

 

__setjmp:	.asmfunc

_setjmp:



	dbl(*AR0+) = LCRPC



	.if (.PHASE3 | __TMS320C55X_PLUS__)

		dbl(*AR0+) = XAR5

		dbl(*AR0+) = XAR6

		dbl(*AR0+) = XAR7



		AC1 = popboth()

		pshboth(AC1)

		dbl(*AR0+) = AC1



	    .if __TMS320C55X_PLUS__

	        dbl(*AR0+) = AC5

	        dbl(*AR0+) = AC6

	        dbl(*AR0+) = AC7

	        *AR0+ = AC5.G

	        *AR0+ = AC6.G

	        *AR0+ = AC7.G

	    .endif



	.else

		*AR0+ = AR5

		*AR0+ = AR6

		*AR0+ = AR7



		AR1 = *SP(#0)

		*AR0+ = AR1



		AR2 = SSP

		AR1 = *AR2

		*AR0+ = AR1

	.endif



	; don't have to save XSP, since it can't change.



	*AR0+ 	   = SP

	*AR0+ 	   = SSP



	*AR0+ 	   = DR2

	*AR0+ 	   = DR3



	T0         = #0



	return

	.endasmfunc



;*---------------------------------------------------------------------------

;*   longjmp

;*

;*     C syntax  :   int longjmp(env, returnvalue)

;*                      jmp_buf *env;

;*                      int     returnvalue;

;*

;*     Function  : Restore the context contained in the jump buffer.

;*                 This causes an apparent "2nd return" from the

;*                 setjmp invocation which built the "env" buffer.

;*                 This return appears to return "returnvalue".

;*                 NOTE: This function may not return 0.

;*---------------------------------------------------------------------------

_longjmp:	.asmfunc



	LCRPC = dbl(*AR0+)



	.if (.PHASE3 | __TMS320C55X_PLUS__)

		XAR5 = dbl(*AR0+)

		XAR6 = dbl(*AR0+)

		XAR7 = dbl(*AR0+)



		AC1  = dbl(*AR0+)



	    .if __TMS320C55X_PLUS__

	        AC5  = dbl(*AR0+)

	        AC6  = dbl(*AR0+)

	        AC7  = dbl(*AR0+)

	        AC5.G = *AR0+

	        AC6.G = *AR0+

	        AC7.G = *AR0+

	    .endif



	.else

		AR5 = *AR0+

		AR6 = *AR0+

		AR7 = *AR0+



		AR1 = *AR0+

		AR2 = *AR0+

	.endif



	SP    = *AR0+

	SSP   = *AR0+



	.if (.PHASE3 | __TMS320C55X_PLUS__)

		AC2 = popboth()

		pshboth(AC1)

	.else

		*SP(#0) = AR1

		AR3 = SSP

		*AR3 = AR2

	.endif



	DR2   = *AR0+

	DR3   = *AR0+



	if (T0 == #0) execute(D_Unit) || T0 = #1



	return

	.endasmfunc


setjmp.h/       1148595158  0     0     0       1447      `
/*****************************************************************************/

/* setjmp.h   v3.3.2                                                         */

/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _SETJMP

#define _SETJMP



#include <linkage.h>



#ifdef __cplusplus

extern "C" namespace std {

#endif



#define setjmp(x) _setjmp(x)



#if defined(__TMS320C55X_PLUS__)

    typedef long jmp_buf[12];

    #if defined(__EDG_JMP_BUF_NUM_ELEMENTS) && __EDG_JMP_BUF_NUM_ELEMENTS !=12

       #error "Front end and runtime disagree on size of jmp_buf"

    #endif

#else

    typedef long jmp_buf[7];

    #if defined(__EDG_JMP_BUF_NUM_ELEMENTS) && __EDG_JMP_BUF_NUM_ELEMENTS !=7

       #error "Front end and runtime disagree on size of jmp_buf"

    #endif

#endif /* defined(__TMS320C55X_PLUS__) */



_CODE_ACCESS int  _setjmp(jmp_buf env); 

_CODE_ACCESS void longjmp(jmp_buf env, int val);



#ifdef __cplusplus

} /* extern "C" namespace std */



#ifndef _CPP_STYLE_HEADER

using std::jmp_buf;

using std::_setjmp;

using std::longjmp;

#endif /* _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#else



#ifdef __cplusplus



#ifndef _CPP_STYLE_HEADER

using std::jmp_buf;

using std::_setjmp;

using std::longjmp;

#endif /* _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#endif /* _SETJMP */


setvbuf.c/      1148595158  0     0     0       4134      `
/*****************************************************************************/

/*  SETVBUF.C  v3.3.2                                                        */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    SETVBUF  -  Set the buffering mode for a stream                        */

/*****************************************************************************/

#include <stdio.h>

#include <stdlib.h>



extern void   _cleanup();

extern _DATA_ACCESS void (*_cleanup_ptr)(void);





/*****************************************************************************/

/* SETVBUF  -  Set the buffering mode for a stream                           */

/*                                                                           */

/*    This function sets the buffering mode for a stream, and allocates a    */

/*    buffer for it if necessary.                                            */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int setvbuf(register FILE *_fp, register char *_buf,

			 register int _type, register size_t _size)

{

   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if(_fp->fd == -1 || (_type != _IONBF && _size <= 0)) return (EOF);



   /*------------------------------------------------------------------------*/

   /* If a buffer already exists, free it if it was malloc'd, and reset all  */

   /* of the stream's buffer pointers.                                       */

   /*------------------------------------------------------------------------*/

   if(_fp->buf)

   {

      if(_STCHK(_fp, _BUFFALOC)) free((_fp->buf)-1);

      _UNSET(_fp, _BUFFALOC);

      _fp->buf = NULL;

      _fp->pos = NULL;

      _fp->bufend = NULL;

      _fp->buff_stop = NULL;

   }



   /*------------------------------------------------------------------------*/

   /* If NULL was used for the buffering mode, default to fully-buffered.    */

   /*------------------------------------------------------------------------*/

   if(! _type) _type = _IOFBF;



   /*------------------------------------------------------------------------*/

   /* Clear any previous buffering flags, and set the new one.               */

   /*------------------------------------------------------------------------*/

   _UNSET(_fp, (_IOLBF | _IOFBF | _IONBF));

   _SET(_fp, _type);



   /*------------------------------------------------------------------------*/

   /* If a buffer was provided, but its size is only one byte, allocate a    */

   /* different one.  Also, do not allow a buffer size greater than BUFSIZ.  */

   /* The buffer will always have one space at the beginning that is         */

   /* for UNGETC, in the event that an UNGETC is performed on an empty file, */

   /* or when the buffer is full, but unread.                                */

  /*------------------------------------------------------------------------*/

   if(_size == 1) _buf = NULL;

   if(_size > BUFSIZ-1) _size = BUFSIZ -1;

   _size++;



   if (_buf) _fp->pos = _fp->buf = (unsigned char*)_buf+1;

   else

   {

      if (! (_fp->pos = _fp->buf = (unsigned char*)malloc(_size))) return (EOF);

      _fp->pos++;

      _fp->buf++;

      _SET(_fp, _BUFFALOC);

   }



   _fp->bufend = _fp->buf + _size -1;



   /*------------------------------------------------------------------------*/

   /* SETUP _CLEANUP_PTR SO ALL BUFFERS WILL BE FLUSHED AT EXIT.             */

   /*------------------------------------------------------------------------*/

   _cleanup_ptr = _cleanup;



   return (0);

}



sin.c/          1148595158  0     0     0       2055      `
/****************************************************************************/

/*  sin.c            v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:54 CDT 2000 */

 

#include "reald.h"



  REAL SINF(REAL x)

{



/* Adapted from "Software Manual for the Elementary Functions" */

/* Cody and Waite, Prentice Hall 1980. pages 127-133           */



    static  REAL R[4] = 

       {KNST( 0.2601903036e-5),

        KNST(-0.1980741872e-3),

        KNST( 0.8333025139e-2),

        KNST(-0.1666665668e+0)};



    int MustNegate, n;

    REAL f, g, xn, x1, Result, y;



    MustNegate = LSZF(x);

    ABSF2(y, x);

    CPYF(f, x); /* fast code for -PI/2..PI/2 */

    if GTRF(y, Pi_Over_Two) 

    {

       MPYF3(xn, y, One_Over_Pi);



       if GEQF(y, CNST( 2147483648.0) )



       {

          REAL ip;

          CPYF(xn, ROUNDF(xn));

          n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */

          CPYF(x1,TRUNCF(y));

       }

       else

       { 

          FIXFI2(n, ADDF(xn,HALF)); /* round (xn > 0) */

          FLTIF2(xn, n);

          TNCF2(x1, y);

       }



       /* f = ((x1 - xn * C1) + (y - x1)) - xn * C2; */

       SUBF3(f, ADDF(SUBF(x1, 

                          MPYF(xn,CNST(3.140625) )), 

                     SUBF(y,x1)), 

                MPYF(xn,CNST(9.67653589793e-4) ));



       /* protect against round-off and enhanced precision problems */

       if GTRF(ABSF(f), Pi_Over_Two)

          CPYF(f, (GTZF(f) ? Pi_Over_Two : NEGF(Pi_Over_Two)));



       if (MustNegate ^ (n & 1)) NEGF1(f);

    }



    SQRF2(g, f);



    POLYF(Result, g, R, 4 );



    ADDF3(Result, f, MPYF(f, Result));



    /* deal with round-off errors */

    if GTRF(ABSF(Result), ONE)

       Result = (GTRF(Result,ONE) ? ONE : CNST(-1.0));



    return Result;

} /* SINF */


sinh.c/         1148595158  0     0     0       1689      `
/****************************************************************************/

/*  sinh.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:55 CDT 2000 */

 

#include "reald.h"



  REAL SINHF (REAL x)

{

   

   static  REAL P[2] =

      {KNST(-0.190333399e+0),

       KNST(-0.713793159e+1)};



   static  REAL Q[1] =

      {KNST(-0.428277109e+2)};



    REAL g, w, y, z, Result;



    /* Adapted from "Software Manual for the Elementary Functions" */

    /* Cody and Waite, Prentice Hall 1980. pages 217-228.          */



    ABSF2(y,x);

    if LEQF(y,ONE) 

    {

       if LSSF(y, CNST(2.44140625e-4) ) return x;

       SQRF2(g, x);



       POLYF(Result,g,P,2 );

       POLYbF(z,g,Q,1 );

       DIVF2(Result, z);



       ADDF3(Result, x, MPYF(x,Result));

    }

    else 

    {

       if LEQF(y, CNST( 88.72283382) ) 

       {

          CPYF(z, EXPF(y));

          MPYF3(Result, SUBF(z, INVF(z)), HALF);

       }

       else 

       {

          SUBF3(w, y, 0.69316101074218750000E+0 );

          if GTRF(w, ADDF(SUBF(CNST( 88.72283382) ,0.69316101074218750000E+0 ),0.69) ) 

          {

             errno = EDOM;

             if LSZF(x) return CNST(-3.402823466E+38) ;

             return CNST( 3.402823466E+38) ;

          }

          CPYF(z, EXPF(w));

          ADDF3(Result, z, MPYF(0.13830277879601902638E-4 ,z));

       }

       if LSZF(x) NEGF1(Result);

    }

    return Result;

} /* SINHF */


sinit.c/        1148595158  0     0     0       3351      `
/****************************************************************************/

/*  sinit     v3.3.2                                                        */

/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <stdlib.h>



extern void _DATA_ACCESS (*_dtors_ptr)(void);



/*************************************************************************/

/* LIST OF REQUIRED STATIC DESTRUCTIONS.  object POINTS TO THE OBJECT    */

/* TO BE DESTROYED, OR NULL IF THERE ARE SEVERAL.  dtor IS THE           */

/* DESTRUCTOR FOR THE OBJECT, AND dfun IS A FUNCTION THAT WILL CALL ALL  */

/* OF THE DESTRUCTORS IS THERE ARE SEVERAL.  ALWAYS ADD TO THE HEAD OF   */

/* THE LIST TO ENSURE THE PROPER ORDER OF DESTRUCTION.                   */

/*************************************************************************/

typedef struct dtor_list

{

   struct dtor_list *next;

   void             *object;

   union

   {

      void  (*dtor)(void *, int);

      void  (*dfun)(void);

   } fun;

} DTOR_LIST;



DTOR_LIST *dtors = NULL;

	 

/****************************************************************************/

/* CALL_DTORS() - PERFORM STATIC DESTRUCTION.                               */

/****************************************************************************/

void call_dtors(void)

{

   while (dtors)

   {

      /*-----------------------------------------------------------------*/

      /* SINCE A DESTRUCTOR MAY ADD NEW DESTRUCTORS TO THE LIST, NOTE    */

      /* AND REMOVE THE HEAD OF THE DESTRUCTOR LIST NOW.                 */

      /*-----------------------------------------------------------------*/

      DTOR_LIST *curr_dtor = dtors;

      dtors = dtors->next;



      /*-----------------------------------------------------------------*/

      /* IF A SINGLE OBJECT, CALL ITS DESTRUCTOR ON ITSELF (A FLAG VALUE */

      /* OF 2 INDICATES THAT OPERATOR DELETE SHOULD NOT BE CALLED).      */

      /* IF MULTIPLE OBJECTS, CALL THE SUPPLIED FUNCTION TO DESTROY THEM */

      /* ALL.                                                            */

      /*-----------------------------------------------------------------*/

      if (curr_dtor->object)  curr_dtor->fun.dtor(curr_dtor->object, 2);

      else                    curr_dtor->fun.dfun();

   }

}



/****************************************************************************/

/* ADD_DTOR() - ADD A DESTRUCTOR TO THE LIST OF STATIC DESTRUCTIONS.        */

/****************************************************************************/

void __add_dtor(DTOR_LIST *dtor_entry)

{

   /*-----------------------------------------------------------------------*/

   /* REGISTER call_dtors() SO exit() WILL CALL IT.  call_dtors() ISN'T     */

   /* CALLED DIRECTLY FROM exit() SO THAT IT ISN'T LINKED IN IF NOT USED.   */

   /*-----------------------------------------------------------------------*/

   _dtors_ptr = call_dtors;



   /*-----------------------------------------------------------------------*/

   /* ADD THE DESTRUCTOR TO THE LIST.                                       */

   /*-----------------------------------------------------------------------*/

   dtor_entry->next = dtors;

   dtors = dtor_entry;

}


sllll.asm/      1148595158  0     0     0       4522      `
******************************************************************************

* sllll.asm  v3.3.2

* Copyright (c) 2000-2006 Texas Instruments Incorporated

******************************************************************************

	.include "c55xasm.i"

	.mmregs

	.cpl_on

	.arms_on

	.model call=internal ; This function is recognized by name

                             ; in the compiler



	.noremark 5217	     ; The logical shifts used in this file

			     ; safely avoid P1 ECN 217

	.noremark 5538       ; The non-paralleled compares in this file

                             ; safely avoid SE CPU_24

	.noremark 5673       ; The shifts in this file avoid SE CPU_89



*****************************************************************************

* __SLLLLI - Signed shift

*

* WARNING!  Changes to register defs in this function must be reflected in

* the constraint class SLLLLI_SET in ld3.md

*****************************************************************************

    .if __TMS320C55X_PLUS__

*****************************************************************************

* __SLLLLI - Signed shift 

*****************************************************************************

* RYUJIN VERSION

*****************************************************************************

	.global __sslllli

__sslllli:

	bit(ST1, #ST1_SATD) = #1



	.global	__slllli

__slllli:	.asmfunc

	; arg1: AC0, source

	; arg2:  T0, shift amount (always an int quantity)



        T1 = #31                ||  bit(ST1, #ST1_M40) = #1

        compare (T0 >= #32) goto L1



        T1 = #-32               ||  compare (T0 >= #-31) goto L2



L1:	AC0 = AC0 << T1         ||  T0 = T0 - T1



L2:     AC0 = AC0 << T0         ||  bit(ST1, #ST1_SATD) = #0

        bit(ST1, #ST1_M40) = #0 ||  return    

	.endasmfunc

   .else

*****************************************************************************

* __SLLLLI - Signed shift 

*****************************************************************************

* LAIJIN VERSION

*****************************************************************************

	.global __sslllli

__sslllli:

	bit(ST1, #ST1_SATD) = #1



	.global	__slllli

__slllli:	.asmfunc

	; arg1: AC0, source

	; arg2:  T0, shift amount (always an int quantity)



        bit(ST1, #ST1_M40) = #1

        T1 = #31

        TC1 = (T0 > T1)         ||  nop    ; avoid Silicon Exception CPU_24

        if (TC1) goto L1



        T1 = #-32

        TC1 = (T0 > T1)

        if (TC1) goto L2



L1:	AC0 = AC0 << T1         ||  T0 = T0 - T1



L2:     AC0 = AC0 << T0         ||  bit(ST1, #ST1_SATD) = #0

        bit(ST1, #ST1_M40) = #0 ||  return    

	.endasmfunc

   .endif

	

*****************************************************************************

* __SLLULL - Unsigned shift

*

* WARNING!  Changes to register defs in this function must be reflected in

* the constraint class SLLULL_SET in ld3.md

*****************************************************************************

   .if __TMS320C55X_PLUS__

*****************************************************************************

* __SLLULL - Unsigned shift 

*****************************************************************************

* RYUJIN VERSION

*****************************************************************************

	.global	__sllull

__sllull:	.asmfunc

	; arg1: AC0, source

	; arg2:  T0, shift amount (always an int quantity)



	T1 = #31                ||  bit(ST1, #ST1_M40) = #1

	compare (T0 >= #32) goto L3



	T1 = #-32               ||  compare (T0 >= #-31) goto L4



L3:	AC0 = AC0 <<< T1        ||  T0 = T0 - T1



L4:     AC0 = AC0 <<< T0

        bit(ST1, #ST1_M40) = #0 ||  return    

	.endasmfunc

   .else

*****************************************************************************

* __SLLULL - Unsigned shift 

*****************************************************************************

* RYUJIN VERSION

*****************************************************************************

	.global	__sllull

__sllull:	.asmfunc

	; arg1: AC0, source

	; arg2:  T0, shift amount (always an int quantity)



        bit(ST1, #ST1_M40) = #1

        T1 = #31

        TC1 = (T0 > T1)          ||  nop   ; avoid Silicon Exception CPU_24

        if (TC1) goto L3



        T1 = #-32

        TC1 = (T0 > T1) 

        if (TC1) goto L4



L3:	AC0 = AC0 <<< T1         ||  T0 = T0 - T1



L4:     AC0 = AC0 <<< T0

        bit(ST1, #ST1_M40) = #0  ||  return    

	.endasmfunc

   .endif

snprintf.c/     1148595158  0     0     0       3272      `
/*****************************************************************************/

/*  SNPRINTF.C v3.3.2                                                        */

/*  Copyright (c) 2001-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    SNPRINTF -  Copy formatted output to a string                          */

/*    _OUTC    -  Put a character in a string                                */

/*    _OUTS    -  Append a string to another string                          */

/*****************************************************************************/

#include <stdio.h>

#include <format.h>

#include <stdarg.h>

#include <string.h>



extern int _printfi(char **_format, va_list _ap, void *_op,

		    int (*_outc)(char, void *), int (*_outs)(char *, void *));



static int _outc(char c, void *_op);

static int _outs(char *s, void *_op);



struct holder {

    char  *out_end;

    size_t n;

    size_t written;

};



/*****************************************************************************/

/* SNPRINTF  -  Copy formatted output to a string                            */

/*                                                                           */

/*    This function passes a format string and an argument list to           */

/*    _PRINTFI, and writes the result string to the string _STRING.          */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int snprintf(char *_string, size_t _n, const char *_format, ...)

{

    va_list _ap;

    int    rval;

    char  *fptr = (char *)_format;

    struct holder holder; 



    holder.out_end = _string;

    holder.n       = _n;

    holder.written = 0;



    va_start(_ap, _format);

    rval = _printfi(&fptr, _ap, (void *)&holder, _outc, _outs);

    va_end(_ap);



    if (_n) *holder.out_end = '\0';



    return rval;

}



/*****************************************************************************/

/* _OUTC -  Put a character in a string                                      */

/*****************************************************************************/

static int _outc(char c, void *_op)

{

    struct holder *holder = (struct holder *)_op;

    

    if (holder->written < holder->n)

	*holder->out_end++ = c;



    holder->written++;



    return c;

}



/*****************************************************************************/

/* _OUTS -  Append a string to another string                                */

/*****************************************************************************/

static int _outs(char *s, void *_op)

{

    struct holder *holder = (struct holder *)_op;

    size_t len = strlen(s);



    if (holder->written < holder->n)

    {

	size_t space = holder->n - holder->written;

	size_t use = len > space ? space : len;

	memcpy(holder->out_end, s, use);

	holder->out_end += use;

    }

    

    holder->written += len;



    return len;

}

sprintf.c/      1148595158  0     0     0       2736      `
/*****************************************************************************/

/*  SPRINTF.C v3.3.2                                                         */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    SPRINTF  -  Copy formatted output to a string                          */

/*    _OUTC    -  Put a character in a string                                */

/*    _OUTS    -  Append a string to another string                          */

/*****************************************************************************/

#include <stdio.h>

#include <format.h>

#include <stdarg.h>

#include <string.h>



extern int _printfi(char **_format, va_list _ap, void *_op,

		    int (*_outc)(char, void *), int (*_outs)(char *, void *));



static int _outc(char c, void *_op);

static int _outs(char *s, void *_op);



/*****************************************************************************/

/* SPRINTF  -  Copy formatted output to a string                             */

/*                                                                           */

/*    This function passes a format string and an argument list to           */

/*    _PRINTFI, and writes the result string to the string _STRING.          */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int sprintf(char *_string, const char *_format, ...)

{

    va_list _ap;

    int   rval;

    char *fptr = (char *)_format;

    char *out_end = _string;



    va_start(_ap, _format);

    rval = _printfi(&fptr, _ap, (void *)&out_end, _outc, _outs);

    va_end(_ap);



    *out_end = '\0';



    return (rval);

}



/*****************************************************************************/

/* _OUTC -  Put a character in a string                                      */

/*****************************************************************************/

static int _outc(char c, void *_op)

{

    return *(*((char **)_op))++ = c;

}



/*****************************************************************************/

/* _OUTS -  Append a string to another string                                */

/*****************************************************************************/

static int _outs(char *s, void *_op)

{

    size_t len = strlen(s);



    memcpy(*((char **)_op), s, len);

    *((char **)_op) += len;

    return len;

}

sqrt.c/         1148595158  0     0     0       3417      `
/****************************************************************************/

/*  sqrt.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:56 CDT 2000 */

 

#include "reald.h"



  REAL SQRTF(REAL x)

{

    REAL    f, y, z;

    EXPONENT_TYPE e;

    int           i;



    if LEZF(x) 

    {

       if EQZF(x) return ZERO;

       errno = EDOM;



       /* Assume that an argument of < 0.0 got that way because of finite    */

       /* precision during preceeding calculations and that the ideal        */

       /* value is actually 0.0.                                             */

       return ZERO;

    }



    RIPF(x, f, e);



    {

    

       /* First form an estimate of the inverse-square-root.                */

       /* The accuracy of the estimate determines the number of required    */

       /* Newton iterations to compute the required n-bit mantissa result.  */

       /* Given a number expressed as x = f* 2**e, an estimate of 1/SQRT(x),*/

       /* may be computed as:                                               */

       /*   1/SQRT(x)                                                       */

       /* = 1/SQRT(f * 2**e)                                                */

       /* = 1/SQRT(f)      * 1/SQRT(2**e)                                   */

       /*~= (C1*f + C2)    * 1/SQRT(2**(e & 1)) * 1/SQRT(2**(e-(e & 1)))    */

       /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2))     */

       /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */

       /* = (C1*f + C2)    * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)*2 */

       /* = 2*(C1*f + C2)  * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */

       /* =(2*C1*f + 2*C2) * 1/SQRT(2**(e & 1)) * (2**-((e-(e & 1))/2)-1)   */

       /* =(2*C1*f + 2*C2) * {1 or 1/SQRT(2)}   * (2**-((e-(e & 1))/2)-1)   */



       /* .5 <= f < 1, we need 1 <= f < 2, so... */

       /* e = e - 1  ; -- moved below.  Maybe CPU has LSB test as byproduct. */

       /* f = f * 2.0; -- subsumed into calculation below */



       ADDF3(f, MPYF(CNST(-1.145508) ,f), CNST( 2.528320) );



       e -= 1;

       if (e & 1) 

       {

          e -= 1;

          MPYF2(f, One_Over_Sqrt_2);

       }

       SCLF3(y, f, ~(e >> 1));  /* note: last use of "e" */



       /* Estimate of 1/sqrt in y now good to about 5 mantissa bits. */

       /* Refine estimate with Newton iterations.                    */



       /* Do one less newton iterations than is required.            */

       /* Accuracy roughly doubles each time through the loop.       */

       /* Haven't determined actual accuracy vs. iterations yet.     */

       /* Thresholds on loop choices are thus overly conservative.   */

       /* Note: Cannot square y below for reasons of over/under-flow.*/

       for (i = 1; i <= 2 ; i++)

          /* y = y+y*(0.5-((x*y)*0.5)*y); */

          ADDF2(y,MPYF(y,SUBF(HALF,MPYF(MPYF(MPYF(x,y),HALF),y))));



       MPYF3(z,x,y);



       /* Here's the last iteration! */

       /* return z+z*(0.5-((x*y)*0.5)*y); */

       return ADDF(z,MPYF(z,SUBF(HALF,MPYF(MPYF(MPYF(x,y),HALF),y))));

    }



} /* SQRTF */




sscanf.c/       1148595158  0     0     0       5142      `
/*****************************************************************************/

/*  SSCANF.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    SSCANF      -  Read formatted input from a string                      */

/*    _INPCHAR    -  Get a character from the string                         */

/*    _UNINPCHAR  -  Put a character back onto the string                    */

/*    _CHKMBC     -  Check that the characters match the input               */

/*****************************************************************************/

#include <stdio.h>

#include "format.h"

#include <ctype.h>

#include <stdarg.h>

#include <stdlib.h>

#include <string.h>



static int _inpchar(void **inp);

static void _uninpchar(void **inp, char outchar);

static int _chkmbc(void **inp, char **_format, int *num_read);



/*****************************************************************************/

/* SSCANF   -  Read formatted input from a string                            */

/*                                                                           */

/*    This function returns the number of arguments that were assigned a     */

/*    value.                                                                 */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int sscanf(const char *_str, const char *_fmt, ...)

{

   va_list _ap;

   va_start(_ap, _fmt);



   return (_scanfi((void *)_str, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));

}



/*****************************************************************************/

/* _INPCHAR -  Get a character from the string                               */

/*****************************************************************************/

static int _inpchar(void **inp)

{

   char result;

   char *buf = (char *)(*inp);



   result = *(buf++);

   *inp = (void *)buf;  



   return ((result == '\0') ? EOF : result);

}



/*****************************************************************************/

/* _UNINPCHAR  -  Put a character back into the string                       */

/*                                                                           */

/* Note:  Since sscanf() never modifies the input buffer, we can assume      */

/*        that any calls to "_uninpchar" are merely putting back the same    */

/*        character that it had previously read in.  In this case, ignore    */

/*        the contents of outchar and simply back the buffer pointer up.     */

/*                                                                           */

/*        The parameter "outchar" cannot be removed, however, because        */

/*        the fscanf version of this function uses it.  Both versions        */

/*        of this function must have the same prototype since they are both  */

/*        passed as a function pointer to _scanfi.                           */

/*****************************************************************************/

static void _uninpchar(void **inp, char outchar)

{

   char *buf = (char *)(*inp);

   buf--;

   *inp = (void *)buf;  

   return;

}



/*****************************************************************************/

/* _CHKMBC  -  Check that the characters match the input                     */

/*                                                                           */

/*    Check that all characters in the format string that are not part of a  */

/*    conversion specification match the input, until the next '%' or the    */

/*    end of the format string is reached.  The function returns a 0 upon    */

/*    reaching the end of the format string or a mismatch, or a 1 if a '%'   */

/*    is encountered.                                                        */

/*                                                                           */

/*****************************************************************************/

static int _chkmbc(void **inp, char **_format, int *num_read)

{

   char *buf = (char *)*inp;



   /*------------------------------------------------------------------------*/

   /* If there is a white space character in the format statement, skip to   */

   /* the next non-white space character in the input.                       */

   /*------------------------------------------------------------------------*/

   while(isspace(**_format))

   {

      for(;isspace(*buf); buf++) (*num_read)++;

      (*_format)++;

   }



   for(;(**_format != '%') && (**_format != '\0');)

      if(*((*_format)++) != *(buf++)) return (0);

      else (*num_read)++;



   if(**_format == '%')

   {

      *inp = (void *)buf;

       return 1;

   }

   else return (0);

}

stdarg.h/       1148595158  0     0     0       4676      `
/****************************************************************************/

/* stdarg.h v3.3.2                                                          */

/* Copyright (c) 1996-2006 Texas Instruments Incorporated                   */

/****************************************************************************/



#ifndef _STDARG

#define _STDARG



#ifdef __cplusplus

namespace std {

#endif /* __cplusplus */



typedef char *va_list;



#ifdef __cplusplus

} /* namespace std */

#endif



#if !defined(__TMS320C55X_PLUS_BYTE__)

#define va_start(ap, parmN) 	(ap = ((char *)__va_parmadr(parmN)) + 	\

	((__va_argref(parmN) ? sizeof(&parmN) : sizeof(parmN))-sizeof(int)))

#else

#define va_start(ap, parmN) 	(ap = ((char *)__va_parmadr(parmN)) + 	\

	((__va_argref(parmN) ? sizeof(&parmN) :                         \

	    (sizeof(parmN) < 2 ? 2 : sizeof(parmN)))))

#endif



#define va_end(ap)



/****************************************************************************/

/* VA_ARG - Return pointer to the next argument                             */

/*                                                                          */

/* Conventions:                                                             */

/*   1) An argument of size greater then one word is aligned on an even     */

/*      word boundary.                                                      */

/*   2) Argument pointer points to the last word of the previous argument   */

/*      and is updated to point to the last word of the current argument.   */

/*                                                                          */

/* When an argument is passed by-reference (indicated by __va_argref being  */

/* true) the actual argument passed is a pointer and will be treated much   */

/* the same as a "void *" argument.                                         */

/*                                                                          */

/* The first expression of the outer comma expression adds in any necessary */

/* stack alignment per convention 1) above.                                 */

/*                                                                          */

/* The second expression of the outer comma expression increments the       */

/* argument pointer to point to the last word of the argument and produces  */

/* the address to use for the argument.                                     */

/****************************************************************************/



#if !defined(__TMS320C55X_PLUS_BYTE__)

#define va_arg(ap, type)  (						     \

    __va_argref(type) ?							     \

      ((ap) += (sizeof(void *) > 1 && ( ! ((long)(ap) & 1)))) :		     \

      ((ap) += (sizeof(type  ) > 1 && ( ! ((long)(ap) & 1)))),		     \

    __va_argref(type) ?							     \

      ((ap) += sizeof(void *), (** (type **) ((ap) - (sizeof(void *)-1)))) : \

      ((ap) += sizeof(type  ), (*  (type *)  ((ap) - (sizeof(type  )-1))))   \

    )

#else



/*****************************************************************************/

/* objects of size "char" are widened to "int" before being passed to a	     */

/* variadic function.  ints are aligned to 2 bytes, longs to 4, long longs   */

/* to 8. aggregates are handled as pointers, which in huge model are 4	     */

/* bytes.								     */

/*****************************************************************************/

/* Note: ap is left pointing to the *beginning* of where the next arg might  */

/* occur								     */

/*****************************************************************************/

#define va_arg(ap, type)  (						      \

    __va_argref(type) ?							      \

      ((ap) = (char *)(((long)ap + 3) & ~3)) :                                \

      ((ap) = (char *)                                                        \

              ((sizeof(type) == sizeof(long long)) ? (((long)ap + 7) & ~7) :  \

	       (sizeof(type) == sizeof(long))      ? (((long)ap + 3) & ~3) :  \

	       (                                      ((long)ap + 1) & ~1))), \

    __va_argref(type) ?							      \

      ((ap) += 4, (** (type **) ((ap) - 4))) :                                \

      ((ap) += ((sizeof(type) < 2) ? 2 : sizeof(type)),                       \

       *(type*)((ap) - ((sizeof(type) < 2 ? 2 : sizeof(type)))))              \

    )



#endif



#ifdef __cplusplus



#ifndef _CPP_STYLE_HEADER

using std::va_list;

#endif /* _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#else



#ifdef __cplusplus



#ifndef _CPP_STYLE_HEADER

using std::va_list;

#endif /* _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#endif /* _STDARG */

stddef.h/       1148595158  0     0     0       1212      `
/*****************************************************************************/

/* stddef.h   v3.3.2                                                         */

/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _STDDEF

#define _STDDEF



#ifdef __cplusplus

extern "C" namespace std {

#endif



#ifndef NULL

#define NULL 0

#endif



typedef __PTRDIFF_T_TYPE__ ptrdiff_t;



#ifndef _SIZE_T

#define _SIZE_T

typedef __SIZE_T_TYPE__ size_t;

#endif



#ifndef __cplusplus

#ifndef _WCHAR_T

#define _WCHAR_T



typedef __WCHAR_T_TYPE__ wchar_t;



#endif /* _WCHAR_T */

#endif /* ! __cplusplus */



#define offsetof(_type, _ident) \

    (__intaddr__( ((char *) &((_type *)0)->_ident) - ((char *) 0) ))



#ifdef __cplusplus

} /* extern "C" namespace std */



#ifndef _CPP_STYLE_HEADER

using std::ptrdiff_t;

using std::size_t;

/*using std::wchar_t;*/

#endif



#endif  /* __cplusplus */



#else



#ifdef __cplusplus



#ifndef _CPP_STYLE_HEADER

using std::ptrdiff_t;

using std::size_t;

/*using std::wchar_t;*/

#endif



#endif  /* __cplusplus */



#endif  /* _STDDEF */

stdexcept/      1148595158  0     0     0       1358      `
/*****************************************************************************/

/* stdexcept  v3.3.2                                                         */

/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/

#ifdef __EXCEPTIONS

#ifndef _STDEXCEPT_STDH

#define _STDEXCEPT_STDH



/* This lets users disable the EDG supplied exception classes. */

#ifndef __NO_EDG_EXCEPTION_CLASSES



#ifdef __EDG_RUNTIME_USES_NAMESPACES

namespace std {

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

  class exception {

  public:

    exception() throw();

    exception(const exception&) throw();

    exception& operator=(const exception&) throw(); 

    virtual ~exception() throw();

    virtual const char* what() const throw();

  };

#ifdef __EDG_RUNTIME_USES_NAMESPACES

}  /* namespace std */



#ifdef __EDG_IMPLICIT_USING_STD

/* Implicitly include a using directive for the STD namespace when this

   preprocessing flag is TRUE. */

using namespace std;

#endif /* ifdef __EDG_IMPLICIT_USING_STD */



#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */



#endif /* _STDEXCEPT_STDH */

#else /* __EXCEPTIONS */

#ifndef _STDEXCEPT

#define _STDEXCEPT

#endif

#endif /* __EXCEPTIONS */



stdexcept.h/    1148595158  0     0     0       1730      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*

The stdexcept header should be included as "#include <stdexcept>".

This file is provided for compatibility with older programs that use

"#include <stdexcept.h>".

*/

#ifndef _STDEXCEPT_H

#define _STDEXCEPT_H



#include <stdexcept>



#endif /* _STDEXCEPT_H */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

stdexcept_.cpp/ 1148595158  0     0     0       2064      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Functions that implement the "stdexcept" classes (19.1).



*/



#include "basics.h"

#include "runtime.h"



#if EXCEPTION_HANDLING



#include <stdexcept>



/*

If the runtime should be defined in the std namespace, open

the std namespace.

*/

#ifdef __EDG_RUNTIME_USES_NAMESPACES

namespace std {

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */





/*

If the runtime should be defined in the std namespace, close

the std namespace.

*/

#ifdef __EDG_RUNTIME_USES_NAMESPACES

}  /* namespace std */

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */





#endif /* EXCEPTION_HANDLING */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

stdint.h/       1148595158  0     0     0       6123      `
/*****************************************************************************/

/* STDINT.H v3.3.2                                                           */

/* Copyright (c) 2002-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/

#ifndef _STDINT_H_

#define _STDINT_H_



/* 7.18.1.1 Exact-width integer types */



#if 0 || defined(__TMS320C55X_PLUS_BYTE__)

    typedef   signed char    int8_t;

    typedef unsigned char   uint8_t;

    typedef          int    int16_t;

    typedef unsigned int   uint16_t;

    typedef          long   int32_t;

    typedef unsigned long  uint32_t;

#elif defined(__TMS320C2000__) || defined(_TMS320C5XX) || defined(__TMS320C55X__)

    typedef          int    int16_t;

    typedef unsigned int   uint16_t;

    typedef          long   int32_t;

    typedef unsigned long  uint32_t;

#elif defined(_TMS320C6X) || defined(__TMS470__)

    typedef   signed char   int8_t;

    typedef unsigned char  uint8_t;

    typedef          short  int16_t;

    typedef unsigned short uint16_t;

    typedef          int    int32_t;

    typedef unsigned int   uint32_t;

#endif



    typedef          long long  int40_t;

    typedef unsigned long long uint40_t;





/* 7.18.1.2 Minimum-width integer types */



#if 0 || 0 || 0 || \

    defined(__TMS320C55X_PLUS_BYTE__)

    typedef  int8_t   int_least8_t;

    typedef uint8_t  uint_least8_t;

#elif defined(__TMS320C2000__) || defined(_TMS320C5XX) || defined(__TMS320C55X__)

    typedef  int16_t  int_least8_t;

    typedef uint16_t uint_least8_t;

#endif



    typedef  int16_t  int_least16_t;

    typedef uint16_t uint_least16_t;

    typedef  int32_t  int_least32_t;

    typedef uint32_t uint_least32_t;



    typedef  int40_t  int_least40_t;

    typedef uint40_t uint_least40_t;



/* sorry, int_least64_t not implemented for C54x, C55x, MSP430 */



/* 7.18.1.3 Fastest minimum-width integer types */



    typedef  int16_t  int_fast8_t;

    typedef uint16_t uint_fast8_t;

    typedef  int16_t  int_fast16_t;

    typedef uint16_t uint_fast16_t;



    typedef  int32_t  int_fast32_t;

    typedef uint32_t uint_fast32_t;



    typedef  int40_t  int_fast40_t;

    typedef uint40_t uint_fast40_t;





/* 7.18.1.4 Integer types capable of holding object pointers */

    typedef          long intptr_t;

    typedef unsigned long uintptr_t;



/* 7.18.1.5 Greatest-width integer types */

    typedef          long long intmax_t;

    typedef unsigned long long uintmax_t;



/* 

   According to footnotes in the 1999 C standard, "C++ implementations

   should define these macros only when __STDC_LIMIT_MACROS is defined

   before <stdint.h> is included." 

*/

#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)



/* 7.18.2 Limits of specified width integer types */



    #define  INT16_MAX  INT32_C(32767)

    #define  INT16_MIN  (-INT16_MAX-1)

    #define UINT16_MAX  UINT32_C(65535)





    #define  INT32_MAX  INT32_C(2147483647)

    #define  INT32_MIN  (-INT32_MAX-1)

    #define UINT32_MAX  UINT32_C(4294967295U)



    #define  INT40_MAX  INT40_C(549755813887)

    #define  INT40_MIN  (-INT40_MAX-1)

    #define UINT40_MAX  UINT40_C(1099511627775UL)





#if 0 || 0 || 0 || \

    defined(__TMS320C55X_PLUS_BYTE__)

    #define  INT_LEAST8_MAX   INT8_MAX

    #define  INT_LEAST8_MIN   INT8_MIN

    #define UINT_LEAST8_MAX   UINT8_MAX

#elif defined(__TMS320C2000__) || defined(_TMS320C5XX) || defined(__TMS320C55X__)

    #define  INT_LEAST8_MAX   INT16_MAX

    #define  INT_LEAST8_MIN   INT16_MIN

    #define UINT_LEAST8_MAX   UINT16_MAX

#endif



    #define  INT_LEAST16_MAX  INT16_MAX

    #define  INT_LEAST16_MIN  INT16_MIN

    #define UINT_LEAST16_MAX  UINT16_MAX

    #define  INT_LEAST32_MAX  INT32_MAX

    #define  INT_LEAST32_MIN  INT32_MIN

    #define UINT_LEAST32_MAX  UINT32_MAX



    #define  INT_LEAST40_MAX  INT40_MAX

    #define  INT_LEAST40_MIN  INT40_MIN

    #define UINT_LEAST40_MAX  UINT40_MAX





    #define  INT_FAST8_MAX   INT16_MAX

    #define  INT_FAST8_MIN   INT16_MIN

    #define UINT_FAST8_MAX   UINT16_MAX

    #define  INT_FAST16_MAX  INT16_MAX

    #define  INT_FAST16_MIN  INT16_MIN

    #define UINT_FAST16_MAX  UINT16_MAX



    #define  INT_FAST32_MAX  INT32_MAX

    #define  INT_FAST32_MIN  INT32_MIN

    #define UINT_FAST32_MAX  UINT32_MAX



    #define  INT_FAST40_MAX  INT40_MAX

    #define  INT_FAST40_MIN  INT40_MIN

    #define UINT_FAST40_MAX  UINT40_MAX





    #define INTPTR_MAX   INT32_MAX

    #define INTPTR_MIN   INT32_MIN

    #define UINTPTR_MAX  UINT32_MAX



    #define INTMAX_MIN   INT40_MIN

    #define INTMAX_MAX   INT40_MAX

    #define UINTMAX_MAX  UINT40_MAX



/* 7.18.3 Limits of other integer types */



    #define PTRDIFF_MAX INT16_MAX

    #define PTRDIFF_MIN INT16_MIN



/* sig_atomic_t not defined */



    #define SIZE_MAX INT16_MAX



#define WCHAR_MAX 0xffffu

#define WCHAR_MIN 0



/* wint_t not defined */



/* 7.18.4.1 Macros for minimum-width integer constants */



/*

   There is a defect report filed against the C99 standard concerning how 

   the (U)INTN_C macros should be implemented.  Please refer to --

   http://wwwold.dkuug.dk/JTC1/SC22/WG14/www/docs/dr_209.htm 

   for more information.  These macros are implemented according to the

   suggestion given at this web site.

*/



    #define  INT8_C(value)  ((int_least8_t)(value))

    #define UINT8_C(value)  ((uint_least8_t)(value))

    #define  INT16_C(value) ((int_least16_t)(value))

    #define UINT16_C(value) ((uint_least16_t)(value))

    #define  INT32_C(value) ((int_least32_t)(value))

    #define UINT32_C(value) ((uint_least32_t)(value))



    #define  INT40_C(value) ((int_least40_t)(value))

    #define UINT40_C(value) ((uint_least40_t)(value))





/* 7.18.4.2 Macros for greatest-width integer constants */



    #define  INTMAX_C(value) ((intmax_t)(value))

    #define UINTMAX_C(value) ((uintmax_t)(value))



#endif /* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */



#endif /* _STDINT_H_ */


stdio.h/        1148595158  0     0     0       11030     `
/*****************************************************************************/

/* STDIO.H v3.3.2                                                            */

/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/

#ifndef _STDIO 

#define _STDIO



#include <linkage.h>

#include <stdarg.h>



#ifdef __cplusplus

//----------------------------------------------------------------------------

// <cstdio> IS RECOMMENDED OVER <stdio.h>.  <stdio.h> IS PROVIDED FOR

// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++

//----------------------------------------------------------------------------

extern "C" namespace std {

#endif



/****************************************************************************/

/* TYPES THAT ANSI REQUIRES TO BE DEFINED                                   */

/****************************************************************************/

#ifndef _SIZE_T

#define _SIZE_T

typedef __SIZE_T_TYPE__ size_t;

#endif



typedef struct {

      int fd;                    /* File descriptor */

      unsigned char* buf;        /* Pointer to start of buffer */

      unsigned char* pos;        /* Position in buffer */

      unsigned char* bufend;     /* Pointer to end of buffer */

      unsigned char* buff_stop;  /* Pointer to last read char in buffer */

      unsigned int   flags;      /* File status flags (see below) */

} FILE;



#ifndef _FPOS_T

#define _FPOS_T

typedef long fpos_t;

#endif /* _FPOS_T */



/****************************************************************************/

/* MACROS THAT DEFINE AND USE FILE STATUS FLAGS                             */

/****************************************************************************/

#define _IOFBF       0x0001

#define _IOLBF       0x0002

#define _IONBF       0x0004

#define _BUFFALOC    0x0008

#define _MODER       0x0010

#define _MODEW       0x0020

#define _MODERW      0x0040

#define _MODEA       0x0080

#define _MODEBIN     0x0100

#define _STATEOF     0x0200

#define _STATERR     0x0400

#define _UNGETC      0x0800

#define _TMPFILE     0x1000



#define _SET(_fp, _b)      (((_fp)->flags) |= (_b))

#define _UNSET(_fp, _b)    (((_fp)->flags) &= ~(_b))

#define _STCHK(_fp, _b)    (((_fp)->flags) & (_b))

#define _BUFFMODE(_fp)     (((_fp)->flags) & (_IOFBF | _IOLBF | _IONBF))

#define _ACCMODE(_fp)      (((_fp)->flags) & (_MODER | _MODEW))



/****************************************************************************/

/* MACROS THAT ANSI REQUIRES TO BE DEFINED                                  */

/****************************************************************************/

#define BUFSIZ          256 



#define FOPEN_MAX       _NFILE

#define FILENAME_MAX    256  

#define TMP_MAX         65535



#define SEEK_SET  (0x0000)

#define SEEK_CUR  (0x0001)

#define SEEK_END  (0x0002)



#ifndef NULL

#define NULL 0

#endif



#ifndef EOF

#define EOF    (-1)

#endif



#define stdin     (&_ftable[0])      

#define stdout    (&_ftable[1])

#define stderr    (&_ftable[2])



#define L_tmpnam  (sizeof(P_tmpdir) + 15)



/******** END OF ANSI MACROS ************************************************/



#define P_tmpdir        ""                   /* Path for temp files         */



/****************************************************************************/

/* DEVICE AND STREAM RELATED DATA STRUCTURES AND MACROS                     */

/****************************************************************************/

#define _NFILE          10                   /* Max number of files open    */



extern _DATA_ACCESS FILE _ftable[_NFILE];

extern _DATA_ACCESS char _tmpnams[_NFILE][L_tmpnam];



/****************************************************************************/

/*   FUNCTION DEFINITIONS  - ANSI                                           */

/****************************************************************************/

/****************************************************************************/

/* OPERATIONS ON FILES                                                      */

/****************************************************************************/

extern _CODE_ACCESS int     remove(const char *_file);

extern _CODE_ACCESS int     rename(const char *_old, const char *_new);

extern _CODE_ACCESS FILE   *tmpfile(void);

extern _CODE_ACCESS char   *tmpnam(char *_s);



/****************************************************************************/

/* FILE ACCESS FUNCTIONS                                                    */

/****************************************************************************/

extern _CODE_ACCESS int     fclose(FILE *_fp); 

extern _CODE_ACCESS FILE   *fopen(const char *_fname, const char *_mode);

extern _CODE_ACCESS FILE   *freopen(const char *_fname, const char *_mode,

			            register FILE *_fp);

extern _CODE_ACCESS void    setbuf(register FILE *_fp, char *_buf);

extern _CODE_ACCESS int     setvbuf(register FILE *_fp, register char *_buf, 

			            register int _type, register size_t _size);

extern _CODE_ACCESS int     fflush(register FILE *_fp); 



/****************************************************************************/

/* FORMATTED INPUT/OUTPUT FUNCTIONS                                         */

/****************************************************************************/

extern _CODE_ACCESS int fprintf(FILE *_fp, const char *_format, ...);

extern _CODE_ACCESS int fscanf(FILE *_fp, const char *_fmt, ...);

extern _CODE_ACCESS int printf(const char *_format, ...);

extern _CODE_ACCESS int scanf(const char *_fmt, ...);

extern _CODE_ACCESS int sprintf(char *_string, const char *_format, ...);

extern _CODE_ACCESS int snprintf(char *_string, size_t _n, 

				 const char *_format, ...);

extern _CODE_ACCESS int sscanf(const char *_str, const char *_fmt, ...);

extern _CODE_ACCESS int vfprintf(FILE *_fp, const char *_format, va_list _ap);

extern _CODE_ACCESS int vprintf(const char *_format, va_list _ap);

extern _CODE_ACCESS int vsprintf(char *_string, const char *_format,

				 va_list _ap);

extern _CODE_ACCESS int vsnprintf(char *_string, size_t _n, 

				  const char *_format, va_list _ap);



/****************************************************************************/

/* CHARACTER INPUT/OUTPUT FUNCTIONS                                         */

/****************************************************************************/

extern _CODE_ACCESS int     fgetc(register FILE *_fp);

extern _CODE_ACCESS char   *fgets(char *_ptr, register int _size,

				  register FILE *_fp);

extern _CODE_ACCESS int     fputc(int _c, register FILE *_fp);

extern _CODE_ACCESS int     fputs(const char *_ptr, register FILE *_fp);

extern _CODE_ACCESS int     getc(FILE *_p);

extern _CODE_ACCESS int     getchar(void);

extern _CODE_ACCESS char   *gets(char *_ptr); 

extern _CODE_ACCESS int     putc(int _x, FILE *_fp);

extern _CODE_ACCESS int     putchar(int _x);

extern _CODE_ACCESS int     puts(const char *_ptr); 

extern _CODE_ACCESS int     ungetc(int _c, register FILE *_fp);



/****************************************************************************/

/* DIRECT INPUT/OUTPUT FUNCTIONS                                            */

/****************************************************************************/

extern _CODE_ACCESS size_t  fread(void *_ptr, size_t _size, size_t _count,

				  FILE *_fp);

extern _CODE_ACCESS size_t  fwrite(const void *_ptr, size_t _size,

				   size_t _count, register FILE *_fp); 



/****************************************************************************/

/* FILE POSITIONING FUNCTIONS                                               */

/****************************************************************************/

extern _CODE_ACCESS int     fgetpos(FILE *_fp, fpos_t *_pos);

extern _CODE_ACCESS int     fseek(register FILE *_fp, long _offset,

				  int _ptrname);

extern _CODE_ACCESS int     fsetpos(FILE *_fp, const fpos_t *_pos);

extern _CODE_ACCESS long    ftell(FILE *_fp);

extern _CODE_ACCESS void    rewind(register FILE *_fp); 



/****************************************************************************/

/* ERROR-HANDLING FUNCTIONS                                                 */

/****************************************************************************/

extern _CODE_ACCESS void    clearerr(FILE *_fp);

extern _CODE_ACCESS int     feof(FILE *_fp);

extern _CODE_ACCESS int     ferror(FILE *_fp);

extern _CODE_ACCESS void    perror(const char *_s);



#define _getchar()      getc(stdin)

#define _putchar(_x)    putc((_x), stdout)

#define _clearerr(_fp)   ((void) ((_fp)->flags &= ~(_STATERR | _STATEOF)))



#define _ferror(_x)     ((_x)->flags & _STATERR)



#define _remove(_fl)    (unlink((_fl)))



#ifdef __cplusplus

} /* extern "C" namespace std */



#ifndef _CPP_STYLE_HEADER

using std::size_t;

using std::FILE;

using std::fpos_t;

using std::_ftable;

using std::_tmpnams;

using std::remove;

using std::rename;

using std::tmpfile;

using std::tmpnam;

using std::fclose;

using std::fopen;

using std::freopen;

using std::setbuf;

using std::setvbuf;

using std::fflush;

using std::fprintf;

using std::fscanf;

using std::printf;

using std::scanf;

using std::sprintf;

using std::sscanf;

using std::vfprintf;

using std::vprintf;

using std::vsprintf;

using std::fgetc;

using std::fgets;

using std::fputc;

using std::fputs;

using std::getc;

using std::getchar;

using std::gets;

using std::putc;

using std::putchar;

using std::puts;

using std::ungetc;

using std::fread;

using std::fwrite;

using std::fgetpos;

using std::fseek;

using std::fsetpos;

using std::ftell;

using std::rewind;

using std::clearerr;

using std::feof;

using std::ferror;

using std::perror;

#endif  /* _CPP_STYLE_HEADER */



#endif  /* __cplusplus */



#else



#ifdef __cplusplus



#ifndef _CPP_STYLE_HEADER

using std::size_t;

using std::FILE;

using std::fpos_t;

using std::_ftable;

using std::_tmpnams;

using std::remove;

using std::rename;

using std::tmpfile;

using std::tmpnam;

using std::fclose;

using std::fopen;

using std::freopen;

using std::setbuf;

using std::setvbuf;

using std::fflush;

using std::fprintf;

using std::fscanf;

using std::printf;

using std::scanf;

using std::sprintf;

using std::sscanf;

using std::vfprintf;

using std::vprintf;

using std::vsprintf;

using std::fgetc;

using std::fgets;

using std::fputc;

using std::fputs;

using std::getc;

using std::getchar;

using std::gets;

using std::putc;

using std::putchar;

using std::puts;

using std::ungetc;

using std::fread;

using std::fwrite;

using std::fgetpos;

using std::fseek;

using std::fsetpos;

using std::ftell;

using std::rewind;

using std::clearerr;

using std::feof;

using std::ferror;

using std::perror;

#endif  /* _CPP_STYLE_HEADER */



#endif  /* __cplusplus */



#endif  /* #ifndef _STDIO */



stdlib.h/       1148595158  0     0     0       6040      `
/*****************************************************************************/

/* stdlib.h   v3.3.2                                                         */

/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _STDLIB

#define _STDLIB



#ifdef __cplusplus

//----------------------------------------------------------------------------

// <cstdlib> IS RECOMMENDED OVER <stdlib.h>.  <stdlib.h> IS PROVIDED FOR 

// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++

//----------------------------------------------------------------------------

extern "C" namespace std {

#endif /* !__cplusplus */



typedef struct { int quot, rem; } div_t;



typedef struct { long quot, rem; } ldiv_t;



#define _LLONG_AVAILABLE 1

typedef struct { long long quot, rem; } lldiv_t;



#define MB_CUR_MAX    1



#ifndef NULL

#define NULL          0

#endif



#ifndef _SIZE_T

#define _SIZE_T

typedef __SIZE_T_TYPE__ size_t;

#endif



#ifndef __cplusplus

#ifndef _WCHAR_T

#define _WCHAR_T



typedef __WCHAR_T_TYPE__ wchar_t;



#endif /* _WCHAR_T */

#endif /* ! __cplusplus */



#define EXIT_FAILURE  1

#define EXIT_SUCCESS  0



#define RAND_MAX      32767



#include <linkage.h>



/*---------------------------------------------------------------*/

/* NOTE - Normally, abs, labs, and fabs are expanded inline, so  */

/*        no formal definition is really required. However, ANSI */

/*        requires that they exist as separate functions, so     */

/*        they are supplied in the library.  The prototype is    */

/*        here mainly for documentation.                         */

/*---------------------------------------------------------------*/

    _CODE_ACCESS  int       abs(int _val); 

    _CODE_ACCESS  long      labs(long _val);

#if defined(_LLONG_AVAILABLE)

    _CODE_ACCESS  long long llabs(long long _val);

#endif

        

    _CODE_ACCESS int       atoi(const char *_st);

    _CODE_ACCESS long      atol(const char *_st);

#if defined(_LLONG_AVAILABLE)

    _CODE_ACCESS long long atoll(const char *_st);

#endif

    _CODE_ACCESS int       ltoa(long val, char *buffer);

          _IDECL double    atof(const char *_st);



    _CODE_ACCESS long      strtol(const char *_st, char **_endptr, int _base);

    _CODE_ACCESS unsigned long strtoul(const char *_st, char **_endptr,

    					  int _base);

#if defined(_LLONG_AVAILABLE)

    _CODE_ACCESS long long strtoll(const char *_st, char **_endptr, int _base);

    _CODE_ACCESS unsigned long long strtoull(const char *_st, char **_endptr,

					     int _base);

#endif

    _CODE_ACCESS double    strtod(const char *_st, char **_endptr);

    

    _CODE_ACCESS int    rand(void);

    _CODE_ACCESS void   srand(unsigned _seed);

    

    _CODE_ACCESS void  *calloc(size_t _num, size_t _size);

    _CODE_ACCESS void  *malloc(size_t _size);

    _CODE_ACCESS void  *realloc(void *_ptr, size_t _size);

    _CODE_ACCESS void   free(void *_ptr);

    _CODE_ACCESS void  *memalign(size_t _aln, size_t _size);

    

    _CODE_ACCESS void   abort(void); 

    _CODE_ACCESS int    atexit(void (*_func)(void));

    _CODE_ACCESS void  *bsearch(const void *_key, const void *_base,

    				   size_t _nmemb, size_t _size, 

    			           int (*compar)(const void *,const void *));

    _CODE_ACCESS void   qsort(void *_base, size_t _nmemb, size_t _size, 

    			         int (*_compar)(const void *, const void *));

    _CODE_ACCESS void   exit(int _status);

    

    _CODE_ACCESS div_t  div(int _numer, int _denom);

    _CODE_ACCESS ldiv_t ldiv(long _numer, long _denom);

#if defined(_LLONG_AVAILABLE)

    _CODE_ACCESS lldiv_t lldiv(long long _numer, long long _denom);

#endif



    _CODE_ACCESS char  *getenv(const char *_string);

    _CODE_ACCESS int    system(const char *_name);



#ifdef __cplusplus

} /* extern "C" namespace std */



#ifndef _CPP_STYLE_HEADER

using std::div_t;

using std::ldiv_t;

#if defined(_LLONG_AVAILABLE)

using std::lldiv_t;

#endif

using std::size_t;

using std::abs;

using std::labs;

using std::atoi;

using std::atol;

#if defined(_LLONG_AVAILABLE)

using std::llabs;

using std::atoll;

#endif

using std::atof;

using std::strtol;

using std::strtoul;

#if defined(_LLONG_AVAILABLE)

using std::strtoll;

using std::strtoull;

#endif

using std::strtod;

using std::rand;

using std::srand;

using std::calloc;

using std::malloc;

using std::realloc;

using std::free;

using std::memalign;

using std::abort;

using std::atexit;

using std::bsearch;

using std::qsort;

using std::exit;

using std::div;

using std::ldiv;

#if defined(_LLONG_AVAILABLE)

using std::lldiv;

#endif

using std::getenv;

using std::system;

#endif /* ! _CPP_STYLE_HEADER */



#endif /* __cplusplus */





#ifdef _INLINE



#ifdef __cplusplus

namespace std {

#endif



static __inline double atof(const char *_st) 

{

  return strtod(_st, (char **)0); 

}



#ifdef __cplusplus

} /* namespace std */

#endif



#endif  /* _INLINE */



#else



#ifdef __cplusplus



#ifndef _CPP_STYLE_HEADER

using std::div_t;

using std::ldiv_t;

#if defined(_LLONG_AVAILABLE)

using std::lldiv_t;

#endif

using std::size_t;

using std::abs;

using std::labs;

using std::atoi;

using std::atol;

#if defined(_LLONG_AVAILABLE)

using std::llabs;

using std::atoll;

#endif

using std::atof;

using std::strtol;

using std::strtoul;

#if defined(_LLONG_AVAILABLE)

using std::strtoll;

using std::strtoull;

#endif

using std::strtod;

using std::rand;

using std::srand;

using std::calloc;

using std::malloc;

using std::realloc;

using std::free;

using std::memalign;

using std::abort;

using std::atexit;

using std::bsearch;

using std::qsort;

using std::exit;

using std::div;

using std::ldiv;

#if defined(_LLONG_AVAILABLE)

using std::lldiv;

#endif

using std::getenv;

using std::system;

#endif /* ! _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#endif  /* ! _STDLIB */

strcat.c/       1148595158  0     0     0       411       `
/****************************************************************************/

/*  strcat v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _STRCAT



#include <string.h>


strchr.c/       1148595158  0     0     0       411       `
/****************************************************************************/

/*  strchr v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _STRCHR



#include <string.h>


strcmp.c/       1148595158  0     0     0       411       `
/****************************************************************************/

/*  strcmp v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _STRCMP



#include <string.h>


strcoll.c/      1148595158  0     0     0       605       `
/****************************************************************************/

/*  strcoll v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <string.h>



_CODE_ACCESS int   strcoll(const char *string1, const char *string2)

{

     register const char *r1 = string1 - 1;

     register const char *r2 = string2 - 1;

     register char cp;

 

     while ((*++r2 == (cp = *++r1)) && cp);

     return *r1 - *r2;

}


strcpy.c/       1148595158  0     0     0       411       `
/****************************************************************************/

/*  strcpy v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _STRCPY



#include <string.h>


strcspn.c/      1148595158  0     0     0       1042      `
/****************************************************************************/

/*  strcspn v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <string.h>



_CODE_ACCESS size_t strcspn(const char *s1, const char *s2)

{

   const char *check;

   size_t      count = 0;

 

   /*---------------------------------------------------------------------*/

   /* FOR EACH CHAR IN s1                                                 */

   /*---------------------------------------------------------------------*/

   for (; *s1; s1++, count++)

   {

      for (check = s2; *check;)

	 /*---------------------------------------------------------------*/

	 /* QUIT WHEN FIND A CHAR IN s1 THAT'S EQUAL TO A CHAR IN s2      */

	 /*---------------------------------------------------------------*/

	 if (*s1 == *check++) return count;

   }

   return count;

}

strerror.c/     1148595158  0     0     0       726       `
/****************************************************************************/

/*  strerror  v3.3.2                                                        */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <errno.h>

#include <string.h>



_CODE_ACCESS char *strerror(int errnum)

{

   switch(errnum)

   {

      case 0      :  return ("No error");

      case EDOM   :  return ("Domain error");

      case ERANGE :  return ("Range error");

      case ENOENT :  return ("No such file or directory");

      case EFPOS  :  return ("File positioning error");

   }



   return ("Unknown error");

}

strftime.c/     1148595158  0     0     0       3820      `
/****************************************************************************/

/*  strftime v3.3.2                                                         */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <time.h>

#include <string.h>



extern int  sprintf(char *_string, const char *_format, ...);



static _DATA_ACCESS const char *const fday[] =

           { "Sunday","Monday","Tuesday","Wednesday",

	     "Thursday","Friday","Saturday" };



static _DATA_ACCESS const char *const fmon[] =

	   { "January","February","March","April","May",

	     "June", "July","August","September",

	     "October","November", "December" };



_CODE_ACCESS size_t strftime(char            *out,

	                     size_t           maxsize, 

	                     const char      *format,

	                     const struct tm *time)

{

    struct tm tt = *time; 

    int       count = 0;

    char      buf[37];



    mktime(&tt);     /* MAKE SURE THIS IS A LEGITIMATE TIME */



    for (;;)

    {

	while ((count < maxsize) && *format && (*format != '%'))

	{

	    count++;

	    *out++ = *format++;

	}



	if (count >= maxsize) return 0;

	if (*format == '\0')  { *out = 0; return count; }



	switch (*++format)

	{

	    case '%' : strcpy(buf, "%");                              break;

	    case 'z' : strcpy(buf, _tz.dstname);                      break;

	    case 'Z' : strcpy(buf, _tz.tzname);                       break;



	    case 'A' : strcpy (buf, fday[tt.tm_wday]);                break;

	    case 'a' : strncpy(buf, fday[tt.tm_wday], 3); buf[3] = 0; break;

	    case 'B' : strcpy (buf, fmon[tt.tm_mon]);                 break;

	    case 'b' : strncpy(buf, fmon[tt.tm_mon], 3);  buf[3] = 0; break;

	    case 'c' : sprintf(buf, "%s %s%3d %02d:%02d:%02d %d",

			       fday[tt.tm_wday], fmon[tt.tm_mon],

			       tt.tm_mday, tt.tm_hour, tt.tm_min,

			       tt.tm_sec, tt.tm_year + 1900);         break;



	    case 'I' : sprintf(buf, "%02d", ((tt.tm_hour != 0) &&

			                     (tt.tm_hour != 12)) ? 

			                    tt.tm_hour % 12 : 12);    break;

	    case 'H' : sprintf(buf, "%02d", tt.tm_hour);              break;

	    case 'M' : sprintf(buf, "%02d", tt.tm_min);               break;

	    case 'S' : sprintf(buf, "%02d", tt.tm_sec);               break;

	    case 'j' : sprintf(buf, "%03d", tt.tm_yday + 1);          break;

	    case 'd' : sprintf(buf, "%02d", tt.tm_mday);              break;

	    case 'e' : sprintf(buf, "%2d",  tt.tm_mday);              break;

	    case 'w' : sprintf(buf, "%1d",  tt.tm_wday);              break;

	    case 'm' : sprintf(buf, "%02d", tt.tm_mon + 1);           break;

	    case 'y' : sprintf(buf, "%02d", tt.tm_year % 100);        break;

	    case 'Y' : sprintf(buf, "%4d", 1900 + tt.tm_year);        break;



	    case 'p' : strcpy(buf, tt.tm_hour >= 12 ? "PM":"AM");     break;



	    case 'W' : sprintf(buf, "%02d", tt.tm_yday / 7 +

			       (tt.tm_yday % 7 >= (tt.tm_wday + 6) % 7));

	    							      break;

	    case 'U' : sprintf(buf, "%02d", tt.tm_yday / 7 +

			       (tt.tm_yday % 7 >= tt.tm_wday));       break;



	    case 'x' : sprintf(buf, "%3s %d, %d", fmon[tt.tm_mon], 

			       tt.tm_mday, tt.tm_year + 1900);        break;

	    case 'X' : sprintf(buf, "%02d:%02d:%02d", tt.tm_hour, 

			       tt.tm_min, tt.tm_sec);                 break;

	}



	/*-------------------------------------------------------------*/

	/* IF THIS STRING WILL FIT IN BUFFER, APPEND IT.               */

	/*-------------------------------------------------------------*/

	if ((count += strlen(buf)) > maxsize) return 0;

	strcpy(out, buf);

	out += strlen(buf);

	format++;

    }

}

string.h/       1148595158  0     0     0       8259      `
/*****************************************************************************/

/* string.h   v3.3.2                                                         */

/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _STRING

#define _STRING



#ifdef __cplusplus

//----------------------------------------------------------------------------

// <cstring> IS RECOMMENDED OVER <string.h>.  <string.h> IS PROVIDED FOR

// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++

//----------------------------------------------------------------------------

extern "C" namespace std

{

#endif /* __cplusplus */

 

#ifndef NULL

#define NULL 0

#endif



#ifndef _SIZE_T

#define _SIZE_T

typedef __SIZE_T_TYPE__ size_t;

#endif



#include <linkage.h>



#define _OPT_IDECL	_IDECL



_OPT_IDECL size_t  strlen(const char *_string);



_OPT_IDECL char *strcpy(char *_dest, const char *_src);

_OPT_IDECL char *strncpy(char *_to, const char *_from, size_t _n);

_OPT_IDECL char *strcat(char *_string1, const char *_string2);

_OPT_IDECL char *strncat(char *_to, const char *_from, size_t _n);

_OPT_IDECL char *strchr(const char *_string, int _c);

_OPT_IDECL char *strrchr(const char *_string, int _c);



_OPT_IDECL int  strcmp(const char *_string1, const char *_string2);

_OPT_IDECL int  strncmp(const char *_string1, const char *_string2, size_t _n);



_CODE_ACCESS int     strcoll(const char *_string1, const char *_string2);

_CODE_ACCESS size_t  strxfrm(char *_to, const char *_from, size_t _n);

_CODE_ACCESS char   *strpbrk(const char *_string, const char *_chs);

_CODE_ACCESS size_t  strspn(const char *_string, const char *_chs);

_CODE_ACCESS size_t  strcspn(const char *_string, const char *_chs);

_CODE_ACCESS char   *strstr(const char *_string1, const char *_string2);

_CODE_ACCESS char   *strtok(char *_str1, const char *_str2);

_CODE_ACCESS char   *strerror(int _errno);



_CODE_ACCESS void   *memmove(void *_s1, const void *_s2, size_t _n);

_CODE_ACCESS void   *memcpy(void *_s1, const void *_s2, size_t _n);



_OPT_IDECL int     memcmp(const void *_cs, const void *_ct, size_t _n);

_OPT_IDECL void   *memchr(const void *_cs, int _c, size_t _n);



_OPT_IDECL   void   *memset(void *_mem, int _ch, size_t _n);





#ifdef __cplusplus

} /* extern "C" namespace std */



#ifndef _CPP_STYLE_HEADER

using std::size_t;

using std::strlen;

using std::strcpy;

using std::strncpy;

using std::strcat;

using std::strncat;

using std::strchr;

using std::strrchr;

using std::strcmp;

using std::strncmp;

using std::strcoll;

using std::strxfrm;

using std::strpbrk;

using std::strspn;

using std::strcspn;

using std::strstr;

using std::strtok;

using std::strerror;

using std::memmove;

using std::memcpy;

using std::memcmp;

using std::memchr;

using std::memset;





#endif /* _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#if defined(_INLINE) || defined(_STRING_IMPLEMENTATION)





#ifdef __cplusplus

namespace std {

#endif



#define _OPT_IDEFN	_IDEFN



#if defined(_INLINE) || defined(_STRLEN)

_OPT_IDEFN size_t strlen(const char *string)

{

   size_t      n = (size_t)-1;

   const char *s = string - 1;



   do n++; while (*++s);

   return n;

}

#endif /* _INLINE || _STRLEN */



#if defined(_INLINE) || defined(_STRCPY)

_OPT_IDEFN char *strcpy(register char *dest, register const char *src)

{

     register char       *d = dest - 1;     

     register const char *s = src  - 1;     



     while (*++d = *++s);

     return dest;

}

#endif /* _INLINE || _STRCPY */



#if defined(_INLINE) || defined(_STRNCPY)

_OPT_IDEFN char *strncpy(register char *dest,

		     register const char *src,

		     register size_t n)

{

     if (n) 

     {

	 register char       *d = dest - 1;

	 register const char *s = src - 1;

	 while ((*++d = *++s) && --n);              /* COPY STRING         */

	 if (n-- > 1) do *++d = '\0'; while (--n);  /* TERMINATION PADDING */

     }

     return dest;

}

#endif /* _INLINE || _STRNCPY  */



#if defined(_INLINE) || defined(_STRCAT)

_OPT_IDEFN char *strcat(char *string1, const char *string2)

{

   char       *s1 = string1 - 1;

   const char *s2 = string2 - 1;



   while (*++s1);		     /* FIND END OF STRING   */

   s1--;  			     /* BACK UP OVER NULL    */

   while (*++s1 = *++s2);	     /* APPEND SECOND STRING */

   return string1;

}

#endif /* _INLINE || _STRCAT */



#if defined(_INLINE) || defined(_STRNCAT)

_OPT_IDEFN char *strncat(char *dest, const char *src, register size_t n)

{

    if (n)

    {

	char       *d = dest - 1;

	const char *s = src  - 1;



	while (*++d);                      /* FIND END OF STRING   */

	d--;                               /* BACK UP OVER NULL    */



	while (n--)

	  if (!(*++d = *++s)) return dest; /* APPEND SECOND STRING */

	*++d = 0;

    }

    return dest;

}

#endif /* _INLINE || _STRNCAT */



#if defined(_INLINE) || defined(_STRCHR)

_OPT_IDEFN char *strchr(const char *string, int c)

{

   char        tch, ch  = c;

   const char *s        = string - 1;



   for (;;)

   {

       if ((tch = *++s) == ch) return (char *) s;

       if (!tch)               return (char *) 0;

   }

}

#endif /* _INLINE || _STRCHR */



#if defined(_INLINE) || defined(_STRRCHR)

_OPT_IDEFN char *strrchr(const char *string, int c)

{

   char        tch, ch = c;

   char       *result  = 0;

   const char *s       = string - 1;



   for (;;)

   {

      if ((tch = *++s) == ch) result = (char *) s;

      if (!tch) break;

   }



   return result;

}

#endif /* _INLINE || _STRRCHR */



#if defined(_INLINE) || defined(_STRCMP)

_OPT_IDEFN int strcmp(register const char *string1,

		  register const char *string2)

{

   register int c1, res;



   for (;;)

   {

       c1  = (unsigned char)*string1++;

       res = c1 - (unsigned char)*string2++;



       if (c1 == 0 || res != 0) break;

   }



   return res;

}

#endif /* _INLINE || _STRCMP */



#if defined(_INLINE) || defined(_STRNCMP)

_OPT_IDEFN int strncmp(const char *string1, const char *string2, size_t n)

{

     if (n) 

     {

	 const char *s1 = string1 - 1;

	 const char *s2 = string2 - 1;

	 unsigned char cp;

	 int         result;



	 do 

	    if (result = (unsigned char)*++s1 - (cp = (unsigned char)*++s2))

                return result;

	 while (cp && --n);

     }

     return 0;

}

#endif /* _INLINE || _STRNCMP */



#if defined(_INLINE) || defined(_MEMCMP)

_OPT_IDEFN int memcmp(const void *cs, const void *ct, size_t n)

{

   if (n) 

   {

       const unsigned char *mem1 = (unsigned char *)cs - 1;

       const unsigned char *mem2 = (unsigned char *)ct - 1;

       int                 cp;



       while ((cp = *++mem1) == *++mem2 && --n);

       return cp - *mem2;

   }

   return 0;

}

#endif /* _INLINE || _MEMCMP */



#if defined(_INLINE) || defined(_MEMCHR)

_OPT_IDEFN void *memchr(const void *cs, int c, size_t n)

{

   if (n)

   {

      const unsigned char *mem = (unsigned char *)cs - 1;   

      unsigned char        ch  = c;



      do if ( *++mem == ch ) return (void *)mem;

      while (--n);

   }

   return NULL;

}

#endif /* _INLINE || _MEMCHR */



#if ((defined(_INLINE) || defined(_MEMSET)) && !0)

_OPT_IDEFN void *memset(void *mem, register int ch, register size_t length)

{

     register char *m = (char *)mem - 1;



     while (length--) *++m = ch;

     return mem;

}

#endif /* _INLINE || _MEMSET */



#ifdef __cplusplus

} /* namespace std */

#endif





#endif /* (_INLINE || _STRING_IMPLEMENTATION) */



#else



#ifdef __cplusplus



#ifndef _CPP_STYLE_HEADER

using std::size_t;

using std::strlen;

using std::strcpy;

using std::strncpy;

using std::strcat;

using std::strncat;

using std::strchr;

using std::strrchr;

using std::strcmp;

using std::strncmp;

using std::strcoll;

using std::strxfrm;

using std::strpbrk;

using std::strspn;

using std::strcspn;

using std::strstr;

using std::strtok;

using std::strerror;

using std::memmove;

using std::memcpy;

using std::memcmp;

using std::memchr;

using std::memset;





#endif /* _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#endif /* ! _STRING */


strlen.c/       1148595158  0     0     0       411       `
/****************************************************************************/

/*  strlen v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _STRLEN



#include <string.h>


strncat.c/      1148595158  0     0     0       412       `
/****************************************************************************/

/*  strncat v3.3.2                                                          */

/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _STRNCAT



#include <string.h>

strncmp.c/      1148595158  0     0     0       412       `
/****************************************************************************/

/*  strncmp v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _STRNCMP



#include <string.h>

strncpy.c/      1148595158  0     0     0       412       `
/****************************************************************************/

/*  strncpy v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _STRNCPY



#include <string.h>

strpbrk.c/      1148595158  0     0     0       566       `
/****************************************************************************/

/*  strpbrk v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <string.h>



_CODE_ACCESS char *strpbrk(const char *s1, const char *s2)

{

   for (; *s1; s1++)

   {

      const char *check = s2;

 

      while (*check)

         if (*check++ == *s1) return (char *)s1;

   }

   return NULL;

}

strrchr.c/      1148595158  0     0     0       412       `
/****************************************************************************/

/*  strrchr v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/



#undef  _INLINE

#define _STRING_IMPLEMENTATION

#define _STRRCHR



#include <string.h>

strspn.c/       1148595158  0     0     0       862       `
/****************************************************************************/

/*  strspn  v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <string.h>



_CODE_ACCESS size_t strspn(register const char *string, const char *chs)

{

     size_t count = 0;



     for (;;)            /* FOR EACH CHARACTER IN STRING */

     {

	register char  ch    = *string++;

        register char *check = (char *)chs;

	register char  tch   = *check;                



        while (tch)      /* FOR EACH CHARACTER IN LOOKUP STRING */

        {

	   if (ch == tch) break;

           tch = *++check;

        }



        if (!ch || ch != tch) return(count);

	count++;

     }

}

strstr.c/       1148595158  0     0     0       777       `
/****************************************************************************/

/*  strstr v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <string.h>



_CODE_ACCESS char *strstr(register const char *string1, const char *string2)

{

     register char cp1, cp2;

     register const char *pos = string1;



     while (*string1)         /* FOR EACH STRING IN SOURCE STRING */

     {

         register const char *cmp = string2;



         while (((cp1 = *string1++) == (cp2 = *cmp++)) && cp1);

	 if (cp2 == 0) return (char *)pos;

	 string1 = ++pos;

     }

     return (0);

}




strtod.c/       1148595158  0     0     0       4034      `
/****************************************************************************/

/*  strtod v3.3.2                                                           */

/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <stdlib.h>

#include <ctype.h>

#include <float.h>

#include <errno.h>

#include <math.h>

#include <linkage.h>

#include <stdio.h>

#include <limits.h>



#if (DBL_MAX_10_EXP >= 256)  

static const _DATA_ACCESS double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 

						  1.e16, 1.e32, 1.e64, 1.e128,

						  1.e256};

#else 			    

static const _DATA_ACCESS double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 

						  1.e16, 1.e32};

#endif



static const _DATA_ACCESS double digits[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };



_CODE_ACCESS double strtod(const char *st, char **endptr)

{

    double      result = 0;

    char        cp;

    const char *fst    = st;

    int         exp    = 0;               /* EXPONENT              */

    int         count  = 0;               /* EXPONENT CALCULATION  */

    int         value  = 0;               /* SUCCESSFUL PARSE      */

    int         sign;

    int         plus_or_minus = 0;        /* READ IN EXPONENT SIGN (+/-) */



    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if ((sign = ((cp = *fst) == '-')) || (cp == '+')) { ++fst; value = 1; }



    /*----------------------------------------------------------------------*/

    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */

    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */

    /*----------------------------------------------------------------------*/

    for (; _isdigit(cp = *fst); ++fst) 

    {

       result = result * 10 + digits[cp - '0']; 

       value  = 1;

    }



    if (cp == '.') {

       while (_isdigit(cp = *++fst)) 

       {

          result = result * 10 + digits[cp - '0']; 

          value  = 1;

	  --exp;

       }

    }



    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */



    /*----------------------------------------------------------------------*/

    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */

    /* IF EXPONENT IS BOGUS (i.e. "1.234empty" or "1.234e+mpty") RESTORE    */

    /* BOGUS EXPONENT BACK ONTO RETURNED STRING (endptr).                   */

    /*----------------------------------------------------------------------*/

    if (value && _toupper(*fst) == 'E')

    {

       if ((sign = ((cp = *++fst) == '-')) || (cp == '+'))

       {

          cp = *++fst;

          plus_or_minus = 1;

       }

 

       if (!_isdigit(cp))

       {

          if (plus_or_minus) *--fst;

          *--fst;

          goto skip_loop;

       }



       for (count = 0; _isdigit(cp); cp = *++fst)

       {

	  if ((INT_MAX - abs(exp) - (cp - '0')) / 10 > count)

          {

             count *= 10; 

	     count += cp - '0';

	  } else

	  {

	    count = INT_MAX - exp;

	    break;

	  }

       }



skip_loop:



       if (sign) exp -= count;

       else      exp += count;

    }



    /*----------------------------------------------------------------------*/

    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */

    /*----------------------------------------------------------------------*/

    if (result != 0.0)

    {

       if (exp > DBL_MAX_10_EXP) 

	  { errno = ERANGE; result = (result < 0) ? -HUGE_VAL : HUGE_VAL; }

       else if (exp < DBL_MIN_10_EXP) 

	  { errno = ERANGE; result = 0.0; }

       else if (exp < 0) {

	    for (count = 0, exp = -exp; exp; count++, exp >>= 1)

	        { if (exp & 1) result /= powerof10[count]; }

       }

       else {

	    for (count = 0; exp; count++, exp >>= 1)

	        { if (exp & 1) result *= powerof10[count]; }

       }

    }



    if (endptr) *endptr = (char *)(value ? fst : st);

    return result;

}

strtoimax.c/    1148595158  0     0     0       549       `
/****************************************************************************/

/*  strtoimax v3.3.2                                                        */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdlib.h>

#include <inttypes.h>



_CODE_ACCESS intmax_t strtoimax(const char *st, char **endptr, int base)

{

    register intmax_t    result = 0;



    result = strtoll(st, endptr, base);



    return result;

}


strtok.c/       1148595158  0     0     0       736       `
/****************************************************************************/

/*  strtok v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <string.h>



_CODE_ACCESS char *strtok(char *str1, const char *str2)

{

     static _DATA_ACCESS char *last_end;

     char *start; 



     if (str1) last_end = str1;



     last_end += strspn(last_end, str2);

     if (*last_end == '\0') return (NULL);



     start = last_end;

     last_end += strcspn(last_end, str2);



     if (*last_end != '\0') *last_end++ = '\0'; 



     return start;

}



strtol.c/       1148595158  0     0     0       2820      `
/****************************************************************************/

/*  strtol v3.3.2                                                           */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdlib.h>

#include <limits.h>

#include <ctype.h>

#include <errno.h>

#include <access.h>



_CODE_ACCESS long strtol(const char *st, char **endptr, int base)

{

    register long        result = 0;

    register char        cp;

    register const char *fst    = st;

    int                  digits = 0;

    int                  sign;



    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */



    if (sign = ((cp = *fst) == '-')) cp = *++fst;

    else if (cp == '+') cp = *++fst;



    if (base > 36) base = 0;



    /*-------------------------------------------------------------------*/

    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */

    /*-------------------------------------------------------------------*/

    switch (base)

    {

	case  0 : if      (cp != '0')           base = 10;

		  else if ((cp = *++fst) == 'x' || cp == 'X')

		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }

		     else                     { base = 10; cp = *--fst; }

		  else 

		  {

		     base = 8; 

		     if (cp < '0' || cp > '7')  cp = *--fst;

		  } 

	          break;



        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&

		      _isxdigit(cp))

	             cp = *(fst += 2);

     }



    /*-------------------------------------------------------------------*/

    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */

    /*-------------------------------------------------------------------*/

    for (;; cp = *++fst)

    {

	register long addval;



	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||

	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||

	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;



        if (result == (addval = (result * base + addval))/base) result = addval;

	else 

	{   

	    errno = ERANGE;

	    if (endptr) *endptr = (char *)st;       

	    return sign ? LONG_MIN : LONG_MAX; 

	}



	digits++;

    }



    /*-------------------------------------------------------------------*/

    /* MARK THE END OF THE CONVERTED INPUT.  NEGATE THE RESULT IF A      */

    /* MINUS SIGN WAS SEEN.                                              */

    /*-------------------------------------------------------------------*/

    if (endptr) *endptr = (char *)(digits ? fst : st);

    if (sign)

    {

	if (result > LONG_MAX) { errno = ERANGE; return (LONG_MIN); }

        return -result;

    }

    return result;

}



strtold.c/      1148595159  0     0     0       4079      `
/****************************************************************************/

/*  strtold v3.3.2                                                          */

/*  Copyright (c) 2002-2006 Texas Instruments Incorporated                  */

/****************************************************************************/

#include <stdlib.h>

#include <ctype.h>

#include <float.h>

#include <errno.h>

#include <math.h>

#include <linkage.h>

#include <stdio.h>

#include <limits.h>



#if (LDBL_MAX_10_EXP >= 256)  

static const _DATA_ACCESS long double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 

						       1.e16, 1.e32, 1.e64L, 

						       1.e128L, 1.e256L};

#else 			    

static const _DATA_ACCESS long double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 

						       1.e16, 1.e32};

#endif



static const _DATA_ACCESS double digits[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };



_CODE_ACCESS long double strtold(const char *st, char **endptr)

{

    long double      result = 0;

    char        cp;

    const char *fst    = st;

    int         exp    = 0;               /* EXPONENT              */

    int         count;                    /* EXPONENT CALCULATION  */

    int         value  = 0;               /* SUCCESSFUL PARSE      */

    int         sign;

    int         plus_or_minus = 0;        /* READ IN EXPONENT SIGN (+/-) */



    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if ((sign = ((cp = *fst) == '-')) || (cp == '+')) { ++fst; value = 1; }



    /*----------------------------------------------------------------------*/

    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */

    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */

    /*----------------------------------------------------------------------*/

    for (; _isdigit(cp = *fst); ++fst) 

    {

       result = result * 10 + digits[cp - '0']; 

       value  = 1;

    }



    if (cp == '.') {

       while (_isdigit(cp = *++fst)) 

       {

          result = result * 10 + digits[cp - '0']; 

          value  = 1;

	  --exp;

       }

    }



    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */



    /*----------------------------------------------------------------------*/

    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */

    /* IF EXPONENT IS BOGUS (i.e. "1.234empty" or "1.234e+mpty") RESTORE    */

    /* BOGUS EXPONENT BACK ONTO RETURNED STRING (endptr).                   */

    /*----------------------------------------------------------------------*/

    if (value && _toupper(*fst) == 'E')

    {

       if ((sign = ((cp = *++fst) == '-')) || (cp == '+'))

       {

          cp = *++fst;

          plus_or_minus = 1;

       }

 

       if (!_isdigit(cp))

       {

          if (plus_or_minus) *--fst;

          *--fst;

          goto skip_loop;

       }



       for (count = 0; _isdigit(cp); cp = *++fst)

       {

	  if ((INT_MAX - abs(exp) - (cp - '0')) / 10 > count)

          {

             count *= 10; 

	     count += cp - '0';

	  } else

	  {

	    count = INT_MAX - exp;

	    break;

	  }

       }



skip_loop:



       if (sign) exp -= count;

       else      exp += count;

    }



    /*----------------------------------------------------------------------*/

    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */

    /*----------------------------------------------------------------------*/

    if (result != 0.0)

    {

       if (exp > LDBL_MAX_10_EXP) 

	  { errno = ERANGE; result = (result < 0) ? -HUGE_VALL : HUGE_VALL; }

       else if (exp < LDBL_MIN_10_EXP) 

	  { errno = ERANGE; result = 0.0; }

       else if (exp < 0) {

	    for (count = 0, exp = -exp; exp; count++, exp >>= 1)

	        { if (exp & 1) result /= powerof10[count]; }

       }

       else {

	    for (count = 0; exp; count++, exp >>= 1)

	        { if (exp & 1) result *= powerof10[count]; }

       }

    }



    if (endptr) *endptr = (char *)(value ? fst : st);

    return result;

}


strtoll.c/      1148595159  0     0     0       2829      `
/****************************************************************************/

/*  strtoll v3.3.2                                                          */

/*  Copyright (c) 2000-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdlib.h>

#include <limits.h>

#include <ctype.h>

#include <errno.h>

#include <access.h>



_CODE_ACCESS long long strtoll(const char *st, char **endptr, int base)

{

    register long long   result = 0;

    register char        cp;

    register const char *fst    = st;

    int                  digits = 0;

    int                  sign;



    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */



    if (sign = ((cp = *fst) == '-')) cp = *++fst;

    else if (cp == '+') cp = *++fst;



    if (base > 36) base = 0;



    /*-------------------------------------------------------------------*/

    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */

    /*-------------------------------------------------------------------*/

    switch (base)

    {

	case  0 : if      (cp != '0')           base = 10;

		  else if ((cp = *++fst) == 'x' || cp == 'X')

		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }

		     else                     { base = 10; cp = *--fst; }

		  else 

		  {

		     base = 8; 

		     if (cp < '0' || cp > '7')  cp = *--fst;

		  } 

	          break;



        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&

		      _isxdigit(cp))

	             cp = *(fst += 2);

     }



    /*-------------------------------------------------------------------*/

    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */

    /*-------------------------------------------------------------------*/

    for (;; cp = *++fst)

    {

	register long long addval;



	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||

	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||

	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;



        if (result == (addval = (result * base + addval))/base) result = addval;

	else 

	{   

	    errno = ERANGE;

	    if (endptr) *endptr = (char *)st; 

	    return sign ? LLONG_MIN : LLONG_MAX; 

	}



	digits++;

    }



    /*-------------------------------------------------------------------*/

    /* MARK THE END OF THE CONVERTED INPUT.  NEGATE THE RESULT IF A      */

    /* MINUS SIGN WAS SEEN.                                              */

    /*-------------------------------------------------------------------*/

    if (endptr) *endptr = (char *)(digits ? fst : st);

    if (sign)

    {

	if (result > LLONG_MAX) { errno = ERANGE; return (LLONG_MIN); }

        return -result;

    }

    return result;

}




strtoul.c/      1148595159  0     0     0       2656      `
/****************************************************************************/

/*  strtoul v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdlib.h>

#include <limits.h>

#include <ctype.h>

#include <errno.h>



_CODE_ACCESS unsigned long strtoul(const char *st, char **endptr, int base)

{

    register unsigned long result = 0;

    register char          cp;

    register const char   *fst = st;

    int                    digits = 0;

    int                    minus = 0;



    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if (base > 36) base = 0;  



    if ((cp = *fst) == '+') cp = *++fst;

    else if ((cp = *fst) == '-') { cp = *++fst; minus = 1; }



    /*-------------------------------------------------------------------*/

    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */

    /*-------------------------------------------------------------------*/

    switch (base)

    {

	case  0 : if      (cp != '0')           base = 10;

		  else if ((cp = *++fst) == 'x' || cp == 'X')

		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }

		     else                     { base = 10; cp = *--fst; }

		  else 

		  {

		     base = 8; 

		     if (cp < '0' || cp > '7')  cp = *--fst;

		  }

	          break;



        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&

		      _isxdigit(fst[2]))

	             cp = *(fst += 2);

    }



    /*-------------------------------------------------------------------*/

    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */

    /*-------------------------------------------------------------------*/

    for (;; cp = *++fst)

    {

	register unsigned long addval;



	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||

	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||

	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;



        if (result == (addval = (result * base + addval))/base) result = addval;

	else 

	{   

	    errno = ERANGE;

	    if (endptr) *endptr = (char *)st;        

	    return ULONG_MAX; 

	}



	digits++;

    }



    /*-------------------------------------------------------------------*/

    /* MARK THE END OF THE CONVERTED INPUT.                              */

    /*-------------------------------------------------------------------*/

    if (endptr) *endptr = (char *)(digits ? fst : st);



    return minus ? -result : result;

}



strtoull.c/     1148595159  0     0     0       2670      `
/****************************************************************************/

/*  strtoull v3.3.2                                                         */

/*  Copyright (c) 2000-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdlib.h>

#include <limits.h>

#include <ctype.h>

#include <errno.h>



_CODE_ACCESS unsigned long long strtoull(const char *st, char **endptr,int base)

{

    register unsigned long long result = 0;

    register char          cp;

    register const char   *fst = st;

    int                    digits = 0;

    int                    minus = 0;



    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if (base > 36) base = 0;  



    if ((cp = *fst) == '+') cp = *++fst;

    else if ((cp = *fst) == '-') { cp = *++fst; minus = 1; }



    /*-------------------------------------------------------------------*/

    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */

    /*-------------------------------------------------------------------*/

    switch (base)

    {

	case  0 : if      (cp != '0')           base = 10;

		  else if ((cp = *++fst) == 'x' || cp == 'X')

		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }

		     else                     { base = 10; cp = *--fst; }

		  else 

		  {

		     base = 8; 

		     if (cp < '0' || cp > '7')  cp = *--fst;

		  }

	          break;



        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&

		      _isxdigit(fst[2]))

	             cp = *(fst += 2);

    }



    /*-------------------------------------------------------------------*/

    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */

    /*-------------------------------------------------------------------*/

    for (;; cp = *++fst)

    {

	register unsigned long long addval;



	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||

	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||

	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;



        if (result == (addval = (result * base + addval))/base) result = addval;

	else 

	{   

	    errno = ERANGE;

	    if (endptr) *endptr = (char *)st;        

	    return ULLONG_MAX; 

	}



	digits++;

    }



    /*-------------------------------------------------------------------*/

    /* MARK THE END OF THE CONVERTED INPUT.                              */

    /*-------------------------------------------------------------------*/

    if (endptr) *endptr = (char *)(digits ? fst : st);



    return minus ? -result : result;

}

strtoumax.c/    1148595159  0     0     0       552       `
/****************************************************************************/

/*  strtoumax v3.3.2                                                        */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stdlib.h>

#include <inttypes.h>



_CODE_ACCESS uintmax_t strtoumax(const char *st, char **endptr, int base)

{

    register uintmax_t    result = 0;



    result = strtoull(st, endptr, base);



    return result;

}

strxfrm.c/      1148595159  0     0     0       736       `
/****************************************************************************/

/*  strxfrm v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#include <stddef.h>

#include <string.h>



_CODE_ACCESS size_t strxfrm(register char *to,

			    register const char *from,

			    register size_t n)

{

     register int count = 0;     

     while (*from++) count++;                       /* GET LENGTH OF STRING */

     from -= count;

     from--;



     if (n) while ((*to++ = *from++) && --n);       /* COPY STRING          */



     return (count);

}

subd.c/         1148595159  0     0     0       724       `
/****************************************************************************/

/*  subd.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:40 CDT 2000 */

 

#include "realdi.h"

#include "ieeemask.h"

#include "renormd.h"

#include "frcaddd.h"

#include "frcmpyd.h"

#include "frcdivd.h"



  REAL SUBF(REAL left, REAL right)

{ 

#ifdef IEEE_Hardware 

   return left - right;

#else 

   MSC(right) ^= (char)(1<<(16 -1));

   return ADDF(left, right);

#endif 

} /* SUBF */



syntd.h/        1148595159  0     0     0       15596     `
/****************************************************************************/

/*  syntd.h          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:31 CDT 2000 */

 

#ifndef __syntd__

#define __syntd__



#if 0

/*---------------------------------------------------------------------------*/

/* Bind abstract REAL to "double" syntax.                                    */

/* Use built-in operators for unary -, +,-,*,/, >,<,>=,<=,==,!=, =           */

/* Use ANSI names for double version of math.h routines (sqrt, sin, ... etc) */

/*---------------------------------------------------------------------------*/

#endif



#define REAL double

#define EXPONENT_TYPE int



#if BPLEAN == 0

   #undef LEAN

#else /*  since REAL is "double", assume next smallest is "float"*/

   #define LEAN float

#endif



#define CNST(x) (x) /*  constants within statements*/

#define TSNC

#define KNST(x) x   /*  constants within tables    */

#define TSNK



#include "numconst.h" /*  NUMerical CONSTants used by some definitions below*/



#if 0

/*---------------------------------------------------------------------------*/

/* Define Compiler Syntax For Basic Operations                               */

/*---------------------------------------------------------------------------*/

/* Names have form: <operation> F { 1 | 2 | 3 }?                             */

/* Where <operation> is one of:                                              */

/*    CPY  -- simple assignment                                              */

/*    NEG  -- negative                                                       */

/*    ABS  -- absolute value                                                 */

/*    SQR  -- square                                                         */

/*    INV  -- inverse (1/x)                                                  */

/*    ADD  -- plus                                                           */

/*    SUB  -- subtract                                                       */

/*    MPY  -- multiply                                                       */

/*    DIV  -- division                                                       */

/*    EQL  -- ==                                                             */

/*    NEQ  -- !=                                                             */

/*    GTR  -- >                                                              */

/*    GEQ  -- >=                                                             */

/*    LSS  -- <                                                              */

/*    LEQ  -- <=                                                             */

/*    EQZ  -- == 0.0                                                         */

/*    NEZ  -- != 0.0                                                         */

/*    GTZ  -- >  0.0                                                         */

/*    GEZ  -- >= 0.0                                                         */

/*    LSZ  -- <  0.0                                                         */

/*    LEZ  -- <= 0.0                                                         */

/* F means REAL                                                              */

/* If no 1,2 or 3 suffix then is function returning result.                  */

/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */

/*    1 -> right = operation right;                                          */

/*    2 -> dst   = operation right;      ( unary operations)                 */

/*         left  = left operation right; (binary operations)                 */

/*    3 -> dst   = left operation right;                                     */

/*---------------------------------------------------------------------------*/

#endif



#define CPYF(dst,right) dst=(right)



#define NEGF(right) (-(right))

#define ABSF(right) (LSSF(right,ZERO) ? NEGF(right) : (right))

#define SQRF(right) ((right) * (right))

#define INVF(right) DIVF(ONE,right)



#define ADDF(left,right) ((left)+(right))

#define SUBF(left,right) ((left)-(right))

#define MPYF(left,right) ((left)*(right))

#define DIVF(left,right) ((left)/(right))



#define NEGF2(dst,right) dst=(-(right))

#define ABSF2(dst,right) dst=(LSSF(right,ZERO)?NEGF(right):(right))

#define SQRF2(dst,right) dst=(right)*(right)

#define INVF2(dst,right) dst=INVF(right)



#define ADDF3(dst,left,right) dst=(left)+(right)

#define SUBF3(dst,left,right) dst=(left)-(right)

#define MPYF3(dst,left,right) dst=(left)*(right)

#define DIVF3(dst,left,right) dst=(left)/(right)



#define NEGF1(right) (right)=-(right)

#define ABSF1(right) if LSSF(right,ZERO) NEGF1(right)

#define SQRF1(right) (right)*=(right)

#define INVF1(right) (right)=INVF(right)



#define ADDF2(left,right) (left)+=(right)

#define SUBF2(left,right) (left)-=(right)

#define RSBF2(left,right) (left) =(right)-(left)

#define MPYF2(left,right) (left)*=(right)

#define DIVF2(left,right) (left)/=(right)



#define CMPF(left,right) ((left)<(right)?-1:((left)!=(right)))

#define CMPF3(dst,left,right) dst=CMPF(left,right)



#define EQLF(left,right) ((left)==(right))

#define NEQF(left,right) ((left)!=(right))

#define LEQF(left,right) ((left)<=(right))

#define GEQF(left,right) ((left)>=(right))

#define GTRF(left,right) ((left)>(right))

#define LSSF(left,right) ((left)<(right))



#define EQZF(left) EQLF(left,ZERO)

#define NEZF(left) NEQF(left,ZERO)

#define LEZF(left) LEQF(left,ZERO)

#define GEZF(left) GEQF(left,ZERO)

#define GTZF(left) GTRF(left,ZERO)

#define LSZF(left) LSSF(left,ZERO)







#if 0

/*---------------------------------------------------------------------------*/

/* Compose and Decompose REAL                                                */

/* integer <-> REAL conversion operations                                    */

/* REAL whole number conversions                                             */

/* REAL whole number conversions, caller KNOWS whole number fits in int      */

/* Exact Remainder                                                           */

/*---------------------------------------------------------------------------*/

/* Names have form: <operation> F { 1 | 2 | 3 }?                             */

/* Where <operation> is one of:                                              */

/*    SCL  -- f * RADIX**e                                                   */

/*    RIP  -- decompose x into f,e such that x == f*RADIX**e and 1/RADIX<=f<1*/

/*                                                                           */

/*    FIX  -- truncate towards zero and convert to int                       */

/*    FLT  -- convert int  to REAL                                           */

/*                                                                           */

/*    TNC  -- truncate towards 0                (x fits in int)              */

/*    RND  -- round to nearest whole number REAL(x fits in int)              */

/*    FLR  -- truncate towards minus infinity   (x fits in int)              */

/*    CEI  -- truncate towards plus  infinity   (x fits in int)              */

/*                                                                           */

/*    REM  -- *EXACT* remainder (big horrible by-hand divide routine)        */

/*                                                                           */

/* Note that the following whole number approximation rtns exist in math.h:  */

/*    TRUNCF -- truncate towards 0                (x any value)              */

/*    ROUNDF -- round to nearest whole number REAL(x any value)              */

/*    FLOORF -- truncate towards minus infinity   (x any value)              */

/*    CEILF  -- truncate towards plus  infinity   (x any value)              */

/*                                                                           */

/* F means REAL                                                              */

/* If no 1,2 or 3 suffix then is function returning result.                  */

/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */

/*    1 -> right = operation right;                                          */

/*    2 -> dst   = operation right;      ( unary operations)                 */

/*         left  = left operation right; (binary operations)                 */

/*    3 -> dst   = left operation right;                                     */

/*---------------------------------------------------------------------------*/

#endif



#define RIPF(x,f,e) f=FREXPF((x),&e)



#define SCLF(f,e)            LDEXPF((f),(e))

#define SCLF2(f,e)       f = LDEXPF((f),(e))

#define SCLF3(dst,f,e) dst = LDEXPF((f),(e))



#define FIXFC(x) ((char)(x))

#define FLTCF(x) ((REAL)(x))



#define FIXFB(x) ((unsigned char)(x))

#define FLTBF(x) ((REAL)(x))



#define FIXFSI(x) ((short)(x))

#define FLTSIF(x) ((REAL)(x)) 



#define FIXFUS(x) ((unsigned short)(x))

#define FLTUSF(x) ((REAL)(x))



#define FIXFI(x) ((int)(x))

#define FLTIF(x) ((REAL)(x))



#define FIXFU(x) ((unsigned)(x))

#define FLTUF(x) ((REAL)(x))



#define FIXFLI(x) ((long)(x))

#define FLTLIF(x) ((REAL)(x))



#define FIXFUL(x) ((unsigned long)(x))

#define FLTULF(x) ((REAL)(x))



#if 0

/* TNCF, RNDF, FLRF, CEIF, may all use FLTIF(FIXFI(f(x))).                */

/* Call sites must be sure to enforce several rules:                      */

/* 1. TRUNCF(f(x)) must not exceed the integer range.                     */

/* 2. if REAL does unbiased round-towards-even,                           */

/*    input x to RNDF must never equal +/- RADIX_to_Mantissa-1.           */

#endif

#ifndef RND_GLITCH

   #error "REAL format .h file must be included before REAL syntax .h file"

#endif

#if (RND_GLITCH)

   #define RND_MAX_P1 RND_P_GLITCH

   #define RND_MIN    RND_M_GLITCH

#else

   #define RND_MAX_P1 INT_MOST_POS_P1

   #define RND_MIN    INT_MOST_NEG

#endif

#ifndef FLT_FIX_Faster_Than_MODF

   #error "target props .h file must be included before REAL syntax .h file"

#endif

#if (FLT_FIX_Faster_Than_MODF)

   #define TNCF(x) (FLTIF(FIXFI(x)))



   #define RNDF(x) (GEZF(x)? \

                    FLTIF(FIXFI((ADDF((x),HALF)))) : \

                    FLTIF(FIXFI((SUBF((x),HALF)))))



   #define FLRF(x) (GEZF(x) ? \

                    (FLTIF(FIXFI(x))) : \

                     (EQLF(x,FLTIF(FIXFI(x))) ? \

                      x : \

                      (FLTIF(NEGF(FIXFI(ADDF(NEGF(x),ONE)))))))



   #define CEIF(x) (LEZF(x) ? \

                    (FLTIF(FIXFI(x))) : \

                     (EQLF(x,FLTIF(FIXFI(x))) ? \

                      x : \

                      (FLTIF(NEGF(FIXFI(SUBF(NEGF(x),ONE)))))))



#else /*  call through to general purpose routines*/

   #define TNCF(x) (TRUNCF(x))

   #define RNDF(x) (ROUNDF(x))

   #define FLRF(x) (FLOORF(x))

   #define CEIF(x) (CEILF(x))

#endif



#define FIXFI1(x) x=FIXFI(x)

#define FLTIF1(x) x=FLTIF(x)

#define FIXFU1(x) x=FIXFU(x)

#define FLTUF1(x) x=FLTUF(x)



#define TNCF1(x) x=TNCF(x)

#define RNDF1(x) x=RNDF(x)

#define FLRF1(x) x=FLRF(x)

#define CEIF1(x) x=CEIF(x)



#define FIXFI2(dst,right) dst=FIXFI(right)

#define FLTIF2(dst,right) dst=FLTIF(right)

#define FIXFU2(dst,right) dst=FIXFU(right)

#define FLTUF2(dst,right) dst=FLTUF(right)



#define TNCF2(dst,right) dst=TNCF(right)

#define RNDF2(dst,right) dst=RNDF(right)

#define FLRF2(dst,right) dst=FLRF(right)

#define CEIF2(dst,right) dst=CEIF(right)





#define REMF(right,left)           (FMODF(right,left))

#define REMF1(right,left)     right=FMODF(right,left)

#define REMF2(dst,right,left) dst  =FMODF(right,left)



#if 0

/*---------------------------------------------------------------------------*/

/* IEEE software support specific routines                                   */

/*---------------------------------------------------------------------------*/

#endif

#ifdef LEAN

#define GROWF(x) ((REAL)(x)) /*  grow from LEAN to REAL*/

#define SLIMF(x) ((LEAN)(x)) /*  slim from REAL to LEAN*/

#endif





#if 0

/*---------------------------------------------------------------------------*/

/* Polynomial evaluation loops macros.                                       */

/*---------------------------------------------------------------------------*/

/* Loops are used for all polynomials.  It is assumed that this              */

/* is more DSP-friendly given that DSP hardware/software has:                */

/*   . zero-overhead looping,                                                */

/*   . optimizations to software pipeline multiply-accumulate,               */

/*   . the lack of full-precision floating-immediate address mode,           */

/*   . relatively expensive fetch of non-tabular constants,                  */

/*   . the existance of auto-increment addressing for table access.          */

/*---------------------------------------------------------------------------*/



/* form of: r=(((K[0]*x + K[1])*x + K[2])*x); r not same as x */

#endif

#define POLYF(r,x,K,s) {int i; REAL *p=K;                             \

                        MPYF3(r,x,*p++);                              \

                        for (i=s-1; i>0; i--) MPYF3(r,x,ADDF(r,*p++));}



#if 0

/* extra add at the end */

/* form of: r=(((K[0]*x + K[1])*x + K[2])*x) + K[3];  r not same as x */

#endif

#define POLYaF(r,x,K,s) {int i; REAL *p=K;                             \

                         MPYF3(r,x,*p++);                              \

                         for (i=s-2; i>0; i--) MPYF3(r,x,ADDF(r,*p++));\

                         ADDF2(r,*p++);}



#if 0

/* form of: r=((K[0]+x)*x + K[1])*x + K[2]) * x) + K[3]; r not same as x */

#endif

#define POLYbF(r,x,K,s) {int i; REAL *p=K;                             \

                         ADDF3(r,x,*p++);                              \

                         for (i=s-1; i>0; i--) ADDF3(r,*p++,MPYF(x,r));}



#if 0

/*---------------------------------------------------------------------------*/

/* Bind The Names Of The Math Library Routines                               */

/*---------------------------------------------------------------------------*/

#endif

#define SQRTF(x)    sqrt(x)

#define RSQRTF(x)   rsqrt(x)

#define EXPF(x)     exp(x)

#define EXP2F(x)    exp2(x)

#define EXP10F(x)   exp10(x)

#define LOGF(x)     log(x)

#define LOG2F(x)    log2(x)

#define LOG10F(x)   log10(x)

#define POWF(x,y)   pow(x,y)

#define POWIF(x,i)  powi(x,i)

#define SINF(x)     sin(x)

#define COSF(x)     cos(x)

#define TANF(x)     tan(x)

#define COTF(x)     cot(x)

#define ASINF(x)    asin(x)

#define ACOSF(x)    acos(x)

#define ATANF(x)    atan(x)

#define ATAN2F(y,x) atan2(y,x)

#define ACOTF(x)    acot(x)

#define ACOT2F(x,y) acot2(x,y)

#define SINHF(x)    sinh(x)

#define COSHF(x)    cosh(x)

#define TANHF(x)    tanh(x)

#define COTHF(x)    coth(x)

#define ASINHF(x)   asinh(x)

#define ACOSHF(x)   acosh(x)

#define ATANHF(x)   atanh(x)

#define ACOTHF(x)   acoth(x)



#define CEILF(x)    ceil(x)

#define FLOORF(x)   floor(x)

#define TRUNCF(x)   _trunc(x)

#define ROUNDF(x)   _nround(x)



#define FABSF(x)    fabs(x)



#define LDEXPF(x,n)   ldexp(x,n)

#define FREXPF(x,exp) frexp(x,exp)

#define MODFF(x,ip)   modf(x,ip)

#define FMODF(x,y)    fmod(x,y)



#endif /* __syntd_*/

syntdi.h/       1148595159  0     0     0       16388     `
/****************************************************************************/

/*  syntdi.h         v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:57:24 CDT 2000 */

 

#ifndef __syntd__

#define __syntd__



#if 0

/*---------------------------------------------------------------------------*/

/* Bind abstract REAL to "double" syntax.                                    */

/* Use ANSI-style function calls for IEEE +,-,*,/, >,<,>=,<=,==,!=, =        */

/* Use d-suffix names for experimental math.h routines (sqrtd, sind, ... etc)*/

/*---------------------------------------------------------------------------*/

#endif



#define REAL double

#define EXPONENT_TYPE int



#if BPLEAN == 0

   #undef LEAN

#else /*  since REAL is "double", assume next smallest is "float"*/

   #define LEAN float

#endif



#define CNST(x) (x)  /*  constants within statements*/

#define TSNC

#define KNST(x) x    /*  constants within tables    */

#define TSNK



#include "numconst.h" /*  NUMerical CONSTants used by some definitions below*/



#if 0

/*---------------------------------------------------------------------------*/

/* Define Compiler Syntax For Basic Operations                               */

/*---------------------------------------------------------------------------*/

/* Names have form: <operation> F { 1 | 2 | 3 }?                             */

/* Where <operation> is one of:                                              */

/*    CPY  -- simple assignment                                              */

/*    NEG  -- negative                                                       */

/*    ABS  -- absolute value                                                 */

/*    SQR  -- square                                                         */

/*    INV  -- inverse (1/x)                                                  */

/*    ADD  -- plus                                                           */

/*    SUB  -- subtract                                                       */

/*    MPY  -- multiply                                                       */

/*    DIV  -- division                                                       */

/*    EQL  -- ==                                                             */

/*    NEQ  -- !=                                                             */

/*    GTR  -- >                                                              */

/*    GEQ  -- >=                                                             */

/*    LSS  -- <                                                              */

/*    LEQ  -- <=                                                             */

/*    EQZ  -- == 0.0                                                         */

/*    NEZ  -- != 0.0                                                         */

/*    GTZ  -- >  0.0                                                         */

/*    GEZ  -- >= 0.0                                                         */

/*    LSZ  -- <  0.0                                                         */

/*    LEZ  -- <= 0.0                                                         */

/* F means REAL                                                              */

/* If no 1,2 or 3 suffix then is function returning result.                  */

/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */

/*    1 -> right = operation right;                                          */

/*    2 -> dst   = operation right;      ( unary operations)                 */

/*         left  = left operation right; (binary operations)                 */

/*    3 -> dst   = left operation right;                                     */

/*---------------------------------------------------------------------------*/

#endif



#define CPYF(dst,right) dst=(right)



#define NEGF(right) _negd(right)

#define ABSF(right) _absd(right)

#define SQRF(right) MPYF(right,right)

#define INVF(right) DIVF(ONE,right)



#define ADDF(left,right) _addd(left,right)

#define SUBF(left,right) _subd(left,right)

#define MPYF(left,right) _mpyd(left,right)

#define DIVF(left,right) _divd(left,right)



#define NEGF2(dst,right) dst=NEGF(right)

#define ABSF2(dst,right) dst=ABSF(right)

#define SQRF2(dst,right) dst=MPYF(right,right)

#define INVF2(dst,right) dst=INVF(right)



#define ADDF3(dst,left,right) dst=ADDF(left,right)

#define SUBF3(dst,left,right) dst=SUBF(left,right)

#define MPYF3(dst,left,right) dst=MPYF(left,right)

#define DIVF3(dst,left,right) dst=DIVF(left,right)



#define NEGF1(right) (right)=NEGF(right)

#define ABSF1(right) (right)=ABSF(right)

#define SQRF1(right) (right)=MPYF(right,right)

#define INVF1(right) (right)=INVF(right)



#define ADDF2(left,right) (left)=ADDF(left,right)

#define SUBF2(left,right) (left)=SUBF(left,right)

#define RSBF2(left,right) (left)=SUBF(right,left)

#define MPYF2(left,right) (left)=MPYF(left,right)

#define DIVF2(left,right) (left)=DIVF(left,right)



#define EQLF(left,right) (_eqld(left,right))

#define NEQF(left,right) (_neqd(left,right))

#define LEQF(left,right) (_leqd(left,right))

#define GEQF(left,right) (_geqd(left,right))

#define LSSF(left,right) (_lssd(left,right))

#define GTRF(left,right) (_gtrd(left,right))



#define CMPF(left,right) _cmpd(left,right) /*  <0 if LT, 0 if EQ, >0 if GT*/

#define CMPF3(dst,left,right) dst=CMPF(left,right)



#define EQZF(left) EQLF(left,ZERO)

#define NEZF(left) NEQF(left,ZERO)

#define LEZF(left) LEQF(left,ZERO)

#define GTZF(left) GTRF(left,ZERO)



   #define GEZF(left) GEQF(left,ZERO)

   #define LSZF(left) LSSF(left,ZERO)



#if 0

/*---------------------------------------------------------------------------*/

/* Compose and Decompose REAL                                                */

/* integer <-> REAL conversion operations                                    */

/* REAL whole number conversions, caller KNOWS whole number fits in int      */

/* Exact Remainder                                                           */

/*---------------------------------------------------------------------------*/

/* Names have form: <operation> F { 1 | 2 | 3 }?                             */

/* Where <operation> is one of:                                              */

/*    SCL  -- f * RADIX**e                                                   */

/*    RIP  -- decompose x into f,e such that x == f*RADIX**e and 1/RADIX<=f<1*/

/*                                                                           */

/*    FIX  -- truncate towards zero and convert to int                       */

/*    FLT  -- convert int  to REAL                                           */

/*    FIXU -- truncate towards zero and convert to unsigned int              */

/*    FLTU -- convert unsigned int  to REAL                                  */

/*                                                                           */

/*    TNC  -- truncate towards 0                (x fits in int)              */

/*    RND  -- round to nearest whole number REAL(x fits in int)              */

/*    FLR  -- truncate towards minus infinity   (x fits in int)              */

/*    CEI  -- truncate towards plus  infinity   (x fits in int)              */

/*                                                                           */

/*    REM  -- *EXACT* remainder (big horrible by-hand divide routine)        */

/*                                                                           */

/* Note that the following whole number approximation rtns exist in math.h:  */

/*    TRUNCF -- truncate towards 0                (x any value)              */

/*    ROUNDF -- round to nearest whole number REAL(x any value)              */

/*    FLOORF -- truncate towards minus infinity   (x any value)              */

/*    CEILF  -- truncate towards plus  infinity   (x any value)              */

/*                                                                           */

/* F means REAL                                                              */

/* If no 1,2 or 3 suffix then is function returning result.                  */

/* Optional 1,2 or 3 means 1-addr, 2-addr or 3-addr version:                 */

/*    1 -> right = operation right;                                          */

/*    2 -> dst   = operation right;      ( unary operations)                 */

/*         left  = left operation right; (binary operations)                 */

/*    3 -> dst   = left operation right;                                     */

/*---------------------------------------------------------------------------*/

#endif



#define RIPF(x,f,e) f=FREXPF((x),&e)



#define SCLF(f,e)            LDEXPF((f),(e))

#define SCLF2(f,e)       f = LDEXPF((f),(e))

#define SCLF3(dst,f,e) dst = LDEXPF((f),(e))



#define FIXFC(x) _fixdc(x) /* ((char)(x))   */

#define FLTCF(x) _fltcd(x) /* ((REAL)(x))   */



#define FIXFB(x) _fixdb(x) /* ((unsigned char)(x)*/

#define FLTBF(x) _fltbd(x) /* ((REAL)(x))       */



#define FIXFSI(x) _fixdsi(x) /* ((short)(x))  */

#define FLTSIF(x) _fltsid(x) /* ((REAL)(x))   */



#define FIXFUS(x) _fixdus(x) /* ((unsigned short)(x)*/

#define FLTUSF(x) _fltusd(x) /* ((REAL)(x))         */



#define FIXFI(x) _fixdi(x) /* ((int)(x))    */

#define FLTIF(x) _fltid(x) /* ((REAL)(x))   */



#define FIXFU(x) _fixdu(x) /* ((unsigned)(x)*/

#define FLTUF(x) _fltud(x) /* ((REAL)(x))   */



#define FIXFLI(x) _fixdli(x) /* ((long)(x))   */

#define FLTLIF(x) _fltlid(x) /* ((REAL)(x))   */



#define FIXFUL(x) _fixdul(x) /* ((unsigned long)(x)*/

#define FLTULF(x) _fltuld(x) /* ((REAL)(x))        */



#if 0

/* TNCF, RNDF, FLRF, CEIF, may all use FLTIF(FIXFI(f(x))).                */

/* Call sites must be sure to enforce several rules:                      */

/* 1. TRUNCF(f(x)) must not exceed the integer range.                     */

/* 2. if REAL does unbiased round-towards-even,                           */

/*    input x to RNDF must never equal +/- RADIX_to_Mantissa-1.           */

#endif

#ifndef RND_GLITCH

   #error "REAL format .h file must be included before REAL syntax .h file"

#endif

#if (RND_GLITCH)

   #define RND_MAX_P1 RND_P_GLITCH

   #define RND_MIN    RND_M_GLITCH

#else

   #define RND_MAX_P1 INT_MOST_POS_P1

   #define RND_MIN    INT_MOST_NEG

#endif

#ifndef FLT_FIX_Faster_Than_MODF

   #error "target props .h file must be included before REAL syntax .h file"

#endif

#if (FLT_FIX_Faster_Than_MODF)

   #define TNCF(x) (FLTIF(FIXFI(x)))



   #define RNDF(x) (GEZF(x)? \

                    FLTIF(FIXFI((ADDF((x),HALF)))) : \

                    FLTIF(FIXFI((SUBF((x),HALF)))))



   #define FLRF(x) (GEZF(x) ? \

                    (FLTIF(FIXFI(x))) : \

                     (EQLF(x,FLTIF(FIXFI(x))) ? \

                      x : \

                      (FLTIF(NEGF(FIXFI(ADDF(NEGF(x),ONE)))))))



   #define CEIF(x) (LEZF(x) ? \

                    (FLTIF(FIXFI(x))) : \

                     (EQLF(x,FLTIF(FIXFI(x))) ? \

                      x : \

                      (FLTIF(NEGF(FIXFI(SUBF(NEGF(x),ONE)))))))



#else /*  call through to general purpose routines*/

   #define TNCF(x) (TRUNCF(x))

   #define RNDF(x) (ROUNDF(x))

   #define FLRF(x) (FLOORF(x))

   #define CEIF(x) (CEILF(x))

#endif



#define FIXFI1(x) x=FIXFI(x)

#define FLTIF1(x) x=FLTIF(x)

#define FIXFU1(x) x=FIXFU(x)

#define FLTUF1(x) x=FLTUF(x)



#define TNCF1(x) x=TNCF(x)

#define RNDF1(x) x=RNDF(x)

#define FLRF1(x) x=FLRF(x)

#define CEIF1(x) x=CEIF(x)



#define FIXFI2(dst,right) dst=FIXFI(right)

#define FLTIF2(dst,right) dst=FLTIF(right)

#define FIXFU2(dst,right) dst=FIXFU(right)

#define FLTUF2(dst,right) dst=FLTUF(right)



#define TNCF2(dst,right) dst=TNCF(right)

#define RNDF2(dst,right) dst=RNDF(right)

#define FLRF2(dst,right) dst=FLRF(right)

#define CEIF2(dst,right) dst=CEIF(right)





#define REMF(right,left)           (FMODF(right,left))

#define REMF1(right,left)     right=FMODF(right,left)

#define REMF2(dst,right,left) dst  =FMODF(right,left)





#if 0

/*---------------------------------------------------------------------------*/

/* IEEE software support specific routines                                   */

/*---------------------------------------------------------------------------*/

#endif

#if (BPREAL == BPbigint)

   #define FRCMPYF(l,r) _frcmpyd(l,r)

   #define FRCDIVF(l,r) _frcdivd(l,r)

#elif (BPREAL == (BPbigint*2))

   #define RENORMF(x) renormd(x)

   #define FRCADDF(lx,lf,rx,rf) _frcaddd(lx,lf,rx,rf)

   #define FRCMPYF(p,l,r) _frcmpyd(p,l,r)

   #define FRCDIVF(q,l,r) _frcdivd(q,l,r)

#else

   #error "IEEE lowest-level support routines NYI for this size REAL"

#endif

#ifdef LEAN

#define GROWF(x) _cvtfd(x) /*  grow from LEAN to REAL*/

#define SLIMF(x) _cvtdf(x) /*  slim from REAL to LEAN*/

#endif



#if 0

/*---------------------------------------------------------------------------*/

/* Polynomial evaluation loops macros.                                       */

/*---------------------------------------------------------------------------*/

/* Loops are used for all polynomials.  It is assumed that this              */

/* is more DSP-friendly given that DSP hardware/software has:                */

/*   . zero-overhead looping,                                                */

/*   . optimizations to software pipeline multiply-accumulate,               */

/*   . the lack of full-precision floating-immediate address mode,           */

/*   . relatively expensive fetch of non-tabular constants,                  */

/*   . the existance of auto-increment addressing for table access.          */

/*---------------------------------------------------------------------------*/



/* form of: r=(((K[0]*x + K[1])*x + K[2])*x); r not same as x */

#endif

#define POLYF(r,x,K,s) {int i; REAL *p=K;                             \

                        MPYF3(r,x,*p++);                              \

                        for (i=s-1; i>0; i--) MPYF3(r,x,ADDF(r,*p++));}



#if 0

/* extra add at the end */

/* form of: r=(((K[0]*x + K[1])*x + K[2])*x) + K[3];  r not same as x */

#endif

#define POLYaF(r,x,K,s) {int i; REAL *p=K;                             \

                         MPYF3(r,x,*p++);                              \

                         for (i=s-2; i>0; i--) MPYF3(r,x,ADDF(r,*p++));\

                         ADDF2(r,*p++);}



#if 0

/* form of: r=((x+K[0])*x + K[1])*x + K[2]) * x) + K[3]; r not same as x */

#endif

#define POLYbF(r,x,K,s) {int i; REAL *p=K;                             \

                         ADDF3(r,x,*p++);                              \

                         for (i=s-1; i>0; i--) ADDF3(r,*p++,MPYF(x,r));}



#if 0

/*---------------------------------------------------------------------------*/

/* Bind The Names Of The Math Library Routines                               */

/*---------------------------------------------------------------------------*/

#endif

#define SQRTF(x)    sqrt(x)

#define RSQRTF(x)   rsqrt(x)

#define EXPF(x)     exp(x)

#define EXP2F(x)    exp2(x)

#define EXP10F(x)   exp10(x)

#define LOGF(x)     log(x)

#define LOG2F(x)    log2(x)

#define LOG10F(x)   log10(x)

#define POWF(x,y)   pow(x,y)

#define POWIF(x,i)  powi(x,i)

#define SINF(x)     sin(x)

#define COSF(x)     cos(x)

#define TANF(x)     tan(x)

#define COTF(x)     cot(x)

#define ASINF(x)    asin(x)

#define ACOSF(x)    acos(x)

#define ATANF(x)    atan(x)

#define ATAN2F(y,x) atan2(y,x)

#define ACOTF(x)    acot(x)

#define ACOT2F(x,y) acot2(x,y)

#define SINHF(x)    sinh(x)

#define COSHF(x)    cosh(x)

#define TANHF(x)    tanh(x)

#define COTHF(x)    coth(x)

#define ASINHF(x)   asinh(x)

#define ACOSHF(x)   acosh(x)

#define ATANHF(x)   atanh(x)

#define ACOTHF(x)   acoth(x)



#define CEILF(x)    ceil(x)

#define FLOORF(x)   floor(x)

#define TRUNCF(x)   _trunc(x)

#define ROUNDF(x)   _nround(x)



#define FABSF(x)    fabs(x)



#define LDEXPF(x,n)   ldexp(x,n)

#define FREXPF(x,exp) frexp(x,exp)

#define MODFF(x,ip)   modf(x,ip)

#define FMODF(x,y)    fmod(x,y)



#endif /* __syntd_*/

tan.c/          1148595159  0     0     0       2290      `
/****************************************************************************/

/*  tan.c            v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:56 CDT 2000 */

 

#include "reald.h"



  REAL TANF(REAL x)

{

/* Adapted from "Software Manual for the Elementary Functions" */

/* Cody and Waite, Prentice Hall 1980. pages 150-163           */



    static  REAL P[1] =

       {KNST(-0.958017723e-1)};



    static  REAL Q[2] =

       {KNST( 0.971685835e-2),

        KNST(-0.429135777e+0)};



    REAL y, xn, f, g, x1, xnum, xden;

    int n;



    ABSF2(y, x);

    MPYF3(xn, x, Two_Over_Pi);



    if GEQF(y, CNST( 2147483648.0) )



    {

       REAL ip;

       CPYF(xn,ROUNDF(xn));

       n = NEZF(MODFF(MPYF(xn,HALF),&ip)); /* n holds 0 or 1 */

       CPYF(x1,TRUNCF(x));

    } 

    else 

    {

       if GEZF(xn) FIXFI2(n,(ADDF(xn,HALF)));

       else        FIXFI2(n,(SUBF(xn,HALF)));

       FLTIF2(xn, n);

       TNCF2(x1, x);

    }



    /* f  = ((x1 - xn * C1) + (x - x1)) - xn * C2; */

    SUBF3(f, ADDF(SUBF(x1,MPYF(xn,CNST(1.5703125) )), SUBF(x,x1)), MPYF(xn,CNST(4.83826794897e-4) ));



    /* protect against round-off and enhanced precision problems */

    if GTRF(ABSF(f), Pi_Over_Four)

       f = (GTZF(f) ? Pi_Over_Four : NEGF(Pi_Over_Four));



    SQRF2(g,f);



    /* xnum = ((                P1)*g*f + f); */

    /* xnum = (((       P2)*g + P1)*g*f + f); */

    /* xnum = (((P3*g + P2)*g + P1)*g*f + f); */

    POLYF(xnum, g, P, 1 )

    MPYF2(xnum,f);

    ADDF2(xnum,f);



    /* xden = ((((                Q2)*g + Q1)*g + 0.5) + 0.5); */

    /* xden = (((((       Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */

    /* xden = (((((Q4*g + Q3)*g + Q2)*g + Q1)*g + 0.5) + 0.5); */

    POLYF(xden, g, Q, 2 );

    ADDF2(xden,HALF);  /* do not compose these two adds! */

    ADDF2(xden,HALF);



    if ((n & 1) == 0) return      DIVF(xnum, xden);

    if NEZF(xnum)     return NEGF(DIVF(xden, xnum));



    if GTZF(xden) return CNST(-3.402823466E+38) ;

    return CNST( 3.402823466E+38) ;

} /* TANF */

tanh.c/         1148595159  0     0     0       1248      `
/****************************************************************************/

/*  tanh.c           v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Wed Aug  2 15:58:57 CDT 2000 */

 

#include "reald.h"



  REAL TANHF (REAL x)

{

    

    static  REAL P[2] =

      {KNST(-0.3831010665e-2),

       KNST(-0.8237728127e+0)};



    static  REAL Q[1] =

      {KNST( 0.2471319654e+1)};



    REAL g, y, Result;



    ABSF2(y,x);



    if GTRF(y, CNST(0.54930614433405484570) ) 

    {

       if GTRF(y, CNST(9.01091334725) ) 

       {

          if LSZF(x) return M_ONE;

          return ONE;

       }

       SUBF3(Result, HALF,INVF((EXPF(ADDF(y,y)) + ONE)));

       ADDF2(Result, Result);

       if LSZF(x) NEGF1(Result);

       return Result;

    }



    /* probably not needed if underflow turns into 0.0 */

    /* if LSSF(y, RADIX_to_M_Hlf_MANTISSA) return x; */



    SQRF2(g,y);



    POLYF (Result,g,P,2 );

    POLYbF(y,g,Q,1 );

    DIVF2(Result,y);



    return ADDF(x, MPYF(x,Result));

} /* TANHF */

throw.cpp/      1148595159  0     0     0       74003     `
/*****************************************************************************/

/* throw.cpp v#####                                                          */

/* Copyright (c) 1996@%%%% Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Throw processing for exception handling.



*/



#include "basics.h"

#include "runtime.h"

#include "eh.h"

#pragma hdrstop

#include "vec_newdel.h"



#if EXCEPTION_HANDLING



/*** START TI ADD ***/

#if !defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

/*** END TI ADD ***/



/* Structure used to maintain a stack of throws that are currently

   being processed. */

typedef struct a_throw_stack_entry *a_throw_stack_entry_ptr;

typedef struct a_throw_stack_entry {

  a_throw_stack_entry_ptr

		next;

			/* The next stack entry. */

  a_type_info_impl_ptr

		type_info;

			/* Type_Info of the object thrown. */

  a_destructor_ptr

		destructor;

			/* Destructor for the thrown object. */

  an_ETS_flag_set

		flags;

			/* A collection of bits that specify how the

			   additional information about the thrown object. */

  an_ETS_flag_set

		*ptr_flags;

			/* Pointer to an array of ETS flags for multi-level

			   pointers.  NULL for single level pointers, and for

			   ABI versions earlier that 2.41.  Used to implement

			   qualification conversions on multi-level

			   pointers. */

  an_access_flag_string

		access_flags;

			/* A null terminated character string that specifies

			   the accessibility of the base classes.  "y" means

			   that the base class is accessible, "m" means that

			   it is not. */

  void*		object_address;

			/* Pointer to the memory allocated to store

			   the copy of the object. */

  void*		pointer_buffer;

			/* A piece of memory large enough to store a pointer.

			   When a pointer is thrown the pointer may undergo

			   one of several possible conversions including a

			   conversion from a pointer to derived to a pointer

			   to base.  This buffer is used to store the modified

		  	   pointer.  The original pointer must be preserved for

			   use by a rethrow. */

  an_eh_stack_entry_ptr

		nearest_enclosing_try_block;

			/* Pointer to the nearest enclosing try block

			   (that is not currently in a handler) at

			   the point at which the throw was started.

			   This is used to detect abandoned throws. */

  a_throw_stack_entry_ptr

		primary_entry;

			/* If this is a rethrow, points to the throw stack

			   entry of the original throw. */

  unsigned long	use_count;

			/* Present only in primary entries (not rethrows).

			   Represents the number of throw stack entries

			   that are still active that refer to the object. */

  a_byte_boolean

		is_rethrow;

			/* TRUE if this entry represents a rethrow.

		  	   The object_address entry for a rethrow points

			   to an object allocated by a previous throw. */

  a_byte_boolean

		discard_entry;

			/* This field is used during the processing of

			   nested throws.  This flag is set when a stack

			   entry is no longer needed but cannot be freed

			   because an entry higher on the stack has not

			   yet been freed. */

  a_byte_boolean

		dtor_called;

			/* TRUE if the destructor for the object has already

			   been called.  This is only used for entries created

			   by throws that are not rethrows. */

  a_byte_boolean

		in_handler;

			/* TRUE when the object has been passed to a

			   handler.  It is at this point that the

			   object can be rethrown. */

  a_byte_boolean

		object_evaluation_complete;

			/* TRUE when the evaluation of the thrown object has

			   been completed, but before the object has been

			   copied to the EH temporary.  If the copy to the EH

			   temporary is elided, then this flag is set when

			   the execution of __throw begins. */

  a_byte_boolean

		object_copy_complete;

			/* Set to FALSE when __throw_alloc is called and

			   set to TRUE when __throw is called.  This

			   flag indicates that the thrown object has been

			   copied and must be destroyed at some point. */

  a_byte_boolean

		use_access_flags;

			/* TRUE if the access_flags string should be used to

			   determine the accessibility of base classes.

			   The access flag string was originally used for

			   this purpose but was later replaced by static

			   information in the base class specification

			   information.  This flag indicates which access

			   checking method should be used for a given throw. */

  an_eh_stack_entry

		throw_marker;

			/* An EH stack entry for the throw marker to be

			   linked into the EH stack while a given throw

			   is active. */

} a_throw_stack_entry;





/* Structure used to record information about blocks of memory handled

   by the EH memory management routines. */

typedef struct a_mem_block_descr *a_mem_block_descr_ptr;

typedef struct a_mem_block_descr {

  a_mem_block_descr_ptr

		next;

			/* The next stack entry. */

  void*		addr;

			/* Address of the block of memory. */

  a_sizeof_t	size;

			/* Size in bytes of the block of memory. */

  a_sizeof_t	used;

			/* Number of bytes used in the block. */

  a_byte_boolean

		dynamically_allocated;

			/* TRUE if the block of memory was dynamically

			   allocated.  The initial memory block is

			   statically allocated. */

} a_mem_block_descr;





/* Describes a single piece of memory allocated by the EH runtime. */

typedef struct a_mem_allocation *a_mem_allocation_ptr;

typedef struct a_mem_allocation {

  a_mem_allocation_ptr

		next;

			/* The next allocation entry. */

  a_sizeof_t	alloc_size;

			/* Size of the piece of memory.  This is the

			   allocated size including any space needed

			   for alignment not just the requested size. */

  void*		addr;

			/* Address of the memory allocated. */

  a_byte_boolean

		is_mem_block_descr_allocation;

			/* TRUE if this is a memory allocation done

			   to keep track of a memory block description

		           record. */

} a_mem_allocation;



#if ABI_CHANGES_FOR_RTTI

a_byte		MANGLED_NAME_OF_UNIQUE_ID_OF_VOID;

			/* This is used to get the address of the

			   unique ID for the void type for pointer to

			   void* conversions. */

#else /* !ABI_CHANGES_FOR_RTTI */

a_type_info_impl

                MANGLED_NAME_OF_VOID;

			/* This is used to get the address of the

			   type_info for the void type for pointer to

			   void* conversions. */

#endif /* !ABI_CHANGES_FOR_RTTI */





static a_throw_stack_entry_ptr

		curr_throw_stack_entry = NULL;

			/* The pointer to the top of the stack of throw

			   entries. */



static a_mem_block_descr_ptr

		curr_mem_block_descr = NULL;

			/* Pointer to the top of a stack of memory

			   blocks managed by the EH runtime. */



static a_mem_allocation_ptr

		mem_allocation_stack = NULL;

			/* Pointer to the top of a stack of memory

			   allocation entries. */

/*** START TI ADD ***/ 

#if 0

static a_mem_block_descr

		initial_mem_block_descr;

			/* Initial entry pointed to by the memory block

			   stack. */





static union {

  char		memory[EH_MEMORY_ALLOCATION_INCREMENT];

			/* The initial block of memory to be used.  This

			   avoids the need for the EH runtime to do

			   any dynamic memory allocation in most cases. */

  TYPE_WITH_MOST_STRICT_ALIGNMENT

		dummy;

			/* Used to ensure that the memory block is

			   guaranteed to be aligned on an appropriate

			   boundary. */

} initial_mem_block;

#endif

/*** END TI ADD ***/ 



/* Round a given size up to a multiple of MOST_STRICT_ALIGNMENT. */

#define round_size_to_alignment(size)					\

  (((size + MOST_STRICT_ALIGNMENT - 1) / MOST_STRICT_ALIGNMENT) *	\

                                                   MOST_STRICT_ALIGNMENT)



/* The number of bytes needed for a memory block description and any

   required alignment. */

#define NEEDED_FOR_MEM_BLOCK_DESCR \

  round_size_to_alignment(sizeof(a_mem_block_descr))





/* The number of bytes needed for a memory allocation structure and any

   required alignment. */

#define NEEDED_FOR_MEM_ALLOCATION_INFO \

  round_size_to_alignment(sizeof(a_mem_allocation))



/* The number of bytes needed at the end of a memory block to record the

   information needed to allocate a new memory block. */

#define RESERVED_FOR_END_OF_MEM_BLOCK \

  (NEEDED_FOR_MEM_BLOCK_DESCR + NEEDED_FOR_MEM_ALLOCATION_INFO)





/* The number of bytes that must be added to the_ptr to obtain a value

   with suitable alignment.  the_ptr is actually an integer value that

   represents an offset from the base of a block of memory that is known

   to be appropriately aligned. */

#define increment_needed_for_alignment(the_ptr)				\

  (((the_ptr % MOST_STRICT_ALIGNMENT) == 0) ?	\

         0 :								\

         (MOST_STRICT_ALIGNMENT - (the_ptr % MOST_STRICT_ALIGNMENT)))



static void alloc_new_mem_block(a_sizeof_t size);





static void* eh_get_memory(a_sizeof_t	size)

/*

This is a low level routine that just gets a piece of dynamically

allocated memory from the system.   This must get the memory in

a means that will not result in an exception being thrown.

*/

{

  void*		mem_block;



  mem_block = malloc(size);

  /* If we can't get the memory we need, call the terminate routine. */

  if (mem_block == NULL) {

    __call_terminate();

  }  /* if */

  return mem_block;

}  /* eh_get_memory */





static void eh_free_memory(void* ptr)

/*

This is a low level routine that simply frees a piece of dynamically allocated

memory to the system.  This must free the memory in a means that will not

result in an exception being thrown.

*/

{

  free(ptr);

}  /* eh_free_memory */





static void mem_block_descr_init(a_mem_block_descr_ptr mbdp)

/*

Initialize the fields of a memory block description record.

*/

{

  mbdp->next = NULL;

  mbdp->addr = NULL;

  mbdp->size = 0;

  mbdp->used = 0;

  mbdp->dynamically_allocated = FALSE;

}  /* mem_block_descr_init */





static void init_eh_memory_management(void)

/*

Initialize the variables that keep track of memory used by the EH runtime.

*/

{

/*** START TI ADD ***/ 

#if 0   /* Original EDG code */

  /* Initialize the initial memory block description record. */

  mem_block_descr_init(&initial_mem_block_descr);

  initial_mem_block_descr.addr = initial_mem_block.memory;

  initial_mem_block_descr.size = EH_MEMORY_ALLOCATION_INCREMENT;

  initial_mem_block_descr.used = 0;

  initial_mem_block_descr.dynamically_allocated = FALSE;

  curr_mem_block_descr = &initial_mem_block_descr;

#else  /* TI code */

  /* Allocate and initialize the initial memory block description record. */

  a_mem_block_descr_ptr initial_mem_block_descr = 

             (a_mem_block_descr_ptr)eh_get_memory(sizeof(a_mem_block_descr));

  mem_block_descr_init(initial_mem_block_descr);

  initial_mem_block_descr->addr = eh_get_memory(EH_MEMORY_ALLOCATION_INCREMENT);

  initial_mem_block_descr->size = EH_MEMORY_ALLOCATION_INCREMENT;

  initial_mem_block_descr->used = 0;

  initial_mem_block_descr->dynamically_allocated = FALSE;

  curr_mem_block_descr = initial_mem_block_descr;

#endif

/*** END TI ADD ***/

}  /* init_eh_memory_management */





/*

Return the address of the specified character position within the

current memory block.

*/

#define addr_in_mem_block(pos)						\

  (void *)(((char *)curr_mem_block_descr->addr) + pos)





static void* alloc_in_mem_block(a_sizeof_t	      size,

			        a_mem_allocation_ptr* map)

/*

Allocate a memory allocation record and the requested amount of space

in the current memory block.  There must be enough space for the allocation

to succeed and size must be a multiple of MOST_STRICT_ALIGNMENT.

*/

{

  void*			ptr;

  int			used;



  /* Get space from the memory block to store a new memory block description

     an a memory allocation record to describe it. */

  used = curr_mem_block_descr->used;

  *map = (a_mem_allocation_ptr)addr_in_mem_block(used);

  used += NEEDED_FOR_MEM_ALLOCATION_INFO;

  ptr = (void*)addr_in_mem_block(used);

  used += size;

  curr_mem_block_descr->used = used;

  /* Add this memory allocation record to the top of the stack. */

  (*map)->next = mem_allocation_stack;

  (*map)->addr = ptr;

  mem_allocation_stack = *map;

  /* Initialize the other fields of the memory allocation record. */

  (*map)->alloc_size = size;

  (*map)->is_mem_block_descr_allocation = FALSE;

  check_assertion(curr_mem_block_descr->used <= curr_mem_block_descr->used);

  check_assertion(size % MOST_STRICT_ALIGNMENT == 0);

  return ptr;

}  /* alloc_in_mem_block */





static void alloc_new_mem_block(a_sizeof_t	size)

/*

Allocate a new memory block of at least "size" bytes.  Actually,

it must also have enough space for an additional mem_block_descr entry

too.  We actually allocate "size + EH_MEM_ALLOCATION_INCREMENT" bytes since

we know that "size" bytes will immediately be consumed.

*/

{

  void*			mem_block;

  a_mem_allocation_ptr	map;

  a_mem_block_descr_ptr	mpdp;

  a_sizeof_t		new_size;



  /* Adjust the requested size.  The adjusted size is a multiple of the

     memory allocation increment.  If (adjusted_size - size) >

     (memory_allocation_increment * .5) then we allocate an extra

     memory_allocation_increment bytes. */

  new_size = ((size / EH_MEMORY_ALLOCATION_INCREMENT) + 1) *

                                              EH_MEMORY_ALLOCATION_INCREMENT;

  if ((new_size - size) < (EH_MEMORY_ALLOCATION_INCREMENT >>1)) {

    new_size += EH_MEMORY_ALLOCATION_INCREMENT;

  }  /* if */

  size = new_size;

  /* Get space from the memory block to store a new memory block description

     an a memory allocation record to describe it. */

  mpdp = (a_mem_block_descr_ptr)alloc_in_mem_block(NEEDED_FOR_MEM_BLOCK_DESCR,

						   &map);

  map->is_mem_block_descr_allocation = TRUE;

  mem_block = eh_get_memory(size);

  /* Add the new memory block description to the top of the stack. */

  mpdp->next = curr_mem_block_descr;

  curr_mem_block_descr = mpdp;

  /* Initialize the fields of the memory block descriptor. */

  mpdp->addr = mem_block;

  mpdp->size = size;

  mpdp->used = 0;

  mpdp->dynamically_allocated = TRUE;

}  /* alloc_new_mem_block */





static void* eh_alloc_on_stack(a_sizeof_t	size)

/*

Allocate a block of memory on the EH memory stack.

*/

{

  a_mem_allocation_ptr	map;

  int			needed_for_alignment;

  void*			ptr;

  a_sizeof_t		alloc_size;



  /* The memory management system is initialized the first time that

     this routine is called. */

  if (curr_mem_block_descr == NULL) {

    init_eh_memory_management();

  }  /* if */

  /* Determine the number of bytes that must be added to size to ensure

     that the resulting "used" value will be appropriately aligned. */

  needed_for_alignment = increment_needed_for_alignment(size);

  /* Make sure that the current memory block would have enough space

     leftover to allocate the requested space, plus the space needed for

     the memory allocation information plus a new memory block descriptor.

     If not, start the new memory block now. */

  alloc_size = size + needed_for_alignment;

  if ((alloc_size + NEEDED_FOR_MEM_ALLOCATION_INFO +

       curr_mem_block_descr->used +

       RESERVED_FOR_END_OF_MEM_BLOCK) > curr_mem_block_descr->size) {

    alloc_new_mem_block(alloc_size);

  }  /* if */

  ptr = alloc_in_mem_block(alloc_size, &map);

#if DEBUG

  if (__debug_level >= 5) {

    fprintf(__f_debug, "Allocated %lu bytes starting at %p, ending at %p\n",

            (unsigned long)size, (void*)ptr, (void*)(((char *)ptr)+size-1));

  }  /* if */

#endif /* DEBUG */

  return ptr;

}  /* eh_alloc_on_stack */





static void free_in_mem_block(void*	ptr)

/*

Free a block of memory allocated in a memory block.

*/

{

  a_mem_allocation_ptr	map;

  int			used;



  map = mem_allocation_stack;

  mem_allocation_stack = map->next;

  check_assertion(map->addr == ptr);

  used = curr_mem_block_descr->used;

  used -= map->alloc_size;

  used -= NEEDED_FOR_MEM_ALLOCATION_INFO;

  curr_mem_block_descr->used = used;

}  /* free_in_mem_block */





static void eh_free_on_stack(void*	ptr)

/*

Free a piece of memory on the memory stack.  If a memory block becomes

empty then remove it from the stack.

*/

{

  /* Free the memory passed by the caller. */

  free_in_mem_block(ptr);

  /* Is the memory block now empty? */

  if (curr_mem_block_descr->used == 0) {

    if (curr_mem_block_descr->next != NULL) {

      /* Don't free the initial memory block. */

      a_mem_block_descr_ptr	mpdp_to_free;

      mpdp_to_free = curr_mem_block_descr;

      curr_mem_block_descr = mpdp_to_free->next;

      /* Free the memory block.  This is freed to the system -- not just to

         the memory stack like other kinds of memory. */

      if (mpdp_to_free->dynamically_allocated) {

        /* Only free dynamically allocated blocks. */

        eh_free_memory(mpdp_to_free->addr);

      }  /* if */

      /* Free the memory block description entry. */

      free_in_mem_block(mpdp_to_free);

    }  /* if */

  }  /* if */

}  /* eh_free_on_stack */





/* Determine whether the type qualifiers are acceptable.  The thrown type

   may not have more qualifiers than the caught type.  The qualifiers are

   only checked if the thrown type is a pointer. */

#define qualifiers_acceptable(caught_flags, thrown_flags)		\

  ((!is_single_level_pointer(thrown_flags)) || 				\

   (caught_flags & thrown_flags & ETS_QUALIFIERS) ==			\

                                            (thrown_flags & ETS_QUALIFIERS))



#if DEBUG

static void db_eh_region_descr(an_eh_region_descr_ptr  ehrdp)

/*

Print the contents of a region description entry.

*/

{

  if (ehrdp == NULL) {

    fprintf(__f_debug, "  <NULL pointer>\n");

  } else {

    if (ehrdp->flags) {

      fprintf(__f_debug, "  flags: ");

      if (ehrdp->flags & RDF_INDIRECT) fprintf(__f_debug, " indirect");

      if (ehrdp->flags & RDF_NEW_ALLOCATION) fprintf(__f_debug, " new");

      if (ehrdp->flags & RDF_BASE_CLASS_SUBOBJECT) {

        fprintf(__f_debug, " subobject");

        /* The SUBOBJECT_VTABLE and LET_THIS flags share the same bit.

           The meaning depends on the setting of the BASE_CLASS_SUBOBJECT

           flag. */

        if (ehrdp->flags & RDF_SUBOBJECT_VTABLE) {

          fprintf(__f_debug, " subobject vtable");

        }  /* if */

      }  /* if */

      if (ehrdp->flags & RDF_GUARD_VAR_FOR_LOCAL_STATIC) {

        fprintf(__f_debug, " local static guard");

      }  /* if */

    }  /* if */

    fprintf(__f_debug, "  destr/delete=%p\n",

            (void*)(unsigned long)ehrdp->destructor_or_delete_routine);

#if 0

    if (ehrdp->array_size != 0) {

      fprintf(__f_debug, "  array_size=%ld\n", ehrdp->array_size);

    }  /* if */

#endif /* 0 */

    fprintf(__f_debug, "  handle=%d\n", ehrdp->handle);

    fprintf(__f_debug, "  next region=%d\n", ehrdp->index_of_next_region);

  }  /* if */

} /* db_eh_region_descr */





static void db_throw_stack_entry(a_throw_stack_entry_ptr tsep)

{

  fprintf(__f_debug, "typinfo=%p ", (void*)tsep->type_info);

  fprintf(__f_debug, "flags=%0x ", tsep->flags);

  fprintf(__f_debug, "object_address=%p ", (void*)tsep->object_address);

  if (tsep->is_rethrow) {

    fprintf(__f_debug, "is_rethrow=%0d ", tsep->is_rethrow);

  }  /* if */

  if (tsep->discard_entry) {

    fprintf(__f_debug, "discard_entry=%0d ", tsep->discard_entry);

  }  /* if */

  if (tsep->dtor_called) {

    fprintf(__f_debug, "dtor_called=%0d ", tsep->dtor_called);

  }  /* if */

  if (tsep->in_handler) {

    fprintf(__f_debug, "in_handler=%0d ", tsep->in_handler);

  }  /* if */

  if (tsep->use_count != 0) {

    fprintf(__f_debug, "use_count=%0lu ", tsep->use_count);

  }  /* if */

  if (tsep->primary_entry != NULL) {

    fprintf(__f_debug, "primary_entry=%p ", tsep->primary_entry);

  }  /* if */

}  /* db_throw_stack_entry */





static void db_throw_stack(char* str)

{

  a_throw_stack_entry_ptr	tsep = curr_throw_stack_entry;

  int				count = 0;



  fprintf(__f_debug, "Throw stack %s:\n", str);

  while (tsep != NULL) {

    fprintf(__f_debug, "  Entry %0d at %p: ", count++, tsep);

    db_throw_stack_entry(tsep);

    fprintf(__f_debug, "\n");

    tsep = tsep->next;

  }  /* while */

}  /* db_throw_stack */

#endif /* DEBUG */





static void cleanup(an_eh_stack_entry_ptr ehsep,

                    a_region_number       region,

		    a_region_number	  stop_at_region)

/*

Do the cleanup operations required in the function described by ehsep.

The current region number within ehsep is designated by region.  Cleanup

processing stops when we reach the region designated by stop_at_region.

Normally this is NULL_REGION_NUMBER but may have another value when

doing a partial cleanup as is done when an object in a try block

requires cleanup.

*/

{

  an_object_ptr	                *obj_addr_array;

  an_eh_region_descr_ptr	ehrdp;

  obj_addr_array = ehsep->variant.function.object_address_table;

  for (; region != stop_at_region; region = ehrdp->index_of_next_region) {

    an_object_ptr	        obj_addr;

    a_conditional_flag*	        flag_addr = NULL;

    char			*temp_addr;

    a_region_descr_flag_set     flags;

    an_eh_array_supplement_ptr	ehasp = NULL;

    void			*vtbl_ptr = NULL;



    ehrdp = &ehsep->variant.function.regions[region];

#if DEBUG

    if (__debug_level >= 2) {

      fprintf(__f_debug, "Region: %d, descr address=%p\n", region,

              (void*)ehrdp);

      db_eh_region_descr(ehrdp);

    }  /* if */

#endif /* DEBUG */

    flags = ehrdp->flags;

    if (flags & RDF_CONDITIONAL_FLAG) {

      /* This cleanup action is conditional.  The next region entry

         contains a handle that points to the flag.  Check the flag and

         only process this entry if it is TRUE. */

#if 0

      /* The following line needs to be modified when stack offsets are

	 being used instead of an object address array. */

#endif /* 0 */

      /* The object information is pointed to directly by the region entry. */

      flag_addr = (a_conditional_flag*)*(obj_addr_array + (ehrdp + 1)->handle);

#if DEBUG

      if (__debug_level >= 2) {

        fprintf(__f_debug, "  Conditional flag=%0d\n", *flag_addr);

      }  /* if */

#endif /* DEBUG */

      /* Skip processing of this entry if the flag is not set. */

      if (!*flag_addr) continue;

    }  /* if */

    if ((flags & RDF_SUBOBJECT_VTABLE) != 0 &&

        (flags & RDF_BASE_CLASS_SUBOBJECT) != 0) {

      /* This is a subobject destruction that has a special vtable pointer

         that is to be used.  The next region table entry contains a handle

         that points to the vtable address to be used.  If there is a

         conditional flag, the handle is in the region table entry after

         the conditional flag. */

      an_eh_region_descr_ptr	vtbl_ehrdp;

      vtbl_ehrdp = ehrdp + 1;

      if (flag_addr != NULL) vtbl_ehrdp++;

#if 0

      /* The following line needs to be modified when stack offsets are

	 being used instead of an object address array. */

#endif /* 0 */

      vtbl_ptr = *(void**)(obj_addr_array + vtbl_ehrdp->handle);

      if (vtbl_ehrdp->flags & RDF_INDIRECT) {

        /* If the indirect flag is set on the vtable region entry, get the

           actual vtable pointer from the address referred to by the region

           table entry.  This is not used by the fully portable mechanism. */

        temp_addr = (char *)*(void**)vtbl_ptr;

        vtbl_ptr = (void *)temp_addr;

      }  /* if */

#if DEBUG

      if (__debug_level >= 2) {

        fprintf(__f_debug, "  Vtable pointer=%p\n", vtbl_ptr);

      }  /* if */

#endif /* DEBUG */

    }  /* if */

#if 0

    /* In an implementation that uses stack offsets instead of an object

       address table, the handle field in the region description entry 

       will be a stack offset to be added to either the stack base or the

       current "this" parameter (if RDF_THIS_PARAM_OFFSET is set). */

#endif /* 0 */

    if (flags & RDF_ARRAY) {

      /* The object information is contained in the array supplement. */

      ehasp = &ehsep->variant.function.array_table[ehrdp->handle];

      obj_addr = *(obj_addr_array + ehasp->handle);

    } else {

      /* The object information is pointed to directly by the region entry. */

      obj_addr = *(obj_addr_array + ehrdp->handle);

    }  /* if */

    if (flags & RDF_INDIRECT) {

      /* If the indirect flag is set, get the actual object address from

         the address referred to by the region table entry.  This is not

         used by the fully portable mechanism. */

      temp_addr = (char *)*(void**)obj_addr;

      obj_addr = (void *)temp_addr;

    }  /* if */

#if DEBUG

    if (__debug_level >= 2) {

      fprintf(__f_debug, "  object address=%p\n", (void*)obj_addr);

    }  /* if */

#endif /* DEBUG */

    /* Do the actual cleanup of the object. */

    if ((flags & RDF_GUARD_VAR_FOR_LOCAL_STATIC) != 0) {

      /* The cleanup object is the variable that is set when a local static

         variable is initialized.  When such an entry is on the cleanup list

         it means that the exception was thrown while the local static was

         being initialized.  The cleanup action is to reset the guard

         variable so that it will be initialized again the next time the

         declaration of the local static is reached.  The test of

         RDF_BASE_CLASS_SUBOBJECT is needed because the GUARD_VAR bit

         is shared with the SUBOBJECT_VTABLE bit. */

      flag_addr = (a_conditional_flag*)obj_addr;

#ifdef __EDG_IA64_ABI

      /* In the IA-64 ABI, the guard is not actually set until the object

         initialization is complete, so the guard variable does not really

         need to be cleared (although the runtime routine does do so).  The

         call of __cxa_guard_abort is primarily done so that a lock can be

         released, if the implementation uses such locks. */

      ABI_NAMESPACE::__cxa_guard_abort((an_ia64_guard_ptr)flag_addr);

#else /* ifndef __EDG_IA64_ABI */

      *flag_addr = 0;

#endif /* ifdef __EDG_IA64_ABI */

    } else if (!(flags & RDF_NEW_ALLOCATION)) {

      /* A normal (not a new allocation) region.  Call the destructor for

         the object. */

      a_destructor_ptr	dtor_ptr;

      dtor_ptr = (a_destructor_ptr)ehrdp->destructor_or_delete_routine;

      if (flags & RDF_ARRAY) {

        an_element_count	elements = ehasp->array_size;

#ifndef __EDG_IA64_ABI

        __vec_delete(obj_addr, elements, ehasp->element_size, dtor_ptr,

                    /*delete_flag=*/FALSE, /*unused_arg=*/0);

#else /* ifdef __EDG_IA64_ABI */

        ABI_NAMESPACE::__cxa_vec_dtor(obj_addr, elements, 

                                      ehasp->element_size, dtor_ptr);

#endif /* ifdef __EDG_IA64_ABI */

      } else if (vtbl_ptr != NULL) {

        /* A non-array object for which a special destructor must be called

           in order to supply information about the construction vtable to

           be used. */

        a_destructor_with_vtable_param_ptr	dtor_with_vtable;

        dtor_with_vtable = (a_destructor_with_vtable_param_ptr)dtor_ptr;

        dtor_with_vtable(obj_addr, vtbl_ptr);

      } else {

#ifndef __EDG_IA64_ABI

        /* Not an array and not an object that requires special construction

           vtable information.  Just destroy the object.  If the object is a

           complete object, pass in the value "2" to indicate that the

	   object and any subobjects should be destroyed.  If the object

           is itself a base class subobject, pass in the value "0"

	   indicating that only the object (and not any subobjects)

	   should be destroyed. */

        (dtor_ptr)(obj_addr, (flags & RDF_BASE_CLASS_SUBOBJECT) ? 0 : 2);

#else /* ifdef __EDG_IA64_ABI */

        (dtor_ptr)(obj_addr);

#endif /* ifdef __EDG_IA64_ABI */

      }  /* if */

    } else {

      /* A new allocation region.  Call the delete operator to free the

         space. */

      if (obj_addr != NULL) {

        if (flags & RDF_ARRAY) {

          /* The array flag indicates that this is the two operand form of

             the delete operation. */

          a_two_operand_delete_ptr	delete_ptr;

          delete_ptr =

                (a_two_operand_delete_ptr)ehrdp->destructor_or_delete_routine;

          (delete_ptr)(obj_addr, ehasp->element_size);

        } else {

          a_delete_ptr	delete_ptr;

          delete_ptr = (a_delete_ptr)ehrdp->destructor_or_delete_routine;

          (delete_ptr)(obj_addr);

        }  /* if */

      }  /* if */

    }  /* if */

  }  /* for */

}  /* cleanup */





/*

Return TRUE if tp1_qualifiers does not have some type qualifier that

tp2_qualifiers has.

*/

#define any_qualifier_in_set_missing(tp1_qualifiers, tp2_qualifiers)  \

  ((~(tp1_qualifiers) & (tp2_qualifiers)) != 0)



#if ABI_COMPATIBILITY_VERSION >= 241



static a_boolean check_pointer_levels_and_qualifiers(

			an_exception_type_specification_ptr	etsp,

			an_ETS_flag_set				*ptr_flags)

/*

Compare the type specified by "ptr_flags" with the one specified by

"etsp".  If the pointers have the same number of levels, and if the

qualifiers are compatible, return TRUE; otherwise return FALSE.  The

caller has already verified that both types are multi-level pointers.

The caller is also responsible for ensuring that the types pointed to

are the same.  For the qualifiers to be compatible, a qualification

conversion, as described in 4.4 [conv.qual] of the standard must be

permitted.

*/

{

  a_boolean		okay;

  a_boolean		previous_qualifiers_include_const = TRUE;

  an_ETS_flag_set	*source_ptr_flags;

  an_ETS_flag_set	*dest_ptr_flags;



  dest_ptr_flags = etsp->ptr_flags;

  source_ptr_flags = ptr_flags;

  for (okay = TRUE; okay == TRUE;) {

    an_ETS_flag_set	dest_qualifiers;

    an_ETS_flag_set	source_qualifiers;

    /* Get the qualifiers for the current level. */

    dest_qualifiers = get_qualifiers(*dest_ptr_flags);

    source_qualifiers = get_qualifiers(*source_ptr_flags);

    if (is_last(*source_ptr_flags) != is_last(*dest_ptr_flags)) {

      /* The number of levels of pointers do not match. */

      okay = FALSE;

    } else if (any_qualifier_in_set_missing(dest_qualifiers,

                                            source_qualifiers)) {

      /* Some qualifier is missing. */

      okay = FALSE;

    } else {

      /* If the destination has additional qualifiers not found in the

         source, any previous qualifiers must have included const. */

      if (any_qualifier_in_set_missing(source_qualifiers,

				       dest_qualifiers)) {

	okay = previous_qualifiers_include_const;

	if (!okay) break;

      }  /* if */

      /* See if this qualifier includes const. */

      if (!is_const(dest_qualifiers)) {

	previous_qualifiers_include_const = FALSE;

      }  /* if */

    }  /* if */

    /* Terminate the loop if this is the last qualifier. */

    if (is_last(*source_ptr_flags)) break;

    dest_ptr_flags++;

    source_ptr_flags++;

  }  /* for */

  return okay;

}  /* check_pointer_levels_and_qualifiers */



#endif /* ABI_COMPATIBILITY_VERSION >= 241 */



static int check_exception_type_specifications

                        (an_exception_type_specification_ptr  etsp,

                         a_type_info_impl_ptr		      type_info,

			 an_ETS_flag_set		      flags,

			 an_ETS_flag_set		      *ptr_flags,

			 an_access_flag_string                access_flags,

			 a_boolean			      use_access_flags,

			 void**				      object_ptr,

			 an_exception_type_specification_ptr* etsp_found)

/*

Examine the exception type information associated with a given try block or

throw specification and determine whether any of the entries match the

object being thrown.  Returns 0 if no matching catch was found.  If a match

is found the position in the catch array is returned (actually, the array

index plus 1).  A pointer to the exception type specification of the matching

entry is returned in etsp_found.

*/

{

  int		        result = 0;

  int		        index = 0;

  a_boolean	        done = FALSE;

  a_boolean		is_ptr;



  *etsp_found = NULL;

  is_ptr = is_pointer(flags, ptr_flags);

  do {

    a_boolean	        match = FALSE;

    void*               new_ptr;

    a_boolean		ets_is_ptr;

    a_boolean		is_single_ptr;

    a_boolean		ets_is_single_ptr;

    an_access_flag_string local_access_flags = access_flags;

#if DEBUG

    void* orig_ptr = object_ptr != NULL ? *object_ptr : NULL;

#endif /* DEBUG */

    ets_is_ptr = is_pointer(etsp->flags, etsp->ptr_flags);

    ets_is_single_ptr = is_single_level_pointer(etsp->flags);

    is_single_ptr = is_single_level_pointer(flags);

    index++;

    if (is_ellipsis(etsp->flags)) {

      match = TRUE;

    } else if (ets_is_ptr != is_ptr) {

      /* One is a pointer and the other is not.  This can't be a match. */

    } else if (matching_type_info(etsp->type_info, type_info)) {

      /* The underlying types match.  Determine whether the any pointer levels

         above that type are acceptable. */

      if (!is_ptr) {

        /* Both are not pointers -- a match. */

        match = TRUE;

      } else if (is_single_ptr != ets_is_single_ptr) {

        /* One pointer is single level, the other is multi-level.  No match. */

      } else if (is_single_ptr) {

        /* Both are single level pointers.  Make sure that any qualifiers

           present on the source type are there on the destination. */

        an_ETS_flag_set	source_qualifiers = get_qualifiers(flags);

        an_ETS_flag_set	dest_qualifiers = get_qualifiers(etsp->flags);

        if (!any_qualifier_in_set_missing(dest_qualifiers,

                                          source_qualifiers)) {

          /* The qualifiers are acceptable. */

          match = TRUE;

        }  /* if */

#if ABI_COMPATIBILITY_VERSION >= 241

      } else {

        /* Both are multi-level pointers.  Make sure the source can be

           converted to the destination by a valid qualification conversion. */

        if (check_pointer_levels_and_qualifiers(etsp, ptr_flags)) {

          match = TRUE;

        }  /* if */

#endif /* ABI_COMPATIBILITY_VERSION >= 241 */

      }  /* if */

    }  /* if */

    if (match) {

      /* We already found a match -- doesn't check further. */

    } else if (ets_is_ptr != is_ptr) {

      /* One is a pointer and the other is not.  This can't be a match. */

    } else if (!qualifiers_acceptable(etsp->flags, flags)) {

      /* A pointer is being thrown to a catch without appropriate qualifiers.

         This is not a match.  This check only tests the lowest bottom level

         of qualifiers and used for the match of a conversion to void* and

         derived to base conversions below. */

#if ABI_CHANGES_FOR_RTTI

    } else if (

#ifndef __EDG_IA64_ABI

               etsp->type_info->unique_id != NULL &&

               etsp->type_info->unique_id ==

                                         &MANGLED_NAME_OF_UNIQUE_ID_OF_VOID &&

#else /* ifdef __EDG_IA64_ABI */

               matching_type_info(etsp->type_info, &typeid(void)) &&

#endif /* ifdef __EDG_IA64_ABI */

               (ets_is_ptr == is_ptr) && ets_is_single_ptr) {

      /* The exception type specification is a void * and the object

         being thrown is some kind of pointer.  This is a match. */

      match = TRUE;

#else /* !ABI_CHANGES_FOR_RTTI */

    } else if (etsp->type_info == &MANGLED_NAME_OF_VOID &&

               (ets_is_ptr == is_ptr) && ets_is_single_ptr) {

      /* The exception type specification is a void * and the object

         being thrown is some kind of pointer.  This is a match. */

      match = TRUE;

#endif /* !ABI_CHANGES_FOR_RTTI */

    } else if ((!is_ptr ||

               (is_single_ptr && ets_is_single_ptr)) &&

#ifndef __EDG_IA64_ABI

	       type_info->base_class_entries != NULL &&

#else /* ifdef __EDG_IA64_ABI */

               (typeid(*type_info) == typeid(abi::__si_class_type_info) ||

                typeid(*type_info) == typeid(abi::__vmi_class_type_info)) &&

#endif /* ifdef __EDG_IA64_ABI */

	       __derived_to_base_conversion(object_ptr, &new_ptr, type_info,

					    etsp->type_info,

					    &local_access_flags,

                                            use_access_flags)) {

      /* A base class of the class that was thrown.  If the base class

	 is ambiguous or inaccessible then the base class flag will not

         be set.  The pointer is converted from a pointer to the derived 

	 class to a pointer to the base class.  Object_ptr will be NULL

	 when this routine is call to check throw specifications and no

	 object is involved, in which case the pointer conversion will not be

	 done, but derived_to_base_conversion will return TRUE to indicate

	 that such a conversion is possible. */

      match = TRUE;

      /* If a derived to base conversion was done, update the object pointer

	 to point to the base class. */

      if (object_ptr != NULL) *object_ptr = new_ptr;

#if DEBUG

      if (object_ptr != NULL && *object_ptr != NULL) {

        if (__debug_level >= 3) {

          if (orig_ptr != *object_ptr) {

            fprintf(__f_debug, "Orig ptr=%p, new ptr=%p\n", orig_ptr,

                    *object_ptr);

          }  /* if */

        }  /* if */

      }  /* if */

#endif /* DEBUG */

    }  /* if */

    if (match) {

      result = index;

     *etsp_found = etsp;

      break;

    }  /* if */

    done = etsp->flags & ETS_LAST;

    etsp++;

  } while (!done);

  return result;

}  /* check_exception_type_specifications */





static void destroy_thrown_object(a_throw_stack_entry_ptr	tsep)

/*

Call the destructor for the copy of the object created by the runtime and

indicate that the throw stack entry may be discarded when it reaches the

top of the throw stack.

*/

{

  void*				object_address;

  a_throw_stack_entry_ptr	primary_tsep;



#if DEBUG

  if (__debug_level >= 6) {

    db_throw_stack("at start of destroy_thrown_object");

    fprintf(__f_debug, "Possibly destroying object associated with tsep %p\n",

            tsep);

  }  /* if */

#endif /* DEBUG */

  /* If this is a rethrow, get a pointer to the throw stack entry associated

     with the original throw. */

  primary_tsep = tsep->is_rethrow ? tsep->primary_entry : tsep;

  if (!tsep->discard_entry) {

    /* If this is the first time the routine has been called for this entry,

       set the discard flag and decrement the use count. */

    tsep->discard_entry = TRUE;

    primary_tsep->use_count--;

  }  /* if */

  /* If the entry can be destroyed, and the destructor has not already been

     called, then call it now. */

  if (primary_tsep->use_count == 0 && !primary_tsep->dtor_called) {

    /* Call the destructor for the object if needed. */

    primary_tsep->dtor_called = TRUE;

    object_address = primary_tsep->object_address;

    if (primary_tsep->object_copy_complete &&

        !is_pointer(primary_tsep->flags, primary_tsep->ptr_flags)) {

#if DEBUG

      if (__debug_level >= 4) {

        fprintf(__f_debug, "Destroying object at %p\n", object_address);

      }  /* if */

#endif /* DEBUG */

      a_destructor_ptr	dtor_ptr;

      dtor_ptr = (a_destructor_ptr)primary_tsep->destructor;

      if (dtor_ptr != NULL) {

#ifndef __EDG_IA64_ABI

        (dtor_ptr)(object_address, 2);

#else /* ifdef __EDG_IA64_ABI */

        (dtor_ptr)(object_address);

#endif /* ifdef __EDG_IA64_ABI */

      }  /* if */

    }  /* if */

  }  /* if */

}  /* destroy_thrown_object */





EXTERN_C void __exception_started()

/*

Marks the point at which an exception that is thrown is considered

"uncaught".  This is the point after the evaluation of the thrown

object, but before the object is copied to the EH temporary.  If the

copy to the temporary is elided, this point is after both the evaluation

and the copy that is integrated into the evaluation.

*/

{

  a_throw_stack_entry_ptr	tsep = curr_throw_stack_entry;



  /* Link the throw processing marker onto the EH stack. */

  tsep->throw_marker.next = __curr_eh_stack_entry;

  __curr_eh_stack_entry = &tsep->throw_marker;

  tsep->object_evaluation_complete = TRUE;

}  /* exception_started */





EXTERN_C void __exception_caught(void)

/*

Unlink the throw marker entry from the EH stack.  This is called after

the catch parameter has been copied.

*/

{

  check_assertion(__curr_eh_stack_entry->kind ==

                  ehsek_throw_processing_marker);

  __curr_eh_stack_entry = __curr_eh_stack_entry->next;

}  /* __exception_caught */





EXTERN_C int __throw(void)

/*

Process a throw.  This routine looks through the stack entries for

a try block with a catch that matches the type of the object thrown.

*/

{

  an_eh_stack_entry_ptr		ehsep;

  an_eh_stack_entry_ptr		destination_ehsep = NULL;

#if !UNWIND_STACK_BEFORE_CALLING_TERMINATE

  an_eh_stack_entry_ptr		non_internal_destination_ehsep = NULL;

#endif /* !UNWIND_STACK_BEFORE_CALLING_TERMINATE */

  int				destination_catch_value;

  void*				object_ptr;

  void*				object_buffer_ptr;

  a_type_info_impl_ptr		thrown_type_info;

  an_ETS_flag_set		throw_flags;

  an_ETS_flag_set		*throw_ptr_flags;

  an_exception_type_specification_ptr

				etsp_found;

  an_access_flag_string         access_flags;

  a_boolean			use_access_flags;



  if (!curr_throw_stack_entry->object_evaluation_complete) {

    /* If the __exception_started routine was not explicitly called by the

       code generated at the throw site, call it now. */

    __exception_started();

  }  /* if */

  /* When __throw is called we know that the object has been copied and

     must be destroyed when the throw stack entry is popped. */

  curr_throw_stack_entry->object_copy_complete = TRUE;

  /* Get the information about the current thrown object from the

     throw stack. */

  thrown_type_info = curr_throw_stack_entry->type_info;

  throw_flags = curr_throw_stack_entry->flags;

  throw_ptr_flags = curr_throw_stack_entry->ptr_flags;

  access_flags = curr_throw_stack_entry->access_flags;

  use_access_flags = curr_throw_stack_entry->use_access_flags;

  /* If the throw object is a pointer we copy the pointer into a separate

     buffer whose address is passed to the catch.  This is done because

     the pointer may undergo a conversion (such as derived to base) and we

     need to preserve the original pointer in case it is needed by a

     rethrow. */

  if (is_pointer(throw_flags, throw_ptr_flags)

/*** START TI ADD ***/ 

      && !is_pointer_to_func(throw_flags, throw_ptr_flags)

/*** END TI ADD ***/

      ) {

    /* It is a pointer.  object_buffer_ptr points to the special pointer

       buffer in the throw stack.  object_ptr contains the value of the

       pointer. */

    object_buffer_ptr = curr_throw_stack_entry->object_address;

    object_ptr = *(void**)object_buffer_ptr;

    object_buffer_ptr = (void*)&curr_throw_stack_entry->pointer_buffer;

  } else {

    /* It is not a pointer.  object_buffer_ptr points to the original copy

       of the object.  object_ptr points to the object buffer. */

    object_buffer_ptr = curr_throw_stack_entry->object_address;

    object_ptr = object_buffer_ptr;

  }  /* if */

#if DEBUG

  if (__debug_level >= 1) {

    fprintf(__f_debug, "__throw called\n");

  }  /* if */

#endif /* DEBUG */

  /* Get the address of the thrown object. */

  /* Find the try block that can catch the object being thrown. */

  ehsep = __curr_eh_stack_entry;

  check_assertion(ehsep == &curr_throw_stack_entry->throw_marker);

  /* Skip past the throw marker entry. */

  ehsep = ehsep->next;

  while (ehsep != NULL) {

    an_eh_stack_entry_kind	kind = ehsep->kind;

    if (kind == (an_eh_stack_entry_kind)ehsek_function) {

      /* Do nothing with function blocks at this time. */

    } else if (kind == (an_eh_stack_entry_kind)ehsek_vec_new_or_delete) {

      /* Do nothing with vec_new and vec_delete entries at this time. */

    } else if (kind == (an_eh_stack_entry_kind)ehsek_try_block) {

      if (ehsep->variant.try_block.catch_info == NULL) {

        /* Skip over try blocks for which a catch is active. */

        int result;

        if (ehsep->variant.try_block.catch_entries != NULL) {

          /* A normal (i.e., non-internal) try block.  See if any of the

            catch handlers match the object thrown. */

          result = check_exception_type_specifications

				(ehsep->variant.try_block.catch_entries,

				 thrown_type_info, throw_flags,

                                 throw_ptr_flags, access_flags,

				 use_access_flags, &object_ptr, &etsp_found);

        } else {

          /* An internal try block, which has no catch entries.  An internal

             try block is equivalent to a "catch (...)".  Set result to 1 to

             indicate that this is a valid handler for the throw.  The value

             of result will not be used in the handler code. */

          result = 1;

        }  /* if */

        if (result != 0) {

          /* A matching try block was found.  This could be an regular try

             block or an "internal" try block that is generated as part of

             the EH cleanup code for things like placement new operations

             (with matching placement delete functions).  Internal try

             blocks are treated like normal try blocks in all respects

             except that they are not considered a matching handler for

             purposes of determining whether or not terminate() should be

             called. */

          if (destination_ehsep == NULL) {

            destination_ehsep = ehsep;

            destination_catch_value = result;

          }  /* if */

          if (ehsep->variant.try_block.catch_entries != NULL) {

            /* This is a normal (i.e., not an internal) try block. */

#if !UNWIND_STACK_BEFORE_CALLING_TERMINATE

            non_internal_destination_ehsep = ehsep;

#endif /* !UNWIND_STACK_BEFORE_CALLING_TERMINATE */

            break;

          }  /* if */

        }  /* if */

      }  /* if */

    } else if (destination_ehsep != NULL) {

      /* Once a matching try block has been found, disregard an subsequent

         throw specification entries or throw processing markers that might

         be found.   The only other entries that are considered are

         non-internal try blocks to see if a matching handler can be found. */

      ehsep = ehsep->next;

      continue;

    } else if (kind == (an_eh_stack_entry_kind)ehsek_throw_spec) {

      /* Check for violations of throw specifications.  If a throw

         specification is violated we cleanup until we reach the

         violated throw specification and then call unexpected.

         If result is zero, no match was found.  If there is an empty

         specification then, by definition, no match is found. */

      int	result = 0;

      if (ehsep->variant.throw_specification != NULL) {

        an_exception_type_specification_ptr	dummy_etsp;

        result = check_exception_type_specifications

				  (ehsep->variant.throw_specification,

				   thrown_type_info, throw_flags,

                                   throw_ptr_flags, access_flags,

				   use_access_flags, (void**)NULL,

                                   &dummy_etsp);

      }  /* if */

      if (result == 0) {

        destination_ehsep = ehsep;

        break;

      }  /* if */

    } else if (kind == (an_eh_stack_entry_kind)ehsek_throw_processing_marker) {

      /* This entry is put on the stack before object cleanup begins.  If

         we find this marker it means that a destructor threw an

         exception that was not handled within the destructor.  The EH

         stack entry should point to the throw processing marker when

         exception_caught is called. */

      __curr_eh_stack_entry = ehsep;

      /* Indicate that the current thrown object is now in a handler.  This

         makes the object eligible for a rethrow. */

      curr_throw_stack_entry->in_handler = TRUE;

      __exception_caught();

      __call_terminate();

    } else {

      unexpected_condition();

    }  /* if */

    ehsep = ehsep->next;

  }  /* while */

#if !UNWIND_STACK_BEFORE_CALLING_TERMINATE

  /* If no matching (non-internal) handler was found, call terminate. */

  if (non_internal_destination_ehsep == NULL) {

      /* Indicate that the current thrown object is now in a handler.  This

         makes the object eligible for a rethrow. */

      curr_throw_stack_entry->in_handler = TRUE;

    __exception_caught();

    __call_terminate();

  }  /* if */

#endif /* !UNWIND_STACK_BEFORE_CALLING_TERMINATE */

  /* Go through the EH stack again and do any necessary cleanup. */

  ehsep = __curr_eh_stack_entry;

  /* Skip past the throw marker entry. */

  ehsep = ehsep->next;

  while (ehsep != destination_ehsep) {

    an_eh_stack_entry_kind	kind = ehsep->kind;

#if DEBUG

     if (__debug_level >= 2) {

       fprintf(__f_debug, "Processing EH stack entry at %p, kind=%d\n",

               (void *)ehsep, kind);

     }  /* if */

#endif /* DEBUG */

    if (kind == (an_eh_stack_entry_kind)ehsek_function) {

      cleanup(ehsep, __eh_curr_region, NULL_REGION_NUMBER);

      __eh_curr_region = ehsep->variant.function.saved_region_number;

    } else if (kind == (an_eh_stack_entry_kind)ehsek_vec_new_or_delete) {

      /* A vec_new or vec_delete operation that was in process when the

         exception occurred.  Call the routine to cleanup the partially

         constructed or destructed array. */

      __cleanup_vec_new_or_delete(ehsep);

    } else if (kind == (an_eh_stack_entry_kind)ehsek_try_block) {

      /* A try block that is being skipped. */

      if (ehsep->variant.try_block.catch_info != NULL) {

        /* A catch clause associated with this try block is currently

	   being processed.  Because this try block is being bypassed the

           throw entry is no longer needed.  It cannot be discarded yet

           because the thrown objects are allocated using a stack.  Call

           the destructor for the object and set a flag that this entry

           should be discarded when it reaches the top of the stack. */

        a_throw_stack_entry_ptr	tsep;

        tsep = (a_throw_stack_entry_ptr)ehsep->variant.try_block.catch_info;

        destroy_thrown_object(tsep);

      }  /* if */

    } else if (kind == (an_eh_stack_entry_kind)ehsek_throw_spec) {

      /* Do nothing. */

    } else if (kind == (an_eh_stack_entry_kind)ehsek_throw_processing_marker) {

      /* Do nothing. */

    } else {

      unexpected_condition();

    }  /* if */

    ehsep = ehsep->next;

  }  /* while */

#if UNWIND_STACK_BEFORE_CALLING_TERMINATE

  /* If no handler was found call the terminate function.  Note that this

     tests "destination_ehsep" instead of "non_internal_destination_ehsep".

     When an internal try block is the matching handler, it should be used

     to do the necessary cleanup even when no "real" matching handler is

     found.  When the internal try block does its rethrow, the rethrow will

     result in a call to terminate() when no matching handler is found. */

  if (destination_ehsep == NULL) {

    /* Indicate that the current thrown object is now in a handler.  This

       makes the object eligible for a rethrow. */

    curr_throw_stack_entry->in_handler = TRUE;

    __exception_caught();

    __call_terminate();

  }  /* if */

#endif /* UNWIND_STACK_BEFORE_CALLING_TERMINATE */

  if (destination_ehsep->kind == (an_eh_stack_entry_kind)ehsek_try_block) {

    /* A try block may have objects that must be cleaned up before

       transferring control to one of the catch clauses.  This is determined

       by comparing the current region number with the region number in

       the try block.  If they are different then some objects must be

       cleaned up.  Call the cleanup routine to cleanup objects until we

       reach the region number indicated by the value in the try block. */

    if (destination_ehsep->variant.try_block.region_number !=

							 __eh_curr_region) {

      /* Find the function entry that contains the cleanup information. */

      an_eh_stack_entry_ptr	function_ehsep = destination_ehsep->next;

      while (function_ehsep->kind != (an_eh_stack_entry_kind)ehsek_function) {

        function_ehsep = function_ehsep->next;

      }  /* while */

      cleanup(function_ehsep, __eh_curr_region,

              destination_ehsep->variant.try_block.region_number);

      /* Restore the region number to the appropriate value for entry to the

         catch clause. */

      __eh_curr_region = destination_ehsep->variant.try_block.region_number;

    }  /* if */

  }  /* if */



  /* Update the throw processing marker so that its "next" entry points

     to the appropriate location after all cleanup actions have taken

     place. */

  check_assertion(__curr_eh_stack_entry ==

                  &curr_throw_stack_entry->throw_marker);

  __curr_eh_stack_entry->next = destination_ehsep;

  /* Indicate that the current thrown object is now in a handler.  This makes

     the object eligible for a rethrow. */

  curr_throw_stack_entry->in_handler = TRUE;

  if (destination_ehsep->kind == (an_eh_stack_entry_kind)ehsek_try_block) {

    a_boolean	exception_caught = FALSE;

    __catch_clause_number = destination_catch_value;

    if (is_pointer(throw_flags, throw_ptr_flags)

/*** START TI ADD ***/ 

	&& !is_pointer_to_func(throw_flags, throw_ptr_flags)

/*** END TI ADD ***/

	) {

      /* The throw object is a pointer that may have underdone some

         kind of conversion such as a derived to base conversion.  Save

         the updated pointer.  Note that object_buffer_ptr has already

         been modified to point to a separate buffer so that the original

         pointer is preserved in case it is needed by a rethrow. */

      *(void**)object_buffer_ptr = object_ptr;

      __caught_object_address = object_buffer_ptr;

    } 

/*** START TI ADD ***/ 

    else if (is_pointer_to_func(throw_flags, throw_ptr_flags)) {

      __caught_object_address = object_buffer_ptr;

    }

/*** END TI ADD ***/

    else {

      /* The thrown object is not a pointer.  object_ptr starts out with the

         same value as object_buffer_ptr but may be modified my a

         derived to base conversion.  It still points somewhere within

         the object buffer, however. */

      __caught_object_address = object_ptr;

    }  /* if */

    /* Update the pointer in the try block to point to the throw stack entry

       for the thrown object. */

    destination_ehsep->variant.try_block.catch_info =

                                               (void*)curr_throw_stack_entry;

#if ABI_COMPATIBILITY_VERSION < 235

    /* Starting with ABI version 2.35, __exception_caught is called by

       __internal_rethrow at the conclusion of the catch clause associated

       with an internal try block. */

    if (destination_ehsep->variant.try_block.catch_entries == NULL) {

      /* For an internal try block an exception is considered caught as soon

         as the handler is started (because there is no copy constructor to

         be called to initialize the catch parameter).  Mark the exception

         as caught now. */

      exception_caught = TRUE;

    }  /* if */

#endif /* ABI_COMPATIBILITY_VERSION < 235 */

#if ABI_COMPATIBILITY_VERSION < 233

    /* ABI versions earlier than 2.33 don't include calls to the

       __exception_caught routine.  Call it explicitly here.  This

      is equivalent to the old behavior. */

    exception_caught = TRUE;

#endif /* ABI_COMPATIBILITY_VERSION < 233 */

    if (exception_caught) {

      /* Mark the exception as caught now, if appropriate. */

      __exception_caught();

    }  /* if */

    longjmp(destination_ehsep->variant.try_block.setjmp_buffer, 1);

  } else if (destination_ehsep->kind ==

                                (an_eh_stack_entry_kind)ehsek_throw_spec) {

    /* A destination stack entry indicates that a throw specification was

       violated.  Call unexpected.  The EH stack should point to the

       entry for the exception specification that was violated.  Remove

       the throw processing marker from the stack. */

    __curr_eh_stack_entry = __curr_eh_stack_entry->next;

#if !ABI_CHANGES_FOR_RTTI

   /* When RTTI is not used, the old semantics of unexpected() are used in

      which the type of an object thrown by unexpected is not checked against

      the violated exception specification.  Remove the EH stack entry

      for the violated throw specification. */

   __curr_eh_stack_entry = __curr_eh_stack_entry->next;

#endif /* ABI_CHANGES_FOR_RTTI */

    __call_unexpected();

  }  /* if */

  return 0;

}  /* __throw */





static void push_throw_stack(a_type_info_impl_ptr    type_info,

			     a_destructor_ptr	     destructor,

			     an_ETS_flag_set	     flags,

			     an_ETS_flag_set	     *ptr_flags,

                             an_access_flag_string   access_flags,

                             a_boolean               use_access_flags,

			     void*		     object_address,

			     a_boolean		     is_rethrow,

                             a_throw_stack_entry_ptr primary_entry)

/*

Push an entry onto the throw stack and initialize its fields.

*/

{

  a_throw_stack_entry_ptr	tsep;

  an_eh_stack_entry_ptr		ehsep;



  tsep =

      (a_throw_stack_entry_ptr)eh_alloc_on_stack(sizeof(a_throw_stack_entry));

  tsep->next = curr_throw_stack_entry;

  curr_throw_stack_entry = tsep;

  tsep->type_info = type_info;

  tsep->destructor = destructor;

  tsep->flags = flags;

  tsep->ptr_flags = ptr_flags;

  tsep->access_flags = access_flags;

  tsep->use_access_flags = use_access_flags;

  tsep->object_address = object_address;

  tsep->pointer_buffer = NULL;

  tsep->primary_entry = primary_entry;

  tsep->use_count = 0;

  /* If this is a rethrow, increment the use count of the primary entry.

     Otherwise, increment the use count of this entry. */

  if (is_rethrow) {

    primary_entry->use_count++;

  } else {

    tsep->use_count++;

  }  /* if */

  tsep->is_rethrow = is_rethrow;

  tsep->dtor_called = FALSE;

  tsep->discard_entry = FALSE;

  tsep->in_handler = FALSE;

  tsep->object_copy_complete = FALSE;

  tsep->object_evaluation_complete = FALSE;

  tsep->throw_marker.next = NULL;

  tsep->throw_marker.kind = ehsek_throw_processing_marker;

  /* Record a pointer to the nearest enclosing try block in the throw

     stack entry.  If this throw has the same nearest enclosing try block

     as the previous throw then the previous throw should be discarded.

     This can occur if a throw is done from a copy constructor called

     after __throw_alloc but before __throw. */

  ehsep = __curr_eh_stack_entry;

  while (ehsep != NULL) {

    /* Try blocks that are currently inside a handler are not considered. */

    if (ehsep->kind == (an_eh_stack_entry_kind)ehsek_try_block &&

        ehsep->variant.try_block.catch_info == NULL) break;

    ehsep = ehsep->next;

  }  /* while */

  tsep->nearest_enclosing_try_block = ehsep;

  if (tsep->next != NULL) {

    if (tsep->next->nearest_enclosing_try_block == ehsep) {

      /* There is a previous throw and it does point to the same nearest

         enclosing try block. */

      destroy_thrown_object(tsep);

    }  /* if */

  }  /* if */

}  /* push_throw_stack */





EXTERN_C void __rethrow(void)

/*

Rethrow the current thrown object.

*/

{

  a_throw_stack_entry_ptr	tsep = curr_throw_stack_entry;



  /* Find the throw stack entry for the throw currently being handled. */

  for (; tsep != NULL; tsep = tsep->next) {

    if (tsep->in_handler && !tsep->is_rethrow) break;

  }  /* for */

  if (tsep == NULL) {

    /* No handler is currently active. */

    __call_terminate();

  }  /* if */

  push_throw_stack(tsep->type_info,

                   tsep->destructor,

		   tsep->flags,

                   tsep->ptr_flags,

		   tsep->access_flags,

		   tsep->use_access_flags,

		   tsep->object_address,

		   /*is_rethrow=*/TRUE,

                   tsep);

  __throw();

}  /* __rethrow */





#if ABI_COMPATIBILITY_VERSION >= 235

EXTERN_C void __internal_rethrow(void)

/*

Entry point to rethrow used by internal try blocks.  This routine simply

calls __exception_caught to mark the throw as complete, then does a normal

rethrow.

*/

{

  __exception_caught();

  __rethrow();

}  /* __internal_rethrow */

#endif /* ABI_COMPATIBILITY_VERSION >= 235 */





/*

__throw_alloc is called for ABI versions that do not include RTTI.

When RTTI is supported, __throw_setup is called for ABI versions up to

and including 2.37, and in later ABI versions for types that have no

destructor.  The 2.38 ABI passes the destructor pointer to

__throw_setup_dtor, and removes it from the type_info_impl structure

to fix some corner cases in which a destructor is required solely for

the purpose of creating a type_info_impl object.  The 2.41 ABI uses

__throw_setup_ptr when a multi-level pointer is passed.  This is used

to supply additional information used for qualification conversions.

*/



#if ABI_COMPATIBILITY_VERSION >= 241



EXTERN_C void* __throw_setup_ptr(a_type_info_impl_ptr  type_info,

  			          a_sizeof_t	        size,

			          an_ETS_flag_set	*ptr_flags)

/*

Allocate space for the object to be thrown and save information about

the type being thrown.  This is like __throw_setup, except that the

a pointer to an array of ETS flags for multi-level pointers is passed.

*/

{

  void*				object_address;

  

  object_address = (void *)eh_alloc_on_stack(size);

  push_throw_stack(type_info, (a_destructor_ptr)NULL, ETS_NO_FLAGS,

                   ptr_flags, (an_access_flag_string)NULL,

	           /*use_access_flags=*/FALSE, object_address,

		   /*is_rethrow=*/FALSE,

                   (a_throw_stack_entry_ptr)NULL);

  return object_address;

}  /* __throw_setup_ptr */



#endif /* ABI_COMPATIBILITY_VERSION >= 241 */



#if ABI_CHANGES_FOR_RTTI

EXTERN_C void* __throw_setup(a_type_info_impl_ptr  type_info,

  			     a_sizeof_t	           size,

			     int	           ets_flags)

/*

Allocate space for the object to be thrown and save information about

the type being thrown.  This is like __throw_alloc, except no access_flags

are provided.  ets_flags is passed as an int (and not an_ETS_flag_set)

because that is how it is passed by the code generated by the front end.

*/

{

  void*				object_address;

  a_destructor_ptr		destructor;

  /* For ABI versions up to and including 2.37, the destructor pointer,

     if any, is stored in the type_info_impl object.  After 2.37, this

     routine is only used for objects without destructors. */

#if ABI_COMPATIBILITY_VERSION <= 237

  destructor = type_info->destructor;

#else /* !ABI_COMPATIBILITY_VERSION <= 237 */

  destructor = (a_destructor_ptr)NULL;

#endif /* ABI_COMPATIBILITY_VERSION <= 237 */

  object_address = (void *)eh_alloc_on_stack(size);

  push_throw_stack(type_info, destructor, ets_flags, (an_ETS_flag_set*)NULL,

                   (an_access_flag_string)NULL,

	           /*use_access_flags=*/FALSE, object_address,

		   /*is_rethrow=*/FALSE,

                   (a_throw_stack_entry_ptr)NULL);

  return object_address;

}  /* __throw_setup */



#if ABI_COMPATIBILITY_VERSION >= 238



EXTERN_C void* __throw_setup_dtor(a_type_info_impl_ptr  type_info,

  			          a_sizeof_t	        size,

			          int			ets_flags,

				  a_destructor_ptr	destructor)

/*

Allocate space for the object to be thrown and save information about

the type being thrown.  This is like __throw_setup, except that the

destructor pointer is passed as a parameter instead of being fetched

from the type_info_impl structure.  ets_flags is passed as an int (and

not an_ETS_flag_set) because that is how it is passed by the code

generated by the front end.

*/

{

  void*				object_address;



  object_address = (void *)eh_alloc_on_stack(size);

  push_throw_stack(type_info, destructor, ets_flags, (an_ETS_flag_set*)NULL,

                   (an_access_flag_string)NULL,

	           /*use_access_flags=*/FALSE, object_address,

		   /*is_rethrow=*/FALSE,

                   (a_throw_stack_entry_ptr)NULL);

  return object_address;

}  /* __throw_setup_dtor */



#endif /* ABI_COMPATIBILITY_VERSION >= 238 */



#else /* !ABI_CHANGES_FOR_RTTI */



EXTERN_C void* __throw_alloc(a_type_info_impl_ptr  type_info,

			     a_sizeof_t		   size,

			     int		   ets_flags,

			     an_access_flag_string access_flags)

/*

Allocate space for the object to be thrown and save information about

the type being thrown.  ets_flags is passed as an int (and not an_ETS_flag_set)

because that is how it is passed by the code generated by the front end.

*/

{

  void*				object_address;



  object_address = (void *)eh_alloc_on_stack(size);

  push_throw_stack(type_info, type_info->destructor, ets_flags,

                   (an_ETS_flag_set*)NULL, access_flags,

                   /*use_access_flags=*/TRUE,

		   object_address, /*is_rethrow=*/FALSE,

                   (a_throw_stack_entry_ptr)NULL);

  return object_address;

}  /* __throw_alloc */

#endif /* ABI_CHANGES_FOR_RTTI */





EXTERN_C void __free_thrown_object(void)

/*

Free the space used to make the copy of the thrown object.  Called at

the completion of a catch clause.

*/

{

#if DEBUG

  if (__debug_level >= 6) {

    db_throw_stack("at start of free_thrown_object");

  }  /* if */

#endif /* DEBUG */

  check_assertion(curr_throw_stack_entry != NULL);

  destroy_thrown_object(curr_throw_stack_entry);

  /* Free any entries with the discard_entry flag set.  This always frees

     the top entry but may also free additional entries associated with

     pending catches that were later skipped over by a throw. */

  while (curr_throw_stack_entry != NULL &&

         curr_throw_stack_entry->discard_entry) {

    a_throw_stack_entry_ptr	tsep = curr_throw_stack_entry;

    a_boolean			is_rethrow = tsep->is_rethrow;

    void*			object_address = tsep->object_address;

    /* If this is not a rethrow, the destructor should have already been

       called. */

    check_assertion(is_rethrow || tsep->dtor_called);

    /* Unlink this entry from the throw stack. */

    curr_throw_stack_entry = tsep->next;

    /* Free the space used for the throw stack entry.  Note that the stack

       entry and the object must be freed in the reverse of the order

       in which they were allocated since this is a stack. */

    eh_free_on_stack(tsep);

    if (!is_rethrow) {

      /* Free the space used for the copy of the object. */

      eh_free_on_stack(object_address);

    }  /* if */

  }  /* while */

#if DEBUG

  if (__debug_level >= 3) {

    db_throw_stack("at end of free_thrown_object");

  }  /* if */

#endif /* DEBUG */

}  /* __free_thrown_object */





EXTERN_C void __eh_exit_processing(void)

/*

Exit has been called.  Do any processing required to ensure that an

exception thrown by a static destructor or routine registered with

at_exit cannot throw beyond the exit call.

*/

{

  /* Clear the EH stack entry.  This will prevent a throw from finding

     a try block that was entered before exit was called. */

  __curr_eh_stack_entry = NULL;

}  /* __eh_exit_processing */





EXTERN_C void __suppress_optim_on_vars_in_try(void)

/*

Calls of this routine are generated when the C generating back end is

used.  It is used to make optimizers think that the addresses have been

taken of any local variables used inside a try block, thus ensuring that

their values will be saved when calling a routine inside the try block

that may throw an exception.  The routine is not supposed to actually

get called.

*/

{

  unexpected_condition();

} /* __suppress_optim_on_vars_in_try */



EXTERN_C an_eh_stack_entry_ptr __get_curr_eh_stack_entry(void)

/*

Return a pointer to __get_curr_eh_stack_entry.

*/

{

  return __curr_eh_stack_entry;

}  /* __get_curr_eh_stack_entry */





EXTERN_C void __type_of_thrown_object(a_type_info_impl_ptr	*type,

				      an_ETS_flag_set		*flags,

				      an_ETS_flag_set		**ptr_flags)

/*

Return a pointer to the typeinfo entry for the type of the object that

was thrown and the flags associated with the thrown object.

*/

{

  check_assertion(curr_throw_stack_entry != NULL);

  *type = curr_throw_stack_entry->type_info;

  *flags = curr_throw_stack_entry->flags;

  *ptr_flags = curr_throw_stack_entry->ptr_flags;

}  /* __type_of_thrown_object */





EXTERN_C a_boolean __can_throw_type(a_type_info_impl_ptr	type,

				    an_ETS_flag_set		flags,

				    an_ETS_flag_set		*ptr_flags)

/*

This routine is called by the code that checks whether an exception thrown

by unexpected() violates the current exception specification.  Find the

innermost exception specification and check whether the specified type

and flag combination is allowed.

*/

{

  a_boolean		result = FALSE;

  an_eh_stack_entry_ptr	ehsep;



  ehsep = __curr_eh_stack_entry;

  for (ehsep = __curr_eh_stack_entry; ehsep != NULL; ehsep = ehsep->next) {

    if (ehsep->kind == (an_eh_stack_entry_kind)ehsek_throw_spec) break;

  }  /* for */

  check_assertion(ehsep != NULL);

  if (ehsep->variant.throw_specification != NULL) {

    an_exception_type_specification_ptr	dummy_etsp;

    int					catch_pos;

    catch_pos = check_exception_type_specifications

				  (ehsep->variant.throw_specification,

				   type, flags, ptr_flags,

                                   (an_access_flag_string)NULL,

				   /*use_access_flags=*/FALSE, (void**)NULL,

                                   &dummy_etsp);

    if (catch_pos != 0) result = TRUE;

  }  /* if */

  return result;

}  /* __can_throw_type */



/*** START TI ADD ***/

/*

EH_CONTEXT is the data structure to hold the EH globals

*/

struct EH_CONTEXT

{

    a_region_number          eh_curr_region;

    an_eh_stack_entry_ptr    curr_eh_stack_entry;

    int                      catch_clause_number;

    void                    *caught_object_address;

    a_throw_stack_entry_ptr  curr_throw_stack_entry;

    a_mem_block_descr_ptr    curr_mem_block_descr;

    a_mem_allocation_ptr     mem_allocation_stack;

};

/*

 return the size of the memory block to hold the EH globals

*/

EXTERN_C int __eh_context_size()

{

    return sizeof(EH_CONTEXT);

}

/*

Store EH globals to "to"; and restore EH globals from "from"

*/

EXTERN_C void __swap_eh_context(void *restore_from_context, 

                                void *save_to_context)

{

    EH_CONTEXT *from = (EH_CONTEXT *)restore_from_context;

    EH_CONTEXT *to   = (EH_CONTEXT *)save_to_context;



    if (to)

    {

        to->eh_curr_region         = __eh_curr_region;

        to->curr_eh_stack_entry    = __curr_eh_stack_entry;

        to->catch_clause_number    = __catch_clause_number;

        to->caught_object_address  = __caught_object_address;

        to->curr_throw_stack_entry = curr_throw_stack_entry;

        to->curr_mem_block_descr   = curr_mem_block_descr;

        to->mem_allocation_stack   = mem_allocation_stack;

    }



    if (from)

    {

        __eh_curr_region         = from->eh_curr_region;

        __curr_eh_stack_entry    = from->curr_eh_stack_entry;

        __catch_clause_number    = from->catch_clause_number;

        __caught_object_address  = from->caught_object_address;

        curr_throw_stack_entry   = from->curr_throw_stack_entry;

        curr_mem_block_descr     = from->curr_mem_block_descr;

        mem_allocation_stack     = from->mem_allocation_stack;

    }

}



#endif /* !defined (__TI_TABLE_DRIVEN_EXCEPTIONS) */

/*** END TI ADD ***/

#else /* !EXCEPTION_HANDLING */



EXTERN_C void __eh_exit_processing(void)

/*

A stub version of __eh_exit_processing that is used when the runtime is

built without exception handling support.  This version does nothing.

*/

{

}  /* __eh_exit_processing */



#endif /* EXCEPTION_HANDLING */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/


time.c/         1148595159  0     0     0       543       `
/*****************************************************************************/

/*  TIME.C v3.3.2                                                            */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/

#include <time.h> 



extern _CODE_ACCESS time_t HOSTtime();



_CODE_ACCESS time_t time(time_t *timer) 

{

   time_t result;



   result = (time_t)HOSTtime();

   if(timer) *timer = result;

   return(result);

}




time.h/         1148595159  0     0     0       3506      `
/*****************************************************************************/

/* time.h     v3.3.2                                                         */

/* Copyright (c) 1990-2006  Texas Instruments Incorporated                   */

/*****************************************************************************/



#ifndef _TIME

#define _TIME



#include <linkage.h>



#define CLOCKS_PER_SEC 200000000 /* 200 MHz */



#ifndef NULL

#define NULL      0

#endif



#ifdef __cplusplus

extern "C" namespace std {

#endif



typedef unsigned long clock_t;

typedef unsigned long time_t;



#ifndef _SIZE_T

#define _SIZE_T

typedef __SIZE_T_TYPE__ size_t;

#endif



struct tm 

{

    int tm_sec;      /* seconds after the minute   - [0,59]  */

    int tm_min;      /* minutes after the hour     - [0,59]  */

    int tm_hour;     /* hours after the midnight   - [0,23]  */

    int tm_mday;     /* day of the month           - [1,31]  */

    int tm_mon;      /* months since January       - [0,11]  */

    int tm_year;     /* years since 1900                     */

    int tm_wday;     /* days since Sunday          - [0,6]   */

    int tm_yday;     /* days since Jan 1st         - [0,365] */

    int tm_isdst;    /* Daylight Savings Time flag           */

};



/*************************************************************************/

/* TIME ZONE STRUCTURE DEFINITION                                        */

/*************************************************************************/

typedef struct 

{

    short daylight;

    long  timezone;

    char  tzname[4];

    char  dstname[4];

} TZ;



extern _DATA_ACCESS TZ _tz;



/****************************************************************************/

/* FUNCTION DECLARATIONS.  (NOTE : clock AND time ARE SYSTEM SPECIFIC)      */

/****************************************************************************/

_CODE_ACCESS clock_t    clock(void);             

_CODE_ACCESS time_t     time(time_t *_timer);   

 

_CODE_ACCESS time_t     mktime(struct tm *_tptr);

_CODE_ACCESS double     difftime(time_t _time1, time_t _time0);

      _IDECL char      *ctime(const time_t *_timer);

_CODE_ACCESS char      *asctime(const struct tm *_timeptr);

_CODE_ACCESS struct tm *gmtime(const time_t *_timer);

_CODE_ACCESS struct tm *localtime(const time_t *_timer);

_CODE_ACCESS size_t     strftime(char *_out, size_t _maxsize, 

				 const char *_format,

				 const struct tm *_timeptr);



#if defined(_INLINE) || defined(_CTIME_)



_IDEFN char *ctime(const time_t *timer)

{

   return(asctime(localtime(timer)));

}



#endif /* _INLINE || _CTIME_ */



#ifdef __cplusplus

} /* extern "C" */



#ifndef _CPP_STYLE_HEADER

using std::clock_t;

using std::time_t;

using std::size_t;

using std::tm;

using std::TZ;

using std::_tz;

using std::clock;

using std::time;

using std::mktime;

using std::difftime;

using std::ctime;

using std::asctime;

using std::gmtime;

using std::localtime;

using std::strftime;

#endif /* ! _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#else



#ifdef __cplusplus



#ifndef _CPP_STYLE_HEADER

using std::clock_t;

using std::time_t;

using std::size_t;

using std::tm;

using std::TZ;

using std::_tz;

using std::clock;

using std::time;

using std::mktime;

using std::difftime;

using std::ctime;

using std::asctime;

using std::gmtime;

using std::localtime;

using std::strftime;

#endif /* ! _CPP_STYLE_HEADER */



#endif /* __cplusplus */



#endif /* _TIME */

tmpfile.c/      1148595159  0     0     0       1371      `
/*****************************************************************************/

/*  TMPFILE.C v3.3.2                                                         */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    TMPFILE  -  Create a temporary file, and return a pointer to the       */

/*                stream                                                     */

/*****************************************************************************/

#include <stdio.h>

#include "file.h"

#include <string.h>





/*****************************************************************************/

/* TMPFILE  -  Create a temporary file, and return a pointer to its FILE     */

/*             structure                                                     */

/*****************************************************************************/

_CODE_ACCESS FILE *tmpfile(void)

{

   char tfname[L_tmpnam];

   FILE *_fp = (tmpnam(tfname)) ? (fopen(tfname, "wb+")) : NULL;



   if(_fp)

   {

      _SET(_fp, _TMPFILE);

      strcpy(_tmpnams[_fp->fd], tfname);

   }



   return (_fp);

}




tmpnam.c/       1148595159  0     0     0       4110      `
/*****************************************************************************/

/*  TMPNAM.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    TMPNAM   -  Generate a unique filename                                 */

/*    _GETNAME -  Generate the character string for the filename             */

/*****************************************************************************/

#include <stdio.h>

#include "file.h"

#include <string.h>



static char *_getname(int cnt, char *result);





/*****************************************************************************/

/* TMPNAM   -  Generate a unique filename                                    */

/*                                                                           */

/*    This function generates a unique filename, and can be called up to     */

/*    TMP_MAX times.                                                         */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS char *tmpnam(char *_s)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   static _DATA_ACCESS unsigned int  counter = 0;

   static _DATA_ACCESS char tfname[L_tmpnam];

   int  fd;

 

   /*------------------------------------------------------------------------*/ 

   /* Get a filename from _GETNAME                                           */

   /*------------------------------------------------------------------------*/ 

   _getname(counter++, tfname);



   /*------------------------------------------------------------------------*/ 

   /* Check to see if the filename exists.  Keep getting filenames until     */

   /* a unique one is found, or this function has reached its limit.         */

   /*------------------------------------------------------------------------*/ 

   while(((fd=open(tfname, O_RDONLY, 0666)) >= 0) && (counter < TMP_MAX))

   {

      close(fd);

      _getname(counter++, tfname);

   }

 

   if(counter >= TMP_MAX) return (NULL);

 

   /*------------------------------------------------------------------------*/ 

   /* If _S is not NULL, store the new filename in it.                       */

   /*------------------------------------------------------------------------*/ 

   if(_s)

   {

      strcpy(_s, tfname);

      return (_s);

   }

 

   return (tfname);

}





/*****************************************************************************/

/* _GETNAME -  Generate the character string for the filename                */

/*                                                                           */

/*    This function takes a number passed to it by TMPNAM, and generates a   */

/*    filename from it.  It returns a pointer to the filename.               */

/*                                                                           */

/*****************************************************************************/

static char *_getname(int cnt, char *result)

{

   /*------------------------------------------------------------------------*/

   /* Local variables                                                        */

   /*------------------------------------------------------------------------*/

   char *end   = result + L_tmpnam -1;

   char *spos;

 

   strcpy(result, P_tmpdir);

   spos = (result + strlen(result));

 

   *(spos++) = 'T';

 

   for(;cnt; cnt /= 10) *(spos++) = ((cnt % 10)+ '0');

 

   for(;spos < end; *(spos++)='0');

   *(end--) = '\0';

 

   return (result);

}



tmzone.c/       1148595159  0     0     0       553       `
/*****************************************************************************/

/*  _tz v3.3.2                                                               */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                  */

/*****************************************************************************/

#include <time.h>



_DATA_ACCESS TZ _tz =

{

   0,                       /* daylight */

   21600,                   /* timezone */

   "CST",                   /* tzname   */

   "DST",                   /* dstname  */

};




toascii.c/      1148595159  0     0     0       426       `
/****************************************************************************/

/*  toascii v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int toascii(int c)

{

    return(_toascii(c));

}



tolower.c/      1148595159  0     0     0       424       `
/****************************************************************************/

/*  tolower v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int tolower(int c)

{

    return(_tolower(c));

}

toupper.c/      1148595159  0     0     0       426       `
/****************************************************************************/

/*  toupper v3.3.2                                                          */

/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

#undef _INLINE

#include <ctype.h> 



_CODE_ACCESS int toupper(int c)

{

    return(_toupper(c));

}



trgcio.h/       1148595159  0     0     0       4902      `
/*****************************************************************************/

/*  TRGCIO.H v3.3.2                                                          */

/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/*  This file contains OTIS-driven CIO constant definitions                  */

/*****************************************************************************/



/*---------------------------------------------------------------------------*/

/* constants for the data transfer functions for the predefined driver       */

/*---------------------------------------------------------------------------*/

#define _DTOPEN    (0xF0)

#define _DTCLOSE   (0xF1)

#define _DTREAD    (0xF2)

#define _DTWRITE   (0xF3)

#define _DTLSEEK   (0xF4)

#define _DTUNLINK  (0xF5)

#define _DTGETENV  (0xF6)

#define _DTRENAME  (0xF7)

#define _DTGETTIME (0xF8)

#define _DTGETCLK  (0xF9)

#define _DTSYNC    (0xFF)



#define CIOBUFSIZ BUFSIZ+32



#if 1 && !defined(__TMS320C55X_PLUS_BYTE__)

/*---------------------------------------------------------------------------*/

/* THESE MACROS PACK AND UNPACK SHORTS AND LONGS INTO CHARACTER ARRAYS       */

/*                                                                           */

/* THIS IS DONE BYTE REVERSED TO MAKE THE PC'S JOB EASIER AND SINCE THE      */

/*     DEVICE COULD BE BIG OR LITTLE ENDIAN                                  */

/*---------------------------------------------------------------------------*/

#define LOADSHORT(x,y,z)  { x[(z)]   = ((unsigned short) (y) & 0xFF); \

                            x[(z)+1] = ((unsigned short) ((y) >> 8) & 0xFF);  }



#define UNLOADSHORT(x,z)   ((short) ( (((long) x[(z)]   << 16) + \

			               ((long) x[(z)+1] << 24)) >> 16))



#define LOAD32(x,y,z) { x[(z)]   = ((unsigned short) (y) & 0xFF); \

                          x[(z)+1] = ((unsigned short) ((y) >> 8) & 0xFF); \

                          x[(z)+2] = ((unsigned short) ((y) >> 16) & 0xFF);  \

                          x[(z)+3] = ((unsigned short) ((y) >> 24) & 0xFF);   }



#define UNLOAD32(x,z) ( ((long) x[(z)])                   +  \

                        ((unsigned long) x[(z)+1] << 8)   +  \

                        ((unsigned long) x[(z)+2] << 16)  +  \

                        ((unsigned long) x[(z)+3] << 24))



/*---------------------------------------------------------------------------*/

/* THESE MACROS CAN BE USED TO PACK AND UNPACK CHARACTER STREAMS INTO TARGET */

/* WORDS FOR MORE EFFICIENT TRANSFER.                                        */

/*---------------------------------------------------------------------------*/

#define PACKCHAR(val, base, byte) ( ((byte)%2 == 0) ?  \

	 (*((base) + ((byte)/2)) = ((val) & 0xFF) << (((byte+1)%2) * 8)) : \

	 (*((base) + ((byte)/2)) |= ((val) & 0xFF)))



#define UNPACKCHAR(base, byte) \

         ( (*((base) + ((byte)/2)) >> (((byte+1)%2) * 8)) & 0xFF )



#define BSSCIOBUF 1

#endif /* TMS320C55XX */









#if 0 || 0 || 0 || 0 || defined(__TMS320C55X_PLUS_BYTE__)

/*---------------------------------------------------------------------------*/

/* THESE MACROS PACK AND UNPACK SHORTS AND LONGS INTO CHARACTER ARRAYS       */

/*                                                                           */

/* THIS IS DONE BYTE REVERSED TO MAKE THE PC'S JOB EASIER AND SINCE THE      */

/*     DEVICE COULD BE BIG OR LITTLE ENDIAN                                  */

/*---------------------------------------------------------------------------*/

#define LOADSHORT(x,y,z)  { x[(z)]   = (unsigned short) (y); \

                            x[(z)+1] = (unsigned short) (y) >> 8;  }



#define UNLOADSHORT(x,z) ((short) ( (short) x[(z)] +             \

				   ((short) x[(z)+1] << 8)))



#define LOAD32(x,y,z) { x[(z)]   = (unsigned long) (y); \

                          x[(z)+1] = (unsigned long) (y) >> 8; \

                          x[(z)+2] = (unsigned long) (y) >> 16;  \

                          x[(z)+3] = (unsigned long) (y) >> 24;   }



#define UNLOAD32(x,z) ( (long) x[(z)]           +  \

                         ((long) x[(z)+1] << 8)   +  \

                         ((long) x[(z)+2] << 16)  +  \

			 ((long) x[(z)+3] << 24))



/*---------------------------------------------------------------------------*/

/* THESE MACROS CAN BE USED TO PACK AND UNPACK CHARACTER STREAMS INTO TARGET */

/* WORDS FOR MORE EFFICIENT TRANSFER.                                        */

/*---------------------------------------------------------------------------*/

#define PACKCHAR(val, base, byte) ( (base)[(byte)] = (val) )



#define UNPACKCHAR(base, byte)    ( (base)[byte] )



#define BSSCIOBUF 0

#endif 







trgdrv.c/       1148595159  0     0     0       7800      `
/*****************************************************************************/

/*  TRGDRV.C v3.3.2                                                          */

/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/****************************************************************************/

/* Functions:                                                               */

/*    HOSTopen()    -    Sends open command with arguments to the host      */

/*    HOSTclose()   -    Sends close command with arguments to the host     */

/*    HOSTread()    -    Sends read command with arguments to the host      */

/*    HOSTwrite()   -    Sends write command with arguments to the host     */

/*    HOSTlseek()   -    Sends lseek command with arguments to the host     */

/*    HOSTunlink()  -    Sends unlink command with arguments to the host    */

/*    HOSTrename()  -    Sends rename command with arguments to the host    */

/*    GETENV()      -    Get the enviroment value for the passed variable   */

/*                        name                                              */

/*    HOSTTIME()    -    Get the time from the host                         */

/*    HOSTCLK()     -    Get the target clock value (CLK register)          */

/****************************************************************************/

#include <stdio.h>

#include <string.h>

#include <time.h>



#include "file.h"

#include "_lock.h"



#include "trgcio.h"



#if defined(REDUCE_GETENV_BUFSIZE)

#define GETENV_VALUE_BUFSIZE 128

#else

#define GETENV_VALUE_BUFSIZE 200

#endif



extern _CODE_ACCESS int HOSTopen(const char *path, unsigned flags, int llv_fd),

                        HOSTclose(int dev_fd),

                        HOSTread(int dev_fd, char *buf, unsigned count),

                        HOSTwrite(int dev_fd, const char *buf, unsigned count),

                        HOSTunlink(const char *path),

                        HOSTrename(const char *old_name, const char *new_name);



extern _CODE_ACCESS off_t HOSTlseek(int dev_fd, off_t offset, int origin);

extern _CODE_ACCESS time_t HOSTtime(void);

extern _CODE_ACCESS clock_t HOSTclock(void);



extern _CODE_ACCESS void readmsg(register unsigned char *parm,

				 register char *data);



extern _CODE_ACCESS void writemsg(unsigned char  command,

                                  register const unsigned char *parm,

                                  register const          char *data,

                                  unsigned int   length);



static _DATA_ACCESS unsigned char parmbuf[8];



/****************************************************************************/

/* HOSTOPEN()  -  Pass the open command and its arguments to the host.      */

/****************************************************************************/

_CODE_ACCESS int HOSTopen(const char *path, unsigned flags, int llv_fd)

{

   int dev_fd;

   _lock();



   LOADSHORT(parmbuf,llv_fd,0);

   LOADSHORT(parmbuf,flags,2);

   writemsg(_DTOPEN,parmbuf,(char *)path,strlen(path)+1);

					 /* SEND NULL ACROSS ALSO */

   readmsg(parmbuf,NULL);



   dev_fd = UNLOADSHORT(parmbuf,0);

   _unlock();

   return (dev_fd < 0) ? dev_fd : llv_fd;

}



/****************************************************************************/

/* HOSTCLOSE()  -  Pass the close command and its arguments to the host.    */

/****************************************************************************/

_CODE_ACCESS int HOSTclose(int dev_fd)

{

   int result;

   _lock();



   LOADSHORT(parmbuf,dev_fd,0);



   writemsg(_DTCLOSE,parmbuf,NULL,0);

   readmsg(parmbuf,NULL);



   result = UNLOADSHORT(parmbuf,0);

   _unlock();

   return result;

}



/****************************************************************************/

/* HOSTREAD()  -  Pass the read command and its arguments to the host.      */

/****************************************************************************/

_CODE_ACCESS int HOSTread(int dev_fd, char *buf, unsigned count)

{

   int result;

   _lock();



   if (count > BUFSIZ) count = BUFSIZ;



   LOADSHORT(parmbuf,dev_fd,0);

   LOADSHORT(parmbuf,count,2);



   writemsg(_DTREAD,parmbuf,NULL,0);

   readmsg(parmbuf,buf);



   result = UNLOADSHORT(parmbuf,0);

   _unlock();

   return result;

}



/****************************************************************************/

/* HOSTWRITE()  -  Pass the write command and its arguments to the host.    */

/****************************************************************************/

_CODE_ACCESS int HOSTwrite(int dev_fd, const char *buf, unsigned count)

{

   int result;

   _lock();



   if (count > BUFSIZ) count = BUFSIZ;



   LOADSHORT(parmbuf,dev_fd,0);

   LOADSHORT(parmbuf,count,2);

   writemsg(_DTWRITE,parmbuf,(char *)buf,count);

   readmsg(parmbuf,NULL);



   result = UNLOADSHORT(parmbuf,0);

   _unlock();

   return result;

}



/****************************************************************************/

/* HOSTLSEEK()  -  Pass the lseek command and its arguments to the host.    */

/****************************************************************************/

_CODE_ACCESS off_t HOSTlseek(int dev_fd, off_t offset, int origin)

{

   off_t result;

   _lock();



   LOADSHORT(parmbuf,dev_fd,0);

   LOAD32(parmbuf,offset,2);

   LOADSHORT(parmbuf,origin,6);



   writemsg(_DTLSEEK,parmbuf,NULL,0);

   readmsg(parmbuf,NULL);



   result = UNLOAD32(parmbuf,0);

   _unlock();

   return result;

}



_CODE_ACCESS int HOSTunlink(const char *path)

{

   int result;

   _lock();



   writemsg(_DTUNLINK,parmbuf,(char *)path,strlen(path) + 1);

   readmsg(parmbuf,NULL);



   result = UNLOADSHORT(parmbuf,0);

   _unlock();

   return result;

}



_CODE_ACCESS int HOSTrename(const char *old, const char *new)

{

   char combined[100];

   int  length; 

   int  result;

   _lock();



   strcpy(combined,old);

   length = strlen(old)+1;

   strcpy(combined+length,new);

   length += strlen(new) + 1;



   writemsg(_DTRENAME,parmbuf,combined,length);

                                                 /*SEND NULL ACROSS ALSO*/

   readmsg(parmbuf,NULL);



   result = UNLOADSHORT(parmbuf,0);

   _unlock();

   return result;

}



/****************************************************************************/

/* GETENV()  -  Get the enviroment value for the passed variable name       */

/****************************************************************************/

_CODE_ACCESS char *getenv(const char *_string)

{

   static _DATA_ACCESS char result[GETENV_VALUE_BUFSIZE];



   _lock();



   writemsg(_DTGETENV,parmbuf,(char *)_string,strlen(_string) + 1);

   readmsg(parmbuf,result);



   _unlock();

   return strlen(result) ? result : 0;

}



/****************************************************************************/

/* HOSTTIME()  -  Get the time from the host                                */

/****************************************************************************/

_CODE_ACCESS time_t HOSTtime(void)

{

   time_t result;

   _lock();



   writemsg(_DTGETTIME,parmbuf,NULL,0);

   readmsg(parmbuf, NULL);



   result = (time_t)(UNLOAD32(parmbuf,0));

   _unlock();

   return result;

}



/****************************************************************************/

/* HOSTclock()  -  Get the current number of clock ticks                    */

/****************************************************************************/

_CODE_ACCESS clock_t HOSTclock(void)

{

   clock_t result;

   _lock();



   writemsg(_DTGETCLK,parmbuf,NULL,0);

   readmsg(parmbuf, NULL);



   result = (clock_t)(UNLOAD32(parmbuf,0));

   _unlock();

   return result;

}

trgmsg.c/       1148595159  0     0     0       6080      `
/*****************************************************************************/

/*  TRGMSG.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Bottom level data transfer routines for host communication with the       */

/* target.                                                                   */

/*                                                                           */

/* Functions:                                                                */

/*  writemsg()  -  Sends the passed data and parameters on to the host.      */

/*  readmsg()   -  Reads the data and parameters passed from the host.       */

/*****************************************************************************/

#include "stdio.h"

#include "trgcio.h"



/*****************************************************************************/

/* Allow the user the options of placing this code in RAM so the debugger    */

/* does not give errors about setting breakpoints when loading code into     */

/* non-writeable memory.                                                     */ 

/*****************************************************************************/

#pragma CODE_SECTION(writemsg, ".text:CIO_breakpoint")



#if BSSCIOBUF

/*#define DEFCIO(size) unsigned char _CIOBUF_[size]*/

#define STR(x) #x

#define DEFCIO(size) __asm("__CIOBUF_: .usect  .cio," STR(size) ",4"); \

		     extern volatile unsigned char _CIOBUF_[size]





#elif defined(_MVP_PP) || defined(_MVP_MP)

#pragma SHARED   (_CIOBUF_);

#pragma DATA_SECTION (_CIOBUF_, ".cio");

#pragma DATA_ALIGN   (_CIOBUF_, 4);

#define DEFCIO(size) volatile unsigned char _CIOBUF_[size]



#elif defined(_TMS370C8)

#define STR(x) #x

#define DEFCIO(size) __asm("__CIOBUF_: .usect  .cio," STR(size)); \

		     extern far volatile unsigned char _CIOBUF_[size]



#else

#define STR(x) #x

#define DEFCIO(size) __asm("__CIOBUF_: .usect  .cio," STR(size) ",4"); \

		     extern volatile unsigned char _CIOBUF_[size]

#endif



DEFCIO(CIOBUFSIZ);



/***************************************************************************/

/*                                                                         */

/*  WRITEMSG()  -  Sends the passed data and parameters on to the host.    */

/*                                                                         */

/***************************************************************************/

void writemsg(unsigned char                 command,

              register const unsigned char *parm,

              register const char          *data,

              unsigned int                  length)

{

    register volatile unsigned char * p = (volatile unsigned char *) _CIOBUF_;



    register unsigned int i;



    /***********************************************************************/

    /* THE LENGTH IS WRITTEN AS A TARGET INT                               */

    /***********************************************************************/ 

    *(unsigned int *)p = length; 

    p += sizeof(unsigned int);



    /***********************************************************************/ 

    /* THE COMMAND IS WRITTEN AS A TARGET BYTE                             */

    /***********************************************************************/ 

    *p++ = command;



    /***********************************************************************/ 

    /* PACK THE PARAMETERS AND DATA SO THE HOST READS IT AS BYTE STREAM    */

    /***********************************************************************/ 

    for (i = 0; i < 8; i++)      PACKCHAR(*parm++, p, i);

    for (i = 0; i < length; i++) PACKCHAR(*data++, p, i+8);



    /***********************************************************************/ 

    /* THE EMULATOR BREAKPOINTS IN DECODE PHASE, SO HAVE TO ADD IN SOME    */

    /* NOPS TO MAKE SURE LAST REAL INSTRUCTION COMPLETES BEFORE BREAKPOINT */

    /***********************************************************************/ 

    __asm("	nop");

    __asm("	nop");

    __asm("	nop");



    /***********************************************************************/

    /* THE BREAKPOINT THAT SIGNALS THE HOST TO DO DATA TRANSFER            */

    /***********************************************************************/

#if defined(EMBED_CIO_BP)

    __asm("	.global	C$$IOE$$");

    __asm("	estop_1()");

    __asm("C$$IOE$$:nop");

#else

    __asm("	.global	C$$IO$$");

    __asm("	nop");

    __asm("C$$IO$$:nop");

#endif



}



/***************************************************************************/

/*                                                                         */

/*  READMSG()   -  Reads the data and parameters passed from the host.     */

/*                                                                         */

/***************************************************************************/

void readmsg(register unsigned char *parm,

             register char          *data)

{

    register volatile unsigned char * p = (volatile unsigned char *) _CIOBUF_;



    register unsigned int i;

    unsigned int length;



    /***********************************************************************/

    /* THE LENGTH IS READ AS A TARGET INT                                  */

    /***********************************************************************/

    length = *(unsigned int *)p;

    p += sizeof(unsigned int);

    

    /***********************************************************************/

    /* UNPACK THE PARAMETERS AND DATA                                      */

    /***********************************************************************/

    for (i = 0; i < 8; i++) *parm++ = UNPACKCHAR(p, i);

    if (data != NULL) 

       for (i = 0; i < length; i++) *data++ = UNPACKCHAR(p, i+8);

}

trunc.c/        1148595159  0     0     0       617       `
/****************************************************************************/

/*  trunc.c          v3.3.2                                                 */

/*  Copyright (c) 1997-2006  Texas Instruments Incorporated                 */

/****************************************************************************/

 

/* This source automatically generated on Thu Jul 10 17:56:02 CDT 2003 */

 

#include "reald.h"



 REAL TRUNCF(REAL x)

{



   if (GEQF(x,CNST(-32768.0)) && LSSF(x,CNST( 32768.0))) return FLTIF(FIXFI(x));



   {

      REAL ip;

      MODFF(x,&ip);

      return ip;

   }

} /* TRUNCF */


typeinfo/       1148595159  0     0     0       1790      `
/*****************************************************************************/

/* typeinfo  v3.3.2                                                          */

/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/

#if __EXCEPTIONS

#define THROW(throw_spec) throw(throw_spec)

#define THROW_NOTHING() throw()

#else /* !__EXCEPTIONS */

#define THROW(throw_spec) /* Nothing. */

#define THROW_NOTHING() /* Nothing. */

#endif /* __EXCEPTIONS */





#ifndef _TYPEINFO

#define _TYPEINFO



#ifndef __embedded_cplusplus



#include <stdexcept>

namespace std 

{



#if __EXCEPTIONS

   class bad_cast : public exception {

      public:

	 bad_cast() throw();

	 bad_cast(const bad_cast&) throw();

	 bad_cast& operator=(const bad_cast&) throw();

	 virtual ~bad_cast() throw();

	 virtual const char* what() const throw();

   };



   class bad_typeid : public exception {

      public:

	 bad_typeid() throw();

	 bad_typeid(const bad_typeid&) throw();

	 bad_typeid& operator=(const bad_typeid&) throw();

	 virtual ~bad_typeid() throw();

	 virtual const char* what() const throw();

   };

#endif /* __EXCEPTIONS */



#pragma define_type_info

   class type_info 

   {

      public:

	 virtual ~type_info();

	 bool operator==(const type_info& rhs) const;

	 bool operator!=(const type_info& rhs) const;

	 bool before( const type_info& rhs) const;

	 const char* name() const;

      protected:

	 type_info(const type_info& rhs);

      private:

	 type_info& operator=(const type_info& rhs);



#ifdef __EDG_IA64_ABI

  private:

    const char *__type_name;

#endif /* ifdef __EDG_IA64_ABI */

   };



}

#endif /* __embedded_cplusplus */

#endif /*_TYPEINFO */



typeinfo_.cpp/  1148595159  0     0     0       9998      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Run-time type identification -- user callable functions.



*/



#include "basics.h"

#include "runtime.h"



#if ABI_CHANGES_FOR_RTTI



#include "rtti.h"

#include <typeinfo>



/*

If the runtime should be defined in the std namespace, open

the std namespace.

*/

#ifdef __EDG_RUNTIME_USES_NAMESPACES

namespace std {

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */





__bool type_info::operator==(const type_info& rhs) const

/*

Return TRUE if two type_info structures refer to the same type.

*/

{

  a_type_info_impl_ptr  tiip1;

  a_type_info_impl_ptr  tiip2;



  tiip1 = (a_type_info_impl_ptr)this;

  tiip2 = (a_type_info_impl_ptr)&rhs;

  return matching_type_info(tiip1, tiip2);

}  /* type_info::operator== */





__bool type_info::operator!=(const type_info& rhs) const

/*

Return TRUE if two type_info structures do not refer to the same type.

*/

{

  a_type_info_impl_ptr  tiip1;

  a_type_info_impl_ptr  tiip2;



  tiip1 = (a_type_info_impl_ptr)this;

  tiip2 = (a_type_info_impl_ptr)&rhs;

  return !matching_type_info(tiip1, tiip2);

}  /* type_info::operator!= */





__bool type_info::before(const type_info& rhs) const

/*

Return TRUE if the type_info for *this precedes the type_info for rhs using

some implementation dependent collating sequence.

*/

{

#ifdef __EDG_IA64_ABI

  /* Do the comparison based on the address at which the type name string

     is allocated.  The name string is guaranteed by the ABI to be unique. */

  return __type_name < rhs.__type_name;

#else /* defined(__EDG_IA64_ABI) */

  /* This is implemented by comparing the pointers used to represent the type

     information.  If the type_info_impl has a unique_id, the address of the

     unique_id is used for collation.  If it does not have a unique_id (i.e.,

     we know there is only a single type_info_impl structure for the type) then

     the address of the single type_info_impl is used for collation. */

  a_type_info_impl_ptr  tiip1;

  a_type_info_impl_ptr  tiip2;

  void*                 ptr1;

  void*                 ptr2;



  tiip1 = (a_type_info_impl_ptr)this;

  tiip2 = (a_type_info_impl_ptr)&rhs;

  ptr1 = tiip1->unique_id != NULL ? (void*)tiip1->unique_id : (void*)tiip1;

  ptr2 = tiip2->unique_id != NULL ? (void*)tiip2->unique_id : (void*)tiip2;

  return ptr1 < ptr2;

#endif /* defined(__EDG_IA64_ABI) */

}  /* type_info::before */





const char * type_info::name() const

/*

Returns a pointer to the name string for this type.

*/

{

#ifndef __EDG_IA64_ABI

  a_type_info_impl_ptr  tiip1;



  tiip1 = (a_type_info_impl_ptr)this;

  return tiip1->name;

#else /* defined(__EDG_IA64_ABI) */

  return __type_name;

#endif /* defined(__EDG_IA64_ABI) */

}  /* type_info::name */





type_info::~type_info()

/*

Destructor for type_info.  This should never actually be called.

*/

{

}  /* type_info::~type_info */





/* The definition of the exception classes can be disabled. */

#if USE_EDG_EXCEPTION_CLASSES



#if EXCEPTION_HANDLING



/*

The bad_cast class is only supplied when the runtime supports exception

handling.

*/

bad_cast::bad_cast() THROW_NOTHING()

/*

Constructor for bad_cast.

*/

{

}  /* bad_cast::bad_cast */





bad_cast::bad_cast(const bad_cast& rhs) THROW_NOTHING() : exception(rhs)

/*

Copy constructor for bad_cast.  Currently does nothing.

*/

{

}  /* bad_cast::bad_cast */





bad_cast& bad_cast::operator=(const bad_cast& rhs) THROW_NOTHING()

/*

Assignment operator for bad_cast.  Currently does nothing.

*/

{

  /* Call the base class assignment operator. */

  exception::operator=(rhs);

  return *this;

}  /* bad_cast::operator= */





bad_cast::~bad_cast() THROW_NOTHING()

/*

Destructor for bad_cast.

*/

{

}  /* bad_cast::~bad_cast */





const char* bad_cast::what() const THROW_NOTHING()

/*

Return a string providing information about the exception.  Currently,

no additional information is available.

*/

{

  return "";

}  /* bad_cast::~bad_cast */





bad_typeid::bad_typeid() THROW_NOTHING()

/*

Constructor for bad_typeid.

*/

{

}  /* bad_typeid::bad_typeid */





bad_typeid::bad_typeid(const bad_typeid& rhs) THROW_NOTHING() : exception(rhs)

/*

Copy constructor for bad_typeid.  Currently does nothing.

*/

{

}  /* bad_typeid::bad_typeid */





bad_typeid& bad_typeid::operator=(const bad_typeid& rhs) THROW_NOTHING()

/*

Assignment operator for bad_typeid.  Currently does nothing.

*/

{

  /* Call the base class assignment operator. */

  exception::operator=(rhs);

  return *this;

}  /* bad_typeid::operator= */





bad_typeid::~bad_typeid() THROW_NOTHING()

/*

Destructor for bad_typeid.

*/

{

}  /* bad_typeid::~bad_typeid */





const char* bad_typeid::what() const THROW_NOTHING()

/*

Return a string providing information about the exception.  Currently,

no additional information is available.

*/

{

  return "";

}  /* bad_typeid::~bad_typeid */



#endif /* EXCEPTION_HANDLING */



#endif /* USE_EDG_EXCEPTION_CLASSES */



#ifdef __EDG_IA64_ABI



/*

Define the type_info objects that are supposed to be present in the runtime

library.  Try to work hard enough that the compiler won't eliminate the

generation of the type_info objects.

*/

const type_info *__dummy_typeinfo;

void __gen_dummy_typeinfos()

{

#define gen_typeinfos(type)                 \

  __dummy_typeinfo = &typeid(type),         \

  __dummy_typeinfo = &typeid(type *),       \

  __dummy_typeinfo = &typeid(const type *)

  gen_typeinfos(void); 

  gen_typeinfos(bool); 

  gen_typeinfos(wchar_t);

  gen_typeinfos(char); 

  gen_typeinfos(signed char); gen_typeinfos(unsigned char); 

  gen_typeinfos(short);       gen_typeinfos(unsigned short); 

  gen_typeinfos(int);         gen_typeinfos(unsigned int); 

  gen_typeinfos(long);        gen_typeinfos(unsigned long); 

  gen_typeinfos(long long);   gen_typeinfos(unsigned long long);

  gen_typeinfos(float); 

  gen_typeinfos(double); 

  gen_typeinfos(long double);

#undef gen_typeinfos

}

  

#endif /* ifdef __EDG_IA64_ABI */



/*

If the runtime should be defined in the std namespace, close

the std namespace.

*/

#ifdef __EDG_RUNTIME_USES_NAMESPACES

}  /* namespace std */

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



#ifdef __EDG_IA64_ABI

#ifdef __EDG_RUNTIME_USES_NAMESPACES

namespace __cxxabiv1 {

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */



__fundamental_type_info::~__fundamental_type_info()

/*

Destructor for __fundamental_type_info.  This should never actually be 

called.  

*/

{

}  /* __fundamental_type_info::~__fundamental_type_info */





__array_type_info::~__array_type_info()

/*

Destructor for __array_type_info.  This should never actually be 

called.  

*/

{

}  /* __array_type_info::~__array_type_info */





__function_type_info::~__function_type_info()

/*

Destructor for __function_type_info.  This should never actually be 

called.  

*/

{

}  /* __function_type_info::~__function_type_info */





__enum_type_info::~__enum_type_info()

/*

Destructor for __enum_type_info.  This should never actually be 

called.  

*/

{

}  /* __enum_type_info::~__enum_type_info */





__class_type_info::~__class_type_info()

/*

Destructor for __class_type_info.  This should never actually be 

called.  

*/

{

}  /* __class_type_info::~__class_type_info */





__si_class_type_info::~__si_class_type_info()

/*

Destructor for __si_class_type_info.  This should never actually be 

called.  

*/

{

}  /* __si_class_type_info::~__si_class_type_info */





__vmi_class_type_info::~__vmi_class_type_info()

/*

Destructor for __vmi_class_type_info.  This should never actually be 

called.  

*/

{

}  /* __vmi_class_type_info::~__vmi_class_type_info */





__pbase_type_info::~__pbase_type_info()

/*

Destructor for __pbase_type_info.  This should never actually be 

called.  

*/

{

}  /* __pbase_type_info::~__pbase_type_info */





__pointer_type_info::~__pointer_type_info()

/*

Destructor for __pointer_type_info.  This should never actually be 

called.  

*/

{

}  /* __pointer_type_info::~__pointer_type_info */





__pointer_to_member_type_info::~__pointer_to_member_type_info()

/*

Destructor for __pointer_to_member_type_info.  This should never actually be 

called.  

*/

{

}  /* __pointer_to_member_type_info::~__pointer_to_member_type_info */



#ifdef __EDG_RUNTIME_USES_NAMESPACES

}  /* namespace __cxxabiv1 */

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

#endif /* ifdef __EDG_IA64_ABI */



#endif /* ABI_CHANGES_FOR_RTTI */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

udiv.asm/       1148595159  0     0     0       3270      `
;******************************************************************************

;* udiv.asm  v3.3.2

;* Copyright (c) 1997-2006 Texas Instruments Incorporated

;******************************************************************************

	.include "c55xasm.i"

	.mmregs

	.cpl_on

	.arms_on

	.model  call=internal ; This function is recognized by name 

			      ; in the compiler.



******************************************************************************

* 16-BIT UNSIGNED DIVIDE

*

* arg1 	 : dividend - T0  (U)

* arg2 	 : divisor  - T1  (V)

* return : quotient - T0  (Q == U / V)

*

*

* WARNING!  Changes to register defs in this function must be reflected in

* the constraint class DIVU_SET in ld3.md

******************************************************************************

	.global	I$$UDIV

	.global __divu



I$$UDIV:	.asmfunc

__divu:

******************************************************************************

* PREPARATION

******************************************************************************

	SP = SP - #1

	bit(ST1, #ST1_SXMD) = #0 	; turn off SXM mode

	AC0 = T0			; Move Q to AC0

||	*SP(#0) = T1			; Store Divisor in memory



******************************************************************************

* PERFORM DIVIDE

******************************************************************************

	repeat(#15)             	; repeat 16 times

	subc(*SP(#(0)), AC0, AC0)       ; divide step



******************************************************************************

* QUOTIENT IS IN LO(AC0), REMAINDER IS IN HI(AC0)

******************************************************************************

	bit(ST1, #ST1_SXMD) = #1 	; turn on SXM mode

	T0 = AC0 			; discard remainder

	SP = SP + #1



	return                  	; return

	.endasmfunc



******************************************************************************

* 16-BIT UNSIGNED MODULUS

*

* arg1 	 : dividend  - T0  (U)

* arg2 	 : divisor   - T1  (V)

* return : remainder - T0  (Q == U % V)

*

*

* WARNING!  Changes to register defs in this function must be reflected in

* the constraint class REMU_SET in ld3.md

******************************************************************************

	.global	I$$UMOD

	.global __remu



I$$UMOD:	.asmfunc

__remu:

******************************************************************************

* PREPARATION

******************************************************************************

	SP = SP - #1

	bit(ST1, #ST1_SXMD) = #0 	; turn off SXM mode

	AC0 = T0			; Move Q to AC0

||	*SP(#0) = T1			; Store Divisor in memory



******************************************************************************

* PERFORM DIVIDE

******************************************************************************

	repeat(#15)             	; repeat 16 times

	subc(*SP(#(0)), AC0, AC0)       ; divide step



******************************************************************************

* QUOTIENT IS IN LO(AC0), REMAINDER IS IN HI(AC0)

******************************************************************************

	bit(ST1, #ST1_SXMD) = #1 	; turn on SXM mode

	T0 = HI(AC0)		      	; extract remainder from AC0_H

	SP = SP + #1



	return                 		; return

	.endasmfunc

unaccess.h/     1148595159  0     0     0       36        `
/* unaccess.h: Empty by default */

ungetc.c/       1148595159  0     0     0       3503      `
/*****************************************************************************/

/*  UNGETC.C v3.3.2                                                          */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    UNGETC   -  Push a character back onto a stream                        */

/*****************************************************************************/

#include <stdio.h>





/*****************************************************************************/

/* UNGETC   -  Push a character back onto a stream                           */

/*                                                                           */

/*    This function returns the character pushed back upon success, or an    */

/*    EOF upon failure.                                                      */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int ungetc(int _c, register FILE *_fp)

{

   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if(_fp->fd == -1) return (EOF);



   /*------------------------------------------------------------------------*/

   /* If the character is an EOF, or if an UNGETC has already been performed */

   /* and there is no room left in the buffer, return an EOF.                */

   /*------------------------------------------------------------------------*/

   if(_c == EOF || (_fp->pos < _fp->buf)) return (EOF);



   /*------------------------------------------------------------------------*/

   /* If the file is in update mode, and is currently writing, change it to  */

   /* read mode.                                                             */

   /*------------------------------------------------------------------------*/

   if(_STCHK(_fp, _MODERW))

   {

      _UNSET(_fp, _MODEW);

      _SET(_fp, _MODER);

   }

 

   /*------------------------------------------------------------------------*/

   /* Set up a buffer if one is needed, and none exists.                     */

   /*------------------------------------------------------------------------*/

   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))

      if(setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ) == EOF) return (EOF);

 

   /*------------------------------------------------------------------------*/

   /* Put the character in the buffer, set the _UNGETC flag in the stream,   */

   /* and clear the EOF flag in the stream.                                  */

   /*------------------------------------------------------------------------*/

   *(--_fp->pos) = (unsigned char)_c;

   _SET(_fp, _UNGETC);

   _UNSET(_fp, _STATEOF);



   /*------------------------------------------------------------------------*/

   /* If this is an UNGETC on an empty file, make the end of the read buffer.*/

   /*------------------------------------------------------------------------*/

   if(!_fp->buff_stop) _fp->buff_stop = _fp->buf;



   return ((unsigned char)_c);

}




values.h/       1148595159  0     0     0       9340      `
/*****************************************************************************/

/* values.h   v3.3.2                                                         */

/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */

/*****************************************************************************/



#ifndef _VALUES

#define _VALUES



#define BITS	  23                 /* There are 23 bits in the mantissa   */

#define MAXX	  88.72283906        /* ln(HUGE_VAL)                        */

#define MAXH	  89.41598624	     /* ln(HUGE_VAL) + ln(2)                */

#define TWO23	  8388608	     /* 2 ^ BITS                            */

#define XBIG	  8.664339757	     /* (BITS/2 + 1) * ln(2)                */



/****************************************************************************/

/*  The following macros define constants used throughout the functions.    */

/****************************************************************************/



/* macros used in asin and acos */



#define SQRTWO	  1.4142135623730950

#if BITS<=24

#define ASP1	  0.933935835

#define ASP2	 -0.504400557

#define ASQ0	  0.560363004e1

#define ASQ1	 -0.554846723e1

#elif BITS>=25 && BITS<=36

#define ASP1	 -0.27516555290596e1

#define ASP2	  0.29058762374859e1

#define ASP3	 -0.59450144193246

#define ASQ0	 -0.16509933202424e2

#define ASQ1	  0.24864728969164e2

#define ASQ2	 -0.10333867072113e2

#elif BITS>=37 && BITS<=48

#define ASP1	  0.85372164366771950e1

#define ASP2	 -0.13428707913425312e2

#define ASP3	  0.59683157617751534e1

#define ASP4	 -0.65404068999335009

#define ASQ0	  0.51223298620109691e2

#define ASQ1	 -0.10362273186401480e3

#define ASQ2	  0.68719597653808806e2

#define ASQ3	 -0.16429557557495170e2

#else

#define ASP1	 -0.27368494524164255994e2

#define ASP2	  0.57208227877891731407e2

#define ASP3	 -0.39688862997504877339e2

#define ASP4	  0.10152522233806463645e2

#define ASP5	 -0.69674573447350646411

#define ASQ0	 -0.16421096714498560795e3

#define ASQ1	  0.41714430248260412556e3

#define ASQ2	 -0.38186303361750149284e3

#define ASQ3	  0.15095270841030604719e3

#define ASQ4	 -0.23823859153670238830e2

#endif



/* macros used in atan and atan2 */



#define TWO_SQRT3 0.26794919243112270647

#define SQRTTHREE 1.73205080756887729353

#define PI	  3.14159265358979323846

#if BITS<=24

#define ATP0	 -0.4708325141

#define ATP1	 -0.5090958253e-1

#define ATQ0	  0.1412500740e1

#elif BITS>=25 && BITS<=32

#define ATP0	 -0.144008344874e1

#define ATP1	 -0.720026848898

#define ATQ0	  0.432025038919e1

#define ATQ1	  0.475222584599e1

#elif BITS>=33 && BITS<=50

#define ATP0	 -0.427432672026241096e1

#define ATP1	 -0.427444985367930329e1

#define ATP2	 -0.794391295408336251

#define ATQ0	  0.128229801607919841e2

#define ATQ1	  0.205171376564218456e2

#define ATQ2	  0.919789364835039806e1

#else

#define ATP0	 -0.13688768894191926929e2

#define ATP1	 -0.20505855195861651981e2

#define ATP2	 -0.84946240351320683534e1

#define ATP3	 -0.83758299368150059274

#define ATQ0	  0.41066306682575781263e2

#define ATQ1	  0.86157349597130242515e2

#define ATQ2	  0.59578436142597344465e2

#define ATQ3	  0.15024001160028576121e2

#endif



/* macros used in sin and cos */



#define INVSPI	  0.31830988618379067154

#define HALFPI	  1.57079632679489661923

#if BITS<=32

#define C1	  3.140625

#define C2	  9.67653589793e-4

#else

#define C1	  3.1416015625

#define C2	 -8.908910206761537356617e-6

#endif

#if BITS<=24

#define R1	 -0.1666665668e+0

#define R2	  0.8333025139e-2

#define R3	 -0.1980741872e-3

#define R4	  0.2601903036e-5

#elif BITS>=25 && BITS<=32

#define R1	 -0.1666666660883

#define R2	  0.8333330720556e-2

#define R3	 -0.1984083282313e-3

#define R4	  0.2752397106775e-5

#define R5	 -0.2386834640601e-7

#elif BITS>=33 && BITS<=50

#define R1	 -0.166666666666659653

#define R2	  0.833333333327592139e-2

#define R3	 -0.198412698232225068e-3

#define R4	  0.275573164212926457e-5

#define R5	 -0.250518708834705760e-7

#define R6	  0.160478446323816900e-9

#define R7	 -0.737066277507114174e-12

#else

#define R1	 -0.16666666666666665052

#define R2	  0.83333333333331650314e-2

#define R3	 -0.19841269841201840457e-3

#define R4	  0.27557319210152756119e-5

#define R5	 -0.25052106798274584544e-7

#define R6	  0.16058936490371589114e-9

#define R7	 -0.76429178068910467734e-12

#define R8	  0.27204790957888846175e-14

#endif



/* macros used in exp, cosh, and sinh */



#define LOGe2	  0.6931471805599453094172321

#define LOG102    0.301029995663981198017

#define INVLOGe2  1.4426950408889634074

#if BITS<=29

#define EXP0	  0.24999999950

#define EXP1	  0.41602886268e-2

#define EXQ0	  0.5

#define EXQ1	  0.49987178778e-1

#elif BITS>=30 && BITS<=42

#define EXP0	  0.24999999999992

#define EXP1	  0.59504254977591e-2

#define EXQ0	  0.5

#define EXQ1	  0.53567517645222e-1

#define EXQ2	  0.29729363682238e-3

#elif BITS>=43 && BITS<=56

#define EXP0	  0.249999999999999993

#define EXP1	  0.694360001511792852e-2

#define EXP2	  0.165203300268279130e-4

#define EXQ0	  0.5

#define EXQ1	  0.555538666969001188e-1

#define EXQ2	  0.495862884905441294e-3

#else

#define EXP0	  0.25

#define EXP1	  7.5753180159422776666e-3

#define EXP2	  3.1555192765684646356e-5

#define EXQ0	  0.5

#define EXQ1	  5.6817302698551221787e-2

#define EXQ2	  6.3121894374398503557e-4

#define EXQ3	  7.5104028399870046114e-7

#endif

#if BITS<=24

#define SHP0	 -0.713793159e1

#define SHP1	 -0.190333399

#define SHQ0	 -0.428277109e2

#elif BITS>=25 && BITS<=40

#define SHP0	  0.10622288837151e4

#define SHP1	  0.31359756456058e2

#define SHP2	  0.34364140358506

#define SHQ0	  0.63733733021822e4

#define SHQ1	 -0.13051012509199e3

#elif BITS>=41 && BITS<=50

#define SHP0	  0.23941435923050069e4

#define SHP1	  0.85943284838549010e2

#define SHP2	  0.13286428669224229e1

#define SHP3	  0.77239398202941923e-2

#define SHQ0	  0.14364861553830292e5

#define SHQ1	 -0.20258336866427869e3

#else

#define SHP0	 -0.35181283430177117881e6

#define SHP1	 -0.11563521196851768270e5

#define SHP2	 -0.16375798202630751372e3

#define SHP3	 -0.78966127417357099479

#define SHQ0	 -0.21108770058106271242e7

#define SHQ1	  0.36162723109421836460e5

#define SHQ2	 -0.27773523119650701667e3

#endif



/* macros used in log10 and log */



#define SQRTHALF  0.70710678118654752440

#define LOG10e	  0.4342944819032518

#define C3	  0.693359375

#define C4	 -2.121944400546905827679e-4

#if BITS<=24

#define A0	 -0.5527074855

#define B0	 -0.6632718214e1

#elif BITS>=25 && BITS<=32

#define A0	 -0.4649062303464

#define A1	  0.1360095468621e-1

#define B0	 -0.5578873750242e1

#elif BITS>=33 && BITS<=48

#define A0	  0.37339168963160866e1

#define A1	 -0.63260866233859665

#define A2	  0.44445515109803323e-2

#define B0	  0.44807002755736436e2

#define B1	 -0.14312354355885324e2

#else

#define A0	 -0.64124943423745581147e2

#define A1	  0.16383943563021534222e2

#define A2	 -0.78956112887491257267

#define B0	 -0.76949932108494879777e3

#define B1	  0.31203222091924532844e3

#define B2	 -0.35667977739034646171e2

#endif



/* macros used in pow */



#define L1	  2.885390072738

#define L3	  0.961800762286

#define L5	  0.576584342056

#define L7	  0.434259751292

#define T6	  0.0002082045327

#define T5	  0.001266912225

#define T4	  0.009656843287

#define T3	  0.05549288453

#define T2	  0.2402279975

#define T1	  0.6931471019



/* macros used in tan */



#define TWOINVPI  0.63661977236758134308

#if BITS<=32

#define C5	  1.5703125

#define C6	  4.83826794897e-4

#else

#define C5	  1.57080078125

#define C6	 -4.454455103380768678308e-6

#endif

#if BITS<=24

#define TAP1	 -0.958017723e-1

#define TAQ1	 -0.429135777e+0

#define TAQ2	  0.971685835e-2

#elif BITS>=25 && BITS<=32

#define TAP1	 -0.1113614403566

#define TAP2	  0.1075154738488e-2

#define TAQ1	 -0.4446947720281

#define TAQ2	  0.1597339213300e-1

#elif BITS>=33 && BITS<=52

#define TAP1	 -0.1282834704095743847

#define TAP2	  0.2805918241169988906e-2

#define TAP3	 -0.7483634966612065149e-5

#define TAQ1	 -0.4616168037429048840

#define TAQ2	  0.2334485282206872802e-1

#define TAQ3	 -0.2084480442203870948e-3

#else

#define TAP1	 -0.13338350006421960681

#define TAP2	  0.34248878235890589960e-2

#define TAP3	 -0.17861707342254426711e-4

#define TAQ1	 -0.46671683339755294240

#define TAQ2	  0.25663832289440112864

#define TAQ3	 -0.31181531907010027307e-3

#define TAQ4	  0.49819433993786512270e-6

#endif



/* macros used in tanh */



#define LOGe3by2  0.54930614433405484570

#if BITS<=24

#define THP0	 -0.8237728127

#define THP1	 -0.3831010665e-2

#define THQ0	  0.2471319654e1

#elif BITS>=25 && BITS<=36

#define THP0	 -0.21063958000245e2

#define THP1	 -0.93363475652401

#define THQ0	  0.63191874015582e2

#define THQ1	  0.28077653470471e2

#elif BITS>=37 && BITS<=48

#define THP0	 -0.19059522426982292e2

#define THP1	 -0.92318689451426177

#define THP2	 -0.36242421934642173e-3

#define THQ0	  0.57178567280965817e2

#define THQ1	  0.25640987595178975e2

#else

#define THP0	 -0.16134119023996228053e4

#define THP1	 -0.99225929672236083313e2

#define THP2	 -0.96437492777225469787

#define THQ0	  0.48402357071988688686e4

#define THQ1	  0.22337720718962312926e4

#define THQ2	  0.11274474380534949335e3

#endif



#endif /* _VALUES */

vars.cpp/       1148595159  0     0     0       2210      `
/*****************************************************************************/

/* vars.cpp v#####                                                           */

/* Copyright (c) 1996@%%%% Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/



/*



Performs initialization of global variables used by the runtime.



*/



#define EXTERN /* empty */

#define VAR_INITIALIZERS 1



#include "basics.h"

#include "runtime.h"

#include "vec_newdel.h"

/*** START TI ADD ***/

/* We do not need main.h to build TI RTS */

#if 0

/*** END TI ADD ***/

#include "main.h"

*** START TI ADD ***/

#endif

/*** END TI ADD ***/

#include "vec_newdel.h"

#include "eh.h"



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/







vec_cctor.cpp/  1148595159  0     0     0       2724      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ runtime routine to execute a copy constructor for each element of an array.



*/



#include "basics.h"

#include "runtime.h"



#ifndef __EDG_IA64_ABI

EXTERN_C void __vec_cctor(void                         *array_ptr,

                          size_t                       number_of_elements,

                          size_t                       element_size,

                          a_copy_constructor_ptr       ctor,

                          void                         *src_array_ptr)

/*

Walk through the array, calling the specified copy constructor for each

array element.  The corresponding element of the array pointed to by

src_array_ptr is the source operand for the copy constructor.  Because

this runtime routine will only be called for constructor initialization

of member arrays, the number_of_elements can never be zero.

*/

{

  int  i;

  char *arr_ptr;

  char *src_arr;



  if (ctor != NULL) {

    for (i = 0, arr_ptr = (char *)array_ptr, src_arr = (char *)src_array_ptr;

         i < number_of_elements;

         i++, arr_ptr += element_size, src_arr += element_size) {

      (*ctor)((void *)arr_ptr, (void *)src_arr);

    }  /* for */

  }  /* if */

}  /* __vec_ctor */

#endif /* ifndef __EDG_IA64_ABI */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

vec_newdel.cpp/ 1148595159  0     0     0       64279     `
/*****************************************************************************/

/* vec_newdel.cpp v#####                                                     */

/* Copyright (c) 1996@%%%% Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



C++ runtime routines to provide vector new() and delete() functionality.



*/



#include "basics.h"

#include "runtime.h"

#include "eh.h"

#pragma hdrstop

#include "vec_newdel.h"

/*** START TI ADD ***/

/* We do not need main.h to build TI RTS */

#if 0

/*** END TI ADD ***/

#include "main.h"

/*** START TI ADD ***/

#endif

/*** END TI ADD ***/

#if ABI_COMPATIBILITY_VERSION >= 300

#include "memzero.h"

#endif /* ABI_COMPATIBILITY_VERSION >= 300 */



/*

For arrays, _vec_new() and _vec_delete() will maintain a linked list of 

"hidden" information on each array allocated and subsequently deleted.

This information will be used by _vec_ctor() and _vec_dtor() to determine

the size of undimensioned arrays.

*/



/*

Hidden structure of information for each array "allocated" by new().

*/

typedef struct vec_info *a_vec_info_ptr;

				/* Pointer to a vector information struct. */

typedef struct vec_info {

  a_vec_info_ptr

		next;		/* Pointer to the next structure in a linked

				   list. */

  void 	        *array_ptr;	/* Pointer to array. */

  size_t        array_size;	/* Size of memory in the array. */

} vec_info;





#if !USE_PREFIX_FOR_ARRAY_ALLOC_INFO

static a_vec_info_ptr _head_vec_info = NULL;

				/* Pointer to the beginning of the linked list

				   of array information. */



static a_vec_info_ptr _free_vec_info = NULL;

				/* Pointer to a list of free array information

				   structures. */

#endif /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO */



#ifndef __EDG_IA64_ABI

EXTERN_C void _array_pointer_not_from_vec_new();

                               /* Function called when an invalid pointer that

                                  was not allocated by vec_new is passed

                                  to one of the vector handling routines. */

#endif /* ifndef __EDG_IA64_ABI */



struct an_array_alloc_eh_info {

  void*	array_ptr;

			/* Pointer to the memory allocated for the array. */

  a_sizeof_t

		number_of_elements;

			/* Total number of elements in the array. */

  a_sizeof_t

		element_size;

			/* Size of each element. */

  a_sizeof_t

		prefix_size;

                        /* Size of the array prefix. */

  a_sizeof_t

		elements_processed;

			/* Number of elements constructed or destructed so

			   far. */

  a_boolean

		is_vec_new;

			/* TRUE if this is a vec_new operation, FALSE if this

			   is a vec_delete. */

  a_boolean

		free_memory_on_cleanup;

			/* TRUE if the memory for the array was allocated by

			   new and should be freed during object cleanup. */

  a_destructor_ptr  

		destructor;

			/* Pointer to the destructor to be called for each

			   element of the array. */

  a_delete_ptr

		delete_routine;

			/* Pointer to the delete routine to be called to

			   deallocate an array. */



  a_boolean	is_two_arg;

			/* TRUE if the delete routine is the two argument

			   form.  FALSE if it is the single argument form. */

#ifdef __EDG_IA64_ABI

  a_boolean     terminate_immediately;

                        /* TRUE if any exception during the destruction of the

                           array elements should result in termination.  */

#endif /* defined(__EDG_IA64_ABI) */

};



/*** START TI ADD ***/

#if EXCEPTION_HANDLING && defined(__TI_TABLE_DRIVEN_EXCEPTIONS) 

EXTERN_C void __cleanup_vec_new_or_delete(an_array_alloc_eh_info_ptr aaehip);

EXTERN_C void __cxa_call_terminate(void *);

#endif

/*** END TI ADD ***/



/*

Increment a void* pointer by a given value.

*/

#define increment_ptr(ptr, incr) (ptr = ((void*)((char*)ptr + incr)))



/*** START TI REPLACE ***/

#if EXCEPTION_HANDLING && !defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

/*** END TI REPLACE ***/

static void add_vec_new_or_delete_eh_stack_entry

				(an_eh_stack_entry_ptr	    ehsep,

                                 an_array_alloc_eh_info_ptr aaehip,

			         a_boolean		    is_vec_new)

/*

Link an entry onto the EH stack that describes the vec_new or vec_delete

operation that is in process.

*/

{

  ehsep->next = __curr_eh_stack_entry;

  __curr_eh_stack_entry = ehsep;

  ehsep->kind = ehsek_vec_new_or_delete;

  ehsep->variant.array_alloc_eh_info = aaehip;

  aaehip->array_ptr                 = NULL;

  aaehip->number_of_elements        = 0;

  aaehip->element_size              = 0;

  aaehip->prefix_size               = 0;

  aaehip->elements_processed        = 0;

  aaehip->is_vec_new                = is_vec_new;

  aaehip->free_memory_on_cleanup    = FALSE;

  aaehip->destructor		    = NULL;

  aaehip->delete_routine	    = NULL;

  aaehip->is_two_arg	 	    = FALSE;

}  /* add_vec_new_or_delete_eh_stack_entry */

/*** START TI REPLACE ***/

#endif /* EXCEPTION_HANDLING && !defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */

/*** END TI REPLACE ***/





#if USE_PREFIX_FOR_ARRAY_ALLOC_INFO

/*

Structure used to record the size of an array that has been allocated.

Space for this structure is reserved at the beginning of the block of

memory allocated to hold the array.

*/



/* ARM ABI Mode is based on "C++ ABI for the ARM Architecture"(CPPABI)

3.2.2 Array construction and destruction 

3.2.2.1 Array cookies

3.2.2.2 Array cookie alignment

on page 9,  Doc # Genc-003540 v1.0 */





#if !defined(__EDG_IA64_ABI) && defined(TI_ARRAY_PREFIX)

typedef struct an_alloc_prefix *an_alloc_prefix_ptr;

/*** START TI ADD ***/

struct an_alloc_prefix {

  size_t number_of_elements;

                        /* To maintain backward compatibility with

			   previous TI RTS, we modified this data 

			   structure. It is to our knowledge that 

			   this change and its relevant changes

			   will not harm the functionality of 

			   the RTS */

};

#define LARGE_TYPE_MASK (sizeof(long double) - 1)

size_t __array_new_prefix_size = 

                    (sizeof(an_alloc_prefix) + LARGE_TYPE_MASK) & ~LARGE_TYPE_MASK;

#elif !defined(__EDG_IA64_ABI) && !defined(TI_ARRAY_PREFIX)

typedef struct an_alloc_prefix *an_alloc_prefix_ptr;

/* EDG defined array prefix */

struct an_alloc_prefix {

  size_t	size;

			/* The size of the array, in bytes. */



  size_t	encoded_number_of_elements;

			/* The number of elements in the array.  This value

                           is encoded so that a zero value is not represented

			   as a zero.  This is done to help detect situations

			   in which the prefix has been overwritten. */

};

/*

Compute the size in bytes of the prefix to be allocated.  This must

be at least as large as an_alloc_prefix, but must also be a multiple

of the most strict alignment. */

size_t	__array_new_prefix_size = 

	          ((sizeof(an_alloc_prefix) + MOST_STRICT_ALIGNMENT - 1) /

                               MOST_STRICT_ALIGNMENT) * MOST_STRICT_ALIGNMENT;



#elif defined(__EDG_IA64_ABI) 

#if __EDG_IA64_ABI_USE_VARIANT_ARRAY_COOKIES

/*

Define the type used for the array cookie.  The ARM EABI uses a variant

version of the mechanism in the IA-64 ABI.

*/

typedef struct an_alloc_prefix {

  size_t	element_size;

			/* The size of an element. */

  size_t	element_count;

			/* The number of elements in the array. */

} an_alloc_prefix;

#else /* !__EDG_IA64_ABI_USE_VARIANT_ARRAY_COOKIES */

typedef size_t an_alloc_prefix;

#endif /* __EDG_IA64_ABI_USE_VARIANT_ARRAY_COOKIES */

typedef an_alloc_prefix *an_alloc_prefix_ptr;

#endif /* End of prefix definition */

#else /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO */

/*

No prefix is used in the alternate mode.

*/

size_t	__array_new_prefix_size = 0;

#endif /* USE_PREFIX_FOR_ARRAY_ALLOC_INFO */





static inline void* alloc_array(size_t		size,

                                size_t          prefix_size,

			        a_new_ptr	new_routine)

/*

Call the allocation routine to allocate the memory for the array.  Adjust

the size as needed to provide storage for the prefix information used to

save the array size.  The size of the prefix, if any, is given by

prefix_size.

*/

{

  void		*array_ptr;

  /* Increment the size to provide space for the prefix block. */

  size += prefix_size;

  /* Allocate the memory using the appropriate new routine.  If a pointer

     was provided by the caller, use that one.  Otherwise, use the

     one specified by the ABI being used. */

  if (new_routine == NULL) {

#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE

    array_ptr = operator new[](size);

#else /* !ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */

    array_ptr = operator new(size);

#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */

  } else {

    array_ptr = (*new_routine)(size);

  }  /* if */

  if (array_ptr != NULL) {

    /* Return a pointer to the part of the array after the prefix. */

    array_ptr = (void*)(((char *)array_ptr) + prefix_size);

  }  /* if */

  return array_ptr;

}  /* alloc_array */





static void free_array(void*		array_ptr,

		       size_t		size,

                       size_t           prefix_size,

		       a_delete_ptr	delete_routine,

		       int		is_two_arg)

/*

Call the deallocation routine to free the memory for the array.  Adjust

the size as needed to provide storage for the prefix information used to

save the array size.  The size of the prefix (if any) is given by

prefix_size.

*/

{

  /* Increment the size to provide space for the prefix block. */

  size += prefix_size;

  /* Adjust the pointer to point to the start of the prefix. */

  array_ptr = (void*)(((char *)array_ptr) - prefix_size);

  /* Free the memory using the appropriate new routine.  If a pointer

     was provided by the caller, use that one.  Otherwise, use the

     one specified by the ABI being used. */

  if (delete_routine == NULL) {

#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE

    operator delete[](array_ptr);

#else /* !ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */

    operator delete(array_ptr);

#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */

  } else {

    if (is_two_arg) {

      a_two_operand_delete_ptr two_op_delete_routine;

      two_op_delete_routine = (a_two_operand_delete_ptr)delete_routine;

      (*two_op_delete_routine)(array_ptr, size);

    } else {

      (*delete_routine)(array_ptr);

    }  /* if */

  }  /* if */

}  /* free_array */





#if !USE_PREFIX_FOR_ARRAY_ALLOC_INFO

/*ARGSUSED*/ /* <-- "number_of_elements" is only used when

                    USE_PREFIX_FOR_ARRAY_ALLOC_INFO is TRUE. 

 		    "element_size" is not used in that case. */

#else /* USE_PREFIX_FOR_ARRAY_ALLOC_INFO */

#ifdef __EDG_IA64_ABI

/*ARGSUSED*/ /* <-- "size" is not used in that case. */

#if !__EDG_IA64_ABI_USE_VARIANT_ARRAY_COOKIES

/*ARGSUSED*/ /* <-- "element_size" is not used in that case. */

#endif /* !__EDG_IA64_ABI_USE_VARIANT_ARRAY_COOKIES */

#else /* ifndef __EDG_IA64_ABI */

/*ARGSUSED*/ /* <-- "element_size" is not used in that case. */

#endif /* ifdef __EDG_IA64_ABI */

#endif /* USE_PREFIX_FOR_ARRAY_ALLOC_INFO */



static inline a_boolean record_array_alloc_info(void*	array_ptr,

	   				        size_t	size,

					        size_t	number_of_elements,

						size_t  element_size)

/*

Record the size of the array so that it can be retrieved later using

the array pointer.  Returns TRUE if an error occurred and the size

could not be recorded.

*/

{

#if USE_PREFIX_FOR_ARRAY_ALLOC_INFO

  an_alloc_prefix_ptr	app;

#if !defined(__EDG_IA64_ABI) && defined(TI_ARRAY_PREFIX)

  /* Get a pointer to the prefix information and fill in the fields.

     The number of elements is saved as the complement of the actual

     value.  This is done so that zeroing out the prefix (as might happen

     if the memory were overwritten) would not result in valid values. */

  app = (an_alloc_prefix_ptr)(((char *)array_ptr) - __array_new_prefix_size);

  app->number_of_elements = number_of_elements; 

#elif !defined(__EDG_IA64_ABI) && !defined(TI_ARRAY_PREFIX)

  app = (an_alloc_prefix_ptr)(((char *)array_ptr) - __array_new_prefix_size);

  app->size = size;

  app->encoded_number_of_elements = ~number_of_elements;

#else /* defined(__EDG_IA64_ABI) */

  app = ((an_alloc_prefix_ptr)array_ptr) - 1;

#if !__EDG_IA64_ABI_USE_VARIANT_ARRAY_COOKIES

  *app = (an_alloc_prefix)number_of_elements;

#else /* __EDG_IA64_ABI_USE_VARIANT_ARRAY_COOKIES */

  app->element_size = element_size;

  app->element_count = number_of_elements;

#endif /* !__EDG_IA64_ABI_USE_VARIANT_ARRAY_COOKIES */

#endif /* defined(__EDG_IA64_ABI) */

  return FALSE;

#else /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO */

  a_vec_info_ptr	info_ptr;

  /* Allocate the needed memory and construct the "hidden" array

     information. */

  if (_free_vec_info != NULL) {

    /* Reuse a previously allocated structure. */

    info_ptr = _free_vec_info;

    _free_vec_info = info_ptr->next;

  } else {

    /* Allocate an array information structure from free memory. */

    info_ptr = (a_vec_info_ptr)malloc(sizeof(vec_info));

    if (info_ptr == NULL) {

      array_ptr = NULL;

    }  /* if */

  }  /* if */

  if (info_ptr != NULL) {

    info_ptr->next       = _head_vec_info;

    info_ptr->array_ptr  = array_ptr;

    info_ptr->array_size = size;

    _head_vec_info  = info_ptr;

  }  /* if */

  return array_ptr == NULL;

#endif /* USE_PREFIX_FOR_ARRAY_ALLOC_INFO */

}  /* record_array_alloc_info */





#if !USE_PREFIX_FOR_ARRAY_ALLOC_INFO

/*ARGSUSED*/ /* <-- "element_size" is only used when

                    USE_PREFIX_FOR_ARRAY_ALLOC_INFO is TRUE. */

#endif /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO */

static inline size_t get_array_size(void*	array_ptr,

			 	    size_t	element_size,

				    size_t	*number_of_elements)

/*

Return the array size saved when the array was allocated.  The size is

stored either in a prefix allocated immediately before the array or in

a separate data structure.  array_ptr points to the start of the array

whose size is to be determined.  element_size is the size of each element.

The number of elements in the array is returned in *number_of_elements.

*/

{

#if USE_PREFIX_FOR_ARRAY_ALLOC_INFO

  an_alloc_prefix_ptr	app;

  size_t		size;

#if !defined(__EDG_IA64_ABI) && !defined(TI_ARRAY_PREFIX)

  size_t                size_to_check;

#endif



#if !defined(__EDG_IA64_ABI) && defined(TI_ARRAY_PREFIX)

  /* Get the size from the prefix.  Compute the size from the

     element count saved in the prefix and the element size passed

     by the caller.  Note that the number of elements is saved as the

     complement of the actual value.  If the two sizes do not agree,

     either the memory was not allocated by array_new, or the prefix was

     corrupted. */

  app = (an_alloc_prefix_ptr)(((char *)array_ptr) - __array_new_prefix_size);

  size = app->number_of_elements * element_size;

/*** START TI ADD ***/

  *number_of_elements = app->number_of_elements;

/*** END TI ADD ***/ 

#elif !defined(__EDG_IA64_ABI) && !defined(TI_ARRAY_PREFIX)

  size = app->size;

  *number_of_elements = ~(app->encoded_number_of_elements);

  size_to_check = element_size * (~(app->encoded_number_of_elements));

  if (size != size_to_check) _array_pointer_not_from_vec_new();

#elif defined(__EDG_IA64_ABI) 

  app = ((an_alloc_prefix_ptr)array_ptr) - 1;

#if __EDG_IA64_ABI_USE_VARIANT_ARRAY_COOKIES

  *number_of_elements = app->element_count;

#else /* !__EDG_IA64_ABI_USE_VARIANT_ARRAY_COOKIES */

  *number_of_elements = *app;

#endif /* __EDG_IA64_ABI_USE_VARIANT_ARRAY_COOKIES */

  size = *number_of_elements * element_size;

#endif /* defined(__EDG_IA64_ABI) */

  return size;

#else /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO */

  a_vec_info_ptr        prev_ptr;

  a_vec_info_ptr 	info_ptr = NULL;

  size_t		size;

  /* Find the "hidden" information  for this array. */

  for (prev_ptr = NULL, info_ptr = _head_vec_info;

       (info_ptr != NULL) && (info_ptr->array_ptr != array_ptr);

       info_ptr = info_ptr->next) {

    prev_ptr = info_ptr;

  }  /* for */

  if (info_ptr == NULL) {

    /* This array was not allocated by vec_new, so we do not know the

       size.  Call a function that will abort.  The name should

       be sufficient to identify the nature of the problem to the user. */

     _array_pointer_not_from_vec_new();

  }  /* if */

  size = info_ptr->array_size;

  /* Unhook this array information from the linked list and add to the

     front of the free list. */

  if (prev_ptr == NULL) {

    /* This structure is on the beginning of the linked list. */

    _head_vec_info = info_ptr->next;

  } else {

    prev_ptr->next = info_ptr->next;

  }  /* if */

  info_ptr->next = _free_vec_info;

   _free_vec_info = info_ptr;

  return size;

#endif /* USE_PREFIX_FOR_ARRAY_ALLOC_INFO */

}  /* get_array_size */





/*ARGSUSED*/ /* <-- "dtor" is only used when EXCEPTION_HANDLING is TRUE. 

                    "prefix_size" is only used when

                    USE_PREFIX_FOR_ARRAY_ALLOC_INFO is true. */

static void *array_new_general(void                  *array_ptr,

                               size_t                number_of_elements,

                               size_t                element_size,

                               size_t                prefix_size,

                               void                  *src_array_ptr,

                               a_constructor_ptr     ctor,

                               a_destructor_ptr  	     dtor,

		               a_new_ptr	     new_routine,

                               a_delete_ptr          delete_routine,

			       int		     is_two_arg,

                               a_boolean             zero_init)

/*

Allocate storage for an array, then call a constructor for each

element of the array.  If array_ptr is NULL, allocate the space for an

array of class objects (with number_of_elements elements each of size

element_size).  Also remember the size of the array in a

behind-the-scenes data structure so that it can be recalled at the

time of the corresponding vec_delete call.  If array_ptr is non-NULL,

it points to an already-allocated array.  If ctor is non-NULL, it

points to a constructor function to be called for each element of the

array (whether the array is allocated here or pre-allocated).  Return

the address of the array.



src_array_ptr points to the array to be copied when ctor points to a

copy constructor.



dtor is a pointer to the destructor for objects of the element type.

This is used by the exception handling mechanism for object cleanup

if an exception is thrown while the array is being constructed.

If there is no destructor then dtor is NULL and no cleanup is done.



delete_routine is a pointer to the delete routine to be used to deallocate the

space in the event that an exception is thrown during construction.

is_two_arg is TRUE if delete_routine refers to a two argument version of the

delete operator.  zero_init is TRUE if the memory should be cleared before

invoking constructors.



This routine needs to record the size of the array that was allocated so

that the size is known when the array is deallocated.  One of two means

of recording this information is used depending on the setting of the

configuration flag USE_PREFIX_FOR_ARRAY_ALLOC_INFO.  If this flag is TRUE,

a prefix structure is allocated as part of the array allocation, and this

prefix is used to store the size.  The pointer returned to the caller points

to the memory after the prefix block.



When USE_PREFIX_FOR_ARRAY_ALLOC_INFO is FALSE, a linked list is used

to record the number of elements in the array.  Consequently, the

performance degrades if a large number of arrays are allocated.  For

this reason, the alternate mechanism is recommended for production

use.

*/

{

  size_t   array_size;

  int      i;

  void     *arr_ptr;



#if EXCEPTION_HANDLING 

/*** START TI ADD ***/

#if !defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

/*** END TI ADD ***/

  an_eh_stack_entry		ehse;

/*** START TI ADD ***/

#endif /* !defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */

/*** END TI ADD ***/

  an_array_alloc_eh_info	aaehi;

  a_boolean			create_eh_stack_entry;

  a_boolean			free_memory_on_cleanup = array_ptr == NULL;



  /* An entry is created on the EH stack if the class for which the

     array is being created has a destructor, or if the object is

     dynamically allocated. */

  create_eh_stack_entry = dtor != NULL || array_ptr == NULL;

#endif /* EXCEPTION_HANDLING */

  if (array_ptr == NULL || prefix_size) {

    a_boolean	err;

    array_size = number_of_elements * element_size;

    if (array_ptr == NULL) {

      /* Allocate the array if a pointer has not been supplied by the

         caller. */

      array_ptr = alloc_array(array_size, prefix_size, new_routine);

      if (array_ptr == NULL) {

        goto error_exit;

      }  /* if */

    }  /* if */

    /* Record the array size information so that the array can be properly

       freed later. */

    if (prefix_size != 0) {

      err = record_array_alloc_info(array_ptr, array_size, number_of_elements,

				    element_size);

      if (err) goto error_exit;

    }  /* if */

#if ABI_COMPATIBILITY_VERSION >= 300

  } else if (zero_init) {

    array_size = number_of_elements * element_size;

#endif /* ABI_COMPATIBILITY_VERSION >= 300 */

  }  /* if */

#if ABI_COMPATIBILITY_VERSION >= 300

  if (zero_init) {

    __memzero(array_ptr, array_size);

  }  /* if */

#endif /* ABI_COMPATIBILITY_VERSION >= 300 */

#if EXCEPTION_HANDLING 

  if (create_eh_stack_entry) {

/*** START TI ADD ***/

#if !defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

/*** END TI ADD ***/

    add_vec_new_or_delete_eh_stack_entry(&ehse, &aaehi, /*is_vec_new=*/TRUE);

/*** START TI ADD ***/

#else /* defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */

    aaehi.elements_processed     = 0;

    aaehi.is_vec_new             = TRUE;

#endif /* !defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */

/*** END TI ADD ***/

    aaehi.free_memory_on_cleanup = free_memory_on_cleanup;

    aaehi.number_of_elements     = number_of_elements;

    aaehi.element_size           = element_size;

    aaehi.prefix_size            = prefix_size;

    aaehi.destructor		 = dtor;

    aaehi.delete_routine	 = delete_routine;

    aaehi.is_two_arg		 = is_two_arg;

    aaehi.array_ptr              = array_ptr;

#ifdef __EDG_IA64_ABI

    aaehi.terminate_immediately  = FALSE;

#endif /* defined(__EDG_IA64_ABI) */

  }  /* if */

#endif /* EXCEPTION_HANDLING */

  /* Call the constructor, if any, for each member of the array.  Note that

     there may be zero elements.  Cfront tacks on what appears to be eight

     additional NULL values to be used as the addresses of the first

     eight virtual base classes.  The EDG compiler generates a special wrapper

     for use by vec_new and doesn't need the additional arguments.  The

     additional arguments here allow cfront-generated vec_new calls to

     be used with this vec_new. */

/*** START TI ADD ***/

#if EXCEPTION_HANDLING && defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

  try {

#endif

/*** END TI ADD ***/

  if (ctor != NULL) {

    for (i = 0, arr_ptr = array_ptr;

         i < number_of_elements;

         i++, increment_ptr(arr_ptr, element_size)) {

     if (src_array_ptr == NULL) {

       /* Call the default constructor. */

#if CFRONT_COMPATIBILITY_MODE

        a_cfront_constructor_ptr	cfront_ctor;

        cfront_ctor = (a_cfront_constructor_ptr)ctor;

        (*cfront_ctor)(arr_ptr, (void *)0, (void *)0, (void *)0, (void *)0,

                       (void *)0, (void *)0, (void *)0, (void *)0);

#else /* CFRONT_COMPATIBILITY_MODE */

        (*ctor)(arr_ptr); 

#endif /* CFRONT_COMPATIBILITY_MODE */

      } else {

        /* Call the copy constructor. */

        a_copy_constructor_ptr	cctor;

        cctor = (a_copy_constructor_ptr)ctor;

        (*cctor)(arr_ptr, src_array_ptr);

      }  /* if */

#if EXCEPTION_HANDLING

      if (dtor != NULL) {

        /* Update the counter of the number of elements processed in the

           EH stack entry. */

        aaehi.elements_processed++;

      }  /* if */

#endif /* EXCEPTION_HANDLING */

      /* Go to the next element in the source array when the constructor

         being called is a copy constructor. */

      if (src_array_ptr != NULL) increment_ptr(src_array_ptr, element_size);

    }  /* for */

  }  /* if */

#if EXCEPTION_HANDLING 

/*** START TI ADD ***/

#if defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

  } catch (...)

  {

      /* Generic C++ ABI, Sec 3.3.3, Array Construction and Destruction API

       * Catch any exception thrown by the constructor/copy constructor,

       * call the destructor on any elements constructed, and reraise 

       * the exception

       * If dtor throws, do not propagate the exception, call terminate.

       */

      try {

	  __cleanup_vec_new_or_delete(&aaehi);

      } catch (...)

      {

	  __cxa_call_terminate(0);

      }

      throw;

  }

#else

/*** END TI ADD ***/

  if (create_eh_stack_entry) {

    /* Unlink the vec_new EH stack entry. */

    __curr_eh_stack_entry = __curr_eh_stack_entry->next;

  }  /* if */

/*** START TI ADD ***/

#endif /* __TI_TABLE_DRIVEN_EXCEPTIONS */

/*** END TI ADD ***/



#endif /* EXCEPTION_HANDLING */

error_exit:

  /* Return the pointer to the array. */

  return array_ptr;

}  /* array_new_general */



#ifndef __EDG_IA64_ABI

#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE

EXTERN_C void *__array_new(size_t                       number_of_elements,

                           size_t                       element_size,

                           a_constructor_ptr	 	ctor,

                           a_destructor_ptr  	        dtor,

			   a_new_ptr		 	new_routine,

                           a_delete_ptr          	delete_routine,

			   int			 	is_two_arg)

/*

This entry point is used for operations that use class specific array

new and delete operators.  The new and delete routines are pointed to

by new_routine and delete_routine.  is_two_arg is TRUE if the delete

routine is one that requires two arguments.

*/

{

  return (array_new_general((void*)NULL, number_of_elements, element_size,

                            __array_new_prefix_size, (void*)NULL, ctor, dtor,

                            new_routine, delete_routine, is_two_arg,

                            /*zero_init=*/FALSE));

}  /* __array_new */

#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */





#if ABI_COMPATIBILITY_VERSION >= 234

EXTERN_C void *__placement_array_new(

			   void				*array_ptr,

			   size_t                       number_of_elements,

                           size_t                       element_size,

                           a_constructor_ptr	 	ctor,

                           a_destructor_ptr  	        dtor)

/*

This entry point is used for placement array new operations.  The actual

memory is allocated by a call to the appropriate new routine before

this routine is called.  This routine is used to record the array size

information and to call the constructor for each array element.

*/

{

  return (array_new_general(array_ptr, number_of_elements, element_size,

                            __array_new_prefix_size, (void*)NULL, ctor, dtor,

                            (a_new_ptr)NULL, (a_delete_ptr)NULL,

                            /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));

}  /* __placement_array_new */

#endif /* ABI_COMPATIBILITY_VERSION >= 234 */







EXTERN_C void *__vec_new_eh(void                         *array_ptr,

                            size_t                       number_of_elements,

                            size_t                       element_size,

                            a_constructor_ptr	 	 ctor,

                            a_destructor_ptr  	         dtor)

/*

This entry point is used by code that uses exception handling for

new operations that do not involve the use of a class specific

operator new.

*/

{

  return (array_new_general(array_ptr, number_of_elements, element_size,

                            (array_ptr == NULL) ? __array_new_prefix_size : 0,

                            (void*)NULL, ctor, dtor,

                            (a_new_ptr)NULL, (a_delete_ptr)NULL,

                            /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));

}  /* __vec_new_eh */





EXTERN_C void *__vec_new(void                         *array_ptr,

                         size_t                       number_of_elements,

                         size_t                       element_size,

                         a_constructor_ptr            ctor)

/*

This is an entry point used for compatibility with code generated

before EH was supported.  This is similar to vec_new_eh, except that

no destructor pointer is provided.

*/

{

  return (array_new_general(array_ptr, number_of_elements, element_size,

                            (array_ptr == NULL) ? __array_new_prefix_size : 0,

                            (void*)NULL, ctor, (a_destructor_ptr  )NULL, 

                            (a_new_ptr)NULL, (a_delete_ptr)NULL,

                            /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));

}  /* __vec_new */





EXTERN_C void __vec_cctor_eh(void                       *array_ptr,

                             size_t                     number_of_elements,

                             size_t                     element_size,

                             a_copy_constructor_ptr	ctor,

                	     void                       *src_array_ptr,

                             a_destructor_ptr  		dtor)

/*

This is an entry point to array_new_general used to call the copy

constructor for each element of an array.  The corresponding element of

the array pointed to by src_array_ptr is the source operand for the

copy constructor.  Because this runtime routine will only be called for

constructor initialization of member arrays, the number_of_elements

can never be zero.

*/

{

  (void)array_new_general(array_ptr, number_of_elements, element_size,

                          (array_ptr == NULL) ? __array_new_prefix_size : 0,

                          src_array_ptr, (a_constructor_ptr)ctor, dtor, 

                          (a_new_ptr)NULL, (a_delete_ptr)NULL,

                          /*is_two_arg=*/FALSE, /*zero_init=*/FALSE);

}  /* __vec_cctor_eh */





#if ABI_COMPATIBILITY_VERSION >= 300

EXTERN_C void *__array_new_zero(size_t                number_of_elements,

                                size_t                element_size,

                                a_constructor_ptr     ctor,

                                a_destructor_ptr        dtor,

                                a_new_ptr             new_routine,

                                a_delete_ptr          delete_routine,

                                int                   is_two_arg)

/*

This entry point is used for operations requiring value-initialization.

In such cases, memory is zeroed before calling a (default) constructor

on it.  See array_new_general for the meaning of the parameters.

*/

{

  return (array_new_general((void*)NULL, number_of_elements, element_size,

                            __array_new_prefix_size, (void*)NULL, ctor, dtor,

                            new_routine, delete_routine, is_two_arg,

                            /*zero_init=*/TRUE));

}  /* __array_new_zero */





EXTERN_C void *__placement_array_new_zero(

                                        void               *array_ptr,

                                        size_t             number_of_elements,

                                        size_t             element_size,

                                        a_constructor_ptr  ctor,

                                        a_destructor_ptr     dtor)

/*

This entry point is used for placement array new operations requiring value-

initialization.  The actual memory is allocated by a call to the appropriate

new routine before this routine is called.  This routine is used to record

the array size information and to call the constructor for each array element.

*/

{

  return (array_new_general(array_ptr, number_of_elements, element_size,

                            __array_new_prefix_size, (void*)NULL, ctor, dtor,

                            (a_new_ptr)NULL, (a_delete_ptr)NULL,

                            /*is_two_arg=*/FALSE, /*zero_init=*/TRUE));

}  /* __placement_array_new_zero */





EXTERN_C void *__vec_new_eh_zero(void               *array_ptr,

                                 size_t             number_of_elements,

                                 size_t             element_size,

                                 a_constructor_ptr  ctor,

                                 a_destructor_ptr     dtor)

/*

This entry point is used by code that uses exception handling for

new operations that do not involve the use of a class specific

operator new but that require memory to be zeroed before the default

constructor is called.

*/

{

  return (array_new_general(array_ptr, number_of_elements, element_size,

                            (array_ptr == NULL) ? __array_new_prefix_size : 0,

                            (void*)NULL, ctor, dtor, (a_new_ptr)NULL, 

                            (a_delete_ptr)NULL, /*is_two_arg=*/FALSE, 

                            /*zero_init=*/TRUE));

}  /* __vec_new_eh_zero */

#endif /* ABI_COMPATIBILITY_VERSION >= 300 */

#else /* defined(__EDG_IA64_ABI) */

EXTERN_C void *ABI_NAMESPACE::__cxa_vec_new(

                                         size_t            number_of_elements,

                                         size_t            element_size,

                                         size_t            prefix_size,

                                         a_constructor_ptr ctor,

                                         a_destructor_ptr    dtor)

/*

The entry point used for ordinary array new.

*/

{

  return (array_new_general((void *)NULL, (int)number_of_elements,

                            element_size, prefix_size, (void *)NULL,

                            ctor, dtor, (a_new_ptr)NULL, (a_delete_ptr)NULL,

                            /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));

}  /* __cxa_vec_new */





EXTERN_C void *ABI_NAMESPACE::__cxa_vec_new2(

                                         size_t            number_of_elements,

                                         size_t            element_size,

                                         size_t            prefix_size,

                                         a_constructor_ptr ctor,

                                         a_destructor_ptr    dtor,

                                         a_new_ptr         new_routine,

                                         a_delete_ptr      delete_routine)

/*

The entry point used for array new with class-specific new and delete

operators.

*/

{

  return (array_new_general((void *)NULL, (int)number_of_elements,

                            element_size, prefix_size, (void *)NULL,

                            ctor, dtor, new_routine, delete_routine,

                            /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));

}  /* __cxa_vec_new2 */





EXTERN_C void *ABI_NAMESPACE::__cxa_vec_new3(

                                  size_t                   number_of_elements,

                                  size_t                   element_size,

                                  size_t                   prefix_size,

                                  a_constructor_ptr        ctor,

                                  a_destructor_ptr           dtor,

                                  a_new_ptr                new_routine,

                                  a_two_operand_delete_ptr delete_routine)

/*

The entry point used for array new with class-specific new and delete

operators where the delete operator, if any, takes two arguments.

*/

{

  return (array_new_general((void *)NULL, (int)number_of_elements,

                            element_size, prefix_size, (void *)NULL,

                            ctor, dtor, new_routine, 

                            (a_delete_ptr)delete_routine,

                            /*is_two_arg=*/TRUE, /*zero_init=*/FALSE));

}  /* __cxa_vec_new3 */





/*

EABI Requires __cxa_vec_ctor and __cxa_vec_cctor to return void* . The value

returned is the same as the first parameter - a pointer to the array being

constructed

C++ ABI for the ARM Architecture, Section 3.2.2.3

*/

#ifdef __eabi__

EXTERN void * ABI_NAMESPACE::__cxa_vec_ctor

#else

EXTERN void ABI_NAMESPACE::__cxa_vec_ctor

#endif

                                        (

                                         void              *array_ptr,

                                         size_t            number_of_elements,

                                         size_t            element_size,

                                         a_constructor_ptr ctor,

                                         a_destructor_ptr    dtor)

/*

The entry point used for constructing an array of objects where the memory has

already been allocated.

*/

{

  (void)(array_new_general(array_ptr, (int)number_of_elements,

                           element_size, /*prefix_size=*/0, (void *)NULL,

                           ctor, dtor, (a_new_ptr)NULL, (a_delete_ptr)NULL,

                           /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));



#ifdef __eabi__

  return array_ptr;

#endif

}  /* __cxa_vec_ctor */



#ifdef __eabi__

EXTERN_C void * ABI_NAMESPACE::__cxa_vec_cctor

#else

EXTERN_C void ABI_NAMESPACE::__cxa_vec_cctor

#endif

                                   (

                                    void                   *array_ptr,

                                    void                   *src_array_ptr,

                                    size_t                 number_of_elements,

                                    size_t                 element_size,

                                    a_copy_constructor_ptr ctor,

                                    a_destructor_ptr         dtor)

/*

The entry point used for copying an array of objects.

*/

{

  (void)(array_new_general(array_ptr, (int)number_of_elements,

                           element_size, /*prefix_size=*/0, src_array_ptr,

                           (a_constructor_ptr)ctor, dtor, (a_new_ptr)NULL,

                            (a_delete_ptr)NULL, /*is_two_arg=*/FALSE, 

                            /*zero_init=*/FALSE));

#ifdef __eabi__

  return array_ptr;

#endif

}  /* __cxa_vec_cctor */



#endif /* defined(__EDG_IA64_ABI) */



#if EXCEPTION_HANDLING 

EXTERN_C void __cleanup_vec_new_or_delete(

/*** START TI ADD ***/

#if !defined(__TI_TABLE_DRIVEN_EXCEPTIONS) 

/*** END TI ADD ***/

					    an_eh_stack_entry_ptr ehsep

/*** START TI ADD ***/

#else

					    an_array_alloc_eh_info_ptr aaehip

#endif /* !defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */

/*** END TI ADD ***/

	                                 )

/*

Called by the exception handling cleanup routine to do the cleanup

processing for a vec_new or vec_delete operation that was interrupted by

an exception.

*/

{

  /* Call the destructor, if specified, on each element in the array, in

     reverse order. */

/*** START TI ADD ***/

#if !defined(__TI_TABLE_DRIVEN_EXCEPTIONS) 

/*** END TI ADD ***/

  an_array_alloc_eh_info_ptr	aaehip = ehsep->variant.array_alloc_eh_info;

/*** START TI ADD ***/

#endif /* !defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */

/*** END TI ADD ***/

  a_destructor_ptr  		dtor = aaehip->destructor;

  a_sizeof_t			number_of_elements;

  a_sizeof_t			element_size;

  void*               		arr_ptr;

  void*				array_ptr;

  a_sizeof_t			i;

  a_sizeof_t		        first_element;



#ifdef __EDG_IA64_ABI

  if (aaehip->terminate_immediately) {

/*** START TI ADD ***/

#if defined(__TI_TABLE_DRIVEN_EXCEPTIONS) 

    __cxa_call_terminate(0);

#else

/*** END TI ADD ***/

    __call_terminate();

/*** START TI ADD ***/

#endif /* defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */

/*** END TI ADD ***/

  }  /* if */

#endif /* defined(__EDG_IA64_ABI) */

  array_ptr = (void *)aaehip->array_ptr;

  element_size = aaehip->element_size;

  if (aaehip->is_vec_new) {

    /* Cleaning up a vec_new.  Destroy the fully constructed elements of

       the array in reverse order. */

    number_of_elements = aaehip->elements_processed;

    first_element = number_of_elements - 1;

  } else {

    first_element = aaehip->number_of_elements -

                    aaehip->elements_processed - 1;

    number_of_elements = first_element + 1;

  }  /* if */

  if (dtor != NULL) {

    /* If there is a destructor, destroy the objects. */

    for (i = 0,

         arr_ptr = (void *)(((char *)array_ptr) +

                                                first_element * element_size);

         i < number_of_elements;

         i++, increment_ptr(arr_ptr, -(int)(element_size))) {

#ifndef __EDG_IA64_ABI

      /* Call the destructor with 0x2 - whole object = TRUE

                                  0x1 - delete object = FALSE. */

      (*dtor)(arr_ptr, 0x2 /*whole object = TRUE, delete = FALSE*/);

#else /* ifdef __EDG_IA64_ABI */

      (*dtor)(arr_ptr);

#endif /* ifdef __EDG_IA64_ABI */

    }  /* for */

  }  /* if */

  if (aaehip->free_memory_on_cleanup) {

    /* Call the routine to free the memory. */

    size_t	size = element_size * aaehip->number_of_elements;

    free_array(array_ptr, size, aaehip->prefix_size,

               aaehip->delete_routine, aaehip->is_two_arg);

  }  /* if */

}  /* __cleanup_vec_new_or_delete */

#endif /* EXCEPTION_HANDLING */





#ifndef __EDG_IA64_ABI

/*ARGSUSED*/ /* terminate_immediately is used only in the IA-64 ABI. */

#endif /* ifndef __EDG_IA64_ABI */

static void array_delete_general(void                *array_ptr,

                                 int		     number_of_elements_param,

                                 size_t              element_size,

                                 size_t              prefix_size,

                                 a_destructor_ptr      dtor,

				 int		     delete_flag,

                                 a_delete_ptr	     delete_routine,

				 int		     is_two_arg,

                                 int                 terminate_immediately)

                                     

/*

Call a destructor for each element of an array, then delete the storage

for the array.  array_ptr points to the array, which has number_of_elements

elements each of size element_size.  If number_of_elements is -1, use the

size stored by vec_new at the time of allocation of this array.  In that case,

the size of the prefix is given by prefix_size.  If array_ptr is NULL, this

routine does nothing and returns.  If dtor is non-NULL, it points to a

destructor function to be called for each element of the array.  If

delete_flag is TRUE, the storage for the array is deallocated after the

destruction; number_of_elements must be -1 for that case.  If

terminate_immediately is TRUE, std::terminate will be called if any of the

destructor elements throws an exception; otherwise, the remainder of the

elements will be destroyed and the exception will be rethrown.

*/

{

  int                   i;

  void                  *arr_ptr;

  size_t		array_size = 0;

  size_t		number_of_elements = number_of_elements_param;



  /* If the address of the array is NULL, do nothing. */

  if (array_ptr != NULL ) {

#if EXCEPTION_HANDLING 

/*** START TI ADD ***/

#if !defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

/*** END TI ADD ***/

    an_eh_stack_entry		ehse;

/*** START TI ADD ***/

#endif /* !defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */

/*** END TI ADD ***/    

    an_array_alloc_eh_info	aaehi;

/*** START TI ADD ***/

#if !defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

/*** END TI ADD ***/

    add_vec_new_or_delete_eh_stack_entry(&ehse, &aaehi, 

                                         /*is_vec_new=*/FALSE);

/*** START TI ADD ***/

#else /* defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */

    aaehi.elements_processed     = 0;

    aaehi.is_vec_new             = FALSE;

#endif /* !defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */



    aaehi.free_memory_on_cleanup = delete_flag;

    aaehi.array_ptr              = array_ptr;

    aaehi.number_of_elements     = number_of_elements;

    aaehi.element_size           = element_size;

    aaehi.prefix_size            = prefix_size;

    aaehi.destructor		 = dtor;

    aaehi.delete_routine	 = delete_routine;

    aaehi.is_two_arg		 = is_two_arg;

#ifdef __EDG_IA64_ABI

    aaehi.terminate_immediately  = terminate_immediately;

#endif /* defined(__EDG_IA64_ABI) */

#endif /* EXCEPTION_HANDLING */

    /* Determine the number of elements in the array, if unknown.  Note that

       number_of_elements_param is used because that value is signed. */

    if (number_of_elements_param == -1 && prefix_size != 0) {

      /* Determine the number of elements from the memory allocation size. */

      array_size = get_array_size(array_ptr, element_size,

				  &number_of_elements);

    }  /* if */

#if EXCEPTION_HANDLING

    aaehi.number_of_elements     = number_of_elements;

#endif /* EXCEPTION_HANDLING */



/*** START TI ADD ***/

#if EXCEPTION_HANDLING && defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

    try {

#endif

/*** END TI ADD ***/



    /* Call the destructor, if specified, on each element in the array, in

       reverse order. */

    if (dtor != NULL) {

      for (i = 0,

           arr_ptr = (void*)((char*)array_ptr +

                             (number_of_elements - 1) * element_size);

           i < number_of_elements;

           i++, increment_ptr(arr_ptr, -(int)(element_size))) {

#if EXCEPTION_HANDLING

        /* Update the counter of the number of elements processed in the

           EH stack entry.  This is incremented before the destructor is

           called so that, should an exception occur, we won't try

           destroying this element again. */

        aaehi.elements_processed++;

#endif /* EXCEPTION_HANDLING */

#ifndef __EDG_IA64_ABI

        /* Call the destructor with 0x2 - whole object = TRUE

                                    0x1 - delete object = FALSE. */

        (*dtor)(arr_ptr, 0x2 /*whole object = TRUE, delete = FALSE*/);

#else /* defined(__EDG_IA64_ABI) */

        (*dtor)(arr_ptr);

#endif /* defined(__EDG_IA64_ABI) */

      }  /* for */

    }  /* if */

#if EXCEPTION_HANDLING 

/*** START TI ADD ***/

#if defined(__TI_TABLE_DRIVEN_EXCEPTIONS)

  } catch (...)

  {

      /* Generic C++ ABI, Sec 3.3.3, Array Construction and Destruction API

       * Catch any exception throw by the destructor. Call the __cleanup

       * function to call the destructor on the remaining elements, then

       * reraise the exception

       * If dtor throws, do not propagate the exception, call terminate.

       */

      try {

	  __cleanup_vec_new_or_delete(&aaehi);

      } catch (...)

      {

	  __cxa_call_terminate(0);

      }

      throw;

  }

#else

/*** END TI ADD ***/

    /* Unlink the vec_new EH stack entry.  This is unlinked before the memory

       for the array is freed.  If an exception occurs during the free

       it should just be handled by the normal mechanism. */

    __curr_eh_stack_entry = __curr_eh_stack_entry->next;

/*** START TI ADD ***/

#endif /* defined(__TI_TABLE_DRIVEN_EXCEPTIONS) */

/*** END TI ADD ***/

#endif /* EXCEPTION_HANDLING */

    /* Delete the array, if requested. */

    if (delete_flag) {

      free_array(array_ptr, array_size, prefix_size, delete_routine,

                 is_two_arg);

    }  /* if */

  }  /* if */

}  /* array_delete_general */



#ifndef __EDG_IA64_ABI

/*ARGSUSED*/ /* <-- "unused" is unused. */

EXTERN_C void __vec_delete(void                *array_ptr,

                           size_t              number_of_elements,

                           size_t              element_size,

                           a_destructor_ptr      dtor,

                           int                 delete_flag,

                           int                 unused)

/*

Entry point used for the normal vector delete operation.  The unused

parameter is there for cfront compatibility.

*/

{

  array_delete_general(array_ptr, number_of_elements, element_size, 

                       (number_of_elements == (size_t)-1) ? 

                                                 __array_new_prefix_size : 0,

                       dtor, delete_flag, (a_delete_ptr)NULL,

                       /*is_two_arg=*/FALSE, /*terminate_immediately=*/FALSE);

}  /* __vec_delete */





#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE

EXTERN_C void __array_delete(void                *array_ptr,

                             size_t              number_of_elements,

                             size_t              element_size,

                             a_destructor_ptr      dtor,

                             a_delete_ptr	 delete_routine,

			     int		 is_two_arg)

/*

This entry point is used for operations that use class specific array

new and delete operators.  The delete routine is pointed to

by delete_routine.  is_two_arg is TRUE if the delete routine is one that

requires two arguments.

*/

{

  array_delete_general(array_ptr, number_of_elements, element_size, 

                       (number_of_elements == (size_t)-1) ? 

                                                __array_new_prefix_size : 0,

                       dtor, /*delete_flag=*/TRUE, delete_routine, 

                       is_two_arg, /*terminate_immediately=*/FALSE);

}  /* __array_delete */

#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */

#else /* defined(__EDG_IA64_ABI) */

EXTERN_C void ABI_NAMESPACE::__cxa_vec_dtor(

                                          void             *array_ptr,

                                          size_t           number_of_elements,

                                          size_t           element_size,

                                          a_destructor_ptr   dtor)

/*

Run the destructors for an array of objects.

*/

{

  array_delete_general(array_ptr, number_of_elements, element_size,

                       /*prefix_size=*/0, dtor, /*delete_flag=*/FALSE,

                       (a_delete_ptr)NULL, /*is_two_arg=*/FALSE,

                       /*terminate_immediately=*/FALSE);

}  /* __cxa_vec_dtor */





EXTERN_C void ABI_NAMESPACE::__cxa_vec_delete(void             *array_ptr,

                                              size_t           element_size,

                                              size_t           prefix_size,

                                              a_destructor_ptr   dtor)

/*

The entry point for ordinary array delete.

*/

{

  array_delete_general(array_ptr, /*number_of_elements=*/-1, element_size,

                       prefix_size, dtor, /*delete_flag=*/TRUE,

                       (a_delete_ptr)NULL, /*is_two_arg=*/FALSE,

                       /*terminate_immediately=*/FALSE);

}  /* __cxa_vec_delete */





EXTERN_C void ABI_NAMESPACE::__cxa_vec_delete2(void             *array_ptr,

                                               size_t           element_size,

                                               size_t           prefix_size,

                                               a_destructor_ptr   dtor,

                                               a_delete_ptr     delete_routine)

/*

The entry point for array delete with a class-specific operator delete.

*/

{

  array_delete_general(array_ptr, /*number_of_elements=*/-1, element_size,

                       prefix_size, dtor, /*delete_flag=*/TRUE,

                       delete_routine, /*is_two_arg=*/FALSE,

                       /*terminate_immediately=*/FALSE);

}  /* __cxa_vec_delete2 */





EXTERN_C void ABI_NAMESPACE::__cxa_vec_delete3(

                                     void                     *array_ptr,

                                     size_t                   element_size,

                                     size_t                   prefix_size,

                                     a_destructor_ptr         dtor,

                                     a_two_operand_delete_ptr delete_routine)

/*

The entry point for array delete with a two-argument class-specific operator

delete.

*/

{

  array_delete_general(array_ptr, /*number_of_elements=*/-1, element_size,

                       prefix_size, dtor, /*delete_flag=*/TRUE,

                       (a_delete_ptr)delete_routine, /*is_two_arg=*/TRUE,

                       /*terminate_immediately=*/FALSE);

}  /* __cxa_vec_delete3 */





EXTERN_C void ABI_NAMESPACE::__cxa_vec_cleanup(

					void             *array_ptr,

					size_t           number_of_elements,

					size_t           element_size,

					a_destructor_ptr dtor)

/*

The entry point used to invoke the destructor on an array of objects,

and to invoke terminate if a destructor exits with a throw.

*/

{

  if (dtor != NULL) {

    array_delete_general(array_ptr, number_of_elements, element_size,

                         /*prefix_size=*/0, dtor, /*delete_flag=*/FALSE,

                         (a_delete_ptr)NULL, /*is_two_arg=*/FALSE,

                         /*terminate_immediately=*/TRUE);

  }  /* if */

}  /* __cxa_vec_cleanup */



#endif /* defined(__EDG_IA64_ABI) */



#ifndef __EDG_IA64_ABI                                     

EXTERN_C void _array_pointer_not_from_vec_new()

/*

This routine is used when a pointer that was not created by vec_new is

passed to one other vector handling routines that needs to get the size

from the information created by vec_new.  This routine simply aborts.

The name is intended to describe the nature of the problem to the user

*/

{

  __abort_execution(ec_array_not_from_vec_new);

}

#endif /* ifndef __EDG_IA64_ABI */



/****************************************************************************/

/*  Array Construction and Destruction Library Helper Functions             */

/*  Extracted from                                                          */

/*  C++ ABI for the ARM Architecture, 30th October 2003. Section 3.2.2.3    */

/*  Copyright (c)  ARM Limited                                              */

/****************************************************************************/



#ifdef __eabi__

namespace __aeabiv1 

{

  using namespace __cxxabiv1;



  using::std::size_t;



  // Note:Only the __aeabi_ * names are exported.

  // array_cookie, cookie_size, cookie_of, etc.are presented for exposition 

  // only. They are not expected to be available to users, but implementers 

  // may find them useful.

  struct array_cookie {

    size_t          element_size; //element_size != 0

    size_t element_count;

  };



  //The struct array_cookie fields and the arguments element_size and 

  //element_count are ordered for convenient use of LDRD / STRD on 

  //architecture 5 TE and above.

  const size_t cookie_size = sizeof(array_cookie);



  //cookie_of() takes a pointer to the user array and returns a reference 

  //to the cookie.

  inline array_cookie & cookie_of(void *user_array) {

    return reinterpret_cast < array_cookie * >(user_array)[-1];

  }



  //element_size_of() takes a pointer to the user array and returns a 

  //reference to the element_size field of the cookie.

  inline size_t & element_size_of(void *user_array) { 

    return cookie_of(user_array).element_size; 

  }



  //element_count_of() takes a pointer to the user array and returns a 

  //reference to the element_count field of the cookie.

  inline size_t & element_count_of(void *user_array) {

    return cookie_of(user_array).element_count;

  }



  //user_array_of() takes a pointer to the cookie and returns a pointer 

  //to the user array.

  inline void *user_array_of(array_cookie * cookie_address) {

    return cookie_address + 1;

  }



extern "C" void *__aeabi_vec_ctor_nocookie_nodtor(

			     void *user_array,

			     void *(*constructor) (void *),

			     size_t element_size, size_t element_count) 

{

    // The meaning of this function is given by the following model 

    // implementation...

    // Note:AEABI mandates that __cxa_vec_ctor return its first argument

    return __cxa_vec_ctor(user_array, element_count, element_size, 

	    	          constructor, NULL);



}



// __aeabi_vec_ctor_cookie_nodtor is like __aeabi_vec_ctor_nocookie_nodtor 

// but sets cookie fields and returns user_array. The parameters are arranged 

// to make STRD usable.Does nothing and returns NULL if cookie is NULL.

extern "C" void *__aeabi_vec_ctor_cookie_nodtor(

			   array_cookie * cookie,

			   void *(*constructor) (void *),

			   size_t element_size, size_t element_count) 

{

    // The meaning of this function is given by the following model 

    // implementation...

    if (cookie == NULL) {

      return NULL;

    } else {

      cookie->element_size = element_size;

      cookie->element_count = element_count;

      return __aeabi_vec_ctor_nocookie_nodtor(

			      user_array_of(cookie), constructor, 

			      element_count, element_size);

   }

}



extern "C" void *__aeabi_vec_cctor_nocookie_nodtor(

			      void *user_array_dest,

			      void *user_array_src,

			      size_t element_size, size_t element_count,

			      void *(*copy_constructor) (void *, void *)) 

{

    // The meaning of this function is given by the following model 

    // implementation...

    // Note:AEABI mandates that __cxa_vec_cctor return its first argument

    return __cxa_vec_cctor(user_array_dest, user_array_src,

		           element_count, element_size, copy_constructor, NULL);

}



extern "C" void *__aeabi_vec_new_cookie_noctor(size_t element_size, 

	                                       size_t element_count) 

{

    // The meaning of this function is given by the following model 

    // implementation...

    array_cookie * cookie =

      reinterpret_cast < array_cookie * >

      (::operator new[] (element_count * element_size + cookie_size));



    cookie->element_size = element_size;

    cookie->element_count = element_count;



    return user_array_of(cookie);

}



extern "C" void *__aeabi_vec_new_nocookie(size_t element_size, 

					  size_t element_count, 

					  void *(*constructor) (void *)) 

{

    // The meaning of this function is given by the following model 

    // implementation...

    return __cxa_vec_new(element_count, element_size, 0, constructor, NULL);

}



extern "C" void *__aeabi_vec_new_cookie_nodtor(size_t element_size, 

	                            	       size_t element_count, 

					       void *(*constructor) (void *)) 

{

    //The meaning of this function is given by the following model 

    //implementation...

    return __cxa_vec_new(element_count, element_size, cookie_size, constructor, NULL);



}



extern "C" void *__aeabi_vec_new_cookie(size_t element_size, 

	                                size_t element_count, 

					void *(*constructor) (void *), 

					void *(*destructor) (void *)) 

{

    // The meaning of this function is given by the following model 

    // implementation...

    return __cxa_vec_new(element_count, element_size, cookie_size, 

	        	 constructor, destructor);

}



// __aeabi_vec_dtor is like __cxa_vec_dtor but has its parameters reordered 

// and returns a pointer to the cookie(assuming user_array has one)

// Unlike __cxa_vec_dtor, destructor must not be NULL.

// user_array must not be NULL.

extern "C" void *__aeabi_vec_dtor(void *user_array, 

				  void *(*destructor) (void *), 

				  size_t element_size, 

				  size_t element_count) 

{

    // The meaning of this function is given by the following model 

    // implementation...

    __cxa_vec_dtor(user_array, element_count, element_size, destructor);

    return &cookie_of(user_array);

}



// __aeabi_vec_dtor_cookie is only used on arrays that have cookies.

// __aeabi_vec_dtor is like __cxa_vec_dtor but returns a pointer to the 

// cookie. That is, it takes a pointer to the user array, calls the 

// given destructor on each element(from highest index down to zero) and 

// returns a pointer to the cookie.

// Does nothing and returns NULL if cookie is NULL.

// Unlike __cxa_vec_dtor, destructor must not be NULL.

// Exceptions are handled as in __cxa_vec_dtor.

// __aeabi_vec_dtor_cookie must not change the element count in the cookie.

// (But it may corrupt the element size if desired.)

extern "C" void *__aeabi_vec_dtor_cookie(void *user_array, 

					 void *(*destructor) (void *)) 

{

    // The meaning of this function is given by the following model 

    // implementation...

    // like:

    // __cxa_vec_dtor(user_array, element_count_of(user_array),

    // element_size_of(user_array), destructor);

    return user_array == NULL ? NULL :

      __aeabi_vec_dtor(user_array, destructor,

	       element_size_of(user_array), element_count_of(user_array));

}



extern "C" void __aeabi_vec_delete(void *user_array, 

	               	           void *(*destructor) (void *)) 

{

    // The meaning of this function is given by the following model 

    // implementation...

    // like:__cxa_vec_delete(user_array, element_size_of(user_array),

    // cookie_size, destructor);

    ::operator delete[] (__aeabi_vec_dtor_cookie(user_array, destructor));

}



extern "C" void __aeabi_vec_delete3(void *user_array, 

			 	    void *(*destructor) (void *), 

				    void (*dealloc) (void *, size_t)) 

{

    // The meaning of this function is given by the following model 

    // implementation...

    // like:__cxa_vec_delete3(user_array, element_size_of(user_array),

    // cookie_size, destructor, decalloc);

    if (user_array != NULL) {

      size_t size = element_size_of(user_array) * element_count_of(user_array) 

	            + cookie_size;

      (*dealloc) (__aeabi_vec_dtor_cookie(user_array, destructor), size);

    }

}



extern "C" void __aeabi_vec_delete3_nodtor(void *user_array, 

	                                   void (*dealloc) (void *, size_t)) 

{

    // The meaning of this function is given by the following model 

    // implementation...

    // like:__cxa_vec_delete3(user_array, element_size_of(user_array),

    // cookie_size, 0, decalloc);

    if (user_array != NULL) {

      size_t size = element_size_of(user_array) * element_count_of(user_array) 

	            + cookie_size;

      (*dealloc) (&cookie_of(user_array), size);

    }

}



} //namespace __aeabiv1

#endif /* __eabi__ */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/


vec_newdel.h/   1148595159  0     0     0       3012      `
/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Declarations for runtime routines for vector new() and delete() functionality.



*/



#ifndef VEC_NEWDEL_H

#define VEC_NEWDEL_H



#include "runtime.h"



#ifndef __EDG_IA64_ABI



EXTERN_C void *__vec_new_eh(void                         *array_ptr,

                            size_t                          number_of_elements,

                            size_t                       element_size,

                            a_constructor_ptr	 	 ctor,

                            a_destructor_ptr	         dtor);



EXTERN_C void *__vec_new(void                         *array_ptr,

                         size_t                          number_of_elements,

                         size_t                       element_size,

                         a_constructor_ptr            ctor);



EXTERN_C void __vec_delete(void                *array_ptr,

                           size_t              number_of_elements,

                           size_t              element_size,

                           a_destructor_ptr    dtor,

                           int                 delete_flag,

                           int                 /*unused_arg*/);



EXTERN_C void _array_pointer_not_from_vec_new();



#endif /* ifdef __EDG_IA64_ABI */



/*

Type name used by the exception handling mechanism to point to the

structure used to maintain information about array new and delete

operations that are in process.

*/

typedef struct an_array_alloc_eh_info *an_array_alloc_eh_info_ptr;



#endif /* ifndef VEC_NEWDEL_H */



/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

vectors.asm/    1148595159  0     0     0       2586      `
;****************************************************************************

;* VECTORS.ASM  v3.3.2 - Prototype Interrupt Vector Table for C55X C Runtime

;* Copyright (c) 1993-2006  Texas Instruments Incorporated                   

;****************************************************************************



	.model  call=internal



;****************************************************************************

; Interrupt Vector Table

;

; 32 interrupt vector addresses.  Each is 64 bits long.  The first 32 bits

; contains the 24-bit program address of the Interrupt Service Routine (ISR).

; The second 32 bits are executed before transferring control to the ISR.

;****************************************************************************



	.sect	"vectors"



;****************************************************************************

;* Point Reset Vector to C Environment Entry Point                           

;****************************************************************************

	.def	_Reset

	.ref	_c_int00



	.if __TMS320C55X_PLUS_BYTE__

_Reset:	.ivec _c_int00, STK_LINEAR | RET_FAST | DATA_PTR_BYTE

	.else

_Reset:	.ivec _c_int00, USE_RETA

	.endif



;****************************************************************************

;* Other interrupt vector definitions go here

;****************************************************************************



nmi:	.ivec _no_handler  ; Non-maskable hardware interrupt

int02:	.ivec _no_handler

int03:	.ivec _no_handler

int04:	.ivec _no_handler

int05:	.ivec _no_handler

int06:	.ivec _no_handler

int07:	.ivec _no_handler

int08:	.ivec _no_handler

int09:	.ivec _no_handler

int10:	.ivec _no_handler

int11:	.ivec _no_handler

int12:	.ivec _no_handler

int13:	.ivec _no_handler

int14:	.ivec _no_handler

int15:	.ivec _no_handler

int16:	.ivec _no_handler

int17:	.ivec _no_handler

int18:	.ivec _no_handler

int19:	.ivec _no_handler

int20:	.ivec _no_handler

int21:	.ivec _no_handler

int22:	.ivec _no_handler

int23:	.ivec _no_handler

int24:	.ivec _no_handler  ; Bus error interrupt

int25:	.ivec _no_handler  ; Data log interrupt

int26:	.ivec _no_handler  ; Real-time OS interrupt

int27:	.ivec _no_handler  ; General-purpose software-only interrupt

int28:	.ivec _no_handler  ; General-purpose software-only interrupt

int29:	.ivec _no_handler  ; General-purpose software-only interrupt

int30:	.ivec _no_handler  ; General-purpose software-only interrupt

int31:	.ivec _no_handler  ; General-purpose software-only interrupt



	.text

_no_handler: goto _no_handler



       .end

vfprintf.c/     1148595159  0     0     0       2788      `
/*****************************************************************************/

/*  VFRINTF.C v3.3.2                                                         */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    VFPRINTF -  Print formatted output to a stream                         */

/*    _OUTC    -  Put a character in a stream                                */

/*    _OUTS    -  Put a string in a stream                                   */

/*****************************************************************************/

#include "format.h"

#include <stdarg.h>

#include <stdio.h>

#include <string.h>

 

extern int _printfi(char **_format, va_list _ap, void *_op, 

                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

 

static int _outc(char c, void *_op);

static int _outs(char *s, void *_op);

 

/*****************************************************************************/

/* VFPRINTF -  Print formatted output to a stream                            */

/*                                                                           */

/*    This function passes a the format string and an argument list to       */

/*    _PRINTFI, and writes the result string to the stream _FP.              */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int vfprintf(FILE *_fp, const char *_format, va_list _ap)

{

   char *fptr = (char *)_format;



   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if(_fp->fd == -1) return (-1);



   return (_printfi(&fptr, _ap, (void *)_fp, _outc, _outs));

 

}

 

/*****************************************************************************/

/* _OUTC -  Put a character in a stream                                      */

/*****************************************************************************/

static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }

 

/*****************************************************************************/

/* _OUTS -  Put a string in a stream                                         */

/*****************************************************************************/

static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }

vprintf.c/      1148595159  0     0     0       2793      `
/*****************************************************************************/

/*  VPRINTF.C v3.3.2                                                         */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    VPRINTF  -  Print formatted output to stdio                            */

/*    _OUTC    -  Put a character in a stream                                */

/*    _OUTS    -  Put a string in a stream                                   */

/*****************************************************************************/

#include <stdio.h>

#include "format.h"

#include <stdarg.h>

#include <string.h>

 

extern int _printfi(char **_format, va_list _ap, void *_op,

                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

 

static int _outc(char c, void *_op);

static int _outs(char *s, void *_op);

 



/*****************************************************************************/

/* VPRINTF  -  Print formatted output to a stdio                             */

/*                                                                           */

/*    This function passes a the format string and an argument list to       */

/*    _PRINTFI, and writes the result string to the stream stdio.            */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int vprintf(const char *_format, va_list _ap)

{

   char *fptr = (char *)_format;



   /*------------------------------------------------------------------------*/

   /* If the current stream is not associated with a file, return an error.  */

   /*------------------------------------------------------------------------*/

   if(stdout->fd == -1) return (EOF);



   return (_printfi(&fptr, _ap, (void *)stdout, _outc, _outs));

 

}

 



/*****************************************************************************/

/* _OUTC -  Put a character in a stream                                      */

/*****************************************************************************/

static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }

 



/*****************************************************************************/

/* _OUTS -  Put a string in a stream                                         */

/*****************************************************************************/

static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }




vsnprintf.c/    1148595159  0     0     0       3268      `
/*****************************************************************************/

/*  VSNPRINTF.C v3.3.2                                                       */

/*  Copyright (c) 2001-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    VSNPRINTF -  Copy formatted output to a string                         */

/*    _OUTC     -  Put a character in a string                               */

/*    _OUTS     -  Append a string to another string                         */

/*****************************************************************************/

#include <stdio.h>

#include "format.h"

#include <stdarg.h>

#include <string.h>

 

extern int _printfi(char **_format, va_list _ap, void *_op,

                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

 

static int _outc(char c, void *_op);

static int _outs(char *s, void *_op);



struct holder {

    char  *out_end;

    size_t n;

    size_t written;

};





/*****************************************************************************/

/* VSNPRINTF -  Copy formatted output to a string                            */

/*                                                                           */

/*    This function passes a format string and an argument list to           */

/*    _PRINTFI, and writes the result string to the string _STRING.          */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int vsnprintf(char *_string, size_t _n,

			   const char *_format, va_list _ap)

{

    int    rval;

    char  *fptr = (char *)_format;

    struct holder holder; 



    holder.out_end = _string;

    holder.n       = _n;

    holder.written = 0;



    rval = _printfi(&fptr, _ap, (void *)&holder, _outc, _outs);

    

    if (_n) *holder.out_end = '\0';

    

    return rval;

}





/*****************************************************************************/

/* _OUTC -  Put a character in a string                                      */

/*****************************************************************************/

static int _outc(char c, void *_op)

{

    struct holder *holder = (struct holder *)_op;

    

    if (holder->written < holder->n)

	*holder->out_end++ = c;

    

    holder->written++;

    

    return c;

}

 



/*****************************************************************************/

/* _OUTS -  Append a string to another string                                */

/*****************************************************************************/

static int _outs(char *s, void *_op)

{

    struct holder *holder = (struct holder *)_op;

    size_t len = strlen(s);



    if (holder->written < holder->n)

    {

	size_t space = holder->n - holder->written;

	size_t use = len > space ? space : len;

	memcpy(holder->out_end, s, use);

	holder->out_end += use;

    }

    

    holder->written += len;



    return len;

}

 

vsprintf.c/     1148595159  0     0     0       2711      `
/*****************************************************************************/

/*  VSPRINTF.C v3.3.2                                                        */

/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */

/*****************************************************************************/



/*****************************************************************************/

/* Functions:                                                                */

/*    VSPRINTF -  Copy formatted output to a string                          */

/*    _OUTC    -  Put a character in a string                                */

/*    _OUTS    -  Append a string to another string                          */

/*****************************************************************************/

#include <stdio.h>

#include "format.h"

#include <stdarg.h>

#include <string.h>

 

extern int _printfi(char **_format, va_list _ap, void *_op,

                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

 

static int _outc(char c, void *_op);

static int _outs(char *s, void *_op);





/*****************************************************************************/

/* VSPRINTF -  Copy formatted output to a string                             */

/*                                                                           */

/*    This function passes a format string and an argument list to           */

/*    _PRINTFI, and writes the result string to the string _STRING.          */

/*                                                                           */

/*****************************************************************************/

_CODE_ACCESS int vsprintf(char *_string, const char *_format, va_list _ap)

{

    int   rval;

    char *fptr = (char *)_format;

    char *out_end = _string;



    rval = _printfi(&fptr, _ap, (void *)&out_end, _outc, _outs);



    *out_end = '\0';



    return rval;

}





/*****************************************************************************/

/* _OUTC -  Put a character in a string                                      */

/*****************************************************************************/

static int _outc(char c, void *_op)

{

    return *(*((char **)_op))++ = c;

}

 



/*****************************************************************************/

/* _OUTS -  Append a string to another string                                */

/*****************************************************************************/

static int _outs(char *s, void *_op)

{

    size_t len = strlen(s);

    

    memcpy(*((char **)_op), s, len);

    *((char **)_op) += len;

    return len;

}

 


vtbl.h/         1148595159  0     0     0       3165      `
/*****************************************************************************/

/* vtbl.h v3.3.2                                                             */

/* Copyright (c) 1996-2006 Texas Instruments Inc., all rights reserved       */

/*****************************************************************************/

/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/

/*



Virtual function table entry layout.



*/



#ifndef _VTBL_H

#define _VTBL_H



#ifndef __EDG_IA64_ABI

#if 1

   struct a_vtbl_entry

   {

      short   delta;      /* OFFSET TO GET TO THE COMPLETE OBJECT   */

      void  (*func)();    /* VIRTUAL FUNCTION TO BE CALLED          */

   };

#else

struct a_vtbl_entry {

  __EDG_DELTA_TYPE

		delta;

			/* Value to be added to the "this" pointer to adjust

			   it to point to the class for which the virtual

			   function is actually defined. */

  __EDG_VIRTUAL_FUNCTION_INDEX_TYPE

		index;

			/* Index into the virtual function table.  Only

			   used in member function pointers, not present in

			   vtbl entries.  Cfront uses the same structure for

		  	   both member pointers and vtbl entries, so this is

			   present for cfront compatibility. */

  union {

    a_void_function_ptr

		ptr;

			/* Pointer to the function to be called. */

    a_type_info_impl_ptr

		type_info_impl;

			/* Pointer to the type information implementation

			   entry.  This is present in slot zero of the

			   virtual function table. */

  } function;

};

#endif

#else /* defined(__EDG_IA64_ABI) */



typedef __EDG_DELTA_TYPE a_vtbl_entry;



#endif /* defined(__EDG_IA64_ABI) */



typedef 

/*** START TI ADD ***/

const  

/*** END TI ADD ***/

a_vtbl_entry *a_vtbl_entry_ptr;



#endif /* ifndef _VTBL_H */





/******************************************************************************

*                                                             \  ___  /       *

*                                                               /   \         *

* Edison Design Group C++  Runtime                           - | \^/ | -      *

* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *

* All rights reserved.  Consult your license regarding        /  | |  \       *

* permissions and restrictions.                                  [_]          *

*                                                                             *

******************************************************************************/



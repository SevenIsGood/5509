<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C55XX CSL 3.06.00 Examples: POWER EXAMPLE DOCUMENTATION</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C55XX CSL 3.06.00 Examples
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">POWER EXAMPLE DOCUMENTATION </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="POWER1"></a>
POWER EXAMPLE1 - I2C Register Access &amp; clock stop TEST</h1>
<h2><a class="anchor" id="POWER1x"></a>
TEST DESCRIPTION:</h2>
<p>I2C REG R/W RECOVERY AFTER CLOCK GATING </p><pre class="fragment">   This test starts reading default after-reset values in the
</pre><p> I2C register space and validates them to be as expected by the datasheet. In between the clock to the I2C peripheral is shut off and restarted. The I2C register space r/w check is resumed. The r/w shouldn't be affected by the shutdown-restart activity on the clock to the I2C module.</p>
<h2><a class="anchor" id="POWER1y"></a>
TEST PROCEDURE:</h2>
<ol type="1">
<li>Configure the clock to the I2C module.</li>
<li>Start reading the default after-reset values of the I2C registers.</li>
<li>Compare them with the expected values as mentioned in the datasheet.</li>
<li>Shut down the clock to I2C peripheral by setting the corresponding bit in PCGCR1.</li>
<li>After a small delay, restart the clock by clearing the same bit.</li>
<li>Resume reg r/w and ensure there are no mismatches.</li>
</ol>
<h2><a class="anchor" id="POWER1z"></a>
TEST RESULT:</h2>
<p>All the CSL APIs should return success. Reg r/w shouldn't throw any mismatch.</p>
<h1><a class="anchor" id="POWER12"></a>
POWER EXAMPLE12 - McSPI MASTER FULL DUPLEX  CLK GATING TEST</h1>
<h2><a class="anchor" id="POWER12x"></a>
TEST DESCRIPTION:</h2>
<p>This test code verifies the full duplex functionality of CSL McSPI module. McSPI module on the C5517 DSP is used to communicate with SPI MsP430. This test code verifies the McSPI functionality with MsP430 SPI .</p>
<p>CSL McSPI module will be configured using McSPI_config() API.Write,Read function used for data transfer operation. After successful completion of the write operation read sent to the SPI.Write and read buffers are compared for the data verification. A small amount of delay is required after each data operation to allow the device get ready for next data operation.</p>
<p>NOTE: THIS TEST HAS BEEN DEVELOPED TO WORK WITH CHIP VERSION C5517. MAKE SURE THAT PROPER CHIP VERSION MACRO IS DEFINED IN THE FILE c55xx_csl\inc\csl_general.h. "#define CHIP_C5517"</p>
<h2><a class="anchor" id="POWER12y"></a>
TEST PROCEDURE:</h2>
<pre class="fragment">   Load the slave program in msp430
   Load the program in C5517


   Run the slave program first &amp; then the C5517 master program.
   Master program will print the Tx,Rx data .
</pre><h2><a class="anchor" id="POWER12z"></a>
TEST RESULT:</h2>
<p>All the CSL APIs should return success Run the slave program first &amp; then the master program Data in the read and write buffers should match.(or)Data needs to be verified in Slave program buffer</p>
<p>Data should loopback &amp; printed as below</p>
<p>McSPI Tx Data : 0 McSPI Rx data : ff count=1</p>
<p>McSPI Tx Data : 1 McSPI Rx data : fe count=2</p>
<p>McSPI Tx Data : 2 McSPI Rx data : 0 count=3</p>
<p>McSPI Tx Data : 3 McSPI Rx data : 1 count=4</p>
<p>McSPI Tx Data : 4 McSPI Rx data : 2 count=5</p>
<p>McSPI Tx Data : 5 McSPI Rx data : 3 count=6</p>
<p>McSPI Tx Data : 6 McSPI Rx data : 4 count=7</p>
<p>McSPI Tx Data : 7 McSPI Rx data : 5 count=8 ... ... ...</p>
<p>McSPI Tx data : 19 McSPI Rx data : 17 count = 26</p>
<p>McSPI Tx data : 1a McSPI Rx data : 18 count = 27</p>
<p>McSPI Tx data : 1b McSPI Rx data : 19 count = 28</p>
<p>McSPI Tx data : 1c McSPI Rx data : 1a count = 29</p>
<p>McSPI Tx data : 1d McSPI Rx data : 1b count = 30</p>
<p>McSPI Tx data : 1e McSPI Rx data : 1c count = 31</p>
<p>McSPI Tx data : 1f McSPI Rx data : 1d count = 32 count = 33 count = 34 count = 35 count = 36 count = 37 count = 38 count = 39 count = 40 count = 41 count = 42 count = 43 count = 44 count = 45 count = 46 count = 47 count = 48 count = 49 count = 50 count = 51 count = 52 count = 53 count = 54 count = 55 count = 56 count = 57 count = 58 count = 59 count = 60 count = 61 count = 62 count = 63 count = 64 count = 64</p>
<p>McSPI Tx data : 20 McSPI Rx data : 1e count = 65</p>
<p>McSPI Tx data : 21 McSPI Rx data : 1f count = 66</p>
<p>McSPI Tx data : 22 McSPI Rx data : 20 count = 67</p>
<p>McSPI Tx data : 23 McSPI Rx data : 21 count = 68</p>
<p>McSPI Tx data : 24 McSPI Rx data : 22 count = 69</p>
<h1><a class="anchor" id="POWER2"></a>
POWER EXAMPLE2 - ALL LDO ENABLE MODE TEST</h1>
<h2><a class="anchor" id="POWER2x"></a>
TEST DESCRIPTION:</h2>
<p>This test runs a dummy while loop while power can be measured with all LDO's enabled.</p>
<h2><a class="anchor" id="POWER2y"></a>
TEST PROCEDURE:</h2>
<ol type="1">
<li>Ensure CLK_SEL C7 pin is low</li>
<li>Ensure nDSP_LDO_EN pin D12 is low</li>
<li>ANA_LDO is always enabled on Power ON</li>
<li>Open the CCS and connect the target (C5517 EVM-Master board)</li>
<li>Open the project "CSL_PowerManagement_AllLDOEn_Example.pjt" and build it</li>
<li>Load the program on to the target</li>
</ol>
<h1><a class="anchor" id="POWER3"></a>
POWER EXAMPLE3 - IDLE2 RECOVERY USING RTC ALARM</h1>
<h2><a class="anchor" id="POWER3x"></a>
TEST DESCRIPTION:</h2>
<p>This test configures RTC for generating an alarm 8s after it's started, during which period the system is put into IDLE2 state. The subsequent RTC alarm interrupt should bring the CPU out of the IDLE2 state and resume execution from where it was before it idled out.</p>
<h2><a class="anchor" id="POWER3y"></a>
TEST PROCEDURE AND EXPECTED RESULT:</h2>
<ol type="1">
<li>Ensure JP10 CLKSEL is shorted so that usb osc is not used.</li>
<li>Run the test. The RTC alarm (expected after approx. 30s) would be set.</li>
<li>Test will stop once usb clk is shut off.</li>
<li>Pause and Resume the test.</li>
<li>The test will execute the idle instsrn that will idle the cpu and wait for the alarm.</li>
<li>Observe if the alarm interrupt got the CPU out of idle state.</li>
</ol>
<h1><a class="anchor" id="POWER4"></a>
POWER EXAMPLE4 -  IDLE3 RECOVERY</h1>
<h2><a class="anchor" id="POWER4x"></a>
TEST DESCRIPTION:</h2>
<p>This test configures RTC for generating an alarm 8s after it's started, during which period the system is put into IDLE3 state. The subsequent RTC alarm interrupt should bring the CPU out of the IDLE3 state and resume execution from where it was before it idled out.</p>
<h2><a class="anchor" id="POWER4y"></a>
TEST PROCEDURE AND EXPECTED RESULT:</h2>
<ol type="1">
<li>Ensure JP10 CLKSEL is shorted so that usb osc is not used.</li>
<li>Run the test. The RTC alarm (expected after approx. 30s) would be set.</li>
<li>Test will stop once usb clk is shut off.</li>
<li>Pause and Resume the test.</li>
<li>The test will execute the idle instsrn that will idle the cpu and wait for the alarm.</li>
<li>Observe if the alarm interrupt got the CPU out of idle state.</li>
</ol>
<h1><a class="anchor" id="POWER5"></a>
POWER EXAMPLE5 - PLL MAX</h1>
<h2><a class="anchor" id="POWER5x"></a>
TEST DESCRIPTION:</h2>
<p>This test configures RTC to generate an alarm 18s after it's started, during which period the system is put into IDLE3 state. The subsequent RTC alarm interrupt should bring the CPU out of the IDLE3 state and resume execution from where it was before it idled out.</p>
<p>When coming out of IDLE3 state, when PLL was shut off, the PLL is reconfigured to run at 200MHz and restarted. power can be measured while a while(1) is executed at this PLL freqeuncy.</p>
<h2><a class="anchor" id="POWER5y"></a>
TEST PROCEDURE:</h2>
<p>0. Ensure SW6 [1:2] are {ON,ON}, i.e. away from the DOT.</p><ol type="1">
<li>Ensure JP10 CLKSEL is shorted so that usb osc is not used.</li>
<li>Run the test. The RTC alarm (expected after approx. 30s) would be set.</li>
<li>Test will stop once usb clk is shut off.</li>
<li>Pause and Resume the test.</li>
<li>The test will execute the idle instsrn that will idle the cpu and wait for the alarm.</li>
<li>Observe if the alarm interrupt got the CPU out of idle state.</li>
<li>Reconfigure PLL frequency to generate 200MHz.</li>
<li>Execute a while(1) with CPU @200MHz.</li>
</ol>
<h1><a class="anchor" id="POWER6"></a>
POWER EXAMPLE6 -  I2S DMA TXN IN IDLE2</h1>
<h2><a class="anchor" id="POWER6x"></a>
TEST DESCRIPTION:</h2>
<p>This test configures RTC for generating an alarm 8s after it's started, during which period the system is put into IDLE2 state. During the same time, an I2S0(Tx)-I2S2(Rx) DMA transaction is also initiated. The expected RTC alarm interrupt should bring the CPU out of the IDLE2 state and resume execution from where it was before it idled out. Also, the I2S DMA transaction should have gone through and the rx'ed and tx'ed data shouldn't mismatch.</p>
<h2><a class="anchor" id="POWER6y"></a>
TEST PROCEDURE AND EXPECTED RESULT:</h2>
<p>Manual test with I2S0 connect to I2S2, measuring power on JP1</p><ol type="1">
<li>Ensure JP10 CLKSEL is shorted so that usb osc is not used.</li>
<li>Run the test. The RTC alarm (expected after approx. 30s) would be set.</li>
<li>Test will stop once usb clk is shut off.</li>
<li>Pause and Resume the test.</li>
<li>The test will also configure I2S0 as Tx and I2S2 as Rx and initiate a txfer using DMA.</li>
<li>While CPU waits for DMA done, the test will execute the idle instsrn that will idle the cpu and wait for the alarm.</li>
<li>Observe if the alarm interrupt got the CPU out of idle state and the I2S transaction goes through.</li>
<li>A comparison of the I2S Read and Write buffers should not throw a mismatch.</li>
</ol>
<h1><a class="anchor" id="POWER7"></a>
POWER EXAMPLE7 - UART IDLE2/RECOVERY TEST</h1>
<h2><a class="anchor" id="POWER7x"></a>
TEST DESCRIPTION:</h2>
<p>This test configures RTC for generating an alarm 8s after it's started, during which period the system is put into IDLE2 state. During the same time, an UART transaction is also initiated. The expected RTC alarm interrupt should bring the CPU out of the IDLE2 state and resume execution from where it was before it idled out. Also, the UART transaction should have gone through.</p>
<h2><a class="anchor" id="POWER7y"></a>
TEST PROCEDURE AND EXPECTED RESULT:</h2>
<ol type="1">
<li>Manual test with Pin2/3, Pin7/8 on DB-9 connected, power measured on JP1</li>
<li>Run the test. The RTC alarm (expected after approx. 30s) would be set.</li>
<li>Test will stop once usb clk is shut off.</li>
<li>Pause and Resume the test.</li>
<li>The test will also configure UART and initiate a txfer .</li>
<li>While CPU waits UART transfers, the test will execute the idle instsrn that will idle the cpu and wait for the alarm.</li>
<li>Observe if the alarm interrupt got the CPU out of idle state and the UART transaction goes through.</li>
</ol>
<h1><a class="anchor" id="POWER13"></a>
POWER EXAMPLE13 -  UHPI REG R/W RECOVERY AFTER CLOCK GATING</h1>
<h2><a class="anchor" id="POWER13x"></a>
TEST DESCRIPTION:</h2>
<p>This test starts reading default after-reset values in the UHPI register space and validates them to be as expected by the datasheet. In between the clock to the UHPI peripheral is shut off and restarted. The UHPI register space r/w check is resumed. The r/w shouldn't be affected by the shutdown-restart activity on the clock to the UHPI module.</p>
<h2><a class="anchor" id="POWER13y"></a>
TEST PROCEDURE:</h2>
<ol type="1">
<li>Configure the clock to the UHPI module.</li>
<li>Start reading the default after-reset values of the UHPI registers.</li>
<li>Compare them with the expected values as mentioned in the datasheet.</li>
<li>Request for gating UHPI clock by setting the corresponding bit in CLKSTOP1 and wait till ack is received in corresponding bit, again in CLKSTOP1.</li>
<li>Shut down the clock to UHPI peripheral by setting the corresponding bit in PCGCR1.</li>
<li>After a small delay, restart the clock by clearing the same bit.</li>
<li>Resume reg r/w and ensure there are no mismatches.</li>
</ol>
<h2><a class="anchor" id="POWER13z"></a>
TEST RESULT:</h2>
<p>All the CSL APIs should return success. Reg r/w shouldn't throw any mismatch.</p>
<h1><a class="anchor" id="POWER8"></a>
POWER EXAMPLE8 -  IDLE2 RECOVERY USING RTC ALARM</h1>
<h2><a class="anchor" id="POWER8x"></a>
TEST DESCRIPTION:</h2>
<p>This test configures RTC for generating an alarm 8s after it's started, during which period the system is put into IDLE2 state. The subsequent RTC alarm interrupt should bring the CPU out of the IDLE2 state and resume execution from where it was before it idled out.</p>
<h2><a class="anchor" id="POWER8y"></a>
TEST PROCEDURE AND EXPECTED RESULT:</h2>
<ol type="1">
<li>Ensure JP10 CLKSEL is shorted so that usb osc is not used.</li>
<li>Run the test. The RTC alarm (expected after approx. 30s) would be set.</li>
<li>Test will stop once usb clk is shut off.</li>
<li>Pause and Resume the test.</li>
<li>The test will execute the idle instsrn that will idle the cpu and wait for the alarm.</li>
<li>Observe if the alarm interrupt got the CPU out of idle state.</li>
</ol>
<h1><a class="anchor" id="POWER9"></a>
POWER EXAMPLE9 - IDLE2 Interrupt External event</h1>
<h2><a class="anchor" id="POWER9x"></a>
TEST DESCRIPTION:</h2>
<p>This test configures RTC for generating a wakeup interrupt based on an external event after it's started, during which period the system is put into IDLE2 state. The subsequent RTC external interrupt should bring the CPU out of the IDLE2 state and resume execution from where it was before it idled out.</p>
<h2><a class="anchor" id="POWER9y"></a>
TEST PROCEDURE AND EXPECTED RESULT:</h2>
<ol type="1">
<li>Ensure JP10 CLKSEL is shorted so that usb osc is not used.</li>
<li>Run the test.</li>
<li>It will stop once usb clk is shut off.</li>
<li>Pause and Resume the test.</li>
<li>The test will execute the idle instsrn that will idle the cpu and wait.</li>
<li>Move the jumper JP6 (on C5517 EVM)/ JP5 (on C5515 evm) from 1-2 position to 2-3 position. WAKEUP toggles HIGH-&gt;LOW.</li>
<li>Observe if the external event interrupt got the CPU out of idle state.</li>
</ol>
<h1><a class="anchor" id="POWER10"></a>
POWER EXAMPLE10 - RTC ALARM</h1>
<h2><a class="anchor" id="POWER10x"></a>
TEST DESCRIPTION:</h2>
<p>This test configures RTC for generating an alarm 5s after it's started.</p>
<h2><a class="anchor" id="POWER10y"></a>
TEST PROCEDURE AND EXPECTED RESULT:</h2>
<ol type="1">
<li>Run the test.</li>
<li>The RTC alarm (expected after approx. 5s) would be set and RTC started.</li>
<li>The test will display Current time and wait for the alarm.</li>
<li>Observe if the alarm interrupt got generated.</li>
</ol>
<h1><a class="anchor" id="POWER11"></a>
POWER EXAMPLE11 - RTC Idle2 mode external evt wakeup example</h1>
<h2><a class="anchor" id="POWER11x"></a>
TEST DESCRIPTION:</h2>
<p>This test configures RTC for an external event after it's started.</p>
<h2><a class="anchor" id="POWER11y"></a>
TEST PROCEDURE AND EXPECTED RESULT:</h2>
<ol type="1">
<li>Run the test. RTC would be configured for Ext event and RTC started.</li>
<li>The test will wait for the external event interrupt.</li>
<li>Move the jumper JP6 (on C5517 EVM)/ JP5 (on C5515 evm) from 1-2 position to 2-3 position. WAKEUP toggles HIGH-&gt;LOW.</li>
<li>Observe if the external event interrupt got generated. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>

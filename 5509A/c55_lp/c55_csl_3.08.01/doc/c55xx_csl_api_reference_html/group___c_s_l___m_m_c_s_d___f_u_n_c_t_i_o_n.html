<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C55XX CSL 3.06.00 API: MMC/SD Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C55XX CSL 3.06.00 API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MMC/SD Functions<div class="ingroups"><a class="el" href="group___c_s_l___m_m_c_s_d___a_p_i.html">MMCSD</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf5230667e9cde16496d716c5b5fd14f"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gaaf5230667e9cde16496d716c5b5fd14f">MMC_init</a> (void)</td></tr>
<tr class="separator:gaaf5230667e9cde16496d716c5b5fd14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac69a19e39587bc4bc74144287050c64b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open</a> (<a class="el" href="struct_c_s_l___m_m_c_controller_obj.html">CSL_MMCControllerObj</a> *pMmcsdContObj, <a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#gae4058f773c9cc4adc86d490cac7267b3">CSL_MmcsdInstId</a> instId, <a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#gae6360eb80b01a15bae49ca23e73b5743">CSL_MMCSDOpMode</a> opMode, CSL_Status *status)</td></tr>
<tr class="separator:gac69a19e39587bc4bc74144287050c64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d40be0282818757b7e0db8a16ee828f"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga3d40be0282818757b7e0db8a16ee828f">MMC_close</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr class="separator:ga3d40be0282818757b7e0db8a16ee828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78aad8f81a6cb388dff08240e39fc018"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga78aad8f81a6cb388dff08240e39fc018">MMC_setCardType</a> (<a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *pCardObj, <a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#ga90fae15acd7c0ccde7119b9e47ec7a76">CSL_CardType</a> cardType)</td></tr>
<tr class="separator:ga78aad8f81a6cb388dff08240e39fc018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96a951e3a784d66d98977177b0924959"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga96a951e3a784d66d98977177b0924959">MMC_setCardPtr</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *pMmcCardObj)</td></tr>
<tr class="separator:ga96a951e3a784d66d98977177b0924959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1470b3d6a92e29588d52deb2b9673f5"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gae1470b3d6a92e29588d52deb2b9673f5">MMC_setCallBack</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_call_back_obj.html">CSL_MMCCallBackObj</a> *pFunction)</td></tr>
<tr class="separator:gae1470b3d6a92e29588d52deb2b9673f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01b5cd5567e2e2be698da24efab4637b"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga01b5cd5567e2e2be698da24efab4637b">MMC_getNumberOfCards</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint16 *pActiveNoCard)</td></tr>
<tr class="separator:ga01b5cd5567e2e2be698da24efab4637b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eaec80cbfae5e621bdd8750ee60b99d"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga5eaec80cbfae5e621bdd8750ee60b99d">MMC_clearResponse</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr class="separator:ga5eaec80cbfae5e621bdd8750ee60b99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd956aaeb7d25d93c8612a0d4e522f3"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga7cd956aaeb7d25d93c8612a0d4e522f3">MMC_intEnable</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint16 maskValue)</td></tr>
<tr class="separator:ga7cd956aaeb7d25d93c8612a0d4e522f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ff2e72b087a62e027255664bb063dc"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga53ff2e72b087a62e027255664bb063dc">MMC_eventEnable</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#ga33f695a70a63561f62c30b8de50618c8">CSL_MMCSDEventType</a> mmcsdEvent)</td></tr>
<tr class="separator:ga53ff2e72b087a62e027255664bb063dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c8fb4a9c423667209fcda1ab640aa9"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac7c8fb4a9c423667209fcda1ab640aa9">MMC_eventDisable</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#ga33f695a70a63561f62c30b8de50618c8">CSL_MMCSDEventType</a> mmcsdEvent)</td></tr>
<tr class="separator:gac7c8fb4a9c423667209fcda1ab640aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb6e3159e8d4883b1a23f57092e5cca8"><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gafb6e3159e8d4883b1a23f57092e5cca8">MMC_drrdy</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, CSL_Status *pStatus)</td></tr>
<tr class="separator:gafb6e3159e8d4883b1a23f57092e5cca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9c8982f625755a3a91bb05776aba551"><td class="memItemLeft" align="right" valign="top">Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gaa9c8982f625755a3a91bb05776aba551">MMC_dxrdy</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, CSL_Status *pStatus)</td></tr>
<tr class="separator:gaa9c8982f625755a3a91bb05776aba551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05378697af9598064568483c00c30f9c"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga05378697af9598064568483c00c30f9c">MMC_saveStatus</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr class="separator:ga05378697af9598064568483c00c30f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ea09951c9fe728ec28d3c9b9978526"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga39ea09951c9fe728ec28d3c9b9978526">MMC_getStatus</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint32 maskValue, CSL_Status *pStatus)</td></tr>
<tr class="separator:ga39ea09951c9fe728ec28d3c9b9978526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64755486e84519aceab8f6611c76bce8"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga64755486e84519aceab8f6611c76bce8">MMC_setupNative</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_setup_native.html">CSL_MMCSetupNative</a> *pMmcInit)</td></tr>
<tr class="separator:ga64755486e84519aceab8f6611c76bce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0b0ed82c16b1c60be66dac250df513d"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gaa0b0ed82c16b1c60be66dac250df513d">MMC_config</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_config.html">CSL_MMCConfig</a> *pMmcConfig)</td></tr>
<tr class="separator:gaa0b0ed82c16b1c60be66dac250df513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5516a6aa18a9747847f658099349d429"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga5516a6aa18a9747847f658099349d429">MMC_getConfig</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_config.html">CSL_MMCConfig</a> *pMmcConfig)</td></tr>
<tr class="separator:ga5516a6aa18a9747847f658099349d429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66fa12d1e3126f4b5fbee1327381f87c"><td class="memItemLeft" align="right" valign="top">Int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga66fa12d1e3126f4b5fbee1327381f87c">MMC_sendCmd</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint32 cmd, Uint32 arg, Uint16 eventFlags)</td></tr>
<tr class="separator:ga66fa12d1e3126f4b5fbee1327381f87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7819c9f81a2db4e17d5001e6bab9774f"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga7819c9f81a2db4e17d5001e6bab9774f">MMC_sendGoIdle</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr class="separator:ga7819c9f81a2db4e17d5001e6bab9774f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab31b48d48ffc562e53f94c81c1ad6613"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gab31b48d48ffc562e53f94c81c1ad6613">MMC_stop</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr class="separator:gab31b48d48ffc562e53f94c81c1ad6613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad863c45cd0ae47cb96b5a235c4159195"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gad863c45cd0ae47cb96b5a235c4159195">MMC_deselectCard</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *pMmcCardObj)</td></tr>
<tr class="separator:gad863c45cd0ae47cb96b5a235c4159195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7407c0ddc8d6740109c528e0848d05"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *pMmcCardObj)</td></tr>
<tr class="separator:ga2b7407c0ddc8d6740109c528e0848d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga930824e2cdbfd96d66730756219e912f"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint16 clkDivValue)</td></tr>
<tr class="separator:ga930824e2cdbfd96d66730756219e912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126887ca3952a6130e4957846c26ac68"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga126887ca3952a6130e4957846c26ac68">MMC_setRca</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *pMmcCardObj, Uint16 rCardAddr)</td></tr>
<tr class="separator:ga126887ca3952a6130e4957846c26ac68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422c250e5c38131c42df668587162eb7"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga422c250e5c38131c42df668587162eb7">SD_sendRca</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *pSdCardObj, Uint16 *pRCardAddr)</td></tr>
<tr class="separator:ga422c250e5c38131c42df668587162eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b1a903e9a756253ff1cc15130f08eb3"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga4b1a903e9a756253ff1cc15130f08eb3">MMC_sendAllCID</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_card_id_obj.html">CSL_MMCCardIdObj</a> *pMmcCardIdObj)</td></tr>
<tr class="separator:ga4b1a903e9a756253ff1cc15130f08eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe121b613eb075a564f8f827d1b22fa"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gaffe121b613eb075a564f8f827d1b22fa">SD_sendAllCID</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_card_id_obj.html">CSL_MMCCardIdObj</a> *pSdCardIdObj)</td></tr>
<tr class="separator:gaffe121b613eb075a564f8f827d1b22fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ab342afd3a8406390cab83fbcd2a720"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga0ab342afd3a8406390cab83fbcd2a720">MMC_getCardCsd</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_card_csd_obj.html">CSL_MMCCardCsdObj</a> *pMmcCardCsdObj)</td></tr>
<tr class="separator:ga0ab342afd3a8406390cab83fbcd2a720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a7183e22e839d1f57f6d143ce78c3a4"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga3a7183e22e839d1f57f6d143ce78c3a4">SD_getCardCsd</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_card_csd_obj.html">CSL_MMCCardCsdObj</a> *pSdCardCsdObj)</td></tr>
<tr class="separator:ga3a7183e22e839d1f57f6d143ce78c3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0130ec2b49dbd60cedc5bdb4b4a0d48"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gad0130ec2b49dbd60cedc5bdb4b4a0d48">MMC_read</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint32 cardAddr, Uint16 noOfBytes, Uint16 *pReadBuffer)</td></tr>
<tr class="separator:gad0130ec2b49dbd60cedc5bdb4b4a0d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f52bd655086f5a0d406d431c020f0a4"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga7f52bd655086f5a0d406d431c020f0a4">MMC_write</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint32 cardAddr, Uint16 noOfBytes, Uint16 *pWriteBuffer)</td></tr>
<tr class="separator:ga7f52bd655086f5a0d406d431c020f0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cabd2c2de7225dd78daa2387bf8aed4"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga9cabd2c2de7225dd78daa2387bf8aed4">MMC_setDmaHandle</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="group___c_s_l___d_m_a___d_a_t_a_s_t_r_u_c_t.html#ga70d6f2cebee9dafd348ccd554efaeda3">CSL_DMA_Handle</a> hDmaWrite, <a class="el" href="group___c_s_l___d_m_a___d_a_t_a_s_t_r_u_c_t.html#ga70d6f2cebee9dafd348ccd554efaeda3">CSL_DMA_Handle</a> hDmaRead)</td></tr>
<tr class="separator:ga9cabd2c2de7225dd78daa2387bf8aed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d12f302957fef49d39a7ec849ca0da"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gaf3d12f302957fef49d39a7ec849ca0da">MMC_setDataTransferCallback</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga20e1f9dc20404f494d4bb9a5bc59f901">CSL_MMCDataTxferCallBackPtr</a> dataTransferCallback)</td></tr>
<tr class="separator:gaf3d12f302957fef49d39a7ec849ca0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga352c10b5cb98c67b2edcaca9a527d496"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga352c10b5cb98c67b2edcaca9a527d496">MMC_setDmaChanConfig</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___mmcsd_dma_config.html">CSL_MmcsdDmaConfig</a> dmaConfig)</td></tr>
<tr class="separator:ga352c10b5cb98c67b2edcaca9a527d496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3be5dcff1884f09477361fe4fd9f57e8"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga3be5dcff1884f09477361fe4fd9f57e8">MMC_setEndianMode</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#gad374520910fa2c1324dc36d2ae22fa7d">CSL_MmcsdEndianMode</a> writeEndianMode, <a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#gad374520910fa2c1324dc36d2ae22fa7d">CSL_MmcsdEndianMode</a> readEndianMode)</td></tr>
<tr class="separator:ga3be5dcff1884f09477361fe4fd9f57e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga092ceb666b92ba2d19946c827a6b35de"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga092ceb666b92ba2d19946c827a6b35de">MMC_setBlockLength</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint32 blockLen)</td></tr>
<tr class="separator:ga092ceb666b92ba2d19946c827a6b35de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8911fdaf15d677af8c31463963c222a4"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga8911fdaf15d677af8c31463963c222a4">MMC_setWriteBlkEraseCnt</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint32 blkCnt)</td></tr>
<tr class="separator:ga8911fdaf15d677af8c31463963c222a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5311523eff70c1d40ff9e3947c57fab"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac5311523eff70c1d40ff9e3947c57fab">SD_setBusWidth</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint8 busWidth)</td></tr>
<tr class="separator:gac5311523eff70c1d40ff9e3947c57fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22902645c02da20730be0121cc9f623f"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga22902645c02da20730be0121cc9f623f">MMC_getCardStatus</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint32 *pCardStatus)</td></tr>
<tr class="separator:ga22902645c02da20730be0121cc9f623f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff5ef92220929877229fddea116db6d"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gadff5ef92220929877229fddea116db6d">SD_configurePullup</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Bool pullupCfg)</td></tr>
<tr class="separator:gadff5ef92220929877229fddea116db6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf88c714a64d95d1472a56529921915c"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gacf88c714a64d95d1472a56529921915c">MMC_enableBootPartitionAccess</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint8 partition)</td></tr>
<tr class="memdesc:gacf88c714a64d95d1472a56529921915c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the access for the boot partition of eMMC card.  <a href="#gacf88c714a64d95d1472a56529921915c">More...</a><br /></td></tr>
<tr class="separator:gacf88c714a64d95d1472a56529921915c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga646580661159e4edf15075b655ed6cea"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga646580661159e4edf15075b655ed6cea">MMC_disableBootPartitionAccess</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr class="memdesc:ga646580661159e4edf15075b655ed6cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the access for the boot partition of eMMC card.  <a href="#ga646580661159e4edf15075b655ed6cea">More...</a><br /></td></tr>
<tr class="separator:ga646580661159e4edf15075b655ed6cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa49525f3ea1088362501d3078464f947"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gaa49525f3ea1088362501d3078464f947">MMC_bootPartitionEnable</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint8 partition, Bool bootAck)</td></tr>
<tr class="memdesc:gaa49525f3ea1088362501d3078464f947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the boot parition of the eMMC card for boot mode.  <a href="#gaa49525f3ea1088362501d3078464f947">More...</a><br /></td></tr>
<tr class="separator:gaa49525f3ea1088362501d3078464f947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7cf523965bd55c72f749c1c13726568"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gaf7cf523965bd55c72f749c1c13726568">MMC_bootPartitionDisable</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr class="memdesc:gaf7cf523965bd55c72f749c1c13726568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the boot parition of the eMMC card for boot mode.  <a href="#gaf7cf523965bd55c72f749c1c13726568">More...</a><br /></td></tr>
<tr class="separator:gaf7cf523965bd55c72f749c1c13726568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae274ce72051283a596749b055ea5cd2d"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gae274ce72051283a596749b055ea5cd2d">MMC_sendSwitchCmd</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Uint32 argument)</td></tr>
<tr class="memdesc:gae274ce72051283a596749b055ea5cd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends switch commmand to eMMC card.  <a href="#gae274ce72051283a596749b055ea5cd2d">More...</a><br /></td></tr>
<tr class="separator:gae274ce72051283a596749b055ea5cd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce71027860acfef848f48334d9be540"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga6ce71027860acfef848f48334d9be540">MMC_enableBootMode</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr class="memdesc:ga6ce71027860acfef848f48334d9be540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Boot mode for eMMC card.  <a href="#ga6ce71027860acfef848f48334d9be540">More...</a><br /></td></tr>
<tr class="separator:ga6ce71027860acfef848f48334d9be540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e467e16fbdb3ab95336e1a628cdaea"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga66e467e16fbdb3ab95336e1a628cdaea">MMC_getBootPartitionSize</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr class="memdesc:ga66e467e16fbdb3ab95336e1a628cdaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Boot size of the eMMC card.  <a href="#ga66e467e16fbdb3ab95336e1a628cdaea">More...</a><br /></td></tr>
<tr class="separator:ga66e467e16fbdb3ab95336e1a628cdaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1658e5a530ffce50f24ebd0c2a70cb60"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga1658e5a530ffce50f24ebd0c2a70cb60">MMC_setBootBusWidth</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#ga6dd64c9f21aa32b820c9b626c1792191">CSL_MmcsdBootBusWidth</a> bootBusWidth, Bool resetBusWidth)</td></tr>
<tr class="memdesc:ga1658e5a530ffce50f24ebd0c2a70cb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the boot bus width.  <a href="#ga1658e5a530ffce50f24ebd0c2a70cb60">More...</a><br /></td></tr>
<tr class="separator:ga1658e5a530ffce50f24ebd0c2a70cb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44689a2b2eddefa622a8bbe1002b7b60"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga44689a2b2eddefa622a8bbe1002b7b60">MMC_getCardExtCsd</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___m_m_c_card_ext_csd_obj.html">CSL_MMCCardExtCsdObj</a> *pMmcsdCardExtCSD)</td></tr>
<tr class="separator:ga44689a2b2eddefa622a8bbe1002b7b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770b1ccb0e958bf9ce380bd3e8f71ed7"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga770b1ccb0e958bf9ce380bd3e8f71ed7">sendCmd</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, <a class="el" href="struct_c_s_l___mmcsd_cmd.html">CSL_MmcsdCmd</a> *cmd, Uint32 argument)</td></tr>
<tr class="memdesc:ga770b1ccb0e958bf9ce380bd3e8f71ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends command.  <a href="#ga770b1ccb0e958bf9ce380bd3e8f71ed7">More...</a><br /></td></tr>
<tr class="separator:ga770b1ccb0e958bf9ce380bd3e8f71ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada1f8f1c1fa95145770944ec6bb58307"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gada1f8f1c1fa95145770944ec6bb58307">MMC_setEMMCBusWidth</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd, Bool busWidth)</td></tr>
<tr class="memdesc:gada1f8f1c1fa95145770944ec6bb58307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bus width.  <a href="#gada1f8f1c1fa95145770944ec6bb58307">More...</a><br /></td></tr>
<tr class="separator:gada1f8f1c1fa95145770944ec6bb58307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf546ca16367d88a3272acded29ac531d"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gaf546ca16367d88a3272acded29ac531d">MMC_initCtrl</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr class="memdesc:gaf546ca16367d88a3272acded29ac531d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize MMC controller.  <a href="#gaf546ca16367d88a3272acded29ac531d">More...</a><br /></td></tr>
<tr class="separator:gaf546ca16367d88a3272acded29ac531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fcc64e97de81a7fa6d15e335580f47f"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga3fcc64e97de81a7fa6d15e335580f47f">MMC_configFifo</a> (<a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> hMmcsd)</td></tr>
<tr class="memdesc:ga3fcc64e97de81a7fa6d15e335580f47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the MMC/SD Fifo.  <a href="#ga3fcc64e97de81a7fa6d15e335580f47f">More...</a><br /></td></tr>
<tr class="separator:ga3fcc64e97de81a7fa6d15e335580f47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a124fb564fdc4f89e38cd751dbac170"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga4a124fb564fdc4f89e38cd751dbac170">MMC_initState</a> (<a class="el" href="struct_ata_state_struct.html">AtaState</a> *pDrive)</td></tr>
<tr class="separator:ga4a124fb564fdc4f89e38cd751dbac170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82778fe9313e874740bcd78a3f070cf8"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga82778fe9313e874740bcd78a3f070cf8">MMC_issueReadCommand</a> (AtaSector phySector, void *pAtaMediaState, AtaUint16 sectorCount)</td></tr>
<tr class="separator:ga82778fe9313e874740bcd78a3f070cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac33a4b6e29921e909ba63fbf23aaca6e"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac33a4b6e29921e909ba63fbf23aaca6e">MMC_readNextWord</a> (void *pAtaMediaState, AtaUint16 *pWord)</td></tr>
<tr class="separator:gac33a4b6e29921e909ba63fbf23aaca6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ccf47efae5b6671edfb4e50715e128b"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga8ccf47efae5b6671edfb4e50715e128b">MMC_readNextWord1</a> (void *pAtaMediaState, AtaUint16 *pWord, AtaUint16 word_delta)</td></tr>
<tr class="separator:ga8ccf47efae5b6671edfb4e50715e128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42474102f50665ea6e3e0b909e0b6957"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga42474102f50665ea6e3e0b909e0b6957">MMC_readNextNWords</a> (void *pAtaMediaState, AtaUint16 *pData, AtaUint16 words)</td></tr>
<tr class="separator:ga42474102f50665ea6e3e0b909e0b6957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad904a36b62dff38809b18706f2b217a8"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gad904a36b62dff38809b18706f2b217a8">MMC_writeSector</a> (AtaSector phySector, void *pAtaMediaState, AtaUint16 *pWord, int byteSwap)</td></tr>
<tr class="separator:gad904a36b62dff38809b18706f2b217a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ba79b3047d32681fd2f3e507df2792"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga52ba79b3047d32681fd2f3e507df2792">MMC_readNSectors</a> (void *pAtaMediaState, AtaUint16 *pReadBuf, AtaSector startSector, AtaUint16 sectorCount)</td></tr>
<tr class="separator:ga52ba79b3047d32681fd2f3e507df2792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ce2cec113d65fdb5a88bdd6f462e330"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga1ce2cec113d65fdb5a88bdd6f462e330">MMC_writeNSectors</a> (void *pAtaMediaState, AtaUint16 *pWriteBuf, AtaSector startSector, AtaUint16 sectorCount)</td></tr>
<tr class="separator:ga1ce2cec113d65fdb5a88bdd6f462e330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b287854bf37514bd37abbfc5eb6d278"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga3b287854bf37514bd37abbfc5eb6d278">MMC_read_CID</a> (void *pAtaMediaState, unsigned int *pBuf)</td></tr>
<tr class="separator:ga3b287854bf37514bd37abbfc5eb6d278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad815e54ad246ae449a41e7b4c7e7665b"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gad815e54ad246ae449a41e7b4c7e7665b">MMC_read_CSD</a> (void *pAtaMediaState, unsigned int *pBuf)</td></tr>
<tr class="separator:gad815e54ad246ae449a41e7b4c7e7665b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387ce86f026b4c9a65f057bd0d4bf0dc"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga387ce86f026b4c9a65f057bd0d4bf0dc">MMC_writeSectorFlush</a> (void *pAtaMediaState)</td></tr>
<tr class="separator:ga387ce86f026b4c9a65f057bd0d4bf0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002536f323acd8cdcecad9173bb2663a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga002536f323acd8cdcecad9173bb2663a">MMC_commandReadyStatusCheck</a> (void *pAtaMediaState)</td></tr>
<tr class="separator:ga002536f323acd8cdcecad9173bb2663a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12d09d9b9660efa91fe5c7f7ed1352c"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gad12d09d9b9660efa91fe5c7f7ed1352c">MMC_dataReadyStatusCheck</a> (void *pAtaMediaState)</td></tr>
<tr class="separator:gad12d09d9b9660efa91fe5c7f7ed1352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf98518d61cbf3f71d490016ca130f890"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gaf98518d61cbf3f71d490016ca130f890">MMC_busyStatusCheck</a> (void *pAtaMediaState)</td></tr>
<tr class="separator:gaf98518d61cbf3f71d490016ca130f890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf582af3048a97a1354accc831339d7a2"><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gaf582af3048a97a1354accc831339d7a2">MMC_getSerialID</a> (void *pAtaMediaState, AtaSerialID *pSerID)</td></tr>
<tr class="separator:gaf582af3048a97a1354accc831339d7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26f99b002a33a81075edf1fd77ee6aa4"><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga26f99b002a33a81075edf1fd77ee6aa4">MMC_file_system_format</a> (void *pAtaMediaState)</td></tr>
<tr class="separator:ga26f99b002a33a81075edf1fd77ee6aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd44c2a140fd9eb1c97e623515b256aa"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gafd44c2a140fd9eb1c97e623515b256aa">MMC_reset</a> (void *pAtaMediaState)</td></tr>
<tr class="separator:gafd44c2a140fd9eb1c97e623515b256aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c89af9f936bf0bd0ca53585406e4a7b"><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga2c89af9f936bf0bd0ca53585406e4a7b">MMC_get_time</a> (void)</td></tr>
<tr class="separator:ga2c89af9f936bf0bd0ca53585406e4a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae05d86cbca3a1aaacc03fda968bfc15d"><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gae05d86cbca3a1aaacc03fda968bfc15d">MMC_get_mod_time</a> (void)</td></tr>
<tr class="separator:gae05d86cbca3a1aaacc03fda968bfc15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga925e89ab4b717172b1a2ef7dbdf40b2b"><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga925e89ab4b717172b1a2ef7dbdf40b2b">MMC_get_date</a> (void)</td></tr>
<tr class="separator:ga925e89ab4b717172b1a2ef7dbdf40b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a34021ba2878cb90c65d894a6c9d5c"><td class="memItemLeft" align="right" valign="top">AtaUint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gab0a34021ba2878cb90c65d894a6c9d5c">MMC_get_mod_date</a> (void)</td></tr>
<tr class="separator:gab0a34021ba2878cb90c65d894a6c9d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0cb92aff7fccadf76863408e31fd91"><td class="memItemLeft" align="right" valign="top">AtaError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga1a0cb92aff7fccadf76863408e31fd91">MMC_flushFat</a> (void *pAtaMediaState)</td></tr>
<tr class="separator:ga1a0cb92aff7fccadf76863408e31fd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf7cf523965bd55c72f749c1c13726568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_bootPartitionDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the boot parition of the eMMC card for boot mode. </p>
<p>This API disables the boot mode for the boot area partition</p>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gaa49525f3ea1088362501d3078464f947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_bootPartitionEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>bootAck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the boot parition of the eMMC card for boot mode. </p>
<p>This API configures the boot partition from which boot data is read during boot operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">partition</td><td>[IN] Partition number for which boot enable is required 1 - Enable the boot for partition 1 2 - Enable the boot for partition 2 </td></tr>
    <tr><td class="paramname">bootAck</td><td>[IN] Request for acknowledgement during boot mode 0 - Card will not send acknowldgement pattern during boot 1 - Card sends acknowldgement pattern during boot</td></tr>
  </table>
  </dd>
</dl>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gaf98518d61cbf3f71d490016ca130f890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_busyStatusCheck </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_busyStatusCheck</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;

        pAtaState = &amp;ataState;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = pAtaState-&gt;AtaBusyStatusCheck(ataState-&gt;pAtaMediaState);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5eaec80cbfae5e621bdd8750ee60b99d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_clearResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_clearResponse</b> </p>
<p><b>Description</b> <br />
 This function clears all eight response registers of MMCSD.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd    Handle to the MMCSD</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully before this.</p>
<p><b> Post Condition </b> <br />
 Clears response</p>
<p><b>Modifies</b> <br />
 MMCSD Response Registers.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_clearResponse(hMmcsd);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3d40be0282818757b7e0db8a16ee828f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_close</b> </p>
<p><b>Description</b> <br />
 This function closes the specified handle to MMCSD.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd    Handle to the MMCSD</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully before this.</p>
<p><b> Post Condition </b> <br />
 Closes the MMC handle</p>
<p><b>Modifies</b> <br />
 MMCSD handle will be assigned to NULL.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_close(hMmcsd);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga002536f323acd8cdcecad9173bb2663a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MMC_commandReadyStatusCheck </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_commandReadyStatusCheck</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        int            status;

        pAtaState = &amp;ataState;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        status = pAtaState-&gt;AtaCommandReadyStatusCheck(ataState-&gt;pAtaMediaState);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa0b0ed82c16b1c60be66dac250df513d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_config.html">CSL_MMCConfig</a> *&#160;</td>
          <td class="paramname"><em>pMmcConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_config</b> </p>
<p><b>Description</b> <br />
 Function to configure the MMCSD registers. Register configuration will be done as per the configuration parameters passed to the function.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd        Handle to the MMCSD.
        pMmcConfig    Pointer to the MMCSD config parameter.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 MMCSD Register will be populated.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle       hMmcsd;
        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdInstId       instId;
        CSL_status            status;
        CSL_MMCConfig         mmcConfig;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        Note: CSL_MMCConfig field are following.
        mmcConfig.mmcblen = CSL_MMCSD_BLOCK_LENGTH;
        mmcConfig.mmcclk  = 0x10 |CSL_MMCSD_MMCCLK_CLKEN_ENABLE;
        mmcConfig.mmcctl  = CSL_MMCSD_MMCCTL_DATEG_F_EDGE;
        mmcConfig.mmcim   = 0x0;
        mmcConfig.mmcnblk = 0x1;
        mmcConfig.mmctod  = CSL_MMCSD_DATA_RW_TIMEOUT;
        mmcConfig.mmctor  = CSL_MMCSD_RESPONSE_TIMEOUT;

        status = MMC_config(hMmcsd, &amp;mmcConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3fcc64e97de81a7fa6d15e335580f47f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_configFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the MMC/SD Fifo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gad12d09d9b9660efa91fe5c7f7ed1352c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_dataReadyStatusCheck </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_dataReadyStatusCheck</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;

        pAtaState = &amp;ataState;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = pAtaState-&gt;AtaDataReadyStatusCheck(ataState-&gt;pAtaMediaState);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad863c45cd0ae47cb96b5a235c4159195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_deselectCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_deselectCard</b> </p>
<p><b>Description</b> <br />
 This function will send command for deselecting particular card which is assigned in card object.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd            Handle to the MMCSD.
        pMmcCardObj       Pointer to the MMCSD Card Info.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this. <br />
 RCA value should be properly stored in handle hMmcsd.</p>
<p><b> Post Condition </b> <br />
 Deselects the card</p>
<p><b>Modifies</b> <br />
 MMCSD card object structure.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle         hMmcsd;
        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MMCCardObj          mmcCardObj;
        CSL_MmcsdInstId         instId;
        CSL_status              status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_deselectCard(hMmcsd, &amp;mmcCardObj);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga646580661159e4edf15075b655ed6cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_disableBootPartitionAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the access for the boot partition of eMMC card. </p>
<p>After sucessful execution of this API, access to eMMC boot partition is not allowed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gafb6e3159e8d4883b1a23f57092e5cca8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool MMC_drrdy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_drrdy</b> </p>
<p><b>Description</b> <br />
 This function returns data receive ready status. Value returned by this API is useful to decide whether data is available in MMC/SD controller FIFO for reading or not.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd     Handle to the MMCSD
        pStatus    Status of API success or failed.</pre><p><b> Return Value </b> Bool </p><ul>
<li>TRUE - Data is available for reading </li>
<li>FALSE - Data is not available for reading</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        CSL_status            status;
        Bool                  drrdyStatus;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        drrdyStatus = MMC_drrdy(hMmcsd, &amp;status);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa9c8982f625755a3a91bb05776aba551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool MMC_dxrdy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_dxrdy</b> </p>
<p><b>Description</b> <br />
 This function returns data transmit ready status. Value returned by this API is useful to decide whether data can be written to MMCSD controller FIFO or not.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd     Handle to the MMCSD
        pStatus    Status of API success or failed</pre><p><b> Return Value </b> Bool </p><ul>
<li>TRUE - MMCSD FIFO is ready to accept data </li>
<li>FALSE - MMCSD FIFO is not ready to accept data</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        CSL_status            status;
        Bool                  dxrdyStatus;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        dxrdyStatus = MMC_dxrdy(hMmcsd, &amp;status);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6ce71027860acfef848f48334d9be540"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_enableBootMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the Boot mode for eMMC card. </p>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gacf88c714a64d95d1472a56529921915c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_enableBootPartitionAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the access for the boot partition of eMMC card. </p>
<p>After sucessful execution of this API, it is possible to write/read boot partition of the eMMC card with normal MMC commands</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">partition</td><td>[IN] Partition number for which boot access needs to be enabled 1 - Enable the access for boot partition 1 2 - Enable the access for boot partition 2</td></tr>
  </table>
  </dd>
</dl>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gac7c8fb4a9c423667209fcda1ab640aa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_eventDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#ga33f695a70a63561f62c30b8de50618c8">CSL_MMCSDEventType</a>&#160;</td>
          <td class="paramname"><em>mmcsdEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_eventDisable</b> </p>
<p><b>Description</b> <br />
 This function disables the MMC events depending on the 'mmcsdEvent' passed as a parameter. This function is useful to disable single interrupt of MMC interrupt mask register in one function call.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd        Handle to the MMCSD
        mmcsdEvent    Event type.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 <b>Modifies</b> <br />
 Interrupt will be disabled for particular event.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        CSL_MMCSDEventType    mmcsdEvent;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);
        mmcsdEvent = CSL_MMCSD_EDATDNE_INTERRUPT;

        status = MMC_eventDisable(hMmcsd, mmcsdEvent);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga53ff2e72b087a62e027255664bb063dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_eventEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#ga33f695a70a63561f62c30b8de50618c8">CSL_MMCSDEventType</a>&#160;</td>
          <td class="paramname"><em>mmcsdEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_eventEnable</b> </p>
<p><b>Description</b> <br />
 This function enables the MMC events depending on the 'mmcsdEvent' passed as a parameter. This function is useful to enable single interrupt of MMC interrupt mask register in one function call.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd        Handle to the MMCSD
        mmcsdEvent    Event type.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. Before enabling interrupt of any type make sure the isr function is plugged in ISR.</p>
<p><b> Post Condition </b> <br />
 Interrupt will be enabled for particular event.</p>
<p><b>Modifies</b> <br />
 MMC interrupt mask register</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        CSL_MMCSDEventType    mmcsdEvent;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);
        eventType = CSL_MMCSD_EDATDNE_INTERRUPT;

        status = MMC_eventEnable(hMmcsd, mmcsdEvent);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga26f99b002a33a81075edf1fd77ee6aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_file_system_format </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_file_system_format</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaUint16      retVal;

        pAtaState = &amp;ataState;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        retVal = pAtaState-&gt;AtaFileSystemType(ataState-&gt;pAtaMediaState);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1a0cb92aff7fccadf76863408e31fd91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_flushFat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_flushFat</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;

        pAtaState = *ataState;
        pAtaState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = pAtaState-&gt;AtaFlushFat(pAtaState-&gt;pAtaMediaState);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga925e89ab4b717172b1a2ef7dbdf40b2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_get_date </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_get_date</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        None</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaUint16      date;

        pAtaState = &amp;ataState;

        ataErr = MMC_initState(&amp;ataState);

        date   = pAtaState-&gt;get_date();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab0a34021ba2878cb90c65d894a6c9d5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_get_mod_date </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_get_mod_date</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        None</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaUint16      date;

        pAtaState = &amp;ataState;

        ataErr = MMC_initState(&amp;ataState);

        date   = pAtaState-&gt;get_mod_date();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae05d86cbca3a1aaacc03fda968bfc15d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_get_mod_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_get_mod_time</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        None</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaUint16      time;

        pAtaState = &amp;ataState;

        ataErr = MMC_initState(&amp;ataState);

        time   = pAtaState-&gt;get_mod_time();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2c89af9f936bf0bd0ca53585406e4a7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_get_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_get_time</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        None</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaUint16      time;

        pAtaState = &amp;ataState;

        ataErr = MMC_initState(&amp;ataState);

        time   = pAtaState-&gt;get_time();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga66e467e16fbdb3ab95336e1a628cdaea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 MMC_getBootPartitionSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Boot size of the eMMC card. </p>
<p>This API decodes the csd and gets the Boot size of the card</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Uint32 - Size of boot partition </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ab342afd3a8406390cab83fbcd2a720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_getCardCsd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_card_csd_obj.html">CSL_MMCCardCsdObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardCsdObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_getCardCsd</b> </p>
<p><b>Description</b> <br />
 This function will update the CSD Structure information of MMC Card.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd            Handle to the MMCSD.
        pMmcCardCsdObj    Pointer to the MMC Card CSD Info.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 1. <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br />
 2. <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br />
 3. if Card detected is MMC then <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a>for specific to MMC.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 CSD object structure</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle         hMmcsd;
        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MMCCardObj          mmcCardObj;
        CSL_MMCCardCsdObj       mmcCardCsdObj;
        CSL_MmcsdInstId         instId;
        CSL_status              status;
        Uint16                  clkDivValue;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);

        clkDivValue = 0x4 //as MMC clock max is 20MHz and
                            Function clock is 100MHz
        status = MMC_sendOpCond(hMmcsd, clkDivValue);

        status = MMC_getCardCsd(hMmcsd, &amp;mmcCardCsdObj);

        For example following value will be populated.
        pMmcCardCsdObj-&gt;readBlLen         = ;
        pMmcCardCsdObj-&gt;cSize  = ;

        These value will be useful to fetch the card specific information
        as shown below. These figure are tested with 256Mbyte MMC Card

        blockLength  = 512 Bytes
        cardCapacity = 0x260636672 Bytes
        totalSectors = 0x509056 sector</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga44689a2b2eddefa622a8bbe1002b7b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_getCardExtCsd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_card_ext_csd_obj.html">CSL_MMCCardExtCsdObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcsdCardExtCSD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_getCardExtCsd</b> </p>
<p><b>Description</b> <br />
 Reads extended CSD strcuture of eMMC card</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd              Handle to the MMCSD.
        pMmcsdCardExtCSD    Pointer to the MMC Card extended CSD Info.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout</li>
</ul>
<p><b> Pre Condition </b> <br />
 1. <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br />
 2. <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br />
 3. if Card detected is MMC then <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a>for specific to MMC.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 CSD object structure</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle         hMmcsd;
        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MMCCardObj          mmcCardObj;
        CSL_MMCCardExtCsdObj    mmcCardExtCsdObj;
        CSL_MmcsdInstId         instId;
        CSL_status              status;
        Uint16                  clkDivValue;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);

        clkDivValue = 0x4 //as MMC clock max is 20MHz and
                            Function clock is 100MHz
        status = MMC_sendOpCond(hMmcsd, clkDivValue);

        status = MMC_getCardExtCsd(hMmcsd, &amp;mmcCardExtCsdObj);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga22902645c02da20730be0121cc9f623f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_getCardStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pCardStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_getCardStatus</b> </p>
<p><b>Description</b> <br />
 Function to get the status of the memory card. This function sends CMD13 to memory card to get the status. Memory card status will have the useful information to determine the card status and errors if any occurred. Refer to MMC/SD specification for the details of fields contained in the MMC/SD status.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd         MMCSD handle
        pCardStatus    Pointer to store the status sent by the card</pre><p><b> Return Value </b> </p><ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br />
 Gets card status</p>
<p><b>Modifies</b> <br />
 Card status pointer</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MmcsdHandle         hMmcsd;
        CSL_MmcsdInstId         instId;
        CSL_status              status;
        Uint32                  cardStatus;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                          &amp;status);

        status = MMC_getCardStatus(hMmcsd, &amp;cardStatus);
</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5516a6aa18a9747847f658099349d429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_getConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_config.html">CSL_MMCConfig</a> *&#160;</td>
          <td class="paramname"><em>pMmcConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_getConfig</b> </p>
<p><b>Description</b> <br />
 This function will fetch the information present in the MMCSD registers and update to passed the config parameter.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd        Handle to the MMCSD.
        pMmcConfig    Pointer to the MMCSD config Parameter.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle       hMmcsd;
        CSL_MMCControllerObj  pMmcsdContObj;
        CSL_MmcsdInstId       instId;
        CSL_status            status;
        CSL_MMCConfig         pMmcConfig)

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_getConfig(hMmcsd, &amp;pMmcConfig);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga01b5cd5567e2e2be698da24efab4637b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_getNumberOfCards </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pActiveNoCard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_getNumberOfCards</b> </p>
<p><b>Description</b> <br />
 Get the number of cards information from the MMC handler.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd           Handle to the MMCSD
        pActiveNoCard    pointer to store number of active card info.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        Uint16                activeNoCard;
        CSL_MmcsdInstId       instId;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;
        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_getNumberOfCards(hMmcsd, &amp;activeNoCard);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf582af3048a97a1354accc831339d7a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaUint16 MMC_getSerialID </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaSerialID *&#160;</td>
          <td class="paramname"><em>pSerID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_getSerialID</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure
        pID               Pointer to store the serial Id</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaSerialID    serId;

        pAtaState= &amp;ataState;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        retVal = pAtaState-&gt;AtaGetSerialID(ataState-&gt;pAtaMediaState,
                                           &amp;serId);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga39ea09951c9fe728ec28d3c9b9978526"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 MMC_getStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>maskValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_getStatus</b> </p>
<p><b>Description</b> <br />
 This function return the status of particular field of MMCST0 and MMCST1 register according to the passed mask value. Value of MMCST1 will be stored in upper 16 bits and value of MMCST0 will be stored in lower 16 bits of the returned value.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd       Handle to the MMCSD
        maskValue    Mask value to specify the field.
        pStatus      Status of API success or failed.</pre><p><b> Return Value </b> Uint32 </p><ul>
<li>status - MMCST0 and MMCST1 register value.</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        Uint16                maskValue;
        CSL_status            status;
        Uint32                mmcStatus;
        Uint32                maskValue;

        instId = CSL_MMCSD0_INST;
        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        // Get the value of mmcst0 register
        maskValue = 0x0000FFFF;

        mmcStatus = MMC_getStatus(hMmcsd, maskValue, &amp;status);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaf5230667e9cde16496d716c5b5fd14f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_init</b> </p>
<p><b>Description</b> <br />
 This is the initialization function for the MMCSD CSL. The function must be called before calling any other API from MMCSD CSL. This function is for enabling the clock to the MMCSD Controller and routing MMCSD pins to the external serial port. This function should be called only once during system initialization time. This function gates the clock for the two MMCSD modules. Application programs may disable the clocks for MMCSD module which is not in use.</p>
<p><b>Arguments</b> </p><pre class="fragment"> </pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - MMCSD initialization successfully</li>
</ul>
<p><b> Pre Condition </b> <br />
 This should be call first before calling any other MMCSD Function.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_status       status;

        status = MMC_init();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf546ca16367d88a3272acded29ac531d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_initCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize MMC controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a124fb564fdc4f89e38cd751dbac170"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_initState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ata_state_struct.html">AtaState</a> *&#160;</td>
          <td class="paramname"><em>pDrive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_initState</b> </p>
<p><b>Description</b> <br />
 This function initializes ATA state structure. Initializes all function pointers in the ATA state structure with appropriate function address. This function should be called by the application programs before transferring the control over the media to ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pDrive    ATA state structure pointer</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Initializes ATA state structure</p>
<p><b>Modifies</b> <br />
 ATA state structure</p>
<p><b>Example</b> </p><pre class="fragment">        AtaState       ataState;
        AtaError       ataErr;

        ataErr = MMC_initState(&amp;ataState);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7cd956aaeb7d25d93c8612a0d4e522f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_intEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>maskValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_intEnable</b> </p>
<p><b>Description</b> <br />
 This function will enable or disable interrupts for MMCSD depending on the passed mask value for interrupt. MMC interrupt mask register will be configured by this API. This function is useful to enable the multiple MMC interrupts in one function call.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd       Handle to the MMCSD
        maskValue    mask value to specify the interrupt state.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully before this. Before enabling interrupt of any type make sure the isr function is plugged in ISR.</p>
<p><b> Post Condition </b> <br />
 Enables MMC interrupts</p>
<p><b>Modifies</b> <br />
 MMC interrupt mask register</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        Uint16                maskValue;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);
        NOTE: Use the bit mask values of MMCIM register defined
              cslr_mmcsd.h file for making the mask value.

        maskValue = CSL_MMCSD_MMCIM_ETRNDNE_MASK |
                    CSL_MMCSD_MMCIM_EDATED_MASK;

        status = MMC_intEnable(hMmcsd, maskValue);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga82778fe9313e874740bcd78a3f070cf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_issueReadCommand </td>
          <td>(</td>
          <td class="paramtype">AtaSector&#160;</td>
          <td class="paramname"><em>phySector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16&#160;</td>
          <td class="paramname"><em>sectorCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_issueReadCommand</b> </p>
<p><b>Description</b> <br />
 This function is used to fetch all normal data from the media. A sector is always assumed to be 256 16-bit words by the high-level API</p>
<p>Programs calling this function should assign proper value to ATA_No_Swap in case of using that varaible.</p>
<p><b>Arguments</b> </p><pre class="fragment">        phySector         Sector number from which data needs to be read
        pAtaMediaState    ATA media state structure
        sectorCount       Number of sectors to read</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 Reads Data from MMC/SD card</p>
<p><b>Modifies</b> <br />
 Global Read buffer</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaSector      phySector;
        AtaUint16      sectCnt;

        pAtaState = &amp;ataState;

        phySector = 0;
        sectCnt   = 16;
        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = pAtaState-&gt;AtaIssueReadCommand(phySector,
                                                ataState-&gt;pAtaMediaState,
                                                sectCnt);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac69a19e39587bc4bc74144287050c64b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a> MMC_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_controller_obj.html">CSL_MMCControllerObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcsdContObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#gae4058f773c9cc4adc86d490cac7267b3">CSL_MmcsdInstId</a>&#160;</td>
          <td class="paramname"><em>instId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#gae6360eb80b01a15bae49ca23e73b5743">CSL_MMCSDOpMode</a>&#160;</td>
          <td class="paramname"><em>opMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_open</b> </p>
<p><b>Description</b> <br />
 This function opens the CSL MMCSD module and returns handle to the MMCSD object structure. Parameter 'opMode' is provided to select the operating mode of the MMCSD module. Opmode information is stored in the MMCSD handle and is used in data transfer APIs.</p>
<p>NOTE: THIS API SETS THE ENDIAN MODE OF MMCSD READ AND WRITE OPERATIONS TO LITTLE ENDIAN. USE <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga3be5dcff1884f09477361fe4fd9f57e8">MMC_setEndianMode()</a> TO CHANGE ENDIAN MODE.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pMmcsdContObj    MMCSD Controller object structure
        instId           Instance number for MMCSD
        opMode           Operating mode of the MMCSD module
        status           Status of the function call</pre><p><b> Return Value </b> CSL_MmmcsdHandle <br />
 Valid MMCSD handle will be returned if status value is equal to CSL_SOK.</p>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gaaf5230667e9cde16496d716c5b5fd14f">MMC_init()</a> API should be called before <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a>.</p>
<p><b> Post Condition </b> <br />
 1. The status is returned in the status variable. If status returned is </p><ul>
<li>CSL_SOK - Valid MMCSD handle is returned </li>
<li>CSL_ESYS_INVPARAMS - resource is already in use <br />
 2. CSL_MmmcsdObj object structure is populated</li>
</ul>
<p><b>Modifies</b> <br />
 1. The status variable <br />
 2. CSL_MmmcsdObj object structure</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  pMmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;
        status =  MMC_init();
        hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);
        ...
</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad0130ec2b49dbd60cedc5bdb4b4a0d48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>cardAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>noOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pReadBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_read</b> </p>
<p><b>Description</b> <br />
 This function reads data from the memory card at a given address and populates the data to read buffer.</p>
<p>'cardAddr' represents the address location in the card to be accessed. For the standard capacity cards this parameter will be a value in multiples of 512. That means to read a sector number 1 cardAddr will be 1*512, to read a sector number 2 cardAddr will be 2*512 and so on. For the high capacity cards 'cardAddr' parameter will be same as the sector number. That means to read a sector number 1 cardAddr will be 1, to read a sector number 2 cardAddr will be 2 and so on. Reason for this is high capacity cards uses BLOCK addressing instead of the BYTE addressing used by the standard capacity cards to increase the addressable memory capacity.</p>
<p>Detection of high capacity cards can be verified using the flag 'sdHcDetected' in the MMCSD card object structure. sdHcDetected = TRUE - SD card is high capacity card sdHcDetected = FALSE - SD card is standard capacity card</p>
<p>NOTE: CARE SHOULD BE TAKEN WHILE PASSING THE 'cardAddr' PARAMETER. USING BYTE ADDRESSING WITH HIGH CAPACITY CARDS WILL LEAD TO OUT OF SECTOR BOUNDARY ACCESS AND RESULTS IN CODE HANGING FOR MMCSD RESPONSE.</p>
<p>NOTE: Endian mode of the data transfer depends on the parameter 'readEndianMode' in the MMC handle. Default value for the endian mode is 'LITTLE ENDIAN' which will be set during MMC open. Endian mode can be configured using <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga3be5dcff1884f09477361fe4fd9f57e8">MMC_setEndianMode()</a>. DO NOT CHANGE THE ENDIAN MODE WITH OUT USING THIS API.</p>
<p>NOTE: When transferring data in DMA mode, word swap will be done for the data buffer when MMCSD is configured for little endian mode. No word swap is required in upper SW layers.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd         Handle to the MMCSD.
        cardAddr       Location to read from.
        noOfBytes      Number of bytes to read.
        pReadBuffer    Pointer to a buffer.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - card Response time out</li>
</ul>
<p><b> Pre Condition </b> <br />
 1. <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br />
 2. <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br />
 3. <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a>for specific to card. <br />
 4. If card detected is SD then call <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga3a7183e22e839d1f57f6d143ce78c3a4">SD_getCardCsd()</a> specific to SD. If card detected is MMC then call <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga0ab342afd3a8406390cab83fbcd2a720">MMC_getCardCsd()</a> specific to MMC</p>
<p><b> Post Condition </b> <br />
 Populates data to read buffer.</p>
<p><b>Modifies</b> <br />
 Read data buffer.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle       hMmcsd;
        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MMCCardObj        sdCardObj;
        CSL_MMCCardCsdObj     sdCardCsdObj;
        CSL_MmcsdInstId       instId;
        CSL_status            status;
        Uint16                clkDivValue;
        Uint16                noOfBytes;
        Uint16                cardAddr;
        Uint16                readBuffer[256];

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_selectCard(hMmcsd, &amp;sdCardObj);

        clkDivValue = 0x1 //as SD clock max is 50MHz and Function clock is 100MHz
        status = MMC_sendOpCond(hMmcsd, clkDivValue);

        status = SD_getCardCsd(hMmcsd, &amp;sdCardCsdObj);
        For example following value will be populated.
        sdCardCsdObj.readBlLen = ;
        sdCardCsdObj.cSize     = ;
        These values will be useful to fetch the card specific information
        like these-----
        These figure are tested with 1GB SD Card
        blockLength      = 512 Bytes
        cardCapacity     = 0x1015808000 Bytes
        totalSectors     = 0x1984000 sector

        cardAddr = 0x200;
        noOfBytes = 512;

        status = MMC_read(hMmcsd, cardAddr, noOfBytes, readBuffer);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3b287854bf37514bd37abbfc5eb6d278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_read_CID </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_read_CID</b> </p>
<p><b>Description</b> <br />
 This function is used to read the MMCSD card identification information. CID information stored in the internal MMCSD handle is copied to the given data buffer. This function stores 8 words each of length 16bit into the given buffer.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure
        pBuf              Pointer to data buffer to store CID information</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_Open and MMC_sendAllCID/SD_sendAllCID APIs should be called successfully.</p>
<p><b> Post Condition </b> <br />
 Writes CID data to given buffer</p>
<p><b>Modifies</b> <br />
 Data in pBuf</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj    pMmcsdContObj;
        CSL_MmcsdHandle         mmcsdHandle;
        CSL_MMCCardIdObj        sdCardIdObj;
        AtaMMCState             ataMediaState;
        AtaState                ataState;
        AtaError                ataErr;
        unsigned int            csdBuf[8];
        CSL_Status              status;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        //Open MMCSD module
        mmcsdHandle = MMC_open(&amp;pMmcsdContObj, CSL_MMCSD0_INST,
                               CSL_MMCSD_OPMODE_POLLED, &amp;status);
        //Configure MMCSD module
        ....
        ....
        //Read the CID information form card and store it in MMCSD handle
        status = SD_sendAllCID(mmcsdHandle, &amp;sdCardIdObj);

        //Read the CID data from the internal handle
        ataErr = MMC_read_CID(ataState-&gt;pAtaMediaState, csdBuf);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad815e54ad246ae449a41e7b4c7e7665b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_read_CSD </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_read_CSD</b> </p>
<p><b>Description</b> <br />
 This function is used to read the MMCSD card specific information. CSD information stored in the internal MMCSD handle is copied to the given data buffer. This function stores 8 words each of length 16bit into the given buffer.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure
        pBuf              Pointer to data buffer to store CSD information</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_Open and MMC_getCardCsd/SD_getCardCsd APIs should be called successfully.</p>
<p><b> Post Condition </b> <br />
 Writes CSD data to given buffer</p>
<p><b>Modifies</b> <br />
 Data in pBuf</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj    pMmcsdContObj;
        CSL_MmcsdHandle         mmcsdHandle;
        CSL_MMCCardCsdObj       sdCardCsdObj;
        AtaMMCState             ataMediaState;
        AtaState                ataState;
        AtaError                ataErr;
        unsigned int            csdBuf[8];
        CSL_Status              status;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        //Open MMCSD module
        mmcsdHandle = MMC_open(&amp;pMmcsdContObj, CSL_MMCSD0_INST,
                               CSL_MMCSD_OPMODE_POLLED, &amp;status);
        //Configure MMCSD module
        ....
        ....
        //Read the CSD information form card and store it in MMCSD handle
        status = SD_getCardCsd(mmcsdHandle, &amp;sdCardCsdObj);

        //Read the CSD data from the internal handle
        ataErr = MMC_read_CSD(ataState-&gt;pAtaMediaState, csdBuf);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga42474102f50665ea6e3e0b909e0b6957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_readNextNWords </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16&#160;</td>
          <td class="paramname"><em>words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_readNextNWords</b> </p>
<p><b>Description</b> <br />
 This function is used to read N words next to the previously read word from the media. This function calls MMC_readNextWord API N number of times to read the data words. High level APIs should be aware of this and use MMC_readNextWord and MMC_readNextNWords APIs with care.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure
        pData             Pointer to store the data words
        word              Number of words to read</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 Reads data from media</p>
<p><b>Modifies</b> <br />
 Global Read buffer</p>
<p><b>Example</b> </p><pre class="fragment">        #define CSL_MMCSD_BUF_SIZE (16u)

        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaUint16      dataBuf[CSL_MMCSD_BUF_SIZE];
        AtaUint16      words;

        pAtaState = &amp;ataState;

        words  = CSL_MMCSD_BUF_SIZE;
        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = pAtaState-&gt;AtaReadNextNWords(ataState-&gt;pAtaMediaState,
                                              dataBuf, words);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac33a4b6e29921e909ba63fbf23aaca6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_readNextWord </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pWord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_readNextWord</b> </p>
<p><b>Description</b> <br />
 This function is used to read a word next to the previously read word from the media. This function reads the words from the buffered data and send to the application. After reading 256 words from the global read buffer, this functions reads 256 words from the media and stores in the global read buffer. MMC_issueReadCommand functions should be called before calling this function for first time.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure
        pWord             Pointer to store the data word</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully. <br />
 MMC_issueReadCommand should be called when calling MMC_readNextWord function for first time</p>
<p><b> Post Condition </b> <br />
 Copies a data word into pWord</p>
<p><b>Modifies</b> <br />
 Data in pWord</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaUint16      data;
        AtaSector      phySector;
        AtaUint16      sectCnt;

        pAtaState = &amp;ataState;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = pAtaState-&gt;AtaIssueReadCommand(phySector,
                                                ataState-&gt;pAtaMediaState,
                                                sectCnt);

        ataErr = pAtaState-&gt;AtaReadNextWord(ataState-&gt;pAtaMediaState,
                                            &amp;data);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8ccf47efae5b6671edfb4e50715e128b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_readNextWord1 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16&#160;</td>
          <td class="paramname"><em>word_delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_readNextWord1</b> </p>
<p><b>Description</b> <br />
 This function is used to read a word next to the previously read word from the media. This function reads the words from the buffered data and send to the application. After readinmg 256 words from the global read buffer, this functions reads 256 words from the media and stores in the global read buffer. MMC_issueReadCommand functions should be called before calling this function for first time.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure
        pWord             Pointer to store the data word</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully. <br />
 MMC_issueReadCommand should be called when calling MMC_readNextWord function for first time</p>
<p><b> Post Condition </b> <br />
 Copies a data word into pWord</p>
<p><b>Modifies</b> <br />
 Data in pWord</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaUint16      data;
        AtaSector      phySector;
        AtaUint16      sectCnt;

        pAtaState = &amp;ataState;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = pAtaState-&gt;AtaIssueReadCommand(phySector,
                                                ataState-&gt;pAtaMediaState,
                                                sectCnt);

        ataErr = pAtaState-&gt;AtaReadNextWord(ataState-&gt;pAtaMediaState,
                                            &amp;data);</pre><hr/>
<p>=========================================================================== <br />
<b>MMC_readNextWord1</b> </p>
<p><b>Description</b> <br />
 This function is used to read a word next to the previously read word from the media. This function reads the words from the buffered data and send to the application. After readinmg 256 words from the global read buffer, this functions reads 256 words from the media and stores in the global read buffer. MMC_issueReadCommand functions should be called before calling this function for first time.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure
        pWord             Pointer to store the data word
        word_delta        word increment</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully. <br />
 MMC_issueReadCommand should be called when calling MMC_readNextWord function for first time</p>
<p><b> Post Condition </b> <br />
 Copies a data word into pWord</p>
<p><b>Modifies</b> <br />
 Data in pWord</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaUint16      data;
        AtaSector      phySector;
        AtaUint16      sectCnt;

        pAtaState = &amp;ataState;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = pAtaState-&gt;AtaIssueReadCommand(phySector,
                                                ataState-&gt;pAtaMediaState,
                                                sectCnt);

        ataErr = pAtaState-&gt;AtaReadNextWord(ataState-&gt;pAtaMediaState,
                                            &amp;data);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga52ba79b3047d32681fd2f3e507df2792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_readNSectors </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pReadBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaSector&#160;</td>
          <td class="paramname"><em>startSector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16&#160;</td>
          <td class="paramname"><em>sectorCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_readNSectors</b> </p>
<p><b>Description</b> <br />
 This function is used to read N sectors from MMC/SD card. Data buffer should be large enough to hold the data read from multiple sectors. Each sector size will be 512 bytes</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure
        pReadBuf          Pointer to store read data
        startSector       Starting sector number to read
        sectorCount       Number of sectors to read</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 Reads data from media</p>
<p><b>Modifies</b> <br />
 Read buffer</p>
<p><b>Example</b> </p><pre class="fragment">        #define CSL_MMCSD_BUF_SIZE (256u)

        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaError       ataErr;
        AtaUint16      dataBuf[CSL_MMCSD_BUF_SIZE];
        AtaUint16      words;
        Uint16         sectNum;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;
        words   = CSL_MMCSD_BUF_SIZE;
        sectNum = 0;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = MMC_readNSectors(ataState-&gt;pAtaMediaStatee, dataBuf,
                                  words, sectNum, 8);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafd44c2a140fd9eb1c97e623515b256aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_reset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_reset</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;

        pAtaState = &amp;ataState;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = pAtaState-&gt;AtaReset(ataState-&gt;pAtaMediaState);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga05378697af9598064568483c00c30f9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_saveStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_saveStatus</b> </p>
<p><b>Description</b> <br />
 This function stores the value of MMCST0 and MMCST1 registers in the card object strutcure present in the MMCSD handle.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd    Handle to the MMCSD</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br />
 Saves the value of MMCST0 and MMCST1</p>
<p><b>Modifies</b> <br />
 Card object structure</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        Uint16                maskValue;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_saveStatus(hMmcsd);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2b7407c0ddc8d6740109c528e0848d05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_selectCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_selectCard</b> </p>
<p><b>Description</b> <br />
 This function detects which card (MMC/SD/SDHC) is inserted. Information of the card detected will be populated to the card object structure passed as parameter.</p>
<p>MMC object structure passed to this function should global structure variable which persists till end of the program since it is stored by MMCSD CSL for reference in other APIs.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd            Handle to the MMCSD.
        pMmcCardObj       Pointer to the MMCSD Card Info.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle       hMmcsd;
        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MMCCardObj        mmcCardObj;
        CSL_MmcsdInstId       instId;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4b1a903e9a756253ff1cc15130f08eb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_sendAllCID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_card_id_obj.html">CSL_MMCCardIdObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardIdObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_sendAllCID</b> </p>
<p><b>Description</b> <br />
 This will fetch the Information about MMC Card Id and update into the passed id structure.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd           Handle to the MMCSD.
        pMmcCardIdObj    Pointer to the MMC Card ID Info.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 1.MMC_open() API should be called successfully. <br />
 2.MMC_selectCard() API should be called before this so that it will do some needful work for particular card detected. <br />
 3.If Card detected is MMC then <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a> for specific to MMC.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 pMmcCardIdObj will be populated.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle         hMmcsd;
        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MMCCardObj          mmcCardObj;
        CSL_MMCCardIdObj        mmcCardIdObj;
        CSL_MmcsdInstId         instId;
        CSL_status              status;
        Uint16                  clkDivValue;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);

        clkDivValue = 0x4 //As MMC clock max is 20MHz and
                            Function clock is 100MHz
        status = MMC_sendOpCond(hMmcsd, clkDivValue);

        status = MMC_sendAllCID(hMmcsd, &amp;mmcCardIdObj);
        For example following value will be populated.
        pMmcCardIdObj-&gt;mfgId         = ;
        pMmcCardIdObj-&gt;serialNumber  = ;
        pMmcCardIdObj-&gt;monthCode     = ;</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga66fa12d1e3126f4b5fbee1327381f87c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int16 MMC_sendCmd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>eventFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_sendCmd</b> </p>
<p><b>Description</b> <br />
 This is used to send a command to the memory card. Lower 16 bits of the parameter 'cmd' should contain the command that needs to be written to MMCCMD1 register. Upper 16 bits of the 'cmd' should contain the data that needs to be written to MMCCMD2 register.</p>
<p>NOTE:SETTING THE MMCCMD2 VALUE TO '1' IS ALLOWED ONLY TO DATA WRITE COMMANDS THAT USES DMA FOR DATA TRANSFER. FOR OTHER COMMANDS UPPER 16 BITS OF 'CMD' SHOULD ALWAYS BE ZERO.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd        Handle to the MMCSD.
        cmd           Command index.
        arg           Argument.
        eventFlags    MMCSD Event Flags to wait for.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle       hMmcsd;
        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdInstId       instId;
        CSL_status            status;
        Uint32                cmd;
        Uint32                arg;
        Uint16                eventFlags;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        cmd        = CSL_MMCSD_WRITE_INIT_CMD;
        arg        = CSL_MMCSD_ARG_RESET;
        eventFlags = CSL_MMCSD_EVENT_EOFCMD;

        status = MMC_sendCmd(hMmcsd, cmd, arg, eventFlags);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7819c9f81a2db4e17d5001e6bab9774f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_sendGoIdle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_sendGoIdle</b> </p>
<p><b>Description</b> <br />
 This function broadcasts Go Idle command for Setting all cards to the idle state.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd    Handle to the MMCSD</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 This should be called just after <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle         hMmcsd;
        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MmcsdInstId         instId;
        CSL_status              status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_sendGoIdle(hMmcsd);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga930824e2cdbfd96d66730756219e912f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_sendOpCond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>clkDivValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_sendOpCond</b> </p>
<p><b>Description</b> <br />
 This function will set the clock to the SD or MMC Card according to passed parameter of Card Type.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd            Handle to the MMCSD
        clkDivValue       Clock Div value for MMC or SD card.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 1:<a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br />
 2:<a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle         hMmcsd;
        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MMCCardObj          mmcCardObj;
        CSL_MmcsdInstId         instId;
        CSL_status              status;
        Uint16                  clkDivValue;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);

        pMmmcCardObj-&gt;cardType = CSL_MMC_CARD;

        clkDivValue = 0x4 //as MMC clock max is 20MHz and Function clock is 100MHz
        status = MMC_sendOpCond(hMmcsd, clkDivValue);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae274ce72051283a596749b055ea5cd2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_sendSwitchCmd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>argument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends switch commmand to eMMC card. </p>
<p>This API is specific to eMMC card and cannot be used with SD and normal MMC cards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">argument</td><td>[IN] Switch command argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="ga092ceb666b92ba2d19946c827a6b35de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setBlockLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>blockLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_setBlockLength</b> </p>
<p><b>Description</b> <br />
 This function is used to set block length of the memory card using command 16. In the case of a Standard Capacity SD Memory Card or MMC card, command 16 sets the block length(in bytes) for all following block commands (read, write, lock). Default block length is fixed to 512 bytes. In the case of a High Capacity SD memory card, block length set by CMD16 command does not affect the memory read and write commands. Always 512 bytes fixed block length is used.</p>
<p>This API does not verify the value of block length passed as parameter. Calling functions should make sure that the block length passed is proper with respect to the card under operation.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd      MMCSD handle
        blockLen    Length of the memory card block</pre><p><b> Return Value </b> </p><ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br />
 Sets MMC/SD block length</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                          &amp;status);

        status = MMC_setBlockLength(hMmcsd, CSL_MMCSD_BLOCK_LENGTH);
        ...
</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1658e5a530ffce50f24ebd0c2a70cb60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setBootBusWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#ga6dd64c9f21aa32b820c9b626c1792191">CSL_MmcsdBootBusWidth</a>&#160;</td>
          <td class="paramname"><em>bootBusWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>resetBusWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the boot bus width. </p>
<p>This API is used to configure the boot bus width for eMMC card</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">bootBusWidth</td><td>[IN] Boot Bus width 0 - 1bit mode 1 - 4bit mode </td></tr>
    <tr><td class="paramname">resetBusWidth</td><td>[IN] 0 - Reset bus width to 1 after boot operation 1 - Retain boot bus width after boot operation</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: C5505/C5515 MMCSD controller does not support 8-bit mode</p>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status</dd></dl>
<p>This API is used to configure the boot bus width for eMMC card</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">busWidth</td><td>[IN] Boot Bus width 0 - 1bit mode 1 - 4bit mode </td></tr>
    <tr><td class="paramname">resetBootBusWidth[IN]</td><td>0 - Reset bus width to 1 after boot operation 1 - Retain boot bus width after boot operation</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: C5505/C5515 MMCSD controller does not support 8-bit mode</p>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="gae1470b3d6a92e29588d52deb2b9673f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_call_back_obj.html">CSL_MMCCallBackObj</a> *&#160;</td>
          <td class="paramname"><em>pFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_setCallBack</b> </p>
<p><b>Description</b> <br />
 This function sets the address of call back routines which will be called from MMCSD ISR.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd       Handle to the MMCSD.
        pFunction    Pointer to the isr function.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None.</p>
<p><b>Example</b> </p><pre class="fragment">        #define MMCSD_ISR_FUNCTION_MAX (4u)
        void mmcsd0_tx_isr(void);
        void mmcsd0_rcv_isr(void);
        void mmcsd1_tx_isr(void);
        void mmcsd1_rcv_isr(void);

        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        CSL_status            status;
        CSL_MMCCallBackObj    callBckFun;

        instId = CSL_MMCSD0_INST;
        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        callBckFun.isr[CSL_MMCSD_ISR_TXMT] = mmcsd_tx_isr;
        callBckFun.isr[CSL_MMCSD_ISR_RCV]  = mmcsd_rcv_isr;

        status = MMC_setCallBack(hMmcsd, &amp;callBckFun);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga96a951e3a784d66d98977177b0924959"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setCardPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_setCardPtr</b> </p>
<p><b>Description</b> <br />
 This function will set the card object information address into the MMCSD handle. Implementation is limited only to the software layer.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd            Handle to the MMCSD.
        CSL_MMCCardObj    Pointer to the MMCSD Card Object.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully before this.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 Card object structure</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCCardObj        mmcCardObj;
        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_setCardPtr(hMmcsd, &amp;mmcCardObj);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga78aad8f81a6cb388dff08240e39fc018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setCardType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pCardObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#ga90fae15acd7c0ccde7119b9e47ec7a76">CSL_CardType</a>&#160;</td>
          <td class="paramname"><em>cardType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_setCardType</b> </p>
<p><b>Description</b> <br />
 This API just updates the software structure and does not update any hardware registers</p>
<p><b>Arguments</b> </p><pre class="fragment">        pCardObj    Pointer to the card object.
        cardType    type of card MMC or SD.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 None.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCCardObj        cardObj;
        CSL_CardType          cardType;

        cardType = CSL_SD_CARD;

        status = MMC_setCardType(&amp;cardObj, cardType);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf3d12f302957fef49d39a7ec849ca0da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setDataTransferCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga20e1f9dc20404f494d4bb9a5bc59f901">CSL_MMCDataTxferCallBackPtr</a>&#160;</td>
          <td class="paramname"><em>dataTransferCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_setDataTransferCallback</b> </p>
<p><b>Description</b> <br />
 This function stores the data transfer call back function pointer in the MMCSD handle. This callback pointer is used by the MMCSD write and read APIs to issue callback during data transfer operations. This is to facilitate application/driver programs handle MMCSD interrupt in their own way depending on their requirements. Callback function is used when MMCSD is operating in DMA or interrupt mode. During DMA mode operation, call back function will be called after starting the DMA data transfer. During interrupt mode operation call back function will be called</p><ol type="1">
<li>For checking read/write command response</li>
<li>For checking transit/receive ready bit</li>
<li>For checking data done bit</li>
</ol>
<p>In both the operating modes callback function should wait for the MMCSD interrupt. Upon receiving the interrupt, all the MMCSD events should be disabled. MMCSD handle will be passed to the callback function as a parameter.</p>
<p>Setting the callback function is optional for DMA mode but is mandatory for interrupt mode operation. MMC_read/MMC_write APIs return with error in case of no callback is set and MMCSD is configured for interrupt mode.</p>
<p>NOTE: Same callback pointer will be used by write and read APIs. Callback function is applicable to DMA and interrupt mode only. Should not call this API when MMCSD is operation in polled mode.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd                  MMCSD handle
        dataTransferCallback    Transfer done callback pointer</pre><p><b> Return Value </b> </p><ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br />
 Stores the transfer done callback pointer in MMC handle</p>
<p><b>Modifies</b> <br />
 MMC handle</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle                hMmcsd;
        CSL_MMCDataTxferCallBackPtr    dataTransferCallback;
        CSL_MmcsdInstId                instId;
        CSL_status                     status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                          &amp;status);

        status = MMC_setDataTransferCallback(hMmcsd, dataTransferCallback);
        ...
</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga352c10b5cb98c67b2edcaca9a527d496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setDmaChanConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___mmcsd_dma_config.html">CSL_MmcsdDmaConfig</a>&#160;</td>
          <td class="paramname"><em>dmaConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_setDmaChanConfig</b> </p>
<p><b>Description</b> <br />
 This function is used to set the DMA channel configurations. DMA channel configuration values sent by the application are stored in the MMCSD handle and used by the MMC write and read functions. DMA read and write channel configurations can be set independently with only one channel at a time using this function. Direction of the DMA channel is identified using the member 'chanDir' of CSL_MMCDmaConfig structure. Operating mode of the MMCSD module needs to be set to DMA mode for using this API.</p>
<p>Members of CSL_MMCDmaConfig structure are subset of <a class="el" href="struct_c_s_l___d_m_a___config.html" title="DMA configuration structure. ">CSL_DMA_Config</a> structure. Other configuration values DMA source address, destination address, DMA data length etc are not configurable by MMCSD application program and are set by the MMCSD read/write API depending on the request from file system.</p>
<p>Only 4word and 8word DMA burst length is allowed for MMCSD (burstLen). Any other burst length will be ignored and DMA will be configured to 8word burst length by default.</p>
<p>This API is an optional one. Default DMA configurations are assigned by the MMC_open function. No need to call this API until and unless a different DMA configurations are required by the application.</p>
<p>NOTE:This API should not be called when MMCSD is operating Polled mode.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd       MMCSD handle
        dmaConfig    DMA configuration structure</pre><p><b> Return Value </b> </p><ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid configuration parameters</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br />
 Stores the DMA configuration values in MMC handle</p>
<p><b>Modifies</b> <br />
 MMC handle</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj    pMmcsdContObj;
        CSL_MmcsdHandle         hMmcsd;;
        CSL_MmcsdDmaConfig      dmaWriteCfg;
        CSL_MmcsdDmaConfig      dmaReadCfg;
        CSL_MmcsdInstId         instId;
        CSL_status              status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                          &amp;status);

        dmaWriteCfg.autoMode     = CSL_DMA_AUTORELOAD_DISABLE;
        dmaWriteCfg.burstLen     = CSL_DMA_TXBURST_8WORD;
        dmaWriteCfg.chanDir      = CSL_DMA_WRITE;
        dmaWriteCfg.dmaInt       = CSL_DMA_INTERRUPT_ENABLE;

        // Set the DMA write channel configuration
        status = MMC_setDmaChanConfig(hMmcsd, dmaWriteCfg);

        dmaReadCfg.autoMode     = CSL_DMA_AUTORELOAD_DISABLE;
        dmaReadCfg.burstLen     = CSL_DMA_TXBURST_8WORD;
        dmaReadCfg.chanDir      = CSL_DMA_READ;
        dmaReadCfg.dmaInt       = CSL_DMA_INTERRUPT_ENABLE;

        // Set the DMA read channel configuration
        status = MMC_setDmaChanConfig(hMmcsd, dmaReadCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9cabd2c2de7225dd78daa2387bf8aed4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setDmaHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___d_m_a___d_a_t_a_s_t_r_u_c_t.html#ga70d6f2cebee9dafd348ccd554efaeda3">CSL_DMA_Handle</a>&#160;</td>
          <td class="paramname"><em>hDmaWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___d_m_a___d_a_t_a_s_t_r_u_c_t.html#ga70d6f2cebee9dafd348ccd554efaeda3">CSL_DMA_Handle</a>&#160;</td>
          <td class="paramname"><em>hDmaRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_setDmaHandle</b> </p>
<p><b>Description</b> <br />
 This function stores the DMA handles sent by the application program. DMA handle stored in MMCSD handle will be used by the MMC read/write APIs to transfer the data in DMA mode. This API requires that MMCSD operating mode should be set to DMA using MMC_open function. DMA channel handles should be sent by the application in proper order. DMA channel needs to opened before calling this API. This channels will be closed by the MMC_close API.</p>
<p>NOTE:This API should not be called when MMCSD is operating Polled mode.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd       MMCSD handle
        hDmaWrite    Handle to DMA channel used for MMCSD write operation
        hDmaRead     Handle to DMA channel used for MMCSD read operation</pre><p><b> Return Value </b> </p><ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid DMA handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> and <a class="el" href="group___c_s_l___d_m_a___f_u_n_c_t_i_o_n.html#ga3c9ecb2992e2ffa1cabf0512cdc88d31">DMA_open()</a> functions should be called successfully</p>
<p><b> Post Condition </b> <br />
 Stores the DMA handle in MMC handle</p>
<p><b>Modifies</b> <br />
 MMC handle</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  pMmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_DMA_Handle        dmaWrHandle;
        CSL_DMA_Handle        dmaRdHandle;
        CSL_DMA_ChannelObj    dmaWrChanObj;
        CSL_DMA_ChannelObj    dmaRdChanObj;

        CSL_MmcsdInstId       instId;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                          &amp;status);

        dmaWrHandle = DMA_open(&amp;dmaWrChanObj, CSL_DMA_CHAN0);

        dmaRdHandle = DMA_open(&amp;dmaRdChanObj, CSL_DMA_CHAN1);

        // Set DMA handle
        status = MMC_setDmaHandle(hMmcsd, dmaWrHandle, dmaRdHandle);
        ...
</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gada1f8f1c1fa95145770944ec6bb58307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setEMMCBusWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>busWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bus width. </p>
<p>This API is used to configure the bus width for MMC/SD card</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">busWidth</td><td>[IN] Bus width 0 - 1bit mode 1 - 4bit mode</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: C5505/C5515 MMCSD controller does not support 8-bit mode</p>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status </dd></dl>

</div>
</div>
<a class="anchor" id="ga3be5dcff1884f09477361fe4fd9f57e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setEndianMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#gad374520910fa2c1324dc36d2ae22fa7d">CSL_MmcsdEndianMode</a>&#160;</td>
          <td class="paramname"><em>writeEndianMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___e_n_u_m.html#gad374520910fa2c1324dc36d2ae22fa7d">CSL_MmcsdEndianMode</a>&#160;</td>
          <td class="paramname"><em>readEndianMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_setEndianMode</b> </p>
<p><b>Description</b> <br />
 This function is used to set endian mode of the MMC/SD controller. Endian mode set using this API decides the way in which data is transferred from FIFO to storage device.</p>
<p>Default endianness of MMCSD controller: Chip C5504 and C5505: LITTLE ENDIAN. Chip C5514 and C5515: BIG ENDIAN.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd             MMCSD handle
        writeEndianMode    Endian mode for MMC/SD write operation
        readEndianMode     Endian mode for MMC/SD read operation</pre><p><b> Return Value </b> </p><ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br />
 Sets MMC/SD endian mode for write and operations</p>
<p><b>Modifies</b> <br />
 MMC/SD control register</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj  pMmcsdContObj;
        CSL_MmcsdHandle       hMmcsd;
        CSL_MmcsdInstId       instId;
        CSL_status            status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                          &amp;status);

        status = MMC_setEndianMode(hMmcsd, CSL_MMCSD_ENDIAN_LITTLE,
                                  CSL_MMCSD_ENDIAN_LITTLE);
        ...
</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga126887ca3952a6130e4957846c26ac68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setRca </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pMmcCardObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>rCardAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_setRca</b> </p>
<p><b>Description</b> <br />
 This function sets the relative card address for MMC Card. Relative card address is stored in <a class="el" href="struct_c_s_l___m_m_c_card_obj.html" title="structure for card specific information. ">CSL_MMCCardObj</a> which can used by other MMCSD CSL APIs.</p>
<p>Application programs should use only this function to set the RCA of MMC card. RCA passed to this function will be stored in the MMCSD handle and is used by other MMCSD CSL APIs.</p>
<p>NOTE: THIS FUNCTION IS SPECIFIC TO MMC CARD AND SHOULD NOT BE USED WITH THE SD CARD. FOR MMC CARD CMD3(SET_RELATIVE_ADDR) IS USED TO SET THE CARD ADDRESS AND FOR SD CARD CMD3(SEND_RELATIVE_ADDR) IS USED TO REQUEST THE CARD ADDRESS.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd            Handle to the MMCSD.
        pMmcCardObj       Pointer to the MMC Card Info.
        rCardAddr         Relative card address.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 1:<a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br />
 2:<a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br />
 3: If Card detected is MMC then <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a> for specific to MMC.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle         hMmcsd;
        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MMCCardObj          mmcCardObj;
        CSL_MmcsdInstId         instId;
        CSL_status              status;
        Uint16                  clkDivValue;
        Uint16                  rCardAddr;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_selectCard(hMmcsd, &amp;mmcCardObj);

        clkDivValue = 0x4 //as MMC clock max is 20MHz and Function clock is 100MHz
        status = MMC_sendOpCond(hMmcsd, clkDivValue);
        rCardAddr = 0x100;

        status = MMC_setRca(hMmcsd, &amp;mmcCardObj, rCardAddr);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga64755486e84519aceab8f6611c76bce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setupNative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_setup_native.html">CSL_MMCSetupNative</a> *&#160;</td>
          <td class="paramname"><em>pMmcInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_setupNative</b> </p>
<p><b>Description</b> <br />
 This function will set initial configuration to all the MMCSD registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd      Handle to the MMCSD.
        pMmcInit    Pointer to CSL_MMCSetupNative state variable.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this.</p>
<p><b> Post Condition </b> <br />
 MMCSD Registers will be populated.</p>
<p><b>Modifies</b> <br />
 MMCSD Registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle       hMmcsd;
        CSL_MMCControllerObj  pMmcsdContObj;
        CSL_MmcsdInstId       instId;
        CSL_status            status;
        CSL_MMCConfig         mmcInit;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;pMmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        Note: CSL_MMCConfig field are following.
        mmcInit.dmaEnable         = CSL_MMCSD_MMCCMD2_DMATRIG_NO;
        mmcInit.dat3EdgeDetection = CSL_MMCSD_MMCCTL_DATEG_DISABLE;
        mmcInit.cdiv              = CSL_MMCSD_CLK_DIV_INIT;
        mmcInit.rspTimeout        = CSL_MMCSD_RESPONSE_TIMEOUT;
        mmcInit.dataTimeout       = CSL_MMCSD_DATA_RW_TIMEOUT;
        mmcInit.blockLen          = CSL_MMCSD_MIN_BLOCK_LENGTH;

        status = MMC_setupNative(hMmcsd, &amp;mmcInit);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8911fdaf15d677af8c31463963c222a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_setWriteBlkEraseCnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>blkCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_setWriteBlkEraseCnt</b> </p>
<p><b>Description</b> <br />
 Function to set the number of write blocks to be preerased before writing. Set write block erase count command need to be used for faster multiple block write command. Calling this function is not mandatory. In case of calling this API for better performance, it should be called just before calling MMC_write function.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd      MMCSD handle
        blkCnt      Number of blocks</pre><p><b> Return Value </b> </p><ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br />
 Sets preerase block count</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MmcsdHandle         hMmcsd;
        CSL_MmcsdInstId         instId;
        CSL_status              status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                          &amp;status);

        status = MMC_setWriteBlkEraseCnt(hMmcsd, 16);
        ...
</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab31b48d48ffc562e53f94c81c1ad6613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_stop</b> </p>
<p><b>Description</b> <br />
 Function to stop the MMC/SD transfer and receive events. This function sends CMD12 to the memory card.</p>
<p>NOTE: STOP command should be sent to the card when it is in 'data'(read) or 'rcv'(write) state. Sending STOP command while the card in any other state will result in command timeout.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd            Handle to the MMCSD</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called before this. <br />
 Card should be addressed.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle         hMmcsd;
        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MmcsdInstId         instId;
        CSL_status              status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_stop(hMmcsd);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7f52bd655086f5a0d406d431c020f0a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status MMC_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>cardAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>noOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pWriteBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_write</b> </p>
<p><b>Description</b> <br />
 This function writes data in the write data buffer to the memory card at a given address.</p>
<p>'cardAddr' represents the address location in the card to be accessed. For the standard capacity cards this parameter will be a value in multiples of 512. That means to write a sector number 1 cardAddr will be 1*512, to write a sector number 2 cardAddr will be 2*512 and so on. For the high capacity cards 'cardAddr' parameter will be same as the sector number. That means to write a sector number 1 cardAddr will be 1, to write a sector number 2 cardAddr will be 2 and so on. Reason for this is high capacity cards uses BLOCK addressing instead of the BYTE addressing used by the standard capacity cards to increase the addressable memory capacity.</p>
<p>Detection of high capacity cards can be verified using the flag 'sdHcDetected' in the MMCSD card object structure. sdHcDetected = TRUE - SD card is high capacity card sdHcDetected = FALSE - SD card is standard capacity card</p>
<p>NOTE: CARE SHOULD BE TAKEN WHILE PASSING THE 'cardAddr' PARAMETER. USING BYTE ADDRESSING WITH HIGH CAPACITY CARDS WILL LEAD TO OUT OF SECTOR BOUNDARY ACCESS AND RESULTS IN CODE HANGING FOR MMCSD RESPONSE.</p>
<p>NOTE: Endian mode of the data transfer depends on the parameter 'writeEndianMode' in the MMC handle. Default value for the endian mode is 'LITTLE ENDIAN' which will be set during MMC open. Endian mode can be configured using <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga3be5dcff1884f09477361fe4fd9f57e8">MMC_setEndianMode()</a>. DO NOT CHANGE THE ENDIAN MODE WITH OUT USING THIS API.</p>
<p>NOTE: When transferring data in DMA mode, word swap will be done for the data buffer when MMCSD is configured for little endian mode. No word swap is required in upper SW layers.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd            Handle to the MMCSD
        cardAddr          location to read from.
        noOfBytes         no of bytes to read.
        pWriteBuffer      pointer to a buffer.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Close successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - card Response time out</li>
</ul>
<p><b> Pre Condition </b> <br />
 1.MMC_open() API should be called successfully. <br />
 2.MMC_selectCard() API should be called before this so that it will do some needful work for particular card detected. <br />
 3. <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a>for specific to card . <br />
 4. If Card detected is SD then call <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga3a7183e22e839d1f57f6d143ce78c3a4">SD_getCardCsd()</a> specific to SD. If Card detected is SD then call <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga0ab342afd3a8406390cab83fbcd2a720">MMC_getCardCsd()</a> specific to MMC</p>
<p><b> Post Condition </b> <br />
 Writes the data to card</p>
<p><b>Modifies</b> <br />
 MMC/SD card will populated with the passed buffer values.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle       hMmcsd;
        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MMCCardObj        sdCardObj;
        CSL_MMCCardCsdObj     sdCardCsdObj;
        CSL_MmcsdInstId       instId;
        CSL_status            status;
        Uint16                clkDivValue;
        Uint16                noOfBytes;
        Uint16                cardAddr;
        Uint16                writeBuffer[256];

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_selectCard(hMmcsd, &amp;sdCardObj);

        sdCardObj.cardType = CSL_SD_CARD;
         clkDivValue = 0x1 //as SD clock max is 50MHz and Function
                             clock is 100MHz
        status = MMC_sendOpCond(hMmcsd, clkDivValue);

        status = SD_getCardCsd(hMmcsd, &amp;sdCardCsdObj);
        For example following value will be populated.
        pSdCardCsdObj-&gt;readBlLen         = ;
        pSdCardCsdObj-&gt;cSize  = ;
        These value will be useful to fetch the card specific information
        These figure are tested with 1GB Ultra SD Card
        blockLength  = 512 Bytes
        cardCapacity = 0x1015808000 Bytes
        totalSectors = 0x1984000 sector

        cardAddr = 0x200;
        noOfBytes = 512;

        status = MMC_write(hMmcsd, cardAddr, noOfBytes, &amp;writeBuffer);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1ce2cec113d65fdb5a88bdd6f462e330"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_writeNSectors </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pWriteBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaSector&#160;</td>
          <td class="paramname"><em>startSector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16&#160;</td>
          <td class="paramname"><em>sectorCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_writeNSectors</b> </p>
<p><b>Description</b> <br />
 This function is used to write N number of sectors to MMC/SD card. Each sector size will be 512 bytes</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure
        pWriteBuf         Pointer to write data buffer
        startSector       Starting sector number to write
        sectorCount       Number of sectors to write</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 Writes data to media</p>
<p><b>Modifies</b> <br />
 Data in the MMC/SD card</p>
<p><b>Example</b> </p><pre class="fragment">        #define CSL_MMCSD_BUF_SIZE (256u)

        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaError       ataErr;
        AtaUint16      dataBuf[CSL_MMCSD_BUF_SIZE];
        AtaUint16      words;
        Uint16         sectNum;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;
        words   = CSL_MMCSD_BUF_SIZE;
        sectNum = 0;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = MMC_writeNSectors(ataState-&gt;pAtaMediaState, dataBuf,
                                   words, sectNum, 8);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad904a36b62dff38809b18706f2b217a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_writeSector </td>
          <td>(</td>
          <td class="paramtype">AtaSector&#160;</td>
          <td class="paramname"><em>phySector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtaUint16 *&#160;</td>
          <td class="paramname"><em>pWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteSwap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_writeSector</b> </p>
<p><b>Description</b> <br />
 This function is used to write data to the media. This function can write 512 bytes of data at one time.</p>
<p>Programs calling this function should assign proper value to ATA_No_Swap in case of using that varaible.</p>
<p><b>Arguments</b> </p><pre class="fragment">        phySector         Sector number from which data needs to be read
        pAtaMediaState    ATA media state structure
        pWord             Write data buffer
        byteSwap          Flag to request for the byte swap</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success </li>
<li>ATA_ERROR_INVALID_PARAM - Returned for Invalid input parameters </li>
<li>ATA_ERROR_TIMEOUT - Time out Error Occurred </li>
<li>ATA_ERROR_UNSUPPORTED - MMC/SD hardware is not supported</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 Writes Data to MMC/SD card</p>
<p><b>Modifies</b> <br />
 MMCSD Sector data</p>
<p><b>Example</b> </p><pre class="fragment">        #define CSL_MMCSD_BUF_SIZE (256u)

        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;
        AtaSector      phySector;
        AtaUint16      writeBuf[CSL_MMCSD_BUF_SIZE];

        pAtaState = &amp;ataState;

        phySector = 0;
        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = pAtaState-&gt;AtaWriteSector(phySector,
                                           ataState-&gt;pAtaMediaState,
                                           writeBuf, FALSE);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga387ce86f026b4c9a65f057bd0d4bf0dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AtaError MMC_writeSectorFlush </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAtaMediaState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>MMC_writeSectorFlush</b> </p>
<p><b>Description</b> <br />
 This function always returns success. No functionality is implemented. This function address is assigned to the function pointer provided by ATA file system.</p>
<p><b>Arguments</b> </p><pre class="fragment">        pAtaMediaState    ATA media state structure</pre><p><b> Return Value </b> AtaError </p><ul>
<li>ATA_ERROR_NONE - Returned for success</li>
</ul>
<p><b> Pre Condition </b> <br />
 MMC_initState API should be called successfully.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        AtaMMCState    ataMediaState;
        AtaState       ataState;
        AtaState       *pAtaState;
        AtaError       ataErr;

        pAtaState = &amp;ataState;

        ataState-&gt;pAtaMediaState = &amp;ataMediaState;

        ataErr = MMC_initState(&amp;ataState);

        ataErr = pAtaState-&gt;AtaWriteSectorFlush(ataState-&gt;pAtaMediaState);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadff5ef92220929877229fddea116db6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SD_configurePullup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>pullupCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>SD_configurePullup</b> </p>
<p><b>Description</b> <br />
 Function to Connenct/Disconnect the SD card internal pull-up resistors. This function is specific to SD card; cannot be used with MMC card</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd         MMCSD handle
        pullupCfg      Flag indicate the pull-up configuration
                         0 - Disconnects the pull-up resistor
                         1 - Connects the pull-up resistor</pre><p><b> Return Value </b> </p><ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully <br />
 Card should be selected</p>
<p><b> Post Condition </b> <br />
 Connencts/Disconnects SD card pull-up resistor</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MmcsdHandle         hMmcsd;
        CSL_MmcsdInstId         instId;
        CSL_status              status;
        Uint32                  cardStatus;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                          &amp;status);
        ....

        //Select the card

        ....

        status = SD_configurePullup(hMmcsd, 0);
</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3a7183e22e839d1f57f6d143ce78c3a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SD_getCardCsd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_card_csd_obj.html">CSL_MMCCardCsdObj</a> *&#160;</td>
          <td class="paramname"><em>pSdCardCsdObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>SD_getCardCsd</b> </p>
<p><b>Description</b> <br />
 This function will update the CSD Structure info of SD Card.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd            Handle to the MMCSD.
        pSdCardCsdObj     Pointer to the SD Card CSD Info.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 1:<a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br />
 2:<a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br />
 3:If Card detected is SD then <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a>for specific to SD.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle       hMmcsd;
        CSL_MMCControllerObj  mmcsdContObj;
        CSL_MMCCardObj        sdCardObj;
        CSL_MMCCardCsdObj     sdCardCsdObj;
        CSL_MmcsdInstId       instId;
        CSL_status            status;
        Uint16                clkDivValue;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_selectCard(hMmcsd, &amp;sdCardObj);

        clkDivValue = 0x1 //As SD clock max is 50MHz and Function clock is 100MHz
        status = MMC_sendOpCond(hMmcsd, clkDivValue);

        status = SD_getCardCsd(hMmcsd, &amp;sdCardCsdObj);
        For example following value will be populated.
        sdCardCsdObj.readBlLen         = ;
        sdCardCsdObj.cSize  = ;
        These values will be useful to fetch the card specific information
        like these-----
        These figure are tested with 1GB Ultra SD Card
        blockLength      = 512 Bytes
        cardCapacity     = 0x1015808000 Bytes
        totalSectors     = 0x1984000 sector</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaffe121b613eb075a564f8f827d1b22fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SD_sendAllCID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_card_id_obj.html">CSL_MMCCardIdObj</a> *&#160;</td>
          <td class="paramname"><em>pSdCardIdObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>SD_sendAllCID</b> </p>
<p><b>Description</b> <br />
 This will fetch the Information about SD Card Id and update into the passed id structure.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd           Handle to the MMCSD.
        pSdCardIdObj     Pointer to the SD Card ID Info.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 1:<a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br />
 2:<a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br />
 3:If Card detected is SD then <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a> specific to SD.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 pSdCardIdObj object will be populated.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle         hMmcsd;
        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MMCCardObj          sdCardObj;
        CSL_MMCCardIdObj        sdCardIdObj;
        CSL_MmcsdInstId         instId;
        CSL_status              status;
        Uint16                  clkDivValue;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_selectCard(hMmcsd, &amp;sdCardObj);

        clkDivValue = 0x1 //As SD clock max is 50MHz and
                            Function clock is 100MHz
        status = MMC_sendOpCond(hMmcsd, clkDivValue);

        status = SD_sendAllCID(hMmcsd, &amp;sdCardIdObj);

        For example following value will be populated.
        sdCardIdObj.mfgId         = ;
        sdCardIdObj.serialNumber  = ;
        sdCardIdObj.monthCode     = ;</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga422c250e5c38131c42df668587162eb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SD_sendRca </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_m_c_card_obj.html">CSL_MMCCardObj</a> *&#160;</td>
          <td class="paramname"><em>pSdCardObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pRCardAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>SD_sendRca</b> </p>
<p><b>Description</b> <br />
 This function sends request for relative card address(RCA) of SD Card. RCA value published by SD card will be populated to card address parameter. RCA is also stored in <a class="el" href="struct_c_s_l___m_m_c_card_obj.html" title="structure for card specific information. ">CSL_MMCCardObj</a> to use in other MMCSD CSL APIs.</p>
<p>Application programs should use only this function to requesting the RCA from SD card. RCA published by the SD card will be stored in the MMCSD handle and is used by other MMCSD CSL APIs.</p>
<p>NOTE: THIS FUNCTION IS SPECIFIC TO SD CARD AND SHOULD NOT BE USED WITH THE MMC CARD. FOR MMC CARD CMD3(SET_RELATIVE_ADDR) IS USED TO SET THE CARD ADDRESS AND FOR SD CARD CMD3(SEND_RELATIVE_ADDR) IS USED TO REQUEST THE CARD ADDRESS.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd            Handle to the MMCSD.
        pSdCardObj        Pointer to the SD Card Info.
        pRCardAddr        Pointer to store relative card address.</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid Parameter </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 1:<a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> API should be called successfully. <br />
 2:<a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga2b7407c0ddc8d6740109c528e0848d05">MMC_selectCard()</a> API should be called before this so that it will do some needful work for particular card detected. <br />
 3:If Card detected is SD then <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#ga930824e2cdbfd96d66730756219e912f">MMC_sendOpCond()</a> for specific to SD.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Modifies</b> <br />
 pRCardAddr variable will be populated.</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MmcsdHandle         hMmcsd;
        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MMCCardObj          sdCardObj;
        CSL_MmcsdInstId         instId;
        CSL_status              status;
        Uint16                  clkDivValue;
        Uint16                  rCardAddr;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_POLLED,
                          &amp;status);

        status = MMC_selectCard(hMmcsd, &amp;sdCardObj);

        clkDivValue = 0x1; //As SD clock max is 50MHz and Function clock is 100MHz

        status = MMC_sendOpCond(hMmcsd, clkDivValue);
        status = SD_sendRca(hMmcsd, &amp;sdCardObj, &amp;rCardAddr);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac5311523eff70c1d40ff9e3947c57fab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SD_setBusWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>busWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>SD_setBusWidth</b> </p>
<p><b>Description</b> <br />
 Function to set the bus with for SD card. This function sends ACMD6 to the SD card to configure the bus width. This function should be called after selecting the card using CMD7.</p>
<p>NOTE: This function is specific to SD card.Should not be used with MMC.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hMmcsd        MMCSD handle
        busWidth      bus width of the card; 0 - 1 bit, 1 - 4 bit</pre><p><b> Return Value </b> </p><ul>
<li>CSL_SOK - Returned for Success </li>
<li>CSL_ESYS_BADHANDLE - Invalid MMSDC handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters </li>
<li>CSL_EMMCSD_TIMEOUT - Command Reponse Timeout </li>
<li>CSL_EMMCSD_CRCERR - Command CRC Error</li>
</ul>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___m_m_c_s_d___f_u_n_c_t_i_o_n.html#gac69a19e39587bc4bc74144287050c64b">MMC_open()</a> function should be called successfully</p>
<p><b> Post Condition </b> <br />
 Sets SD card bus width</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_MMCControllerObj    mmcsdContObj;
        CSL_MmcsdHandle         hMmcsd;
        CSL_MmcsdInstId         instId;
        CSL_status              status;

        instId = CSL_MMCSD0_INST;

        hMmcsd = MMC_open(&amp;mmcsdContObj, instId, CSL_MMCSD_OPMODE_DMA,
                          &amp;status);

        status = SD_setBusWidth(hMmcsd, 1);
        ...
</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga770b1ccb0e958bf9ce380bd3e8f71ed7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status sendCmd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___m_m_c_s_d___d_a_t_a_s_t_r_u_c_t.html#ga6e484dcdb8316ca3a40475b105296e10">CSL_MmcsdHandle</a>&#160;</td>
          <td class="paramname"><em>hMmcsd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___mmcsd_cmd.html">CSL_MmcsdCmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>argument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends command. </p>
<p>This API sends command to the card. The commands are w.r.t. MMC/SD specification</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hMmcsd</td><td>[IN] Handle to the MMCSD. </td></tr>
    <tr><td class="paramname">cmd</td><td>[IN] command details </td></tr>
    <tr><td class="paramname">argument</td><td>[IN] argument value for the command</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_Status </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C55XX CSL 3.06.00 API: EMIF Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C55XX CSL 3.06.00 API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EMIF Functions<div class="ingroups"><a class="el" href="group___c_s_l___e_m_i_f___a_p_i.html">EMIF</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab175d3a1c935db9acb6421a23745212c"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gab175d3a1c935db9acb6421a23745212c">EMIF_init</a> (<a class="el" href="struct_c_s_l___emif_obj.html">CSL_EmifObj</a> *emifObj)</td></tr>
<tr class="separator:gab175d3a1c935db9acb6421a23745212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ce4fbff03516bcae9c65967f4df62f"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga01ce4fbff03516bcae9c65967f4df62f">SDRAM_config</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, <a class="el" href="struct_c_s_l___sdram_cfg.html">CSL_SdramCfg</a> *sdramConfig, <a class="el" href="struct_c_s_l___sdram_timr.html">CSL_SdramTimr</a> *sdramTimr)</td></tr>
<tr class="separator:ga01ce4fbff03516bcae9c65967f4df62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d0070128dc006f9eac84ded5ff4527e"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga9d0070128dc006f9eac84ded5ff4527e">SDRAM_enablePowerDownMode</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif)</td></tr>
<tr class="separator:ga9d0070128dc006f9eac84ded5ff4527e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga049ed29453ced09ee9b8e8ad3c7ed49a"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga049ed29453ced09ee9b8e8ad3c7ed49a">SDRAM_disablePowerDownMode</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif)</td></tr>
<tr class="separator:ga049ed29453ced09ee9b8e8ad3c7ed49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0346aff2088eef7a6c71d307496adf4e"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga0346aff2088eef7a6c71d307496adf4e">SDRAM_enableSelfRefreshMode</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif)</td></tr>
<tr class="separator:ga0346aff2088eef7a6c71d307496adf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36b8603dcfa7b140b5a2783617bc72b8"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga36b8603dcfa7b140b5a2783617bc72b8">SDRAM_disableSelfRefreshMode</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif)</td></tr>
<tr class="separator:ga36b8603dcfa7b140b5a2783617bc72b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0476c608cfefe33e54f0217be3ea01d7"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga0476c608cfefe33e54f0217be3ea01d7">SDRAM_read</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint32 numWords, Uint32 sdramAddr, Uint16 *dataBuff)</td></tr>
<tr class="separator:ga0476c608cfefe33e54f0217be3ea01d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19525f14b676381f9dec25a07e48072c"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga19525f14b676381f9dec25a07e48072c">SDRAM_write</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint32 numWords, Uint32 sdramAddr, Uint16 *dataBuff)</td></tr>
<tr class="separator:ga19525f14b676381f9dec25a07e48072c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1faa0486fd7b1057139665135a99b7"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga4d1faa0486fd7b1057139665135a99b7">EMIF_asyncConfig</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, <a class="el" href="struct_c_s_l___async_config.html">CSL_AsyncConfig</a> *asyncConfig)</td></tr>
<tr class="separator:ga4d1faa0486fd7b1057139665135a99b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4544371d51e382c0f056db9c7df01c69"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga4544371d51e382c0f056db9c7df01c69">NOR_checkStatus</a> (Uint32 timeOut)</td></tr>
<tr class="separator:ga4544371d51e382c0f056db9c7df01c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c938f6de590312c0b8a94cdcfef16bc"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga5c938f6de590312c0b8a94cdcfef16bc">NOR_WriteNwords</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint32 numWords, Uint32 norAddr, Uint16 *dataBuff)</td></tr>
<tr class="separator:ga5c938f6de590312c0b8a94cdcfef16bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda10f098d22987601e618252bd6365d"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gadda10f098d22987601e618252bd6365d">NOR_readNwords</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint32 numWords, Uint32 norAddr, Uint16 *dataBuff)</td></tr>
<tr class="separator:gadda10f098d22987601e618252bd6365d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7692ac0633d35285d004301e6faf5f5"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gac7692ac0633d35285d004301e6faf5f5">NOR_sendCommand</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint32 norAddr, Uint16 command)</td></tr>
<tr class="separator:gac7692ac0633d35285d004301e6faf5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6279a79856fd337fb52ea01f4b2d2ab0"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga6279a79856fd337fb52ea01f4b2d2ab0">NAND_setup</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, <a class="el" href="struct_c_s_l___nand_config.html">CSL_NandConfig</a> *nandConfig)</td></tr>
<tr class="separator:ga6279a79856fd337fb52ea01f4b2d2ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12e2384ee8c06a0357ee6f57e1896cd"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gab12e2384ee8c06a0357ee6f57e1896cd">NAND_getBankInfo</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, <a class="el" href="struct_c_s_l___nand_async_bank.html">CSL_NandAsyncBank</a> *bank, Uint16 bankNum)</td></tr>
<tr class="separator:gab12e2384ee8c06a0357ee6f57e1896cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa5c8114ce58f2e53bb64c1cda769a5"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gaeaa5c8114ce58f2e53bb64c1cda769a5">NAND_setLatchEnableOffset</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint32 addrOffset, Uint32 cmdOffset)</td></tr>
<tr class="separator:gaeaa5c8114ce58f2e53bb64c1cda769a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bed9d7e3731bcfec042b49921441e2b"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga6bed9d7e3731bcfec042b49921441e2b">NAND_isStatusWriteProtected</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint16 *WPstatus)</td></tr>
<tr class="separator:ga6bed9d7e3731bcfec042b49921441e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db08651a72079eb2da4bfd9be027f34"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga5db08651a72079eb2da4bfd9be027f34">NAND_sendCommand</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, CSL_VUint16 cmd)</td></tr>
<tr class="separator:ga5db08651a72079eb2da4bfd9be027f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b3a1fe44389de119c4748b484edd70"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga51b3a1fe44389de119c4748b484edd70">NAND_checkCommandStatus</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif)</td></tr>
<tr class="separator:ga51b3a1fe44389de119c4748b484edd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfb2bef7ffb838f28fa1a6f1106fdc7d"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gabfb2bef7ffb838f28fa1a6f1106fdc7d">NAND_setAddress</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint16 addr)</td></tr>
<tr class="separator:gabfb2bef7ffb838f28fa1a6f1106fdc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0075d2cf3330714e999cf21fc58ba5a7"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga0075d2cf3330714e999cf21fc58ba5a7">NAND_enableHwECC</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, <a class="el" href="group___c_s_l___e_m_i_f___e_n_u_m.html#gaac3e77e693cf982963090786caae64b0">CSL_EmifChipSelect</a> csInput)</td></tr>
<tr class="separator:ga0075d2cf3330714e999cf21fc58ba5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63fcf36fc202f72ae533f8f46108a100"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga63fcf36fc202f72ae533f8f46108a100">NAND_disableHwECC</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, <a class="el" href="group___c_s_l___e_m_i_f___e_n_u_m.html#gaac3e77e693cf982963090786caae64b0">CSL_EmifChipSelect</a> csInput)</td></tr>
<tr class="separator:ga63fcf36fc202f72ae533f8f46108a100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae04a3c8205fbdbf94e5cb7cc9df4a699"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gae04a3c8205fbdbf94e5cb7cc9df4a699">NAND_readECC</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint16 *eccBuffer, <a class="el" href="group___c_s_l___e_m_i_f___e_n_u_m.html#gaac3e77e693cf982963090786caae64b0">CSL_EmifChipSelect</a> csInput)</td></tr>
<tr class="separator:gae04a3c8205fbdbf94e5cb7cc9df4a699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3308edb55df7d3725b38fd6208a1ee6c"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga3308edb55df7d3725b38fd6208a1ee6c">NAND_readNBytes</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint16 readRequest, Uint16 *pReadBuffer, Uint16 pack, Bool spare)</td></tr>
<tr class="separator:ga3308edb55df7d3725b38fd6208a1ee6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862646cc59c43ac211ac6844e59d82cd"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga862646cc59c43ac211ac6844e59d82cd">NAND_writeNBytes</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint16 writeRequest, Uint16 *pWriteBuffer, Uint16 val, Bool spare)</td></tr>
<tr class="separator:ga862646cc59c43ac211ac6844e59d82cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad96af157e5acb8f40a63e6a258e87029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gad96af157e5acb8f40a63e6a258e87029">NAND_hasRandomRead</a> (Uint32 nandOptions, Uint16 *RRstatus)</td></tr>
<tr class="separator:gad96af157e5acb8f40a63e6a258e87029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa720a7c2c7002fef93efe749fbfc815a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gaa720a7c2c7002fef93efe749fbfc815a">NAND_hasRandomWrite</a> (Uint32 nandOptions, Uint16 *RWstatus)</td></tr>
<tr class="separator:gaa720a7c2c7002fef93efe749fbfc815a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0720755a1b674bb0c77f85fbeafd836"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gad0720755a1b674bb0c77f85fbeafd836">NAND_hasCacheProg</a> (Uint32 nandOptions, Uint16 *CPstatus)</td></tr>
<tr class="separator:gad0720755a1b674bb0c77f85fbeafd836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab566f0408b6e4f1c72a74d6117f16cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gaab566f0408b6e4f1c72a74d6117f16cd">NAND_hasCopyBack</a> (Uint32 nandOptions, Uint16 *CBstatus)</td></tr>
<tr class="separator:gaab566f0408b6e4f1c72a74d6117f16cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f02e8fd205acc2c4d8f24ae579c6c4"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga48f02e8fd205acc2c4d8f24ae579c6c4">EMIF_intrEnable</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif)</td></tr>
<tr class="separator:ga48f02e8fd205acc2c4d8f24ae579c6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae39bf5d15450d761c3625683025b44d1"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gae39bf5d15450d761c3625683025b44d1">EMIF_intrDisable</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif)</td></tr>
<tr class="separator:gae39bf5d15450d761c3625683025b44d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc597c59fac309fc6a865019988cf89"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga4bc597c59fac309fc6a865019988cf89">EMIF_intrReadAT</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint16 *ATstatus)</td></tr>
<tr class="separator:ga4bc597c59fac309fc6a865019988cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae079040c7222fef409d2c4af08d4fcae"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gae079040c7222fef409d2c4af08d4fcae">EMIF_intrReadLT</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint16 *LTstatus)</td></tr>
<tr class="separator:gae079040c7222fef409d2c4af08d4fcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4a23cdcee94e3693997400d27bd21f4"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gab4a23cdcee94e3693997400d27bd21f4">EMIF_intrReadWR</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif, Uint16 *WRstatus)</td></tr>
<tr class="separator:gab4a23cdcee94e3693997400d27bd21f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e32bd1ec486e835f18fdd05c891e516"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#ga0e32bd1ec486e835f18fdd05c891e516">EMIF_intrClear</a> (<a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a> hEmif)</td></tr>
<tr class="separator:ga0e32bd1ec486e835f18fdd05c891e516"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4d1faa0486fd7b1057139665135a99b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status EMIF_asyncConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___async_config.html">CSL_AsyncConfig</a> *&#160;</td>
          <td class="paramname"><em>asyncConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>EMIF_asyncConfig</b> </p>
<p><b>Description</b> <br />
 This API configures the asynchronous memory hardware registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        emifConfig    Emif configuration structure</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Asynchronous configuration is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid config structure</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init should be called successfully</p>
<p><b> Post Condition </b> <br />
 Configures asynchronous registers</p>
<p><b>Modifies</b> <br />
 emif registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj            emifObj;
        CSL_Status             status;
        CSL_EmifConfig         emifCfg;
        CSL_EmifHandle         hEmif;
        CSL_EmifAsyncWaitCfg   asyncWaitConfig;
        CSL_EmifAsyncCfg       asyncConfig;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ...
        emifCfg.emifWidth = CSL_EMIF_8_BIT;
        ...
        ...
        emifCfg.asyncWaitCfg = &amp;asyncWaitConfig;
        emifCfg.asyncCfg     = &amp;asyncConfig;
        status = EMIF_asyncConfig(hEmif, &amp;emifCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab175d3a1c935db9acb6421a23745212c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status EMIF_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___emif_obj.html">CSL_EmifObj</a> *&#160;</td>
          <td class="paramname"><em>emifObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>EMIF_init</b> </p>
<p><b>Description</b> <br />
 This is the initialization function for the emif CSL. It populates emif object structure information. This API should be called before calling any other emif CSL APIs.</p>
<p><b>Arguments</b> </p><pre class="fragment">        emifObj       Pointer to emif object structure</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand init is successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 EMIF object structure is populated</p>
<p><b>Modifies</b> <br />
 EMIF object structure</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj    emifObj;
        CSL_Status     status;

        status = EMIF_init(&amp;emifObj);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0e32bd1ec486e835f18fdd05c891e516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status EMIF_intrClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>EMIF_intrClear</b> </p>
<p><b>Description</b> <br />
 Clears a emif interrupt</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif        Handle to the emif object</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 EMIF_intrEnable should be called successfully</p>
<p><b> Post Condition </b> <br />
 Clears emif interrupt</p>
<p><b>Modifies</b> <br />
 Emif interrupt mask register</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj    emifObj;
        CSL_Status     status;
        CSL_EmifHandle hEmif;
        Uint16         WRstatus;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = EMIF_intrEnable(hEmif);
        ...
        ...
        status = EMIF_intrClear(hEmif);</pre><hr/>
<p>============================================================================ <br />
<b>EMIF_intrClear</b> </p>
<p><b>Description</b> <br />
 Clears a emif interrupt</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif        Handle to the emif object</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 EMIF_intrEnable should be called successfully</p>
<p><b> Post Condition </b> <br />
 Clears emif interrupt</p>
<p><b>Modifies</b> <br />
 Emif interrupt mask register</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        CSL_Status     status;
        CSL_EmifHandle hEmif;
        Uint16         WRstatus;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = EMIF_intrEnable(hEmif);
        ...
        ...
        status = EMIF_intrClear(hEmif);</pre><hr/>
 <p>Clear Wait rise interrupt</p>
<p>Clear line trap interrupt</p>
<p>Clear asyncronous time-out interrupt </p>

</div>
</div>
<a class="anchor" id="gae39bf5d15450d761c3625683025b44d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status EMIF_intrDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>EMIF_intrDisable</b> </p>
<p><b>Description</b> <br />
 This API is used to disable emif interrupts.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif        Handle to the emif object</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - emif interrupt disable is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 EMIF_intrEnable should be called successfully</p>
<p><b> Post Condition </b> <br />
 Disables emif interrupts</p>
<p><b>Modifies</b> <br />
 Emif interrupt registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        CSL_Status     status;
        CSL_EmifHandle hEmif;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = EMIF_intrEnable(hEmif);
        ...
        ...
        status = EMIF_intrDisable(hEmif);</pre><hr/>
 <p>Disable Wait rise interrupt</p>
<p>Disable line trap interrupt</p>
<p>Disable asyncronous time-out interrupt </p>

</div>
</div>
<a class="anchor" id="ga48f02e8fd205acc2c4d8f24ae579c6c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status EMIF_intrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>EMIF_intrEnable</b> </p>
<p><b>Description</b> <br />
 This API enables emif interrupts. This API is used in interrupt mode of operation of the device.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif        Handle to the emif object</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Emif interrupt enable is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 EMIF_init should be called successfully</p>
<p><b> Post Condition </b> <br />
 Enables emif interrupts</p>
<p><b>Modifies</b> <br />
 Emif interrupt registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        CSL_Status     status;
        CSL_EmifHandle hEmif;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = EMIF_intrEnable(hEmif);</pre><hr/>
 <p>Enable Wait rise interrupt</p>
<p>Enable line trap interrupt</p>
<p>Enable asyncronous time-out interrupt </p>

</div>
</div>
<a class="anchor" id="ga4bc597c59fac309fc6a865019988cf89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status EMIF_intrReadAT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>ATstatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>EMIF_intrReadAT</b> </p>
<p><b>Description</b> <br />
 Reads Asynchronous time-out bit of emif interrupt raw register</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif        Handle to the emif object
        ATstatus     Asynchronous time-out status variable</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 EMIF_intrEnable should be called successfully</p>
<p><b> Post Condition </b> <br />
 Emif asynchronous time-out bit status is returned in status variable</p>
<p><b>Modifies</b> <br />
 Asynchronous time-out status variable</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        CSL_Status     status;
        CSL_EmifHandle hEmif;
        Uint16         ATstatus;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = EMIF_intrEnable(hEmif);
        ...
        ...
        status = EMIF_intrReadAT(hEmif,&amp;ATstatus);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae079040c7222fef409d2c4af08d4fcae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status EMIF_intrReadLT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>LTstatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>EMIF_intrReadLT</b> </p>
<p><b>Description</b> <br />
 Reads Line-trap bit of emif interrupt raw register</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif        Handle to the emif object
        LTstatus     Line trap status variable</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 EMIF_intrEnable should be called successfully</p>
<p><b> Post Condition </b> <br />
 Emif line trap bit status is returned in status variable</p>
<p><b>Modifies</b> <br />
 Line trap status variable</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        CSL_Status     status;
        CSL_EmifHandle hEmif;
        Uint16         LTstatus;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = EMIF_intrEnable(hEmif);
        ...
        ...
        status = EMIF_intrReadLT(hEmif,&amp;LTstatus);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab4a23cdcee94e3693997400d27bd21f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status EMIF_intrReadWR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>WRstatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>EMIF_intrReadWR</b> </p>
<p><b>Description</b> <br />
 Reads wait-rise bit of emif interrupt raw register</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif        Handle to the emif object
        WRstatus     Wait-raise status variable</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 EMIF_intrEnable should be called successfully</p>
<p><b> Post Condition </b> <br />
 Emif wait-rise bit status is returned in status variable</p>
<p><b>Modifies</b> <br />
 Wait-rise status variable</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        CSL_Status     status;
        CSL_EmifHandle hEmif;
        Uint16         WRstatus;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = EMIF_intrEnable(hEmif);
        ...
        ...
        status = EMIF_intrReadWR(hEmif,&amp;WRstatus);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga51b3a1fe44389de119c4748b484edd70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_checkCommandStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_checkCommandStatus</b> </p>
<p><b>Description</b> <br />
 This API checks the status of any command to the nand device. This API must be called after sending any command to the nand device.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif    Handle to the emif object</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand status check is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_NAND_E_TIMEOUT - Time-out has occured</li>
</ul>
<p><b> Pre Condition </b> <br />
 NAND_sendCommand API should be called successfully</p>
<p><b> Post Condition </b> <br />
 Returns time-out condition(If occurs)</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifHandle    hEmif;
        CSL_Status        status;

        status = NAND_sendCommand(hEmif, CSL_NAND_CMD_READ_START);

        if(status == CSL_SOK)
        {
            status = NAND_checkCommandStatus(hEmif);
        }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga63fcf36fc202f72ae533f8f46108a100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_disableHwECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___e_n_u_m.html#gaac3e77e693cf982963090786caae64b0">CSL_EmifChipSelect</a>&#160;</td>
          <td class="paramname"><em>csInput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_disableHwECC</b> </p>
<p><b>Description</b> <br />
 This API disables hardware ECC of the nand device.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif      Handle to the emif object
        csInput    Nand chip selection input</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand disable HW ECC is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 NAND_enableHwECC API should be called successfully</p>
<p><b> Post Condition </b> <br />
 Disables nand hardware error check and correction</p>
<p><b>Modifies</b> <br />
 Nand ECC registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_Status          status;
        CSL_EmifHandle      hEmif;
        CSL_EmifChipSelect  csInput;

        csInput = CSL_NAND_CE0;

        status = NAND_enableHwECC(hEmif, csInput);
        ...
        ...
        status = NAND_disableHwECC(hEmif, csInput);</pre><hr/>
<p>============================================================================ <br />
<b>NAND_disableHwECC</b> </p>
<p><b>Description</b> <br />
 This API disables hardware ECC of the nand device.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif      Handle to the emif object
        csInput    Nand chip selection input</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand disable HW ECC is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 NAND_enableHwECC API should be called successfully</p>
<p><b> Post Condition </b> <br />
 Disables nand hardware error check and correction</p>
<p><b>Modifies</b> <br />
 Nand ECC registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_Status          status;
        CSL_EmifHandle      hEmif;
        CSL_EMifChipSelect  csInput;

        csInput = CSL_NAND_CE0;

        status = NAND_enableHwECC(hEmif, csInput);
        ...
        ...
        status = NAND_disableHwECC(hEmif, csInput);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0075d2cf3330714e999cf21fc58ba5a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_enableHwECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___e_n_u_m.html#gaac3e77e693cf982963090786caae64b0">CSL_EmifChipSelect</a>&#160;</td>
          <td class="paramname"><em>csInput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_enableHwECC</b> </p>
<p><b>Description</b> <br />
 This API enables hardware ECC(Error Check and  Correction) of the nand device. ECC is used to check and correct errors occurred during nand data transfer.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif      Handle to the emif object
        csInput    Nand chip selection input</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand enable HW ECC is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 Nand init should be called successfully</p>
<p><b> Post Condition </b> <br />
 Enables nand hardware error check and correction</p>
<p><b>Modifies</b> <br />
 Nand ECC registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj         emifObj;
        CSL_Status          status;
        CSL_EmifHandle      hEmif;
        CSL_EmifChipSelect  csInput;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        csInput = CSL_NAND_CE0;
        status = NAND_enableHwECC(hEmif,csInput);</pre><hr/>
<p>============================================================================ <br />
<b>NAND_enableHwECC</b> </p>
<p><b>Description</b> <br />
 This API enables hardware ECC(Error Check and  Correction) of the nand device. ECC is used to check and correct errors occurred during nand data transfer.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif      Handle to the emif object
        csInput    Nand chip selection input</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand enable HW ECC is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 Nand init should be called successfully</p>
<p><b> Post Condition </b> <br />
 Enables nand hardware error check and correction</p>
<p><b>Modifies</b> <br />
 Nand ECC registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj         emifObj;
        CSL_Status          status;
        CSL_EmifHandle      hEmif;
        CSL_EMifChipSelect  csInput;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        csInput = CSL_NAND_CE0;
        status = NAND_enableHwECC(hEmif,csInput);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab12e2384ee8c06a0357ee6f57e1896cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_getBankInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___nand_async_bank.html">CSL_NandAsyncBank</a> *&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>bankNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_getBankInfo</b> </p>
<p><b>Description</b> <br />
 This API gives the bank details of the nand device. This API populates the base and offset address locations for the NAND flash based on the bank number passed as the parameter. Bank number should be decide based on the EMIF chip select connected to NAND flash as shown below. CSL_NAND_BANK_0 - EMIF_CS2 CSL_NAND_BANK_1 - EMIF_CS3 CSL_NAND_BANK_2 - EMIF_CS4 CSL_NAND_BANK_3 - EMIF_CS5</p>
<p>NOTE: This API sets ALE and CLE address offset to default values assuming A11 address bit is connected to ALE signal of NAND flash and A12 address bit is connected to CLE signal of NAND flash. Use <a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gaeaa5c8114ce58f2e53bb64c1cda769a5">NAND_setLatchEnableOffset()</a> to change the default offset values.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif      Handle to the emif object
        bank       Pointer to nand bank info structure
        bankNum    Nand bank number</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand get bank info is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 Nand init should be called successfully</p>
<p><b> Post Condition </b> <br />
 Populates nand bank info structure</p>
<p><b>Modifies</b> <br />
 Nand bank info structure</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        Uint16         bankNum;
        CSL_Status     status;
        CSL_EmifHandle hEmif;

        bankNum = 0;
        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = NAND_getBankInfo(hEmif, (CSL_NandAsyncBank*)&amp;hEmif-&gt;bank, bankNum);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad0720755a1b674bb0c77f85fbeafd836"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NAND_hasCacheProg </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>nandOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>CPstatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_hasCacheProg</b> </p>
<p><b>Description</b> <br />
 This API checks whether a nand device supports cache programming feature or not.</p>
<p><b>Arguments</b> </p><pre class="fragment">        nandOptions    Extra commands for big block nand
        CPstatus       Cache program status pointer</pre><p><b> Return Value </b> None <br />
 <b> Pre Condition </b> <br />
 nandOptions information needs to be computed from nand device Id</p>
<p><b> Post Condition </b> <br />
 Cache program status is returned in status variable </p><ul>
<li>TRUE - NAND device is having cache programming </li>
<li>FALSE - NAND device is not having cache programming</li>
</ul>
<p><b>Modifies</b> <br />
 Cache program status variable</p>
<p><b>Example</b> </p><pre class="fragment">         Uint32    nandOptions;
         Uint16    CPstatus;

         //get the nandOptions information from nand device Id
         NAND_hasCacheProg(nandOptions, &amp;CPstatus);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaab566f0408b6e4f1c72a74d6117f16cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NAND_hasCopyBack </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>nandOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>CBstatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_hasCopyBack</b> </p>
<p><b>Description</b> <br />
 This API checks whether a nand device supports copy back feature or not.</p>
<p><b>Arguments</b> </p><pre class="fragment">        nandOptions    Extra commands for big block nand
        CBstatus       Copy back status pointer</pre><p><b> Return Value </b> None <br />
 <b> Pre Condition </b> <br />
 nandOptions information needs to be computed from nand device Id</p>
<p><b> Post Condition </b> <br />
 Copy back status is returned in status variable </p><ul>
<li>TRUE - NAND device support copy back feature </li>
<li>FALSE - NAND device does not support copy back feature</li>
</ul>
<p><b>Modifies</b> <br />
 Copy back status variable</p>
<p><b>Example</b> </p><pre class="fragment">        Uint32    nandOptions;
        Uint16    CBstatus;

        //get the nandOptions information from nand device Id
        NAND_hasCopyBack(nandOptions, &amp;CBstatus);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad96af157e5acb8f40a63e6a258e87029"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NAND_hasRandomRead </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>nandOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>RRstatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_hasRandomRead</b> </p>
<p><b>Description</b> <br />
 This API is used to check whether a nand device is having random page read or not. If nand is having random read we can set pointer to any address in the page and retrieve the data from there.</p>
<p><b>Arguments</b> </p><pre class="fragment">        nandOptions    Extra commands for big block nand
        RRstatus       Random read status pointer</pre><p><b> Return Value </b> None <br />
 <b> Pre Condition </b> <br />
 nandOptions information needs to be computed from nand device Id</p>
<p><b> Post Condition </b> <br />
 Random read status is returned in status variable </p><ul>
<li>TRUE - NAND device is having random read </li>
<li>FALSE - NAND device is not having random read</li>
</ul>
<p><b>Modifies</b> <br />
 Random read status variable</p>
<p><b>Example</b> </p><pre class="fragment">         Uint32    nandOptions;
         Uint16    RRstatus;

         //get the nandOptions information from nand device Id
         NAND_hasRandomRead(nandOptions, &amp;RRstatus);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa720a7c2c7002fef93efe749fbfc815a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NAND_hasRandomWrite </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>nandOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>RWstatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_hasRandomWrite</b> </p>
<p><b>Description</b> <br />
 This API is used to check whether a nand device is having random page write or not. If nand is having random write we can set pointer to any address in the page and write the data from there.</p>
<p><b>Arguments</b> </p><pre class="fragment">        nandOptions    Extra commands for big block nand
        RWstatus       Random write status pointer</pre><p><b> Return Value </b> None <br />
 <b> Pre Condition </b> <br />
 nandOptions information needs to be computed from nand device Id</p>
<p><b> Post Condition </b> <br />
 Random write status is returned in status variable </p><ul>
<li>TRUE - NAND device is having random write </li>
<li>FALSE - NAND device is not having random write</li>
</ul>
<p><b>Modifies</b> <br />
 Random write status variable</p>
<p><b>Example</b> </p><pre class="fragment">         Uint32    nandOptions;
         Uint16    RWstatus;

         //get the nandOptions information from nand device Id
         NAND_hasRandomWrite(nandOptions, &amp;RWstatus);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6bed9d7e3731bcfec042b49921441e2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_isStatusWriteProtected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>WPstatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_isStatusWriteProtected</b> </p>
<p><b>Description</b> <br />
 This is the API used to check if the nand device is write protected. It is not possible write any data to nand if it is write-protected. So this API must be called before calling the write API to check the nand status.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        WPstatus      Write protect status pointer</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 EMIF_init and NAND_getBankInfo should be called successfully</p>
<p><b> Post Condition </b> <br />
 Write protect status is returned in status variable </p><ul>
<li>TRUE - NAND device is write protected </li>
<li>FALSE - NAND device is not write protected</li>
</ul>
<p><b>Modifies</b> <br />
 Write protect status variable</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        Uint16         bankNum;
        CSL_Status     status;
        CSL_EmifHandle hEmif;
        Uint16         wpstatus;

        bankNum = 0;
        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = NAND_getBankInfo(hEmif, (CSL_NandAsyncBank*)&amp;hEmif-&gt;bank, bankNum);
         ....
         ....
        status = NAND_isStatusWriteProtected(hEmif,&amp;wpstatus);</pre><hr/>
<p>============================================================================ <br />
<b>NAND_isStatusWriteProtected</b> </p>
<p><b>Description</b> <br />
 This is the API used to check if the nand device is write protected. It is not possible write any data to nand if it is write-protected. So this API must be called before calling the write API to check the nand status.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        WPstatus      Write protect status pointer</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Retutned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 EMIF_init and NAND_getBankInfo should be called successfully</p>
<p><b> Post Condition </b> <br />
 Write protect status is returned in status variable </p><ul>
<li>TRUE - NAND device is write protected </li>
<li>FALSE - NAND device is not write protected</li>
</ul>
<p><b>Modifies</b> <br />
 Write protect status variable</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        Uint16         bankNum;
        CSL_Status     status;
        CSL_EmifHandle hEmif;
                Uint16         wpstatus;

        bankNum = 0;
        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = NAND_getBankInfo(hEmif, (CSL_NandAsyncBank*)&amp;hEmif-&gt;bank, bankNum);
        ....
        ....
        status = NAND_isStatusWriteProtected(hEmif,&amp;wpstatus);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae04a3c8205fbdbf94e5cb7cc9df4a699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_readECC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>eccBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___e_n_u_m.html#gaac3e77e693cf982963090786caae64b0">CSL_EmifChipSelect</a>&#160;</td>
          <td class="paramname"><em>csInput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_readECC</b> </p>
<p><b>Description</b> <br />
 This API is used to read the information generated by ECC hardware. Hardware ECC must be enabled before calling this API.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif        Handle to the emif object
        eccBuffer    ECC Buffer pointer
        csInput      Chip select used for calculating Ecc</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand read is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 NAND_enableHwECC API should be called successfully</p>
<p><b> Post Condition </b> <br />
 Populates ECC data into eccBuffer</p>
<p><b>Modifies</b> <br />
 eccBuffer</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_Status           status;
        CSL_EmifHandle       hEmif;
        Uint16               eccBuffer[8];
        CSL_EmifChipSelect   csInput;

        csInput = CSL_NAND_CE0;

        status = NAND_enableHwECC(hEmif, csInput);
        ...
        ...
        status = NAND_readECC(hEmif, eccBuffer, csInput);</pre><hr/>
<p>============================================================================ <br />
<b>NAND_readECC</b> </p>
<p><b>Description</b> <br />
 This API is used to read the information generated by ECC hardware. Hardware ECC must be enabled before calling this API.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif        Handle to the emif object
        eccBuffer    ECC Buffer pointer
        csInput      Chip select used for calculating Ecc</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand read is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 NAND_enableHwECC API should be called successfully</p>
<p><b> Post Condition </b> <br />
 Populates ECC data into eccBuffer</p>
<p><b>Modifies</b> <br />
 eccBuffer</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_Status           status;
        CSL_EmifHandle       hEmif;
        Uint16               eccBuffer[8];
        CSL_EMifChipSelect   csInput;

        csInput = CSL_NAND_CE0;

        status = NAND_enableHwECC(hEmif, csInput);
        ...
        ...
        status = NAND_readECC(hEmif, eccBuffer, csInput);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3308edb55df7d3725b38fd6208a1ee6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_readNBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>readRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pReadBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>pack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>spare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_readNBytes</b> </p>
<p><b>Description</b> <br />
 This API reads N number of bytes from a nand physical page. Number of bytes to be read is sent as an argument to this API. A read command should be sent and nand page address should be set before calling this API.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif          Handle to the emif object
        readRequest    Number of bytes to read
        pReadBuffer    Read buffer pointer
        pack           Data pack flag
        spare          Spare area flag</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand read is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 NAND_sendCommand and NAND_setAddress APIs should be called successfully</p>
<p><b> Post Condition </b> <br />
 Reads the data from nand</p>
<p><b>Modifies</b> <br />
 Copies data from nand to read buffer</p>
<p><b>Example</b> </p><pre class="fragment">        #define  NAND_BUF_SIZE      (1024)

        CSL_Status     status;
        CSL_EmifHandle hEmif;
        Uint32         address;
        Uint16         nandReadBuf[NAND_BUF_SIZE];

        address = 0x40;
        status = NAND_sendCommand(hEmif,CSL_NAND_CMD_READ_START);

        // Set column address
        status = NAND_setAddress(hEmif,0x00);
        status = NAND_setAddress(hEmif,0x00);
        // Set row address
        status = NAND_setAddress(hEmif,0x40);
        status = NAND_setAddress(hEmif,0x00);
        status = NAND_setAddress(hEmif,0x00);
        ....
        ....
        status = NAND_readNBytes(hEmif,NAND_BUF_SIZE,nandreadBuf,0,0);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5db08651a72079eb2da4bfd9be027f34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_sendCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_VUint16&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_sendCommand</b> </p>
<p><b>Description</b> <br />
 Any command to the nand device should be sent through this API. nand device is having specific commands for each operation.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif          Handle to the emif object
        cmd            Command to the nand device</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand send command is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 EMIF_init and NAND_getBankInfo should be called successfully</p>
<p><b> Post Condition </b> <br />
 Sends command to the nand device</p>
<p><b>Modifies</b> <br />
 Writes command to the command latch address</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        Uint16         bankNum;
        CSL_Status     status;
        CSL_EmifHandle hEmif;

        bankNum = 0;
        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = NAND_getBankInfo(hEmif, (CSL_NandAsyncBank*)&amp;hEmif-&gt;bank, bankNum);
        ....
        ....
        status = NAND_sendCommand(hEmif,CSL_NAND_CMD_READ_START);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabfb2bef7ffb838f28fa1a6f1106fdc7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_setAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_setAddress</b> </p>
<p><b>Description</b> <br />
 This API used to set address of nand page to read/write data from/to nand device. Page address must be set to a valid nand page before calling read/write APIs.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif          Handle to the emif object
        addr           Addres value to set</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand set address is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br />
 EMIF_init and NAND_getBankInfo should be called successfully</p>
<p><b> Post Condition </b> <br />
 Sets nand address</p>
<p><b>Modifies</b> <br />
 Writes address to the address latch</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        Uint16         bankNum;
        CSL_Status     status;
        CSL_EmifHandle hEmif;

        bankNum = 0;
        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = NAND_getBankInfo(hEmif, (CSL_NandAsyncBank*)&amp;hEmif-&gt;bank, bankNum);
        ....
        ....
        status = NAND_setAddress(hEmif,0x01);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaeaa5c8114ce58f2e53bb64c1cda769a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_setLatchEnableOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>addrOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>cmdOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_setLatchEnableOffset</b> </p>
<p><b>Description</b> <br />
 This API sets the CLE and ALE address offset. Any of the EMIF address lines can be used to drive ALE and CLE of the NAND flash. ALE and CLE address offset are decided based of the address lines used to drive ALE and CLE pins. This API should be called after calling <a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gab12e2384ee8c06a0357ee6f57e1896cd">NAND_getBankInfo()</a> API to modify the ALE and CLE address from the default value.</p>
<p>NOTE: Addresses passed should be offset values from the base address. For example assume that EMIF A11 line is used to drive ALE pin and EMIF A12 line is used to driver CLE pin. Then the address offset for ALE will be 0x1000 and address offset for CLE will be 0x2000.</p>
<p>Calling this API is mandatory in case of NAND ALE and CLE connected to pins other than A11 and A12 respectively. Otherwise NAND CSL APIs will not function properly.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        addrOffset    ALE offset location
        cmdOffset     CLE offset location</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Set address offset is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 Nand init should be called successfully <br />
 <a class="el" href="group___c_s_l___e_m_i_f___f_u_n_c_t_i_o_n.html#gab12e2384ee8c06a0357ee6f57e1896cd">NAND_getBankInfo()</a> should be called successfully</p>
<p><b> Post Condition </b> <br />
 Sets the ALE and CLE address offset</p>
<p><b>Modifies</b> <br />
 NAND handle</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj    emifObj;
        Uint16         bankNum;
        CSL_Status     status;
        CSL_EmifHandle hEmif;

        bankNum = 0;
        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ....
        ....
        status = NAND_getBankInfo(hEmif, (CSL_NandAsyncBank*)&amp;hEmif-&gt;bank, bankNum);
        status = NAND_setLatchEnableOffset(hEmif, 0x2000, 0x4000);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6279a79856fd337fb52ea01f4b2d2ab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___nand_config.html">CSL_NandConfig</a> *&#160;</td>
          <td class="paramname"><em>nandConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_setup</b> </p>
<p><b>Description</b> <br />
 This API configures the nand hardware registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        nandConfig    Nand configuration structure</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand setup is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid config structure</li>
</ul>
<p><b> Pre Condition </b> <br />
 Nand init should be called successfully</p>
<p><b> Post Condition </b> <br />
 Configures nand registers</p>
<p><b>Modifies</b> <br />
 nand registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_emifObj            emifObj;
        CSL_Status             status;
        CSL_NandConfig         nandCfg;
        CSL_EmifHandle         hEmif;
        CSL_NandAsyncWaitCfg   asyncWaitConfig;
        CSL_NandAsyncCfg       asyncConfig;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ...
        nandCfg.nandWidth = CSL_EMIF_8_BIT;
        ...
        ...
        nandCfg.asyncWaitCfg = &amp;asyncWaitConfig;
        nandCfg.asyncCfg     = &amp;asyncConfig;
        status = NAND_setup(hEmif, &amp;nandCfg);</pre><hr/>
<p>============================================================================ <br />
<b>NAND_setup</b> </p>
<p><b>Description</b> <br />
 This API configures the EMIF hardware registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        nandConfig    Emif configuration structure</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand setup is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid config structure</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init should be called successfully</p>
<p><b> Post Condition </b> <br />
 Configures emif registers</p>
<p><b>Modifies</b> <br />
 emif registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj            emifObj;
        CSL_Status             status;
        CSL_EmifConfig         emifCfg;
        CSL_EmifHandle         hEmif;
        CSL_EmifAsyncWaitCfg   asyncWaitConfig;
        CSL_EmifAsyncCfg       asyncConfig;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ...
        emifCfg.emifWidth = CSL_NAND_8_BIT;
        ...
        ...
        emifCfg.asyncWaitCfg = &amp;asyncWaitConfig;
        emifCfg.asyncCfg     = &amp;asyncConfig;
        status = EMIF_setup(hEmif, &amp;nandCfg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga862646cc59c43ac211ac6844e59d82cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NAND_writeNBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>writeRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pWriteBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>spare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NAND_writeNBytes</b> </p>
<p><b>Description</b> <br />
 This API writes N number of bytes to a nand physical page. Number of bytes to be written is sent as an argument to this API. A page program command should be sent and nand page address should be set before calling this API. nand device should not be write-protected for proper functioning of this API.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif          Handle to the emif object
        writeRequest   Number of bytes to write
        pWriteBuffer   Write buffer pointer
        val            If a value needs to be wriiten directly without
                       using write buffer
        spare          Spare area flag</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand write is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 NAND_sendCommand and NAND_setAddress APIs should be called successfully</p>
<p><b> Post Condition </b> <br />
 Writes the data to nand</p>
<p><b>Modifies</b> <br />
 Nand write registers</p>
<p><b>Example</b> </p><pre class="fragment">        #define  NAND_BUF_SIZE      (1024)

        CSL_Status     status;
        CSL_EmifHandle hEmif;
        Uint32         address;
        Uint16         nandWriteBuf[NAND_BUF_SIZE];

        address = 0x40;
        status = NAND_sendCommand(hEmif,CSL_NAND_CMD_READ_START);
        // Set column address
        status = NAND_setAddress(hEmif,0x00);
        status = NAND_setAddress(hEmif,0x00);

        // Set row address
        status = NAND_setAddress(hEmif,0x40);
        status = NAND_setAddress(hEmif,0x00);
        status = NAND_setAddress(hEmif,0x00);
        ....
        ....
        status = NAND_writeNBytes(hEmif,NAND_BUF_SIZE,nandWriteBuf,0,0);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4544371d51e382c0f056db9c7df01c69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NOR_checkStatus </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>timeOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NOR_checkStatus</b> </p>
<p><b>Description</b> <br />
 This API checks the status of Erase/Program command to the NOR device. This API must be called after sending the command to the NOR device.</p>
<p><b>Arguments</b> </p><pre class="fragment">        timeOut    Timeout count for the particular command</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - NOR status check is successful </li>
<li>CSL_ESYS_FAIL - Time-out or any errors has occured</li>
</ul>
<p><b> Pre Condition </b> <br />
 Erase or Write commands are be called successfully</p>
<p><b> Post Condition </b> <br />
 Returns time-out condition(If occurs)</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifHandle    hEmif;
        CSL_Status        status;
        . . .
        . . .
        status = NOR_checkStatus(timeOut);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadda10f098d22987601e618252bd6365d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NOR_readNwords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>numWords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>norAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>dataBuff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NOR_readNwords</b> </p>
<p><b>Description</b> <br />
 This API reads numWords from NOR flash.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        numWords      Number of words to be read
        sdramAddr     NOR address to start the read operation
        dataBuff      Data buffer to copy data read from NOR</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - NOR read is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and Asynchronous configurations should be called successfully</p>
<p><b> Post Condition </b> <br />
 Reads from NOR flash</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj            emifObj;
        CSL_Status             status;
        CSL_EmifConfig         emifCfg;
        CSL_EmifHandle         hEmif;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        status = EMIF_asyncConfig(hEmif, &amp;sdramConfig, &amp;sdramTimr);
        ...
        ...
        ...
        status = NOR_readNwords(hEmif, numWords, norAddr, &amp;dataBuff);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac7692ac0633d35285d004301e6faf5f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NOR_sendCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>norAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NOR_sendCommand</b> </p>
<p><b>Description</b> <br />
 This API sends command to NOR flash.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        norAddr       NOR address to start the write operation
        command       Command to be sent to the NOR flash</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - NOR command sent successfully </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameters</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and Asynchronous configurations should be called successfully</p>
<p><b> Post Condition </b> <br />
 Sends command to NOR flash</p>
<p><b>Modifies</b> <br />
 Writes command to the NOR flash</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj            emifObj;
        CSL_Status             status;
        CSL_EmifConfig         emifCfg;
        CSL_EmifHandle         hEmif;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        status = EMIF_asyncConfig(hEmif, &amp;sdramConfig, &amp;sdramTimr);
        ...
        ...
        ...
        status = NOR_sendCommand(hEmif, norAddr, command);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5c938f6de590312c0b8a94cdcfef16bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status NOR_WriteNwords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>numWords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>norAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>dataBuff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>NOR_WriteNwords</b> </p>
<p><b>Description</b> <br />
 This API writes numWords to NOR flash.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hemif         Handle to the emif object
        numWords      Number of words to be written
        norAddr       NOR address to start the write operation
        dataBuff      Data to be written to NOR</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - NOR write is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid config structure</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and Asynchronous configurations should be called successfully</p>
<p><b> Post Condition </b> <br />
 Writes into NOR memory</p>
<p><b>Modifies</b> <br />
 NOR memory content</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj            emifObj;
        CSL_Status             status;
        CSL_EmifConfig         emifCfg;
        CSL_EmifHandle         hEmif;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        status = EMIF_asyncConfig(hEmif, &amp;sdramConfig, &amp;sdramTimr);
        ...
        ...
        ...
        status = NOR_WriteNwords(hEmif, numWords, norAddr, &amp;dataBuff);</pre><hr/>
<p>============================================================================ <br />
<b>NOR_WriteNwords</b> </p>
<p><b>Description</b> <br />
 This API writes numWords to NOR flash.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        numWords      Number of words to be written
        norAddr       NOR address to start the write operation
        dataBuff      Data to be written to NOR</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - NOR write is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid config structure</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and Asynchronous configurations should be called successfully</p>
<p><b> Post Condition </b> <br />
 Writes into NOR memory</p>
<p><b>Modifies</b> <br />
 NOR memory content</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj            emifObj;
        CSL_Status             status;
        CSL_EmifConfig         emifCfg;
        CSL_EmifHandle         hEmif;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        status = EMIF_asyncConfig(hEmif, &amp;sdramConfig, &amp;sdramTimr);
        ...
        ...
        ...
        status = NOR_WriteNwords(hEmif, numWords, norAddr, &amp;dataBuff);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga01ce4fbff03516bcae9c65967f4df62f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDRAM_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___sdram_cfg.html">CSL_SdramCfg</a> *&#160;</td>
          <td class="paramname"><em>sdramConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___sdram_timr.html">CSL_SdramTimr</a> *&#160;</td>
          <td class="paramname"><em>sdramTimr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>SDRAM_config</b> </p>
<p><b>Description</b> <br />
 This API configures the sdram hardware registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hemif         Handle to the emif object
        sdramConfig   SDRAM configuration structure
        sdramTimr     SDRAM timer configuration structure</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - SDRAM configurations are successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid config structure</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init should be called successfully</p>
<p><b> Post Condition </b> <br />
 Configures sdram registers</p>
<p><b>Modifies</b> <br />
 sdram registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj            emifObj;
        CSL_Status             status;
        CSL_EmifConfig         emifCfg;
        CSL_EmifHandle         hEmif;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ...
        ...
        ...
        status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);</pre><hr/>
<p>============================================================================ <br />
<b>SDRAM_config</b> </p>
<p><b>Description</b> <br />
 This API configures the sdram hardware registers.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        sdramConfig   SDRAM configuration structure
        sdramTimr     SDRAM timer configuration structure</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - Nand setup is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid config structure</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init should be called successfully</p>
<p><b> Post Condition </b> <br />
 Configures sdram registers</p>
<p><b>Modifies</b> <br />
 sdram registers</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj            emifObj;
        CSL_Status             status;
        CSL_EmifConfig         emifCfg;
        CSL_EmifHandle         hEmif;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        ...
        ...
        ...
        status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga049ed29453ced09ee9b8e8ad3c7ed49a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDRAM_disablePowerDownMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>SDRAM_disablePowerDownMode</b> </p>
<p><b>Description</b> <br />
 This API disables power dowm mode for SDRAM.</p>
<p><b>Arguments</b> </p><pre class="fragment">*          hemif         Handle to the emif object
*   </pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - SDRAM power down mode disabled successfully </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and SDRAM configurations and SDRAM must be in powerdown mode should be called successfully</p>
<p><b> Post Condition </b> <br />
 SDRAM is out of powerdown mode</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">           CSL_EmifObj            emifObj;
           CSL_Status             status;
           CSL_EmifConfig         emifCfg;
           CSL_EmifHandle         hEmif;

           status = EMIF_init(&amp;emifObj);
           hEmif  = &amp;emifObj;
           status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);
           ...
           ...
           ...
        status = SDRAM_enablePowerDownMode(hEmif);
        ...
        ...
           status = SDRAM_disablePowerDownMode(hEmif);</pre><hr/>
<p>============================================================================ <br />
<b>SDRAM_disablePowerDownMode</b> </p>
<p><b>Description</b> <br />
 This API disables power dowm mode for SDRAM.</p>
<p><b>Arguments</b> </p><pre class="fragment">*          hEmif         Handle to the emif object
*   </pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - SDRAM power down mode disabled successfully </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and SDRAM configurations and SDRAM must be in powerdown mode should be called successfully</p>
<p><b> Post Condition </b> <br />
 SDRAM is out of powerdown mode</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">           CSL_EmifObj            emifObj;
           CSL_Status             status;
           CSL_EmifConfig         emifCfg;
           CSL_EmifHandle         hEmif;

           status = EMIF_init(&amp;emifObj);
           hEmif  = &amp;emifObj;
           status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);
           ...
           ...
           ...
        status = SDRAM_enablePowerDownMode(hEmif);
        ...
        ...
           status = SDRAM_disablePowerDownMode(hEmif);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga36b8603dcfa7b140b5a2783617bc72b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDRAM_disableSelfRefreshMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>SDRAM_disableSelfRefreshMode</b> </p>
<p><b>Description</b> <br />
 This API disables self refresh mode for SDRAM.</p>
<p><b>Arguments</b> </p><pre class="fragment">*          hemif         Handle to the emif object
*   </pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - SDRAM self refresh mode disabled successfully </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and SDRAM configurations and should be called successfully SDRAM must be in self refresh mode</p>
<p><b> Post Condition </b> <br />
 SDRAM is out of self refresh mode</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">           CSL_EmifObj            emifObj;
           CSL_Status             status;
           CSL_EmifConfig         emifCfg;
           CSL_EmifHandle         hEmif;

           status = EMIF_init(&amp;emifObj);
           hEmif  = &amp;emifObj;
           status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);
           ...
           ...
           ...
        status = SDRAM_enableSelfRefreshMode(hEmif);
        ...
        ...
           status = SDRAM_disableSelfRefreshMode(hEmif);</pre><hr/>
<p>============================================================================ <br />
<b>SDRAM_disableSelfRefreshMode</b> </p>
<p><b>Description</b> <br />
 This API disables self refresh mode for SDRAM.</p>
<p><b>Arguments</b> </p><pre class="fragment">*          hEmif         Handle to the emif object
*   </pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - SDRAM self refresh mode disabled successfully </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and SDRAM configurations and should be called successfully SDRAM must be in self refresh mode</p>
<p><b> Post Condition </b> <br />
 SDRAM is out of self refresh mode</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">           CSL_EmifObj            emifObj;
           CSL_Status             status;
           CSL_EmifConfig         emifCfg;
           CSL_EmifHandle         hEmif;

           status = EMIF_init(&amp;emifObj);
           hEmif  = &amp;emifObj;
           status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);
           ...
           ...
           ...
        status = SDRAM_enableSelfRefreshMode(hEmif);
        ...
        ...
           status = SDRAM_disableSelfRefreshMode(hEmif);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9d0070128dc006f9eac84ded5ff4527e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDRAM_enablePowerDownMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>SDRAM_enablePowerDownMode</b> </p>
<p><b>Description</b> <br />
 This API enables power dowm mode for SDRAM.</p>
<p><b>Arguments</b> </p><pre class="fragment">*          hemif         Handle to the emif object
*   </pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - SDRAM power down mode set successfully </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and SDRAM configurations should be called successfully</p>
<p><b> Post Condition </b> <br />
 SDRAM is in powerdown mode</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">           CSL_EmifObj            emifObj;
           CSL_Status             status;
           CSL_EmifConfig         emifCfg;
           CSL_EmifHandle         hEmif;

           status = EMIF_init(&amp;emifObj);
           hEmif  = &amp;emifObj;
           status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);
           ...
           ...
           ...
        status = SDRAM_enablePowerDownMode(hEmif);</pre><hr/>
<p>============================================================================ <br />
<b>SDRAM_enablePowerDownMode</b> </p>
<p><b>Description</b> <br />
 This API enables power dowm mode for SDRAM.</p>
<p><b>Arguments</b> </p><pre class="fragment">*          hEmif         Handle to the emif object
*   </pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - SDRAM power down mode set successfully </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and SDRAM configurations should be called successfully</p>
<p><b> Post Condition </b> <br />
 SDRAM is in powerdown mode</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">           CSL_EmifObj            emifObj;
           CSL_Status             status;
           CSL_EmifConfig         emifCfg;
           CSL_EmifHandle         hEmif;

           status = EMIF_init(&amp;emifObj);
           hEmif  = &amp;emifObj;
           status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);
           ...
           ...
           ...
        status = SDRAM_enablePowerDownMode(hEmif);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0346aff2088eef7a6c71d307496adf4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDRAM_enableSelfRefreshMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>SDRAM_enableSelfRefreshMode</b> </p>
<p><b>Description</b> <br />
 This API enables self refresh mode for SDRAM.</p>
<p><b>Arguments</b> </p><pre class="fragment">*          hemif         Handle to the emif object
*   </pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - SDRAM self refresh mode enabled successfully </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and SDRAM configurations and should be called successfully</p>
<p><b> Post Condition </b> <br />
 SDRAM is in self refresh mode</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">           CSL_EmifObj            emifObj;
           CSL_Status             status;
           CSL_EmifConfig         emifCfg;
           CSL_EmifHandle         hEmif;

           status = EMIF_init(&amp;emifObj);
           hEmif  = &amp;emifObj;
           status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);
           ...
           ...
           ...
        status = SDRAM_enableSelfRefreshMode(hEmif);</pre><hr/>
<p>============================================================================ <br />
<b>SDRAM_enableSelfRefreshMode</b> </p>
<p><b>Description</b> <br />
 This API enables self refresh mode for SDRAM.</p>
<p><b>Arguments</b> </p><pre class="fragment">*          hEmif         Handle to the emif object
*   </pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - SDRAM self refresh mode enabled successfully </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and SDRAM configurations and should be called successfully</p>
<p><b> Post Condition </b> <br />
 SDRAM is in self refresh mode</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">           CSL_EmifObj            emifObj;
           CSL_Status             status;
           CSL_EmifConfig         emifCfg;
           CSL_EmifHandle         hEmif;

           status = EMIF_init(&amp;emifObj);
           hEmif  = &amp;emifObj;
           status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);
           ...
           ...
           ...
        status = SDRAM_enableSelfRefreshMode(hEmif);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0476c608cfefe33e54f0217be3ea01d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDRAM_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>numWords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>sdramAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>dataBuff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>SDRAM_read</b> </p>
<p><b>Description</b> <br />
 This API reads numWords from sdram.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        numWords      Number of words to be read
        sdramAddr     SDRAM address to start the read operation
        dataBuff      Data buffer to copy data read from SDRAM</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - SDRAM read is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid input parameters</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and SDRAM configurations should be called successfully</p>
<p><b> Post Condition </b> <br />
 Reads from sdram memory</p>
<p><b>Modifies</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj            emifObj;
        CSL_Status             status;
        CSL_EmifConfig         emifCfg;
        CSL_EmifHandle         hEmif;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);
        ...
        ...
        ...
        status = SDRAM_read(hEmif, numWords, sdramAddr, &amp;dataBuff);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga19525f14b676381f9dec25a07e48072c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status SDRAM_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_m_i_f___d_a_t_a_s_t_r_u_c_t.html#ga77df45cbecb96db4dbcd55f04d03ce07">CSL_EmifHandle</a>&#160;</td>
          <td class="paramname"><em>hEmif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>numWords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>sdramAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>dataBuff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>SDRAM_write</b> </p>
<p><b>Description</b> <br />
 This API writes numWords to sdram.</p>
<p><b>Arguments</b> </p><pre class="fragment">        hEmif         Handle to the emif object
        numWords      Number of words to be written
        sdramAddr     SDRAM address to start the write operation
        dataBuff      Data to be written to SDRAM</pre><p><b> Return Value </b> CSL_Status </p><ul>
<li>CSL_SOK - SDRAM write is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid config structure</li>
</ul>
<p><b> Pre Condition </b> <br />
 Emif init and SDRAM configurations should be called successfully</p>
<p><b> Post Condition </b> <br />
 Writes into sdram memory</p>
<p><b>Modifies</b> <br />
 sdram memory content</p>
<p><b>Example</b> </p><pre class="fragment">        CSL_EmifObj            emifObj;
        CSL_Status             status;
        CSL_EmifConfig         emifCfg;
        CSL_EmifHandle         hEmif;

        status = EMIF_init(&amp;emifObj);
        hEmif  = &amp;emifObj;
        status = SDRAM_config(hEmif, &amp;sdramConfig, &amp;sdramTimr);
        ...
        ...
        ...
        status = SDRAM_write(hEmif, numWords, sdramAddr, &amp;dataBuff);</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>

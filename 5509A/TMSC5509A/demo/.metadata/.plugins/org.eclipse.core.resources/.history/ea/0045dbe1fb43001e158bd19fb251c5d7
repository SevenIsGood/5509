/****************************************************************************/
/*                                                                          */
/*              离散余弦变换测试                                            */
/*                                                                          */
/*              2014年07月27日                                              */
/*                                                                          */
/****************************************************************************/
// 离散余弦变换类似于离散傅里叶变换，不过离散余弦变换只适用于实数
// 图像的离散余弦变换是 JPEG 压缩的核心部分

#include <stdio.h>                  // C 语言标准输入输出函数库
#include <math.h>                   // C 数学函数库
#include <csl.h>
#include <csl_pll.h>
#include <csl_chiphal.h>
#include "Dct.h"                    // DSP 图像函数库
#include "Pic.h"
/****************************************************************************/
/*                                                                          */
/*              宏定义                                                      */
/*                                                                          */
/****************************************************************************/
// 离散余弦变换测试
#define IMAGEWIDTH 			80
#define IMAGEHEIGHT 		80


// 离散余弦变换
// π 及 浮点数极小值
#define PI                3.14159
#define F_TOL             (1e-06)

// 8*8 方块个数
#define Block_Num         (IMAGEWIDTH*IMAGEHEIGHT/8/8)

/****************************************************************************/
/*                                                                          */
/*              全局变量                                                    */
/*                                                                          */
/****************************************************************************/


// 输入缓存
#pragma DATA_SECTION(IMG_In, ".image");
unsigned short IMG_In[ IMAGEWIDTH*IMAGEHEIGHT ];
// 输出
#pragma DATA_SECTION(IMG_In, ".image");
unsigned short IMG_Out[ IMAGEWIDTH*IMAGEHEIGHT ];
// 红色缓存
#pragma DATA_SECTION(IMG_In, ".image");
unsigned short RED_Buf[ IMAGEWIDTH*IMAGEHEIGHT ];
// 绿色缓存
#pragma DATA_SECTION(IMG_In, ".image");
unsigned short GREEN_Buf[ IMAGEWIDTH*IMAGEHEIGHT ];
// 蓝色缓存
#pragma DATA_SECTION(IMG_In, ".image");
unsigned short BLUE_Buf[ IMAGEWIDTH*IMAGEHEIGHT ];



extern const unsigned char gImage[12808];

/****************************************************************************/
/*                                                                          */
/*              函数声明                                                    */
/*                                                                          */
/****************************************************************************/
void SDRAM_init(void);
// 读取图片数组
void Read_IMG(unsigned char *pImage,int nWidth,int nHeight);
// 颜色分离
void Color_Div(void);
// DCT 变换
void DCT(void);
// IDCT 变换
void IDCT(void);
// 图像还原
void Comb_IMG(void);

/****************************************************************************/
/*                                                                          */
/*              主函数                                                      */
/*                                                                          */
/****************************************************************************/
int main(void)
{
	/*锁相环的设置*/
	PLL_Config  myConfig	  = {
		0, 	//IAI: the PLL locks using the same process that was underway
			//before the idle mode was entered
		1, 	//IOB: If the PLL indicates a break in the phase lock,
			//it switches to its bypass mode and restarts the PLL phase-locking
			//sequence
		24, //PLL multiply value; multiply 24 times
		1 	//Divide by 2 PLL divide value; it can be either PLL divide value
			//(when PLL is enabled), or Bypass-mode divide value
			//(PLL in bypass mode, if PLL multiply value is set to 1)
	};

	CSL_init();

	/*设置系统的运行速度为144MHz*/
	PLL_config(&myConfig);

	SDRAM_init();

	//读取图片数组
	Read_IMG((unsigned char *)gImage, IMAGEWIDTH, IMAGEHEIGHT);

	//颜色分离
	Color_Div();

	//DCT变换
	//DCT();

	//IDCT变换
	//IDCT();

	//图像还原
	Comb_IMG();

	return 0;
}

/****************************************************************************/
/*                                                                          */
/*              函数                                                                                                                                                                            */
/*                                                                          */
/****************************************************************************/
// 读取图片数组
void Read_IMG(unsigned char *pImage,int nWidth,int nHeight)
{
	unsigned short i,j;

	printf("正在读取图像...\n");

	// 复制图像数组
	for( i=0; i<nHeight; i++ )
		for( j=0; j<nWidth; j++ )
		{
			IMG_In[i*nWidth+j ] = ((unsigned short)(*(pImage+1))<<8)+(*pImage);
			IMG_Out[i*nWidth+j ] = IMG_In[i*nWidth+j ] ;
			pImage +=2;
		}

	printf("图像读取完成!\n");
}



// 颜色分离
void Color_Div(void)
{
	unsigned short i,j;

	printf("正在分离颜色...\n");

	// RGB565
	for( i=0; i<IMAGEHEIGHT; i++ )
		for( j=0; j<IMAGEWIDTH; j++ )
		{
			RED_Buf[ i*IMAGEWIDTH+j ]   = ( IMG_In[ i*IMAGEWIDTH+j ] & 0xF800 ) >> 11;
			GREEN_Buf[ i*IMAGEWIDTH+j ] = ( IMG_In[ i*IMAGEWIDTH+j ] & 0x07E0 ) >> 5;
			BLUE_Buf[ i*IMAGEWIDTH+j ]  = ( IMG_In[ i*IMAGEWIDTH+j ] & 0x001F );
		}

	printf("颜色已分离!\n");
}

// DCT 变换
void DCT(void)
{
	printf("正在进行DCT变换...\n");

	// DCT 变换
	IMG_fdct_8x8( RED_Buf,   Block_Num );
	IMG_fdct_8x8( GREEN_Buf, Block_Num );
	IMG_fdct_8x8( BLUE_Buf,  Block_Num );

	printf("DCT变换已完成!\n");
}

// IDCT 变换
void IDCT(void)
{
	unsigned short i,j;

	printf("正在进行IDCT变换...\n");

	// 转换成 12Q4 格式
	for( i=0; i<IMAGEHEIGHT; i++ )
			for( j=0; j<IMAGEWIDTH; j++ )
			{
				RED_Buf[ i*IMAGEWIDTH+j ]   <<= 4;
				GREEN_Buf[ i*IMAGEWIDTH+j ] <<= 4;
				BLUE_Buf[ i*IMAGEWIDTH+j ]  <<= 4;
			}

	// IDCT 变换
	IMG_idct_8x8_12q4(RED_Buf,   Block_Num );
	IMG_idct_8x8_12q4(GREEN_Buf, Block_Num );
	IMG_idct_8x8_12q4(BLUE_Buf,  Block_Num );

	printf("IDCT变换已完成！\n");
}

// 图像还原
void Comb_IMG(void)
{
	unsigned short i,j;

	printf("正在还原图像...\n");

	// 颜色分量截取
	for( i=0; i<IMAGEHEIGHT; i++ )
		for( j=0; j<IMAGEWIDTH; j++ )
		{
			if( RED_Buf[ i*IMAGEWIDTH+j ] < 0 )
				RED_Buf[ i*IMAGEWIDTH+j ] = 0;
			else if( RED_Buf[ i*IMAGEWIDTH+j ] >31 )
				RED_Buf[ i*IMAGEWIDTH+j ] = 31;

			if( GREEN_Buf[ i*IMAGEWIDTH+j ] < 0 )
				GREEN_Buf[ i*IMAGEWIDTH+j ] = 0;
			else if( GREEN_Buf[ i*IMAGEWIDTH+j ] >63 )
				GREEN_Buf[ i*IMAGEWIDTH+j ] = 63;

			if( BLUE_Buf[ i*IMAGEWIDTH+j ] < 0 )
				BLUE_Buf[ i*IMAGEWIDTH+j ] = 0;
			else if( BLUE_Buf[ i*IMAGEWIDTH+j ] >31 )
				BLUE_Buf[ i*IMAGEWIDTH+j ] = 31;
			// 合并颜色分量
			IMG_Out[ i*IMAGEWIDTH+j ] = IMG_In[ i*IMAGEWIDTH+j ];//( RED_Buf[ i*IMAGEWIDTH+j ] << 11 ) | ( GREEN_Buf[ i*IMAGEWIDTH+j ] << 5 ) | BLUE_Buf[ i*IMAGEWIDTH+j ];
		}

	printf("图像已还原!\n");
}

void SDRAM_init(void)
{
    ioport unsigned int *ebsr  =(unsigned int *)0x6c00;
    ioport unsigned int *egcr  =(unsigned int *)0x800;
    ioport unsigned int *emirst=(unsigned int *)0x801;
    //ioport unsigned int *emibe =(unsigned int *)0x802;
    ioport unsigned int *ce01  =(unsigned int *)0x803;
    //ioport unsigned int *ce02  =(unsigned int *)0x804;
    //ioport unsigned int *ce03  =(unsigned int *)0x805;
    ioport unsigned int *ce11  =(unsigned int *)0x806;
    //ioport unsigned int *ce12  =(unsigned int *)0x807;
    //ioport unsigned int *ce13  =(unsigned int *)0x808;
    ioport unsigned int *ce21  =(unsigned int *)0x809;
    //ioport unsigned int *ce22  =(unsigned int *)0x80A;
    //ioport unsigned int *ce23  =(unsigned int *)0x80B;
    ioport unsigned int *ce31  =(unsigned int *)0x80C;
    //ioport unsigned int *ce32  =(unsigned int *)0x80D;
    //ioport unsigned int *ce33  =(unsigned int *)0x80E;
    ioport unsigned int *sdc1  =(unsigned int *)0x80F;
    //ioport unsigned int *sdper =(unsigned int *)0x810;
    //ioport unsigned int *sdcnt =(unsigned int *)0x811;
    ioport unsigned int *init  =(unsigned int *)0x812;
    ioport unsigned int *sdc2  =(unsigned int *)0x813;
    //*ebsr   = 0x221;//0xa01
    *ebsr   = 0xa01;
    *egcr   = 0x220;
    *egcr   = 0X220;
    *ce01   = 0X3000;
    *ce11   = 0X1fff;
    *ce21   = 0x1fff;
    *ce31   = 0x1fff;
    *emirst = 0;
    *sdc1   = 0X5958;
    *sdc2   = 0X38F;
    *init   = 0;
}


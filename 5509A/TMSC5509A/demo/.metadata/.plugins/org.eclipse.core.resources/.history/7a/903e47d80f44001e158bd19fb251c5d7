#include "math.h"
#include "Dct.h"

void IMG_fdct_8x8(short *dct_data, unsigned num_fdcts)
{
    /* -------------------------------------------------------------------- */
    /*  Set up the cosine coefficients.                                     */
    /* -------------------------------------------------------------------- */
    const unsigned short c1 = 0x1F62, c3 = 0x1A9B;      /* Q13   coeffs     */
    const unsigned short c5 = 0x11C7, c7 = 0x063E;      /* Q13   coeffs     */
    const unsigned short c2 = 0x29CF, c6 = 0x1151;      /* Q13.5 coeffs     */
    const unsigned short C1 = 0xFB15, C3 = 0xD4DB;      /* Q16   coeffs     */
    const unsigned short C5 = 0x8E3A, C7 = 0x31F1;      /* Q16   coeffs     */
    const unsigned short C2 = 0xA73D, C6 = 0x4546;      /* Q15.5 coeffs     */
    const unsigned short C4 = 0xB505;                   /* Q16   coeff      */

    /* -------------------------------------------------------------------- */
    /*  Intermediate calculations.                                          */
    /* -------------------------------------------------------------------- */
    short f0, f1, f2, f3, f4, f5, f6, f7;   /* Spatial domain samples.      */
    short g0, g1, h0, h1, p0, p1;           /* Even-half intermediate.      */
    short r0, r1, r0_,r1_;                  /* Even-half intermediate.      */
    short P0, P1, R0, R1;                   /* Even-half intermediate.      */
    short g2, g3, h2, h3;                   /* Odd-half intermediate.       */
    short q1a,s1a,q0, q1, s0, s1;           /* Odd-half intermediate.       */
    short Q0, Q1, S0, S1;                   /* Odd-half intermediate.       */
    short F0, F1, F2, F3, F4, F5, F6, F7;   /* Freq. domain results.        */

    /* -------------------------------------------------------------------- */
    /*  Input and output pointers, loop control.                            */
    /* -------------------------------------------------------------------- */
    unsigned i, j;
    short (*dct)[8][8] = (short (*)[8][8])dct_data;

    if (!num_fdcts) return;

    /* -------------------------------------------------------------------- */
    /*  Outer vertical loop -- Process each 8x8 block.                      */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < num_fdcts; i++)
    {
        /* ---------------------------------------------------------------- */
        /*  Perform Vertical 1-D FDCT on columns within each block.         */
        /* ---------------------------------------------------------------- */
        for (j = 0; j < 8; j++)
        {
            /* ------------------------------------------------------------ */
            /*  Load the spatial-domain samples.                            */
            /*  The incoming terms start at Q0 precision.                   */
            /* ------------------------------------------------------------ */
            f0 = dct[i][0][j];
            f1 = dct[i][1][j];
            f2 = dct[i][2][j];
            f3 = dct[i][3][j];
            f4 = dct[i][4][j];
            f5 = dct[i][5][j];
            f6 = dct[i][6][j];
            f7 = dct[i][7][j];

            /* ------------------------------------------------------------ */
            /*  Stage 1:  Separate into even and odd halves.                */
            /*                                                              */
            /*  The results of this stage are implicitly in Q1, since we    */
            /*  do not explicitly multiply by 0.5.                          */
            /* ------------------------------------------------------------ */
            g0 = f0 + f7;               g1 = f1 + f6;   /* Results in Q1    */
            h1 = f2 + f5;               h0 = f3 + f4;   /* Results in Q1    */
            g3 = f2 - f5;               g2 = f3 - f4;   /* Results in Q1    */
            h2 = f0 - f7;               h3 = f1 - f6;   /* Results in Q1    */

            /* ------------------------------------------------------------ */
            /*  Stage 2                                                     */
            /*                                                              */
            /*  Note, on the odd-half, the results are in Q1.5 since those  */
            /*  values are scaled upwards by sqrt(2) at this point.         */
            /* ------------------------------------------------------------ */
            p0 = g0 + h0;               r0 = g0 - h0;   /* Results in Q1    */
            p1 = g1 + h1;               r1 = g1 - h1;   /* Results in Q1    */

            q1a = g2 + g2;                              /* q1a is now Q2    */
            s1a = h2 + h2;                              /* s1a is now Q2    */
            q1  = ((int)q1a * C4 + 0x8000) >> 16;            /* Results in Q1.5  */
            s1  = ((int)s1a * C4 + 0x8000) >> 16;            /* Results in Q1.5  */

            s0 = h3 + g3;                               /* Results in Q1.5  */
            q0 = h3 - g3;                               /* Results in Q1.5  */

            /* ------------------------------------------------------------ */
            /*  Stage 3                                                     */
            /*                                                              */
            /*  Now, the even-half ends up in Q1.5.  On P0 and P1, this     */
            /*  happens because the multiply-by-C4 was canceled with an     */
            /*  upward scaling by sqrt(2).  On R0 and R1, this happens      */
            /*  because C2 and C6 are at Q15.5, and we scale r0 and r1 to   */
            /*  Q2 before we multiply.                                      */
            /* ------------------------------------------------------------ */
            P0 = p0 + p1;                               /* Results in Q1.5  */
            P1 = p0 - p1;                               /* Results in Q1.5  */

            r0_= r0 + r0;                               /* r0_ is now Q2    */
            r1_= r1 + r1;                               /* r1_ is now Q2    */
            R1 = (C6 * r1_+ C2 * r0_+ 0x8000) >> 16;    /* Results in Q1.5  */
            R0 = (C6 * r0_- C2 * r1_+ 0x8000) >> 16;    /* Results in Q1.5  */

            Q1 = q1 + q0;               Q0 = q1 - q0;
            S1 = s1 + s0;               S0 = s1 - s0;

            /* ------------------------------------------------------------ */
            /*  Stage 4                                                     */
            /*  No further changes in Q-point happen here.                  */
            /* ------------------------------------------------------------ */
            F0 = P0;                    F4 = P1;
            F2 = R1;                    F6 = R0;

            F1 = (C7 * Q1 + C1 * S1 + 0x8000) >> 16;    /* Results in Q1.5  */
            F7 = (C7 * S1 - C1 * Q1 + 0x8000) >> 16;    /* Results in Q1.5  */
            F5 = (C3 * Q0 + C5 * S0 + 0x8000) >> 16;    /* Results in Q1.5  */
            F3 = (C3 * S0 - C5 * Q0 + 0x8000) >> 16;    /* Results in Q1.5  */

            /* ------------------------------------------------------------ */
            /*  Store the frequency domain results.                         */
            /*  These values are all at Q1.5 precision.                     */
            /* ------------------------------------------------------------ */
            dct[i][0][j] = F0;
            dct[i][1][j] = F1;
            dct[i][2][j] = F2;
            dct[i][3][j] = F3;
            dct[i][4][j] = F4;
            dct[i][5][j] = F5;
            dct[i][6][j] = F6;
            dct[i][7][j] = F7;
        }
    }

    /* -------------------------------------------------------------------- */
    /*  Perform Horizontal 1-D FDCT on each 8x8 block.                      */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < num_fdcts; i++)
    {
        /* ---------------------------------------------------------------- */
        /*  Perform Vertical 1-D FDCT on columns within each block.         */
        /* ---------------------------------------------------------------- */
        for (j = 0; j < 8; j++)
        {
            /* ------------------------------------------------------------ */
            /*  Load the spatial-domain samples.                            */
            /*  The incoming terms are at Q1.5 precision from first pass.   */
            /* ------------------------------------------------------------ */
            f0 = dct[i][j][0];
            f1 = dct[i][j][1];
            f2 = dct[i][j][2];
            f3 = dct[i][j][3];
            f4 = dct[i][j][4];
            f5 = dct[i][j][5];
            f6 = dct[i][j][6];
            f7 = dct[i][j][7];

            /* ------------------------------------------------------------ */
            /*  Stage 1:  Separate into even and odd halves.                */
            /*                                                              */
            /*  The results of this stage are implicitly in Q2.5, since we  */
            /*  do not explicitly multiply by 0.5.                          */
            /* ------------------------------------------------------------ */
            g0 = f0 + f7;               g1 = f1 + f6;   /* Results in Q2.5  */
            h1 = f2 + f5;               h0 = f3 + f4;   /* Results in Q2.5  */
            h2 = f0 - f7;               h3 = f1 - f6;   /* Results in Q2.5  */
            g3 = f2 - f5;               g2 = f3 - f4;   /* Results in Q2.5  */

            /* ------------------------------------------------------------ */
            /*  Stage 2                                                     */
            /*                                                              */
            /*  Note, on the odd-half, the results are in Q3 since those    */
            /*  values are scaled upwards by sqrt(2) at this point.  The    */
            /*  order of operations differs in this pass as compared to     */
            /*  the first due to overflow concerns.                         */
            /*                                                              */
            /*  We also inject a rounding term into the DC term which will  */
            /*  also round the Nyquist term, F4.  This trick works despite  */
            /*  the fact that we are technically still at Q2.5 here, since  */
            /*  the step from Q2.5 to Q3 later is done implicitly, rather   */
            /*  than with a multiply.  (This is due to the sqrt(2) terms    */
            /*  cancelling on the P0/P1 butterfly.)                         */
            /* ------------------------------------------------------------ */
            p0 = g0 + h0 + 4;           p1 = g1 + h1;   /* Results in Q2.5  */
            r0 = g0 - h0;               r1 = g1 - h1;   /* Results in Q2.5  */

            q1a= (g2 * C4 + 0x8000) >> 16;              /* q1a now in Q2    */
            s1a= (h2 * C4 + 0x8000) >> 16;              /* s1a now in Q2    */
            q1 = q1a + q1a;                             /* Results in Q3    */
            s1 = s1a + s1a;                             /* Results in Q3    */

            s0 = h3 + g3;                               /* Results in Q3    */
            q0 = h3 - g3;                               /* Results in Q3    */

            /* ------------------------------------------------------------ */
            /*  Stage 3                                                     */
            /*                                                              */
            /*  Now, the even-half ends up in Q0.  This happens on P0 and   */
            /*  P1 because the multiply-by-c4 was canceled with an upward   */
            /*  scaling by sqrt(2), yielding Q3 intermediate value.  The    */
            /*  final >> 3 leaves these at Q0.  On R0 and R1, this happens  */
            /*  because c2 and c6 are at Q13.5, giving a Q16 intermediate   */
            /*  value.  The final >> 16 then leaves those values at Q0.     */
            /* ------------------------------------------------------------ */
            P0 = ((short)(p0 + p1)) >> 3;               /* Results in Q0    */
            P1 = ((short)(p0 - p1)) >> 3;               /* Results in Q0    */
            R1 = (c6 * r1 + c2 * r0 + 0x8000) >> 16;    /* Results in Q0    */
            R0 = (c6 * r0 - c2 * r1 + 0x8000) >> 16;    /* Results in Q0    */

            Q1 = q1 + q0;               Q0 = q1 - q0;   /* Results in Q3    */
            S1 = s1 + s0;               S0 = s1 - s0;   /* Results in Q3    */

            /* ------------------------------------------------------------ */
            /*  Stage 4                                                     */
            /*                                                              */
            /*  Next, the odd-half ends up in Q0.  This happens because     */
            /*  our values are in Q3 and our cosine terms are in Q13,       */
            /*  giving us Q16 intermediate values. The final >> 16 leaves   */
            /*  us a Q0 result.                                             */
            /* ------------------------------------------------------------ */
            F0 = P0;                    F4 = P1;
            F2 = R1;                    F6 = R0;

            F1 = (c7 * Q1 + c1 * S1 + 0x8000) >> 16;    /* Results in Q0    */
            F7 = (c7 * S1 - c1 * Q1 + 0x8000) >> 16;    /* Results in Q0    */
            F5 = (c3 * Q0 + c5 * S0 + 0x8000) >> 16;    /* Results in Q0    */
            F3 = (c3 * S0 - c5 * Q0 + 0x8000) >> 16;    /* Results in Q0    */

            /* ------------------------------------------------------------ */
            /*  Store the results                                           */
            /* ------------------------------------------------------------ */
            dct[i][j][0] = F0;
            dct[i][j][1] = F1;
            dct[i][j][2] = F2;
            dct[i][j][3] = F3;
            dct[i][j][4] = F4;
            dct[i][j][5] = F5;
            dct[i][j][6] = F6;
            dct[i][j][7] = F7;
        }
    }

    return;
}

void IMG_idct_8x8_12q4(short *idct_data, unsigned num_idcts)
{
    /* -------------------------------------------------------------------- */
    /*  Cosine Constants (Q16, scaled down by sqrt(2)).                     */
    /* -------------------------------------------------------------------- */
    const unsigned short C0 = 0xB505;
    const unsigned short C1 = 0xB18B, C2 = 0xA73D;
    const unsigned short C3 = 0x9683, C5 = 0x6492;
    const unsigned short C6 = 0x4546, C7 = 0x2351;

    /* -------------------------------------------------------------------- */
    /*  Intermediate values (used in both loops).                           */
    /* -------------------------------------------------------------------- */
    short F0, F1, F2, F3, F4, F5, F6, F7;  /* stage 0        */
    short P0, P1, R0, R1, Q0, Q1, S0, S1;  /* stage 1        */
    short p0, p1, r0, r1, q0, q1, s0, s1;  /* stage 2        */
    short g0, g1, g2, g3, h0, h1, h2, h3;  /* stage 3        */
    short f0, f1, f2, f3, f4, f5, f6, f7;  /* stage 4        */
    short f0r,f1r,f2r,f3r,f4r,f5r,f6r,f7r; /* rounded        */
    int   f0s,f1s,f2s,f3s,f4s,f5s,f6s,f7s; /* saturated      */
    int   f0t,f1t,f2t,f3t,f4t,f5t,f6t,f7t; /* truncated      */
    int   i, j;                            /* loop counts    */
    short (*idct)[8][8] = (short (*)[8][8])idct_data;

    if (!num_idcts) return;

    /* -------------------------------------------------------------------- */
    /*  Vertical Pass                                                       */
    /*                                                                      */
    /*  This pass performs a single 8-pt IDCT per iteration.  Inputs        */
    /*  are in 12Q4 format, and results of this pass are in 11Q5            */
    /*  format. (Actually, the results are halfway between 11Q5 and         */
    /*  12Q4 due to the scaling by sqrt(2).)                                */
    /*                                                                      */
    /*  The outer loop steps between IDCT blocks, whereas the inner         */
    /*  loop focuses on columns within each IDCT block.                     */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < num_idcts; i++)
    {
        for (j = 0; j < 8; j++)
        {
            /* ------------------------------------------------------------ */
            /*  Stage 0:  Load in frequency-domain coefficients.            */
            /* ------------------------------------------------------------ */
            F0 = idct[i][0][j];
            F1 = idct[i][1][j];
            F2 = idct[i][2][j];
            F3 = idct[i][3][j];
            F4 = idct[i][4][j];
            F5 = idct[i][5][j];
            F6 = idct[i][6][j];
            F7 = idct[i][7][j];

            /* ------------------------------------------------------------ */
            /*  Stage 1 of signal flow graph.                               */
            /* ------------------------------------------------------------ */
            P0 = F0;                P1 = F4;
            R1 = F2;                R0 = F6;

            Q1 = (F1*C7 - F7*C1 + 0x8000) >> 16;
            Q0 = (F5*C3 - F3*C5 + 0x8000) >> 16;
            S0 = (F5*C5 + F3*C3 + 0x8000) >> 16;
            S1 = (F1*C1 + F7*C7 + 0x8000) >> 16;

            /* ------------------------------------------------------------ */
            /*  Stage 2 of signal flow graph.                               */
            /* ------------------------------------------------------------ */
            p0 = ((int)P0 + (int)P1 + 1 ) >> 1;
            p1 = ((int)P0 - (int)P1     ) >> 1;
            r1 = (R1*C6 - R0*C2 + 0x8000) >> 16;
            r0 = (R1*C2 + R0*C6 + 0x8000) >> 16;

            s1 = (S1 + S0);         q1 = (Q1 + Q0);
            s0 = (S1 - S0);         q0 = (Q1 - Q0);

            /* ------------------------------------------------------------ */
            /*  Stage 3 of signal flow graph.                               */
            /* ------------------------------------------------------------ */
            g0 = (p0 + r0);         g1 = (p1 + r1);
            h0 = (p0 - r0);         h1 = (p1 - r1);

            h2 = s1;                g2 = q1;
            g3 = (s0*C0 - q0*C0 + 0x8000) >> 16;
            h3 = (s0*C0 + q0*C0 + 0x8000) >> 16;

            /* ------------------------------------------------------------ */
            /*  Stage 4 of signal flow graph.                               */
            /* ------------------------------------------------------------ */
            f0 = (g0 + h2);         f7 = (g0 - h2);
            f1 = (g1 + h3);         f6 = (g1 - h3);
            f2 = (h1 + g3);         f5 = (h1 - g3);
            f3 = (h0 + g2);         f4 = (h0 - g2);

            /* ------------------------------------------------------------ */
            /*  Stage 5:  Write sample-domain results.                      */
            /* ------------------------------------------------------------ */
            idct[i][0][j] = f0;
            idct[i][1][j] = f1;
            idct[i][2][j] = f2;
            idct[i][3][j] = f3;
            idct[i][4][j] = f4;
            idct[i][5][j] = f5;
            idct[i][6][j] = f6;
            idct[i][7][j] = f7;
        }
    }

    /* -------------------------------------------------------------------- */
    /*  Horizontal Pass                                                     */
    /*                                                                      */
    /*  This performs one IDCT per iteration on the 11Q5 results from       */
    /*  the previous pass.  Both horizontal and vertical passes are         */
    /*  scaled down by sqrt(2) -- the net effect of which is that the       */
    /*  IDCT results generated by this pass (prior to saturation) are       */
    /*  also 11Q5 results, only with no sqrt(2) factors remaining.          */
    /*                                                                      */
    /*  The IDCT butterflies in this pass are identical to the ones in      */
    /*  the vertical pass, except for an additional rounding value          */
    /*  which is added into the DC term early in the flow graph.            */
    /*                                                                      */
    /*  The 11Q5 sample-domain terms are saturated to 9Q7 values, and       */
    /*  then truncated to 9Q0 results before storing.                       */
    /*                                                                      */
    /*  The outer loop steps between IDCT blocks, whereas the inner         */
    /*  loop focuses on rows within each IDCT block.                        */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < num_idcts; i++)
    {
        for (j = 0; j < 8; j++)
        {
            /* ------------------------------------------------------------ */
            /*  Stage 0:  Load in frequency-domain coefficients.            */
            /* ------------------------------------------------------------ */
            F0 = idct[i][j][0];
            F1 = idct[i][j][1];
            F2 = idct[i][j][2];
            F3 = idct[i][j][3];
            F4 = idct[i][j][4];
            F5 = idct[i][j][5];
            F6 = idct[i][j][6];
            F7 = idct[i][j][7];

            /* ------------------------------------------------------------ */
            /*  Stage 1 of signal flow graph.                               */
            /* ------------------------------------------------------------ */
            P0 = F0;                P1 = F4;
            R1 = F2;                R0 = F6;

            Q1 = (F1*C7 - F7*C1 + 0x8000) >> 16;
            Q0 = (F5*C3 - F3*C5 + 0x8000) >> 16;
            S0 = (F5*C5 + F3*C3 + 0x8000) >> 16;
            S1 = (F1*C1 + F7*C7 + 0x8000) >> 16;

            /* ------------------------------------------------------------ */
            /*  Stage 2 of signal flow graph.                               */
            /* ------------------------------------------------------------ */
            p0 = (((int)P0 + (int)P1 + 1) >> 1) + 15;
            p1 = (((int)P0 - (int)P1    ) >> 1) + 16;
            r1 = (R1*C6 - R0*C2 + 0x8000) >> 16;
            r0 = (R1*C2 + R0*C6 + 0x8000) >> 16;

            s1 = (S1 + S0);         q1 = (Q1 + Q0);
            s0 = (S1 - S0);         q0 = (Q1 - Q0);

            /* ------------------------------------------------------------ */
            /*  Stage 3 of signal flow graph.                               */
            /* ------------------------------------------------------------ */
            g0 = (p0 + r0);         g1 = (p1 + r1);
            h0 = (p0 - r0);         h1 = (p1 - r1);

            h2 = s1;                g2 = q1;
            g3 = (s0*C0 - q0*C0 + 0x8000) >> 16;
            h3 = (s0*C0 + q0*C0 + 0x8000) >> 16;

            /* ------------------------------------------------------------ */
            /*  Stage 4 of signal flow graph.                               */
            /* ------------------------------------------------------------ */
            f0 = (g0 + h2);         f7 = (g0 - h2);
            f1 = (g1 + h3);         f6 = (g1 - h3);
            f2 = (h1 + g3);         f5 = (h1 - g3);
            f3 = (h0 + g2);         f4 = (h0 - g2);

            /* ------------------------------------------------------------ */
            /*  Stage 4.1:  Q-pt adjust: Bit 15 is a don't-care.            */
            /* ------------------------------------------------------------ */
            f0r = f0 + f0;          f7r = f7 + f7;
            f1r = f1 + f1;          f6r = f6 + f6;
            f2r = f2 + f2;          f5r = f5 + f5;
            f3r = f3 + f3;          f4r = f4 + f4;

            /* ------------------------------------------------------------ */
            /*  Stage 4.2:  Saturate results to 9Q6.                        */
            /* ------------------------------------------------------------ */
            f0s = f0r > 0x3FFF ? 0x3FFF : f0r < -0x4000 ? -0x4000 : f0r;
            f1s = f1r > 0x3FFF ? 0x3FFF : f1r < -0x4000 ? -0x4000 : f1r;
            f2s = f2r > 0x3FFF ? 0x3FFF : f2r < -0x4000 ? -0x4000 : f2r;
            f3s = f3r > 0x3FFF ? 0x3FFF : f3r < -0x4000 ? -0x4000 : f3r;
            f4s = f4r > 0x3FFF ? 0x3FFF : f4r < -0x4000 ? -0x4000 : f4r;
            f5s = f5r > 0x3FFF ? 0x3FFF : f5r < -0x4000 ? -0x4000 : f5r;
            f6s = f6r > 0x3FFF ? 0x3FFF : f6r < -0x4000 ? -0x4000 : f6r;
            f7s = f7r > 0x3FFF ? 0x3FFF : f7r < -0x4000 ? -0x4000 : f7r;

            /* ------------------------------------------------------------ */
            /*  Stage 4.3:  Truncate results to 9Q0.                        */
            /* ------------------------------------------------------------ */
            f0t = f0s >> 6;         f7t = f7s >> 6;
            f1t = f1s >> 6;         f6t = f6s >> 6;
            f2t = f2s >> 6;         f5t = f5s >> 6;
            f3t = f3s >> 6;         f4t = f4s >> 6;

            /* ------------------------------------------------------------ */
            /*  Stage 5:  Store sample-domain results.                      */
            /* ------------------------------------------------------------ */
            idct[i][j][0] = f0t;
            idct[i][j][1] = f1t;
            idct[i][j][2] = f2t;
            idct[i][j][3] = f3t;
            idct[i][j][4] = f4t;
            idct[i][j][5] = f5t;
            idct[i][j][6] = f6t;
            idct[i][j][7] = f7t;
        }
    }

    return;
}
